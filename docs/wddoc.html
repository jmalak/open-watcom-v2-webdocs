<HEAD>
<TITLE> Open Watcom 2.0 Debugger </TITLE>
</HEAD>
<BODY>
<H1 ID="Index_of_Topics"> Index of Topics </H1>
<DL>
<DT>- A -
<DD><A HREF="#Address_information_class">Address information class</A>
<BR><A HREF="#ARRAY_Lvalue_0x2_R">ARRAY (value 0x2?)</A>
<DT>- B -
<DD><A HREF="#Base_Types">Base Types</A>
<BR><A HREF="#Byte_Order">Byte Order</A>
<DT>- C -
<DD><A HREF="#CHARACTER_BLOCK_Lvalue_0x8_R">CHARACTER_BLOCK (value 0x8?)</A>
<BR><A HREF="#CODE_Lvalue_0x2_R">CODE (value 0x2?)</A>
<BR><A HREF="#Core_Requests">Core Requests</A>
<DT>- D -
<DD><A HREF="#Debugging_Information_Format">Debugging Information Format</A>
<DT>- E -
<DD><A HREF="#ENUMERATED_Lvalue_0x5_R">ENUMERATED (value 0x5?)</A>
<BR><A HREF="#Executable_file_structures">Executable file structures</A>
<DT>- F -
<DD><A HREF="#File_IDO_requests">File I/O requests</A>
<DT>- G -
<DD><A HREF="#GET_MOVED_SECTION">GET_MOVED_SECTION</A>
<BR><A HREF="#GET_OVERLAY_STATE">GET_OVERLAY_STATE</A>
<BR><A HREF="#GET_OVL_TBL_ADDR">GET_OVL_TBL_ADDR</A>
<BR><A HREF="#GET_SECTION_DATA">GET_SECTION_DATA</A>
<BR><A HREF="#GET_STATE_SIZE">GET_STATE_SIZE</A>
<BR><A HREF="#Global_symbols_class">Global symbols class</A>
<DT>- H -
<DD><A HREF="#The_Handler_Routine">The Handler Routine</A>
<BR><A HREF="#The_Hook_Routine">The Hook Routine</A>
<DT>- I -
<DD><A HREF="#The_Interface_Routines">The Interface Routines</A>
<DT>- L -
<DD><A HREF="#Line_number_information">Line number information</A>
<BR><A HREF="#Line_numbers_class">Line numbers class</A>
<BR><A HREF="#Local_symbol_information">Local symbol information</A>
<BR><A HREF="#Local_symbols_class">Local symbols class</A>
<BR><A HREF="#Location_information">Location information</A>
<DT>- M -
<DD><A HREF="#Master_debug_header">Master debug header</A>
<BR><A HREF="#Module_information_class">Module information class</A>
<DT>- N -
<DD><A HREF="#NEW_BASE_Lvalue_0x3_R">NEW_BASE (value 0x3?)</A>
<DT>- O -
<DD><A HREF="#Object_file_structures">Object file structures</A>
<BR><A HREF="#Overlay_manager_interface">Overlay manager interface</A>
<BR><A HREF="#Overlay_requests">Overlay requests</A>
<BR><A HREF="#Overlay_Table_Structure">Overlay Table Structure</A>
<DT>- P -
<DD><A HREF="#POINTER_Lvalue_0x4_R">POINTER (value 0x4?)</A>
<BR><A HREF="#Pointer_Sizes">Pointer Sizes</A>
<BR><A HREF="#PROCEDURE_Lvalue_0x7_R">PROCEDURE (value 0x7?)</A>
<DT>- R -
<DD><A HREF="#REQ_CHECKSUM_MEM_L8R">REQ_CHECKSUM_MEM (8)</A>
<BR><A HREF="#REQ_CLEAR_BREAK_L20R">REQ_CLEAR_BREAK (20)</A>
<BR><A HREF="#REQ_CLEAR_WATCH_L18R">REQ_CLEAR_WATCH (18)</A>
<BR><A HREF="#REQ_CONNECT_L0R">REQ_CONNECT (0)</A>
<BR><A HREF="#REQ_DISCONNECT_L1R">REQ_DISCONNECT (1)</A>
<BR><A HREF="#REQ_FILE_CLOSE_L6R">REQ_FILE_CLOSE (6)</A>
<BR><A HREF="#REQ_FILE_ERASE_L7R">REQ_FILE_ERASE (7)</A>
<BR><A HREF="#REQ_FILE_GET_CONFIG_L0R">REQ_FILE_GET_CONFIG (0)</A>
<BR><A HREF="#REQ_FILE_OPEN_L1R">REQ_FILE_OPEN (1)</A>
<BR><A HREF="#REQ_FILE_READ_L3R">REQ_FILE_READ (3)</A>
<BR><A HREF="#REQ_FILE_RUN_CMD_L9R">REQ_FILE_RUN_CMD (9)</A>
<BR><A HREF="#REQ_FILE_SEEK_L2R">REQ_FILE_SEEK (2)</A>
<BR><A HREF="#REQ_FILE_STRING_TO_FULLPATH_L8R">REQ_FILE_STRING_TO_FULLPATH (8)</A>
<BR><A HREF="#REQ_FILE_WRITE_L4R">REQ_FILE_WRITE (4)</A>
<BR><A HREF="#REQ_FILE_WRITE_CONSOLE_L5R">REQ_FILE_WRITE_CONSOLE (5)</A>
<BR><A HREF="#REQ_GET_ERR_TEXT_L26R">REQ_GET_ERR_TEXT (26)</A>
<BR><A HREF="#REQ_GET_LIB_NAME_L25R">REQ_GET_LIB_NAME (25)</A>
<BR><A HREF="#REQ_GET_MESSAGE_TEXT_L27R">REQ_GET_MESSAGE_TEXT (27)</A>
<BR><A HREF="#REQ_GET_NEXT_ALIAS_L21R">REQ_GET_NEXT_ALIAS (21)</A>
<BR><A HREF="#REQ_GET_SUPPLEMENTARY_SERVICE_L4R">REQ_GET_SUPPLEMENTARY_SERVICE (4)</A>
<BR><A HREF="#REQ_GET_SYS_CONFIG_L6R">REQ_GET_SYS_CONFIG (6)</A>
<BR><A HREF="#REQ_MACHINE_DATA_L33R">REQ_MACHINE_DATA (33)</A>
<BR><A HREF="#REQ_MAP_ADDR_L7R">REQ_MAP_ADDR (7)</A>
<BR><A HREF="#REQ_OVL_GET_DATA_L1R">REQ_OVL_GET_DATA (1)</A>
<BR><A HREF="#REQ_OVL_GET_REMAP_ENTRY_L6R">REQ_OVL_GET_REMAP_ENTRY (6)</A>
<BR><A HREF="#REQ_OVL_READ_STATE_L2R">REQ_OVL_READ_STATE (2)</A>
<BR><A HREF="#REQ_OVL_STATE_SIZE_L0R">REQ_OVL_STATE_SIZE (0)</A>
<BR><A HREF="#REQ_OVL_TRANS_RET_ADDR_L5R">REQ_OVL_TRANS_RET_ADDR (5)</A>
<BR><A HREF="#REQ_OVL_TRANS_VECT_ADDR_L4R">REQ_OVL_TRANS_VECT_ADDR (4)</A>
<BR><A HREF="#REQ_OVL_WRITE_STATE_L3R">REQ_OVL_WRITE_STATE (3)</A>
<BR><A HREF="#REQ_PERFORM_SUPPLEMENTARY_SERVICE_L5R">REQ_PERFORM_SUPPLEMENTARY_SERVICE (5)</A>
<BR><A HREF="#REQ_PROG_GO_L13RDREQ_PROG_STEP_L14R">REQ_PROG_GO (13)/REQ_PROG_STEP (14)</A>
<BR><A HREF="#REQ_PROG_KILL_L16R">REQ_PROG_KILL (16)</A>
<BR><A HREF="#REQ_PROG_LOAD_L15R">REQ_PROG_LOAD (15)</A>
<BR><A HREF="#REQ_READ_IO_L11R">REQ_READ_IO (11)</A>
<BR><A HREF="#REQ_READ_MEM_L9R">REQ_READ_MEM (9)</A>
<BR><A HREF="#REQ_READ_REGS_L31R">REQ_READ_REGS (31)</A>
<BR><A HREF="#REQ_READ_USER_KEYBOARD_L24R">REQ_READ_USER_KEYBOARD (24)</A>
<BR><A HREF="#REQ_REDIRECT_STDIN_L28RDREQ_REDIRECT_STDOUT_L29R">REQ_REDIRECT_STDIN (28)/REQ_REDIRECT_STDOUT (29)</A>
<BR><A HREF="#REQ_RESUME_L3R">REQ_RESUME (3)</A>
<BR><A HREF="#REQ_RFX_FINDCLOSE_L15R">REQ_RFX_FINDCLOSE (15)</A>
<BR><A HREF="#REQ_RFX_FINDFIRST_L13R">REQ_RFX_FINDFIRST (13)</A>
<BR><A HREF="#REQ_RFX_FINDNEXT_L14R">REQ_RFX_FINDNEXT (14)</A>
<BR><A HREF="#REQ_RFX_GETCWD_L6R">REQ_RFX_GETCWD (6)</A>
<BR><A HREF="#REQ_RFX_GETDATETIME_L8R">REQ_RFX_GETDATETIME (8)</A>
<BR><A HREF="#REQ_RFX_GETDRIVE_L4R">REQ_RFX_GETDRIVE (4)</A>
<BR><A HREF="#REQ_RFX_GETFILEATTR_L11R">REQ_RFX_GETFILEATTR (11)</A>
<BR><A HREF="#REQ_RFX_GETFREESPACE_L9R">REQ_RFX_GETFREESPACE (9)</A>
<BR><A HREF="#REQ_RFX_MKDIR_L1R">REQ_RFX_MKDIR (1)</A>
<BR><A HREF="#REQ_RFX_NAMETOCANONICAL_L12R">REQ_RFX_NAMETOCANONICAL (12)</A>
<BR><A HREF="#REQ_RFX_RENAME_L0R">REQ_RFX_RENAME (0)</A>
<BR><A HREF="#REQ_RFX_RMDIR_L2R">REQ_RFX_RMDIR (2)</A>
<BR><A HREF="#REQ_RFX_SETCWD_L5R">REQ_RFX_SETCWD (5)</A>
<BR><A HREF="#REQ_RFX_SETDATETIME_L7R">REQ_RFX_SETDATETIME (7)</A>
<BR><A HREF="#REQ_RFX_SETDRIVE_L3R">REQ_RFX_SETDRIVE (3)</A>
<BR><A HREF="#REQ_RFX_SETFILEATTR_L10R">REQ_RFX_SETFILEATTR (10)</A>
<BR><A HREF="#REQ_SET_BREAK_L19R">REQ_SET_BREAK (19)</A>
<BR><A HREF="#REQ_SET_DEBUG_SCREEN_L23R">REQ_SET_DEBUG_SCREEN (23)</A>
<BR><A HREF="#REQ_SET_USER_SCREEN_L22R">REQ_SET_USER_SCREEN (22)</A>
<BR><A HREF="#REQ_SET_WATCH_L17R">REQ_SET_WATCH (17)</A>
<BR><A HREF="#REQ_SPLIT_CMD_L30R">REQ_SPLIT_CMD (30)</A>
<BR><A HREF="#REQ_SUSPEND_L2R">REQ_SUSPEND (2)</A>
<BR><A HREF="#REQ_THREAD_FREEZE_L2R">REQ_THREAD_FREEZE (2)</A>
<BR><A HREF="#REQ_THREAD_GET_EXTRA_L4R">REQ_THREAD_GET_EXTRA (4)</A>
<BR><A HREF="#REQ_THREAD_GET_NEXT_L0R">REQ_THREAD_GET_NEXT (0)</A>
<BR><A HREF="#REQ_THREAD_SET_L1R">REQ_THREAD_SET (1)</A>
<BR><A HREF="#REQ_THREAD_THAW_L3R">REQ_THREAD_THAW (3)</A>
<BR><A HREF="#REQ_WRITE_IO_L12R">REQ_WRITE_IO (12)</A>
<BR><A HREF="#REQ_WRITE_MEM_L10R">REQ_WRITE_MEM (10)</A>
<BR><A HREF="#REQ_WRITE_REGS_L32R">REQ_WRITE_REGS (32)</A>
<BR><A HREF="#Request_Example">Request Example</A>
<BR><A HREF="#The_Request_Interface">The Request Interface</A>
<BR><A HREF="#Request_Structure_">Request Structure.</A>
<BR><A HREF="#The_Requests">The Requests</A>
<BR><A HREF="#RFX_requests">RFX requests</A>
<DT>- S -
<DD><A HREF="#Section_debug_header">Section debug header</A>
<BR><A HREF="#Section_debug_information">Section debug information</A>
<BR><A HREF="#Segment_address_table">Segment address table</A>
<BR><A HREF="#SET_OVERLAY_STATE">SET_OVERLAY_STATE</A>
<BR><A HREF="#Some_Definitions">Some Definitions</A>
<BR><A HREF="#Source_language_table">Source language table</A>
<BR><A HREF="#Special_Line_Number_Table">Special Line Number Table</A>
<BR><A HREF="#STRUCTURE_Lvalue_0x6_R">STRUCTURE (value 0x6?)</A>
<BR><A HREF="#SUBRANGE_Lvalue_0x3_R">SUBRANGE (value 0x3?)</A>
<BR><A HREF="#System_Dependent_Aspects">System Dependent Aspects</A>
<DT>- T -
<DD><A HREF="#Thread_requests">Thread requests</A>
<BR><A HREF="#TRANSLATE_RETURN_ADDR">TRANSLATE_RETURN_ADDR</A>
<BR><A HREF="#TRANSLATE_VECTOR_ADDR">TRANSLATE_VECTOR_ADDR</A>
<BR><A HREF="#Trap_File_Interface">Trap File Interface</A>
<BR><A HREF="#Trap_Files_Under_DOS">Trap Files Under DOS</A>
<BR><A HREF="#Trap_Files_Under_Netware_386_or_PenPoint">Trap Files Under Netware 386 or PenPoint</A>
<BR><A HREF="#Trap_Files_Under_OSD2">Trap Files Under OS/2</A>
<BR><A HREF="#Trap_Files_Under_QNX">Trap Files Under QNX</A>
<BR><A HREF="#Trap_Files_Under_Windows_NT_">Trap Files Under Windows NT.</A>
<BR><A HREF="#Trap_Files_Under_Windows_">Trap Files Under Windows.</A>
<BR><A HREF="#TrapFini">TrapFini</A>
<BR><A HREF="#TrapInit">TrapInit</A>
<BR><A HREF="#TrapRequest">TrapRequest</A>
<BR><A HREF="#TYPE_NAME_Lvalue_0x1_R">TYPE_NAME (value 0x1?)</A>
<BR><A HREF="#Types_class">Types class</A>
<BR><A HREF="#Typing_information">Typing information</A>
<DT>- V -
<DD><A HREF="#VARIABLE_Lvalue_0x1_R">VARIABLE (value 0x1?)</A>
<BR><A HREF="#Version_number_and_source_language_identification">Version number and source language identification</A>
</DL>
<H1 ID="Debugging_Information_Format"> Debugging Information Format </H1>
<BR>This document describes the object and executable file structures used by the Open Watcom Debugger to provide symbolic
information about a program.&nbsp; This information is subject to change.
<BR>Note that version 4.0 of the Open Watcom debugger supports the DWARF and CodeView symbolic debugging information formats
in addition to the format described in this document.&nbsp; For the purposes of discussion, this format will be known as the
&quot;WATCOM&quot; format.&nbsp; DWARF is now the primary format used by Open Watcom compilers.&nbsp; Support for generating
the WATCOM format will probably remain but is only useful for debugging DOS overlays.
<BR><BR>Before reading this document you should understand the Intel 8086 Object Module Format (OMF).&nbsp; This format is
described in the Intel document<B> 8086 Relocatable Object Module Formats</B> and also the October 1985 issue of<B> PC Tech
Journal</B>.
<BR><BR>Responsibility for the Intel/Microsoft OMF specification has been taken over by the Tools Interface Standards (TIS)
Committee.&nbsp; The TIS standards (including the OMF spec) may be obtained by phoning the Intel literature center at 1-800-548-4725
and asking for order number 241597.
<BR><BR>This document is for the Open Watcom Debugger version 4.0 (or above.)
<H1 ID="Object_file_structures"> Object file structures </H1>
<BR>The compiler is responsible for placing extra information into the object file in order to provide symbolic information
for the Open Watcom Debugger.&nbsp; There are three classes of information, each of which may be present or absent from the
file individually.&nbsp; These classes are line number, type and local symbol information.
<BR>For the Open Watcom C compiler, line number information is provided when the &quot;/d1&quot; switch is used and all three
classes are provided when the &quot;/d2&quot; switch is used.
<H2 ID="Version_number_and_source_language_identification"> Version number and source language identification </H2>
<BR>Since there may be different versions of the type and local symbol information, and there may be multiple front-ends a
special OMF COMENT record is placed in the object file.&nbsp; It has the following form:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; comment_class = 0xfe</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 'D'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; major_version_number (char)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; minor_version_number (char)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; source_language (string)</TT>
<BR><BR>The<TT> comment_class</TT> of 0xfe indicates a linker directive comment.&nbsp; The character 'D' informs the linker
that this record is providing debugging information.&nbsp; The<TT> major_version_number</TT> is changed whenever there is
a modification made to the types or local symbol classes that is not upwardly compatible with previous versions.&nbsp; The<TT>
minor_version_number</TT> increments by one whenever a change is made to those classes that is upwardly compatible with previous
versions.&nbsp; The<TT> source_language</TT> field is a string which determines what language that the file was compiled from.
<BR><BR>If the debugging comment record is not present, the local and type segments (described later) are not in WATCOM format
and should be omitted from the resulting executable file's debugging information.&nbsp; The current major version is one,
and the current minor version is three.
<H2 ID="Line_number_information"> Line number information </H2>
<BR>Line number information is provided by standard Intel OMF LINNUM records.&nbsp; A kludge has been added that allows for
line numbers to refer to more than one source file.&nbsp; See the section on the &quot;Special Line Number Table&quot; in
the executable structures portion of the document for more details.
<H2 ID="Location_information"> Location information </H2>
<BR>A type or symbol definition may contain a location field.&nbsp; This field is of variable length and identifies the memory
(or register) location of the symbol in question.&nbsp; A location field may consist of a single entry, or a list of entries.
&nbsp;Each entry describes an operation of a stack machine.&nbsp; The value of the location field is the top entry of the
stack after all the operations have been performed.&nbsp; To tell whether a field is a single entry or a list, the first byte
is examined.&nbsp; If the value of the byte is greater than 0x80, then the field consists of a list of entries, and the length
in bytes of the list is the value of the first byte minus 0x80.&nbsp; If the first byte is less than 0x80, the byte is the
first byte of a single entry field.&nbsp; The top nibble of the first byte in each entry is a general location class while
the low nibble specifies the sub-class.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; BP_OFFSET&nbsp;&nbsp; (value 0x1?)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BYTE&nbsp;&nbsp;&nbsp; (value 0x10) offset_byte</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WORD&nbsp;&nbsp;&nbsp; (value 0x11) offset_word</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD&nbsp;&nbsp; (value 0x12) offset_dword</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CONST&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (value 0x2?)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ADDR286 (value 0x20) memory_location_32_pointer</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ADDR386 (value 0x21) memory_location_48_pointer</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INT_1&nbsp;&nbsp; (value 0x22) const_byte</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INT_2&nbsp;&nbsp; (value 0x23) const_word</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INT_4&nbsp;&nbsp; (value 0x24) const_dword</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; MULTI_REG&nbsp;&nbsp; (value 0x3?)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Low nibble is number of register bytes that follow - 1.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The registers are specified low order register first.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; REG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (value 0x4?)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Low nibble is low nibble of the appropriate register value.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This may only be used for the first 16 registers.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; IND_REG&nbsp;&nbsp;&nbsp;&nbsp; (value 0x5?)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALLOC_NEAR (value 0x50) register_byte</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALLOC_FAR&nbsp; (value 0x51) register_byte, register_byte</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RALLOC_NEAR (value 0x52) register_byte</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RALLOC_FAR&nbsp; (value 0x53) register_byte, register_byte</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; OPERATOR&nbsp;&nbsp;&nbsp;&nbsp; (value 0x6?)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IND_2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (value 0x60)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IND_4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (value 0x61)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IND_ADDR286 (value 0x62)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IND_ADDR386 (value 0x63)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ZEB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (value 0x64)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ZEW&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (value 0x65)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MK_FP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (value 0x66)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; POP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (value 0x67)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; XCHG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (value 0x68) stack_byte</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ADD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (value 0x69)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DUP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (value 0x6a)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NOP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (value 0x6b)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Here is the list of register numbers:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0-AL,&nbsp; 1-AH,&nbsp;&nbsp; 2-BL,&nbsp;&nbsp; 3-BH,&nbsp;&nbsp; 4-CL,&nbsp;&nbsp;
5-CH,&nbsp;&nbsp; 6-DL,&nbsp;&nbsp; 7-DH</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8-AX,&nbsp; 9-BX,&nbsp;&nbsp; 10-CX,&nbsp; 11-DX,&nbsp; 12-SI,&nbsp; 13-DI,&nbsp; 14-BP,
&nbsp;15-SP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 16-CS,&nbsp; 17-SS,&nbsp; 18-DS,&nbsp; 19-ES</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 20-ST0, 21-ST1, 22-ST2, 23-ST3, 24-ST4, 25-ST5, 26-ST6, 27-ST7</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 28-EAX, 29-EBX, 30-ECX, 31-EDX, 32-ESI, 33-EDI, 34-EBP, 35-ESP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 36-FS,&nbsp; 37-GS</TT>
<BR><BR>CONST pushes a single constant value onto the expression stack.&nbsp; INT_1 and INT_2 constant values are sign-extended
to four bytes before being pushed.
<BR><BR>The OPERATOR class performs a variety of operations on the expression stack.
<DL>
<DT>IND_2
<DD>Pick up two bytes at the location specified by the top entry of the stack, sign-extend to four bytes and replace top of stack
with the result.
<DT>IND_4
<DD>Replace the top of stack with the contents of the four bytes at the location specified by the top of stack.
<DT>IND_ADDR286
<DD>Replace the top of stack with the contents of the four bytes, treated as a far pointer, at the location specified by the top
of stack.
<DT>IND_ADDR386
<DD>Replace the top of stack with the contents of the six bytes, treated as a far pointer, at the location specified by the top
of stack.
<DT>ZEB
<DD>Zero extend the top of stack from a byte to a dword (clear the high three bytes).
<DT>ZEW
<DD>Zero extend the top of stack from a word to a dword.
<DT>MK_FP
<DD>Remove the top two entries from the stack, use the top of stack as an offset and the next element as a segment to form a far
pointer and push that back onto the stack.
<DT>POP
<DD>Remove the top entry from the stack.
<DT>XCHG
<DD>Exchange the top of stack with the entry specified by<TT> stack_byte</TT>.&nbsp; &quot;XCHG 1&quot; would exchange the top
of stack with the next highest entry.
<DT>ADD
<DD>Remove the top two entries from the stack, add them together and push the result.
<DT>DUP
<DD>Duplicate the value at the top of the stack.
<DT>NOP
<DD>Perform no operation.
</DL>
<BR>REG and MULTI_REG push the 'lvalue' of the register.&nbsp; If they are the only entry then the symbol exists in the specified
register.&nbsp; To access the value of the register, you must indirect it.
<BR><BR>BP_OFFSET locations are for variables on the stack.&nbsp; The values given are offsets from the BP register for 286
programs and from the EBP register for 386 programs.&nbsp; A BP_OFFSET could also be expressed with the following series of
operations:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; MULTI_REG(1) SS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; IND_2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; MULTI_REG(1) EBP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; IND_4</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; MK_FP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; INT_1 offset_byte</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ADD</TT>
<BR><BR>The IND_REG location type is used for structured return values.&nbsp; The register or register pair is used to point
at the memory location where the structure is returned.&nbsp; CALLOC means that the calling procedure is responsible for allocating
the return area and passing a pointer to it as a parameter in the specified registers.&nbsp; RALLOC means that the called
routine allocated the area and returns a pointer to it in the given registers.
<H2 ID="Typing_information"> Typing information </H2>
<BR>The Open Watcom Debugger typing information is contained in a special segment in the object file.&nbsp; The segment name
is &quot;$$TYPES&quot; and the segment class is &quot;DEBTYP&quot;.&nbsp; To allow greater flexibility in demand loading the
typing information and also let it exceed 60K for a single module, each object file may have multiple $$TYPES segments.&nbsp;
Each segment is identified by an entry in the demand link table (described in the executable file structures section).&nbsp;
No individual segment may exceed 60K and no individual type record may be split across a segment boundry.&nbsp; Also, any
type which is described by multiple records (structures, enums, procedures) may not be split across a segment boundry.&nbsp;
Since each segment is loaded as a whole by the debugger when demand loading, increasing the segment size requires larger amounts
of contiguous memory be present in the system.&nbsp; Decreasing the size of the individual segments reduces memory requirements,
but increases debugger lookup time since it has to traverse more internal structures.&nbsp; The current code generator starts
a new type segment when the current one exceeds 16K.&nbsp; The segments are considered to be a stream of variable length definitions,
with each definition being preceded by a length byte.&nbsp; A number of the definitions contain indices of some form.&nbsp;
These indices are standard Intel format, with 0 meaning no index, 1 to 127 is represented in one byte, 128 to 32767 in high
byte/low byte form with the top bit on in the high byte.&nbsp; Definitions are given index numbers by the order in which they
appear in the module, with the first being index one.&nbsp; Character strings representing names are always placed at the
end of a definition so that their length can be calculated by subtracting the name's start point from the length of the record.
&nbsp;They are not preceded by a length byte or followed by a zero byte.
<BR><BR>The first byte identifies the kind of the type definition that follows.&nbsp; The top nibble of the byte is used to
indicate the general class of the type definition (there are eight of these).&nbsp; The low order nibble is used to qualify
the general type class and uniquely identify the definition type.
<H3 ID="TYPE_NAME_Lvalue_0x1_R"> TYPE_NAME (value 0x1?) </H3>
<BR>This definition is used to give names to types.&nbsp; There are three sub-classes.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SCALAR&nbsp;&nbsp;&nbsp; (value 0x10) scalar_type_byte, name</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SCOPE&nbsp;&nbsp;&nbsp;&nbsp; (value 0x11) name</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; NAME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (value 0x12) scope_index, type_index, name</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CUE_TABLE (value 0x13) table_offset_dword</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; EOF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (value 0x14)</TT>
<BR><BR>SCALAR is used to give a name to a basic scalar type.&nbsp; It can also be used to give a type index to a scalar type
without a name by specifying the null name.&nbsp; The<TT> scalar_type_byte</TT> informs the Open Watcom Debugger what sort
of scalar item is being given a name.&nbsp; It has the following form:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; BIT: 7 6 5 4 3 2 1 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | |&nbsp;&nbsp; | |&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | |&nbsp;&nbsp; | +-----+--- size in bytes - 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | +---+----------- class (000 - integer)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (001 - unsigned)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (010 - float)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (011 - void (size=0))</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (100 - complex)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------- unused</TT>
<BR><BR>To create an unnamed scalar type, for use in other definitions, just use a zero length name.
<BR><BR><B>NOTE:</B>&nbsp; BASIC would have been a better name for this, since complex is not a scalar type, but the name
was chosen before complex support was added.
<BR><BR>SCOPE is used to restrict the scope of other type names.&nbsp; A restricted scope type name must be preceded by its
appropriate scope name in order for the Open Watcom Debugger to recognize it as a type name.&nbsp; This is useful for declaring
C structure, union, and enum tag names.&nbsp; You declare SCOPE names of &quot;struct&quot;, &quot;union&quot;, and &quot;enum&quot;
and then place the appropriate value in the<TT> scope_index</TT> field of the NAME record when declaring the tag.
<BR><BR>NAME gives an arbitrary type a name.&nbsp; The field,<TT> scope_index</TT>, is either zero, which indicates an unrestricted
type name, or is the type index of a SCOPE definition, which means that the type name must be preceded by the given scope
name in order to be recognized.
<BR><BR>The next two records are kludges to allow OMF line numbers to refer to more than one source file.&nbsp; See the section
of on the &quot;Special Line Number Table&quot; in the executable structure for more details.
<BR><BR>CUE_TABLE is followed by<TT> table_offset_dword</TT> which gives the offset in bytes from the begining of the typing
information for a module to the special line number table.&nbsp; If this record is present, it must be in the first $$TYPES
segment for the module and preferably as close to the begining of the segment as possible.
<BR><BR>EOF marks the end of the typing information for the module and the begining of the special line number table.
<H3 ID="ARRAY_Lvalue_0x2_R"> ARRAY (value 0x2?) </H3>
<BR>This definition is used to define an array type.&nbsp; There are 6 sub-classes.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; BYTE_INDEX&nbsp;&nbsp;&nbsp;&nbsp; (value 0x20) high_bound_byte, base_type_index</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; WORD_INDEX&nbsp;&nbsp;&nbsp;&nbsp; (value 0x21) high_bound_word, base_type_index</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; LONG_INDEX&nbsp;&nbsp;&nbsp;&nbsp; (value 0x22) high_bound_dword, base_type_index</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; TYPE_INDEX&nbsp;&nbsp;&nbsp;&nbsp; (value 0x23) index_type_index, base_type_index</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DESC_INDEX&nbsp;&nbsp;&nbsp;&nbsp; (value 0x24) scalar_type_byte, scalar_type_byte,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bounds_32_pointer, base_type_index</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DESC_INDEX_386 (value 0x25) scalar_type_byte, scalar_type_byte,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bounds_48_pointer, base_type_index</TT>
<BR><BR>BYTE_INDEX, WORD_INDEX, LONG_INDEX are all used to describe a restricted form of array.&nbsp; If one of these forms
is used then the index type is an integer with the low bound of the array being zero and the high bound being whatever is
specified.
<BR><BR>The DESC_INDEX form is used when the array bounds are not known at compile time.&nbsp; The<TT> bounds_32_pointer</TT>
is a far pointer to a structure in memory.&nbsp; The type and size of the first field is given by the first<TT> scalar_type_byte</TT>
and indicates the lower bound for the index.&nbsp; The second field's type and size is given by the second<TT> scalar_type_byte</TT>
.&nbsp; This field gives the number of elements in the array.
<BR><BR>The DESC_INDEX_386 is the same as DESC_INDEX except that a 48-bit far pointer is used to locate the structure in memory.
<H3 ID="SUBRANGE_Lvalue_0x3_R"> SUBRANGE (value 0x3?) </H3>
<BR>This definition is used to define a subrange type.&nbsp; There are 3 sub-classes.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; BYTE_RANGE (value 0x30) lo_bnd_byte, hi_bnd_byte, base_type_index</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; WORD_RANGE (value 0x31) lo_bnd_word, hi_bnd_word, base_type_index</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; LONG_RANGE (value 0x32) lo_bnd_dword, hi_bnd_dword, base_type_index</TT>
<BR><BR>If the base type is unsigned then the low and high bounds should be interpreted as containing unsigned quantities,
otherwise they contain integers.&nbsp; However, the decision to use the byte, word, or long form of the definition is always
made considering the high and low bounds as signed numbers.
<H3 ID="POINTER_Lvalue_0x4_R"> POINTER (value 0x4?) </H3>
<BR>This definition is used to define a pointer type.&nbsp; There are 10 sub-classes.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; NEAR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (value 0x40) base_type_index
[,base_locator]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; FAR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (value 0x41)
base_type_index</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; HUGE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (value 0x42) base_type_index</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; NEAR_DEREF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (value 0x43) base_type_index [,base_locator]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; FAR_DEREF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (value 0x44) base_type_index</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; HUGE_DEREF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (value 0x45) base_type_index</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; NEAR386&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (value 0x46) base_type_index [,base_locator]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; FAR386&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (value 0x47) base_type_index</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; NEAR386_DEFREF&nbsp; (value 0x48) base_type_index [,base_locator]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; FAR386_DEREF&nbsp;&nbsp;&nbsp; (value 0x49) base_type_index</TT>
<BR><BR>When a symbol is one of the *_DEREF types, the Open Watcom Debugger will automatically dereference the pointer.&nbsp;
This &quot;hidden&quot; indirection may be used to define reference parameter types, or other indirectly located symbols.
&nbsp;The *_DEREF types have now been superceeded by location expressions.&nbsp; They should no longer be generated.&nbsp;
The NEAR* pointer types all have an optional<TT> base_locator</TT> field.&nbsp; The debugger can tell if this field is present
by examining the length of the debug type entry at the begining of the record and seeing if there are additional bytes after
the<TT> base_type_index</TT> field.&nbsp; If there are more bytes, the<TT> base_locator</TT> is a location expression whose
result is an address, the value of which is the base selector and offset value when indirecting through the pointer (based
pointers).&nbsp; The contents of the based pointer variable are added to result of the location expression to form the true
resulting address after an indirection.&nbsp; The address of the pointer variable being indirected through is pushed on the
stack before the location expression is evaluated (needed for self-based pointers).&nbsp; If the<TT> base_locator</TT> field
is not present, the debugger will use the default near segment and a zero offset.
<H3 ID="ENUMERATED_Lvalue_0x5_R"> ENUMERATED (value 0x5?) </H3>
<BR>This definition is used to define an enumerated type.&nbsp; There are 4 sub-classes.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; LIST&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (value 0x50) #consts_word, scalar_type_byte</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CONST_BYTE (value 0x51) value_byte, name</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CONST_WORD (value 0x52) value_word, name</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CONST_LONG (value 0x53) value_dword, name</TT>
<BR><BR>LIST is used to inform the Open Watcom Debugger of the number of constants in the enumerated type and the scalar type
used to store them in memory.&nbsp; It will be followed immediately by all the constant definitions for the enumerated type.
&nbsp;See TYPE_NAME for a description of the<TT> scalar_type_byte</TT>.
<BR><BR>CONST_BYTE, CONST_WORD, and CONST_LONG define the individual constant values for an enumerated type.&nbsp; The type
of the constant is provided by the preceeding LIST definition.&nbsp; The decision to use the byte, word, or long form of the
definition is made always by considering the value as a signed number.&nbsp; The CONST_* definition records are not counted
when determining type index values.
<BR><BR>The LIST record and its associated CONST_* records must all be contained in the same $$TYPES segment.
<H3 ID="STRUCTURE_Lvalue_0x6_R"> STRUCTURE (value 0x6?) </H3>
<BR>This definition is used to define a structure type.&nbsp; There are 10 sub-classes.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; LIST&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (value 0x60) #fields_word [,size_dword]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; FIELD_BYTE (value 0x61) offset_byte, type_index, name</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; FIELD_WORD (value 0x62) offset_word, type_index, name</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; FIELD_LONG (value 0x63) offset_dword, type_index, name</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; BIT_BYTE&nbsp;&nbsp; (value 0x64) offset_byte, start_bit_byte, bit_size_byte,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type_index, name</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; BIT_WORD&nbsp;&nbsp; (value 0x65) offset_word, start_bit_byte, bit_size_byte,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type_index, name</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; BIT_LONG&nbsp;&nbsp; (value 0x66) offset_dword, start_bit_byte, bit_size_byte,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type_index, name</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; FIELD_CLASS (v&nbsp;&nbsp;&nbsp; 0x67) attrib_byte, field_locator, type_index, name</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; BIT_CLASS&nbsp; (value 0x68) attrib_byte, field_locator, start_bit_byte,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bit_size_byte, type_index, name</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; INHERIT_CLASS (v&nbsp; 0x69) adjust_locator, ancestor_type_index</TT>
<BR><BR>LIST is used to introduce a structure definition.&nbsp; It is followed immediately by all the field definitions that
make up the structure.&nbsp; The optional<TT> size_dword</TT> gives the size of the structure in bytes.&nbsp; If it is not
present, the debugger calculates the size of the structure based on field offsets and sizes.
<BR><BR>FIELD_BYTE, FIELD_WORD, FIELD_LONG, and FIELD_CLASS define a single field entry in a structure defintion.
<BR><BR>BIT_BYTE, BIT_WORD, BIT_LONG, and BIT_CLASS define a bit field in a structure.&nbsp; :The FIELD_CLASS and BIT_CLASS
records are used for defining fields in a C++ class.&nbsp; The<TT> attrib_byte</TT> contain a set of bits describing attributes
of the field:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; BIT: 7 6 5 4 3 2 1 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; | | | | |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; | | | | +--- internal</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; | | | +----- public</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; | | +------- protected</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; | +--------- private</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-----+----------- unused</TT>
<BR><BR>An internal field is one that is generated for compiler support.&nbsp; It is not normally displayed to the user.&nbsp;
The other bits have their usual C++ meanings.
<BR><BR>The<TT> field_locator</TT> is a location expression describing how to calculate the field address.&nbsp; Before begining
to evaluate the expression, the debugger will implicitly push the base address of the class instance onto the stack.&nbsp;
The following is an example of the location expression used to calculate an ordinary field at offset 10 from the start of
the class:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; INT_1&nbsp;&nbsp; 10</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ADD</TT>
<BR><BR>The INHERIT_CLASS record indicates that a particular class should inherit all the fields specified by<TT> ancestor_type_index</TT>.
&nbsp;This field must point at either a STRUCTURE LIST record or a TYPE NAME that eventually resolves to a STRUCTURE LIST.
&nbsp;The<TT> adjust_locator</TT> is a location expression that tells the debugger how to adjust the field offset expressions
in the inherited class to their proper values for a class of this instance.
<BR><BR>The FIELD_*, BIT_*, and INHERIT_CLASS records are not counted when determining type index values.
<BR><BR>A C union, or Pascal variant record is described by having a number of fields all beginning at the same offset.&nbsp;
The Open Watcom Debugger will display the fields in the reverse order that the records define them.&nbsp; This means that
ordinarily, the records should be sorted by descending offsets and bit positions.
<BR><BR>The LIST record and it's associated field descriptions must all be contained in the same $$TYPES segment.
<H3 ID="PROCEDURE_Lvalue_0x7_R"> PROCEDURE (value 0x7?) </H3>
<BR>This definition is used to define a procedure type.&nbsp; There are 4 sub-classes.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; NEAR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (value 0x70) ret_type_index, #parms_byte {,parm_type_index}</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; FAR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (value 0x71) ret_type_index, #parms_byte {,parm_type_index}</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; NEAR386&nbsp;&nbsp; (value 0x72) ret_type_index, #parms_byte {,parm_type_index}</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; FAR386&nbsp;&nbsp;&nbsp; (value 0x73) ret_type_index, #parms_byte {,parm_type_index}</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; EXT_PARMS (value 0x74) {,parm_type_index}</TT>
<BR><BR>The EXT_PARMS sub-class is used when there are too many parameter types to fit into one PROCEDURE record.&nbsp; This
condition can be recognized when the #parms_byte indicates there are more parameter types than fit into the record according
to the length field at the beginning.&nbsp; In this case the remaining parameter types are continued in the record immediately
following, which will always be of type EXT_PARMS.&nbsp; The EXT_PARMS record must be contained in the same $$TYPES segment
as the preceeding procedure record.
<H3 ID="CHARACTER_BLOCK_Lvalue_0x8_R"> CHARACTER_BLOCK (value 0x8?) </H3>
<BR>Items of type CHARACTER_BLOCK are length delimited strings.&nbsp; There are 4 sub-classes.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CHAR_BYTE&nbsp;&nbsp;&nbsp; (value 0x80) length_byte</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CHAR_WORD&nbsp;&nbsp;&nbsp; (value 0x81) length_word</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CHAR_LONG&nbsp;&nbsp;&nbsp; (value 0x82) length_dword</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CHAR_IND&nbsp;&nbsp;&nbsp;&nbsp; (value 0x83) scalar_type_byte, length_32_pointer</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CHAR_IND_386 (value 0x84) scalar_type_byte, length_48_pointer</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CHAR_IND_LOC (value 0x85) scalar_type_byte, address_locator</TT>
<BR><BR>The CHAR_BYTE, CHAR_WORD, and CHAR_LONG forms are used when the length of the character string is known at compile
time.&nbsp; Even though the length given is an unsigned quantity, the decision on which form to use is made by considering
the value to be signed.&nbsp; The CHAR_IND form is used when the length of the string is determined at run time.&nbsp; The<TT>
length_32_pointer</TT> gives the far address of a location containing the length of the string.&nbsp; The size of this location
is given by the<TT> scalar_type_byte</TT>.&nbsp; The CHAR_IND_386 form is the same as CHAR_IND except that the location of
the length is given by a 48-bit far pointer.&nbsp; The CHAR_IND_LOC form is the same as CHAR_IND except that the address of
the length is given by a location expression.
<H2 ID="Local_symbol_information"> Local symbol information </H2>
<BR>The Open Watcom Debugger local symbol information is contained in a special segment in the object file.&nbsp; The segment
name is &quot;$$SYMBOLS&quot; and the segment class is &quot;DEBSYM&quot;.&nbsp; The segment is considered to be a stream
of variable length definitions, with each definition being preceded by a length byte.&nbsp; A number of the definitions contain
indices of some form.&nbsp; These indices are standard Intel format, with 0 meaning no index, 1 to 127 is represented in one
byte, 128 to 32767 in high byte/low byte form with the top bit on in the high byte.&nbsp; Character strings representing names
are always placed at the end of a definition so that their length can be calculated by subtracting the name's start point
from the length of the record.&nbsp; They are not preceded by a length byte or followed by a zero byte.
<BR><BR>The first byte identifies the kind of the symbol definition that follows.&nbsp; The top nibble of the byte is used
to indicate the general class of the symbol definition.&nbsp; The low order nibble is used to qualify the general definition
class.
<BR><BR>Symbol definitions are used to provide the Open Watcom Debugger with the location and scoping of source language local
symbols.&nbsp; There are two general classes of symbol definition, one for variables and one for code.
<H3 ID="VARIABLE_Lvalue_0x1_R"> VARIABLE (value 0x1?) </H3>
<BR>This definition is used to define the location of a data symbol.&nbsp; There are 4 sub-classes.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; MODULE&nbsp;&nbsp;&nbsp;&nbsp; (value 0x10) memory_location_32_pointer, type_index, name</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; LOCAL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (value 0x11) address_locator, type_index, name</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; MODULE386&nbsp; (value 0x12) memory_location_48_pointer, type_index, name</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; MODULE_LOC (value 0x13) address_locator, type_index, name</TT>
<BR><BR>MODULE defines either an exported, domestic, or imported variable in the module.&nbsp; It is not necessary to generate
symbol information for an imported variable since the Open Watcom Debugger will look for local symbol information in the module
which defines the variable if required.
<BR><BR>LOCAL defines a symbol that is local to a code block or procedure.&nbsp; The defining block is the first one previous
to this definition.&nbsp; Local symbols only &quot;exist&quot; for the purpose of the Open Watcom Debugger lookups when the
program is executing in a block which defines the symbol.
<H3 ID="CODE_Lvalue_0x2_R"> CODE (value 0x2?) </H3>
<BR>This definition is used to define an object in the code.&nbsp; There are 6 sub-classes.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; BLOCK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (value 0x20) start_offset_word, size_word,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parent_block_offset</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; NEAR_RTN&nbsp;&nbsp;&nbsp;&nbsp; (value 0x21) &lt;BLOCK&gt;, pro_size_byte, epi_size_byte,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret_addr_offset_word, type_index,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return_val_loc, #parms_byte</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {,parm_location}, name</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; FAR_RTN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (value 0x22) &lt;BLOCK&gt;, pro_size_byte, epi_size_byte,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret_addr_offset_word, type_index,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return_val_loc, #parms_byte</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {,parm_location}, name</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; BLOCK_386&nbsp;&nbsp;&nbsp; (value 0x23) start_offset_dword, size_dword,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parent_block_offset</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; NEAR_RTN_386 (value 0x24) &lt;BLOCK_386&gt;, pro_size_byte, epi_size_byte,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret_addr_offset_dword, type_index,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return_val_loc, #parms_byte</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {,parm_location}, name</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; FAR_RTN_386&nbsp; (value 0x25) &lt;BLOCK_386&gt;, pro_size_byte, epi_size_byte,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret_addr_offset_dword, type_index,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return_val_loc, #parms_byte</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {,parm_location}, name</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; MEMBER_SCOPE (value 0x26) parent_block_offset, class_type_index</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [obj_ptr_type_byte, object_loc]</TT>
<BR><BR>BLOCK is used to indicate a block of code that contains local symbol definitions.&nbsp; The field<TT> parent_block_offset</TT>
is used to tell the Open Watcom Debugger the next block to search for a symbol definition if it is not found in this block.
&nbsp;The field is set to zero if there is no parent block.
<BR><BR>NEAR_RTN and FAR_RTN are used to specify a routine definition.&nbsp; Notice that the first part is identical to a
code block definition.&nbsp; The<TT> ret_addr_offset_word</TT> is the offset from BP (or EBP) that the return address is located
on the stack.&nbsp; The<TT> #parms_byte</TT> and<TT> parm_location</TT>'s following are only for those parms which are passed
in registers.&nbsp; The remainder of the parms are assumed to be passed on the stack.
<BR><BR>The MEMBER_SCOPE record is used for C++ member functions.&nbsp; It introduces a scope where the the debugger looks
up the fields of the class identified by<TT> class_type_index</TT> as if they were normal symbols.&nbsp; If the<TT> obj_ptr_type_byte</TT>
and<TT> object_loc</TT> location expression portions of the record are present, it indicates that the function has a C++ &quot;this&quot;
pointer, and all fields of the class structure are accessable.&nbsp; The location expression evaluates to the address of the
object that the member function is manipulating.&nbsp; The<TT> obj_ptr_type_byte</TT> contains a value from the low order
nibble of a POINTER type record.&nbsp; It indicates the type of `this' pointer the routine is expecting.&nbsp; I.e.:
<DL>
<DT><B><I>Value</I></B>
<DD><B><I>Definition</I></B>
<DT>0
<DD>16-bit near pointer
<DT>1
<DD>16-bit far pointer
<DT>6
<DD>32-bit near pointer
<DT>7
<DD>32-bit far pointer
</DL>
<BR>If the portions following the<TT> class_type_index</TT> are absent from the record, the routine is a static member function
and only has access to static data members.
<BR>To use this record, the member function's<TT> parent_block_offset</TT> is pointed at the MEMBER_SCOPE record, and the
MEMBER_SCOPE's<TT> parent_block_offset</TT> field is pointed at what the member function would normally be pointing at.&nbsp;
In effect, a new block scope has been introduced.
<BR><BR>The *_386 versions of the records are identical to their 286 counterparts excepts that the<TT> start_offset</TT>,<TT>
size</TT>, and<TT> ret_addr_offset</TT> fields have been widened to 32 bits.
<BR><BR><B>NOTE:</B>&nbsp; There should be a better mapping of parm number to parm location.&nbsp; There is no provision for
Pascal calling conventions (reversed parm order) or other strangeness.
<BR><BR>The BLOCK definition contains a<TT> start_offset_word</TT> (or<TT> start_offset_dword</TT> in a BLOCK_386).&nbsp;
This is the offset from a given memory location provided by NEW_BASE entries and indicates the address of the start of executable
code for the block.
<BR><BR>All the code location definitions are assumed to be sorted in order of increasing end offsets (start offset + size).
&nbsp;This ensures that the first scope that the debugger encounters in a traversal of the symbolic information is the closest
enclosing scope.
<H3 ID="NEW_BASE_Lvalue_0x3_R"> NEW_BASE (value 0x3?) </H3>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ADD_PREV_SEG (value 0x30) seg_increment_word</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SET_BASE&nbsp;&nbsp;&nbsp;&nbsp; (value 0x31) memory_location_32_pointer</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SET_BASE386&nbsp; (value 0x32) memory_location_48_pointer</TT>
<BR><BR>For ADD_PREV_SEG, the specified amount is added to the segment value of the code start address of the module.&nbsp;
The code start offset is reset to zero.&nbsp; All BLOCK definitions occuring after this item are relative to the new value.
&nbsp;After a SET_BASE or SET_BASE386 all BLOCK definitions are relative to the memory location that is given by the record.
<BR><BR><B>NOTE:</B>&nbsp; Avoid the use of the ADD_PREV_SEG record.&nbsp; Its operation is only valid in real mode.&nbsp;
It is included for backwards compatiblity only.
<H1 ID="Executable_file_structures"> Executable file structures </H1>
<BR>The linker is responsible for processing the debugging information contained in the object files and some of its internal
structures and appending them to the executable file.
<BR>After linking, the executable file looks like this:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +-----------------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EXE file&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +=======================+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Overlays&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +=======================+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp; Any Other Stuff&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +=======================+&lt;--- start of debugging information</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; | source language table |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +-----------------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; | segment address table |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +-----------------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&lt;-\</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; section debug info&nbsp;&nbsp; |&nbsp;&nbsp; +-- repeated for each overlay &amp;
root</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&lt;-/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +-----------------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; master debug header&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +=======================+&lt;--- end of file</TT>
<BR><BR>The section marked as &quot;EXE file&quot; is the normal executable file.&nbsp; All debugging information is appended
to the end of the file, after any overlay sections or other information.&nbsp; The<TT> master debug header</TT> begins at
a fixed offset from the end of the file, and provides the location of the remainder of the debug information.&nbsp; The<TT>
source language table</TT> contains the source languages used by the program.&nbsp; The<TT> section debug info</TT> is repeated
once for the root and each overlay section defined in the executable.&nbsp; It contains all the debugging information for
all object modules defined in the root or a particular overlay section.&nbsp; The<TT> section debug info</TT> is further divided
into a number of debugging information classes, these will be explained later.&nbsp; All offsets in the debugging information
that refer to other information items are relative to the start of the information, the start of a section of information,
or the start of a class of the information.&nbsp; In other words, the information is not sensitive to its location in the
executable file.
<H2 ID="Master_debug_header"> Master debug header </H2>
<BR>The master debug header allows the Open Watcom Debugger to verify the fact that there is debugging information, to locate
the other sections and to verify that it is capable of handling the version of debugging information.&nbsp; The master header
structure is as follows:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct master_dbg_header {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16 signature;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp; exe_major_ver;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp; exe_minor_ver;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp; obj_major_ver;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp; obj_minor_ver;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16 lang_size;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16 segment_size;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32 debug_size;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR>The<TT> signature</TT> word contains the value 0x8386.&nbsp; This is the first indication to the Open Watcom Debugger
that there is debugging information present.&nbsp; The<TT> exe_major_ver</TT> field contains the major version number of the
executable file debugging information structures.&nbsp; The major version number will change whenever there is a modification
to these structures that is not upwardly compatible with the previous version.&nbsp; The current major version number is three.
&nbsp;The<TT> exe_minor_ver</TT> field contains the minor version number of the executable file debugging information structures.
&nbsp;The minor version number increments by one whenever there is a change to the structures which is upwardly compatible
with the previous version.&nbsp; The current minor version number is zero.&nbsp; This means that in order for the Open Watcom
Debugger to process the debugging information the following must be true:
<OL>
<LI>FILE exe debug info major version == debugger exe debug info major version
<LI>FILE exe debug info minor version &lt;= debugger exe debug info minor version
</OL>
<BR>The<TT> obj_major_ver</TT> field contains the major version number of the object file debugging information structures
(internal format of the types and local symbol information).&nbsp; The major version number will change whenever there is
a modification to these structures that is not upwardly compatible with the previous version.&nbsp; The current major version
number is one.&nbsp; The<TT> obj_minor_ver</TT> field contains the minor version number of the object file debugging information
structures.&nbsp; The minor version number increments by one whenever there is a change to the structures which is upwardly
compatible compatible with the previous version.&nbsp; The current minor version number is three.&nbsp; This means that in
order for the debugger to process the debugging information the following must be true:
<OL>
<LI>FILE obj debug info major version == debugger obj debug info major version
<LI>FILE obj debug info minor version &lt;= debugger obj debug info minor version
</OL>
<BR>These two fields are filled in by the linker by extracting the version information from special debug comment record in
the processed object files.&nbsp; If two object files in the link contain different major version numbers, the linker should
report an error or warning and not process the type or local symbol information for the 'incorrect' file.&nbsp; The minor
version number placed in the master header should be the maximum of all the minor version numbers extracted from the object
files.
<BR><BR>The<TT> lang_size</TT> field contains the size of the source language table at the beginning of the debug information.
&nbsp;The<TT> segment_size</TT> field informs the debugger of the size, in bytes, of the segment address table.&nbsp; The
field,<TT> debug_size</TT>, gives the total size of the debugging information, including the size of the master header itself.
&nbsp;This allows the debugger to calculate the start of the debugging information by subtracting the value of the<TT> debug_size</TT>
field from the location of the end of file.&nbsp; This gives the start of the source language and segment address tables,
whose sizes are known from the master header.&nbsp; Once the location of the first section of debugging information is determined,
it can be processed.&nbsp; Within the section information is a indicator of its total size, which allows the debugger to find
the start of the next section, and process that as well.&nbsp; This continues until all the debug sections have been processed.
&nbsp;the debugger knows there are no more debug sections to process when the indicated start of a section is the same as
the start of the master header.
<H2 ID="Source_language_table"> Source language table </H2>
<BR>The source language table is merely the collection of unique source languages used in the program.&nbsp; The strings are
extracted from the special debug comment records in the object files and placed in this section one after another with zero
bytes separating them.
<H2 ID="Segment_address_table"> Segment address table </H2>
<BR>The segment address table is an array of all the unique segment numbers used by the executable.&nbsp; Essentially, any
segment value that would appear in the map file will be represented in the table.
<H2 ID="Section_debug_information"> Section debug information </H2>
<BR>Each<TT> section debug info</TT> contains the following:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +-----------------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp; section header&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +-----------------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp; local symbols&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +-----------------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; types&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +-----------------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp; line numbers&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +-----------------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; module info&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +-----------------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp; global symbols&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +-----------------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; address info&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +-----------------------+</TT>
<BR><BR>The local symbols, types and line numbers classes are demand loaded by the debugger as it requires pieces of the classes
for various modules.&nbsp; The module info, global symbols, and address info classes are permanently loaded by the debugger
at the start of a debugging session.&nbsp; The global symbol, module, and address info classes have no size restriction, however
there is a limit of 65536 modules per section and there are some restrictions on how the address info class may be laid out.
&nbsp;These restrictions are described in the section explaining the address info class.
<H3 ID="Section_debug_header"> Section debug header </H3>
<BR>The section header class allows the debugger to determine the size of the section information and the location of the
permanently loaded classes.&nbsp; The header structure is as follows:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct section_dbg_header {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32 mod_offset;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32 gbl_offset;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32 addr_offset;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32 section_size;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16 section_id;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR>The<TT> mod_offset</TT>,<TT> gbl_offset</TT>, and<TT> addr_offset</TT> fields are offsets, from the beginning of the
section debug header to the module info, global symbol, and address info classes of debugging information.&nbsp; The<TT> section_size</TT>
field is the size of the debugging information for the section, including the section header.&nbsp; The following conditions
must hold true for the debugger to recognize the debugging information as valid:
<OL>
<LI>mod_offset &lt; gbl_offset
<LI>gbl_offset &lt; addr_offset
<LI>addr_offset &lt; section_size
</OL>
<BR>The<TT> section_id</TT> field contains the overlay number for this section.&nbsp; This is zero for the root.
<H3 ID="Local_symbols_class"> Local symbols class </H3>
<BR>The local symbols segments are processed normally by the linker, except that the data in the segments is placed in this
section, no relocation entries are output for any fixups in the data and fields in the module structure are intialized to
point to the beginning and size of each object file's contribution to the section.
<H3 ID="Types_class"> Types class </H3>
<BR>The type segments are processed normally by the linker, except that the data in the segments is placed in this section,
no relocation entries are output for any fixups in the data and fields in the module structure are intialized to point to
the beginning and size of each object file's contribution to the section.
<H3 ID="Line_numbers_class"> Line numbers class </H3>
<BR>The LINNUM records for each object file are collected and placed in this class using an array of arrays.&nbsp; The top
level array is the following structure:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct line_segment {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32&nbsp;&nbsp;&nbsp;&nbsp; segment;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; num;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; line_info&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; line[1];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The<TT> segment</TT> field contains a offset, from the start of the address info class, to an addr_info structure
(see the address info class description).&nbsp; This provides the segment value for the array of line_info's following.&nbsp;
The next field,<TT> num</TT>, provides the number of line_info's in the array.&nbsp; The<TT> line</TT> is a variable size
array containing the following structure:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct line_info {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp; line_number;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32&nbsp; code_offset;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR>The<TT> line_number</TT> contains the source line number whose offset is being defined.&nbsp; If the top bit of the
line number is on, this line number refers to an entry in the special line number table.&nbsp; See the &quot;Special Line
Number Table&quot; section for more details.&nbsp; The<TT> code_offset</TT> field contains the offset from the begining of
the module for the first instruction associated with the line number.&nbsp; To get the true code address for the instruction
you must add<TT> code_offset</TT> to the address given by the<TT> segment</TT> field in the line_segment structure.&nbsp;
All the instructions up to the next element's<TT> code_offset</TT>, or the end of the object file's code for that segment
if there is no next<TT> code_offset</TT> are considered to be part of the<TT> line_number</TT> source line.&nbsp; Within each
line_segment structure the line_info array is assumed to be sorted in order of ascending<TT> code_offset</TT>'s.&nbsp; The
module structure for the object file contains fields which indicate the start and size of the line_segment array within the
class.
<BR><BR>Each line_segment structure may not exceed 60K, however the total amount of line information for a module may exceed
60K with multiple line_segment structures and multiple entries in the demand link table (described in the module information
section).
<BR><BR>To obtain a line number from an address, the debugger performs the following steps
<OL>
<LI>Given an address, the defining module is found from the address information class.&nbsp; This allows the debugger to find
and load the line number information for that module, if it is not already loaded.
<LI>Walk down the array of line_segment structures until one with the appropriate segment is found.
<LI>Binary search the array of line_info's until the proper one is located.
</OL>
<H4 ID="Special_Line_Number_Table"> Special Line Number Table </H4>
<BR>The OMF line number record does not allow for more than one source file to be referenced in an object file.&nbsp; This
kludge gets around the restriction.&nbsp; If the top bit is on in<TT> line_number</TT> than that field refers to an entry
in the special line number table.&nbsp; The debugger then searches the typing information for the module for a<TT> CUE_TABLE</TT>
record.&nbsp; If it finds one, it uses the offset given to find the begining of the table in the typing information.&nbsp;
The table looks like this:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* cue entry table */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16 cue_count</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16 cue;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16 fno;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16 line;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16 column;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; } cue_entry; /* repeated cue_count times, sorted by the 'cue' field */</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* file name index table */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16 file_count</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16 index;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; } file_name_index_entry; /* repeated file_count times */</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* file name table */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; A list of zero terminated source file names</TT>
<BR><BR>To find the correct cue entry given the value in a<TT> line_number</TT>, search the<TT> cue_entry</TT> table for the
cue which satisfies the following:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; cue_entry[entry].cue &lt;= (line_number &amp; 0x7fff) &lt; cue_entry[entry+1].cue</TT>
<BR><BR>Once you have the cue entry, you can extract the true line number by:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; line = cue_entry[entry].line + (line_number &amp; 0x7fff)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
- cue_entry[entry].cue;</TT>
<BR><BR>The file name is found by:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; fname_index = file_name_index_table[ cue_entry[entry].fno ]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; fname =&nbsp; file_name_table[ fname_index ]</TT>
<BR><BR>The code offset and segment are found in the<TT> line_info</TT> and<TT> line_segment</TT> structures as usual.
<H3 ID="Module_information_class"> Module information class </H3>
<BR>The module information class is built from the linker's list of object files that it processes to build the executable
file, which are either specified on the linker command line or extracted from libraries.&nbsp; All the modules are implicitly
given an index number by their order in the class.&nbsp; These index numbers start at zero and are used by other classes to
identify individual modules.&nbsp; The module structure contains the following fields:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct mod_info {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16 language;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; demand_info locals;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; demand_info types;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; demand_info lines;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp; name[1];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR>The<TT> language</TT> field contains an offset, from the start of the source language table to the string of the source
language for this module.&nbsp; The<TT> name</TT> field is a variable length array of characters with the first element of
the array being the length of the name.&nbsp; The remaining characters identify the source file the compiler used to generate
the object file (e.g.&nbsp; &quot;C:\DEV\WV\C\DBGMAIN.C&quot;).&nbsp; The source file name is obtained from the THEADR record
of the object file.&nbsp; the debugger uses the file name part of the file specification as its &quot;module name&quot;.&nbsp;
The remaining fields,<TT> locals</TT>,<TT> types</TT>, and<TT> lines</TT> are a structure type which define the location and
size of this module's demand loaded information from those classes.&nbsp; The structure contains these fields:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct demand_info {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32 offset;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16 num_entries;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR>The<TT> offset</TT> field contains the offset from the beginning of the debugging information section to first entry
in the demand link table containing the information for that particular demand load class.&nbsp; The<TT> num_entries</TT>
field gives the number of contiguous entries in the demand link table that are present for the module's demand load information
of that particular class.
<BR><BR>The demand link table consists of an array of unsigned_32 offsets, which are relative from the debugging information
section, to the individual demand info class data blocks.&nbsp; The array is in ascending order of offsets so that the debugger
may calculate the size of a particular demand load data block by subtracting the offset of the next data block from the offset
of the current data block.&nbsp; This implies that there is an extra entry at the end of the table whose offset points to
the end of the final demand load data block so that the debugger always has a 'next' link entry to calculate size of a data
block with.&nbsp; The size of each individual block may not exceed 60K.&nbsp; A picture may be useful here to show how all
the pieces fit together:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; module info</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +--------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;demand link</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;table&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; demand info</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;+--------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data block</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +--------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; +---&gt;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; | offset | ---+&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;
&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +--------+&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; +--------+&nbsp;&nbsp; |&nbsp;&nbsp;
&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |#entries|&nbsp;&nbsp;&nbsp; +----&gt;| offset |---+&nbsp;&nbsp;&nbsp; +------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +--------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +--------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; ...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +--------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +--------+&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; demand info</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; | offset |---+&nbsp;&nbsp;&nbsp; data block</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; +--------+&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp; +------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; +---&gt;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;
&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; +--------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +------+</TT>
<BR><BR>When the debugger wishes to look something up in a demand load class for a module.&nbsp; It uses the offset in the
mod_info structure to locate the array entry in the demand link table which has the offset for the first info data block.
&nbsp;It then loads the first block and searches it for the information.&nbsp; If the information is not present in that block,
it moves to the next entry in the demand link table and repeats the above process.&nbsp; This continues until all the entries
for that particular class of the module (identified by the<TT> num_entries</TT> field in the mod_info structure) have been
examined, or the information is located.
<H3 ID="Global_symbols_class"> Global symbols class </H3>
<BR>All PUBDEF records processed by the linker create entries in this class.&nbsp; The fields in the structure are:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct gbl_info {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addr48_ptr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addr;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; mod_index;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kind;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name[1];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR>The<TT> addr</TT> field contains the location in memory associated with this symbol.&nbsp; The value placed in this
field is the same that the linker places in the map file (i.e.&nbsp; unrelocated, as if the executable loads at location 0:0).
&nbsp;The field contains a 48 bit value (32 bit offset followed by a 16 bit segment).&nbsp; The<TT> mod_index</TT> field is
an index which identifies the module which defines the symbol (i.e.&nbsp; contained the [L]PUBDEF record).&nbsp; The<TT> kind</TT>
gives rudimentary typing information for the symbol.&nbsp; It consists of the following set of bits:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; BIT: 7 6 5 4 3 2 1 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | | | |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | | | +--- STATIC symbol</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | | +----- DATA symbol</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | +------- CODE symbol</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+--------- unused</TT>
<BR><BR>Bit zero is 1 if the global was defined by a LPUBDEF record and 0 if it was defined by a PUBDEF record.&nbsp; LPUBDEF
symbols are generated by the code generator for static symbols, so this allows a debugger to see static symbols even when
no compiler debug switches are being used.&nbsp; Bit one is 1 if the producer of the information is able to determine that
the symbol is a data symbol.&nbsp; Bit two is one if the producer is able to determine that the symbol is a code symbol.&nbsp;
Both bits may be zero if the producer is unable to determine whether the symbol is a code or data item.&nbsp; The final field,<TT>
name</TT> is a variable length array, with the first character indicating the length of the name, and the remaining characters
being the actual name of the symbol.
<H3 ID="Address_information_class"> Address information class </H3>
<BR>The address information class allows the debugger, given a memory address, to determine the module which defines that
memory address.&nbsp; The linker builds this class from the SEGDEF and GRPDEF records in the object files that it processes.
&nbsp;The class consists of an array of structures with the following fields:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct seg_info {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addr48_ptr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addr;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; num;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addr_info&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sects[1];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR>The<TT> addr</TT> field identifies the start of a segment in memory.&nbsp; This field contains the unrelocated value
of the segment starting address (i.e.&nbsp; as if the executable had been loaded at 0:0).&nbsp; The the low order 15 bits
of the next field,<TT> num</TT> tells how many of the<TT> sects</TT> entries there are in the structure.&nbsp; The top bit
of the field is a one when the segment belongs to &quot;NonSect&quot;.&nbsp; &quot;NonSect&quot; is the overlay section which
holds all program data that is not in the root or an overlay section.&nbsp; Typically this consists of DGROUP and FAR_DATA
segments.&nbsp; NonSect always is located at the highest address of all sections.&nbsp; It is preloaded by the overlay manager
and is never moved.&nbsp; If the segment does not belong to NonSect, the top bit of the<TT> num</TT> field is zero.&nbsp;
The<TT> sects</TT> field is a variable size array of structures.&nbsp; This addr_info structure contains the following fields:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct addr_info {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32&nbsp;&nbsp;&nbsp;&nbsp; size;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; mod_index;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR>The<TT> mod_index</TT> field indicates the module in the module information class which defines this piece of the
segment.&nbsp; The<TT> size</TT> field identifies how large a piece of the segment specified by the seg_info structure belongs
to the module.&nbsp; The starting address of the segment piece is given by adding all the previous size fields in the<TT>
sects</TT> array to the original starting address in the seg_info structure.
<BR><BR>The size of a seg_info structure may not exceed 60K.&nbsp; If a single physical segment would have more<TT> sects</TT>
than would fit into this restriction (<TT>num</TT> greater than 10238), it should be split into two separate seg_info structures.
<BR><BR>To identify the module that defines a location in memory, the debugger does the following:
<OL>
<LI>Walk down the array of seg_info structures until one is found with the same segment address as the location that is being
identified.&nbsp; If no such seg_info is found, or the starting offset of the segment is greater than the offset of the memory
location, then there is no defining module.
<LI>Walk down the array of addr_info's in the seg_info structure until an entry is found whose starting offset is less than
or equal to the memory location offset and whose ending offset is greater than the memory location offset.&nbsp; If there
is no such entry, there is no defining module.
<LI>Otherwise, the<TT> mod_offset</TT> field of the addr_info entry is added to the beginning of the module information class,
which gives a pointer to the module structure that defines the memory location.
</OL>
<H1 ID="Trap_File_Interface"> Trap File Interface </H1>
<BR>The Open Watcom debugger consists of a number of separate pieces of code.&nbsp; The main executable, WD.EXE (wd on UNIX
systems), provides a debugging `engine' and user interface.&nbsp; When the engine wishes to perform an operation upon the
program being debugged such as reading memory or setting a breakpoint, it creates a request structure and sends it to the
`trap file' (so called because under DOS, it contains the first level trap handlers).&nbsp; The trap file examines the request
structure, performs the indicated action and returns a result structure to the debugger.&nbsp; The debugger and trap files
also use Machine Architecture Description (MAD) files which abstract the CPU architecture.&nbsp; This design has the following
benefits:
<OL>
<LI>OS debugging interfaces tend to be wildly varying in how they are accessed.&nbsp; By moving all the OS specific interface
code into the trap file and having a defined interface to access it, porting the debugger becomes much easier.
<LI>By abstracting the machine architecture specifics through MAD files, it becomes possible to use one debugger for several
target CPU architectures (such as x86 and Alpha AXP).&nbsp; Unlike most other debuggers, the Open Watcom debugger is not tied
to a single host/target combination and if appropriate trap and MAD files are available, the debugger running on any host
can remotely debug any target.
<LI>The trap file does not have to actually perform the operation.&nbsp; Instead it could send the request out to a remote
server by a communication link such as a serial line or LAN.&nbsp; The remote server can retrieve the request, perform the
operation on the remote machine and send the results back via the link.&nbsp; This enables the debugger to debug applications
in cases where there are memory constraints or other considerations which prevent the debugger proper from running on the
remote system (such as Novell Netware 386).
</OL>
<BR>This document describes the interface initially used by version 4.0 of the WATCOM debugger (shipped with the 10.0 C/C++
and FORTRAN releases).&nbsp; It has been revised to describe changes incorporated in Watcom 11.0 release, as well as subsequent
Open Watcom releases.&nbsp; It is expected to be modified in future releases.&nbsp; Where possible, notification of expected
changes are given in the document, but all aspects are subject to revision.
<H2 ID="Some_Definitions"> Some Definitions </H2>
<BR>Next follow some general trap definitions.
<H3 ID="Byte_Order"> Byte Order </H3>
<BR>The trap file interface is defined to use little endian byte order.&nbsp; That is, the least significant byte is stored
at the lowest address.&nbsp; Little endian byte order was chosen for compatibility with existing trap files and tools.&nbsp;
Fixed byte order also eases network communication between debuggers and trap files running on machines with different byte
order.
<H3 ID="Pointer_Sizes"> Pointer Sizes </H3>
<BR>In a 16-bit hosted environment such as DOS, all pointers used by the trap file are &quot;far&quot; 16:16 pointers.&nbsp;
In a 32-bit environment such as Windows NT the pointers are &quot;near&quot; 0:32 pointers.
<H3 ID="Base_Types"> Base Types </H3>
<BR>A number of basic types are used in the interface.&nbsp; They are defined as follows:
<DL>
<DT><B><I>Type</I></B>
<DD><B><I>Definition</I></B>
<DT>unsigned_8
<DD>1 byte unsigned quantity
<DT>unsigned_16
<DD>2 byte unsigned quantity
<DT>unsigned_32
<DD>4 byte unsigned quantity
<DT>access_req
<DD>The first field of every request is of this type.&nbsp; It is a 1 byte field which identifies the request to be performed.
<DT>addr48_ptr
<DD>This type encapsulates the concept of a 16:32 pointer.&nbsp; All addresses in the debuggee memory are described with these.
&nbsp;The debugger always acts as if the debuggee were in a 32-bit large model environment since the 32-bit flat model and
all 16-bit memory models are subsets.&nbsp; The structure is defined as follows:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef struct {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32&nbsp;&nbsp;&nbsp; offset;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp; segment;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; } addr48_ptr;</TT>
<BR><BR>The<TT> segment</TT> field contains the segment of the address and the<TT> offset</TT> field stores the offset of
the address.
<DT>bytes
<DD>The type<TT> bytes</TT> is an array of unsigned_8.&nbsp; The length is provided by other means.&nbsp; Typically a field of
type<TT> bytes</TT> is the last one in a request and the length is calculated from the total length of the request.
<DT>string
<DD>The type<TT> string</TT> is actually an array of characters.&nbsp; The array is terminated by a null ('\0') character.&nbsp;
The length is provided by other means.&nbsp; Typically a field of type<TT> string</TT> is the last one in a request and the
length is calculated from the total length of the request.
<DT>trap_error
<DD>Some trap file requests return debuggee operating system error codes, notably the requests to perform file I/O on the remote
system.&nbsp; These error codes are returned as an unsigned_32.&nbsp; The debugger considers the value zero to indicate no
error.
<DT>trap_phandle
<DD>This is an<TT> unsigned_32</TT> which holds process (task) handle.&nbsp; A task handle is used to uniquely identify a debuggee
process.
<DT>trap_mhandle
<DD>This is an<TT> unsigned_32</TT> which holds a module handle.&nbsp; Typically the main executable will be one module, and on
systems which support DLLs or shared libraries, each library will be identified by a unique module handle.
</DL>
<H1 ID="The_Request_Interface"> The Request Interface </H1>
<BR>Next follow detailed description of interface elements.
<H2 ID="Request_Structure_"> Request Structure. </H2>
<BR>Each request is a composed of two sequences of bytes provided by the debugger called messages.&nbsp; The first set contains
the actual request code and whatever parameters that are required by the request.&nbsp; The second sequence is where the result
of the operation is to be stored by the trap file.
<BR><BR>The two sequences need not be contiguous.&nbsp; The sequences are described to the trap file through two arrays of
message entry structures.&nbsp; This allows the debugger to avoid unnecessary packing and unpacking of messages, since<TT>
mx_entry</TT>'s can be set to point directly at parameter/result buffers.
<BR><BR>Multiple requests are<B> not</B> allowed in a single message.&nbsp; The<TT> mx_entry</TT>'s are only used to provide
scatter/gather capabilities for one request at a time.
<BR><BR>The message entry structure is as follows (defined in<TT> trptypes.h</TT>):
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef struct {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;*ptr;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; len;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; } mx_entry;</TT>
<BR><BR>The<TT> ptr</TT> is pointing to a block of data for that message entry.&nbsp; The<TT> len</TT> field gives the length
of that block.&nbsp; One array of<TT> mx_entry</TT>'s describes the request message.&nbsp; The second array describes the
return message.
<BR><BR>It is not legal to split a message into arbitrary pieces with mx_entries.&nbsp; Each request documents where an<TT>
mx_entry</TT> is allowed to start with a line of dashes.
<H2 ID="The_Interface_Routines"> The Interface Routines </H2>
<BR>The trap file interface must provide three routines:<TT>&nbsp; TrapInit</TT>,<TT> TrapRequest</TT>, and<TT> TrapFini</TT>.
&nbsp;How the debugger determines the address of these routines after loading a trap file, as well as the calling convention
used, is system dependent and described later.&nbsp; These functions are prototyped in<TT> trpimp.h</TT>.
<H3 ID="TrapInit"> TrapInit </H3>
<BR>This function initializes the environment for proper operation of<TT> TrapRequest</TT>.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; trap_version TRAPENTRY TrapInit( char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *parm,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; *error,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8 remote</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; );</TT>
<BR><BR>The<TT> parm</TT> is a string that the user passes to the trap file.&nbsp; Its interpretation is completely up to
the trap file.&nbsp; In the case of the Open Watcom debugger, all the characters following the semicolon in the<TT> /TRAP</TT>
option are passed as the<TT> parm</TT>.&nbsp; For example:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; wd /trap=nov;testing program</TT>
<BR><BR>The<TT> parm</TT> would be &quot;testing&quot;.&nbsp; Any error message will be returned in<TT> error</TT>.&nbsp;
The<TT> remote</TT> field is a zero if the Open Watcom debugger is loading the trap file and a one if a remote server is loading
it.&nbsp; This function returns a structure<TT> trap_version</TT> of the following form (defined in<TT> trptypes.h</TT>):
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef struct {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp; major;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp; minor;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp; remote;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; } trap_version;</TT>
<BR><BR>The<TT> major</TT> field contains the major version number of the trap file while the<TT> minor</TT> field tells the
minor version number of the trap file.<TT>&nbsp; Major</TT> is changed whenever there is a modification made to the trap file
that is not upwardly compatable with previous versions.<TT>&nbsp; Minor</TT> increments by one whenever a change is made to
the trap file that is upwardly compatible with previous versions.&nbsp; The current major verion is 1, the current minor version
is 3.&nbsp; The<TT> remote</TT> field informs the debugger whether the trap file communicates with a remote machine.
<BR><BR><TT>TrapInit</TT> must be called before using<TT> TrapRequest</TT> to send a request.&nbsp; Failure to do so may result
in unpredictable operation of<TT> TrapRequest</TT>.
<H3 ID="TrapRequest"> TrapRequest </H3>
<BR>All requests between the server and the remote trap file are handled by TrapRequest.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned TRAPENTRY TrapRequest( unsigned num_in_mx,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mx_entry *mx_in,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned num_out_mx,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mx_entry *mx_out</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; );</TT>
<BR><BR>The<TT> mx_in</TT> points to an array of request mx_entry's.&nbsp; The<TT> num_in_mx</TT> field contains the number
of elements of the array.&nbsp; Similarly, the<TT> mx_out</TT> will point to an array of return mx_entry's.&nbsp; The number
of elements will be given by the<TT> num_out_mx</TT> field.&nbsp; The total number of bytes actually filled in to the return
message by the trap file is returned by the function (this may be less than the total number of bytes described by the<TT>
mx_out</TT> array).
<BR><BR>Since every request must start with an<TT> access_req</TT> field, the minimum size of a request message is one byte.
<BR><BR>Some requests do not require a return message.&nbsp; In this case, the program invoking TrapRequest<B> must</B> pass
zero for<TT> num_out_mx</TT> and NULL for<TT> mx_out</TT>.
<H4 ID="Request_Example"> Request Example </H4>
<BR>The request REQ_READ_MEM needs the memory address and length of memory to read as input and will return the memory block
in the output message.&nbsp; To read 30 bytes of memory from address 0x0010:0x8000 into a buffer, we can write:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; mx_entry&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in[1];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; mx_entry&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; out[1];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned char&nbsp;&nbsp; buffer[30];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct in_msg_def {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
req;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addr48_ptr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
addr;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; len;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; } in_msg = { REQ_READ_MEM, { 0x8000, 0x0010 }, sizeof( buffer ) };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16 mem_blk_len;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; in[0].ptr = &amp;in_msg;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; in[0].len = sizeof( in_msg );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; out[0].ptr = &amp;buffer;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; out[0].len = sizeof( buffer );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; mem_blk_len = TrapRequest( 1, in, 1, out );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; if( mem_blk_length != sizeof( buffer ) ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Error in reading memory\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;OK\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The program will print &quot;OK&quot; if it has transferred 30 bytes of data from the debuggee's address space to
the<TT> buffer</TT> variable.&nbsp; If less than 30 bytes is transfered, an error message is printed out.
<H3 ID="TrapFini"> TrapFini </H3>
<BR>The function terminates the link between the debugger and the trap file.&nbsp; It should be called after finishing all
access requests.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void TRAPENTRY TrapFini( void );</TT>
<BR><BR>After calling<TT> TrapFini</TT>, it is illegal to call<TT> TrapRequest</TT> without calling<TT> TrapInit</TT> again.
<H1 ID="The_Requests"> The Requests </H1>
<BR>This section descibes the individual requests, their parameters, and their return values.&nbsp; A line of dashes indicates
where an<TT> mx_entry</TT> is allowed (but not required) to start.&nbsp; The debugger allows (via REQ_GET_SUPPLEMENTARY_SERVICE/REQ_PERFORM_SUPPLEMENTARY_SERVICE)
optional components to be implemented only on specific systems.
<BR>The numeric value of the request which is placed in the<TT> req</TT> field follows the symbolic name in parentheses.
<H2 ID="Core_Requests"> Core Requests </H2>
<BR>These requests need to be implemented in all versions of the trap file, although some of them may only be stub implementations
in some environments.&nbsp; Note that structures suitable for individual requests are declared in<TT> trpcore.h</TT>.
<H3 ID="REQ_CONNECT_L0R"> REQ_CONNECT (0) </H3>
<BR>Request to connect to the remote machine.&nbsp; This must be the first request made.
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; major;&nbsp;&nbsp; &lt;-+- struct trap_version</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; minor;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; remote;&nbsp; &lt;-+</TT>
<BR><BR>The<TT> req</TT> field contains the request.&nbsp; The<TT> trap_version</TT> structure tells the version of the program
making the request.&nbsp; The<TT> major</TT> field contains the major version number of the trap file while the<TT> minor</TT>
field tells the minor version number of the trap file.&nbsp; The<TT> major</TT> is changed whenever there is a modification
made to the trap file that is not upwardly compatable with previous versions.&nbsp; The<TT> minor</TT> increments by one whenever
a change is made to the trap file that is upwardly compatable with previous versions.&nbsp; The current major version is 1,
the current minor version is 3.&nbsp; The<TT> remote</TT> field informs the trap file whether a remote server is between the
Open Watcom debugger and the trap file.
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16 max_msg_size</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ----------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err_msg</TT>
<BR><BR>If error has occurred, the<TT> err_msg</TT> field will returns the error message string.&nbsp; If there is no error,<TT>
error_msg</TT> returns a null character and the field<TT> max_msg_size</TT> will contain the allowed maximum size of a message
in bytes.&nbsp; Any message (typically reading/writing memory or files) which would require more than the maximum number of
bytes to transmit or receive must be broken up into multiple requests.&nbsp; The minimum acceptable value for this field is
256.
<H3 ID="REQ_DISCONNECT_L1R"> REQ_DISCONNECT (1) </H3>
<BR>Request to terminate the link between the local and remote machine.&nbsp; After this request, a REQ_CONNECT must be the
next one made.
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</TT>
<BR><BR>The<TT> req</TT> field contains the request.
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; NONE</TT>
<H3 ID="REQ_SUSPEND_L2R"> REQ_SUSPEND (2) </H3>
<BR>Request to suspend the link between the server and the remote trap file.&nbsp; The debugger issues this message just before
it spawns a sub-shell (the &quot;system&quot; command).&nbsp; This allows a remote server to enter a state where it allows
other trap files to connect to it (normally, once a remote server has connected to a trap file, the remote link will fail
any other attempts to connect to it).&nbsp; This allows the user for instance to start up an RFX process and transfer any
missing files to the remote machine before continuing the debugging process.
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</TT>
<BR><BR>The<TT> req</TT> field contains the request.
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; NONE</TT>
<H3 ID="REQ_RESUME_L3R"> REQ_RESUME (3) </H3>
<BR>Request to resume the link between the server and the remote trap file.&nbsp; The debugger issues this request when the
spawned sub-shell exits.
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</TT>
<BR><BR>The<TT> req</TT> field contains the request.
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; NONE</TT>
<H3 ID="REQ_GET_SUPPLEMENTARY_SERVICE_L4R"> REQ_GET_SUPPLEMENTARY_SERVICE (4) </H3>
<BR>Request to obtain a supplementary service id.
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp; req</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; service_name</TT>
<BR><BR>The<TT> req</TT> field contains the request.&nbsp; The<TT> service_name</TT> field contains a string identifying the
supplementary service.&nbsp; This string is case insensitive.
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; trap_shandle&nbsp;&nbsp;&nbsp; id;</TT>
<BR><BR>The<TT> err</TT> field is non-zero if something went wrong in obtaining or initializing the service.<TT>&nbsp; Id</TT>
is the identifier for a particular supplementary service.&nbsp; It need not be the same from one invocation of the trap file
to another.&nbsp; If both it and the<TT> err</TT> field are zero, it means that the service is not available from this trap
file.
<BR><BR><B>NOTE:</B>&nbsp; integrated with the debugger.&nbsp; There would be two components, one to be added to the debugger
and one to be added to the trap file.&nbsp; The two pieces could communicate with each other via the supplementary services
mechanism.
<H3 ID="REQ_PERFORM_SUPPLEMENTARY_SERVICE_L5R"> REQ_PERFORM_SUPPLEMENTARY_SERVICE (5) </H3>
<BR>Request to perform a supplementary service.
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp; req</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32 service_id</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unspecified</TT>
<BR><BR>The<TT> req</TT> field contains the request.&nbsp; The<TT> service_id</TT> field indicates which service is being
requested.&nbsp; The remainder of the request is specified by the individual supplementary service provider.
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unspecified</TT>
<BR><BR>The return message is specified by the individual supplementary service provider.
<H3 ID="REQ_GET_SYS_CONFIG_L6R"> REQ_GET_SYS_CONFIG (6) </H3>
<BR>Request to get system information from the remote machine.
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</TT>
<BR><BR>The<TT> req</TT> field contains the request.
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp; cpu;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp; fpu;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp; osmajor;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp; osminor;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp; os;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp; huge_shift;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; mad_handle&nbsp; mad;</TT>
<BR><BR>The<TT> mad</TT> field specifies the MAD (Machine Architecture Description) in use and determines how the other fields
will be interpreted.&nbsp; Currently the following MADs are used:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; MAD_X86&nbsp; - Intel Architecture IA-32 compatible</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; MAD_X64&nbsp; - Intel Architecture X64 compatible</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; MAD_AXP&nbsp; - Alpha Architecture</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; MAD_PPC&nbsp; - PowerPC Architecture</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; MAD_MIPS - MIPS Architecture</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; MAD_MSJ&nbsp; - Java Virtual Machine (Microsoft)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; MAD_JVM&nbsp; - Java Virtual Machine (Sun)</TT>
<BR><BR>The<TT> cpu</TT> fields returns the type of the remote CPU.&nbsp; The size of that field is unsigned_8.&nbsp; Possible
CPU types for MAD_X86 are:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; bits 0-3</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X86_86&nbsp; = 0&nbsp;&nbsp; - 8086</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X86_186 = 1&nbsp;&nbsp; - 80186</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X86_286 = 2&nbsp;&nbsp; - 80286</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X86_386 = 3&nbsp;&nbsp; - 80386</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X86_486 = 4&nbsp;&nbsp; - 80486</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X86_586 = 5&nbsp;&nbsp; - Pentium</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X86_686 = 6&nbsp;&nbsp; - Pentium Pro/II/III</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X86_P4&nbsp; = 15&nbsp; - Pentium 4</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; bit&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - MMX registers</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; bit&nbsp; 5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - XMM registers</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; bits 6,7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - unused</TT>
<BR><BR>The<TT> fpu</TT> fields tells the type of FPU.&nbsp; The size of the field is unsigned_8.&nbsp; FPU types for MAD_X86
include:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; X86_EMU = -1&nbsp;&nbsp;&nbsp;&nbsp; - Software emulated FPU</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; X86_NO&nbsp; =&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; - No FPU</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; X86_87&nbsp; =&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp; - 8087</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; X86_287 =&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp; - 80287</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; X86_387 =&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp; - 80387</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; X86_487 =&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp; - 486 integrated FPU</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; X86_587 =&nbsp; 5&nbsp;&nbsp;&nbsp;&nbsp; - Pentium integrated FPU</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; X86_587 =&nbsp; 6&nbsp;&nbsp;&nbsp;&nbsp; - Pentium Pro/II/III integrated FPU</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; X86_P47 =&nbsp; 15&nbsp;&nbsp;&nbsp; - Pentium 4 integrated FPU</TT>
<BR><BR>The<TT> osmajor</TT> and<TT> osminor</TT> contains the major and minor version number for the operating system of
the remote machine.&nbsp; The type of operating system can be found in<TT> os</TT> field.&nbsp; The size of this field is
unsigned_8.&nbsp; The OS can be :
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; OS_IDUNNO&nbsp;&nbsp;&nbsp; =&nbsp; 0&nbsp;&nbsp; - Unknown operating system</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; OS_DOS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&nbsp; 1&nbsp;&nbsp; - DOS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; OS_OS2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&nbsp; 2&nbsp;&nbsp; - OS/2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; OS_PHAR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&nbsp; 3&nbsp;&nbsp; - Phar Lap 386 DOS Extender</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; OS_ECLIPSE&nbsp;&nbsp; =&nbsp; 4&nbsp;&nbsp; - Eclipse 386 DOS Extender (obsolete)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; OS_NW386&nbsp;&nbsp;&nbsp;&nbsp; =&nbsp; 5&nbsp;&nbsp; - NetWare 386</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; OS_QNX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&nbsp; 6&nbsp;&nbsp; - QNX 4.x</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; OS_RATIONAL&nbsp; =&nbsp; 7&nbsp;&nbsp; - DOS/4G or compatible</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; OS_WINDOWS&nbsp;&nbsp; =&nbsp; 8&nbsp;&nbsp; - Windows 3.x</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; OS_PENPOINT&nbsp; =&nbsp; 9&nbsp;&nbsp; - PenPoint (obsolete)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; OS_NT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 10&nbsp;&nbsp; - Win32</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; OS_AUTOCAD&nbsp;&nbsp; = 11&nbsp;&nbsp; - ADS/ADI development (obsolete)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; OS_NEUTRINO&nbsp; = 12&nbsp;&nbsp; - QNX 6.x</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; OS_LINUX&nbsp;&nbsp;&nbsp;&nbsp; = 13&nbsp;&nbsp; - Linux</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; OS_FREEBSD&nbsp;&nbsp; = 14&nbsp;&nbsp; - Free BSD</TT>
<BR><BR>The<TT> huge_shift</TT> field is used to determine the shift needed for huge arithmetic in that system.&nbsp; It stores
the number of left shifts required in order to calculate the next segment correctly.&nbsp; It is 12 for real mode programs.
&nbsp;The value in a protect mode environment must be obtained from the OS of the debuggee machine.&nbsp; This field is only
relevant for 16-bit segmented architectures.
<H3 ID="REQ_MAP_ADDR_L7R"> REQ_MAP_ADDR (7) </H3>
<BR>Request to map the input address to the actual address of the remote machine.&nbsp; The addresses in the symbolic information
provided by the linker do not reflect any relocation performed on the executable by the system loader.&nbsp; This request
obtains that relocation information so that the debugger can update its addresses.
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; addr48_ptr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in_addr;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; trap_mhandle&nbsp;&nbsp;&nbsp; mod_handle;</TT>
<BR><BR>The<TT> req</TT> field contains the request.&nbsp; The<TT> in_addr</TT> tells the address to map.&nbsp; The<TT> mod_handle</TT>
field identifies the module which the address is from.&nbsp; The value from this field is obtained by REQ_PROG_LOAD or REQ_GET_LIB_NAME.
&nbsp;There are two magical values for the<TT> in_addr.segment</TT> field.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; MAP_FLAT_CODE_SELECTOR&nbsp; = -1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; MAP_FLAT_DATA_SELECTOR&nbsp; = -2</TT>
<BR><BR>When the<TT> in_addr.segment</TT> equals one of these values, the debugger does not have a map segment value and is
requesting that the trap file performs the mapping as if the given offset was in the flat address space.
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; addr48_ptr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; out_addr</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; addr48_off&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lo_bound;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; addr48_off&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hi_bound;</TT>
<BR><BR>The mapped address is returned in<TT> out_addr</TT>.&nbsp; Note that in addition to the segment portion being modified,
the offset of the portion of the address may be adjusted as well if the loader performs offset relocations (like OS/2 2.x
or Windows NT).&nbsp; The<TT> lo_bound</TT> and<TT> hi_bound</TT> fields identify the lowest and highest input offsets for
which this mapping is valid.&nbsp; If the debugger needs to map another address whose input segment value is the same as a
previous request, and the input offset falls within the valid range identified by the return of that previous request, it
can perform the mapping itself and not bother sending the request to the trap file.
<H3 ID="REQ_CHECKSUM_MEM_L8R"> REQ_CHECKSUM_MEM (8) </H3>
<BR>Request to calculate the checksum for a block of memory in the debuggee's address space.&nbsp; This is used by the debugger
to determine if the contents of the memory block have changed since the last time it was read.&nbsp; Since only a four byte
checksum has to be transmitted back, it is more efficient than actually reading the memory again.&nbsp; The debugger does
not care how the checksum is calculated.
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; addr48_ptr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in_addr;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; len;</TT>
<BR><BR>The<TT> req</TT> field stores the request.&nbsp; The<TT> in_addr</TT> contains the starting address and the<TT> len</TT>
field tells how large the block of memory is.
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32&nbsp;&nbsp;&nbsp;&nbsp; result</TT>
<BR><BR>The checksum will be returned in<TT> result</TT>.
<H3 ID="REQ_READ_MEM_L9R"> REQ_READ_MEM (9) </H3>
<BR>Request to read a block of memory.
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; addr48_ptr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mem_addr;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; len;</TT>
<BR><BR>The<TT> mem_addr</TT> contains the address of the memory block to read from the remote machine.&nbsp; The length of
the block is determined by<TT> len</TT>.&nbsp; The memory data will be copied to output message.
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; bytes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data</TT>
<BR><BR>The<TT> data</TT> field stores the memory block read in.&nbsp; The length of this memory block is given by the return
value from TrapRequest.&nbsp; If error has occurred in reading memory, the length of the data returns will not be equal to
the number of bytes requested.
<H3 ID="REQ_WRITE_MEM_L10R"> REQ_WRITE_MEM (10) </H3>
<BR>Request to write a block of memory.
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; addr48_ptr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mem_addr</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; bytes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data</TT>
<BR><BR>The<TT> data</TT> field stores the memory data to be transferred.&nbsp; The data will be stored in the debuggee's
address space starting at the address in the<TT> mem_addr</TT> field.
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16 len</TT>
<BR><BR>The<TT> len</TT> field tells the length of memory block actually written to the debuggee machine.&nbsp; If error has
occurred in writing the memory, the length returned will not be equal to the number of bytes requested.
<H3 ID="REQ_READ_IO_L11R"> REQ_READ_IO (11) </H3>
<BR>Request to read data from I/O address space of the debuggee.
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32&nbsp;&nbsp;&nbsp;&nbsp; IO_offset</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; len</TT>
<BR><BR>The<TT> IO_offset</TT> contains the I/O address of the debuggee machine.&nbsp; The length of the block is determined
by<TT> len</TT>.&nbsp; It must be 1, 2 or 4 bytes.&nbsp; The data will be copied from<TT> IO_offset</TT> to the return message.
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; bytes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data</TT>
<BR><BR>The<TT> data</TT> field stores the memory block read in.&nbsp; The length of this memory block is given by the return
value from TrapRequest.&nbsp; If an error has occurred in reading, the length returned will not be equal to the number of
bytes requested.
<H3 ID="REQ_WRITE_IO_L12R"> REQ_WRITE_IO (12) </H3>
<BR>Request to write data to the I/O address space of the debuggee.
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32&nbsp;&nbsp;&nbsp;&nbsp; IO_offset</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; bytes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data</TT>
<BR><BR>The<TT> IO_offset</TT> contains the I/O address of the debuggee machine.&nbsp; The data stored in<TT> data</TT> field
will be copied to<TT> IO_offset</TT> on the debuggee machine.
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp; len</TT>
<BR><BR>The<TT> len</TT> field tells the number of bytes actually written out.&nbsp; If an error has occurred in writing,
the length returned will not be equal to the number of bytes requested.
<H3 ID="REQ_PROG_GO_L13RDREQ_PROG_STEP_L14R"> REQ_PROG_GO (13)/REQ_PROG_STEP (14) </H3>
<BR>Requests to execute the debuggee.&nbsp; REQ_PROG_GO causes the debuggee to resume execution, while REQ_PROG_STEP requests
only a single machine instruction to be executed before returning.&nbsp; In either case, this request will return when a breakpoint,
watchpoint, machine exception or other significant event has been encountered.&nbsp; While executing, a trap file is allowed
to return spurious COND_WATCH indications.&nbsp; The debugger always checks its own watchpoint table for changes before reporting
to the user.&nbsp; This means that a legal implementation of a trap file (but<B> very</B> inefficient) can just single step
the program and return COND_WATCH for every instruction when there are active watchpoints present.
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</TT>
<BR><BR>The request is in<TT> req</TT> field.
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; addr48_ptr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stack_pointer</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; addr48_ptr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; program_counter</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; conditions</TT>
<BR><BR>The<TT> stack_pointer</TT> and<TT> program_counter</TT> fields store the latest values of SS:ESP and CS:EIP (or their
non-x86 equivalents) respectively.&nbsp; The<TT> conditions</TT> informs the debugger what conditions have changed since execution
began.&nbsp; It contains the following flags:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Bit 0&nbsp;&nbsp; : COND_CONFIG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;- Configurations change</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Bit 1&nbsp;&nbsp; : COND_SECTIONS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - Program
overlays change</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Bit 2&nbsp;&nbsp; : COND_LIBRARIES&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - Libraries
(DLL) change</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Bit 3&nbsp;&nbsp; : COND_ALIASING&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - Alias
change</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Bit 4&nbsp;&nbsp; : COND_THREAD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
- Thread change</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Bit 5&nbsp;&nbsp; : COND_THREAD_EXTRA&nbsp;&nbsp;&nbsp;&nbsp; - Thread extra change</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Bit 6&nbsp;&nbsp; : COND_TRACE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;- Trace point occurred</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Bit 7&nbsp;&nbsp; : COND_BREAK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;- Break point occurred</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Bit 8&nbsp;&nbsp; : COND_WATCH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;- Watch point occurred</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Bit 9&nbsp;&nbsp; : COND_USER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; - User interrupt</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Bit 10&nbsp; : COND_TERMINATE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - Program terminated</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Bit 11&nbsp; : COND_EXCEPTION&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - Machine exception</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Bit 12&nbsp; : COND_MESSAGE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - Message
to be displayed</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Bit 13&nbsp; : COND_STOP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;- Debuggee wants to stop</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Bit 14&nbsp; : COND_RUNNING&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - Debuggee
is running</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Bit 15&nbsp; :&nbsp; not used</TT>
<BR><BR>When a bit is off, the debugger avoids having to make additional requests to determine the new state of the debuggee.
&nbsp;If the trap file is not sure that a particular item has changed, or if it is expensive to find out, it should just turn
the bit on.
<H3 ID="REQ_PROG_LOAD_L15R"> REQ_PROG_LOAD (15) </H3>
<BR>Request to load a program.
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; true_argv</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; bytes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; argv</TT>
<BR><BR>The<TT> true_argv</TT> field indicates whether the argument consists of a single string, or a true C-style argument
vector.&nbsp; This field is set to be one for a true argument vector and zero otherwise.&nbsp; The<TT> argv</TT> is a set
of zero-terminated strings, one following each other.&nbsp; The first string gives the name of the program to be loaded.&nbsp;
The remainder of the<TT> argv</TT> field contains the program's arguments.&nbsp; The arguments can be a single string or an
array of strings.
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; trap_phandle&nbsp;&nbsp;&nbsp; task_id</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; trap_mhandle&nbsp;&nbsp;&nbsp; mod_handle</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; flags</TT>
<BR><BR>The<TT> err</TT> field returns the error code while loading the program.&nbsp; The<TT> task_id</TT> shows the task
(process) ID for the program loaded.&nbsp; The<TT> mod_handle</TT> is the system module identification for the executable
image.&nbsp; It is used as input to the REQ_MAP_ADDR request.&nbsp; The<TT> flags</TT> field contains the following information:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Bit 0&nbsp;&nbsp; : LD_FLAG_IS_BIG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; - 32-bit program (obsolete)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Bit 1&nbsp;&nbsp; : LD_FLAG_IS_PROT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;- Protected mode (obsolete)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Bit 2&nbsp;&nbsp; : LD_FLAG_IS_STARTED&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - Program
already started</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Bit 3&nbsp;&nbsp; : LD_FLAG_IGNORE_SEGMENTS&nbsp;&nbsp; - Ignore segments (flat)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Bit 4&nbsp;&nbsp; : LD_FLAG_HAVE_RUNTIME_DLLS - DLL load breaks supported</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Bit 5&nbsp;&nbsp; : LD_FLAG_DISPLAY_DAMAGED&nbsp;&nbsp; - Debugger must repaint screen</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Bit 6,7 : not used</TT>
<H3 ID="REQ_PROG_KILL_L16R"> REQ_PROG_KILL (16) </H3>
<BR>Request to kill the program.
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; trap_phandle&nbsp;&nbsp;&nbsp; task_id</TT>
<BR><BR>The<TT> req</TT> field contains the request.&nbsp; The<TT> task_id</TT> field (obtained from REQ_PROG_LOAD) identifies
the program to be killed.
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</TT>
<BR><BR>The<TT> err</TT> field returns the error code of the OS kill program operation.
<H3 ID="REQ_SET_WATCH_L17R"> REQ_SET_WATCH (17) </H3>
<BR>Request to set a watchpoint at the address given.
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; addr48_ptr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; watch_addr</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size</TT>
<BR><BR>The address of the watchpoint is given by the<TT> watch_addr</TT> field.&nbsp; The<TT> size</TT> field gives the number
of bytes to be watched.
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32&nbsp;&nbsp;&nbsp;&nbsp; multiplier</TT>
<BR><BR>The<TT> err</TT> field returns the error code if the setting failed.&nbsp; If the setting of the watchpoint worked,
the 31 low order bits of<TT> multiplier</TT> indicate the expected slow down of the program when it's placed into execution.
&nbsp;The top bit of the field is set to one if a debug register is being used for the watchpoint, and zero if the watchpoint
is being done by software.
<H3 ID="REQ_CLEAR_WATCH_L18R"> REQ_CLEAR_WATCH (18) </H3>
<BR>Request to clear a watchpoint at the address given.&nbsp; The trap file may assume all watch points are cleared at once.
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; addr48_ptr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; watch_addr</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size</TT>
<BR><BR>The address of the watch point is given by the<TT> watch_addr</TT> field.&nbsp; The<TT> size</TT> field gives the
size of the watch point.
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; NONE</TT>
<H3 ID="REQ_SET_BREAK_L19R"> REQ_SET_BREAK (19) </H3>
<BR>Request to set a breakpoint at the address given.
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; addr48_ptr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break_addr</TT>
<BR><BR>The address of the break point is given by the<TT> break_addr</TT> field.
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32&nbsp;&nbsp;&nbsp;&nbsp; old</TT>
<BR><BR>The<TT> old</TT> field returns the original byte(s) at the address<TT> break_addr</TT>.
<H3 ID="REQ_CLEAR_BREAK_L20R"> REQ_CLEAR_BREAK (20) </H3>
<BR>Request to clear a breakpoint at the address given.&nbsp; The trap file may assume all breakpoints are cleared at once.
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; addr48_ptr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break_addr</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32&nbsp;&nbsp;&nbsp;&nbsp; old</TT>
<BR><BR>The address of the break point is given by the<TT> break_addr</TT> field.&nbsp; The<TT> old</TT> field holds the old
instruction returned from the REQ_SET_BREAK request.
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; NONE</TT>
<H3 ID="REQ_GET_NEXT_ALIAS_L21R"> REQ_GET_NEXT_ALIAS (21) </H3>
<BR>Request to get alias information for a segment.&nbsp; In some protect mode environments (typically 32-bit flat) two different
selectors may refer to the same physical memory.&nbsp; Which selectors do this is important to the debugger in certain cases
(so that symbolic information is properly displayed).
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; seg</TT>
<BR><BR>The<TT> seg</TT> field contains the segment.&nbsp; To get the first alias, put zero in this field.
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; seg</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; alias</TT>
<BR><BR>The<TT> seg</TT> field contains the next segment where an alias appears.&nbsp; If this field returns zero, it implies
no more aliases can be found.&nbsp; The<TT> alias</TT> field returns the alias of the input segment.&nbsp; Zero indicates
a previously set alias should be deleted.
<H3 ID="REQ_SET_USER_SCREEN_L22R"> REQ_SET_USER_SCREEN (22) </H3>
<BR>Request to make the debuggee's screen visible.
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</TT>
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; NONE</TT>
<H3 ID="REQ_SET_DEBUG_SCREEN_L23R"> REQ_SET_DEBUG_SCREEN (23) </H3>
<BR>Request to make the debugger's screen visible.
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</TT>
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; NONE</TT>
<H3 ID="REQ_READ_USER_KEYBOARD_L24R"> REQ_READ_USER_KEYBOARD (24) </H3>
<BR>Request to read the remote keyboard input.
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; wait</TT>
<BR><BR>The request will be time out if it waits longer than the period specifies in the<TT> wait</TT> field.&nbsp; The waiting
period is measured in seconds.&nbsp; A value of zero means to wait forever.
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; key</TT>
<BR><BR>The<TT> key</TT> field returns the input character from remote machine.
<H3 ID="REQ_GET_LIB_NAME_L25R"> REQ_GET_LIB_NAME (25) </H3>
<BR>Request to get the name of a newly loaded library (DLL).
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; trap_mhandle&nbsp;&nbsp;&nbsp; mod_handle</TT>
<BR><BR>The<TT> mod_handle</TT> field contains the library handle.&nbsp; It should be zero to get the name of the first DLL
or the value from the<TT> mod_handle</TT> of a previous request.
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; trap_mhandle&nbsp;&nbsp;&nbsp; mod_handle</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ---------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name</TT>
<BR><BR>The<TT> mod_handle</TT> field contains the library handle.&nbsp; It contains zero if there are no more DLL names to
be returned.&nbsp; The name of the library will be returned in<TT> name</TT> field.&nbsp; If the<TT> name</TT> field is an
empty string (consists just of the '\0' character), then this is a indication that the DLL indicated by the given handle has
been unloaded, and the debugger should remove any symbolic information for the image.&nbsp; It is an error to attempt to remove
a handle that has not been loaded in a previous REQ_GET_LIB_NAME request.
<H3 ID="REQ_GET_ERR_TEXT_L26R"> REQ_GET_ERR_TEXT (26) </H3>
<BR>Request to get the error message text for an error code.
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</TT>
<BR><BR>The<TT> err</TT> field contains the error code number of the error text requested.
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error_msg</TT>
<BR><BR>The error message text will be returned in<TT> error_msg</TT> field.
<H3 ID="REQ_GET_MESSAGE_TEXT_L27R"> REQ_GET_MESSAGE_TEXT (27) </H3>
<BR>Request to retrieve generic message text.&nbsp; After a REQ_PROG_LOAD, REQ_PROG_GO or REQ_PROG_STEP has returned with
COND_MESSAGE or COND_EXCEPTION, the debugger will make this request to obtain the message text.&nbsp; In the case of a COND_EXCEPTION
return text describing the machine exception that caused the return to the debugger.&nbsp; Otherwise return whatever generic
message text that the trap file wants to display to the user.
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</TT>
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; flags</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ---------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; msg</TT>
<BR><BR>The message text will be returned in the<TT> msg</TT> field.&nbsp; The<TT> flags</TT> contains a number of bits which
control the next action of the debugger.&nbsp; They are:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Bit 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : MSG_NEWLINE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Bit 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : MSG_MORE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Bit 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : MSG_WARNING</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Bit 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : MSG_ERROR</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Bit 4 - 7&nbsp;&nbsp; : not used</TT>
<BR><BR>The MSG_NEWLINE bit indicates that the debugger should scroll its display to a new line after displaying the message.
&nbsp;The MSG_MORE bit indicates that there is another line of output to come and the debugger should make another REQ_GET_MESSAGE_TEXT.
&nbsp;MSG_WARNING indicates that the message is a warning level message while MSG_ERROR is an error level message.&nbsp; If
neither of these bits are on, the message is merely informational.
<H3 ID="REQ_REDIRECT_STDIN_L28RDREQ_REDIRECT_STDOUT_L29R"> REQ_REDIRECT_STDIN (28)/REQ_REDIRECT_STDOUT (29) </H3>
<BR>Request to redirect the standard input (REQ_REDIRECT_STDIN) or standard output (REQ_REDIRECT_STDOUT) of the debuggee.
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name</TT>
<BR><BR>The file name to be redirected to/from is given by the<TT> name</TT> field.
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</TT>
<BR><BR>When an error has occurred, the<TT> err</TT> field contains an error code indicating the type of error that has been
detected.
<H3 ID="REQ_SPLIT_CMD_L30R"> REQ_SPLIT_CMD (30) </H3>
<BR>Request to split the command line into the command name and parameters.
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmd</TT>
<BR><BR>The<TT> cmd</TT> field contains the command.&nbsp; Command can be a single command line or an array of command strings.
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; cmd_end</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; parm_start</TT>
<BR><BR>The<TT> cmd_end</TT> field tells the position in command line where the command name ends.&nbsp; The<TT> parm_start</TT>
field stores the position where the program arguments begin.
<H3 ID="REQ_READ_REGS_L31R"> REQ_READ_REGS (31) </H3>
<BR>Request to read CPU register contents.&nbsp; The data returned depends on the target architecture and is defined by the
MAD file.
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</TT>
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unspecified</TT>
<BR><BR>The return message content is specific to the MAD in use and will contain a<TT> mad_registers</TT> union (defined
in<TT> madtypes.h</TT>).
<H3 ID="REQ_WRITE_REGS_L32R"> REQ_WRITE_REGS (32) </H3>
<BR>Request to write CPU register contents.&nbsp; The data is target architecture specific.
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unspecified</TT>
<BR><BR>The message content is specific to the MAD in use and will contain a<TT> mad_registers</TT> union.
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; NONE</TT>
<H3 ID="REQ_MACHINE_DATA_L33R"> REQ_MACHINE_DATA (33) </H3>
<BR>Request to retrieve machine specific data.
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info_type;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; addr48_ptr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addr;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -----------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unspecified</TT>
<BR><BR>The<TT> info_type</TT> field specifies what kind of information should be returned and<TT> addr</TT> determines the
address for which the information is requested.&nbsp; The remainder of the message is MAD specific.
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; addr48_off&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cache_start;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; addr48_off&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cache_end;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -----------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unspecified</TT>
<BR><BR>The return message content is specific to the MAD in use.
<H2 ID="File_IDO_requests"> File I/O requests </H2>
<BR>This section describes requests that deal with file input/output on the target (debuggee) machine.&nbsp; These requests
are actually performed by the core request REQ_PERFORM_SUPPLEMENTARY_SERVICE and appropriate service ID.&nbsp; The following
descriptions do not show that &quot;prefix&quot; to the request messages.
<BR><BR>The service name to be used in the REQ_GET_SUPPLEMENTARY_SERVICE is &quot;Files&quot;.
<BR><BR>The file requests use a new basic type in addition to the ones already described:
<DL>
<DT><B><I>Type</I></B>
<DD><B><I>Definition</I></B>
<DT>trap_fhandle
<DD>This is an<TT> unsigned_64</TT> which holds a debuggee file handle.
</DL>
<H3 ID="REQ_FILE_GET_CONFIG_L0R"> REQ_FILE_GET_CONFIG (0) </H3>
<BR>Request to retreive characteristics of the remote file system.
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</TT>
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ext_separator;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; path_separator[3];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; newline[2];</TT>
<BR><BR>The<TT> ext_separator</TT> contains the separator for file name extensions.&nbsp; The possible path separators can
be found in array<TT> path_separator</TT>.&nbsp; The first one is the &quot;preferred&quot; path separator for that operating
system.&nbsp; This is the path separator that the debugger will use if it needs to construct a file name for the remote system.
&nbsp;The new line control characters are stored in array<TT> newline</TT>.&nbsp; If the operating system uses only a single
character for newline, put a zero in the second element.
<H3 ID="REQ_FILE_OPEN_L1R"> REQ_FILE_OPEN (1) </H3>
<BR>Request to create/open a file.
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name</TT>
<BR><BR>The name of the file to be opened is given by<TT> name</TT>.&nbsp; The<TT> mode</TT> field stores the access mode
of the file.&nbsp; The following bits are defined:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Bit 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp; TF_READ</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Bit 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp; TF_WRITE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Bit 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp; TF_CREATE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Bit 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp; TF_EXEC</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Bit 4 - 7&nbsp; :&nbsp; not used</TT>
<BR><BR>For read/write mode, turn both<TT> TF_READ</TT> and<TT> TF_WRITE</TT> bits on.&nbsp; The<TT> TF_EXEC</TT> bit should
only be used together with<TT> TF_CREATE</TT> and indicates that the created file needs executable permission (if relevant
on the target platform).
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; trap_fhandle&nbsp;&nbsp;&nbsp; handle</TT>
<BR><BR>If successful, the<TT> handle</TT> returns a handle for the file.&nbsp; When an error has occurred, the<TT> err</TT>
field contains a value indicating the type of error that has been detected.
<H3 ID="REQ_FILE_SEEK_L2R"> REQ_FILE_SEEK (2) </H3>
<BR>Request to seek to a particular file position.
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; trap_fhandle&nbsp;&nbsp;&nbsp; handle</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32&nbsp;&nbsp;&nbsp;&nbsp; pos</TT>
<BR><BR>The handle of the file is given by the<TT> handle</TT> field.&nbsp; The<TT> mode</TT> field stores the seek mode.
&nbsp;There are three seek modes:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; TF_SEEK_ORG = 0&nbsp; - Relative to the start of file</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; TF_SEEK_CUR = 1&nbsp; - Relative to the current file position</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; TF_SEEK_END = 2&nbsp; - Rrelative to the end of file</TT>
<BR><BR>The position to seek to is in the<TT> pos</TT> field.
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32&nbsp;&nbsp;&nbsp;&nbsp; pos</TT>
<BR><BR>If an error has occurred, the<TT> err</TT> field contains a value indicating the type of error that has been detected.
&nbsp;The<TT> pos</TT> field returns the current position of the file.
<H3 ID="REQ_FILE_READ_L3R"> REQ_FILE_READ (3) </H3>
<BR>Request to read a block of data from a file.
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; trap_fhandle&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handle</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; len</TT>
<BR><BR>The handle of the file is given by the<TT> handle</TT> field.&nbsp; The<TT> len</TT> field stores the number of bytes
to be transmitted.
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; --------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; bytes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
data</TT>
<BR><BR>If successful, the<TT> data</TT> returns the block of data.&nbsp; The length of returned data is given by the return
value of TrapRequest minus 4 (to account for the size of<TT> err</TT>).&nbsp; The length will normally be equal to the<TT>
len</TT> field.&nbsp; If the end of file is encountered before the read completes, the return value will be less than the
number of bytes requested.&nbsp; When an error has occurred, the<TT> err</TT> field contains a value indicating the type of
error that has been detected.
<H3 ID="REQ_FILE_WRITE_L4R"> REQ_FILE_WRITE (4) </H3>
<BR>Request to write a block of data to a file.
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; trap_fhandle&nbsp;&nbsp;&nbsp; handle</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; bytes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data</TT>
<BR><BR>The handle of the file is given by the<TT> handle</TT> field.&nbsp; The data is given in<TT> data</TT> field.
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; len</TT>
<BR><BR>If there is no error,<TT> len</TT> will equal to that in the<TT> data_len</TT> field.&nbsp; When an error has occurred,
the<TT> err</TT> field contains a value indicating the type of error that has been detected.
<H3 ID="REQ_FILE_WRITE_CONSOLE_L5R"> REQ_FILE_WRITE_CONSOLE (5) </H3>
<BR>Request to write a block of data to the debuggee's screen.
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; bytes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data</TT>
<BR><BR>The data is given in<TT> data</TT> field.
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; len</TT>
<BR><BR>If there is no error,<TT> len</TT> will equal to the<TT> data_len</TT> field.&nbsp; When an error has occurred, the<TT>
err</TT> field contains a value indicating the type of error that has been detected.
<H3 ID="REQ_FILE_CLOSE_L6R"> REQ_FILE_CLOSE (6) </H3>
<BR>Request to close a file.
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; trap_fhandle&nbsp;&nbsp;&nbsp; handle</TT>
<BR><BR>The handle of the file is given by the<TT> handle</TT> field.
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</TT>
<BR><BR>When an error has occurred, the<TT> err</TT> field contains a value indicating the type of error that has been detected.
<H3 ID="REQ_FILE_ERASE_L7R"> REQ_FILE_ERASE (7) </H3>
<BR>Request to erase a file.
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; file_name</TT>
<BR><BR>The<TT> file_name</TT> field contains the file name to be deleted.
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp; err</TT>
<BR><BR>If error has occurred when erasing the file, the<TT> err</TT> field will return the error code number.
<H3 ID="REQ_FILE_STRING_TO_FULLPATH_L8R"> REQ_FILE_STRING_TO_FULLPATH (8) </H3>
<BR>Request to convert a file name to its full path name.
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; file_type</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; file_name</TT>
<BR><BR>The<TT> file_type</TT> field indicates the type of the input file.&nbsp; File types can be:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; TF_FILE_EXE&nbsp; =&nbsp; 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; TF_FILE_DBG&nbsp; =&nbsp; 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; TF_FILE_PRS&nbsp; =&nbsp; 2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; TF_FILE_HLP&nbsp; =&nbsp; 3</TT>
<BR><BR>This is so the trap file can search different paths for the different types of files.&nbsp; For example, under QNX,
the PATH environment variable is searched for the FILE_EXE type, and the WD_PATH environment variable is searched for the
others.&nbsp; The<TT> file_name</TT> field contains the file name to be converted.
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; --------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; path_name</TT>
<BR><BR>If no error occurs the<TT> err</TT> field returns a zero and the full path name will be stored in the<TT> path_name</TT>
field.&nbsp; When an error has occurred, the<TT> err</TT> field contains an error code indicating the type of error that has
been detected.
<H3 ID="REQ_FILE_RUN_CMD_L9R"> REQ_FILE_RUN_CMD (9) </H3>
<BR>Request to run a command on the target (debuggee's) system.
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; chk_size</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmd</TT>
<BR><BR>The<TT> chk_size</TT> field gives the check size in kilobytes.&nbsp; This field is only useful in the DOS implementation.
&nbsp;It contains the value of the /CHECKSIZE debugger command line option and represents the amount of memory the user wishes
to have free for the spawned sub-shell.&nbsp; The<TT> cmd</TT> field stores the command to be executed.
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</TT>
<BR><BR>If error has occurred when executing the command, the<TT> err</TT> field will return the error code number.
<H2 ID="Overlay_requests"> Overlay requests </H2>
<BR>This section describes requests that deal with overlays (supported only under 16-bit DOS).&nbsp; These requests are actually
performed by the core request REQ_PERFORM_SUPPLEMENTARY_SERVICE and appropriate service ID.&nbsp; The following descriptions
do not show that &quot;prefix&quot; to the request messages.
<BR><BR>The service name to be used in the REQ_GET_SUPPLEMENTARY_SERVICE is &quot;Overlays&quot;.
<BR><BR>The overlay requests use a new basic type in addition to the ones already described:
<DL>
<DT><B><I>Type</I></B>
<DD><B><I>Definition</I></B>
<DT>addr32_ptr
<DD>This type encapsulates the concept of a 16:16 pointer into the debuggee's address space.&nbsp; Since overlays are only useful
for 16-bit environments, using the addr48_ptr type would be inefficient.&nbsp; The structure is defined as follows:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef struct {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp; offset;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp; segment;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; } addr32_ptr;</TT>
<BR><BR>The<TT> segment</TT> field contains the segment of the address and the<TT> offset</TT> field stores the offset of
the address.
<DT>ovl_address
<DD>This type contains the overlay address and the number of entries down in the overlay stack.&nbsp; The structure is defined
as follows:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef struct {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addr32_ptr&nbsp; mach;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16 sect_id;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; } ovl_address;</TT>
<BR><BR>The<TT> mach</TT> field is the machine address.&nbsp; The<TT> sect_id</TT> field stores the address section number.
</DL>
<H3 ID="REQ_OVL_STATE_SIZE_L0R"> REQ_OVL_STATE_SIZE (0) </H3>
<BR>Request to return the size of the overlay state information in bytes of the task program.&nbsp; This request maps onto
the overlay manager's GET_STATE_SIZE request.&nbsp; See the Overlay Manager Interface document for more information on the
contents of the return message.
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</TT>
<BR><BR>The<TT> req</TT> field contains the request.
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; size</TT>
<BR><BR>The<TT> size</TT> field returns the size in bytes.&nbsp; A value of zero indicates no overlays are present in the
debuggee and none of the other requests dealing with overlays will ever be called.
<H3 ID="REQ_OVL_GET_DATA_L1R"> REQ_OVL_GET_DATA (1) </H3>
<BR>Request to get the address and size of an overlay section.&nbsp; This request maps onto the overlay manager's GET_SECTION_DATA
request.&nbsp; See the Overlay Manager Interface document for more information on the contents of the return message.
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; sect_id</TT>
<BR><BR>The<TT> sect_id</TT> field indicates the overlay section the information is being requested of.
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; segment</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32&nbsp;&nbsp;&nbsp;&nbsp; size</TT>
<BR><BR>The<TT> segment</TT> field contains the segment value where the overlay section is loaded (or would be loaded if it
was brought into memory).&nbsp; The<TT> size</TT> field gives the size, in bytes, of the overlay section.&nbsp; If there is
no section for the given id, the<TT> segment</TT> field will be zero.
<H3 ID="REQ_OVL_READ_STATE_L2R"> REQ_OVL_READ_STATE (2) </H3>
<BR>Request to read the overlay table state.&nbsp; This request maps onto the overlay manager's GET_OVERLAY_STATE request.
&nbsp;See the Overlay Manager Interface document for more information on the contents of the return message.&nbsp; The size
of the returned data is provided by the REQ_OVL_STATE_SIZE trap file request.
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</TT>
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; bytes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data</TT>
<BR><BR>The<TT> data</TT> field contains the overlay state information requested.
<H3 ID="REQ_OVL_WRITE_STATE_L3R"> REQ_OVL_WRITE_STATE (3) </H3>
<BR>Request to write the overlay table state.&nbsp; This request maps onto the overlay manager's SET_OVERLAY_STATE request.
&nbsp;See the Overlay Manager Interface document for more information on the contents of the return message.
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; --------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; bytes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data</TT>
<BR><BR>The<TT> data</TT> field contains the overlay state information to be restored.
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; NONE</TT>
<H3 ID="REQ_OVL_TRANS_VECT_ADDR_L4R"> REQ_OVL_TRANS_VECT_ADDR (4) </H3>
<BR>Request to check if the input overlay address is actually an overlay vector.&nbsp; This request maps onto the overlay
manager's TRANSLATE_VECTOR_ADDR request.&nbsp; See the Overlay Manager Interface document for more information on the contents
of the messages.
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ovl_address&nbsp;&nbsp;&nbsp;&nbsp; ovl_addr</TT>
<BR><BR>The<TT> mach</TT> field is the machine address.&nbsp; The<TT> sect_id</TT> field stores the number of entries down
in the overlay stack.
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ovl_address&nbsp;&nbsp;&nbsp;&nbsp; ovl_addr</TT>
<BR><BR>The translated address will be returned in the<TT> ovl_addr</TT> field.&nbsp; If the address is not an overlay vector,
then the input address will be returned and the<TT> sect_id</TT> field will be zero.
<H3 ID="REQ_OVL_TRANS_RET_ADDR_L5R"> REQ_OVL_TRANS_RET_ADDR (5) </H3>
<BR>Request to check if the address is the overlay manager parallel return code.&nbsp; This request maps onto the overlay
manager's TRANSLATE_RETURN_ADDR request.&nbsp; See the Overlay Manager Interface document for more information on the contents
of the messages.
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ovl_address&nbsp;&nbsp;&nbsp;&nbsp; ovl_addr</TT>
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ovl_address&nbsp;&nbsp;&nbsp;&nbsp; ovl_addr</TT>
<BR><BR>The translated address will be returned in the<TT> ovl_addr</TT> field.&nbsp; If the address is not an parallel return
code, then the input address will be returned and the<TT> sect_id</TT> field in the structure<TT> ovl_addr</TT> will be zero.
<H3 ID="REQ_OVL_GET_REMAP_ENTRY_L6R"> REQ_OVL_GET_REMAP_ENTRY (6) </H3>
<BR>Request to check if the overlay address needs to be remapped.&nbsp; This request maps onto the overlay manager's GET_MOVED_SECTION
request.&nbsp; See the Overlay Manager Interface document for more information on the contents of the messages.
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ovl_address&nbsp;&nbsp;&nbsp;&nbsp; ovl_addr</TT>
<BR><BR>The<TT> ovl_addr</TT> field contains the overlay address.
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; remapped</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ovl_address&nbsp;&nbsp;&nbsp;&nbsp; ovl_addr</TT>
<BR><BR>If the address gets remapped the<TT> remapped</TT> field will return one.&nbsp; The remapped address will be returned
in the<TT> ovl_addr</TT> field.&nbsp; The input address will be unchanged if the address has not been remapped.
<H2 ID="Thread_requests"> Thread requests </H2>
<BR>This section descibes requests that deal with threads.&nbsp; These requests are actually performed by the core request
REQ_PERFORM_SUPPLEMENTARY_SERVICE and appropriate service ID.&nbsp; The following descriptions do not show that &quot;prefix&quot;
to the request messages.
<BR><BR>The service name to be used in the REQ_GET_SUPPLEMENTARY_SERVICE is &quot;Threads&quot;.
<BR><BR>The thread requests use a new basic type in addition to the ones already described:
<DL>
<DT><B><I>Type</I></B>
<DD><B><I>Definition</I></B>
<DT>trap_thandle
<DD>This is an<TT> unsigned_32</TT> which holds a thread handle.
</DL>
<H3 ID="REQ_THREAD_GET_NEXT_L0R"> REQ_THREAD_GET_NEXT (0) </H3>
<BR>Request to get next thread.
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; trap_thandle&nbsp;&nbsp;&nbsp; thread</TT>
<BR><BR>The<TT> thread</TT> contains the either a zero to get information on the first thread, or the value of the<TT> thread</TT>
field in the return message of a previous request.
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; trap_thandle&nbsp;&nbsp;&nbsp; thread</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; state</TT>
<BR><BR>The<TT> thread</TT> field returns the thread ID.&nbsp; There are no more threads in the list, it will contain zero.
&nbsp;The<TT> state</TT> field can have two values:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; THREAD_THAWED = 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; THREAD_FROZEN = 1</TT>
<H3 ID="REQ_THREAD_SET_L1R"> REQ_THREAD_SET (1) </H3>
<BR>Request to set a given thread ID to be the current thread.
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; trap_thandle&nbsp;&nbsp;&nbsp; thread</TT>
<BR><BR>The<TT> thread</TT> contains the thread number to set.&nbsp; If it's zero, do not attempt to set the thread, just
return the current thread ID.
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; trap_thandle&nbsp;&nbsp;&nbsp; old_thread</TT>
<BR><BR>The<TT> old_thread</TT> field returns the previous thread ID.&nbsp; If the set fails, the<TT> err</TT> field will
be non-zero.
<H3 ID="REQ_THREAD_FREEZE_L2R"> REQ_THREAD_FREEZE (2) </H3>
<BR>Request to freeze a thread so that it will not be run next time when executing the task program.
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; trap_thandle&nbsp;&nbsp;&nbsp; thread</TT>
<BR><BR>The<TT> thread</TT> contains the thread number to freeze.
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</TT>
<BR><BR>If the thread cannot be frozen, the<TT> err</TT> field returns non-zero value.
<H3 ID="REQ_THREAD_THAW_L3R"> REQ_THREAD_THAW (3) </H3>
<BR>Request to allow a thread to run next time when executing the program.
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; trap_thandle&nbsp;&nbsp;&nbsp; thread</TT>
<BR><BR>The<TT> thread</TT> contains the thread number to thaw.
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</TT>
<BR><BR>If the thread cannot be thawed, the<TT> err</TT> field returns non zero value.
<H3 ID="REQ_THREAD_GET_EXTRA_L4R"> REQ_THREAD_GET_EXTRA (4) </H3>
<BR>Request to get extra information about a thread.&nbsp; This is arbitrary textual data which the debugger merely displays
in its thread window.&nbsp; The trap file can place any information in the return message which it feels would be useful for
the user to know.
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32&nbsp;&nbsp;&nbsp;&nbsp; thread</TT>
<BR><BR>The<TT> thread</TT> field contains the thread ID.&nbsp; A zero value means to get the title string for the thread
extra information.&nbsp; This is displayed at the top of the thread window.
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; extra</TT>
<BR><BR>The extra information of the thread will be returned in<TT> extra</TT> field.
<H2 ID="RFX_requests"> RFX requests </H2>
<BR>This section deals with requests that are only used by the RFX (Remote File Xfer) program.&nbsp; These requests are actually
performed by the core request REQ_PERFORM_SUPPLEMENTARY_SERVICE and appropriate service ID.&nbsp; The following descriptions
do not show that &quot;prefix&quot; to the request messages.
<BR><BR>The service name to be used in the REQ_GET_SUPPLEMENTARY_SERVICE is &quot;RFX&quot;.
<H3 ID="REQ_RFX_RENAME_L0R"> REQ_RFX_RENAME (0) </H3>
<BR>Request to rename a file on the debuggee's system.
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; from_name</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; to_name</TT>
<BR><BR>The file whose name is indicated by the field<TT> from_name</TT> will be renamed to the name given by the field<TT>
to_name</TT>
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</TT>
<BR><BR>If error has occurred, the<TT> err</TT> field will return the error code number.
<H3 ID="REQ_RFX_MKDIR_L1R"> REQ_RFX_MKDIR (1) </H3>
<BR>Request to create a directory on the target (debuggee) system.
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dir_name</TT>
<BR><BR>The<TT> dir_name</TT> field contains the name of the directory to be created.
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</TT>
<BR><BR>If error has occurred when creating the directory, the<TT> err</TT> field will return the error code number.
<H3 ID="REQ_RFX_RMDIR_L2R"> REQ_RFX_RMDIR (2) </H3>
<BR>Request to remove a directory on the target system.
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dir_name</TT>
<BR><BR>The<TT> dir_name</TT> field contains the name of the directory to be removed.
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</TT>
<BR><BR>If error has occurred, the<TT> err</TT> field will return the error code number.
<H3 ID="REQ_RFX_SETDRIVE_L3R"> REQ_RFX_SETDRIVE (3) </H3>
<BR>Request to set the current drive on the target system.
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; drive</TT>
<BR><BR>The<TT> drive</TT> field contains the drive number to be set on the target system (0=A,1=B,...).
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</TT>
<BR><BR>If error has occurred, the<TT> err</TT> field will return the error code number.
<H3 ID="REQ_RFX_GETDRIVE_L4R"> REQ_RFX_GETDRIVE (4) </H3>
<BR>Request to get the current drive on the target system.
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</TT>
<BR><BR>The<TT> req</TT> field contains the request.
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; drive</TT>
<BR><BR>The<TT> drive</TT> field returns the current drive number on the target system (0=A,1=B,...).
<H3 ID="REQ_RFX_SETCWD_L5R"> REQ_RFX_SETCWD (5) </H3>
<BR>Request to set a directory on the target system.
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dir_name</TT>
<BR><BR>The<TT> dir_name</TT> field contains the name of the directory to be set.
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</TT>
<BR><BR>If error has occurred, the<TT> err</TT> field will return the error code number.
<H3 ID="REQ_RFX_GETCWD_L6R"> REQ_RFX_GETCWD (6) </H3>
<BR>Request to get the current directory name on the target system.
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; drive</TT>
<BR><BR>The<TT> drive</TT> field contains the target drive number (0=current drive,1=A,2=B,...).
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; --------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dir_name</TT>
<BR><BR>The<TT> dir_name</TT> field contains the name of the directory to be set.&nbsp; If error has occurred, the<TT> err</TT>
field will return the error code number.
<H3 ID="REQ_RFX_SETDATETIME_L7R"> REQ_RFX_SETDATETIME (7) </H3>
<BR>Request to set a file's date and time information on the target system.
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; trap_fhandle&nbsp;&nbsp;&nbsp; handle</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time</TT>
<BR><BR>The<TT> handle</TT> contains the file handle.&nbsp; The<TT> time</TT> field follows the UNIX time format.&nbsp; The<TT>
time</TT> represents the time since January 1, 1970 (UTC).
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; NONE</TT>
<H3 ID="REQ_RFX_GETDATETIME_L8R"> REQ_RFX_GETDATETIME (8) </H3>
<BR>Request to get the date and time information for a file on the target system.
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; trap_fhandle&nbsp;&nbsp;&nbsp; handle</TT>
<BR><BR>The<TT> handle</TT> contains the file handle.
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time</TT>
<BR><BR>The<TT> time</TT> field follows the UNIX time format.&nbsp; The<TT> time</TT> represents the time since January 1,
1970 (UTC).
<H3 ID="REQ_RFX_GETFREESPACE_L9R"> REQ_RFX_GETFREESPACE (9) </H3>
<BR>Request to get the amount of free space left on the drive.
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; drive</TT>
<BR><BR>The<TT> drive</TT> field contains the target drive number (0=current drive,1=A,2=B,...).
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32&nbsp;&nbsp;&nbsp;&nbsp; size</TT>
<BR><BR>The<TT> size</TT> field returns the number of bytes left on the drive.
<H3 ID="REQ_RFX_SETFILEATTR_L10R"> REQ_RFX_SETFILEATTR (10) </H3>
<BR>Request to set the file attribute of a file.
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32&nbsp;&nbsp;&nbsp;&nbsp; attribute</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name</TT>
<BR><BR>The<TT> name</TT> field contains the name whose attributes are to be set.&nbsp; The<TT> attribute</TT> field contains
the new attributes of the file.
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</TT>
<BR><BR>If error has occurred, the<TT> err</TT> field will return the error code number.
<H3 ID="REQ_RFX_GETFILEATTR_L11R"> REQ_RFX_GETFILEATTR (11) </H3>
<BR>Request to get the file attribute of a file.
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; --------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name</TT>
<BR><BR>The<TT> name</TT> field contains the name to be checked.
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32&nbsp;&nbsp;&nbsp;&nbsp; attribute</TT>
<BR><BR>The<TT> attribute</TT> field returns the attribute of the file.
<H3 ID="REQ_RFX_NAMETOCANONICAL_L12R"> REQ_RFX_NAMETOCANONICAL (12) </H3>
<BR>Request to convert a file name to its canonical form.
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; file_name</TT>
<BR><BR>The<TT> file_name</TT> field contains the file name to be converted.
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; --------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; path_name</TT>
<BR><BR>If there is no error, the<TT> err</TT> field returns a zero and the full path name will be stored in the<TT> path_name</TT>
field.&nbsp; When an error has occurred, the<TT> err</TT> field contains an error code indicating the type of error that has
been detected.
<H3 ID="REQ_RFX_FINDFIRST_L13R"> REQ_RFX_FINDFIRST (13) </H3>
<BR>Request to find the first file in a directory.
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attrib</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ----------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name</TT>
<BR><BR>The<TT> name</TT> field contains the name of the directory and the<TT> attrib</TT> field contains the attribute of
the files to list in the directory.
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -----------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; rfx_find&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info</TT>
<BR><BR>If found, the<TT> err</TT> field will be zero.&nbsp; The location and information of about the first file will be
in the structure<TT> info.</TT>&nbsp; Definition of the structure<TT> rfx_find</TT> is as follows:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef struct rfx_find {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
reserved[21];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
attr;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; date;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
name[260];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; } rfx_find;</TT>
<H3 ID="REQ_RFX_FINDNEXT_L14R"> REQ_RFX_FINDNEXT (14) </H3>
<BR>Request to find the next file in the directory.&nbsp; This request should be used only after REQ_RFX_FINDFIRST.
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; --------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; rfx_find&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info</TT>
<BR><BR>The<TT> req</TT> field contains the request.&nbsp; The<TT> info</TT> field contains the rfx_find structure returned
from the previous REQ_FIND_NEXT or REQ_FIND_FIRST.
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -----------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; rfx_find&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info</TT>
<BR><BR>The<TT> info</TT> field is the same as in REQ_FIND_FIRST.
<H3 ID="REQ_RFX_FINDCLOSE_L15R"> REQ_RFX_FINDCLOSE (15) </H3>
<BR>Request to end the directory search operation.
<BR><BR>Request message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</TT>
<BR><BR>The<TT> req</TT> field contains the request.
<BR><BR>Return message:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</TT>
<BR><BR>If successful, the<TT> err</TT> field will be zero, otherwise the system error code will be returned.
<H1 ID="System_Dependent_Aspects"> System Dependent Aspects </H1>
<BR>Every environment has a different method of loading the code for the trap file and locating the TrapInit, TrapRequest,
and TrapFini routines.&nbsp; This section descibes how the Open Watcom debugger performs these operations for the various
systems.
<H2 ID="Trap_Files_Under_DOS"> Trap Files Under DOS </H2>
<BR>A trap file is an &quot;EXE&quot; format file with the extension &quot;.TRP&quot;.&nbsp; The debugger searches the directories
specified by the PATH environment variable.&nbsp; Once found, it is loaded into memory and has the normal EXE style relocations
applied to the image.&nbsp; Then the lowest address in the load image (NOTE:&nbsp; not the starting address from EXE header
information) is examined for the following structure:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef struct {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; signature; /* == 0xDEAF */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; init_off;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; acc_off;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; fini_off;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; } trap_header;</TT>
<BR><BR>If the first 2 bytes contain the value 0xDEAF, the file is considered to be a valid trap file and the<TT> init_off</TT>,<TT>
acc_off</TT>, and<TT> fini_off</TT> fields are used to obtain the offsets of the TrapInit, TrapRequest, and TrapFini routines
repectively.
<BR><BR>The starting address field of the EXE header should be set to point at some code which prints out a message about
not being able to be run from the command line and then terminates.
<H2 ID="Trap_Files_Under_OSD2"> Trap Files Under OS/2 </H2>
<BR>A trap file is a normal OS/2 DLL.&nbsp; The system automatically searches the directories specified by the LIBPATH command
in the CONFIG.SYS file.&nbsp; Once loaded, the Open Watcom debugger uses export ordinal 1 from the DLL for TrapInit, export
ordinal 2 for TrapFini and export ordinal 3 for TrapRequest.&nbsp; Some example code follows:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; rc = DosLoadModule( NULL, 0, trap_file_name, &amp;dll_module );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; if( rc != 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( &quot;unable to load trap file&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; if( DosGetProcAddr( dll_module, &quot;#1&quot;, &amp;TrapInit ) != 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || DosGetProcAddr( dll_module, &quot;#2&quot;, &amp;TrapFini ) != 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || DosGetProcAddr( dll_module, &quot;#3&quot;, &amp;TrapRequest ) != 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( &quot;incorrect version of trap file&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="Trap_Files_Under_Windows_"> Trap Files Under Windows. </H2>
<BR>A trap file is a normal Windows DLL.&nbsp; The system automatically searches the directories specified by the PATH environment
variable.&nbsp; Once loaded, the Open Watcom debugger uses export ordinal 2 from the DLL for TrapInit, export ordinal 3 for
TrapFini and export ordinal 4 for TrapRequest.&nbsp; Some example code follows:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; dll = LoadLibrary( trap_file_name );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; if( dll &lt; 32 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( &quot;unable to load trap file&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; TrapInit&nbsp;&nbsp; = (LPVOID) GetProcAddress( dll, (LPSTR)2 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; TrapFini&nbsp;&nbsp; = (LPVOID) GetProcAddress( dll, (LPSTR)3 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; TrapRequest = (LPVOID) GetProcAddress( dll, (LPSTR)4 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; if( TrapInit == NULL || TrapFini == NULL || TrapRequest == NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( &quot;incorrect version of trap file&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="Trap_Files_Under_Windows_NT_"> Trap Files Under Windows NT. </H2>
<BR>A trap file is a normal Windows NT DLL.&nbsp; The system automatically searches the directories specified by the PATH
environment variable.&nbsp; Once loaded, the Open Watcom debugger uses export ordinal 1 from the DLL for TrapInit, export
ordinal 2 for TrapFini and export ordinal 3 for TrapRequest.&nbsp; Some example code follows:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; dll = LoadLibrary( trap_file_name );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; if( dll &lt; 32 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( &quot;unable to load trap file&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; TrapInit&nbsp;&nbsp; = (LPVOID) GetProcAddress( dll, (LPSTR)1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; TrapFini&nbsp;&nbsp; = (LPVOID) GetProcAddress( dll, (LPSTR)2 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; TrapRequest = (LPVOID) GetProcAddress( dll, (LPSTR)3 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; if( TrapInit == NULL || TrapFini == NULL || TrapRequest == NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( &quot;incorrect version of trap file&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="Trap_Files_Under_QNX"> Trap Files Under QNX </H2>
<BR>A trap file is a QNX load module format file with the extension &quot;.trp&quot; and whose file permissions are not marked
as executable.&nbsp; The debugger searches the directories specified by the WD_PATH environment variable and then the &quot;/usr/watcom/wd&quot;
directory.&nbsp; Once found, it is loaded into memory and has the normal loader relocations applied to the image.&nbsp; Then
the lowest address in the load image (NOTE:&nbsp; not the starting address from load module header information) is examined
for the following structure:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef struct {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; signature; /* == 0xDEAF */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; init_off;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; acc_off;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; fini_off;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; } trap_header;</TT>
<BR><BR>If the first 2 bytes contain the value 0xDEAF, the file is considered to be a valid trap file and the<TT> init_off</TT>,<TT>
acc_off</TT>, and<TT> fini_off</TT> fields are used to obtain the offsets of the TrapInit, TrapRequest, and TrapFini routines
repectively.
<BR><BR>The starting address field of the load image header should be set to point at some code which prints out a message
about not being able to be run from the command line and then terminates.
<H2 ID="Trap_Files_Under_Netware_386_or_PenPoint"> Trap Files Under Netware 386 or PenPoint </H2>
<BR>The trap file routines are linked directly into the remote server code and TrapInit, TrapRequest, TrapFini are directly
called.
<H1 ID="Overlay_manager_interface"> Overlay manager interface </H1>
<BR><BR>For Open Watcom Debugger to be able to debug overlays, it must be able to make requests of the overlay manager for
certain operations.&nbsp; The overlay manager must also be able to inform Open Watcom Debugger when a new overlay section
is loaded.
<BR>When Open Watcom Debugger loads a DOS program, it looks at the initial CS:IP value for the following structure:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct ovl_header {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp; short_jmp_opcode;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;/* == 0xeb */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signed_8&nbsp;&nbsp;&nbsp; short_jmp_displacment;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16 signature;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* == 0x2112 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (far *hook)();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16 handler_offset;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR>Open Watcom Debugger checks to make sure that the first instruction is a short jump (opcode 0xeb) and that the word
following that instruction contains the value 0x2112.&nbsp; If this occurs, Open Watcom Debugger assumes that it is debugging
an overlaid application.
<BR><BR>Open Watcom Debugger then fills in the<TT> hook</TT> field with the far address of a routine that is invoked with
a far call whenever a change in the overlay state occurs.&nbsp; The initial CS value and the contents of the<TT> handler_offset</TT>
field gives the far address of the overlay manager routine responsible for handling debugger requests.
<H2 ID="The_Hook_Routine"> The Hook Routine </H2>
<BR>After the routine addresses have been exchanged, Open Watcom Debugger starts the program executing, to allow the overlay
manager to initialize.&nbsp; After the manager has finished its initialization, it performs a far call to the debugger hook
routine, with the return address on the stack being the &quot;real&quot; starting address of the program being debugged.&nbsp;
All register contents (including flags) should be preserved by the hook routine.
<BR><BR>After initialization, the debugger hook routine is invoked with a far call every time a new overlay section is loaded
into memory.&nbsp; In this case the AX register contains the section number that was just loaded.&nbsp; The DL register contains
a zero or non-zero value if the overlay load was caused by a call or return, respectively.&nbsp; The CX:BX registers form
a far pointer to the last byte of the call instruction that caused the overlay load (in the case of a overlay load being caused
by a return instruction (DL is non-zero) the far pointer is to the last byte of the call instruction that the return is returning
from.)
<BR><BR><B>NOTE:</B>&nbsp; may be loaded by the overlay manager before the hook routine is called.&nbsp; The current overlay
manager also loads all of the ancestors of a section (See the WLINK documentation in the Users' Guide for a description of
what an ancestor is).&nbsp; To find out what sections are really in memory the debugger should invoke the handler routine
with a GET_OVERLAY_STATE request.
<H2 ID="The_Handler_Routine"> The Handler Routine </H2>
<BR>The handler routine is responsible for processing requests from the debugger pertaining to overlays.&nbsp; It is invoked
by the debugger by performing a far call with a request number in the AX register.&nbsp; The AX register is used to return
the result or return status of the request.&nbsp; The CX and BX registers are used for some requests to pass a far pointer
to memory.
<BR><BR>There are two structures that the handler routines deals with.&nbsp; The first is called an overlay state.&nbsp; An
overlay state consists of a block of memory containing all the information necessary for the overlay manager to restore the
overlays to their current condition at some later point in time.&nbsp; The first portion of this block is a bit vector, with
each bit representing an overlay section.&nbsp; If the bit is a one, then the overlay section is currently in memory.&nbsp;
If the bit is a zero then the overlay section is not in memory.&nbsp; To convert from a section number to a bit position use
the following formulas:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; byte_offset = (section_number - 1) / 8;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; bit_number&nbsp; = (section_number - 1) % 8;</TT>
<BR><BR>Following the bit vector is information that the manager uses to restore the overlay stack.
<BR><BR>The second structure used is an overlay address.&nbsp; This consists of a far pointer followed by a 16-bit section
number.
<BR><BR>The following requests are recognized by the debug handler routine.
<H3 ID="GET_STATE_SIZE"> GET_STATE_SIZE </H3>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Inputs:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Outputs:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; AX = request number (0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AX = size of overlay
state</TT>
<BR><BR>This request returns the number of bytes required for an overlay state.
<H3 ID="GET_OVERLAY_STATE"> GET_OVERLAY_STATE </H3>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Inputs:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Outputs:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; AX = request number (1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AX = 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CX:BX = far pointer to memory</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; to store overlay state</TT>
<BR><BR>This request copies the overlay state into the memory pointed at by the CX:BX registers.&nbsp; A one is always returned
in AX.
<H3 ID="SET_OVERLAY_STATE"> SET_OVERLAY_STATE </H3>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Inputs:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Outputs:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; AX = request number (2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AX = 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CX:BX = far pointer to memory</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; to load overlay state</TT>
<BR><BR>This request takes a previously obtained overlay state and causes the overlay manager to return itself to that overlay
configuration.&nbsp; A one is always returned in AX.&nbsp; The overlay manager will not explicitly unload a section that is
not in memory according to the given overlay state, so a GET_OVERLAY_STATE request following a SET_OVERLAY_STATE may not return
the same bit vector portion.&nbsp; This request may also be used by the debugger to explicitly load a section, so the assembly
code may be examined, perhaps.&nbsp; To do this, zero out a block of memory the size of an overlay state, and then turn on
the appropriate section number in the bit vector, then make a SET_OVERLAY_STATE request.&nbsp; Remember that not only that
section will be loaded, but all of its ancestor sections as well.
<H3 ID="TRANSLATE_VECTOR_ADDR"> TRANSLATE_VECTOR_ADDR </H3>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Inputs:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Outputs:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; AX = request number (3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AX = 1 if addr was
translated,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CX:BX = far pointer to&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; 0 otherwise</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; overlay address</TT>
<BR><BR>This request checks to see if the far pointer portion of the overlay address pointed at by CX:BX is actually an overlay
vector.&nbsp; If the address is a vector then the vector address is replaced by the true address of the routine that the vector
is for, and the section number portion is filled in with the section number the of routine.&nbsp; A one is returned in AX
in this case.&nbsp; If the address is not an overlay vector, then the overlay address is untouched and an zero is returned
in AX.
<H3 ID="TRANSLATE_RETURN_ADDR"> TRANSLATE_RETURN_ADDR </H3>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Inputs:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Outputs:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; AX = request number (4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AX = 1 if addr was
translated,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CX:BX = far pointer to&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; 0 otherwise</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; overlay address</TT>
<BR><BR>In order to handle parallel overlay calls, the overlay manager replaces the true return address on the stack with
that of some special code (the parallel return code).&nbsp; It then takes the original return address and section number an
places them on the overlay stack.&nbsp; When a routine returns to the overlay manager, it pops the top entry of the overlay
stack, makes sure that the original overlay section is loaded, and returns to the original return address.
<BR><BR>This function performs much the same function as TRANSLATE_VECTOR_ADDR, except that rather than checking for a vector
address, it checks to see if the address is that of the overlay manager parallel return code.&nbsp; If it is then the section
number in the overlay address is used as the number of entries down in the overlay stack that the real return address and
section number is to be found (zero is the top entry of the overlay stack).&nbsp; The true return address and section number
then replaces the contents of the overlay address and a one is returned in AX.&nbsp; If the address is not the parallel return
code, then the overlay address is left untouched and a zero is returned in AX.
<H3 ID="GET_OVL_TBL_ADDR"> GET_OVL_TBL_ADDR </H3>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Inputs:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Outputs:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; AX = request number (5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AX = 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CX:BX = far pointer to variable</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; of type far pointer to</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; be filled in with</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; overlay table address</TT>
<BR><BR>This request fills in the far pointer pointed at by CX:BX with the address of the overlay table so that a profiler
can find out where sections are located in the executable, or overlay files.&nbsp; The sampler program, when it detects that
it is sampling a overlaid application, can perform this function and write the result into the sample file.&nbsp; Since the
overlay table is always in the root, the profiler can then find the overlay table and from that, find the other sections.
&nbsp;It should be noted that the format of the overlay table may change, so this call should be avoided if at all possible.
<H3 ID="GET_MOVED_SECTION"> GET_MOVED_SECTION </H3>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Inputs:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Outputs:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; AX = request number (6)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AX = 1 if the section
exists</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CX:BX = far pointer to&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; 0 otherwise</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; overlay address</TT>
<BR><BR>With the dynamic overlay manager, sections may be loaded, or moved, to positions other than where the linker originally
placed them.&nbsp; The debugger must be informed of the new positions so that it can update the locations of its symbolic
information.&nbsp; The GET_MOVED_SECTION request is responsible for informing the debugger what sections have moved and their
new locations.&nbsp; The debugger will call this request after the hook routine has been called, or the debugger has invoked
the SET_OVERLAY_STATE request.&nbsp; The request returns the first section whose id larger than the section number that is
in the overlay address being passed in.&nbsp; The overlay manager will fill in the overlay address with the section number
that has moved and its new segment address.&nbsp; The offset portion of the overlay address is unused.&nbsp; The request will
return a one in AX.&nbsp; If there are no sections numbers larger than the one being passed in that have moved, a zero is
returned.
<BR><BR>Here is some example debugger code:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void CheckMovedSections()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; overlay_address&nbsp;&nbsp;&nbsp;&nbsp; addr;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addr.sect_id = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( OvlHandler( GET_MOVED_SECTION, &amp;addr ) ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HandleMovedSection( addr.sect_id, addr.segment
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H3 ID="GET_SECTION_DATA"> GET_SECTION_DATA </H3>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Inputs:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Outputs:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; AX = request number (7)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AX = 1 if the section
exists</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CX:BX = far pointer to&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; 0 otherwise</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; overlay address</TT>
<BR><BR>This request returns information on the current location of a section while it is in memory (or where it would be
if it was loaded).&nbsp; The section number portion of the overlay address is filled in with the section id that information
is being requested about before the request is made.&nbsp; The overlay manager returns zero in AX if the section does not
exist.&nbsp; Otherwise it returns one and fills in the overlay address with the location that the section is in memory, or
where it would currently go if it was loaded at that time.&nbsp; It also fills in the section number portion of the address
with the size of the section in paragraphs.
<H2 ID="Overlay_Table_Structure"> Overlay Table Structure </H2>
<BR>The pointer returned by the GET_OVL_TBL_ADDR request has the following format:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef struct ovl_table {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; major;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; minor;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;far *start;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; delta;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; ovl_size;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ovltab_entry&nbsp;&nbsp;&nbsp; entries[ 1 ];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; } ovl_table;</TT>
<BR><BR>The fields<TT> major</TT> and<TT> minor</TT> field contain version numbers for the overlay table structure.&nbsp;
If an upwardly compatible change in the structures is made, the minor number will be incremented.&nbsp; If a non-upwardly
compatible change to the structures is made, the major field will be incremented.&nbsp; The current major version is 3, the
current minor version is 0.&nbsp; The<TT> start</TT> field contains a 32-bit far pointer to the &quot;actual&quot; starting
address of the program.&nbsp; The overlay manager jumps to this address after it has finished initializing.&nbsp; (If a debugger/sampler
is present then the overlay manager calls into the hook routine with this address on the return stack.) The<TT> delta</TT>
field contains the value to be added to each of the segment relocations when a section is loaded into memory (it contains
the segment value for the first segment in the program.) The<TT> ovl_size</TT> field contains the size of the overlay area.
&nbsp;This is only used in the dynamic overlay manager.&nbsp; The final field,<TT> entries</TT>, is a variable sized array
containing one entry for each overlay section in the program (e.g.&nbsp; the tenth element in the array describes overlay
section 10.) Each entry has the following form:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef struct ovltab_entry {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; flags_anc;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; relocs;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; start_para;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; code_handle;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; num_paras;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fname;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; disk_addr;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; } ovltab_entry;</TT>
<BR><BR>The top bit of the<TT> flag_anc</TT> field contains an indicator, while the program is running, of whether the overlay
section is in memory (value one) or must be loaded from disk (value zero).&nbsp; The next highest bit is filled in by the
linker and informs the overlay manager that the section must be loaded during the overlay manager initialization.&nbsp; The
remaining bits contain the overlay number for the ancestor of this section (zero if there is none).&nbsp; The<TT> relocs</TT>
field say how many segment relocation items there are for this section, while the<TT> start_para</TT> field gives the location
in memory (relative to the start of the program) that the section should be placed when loaded.&nbsp; The<TT> num_paras</TT>
field contains the size of the section in paragraphs, and the<TT> code_handle</TT> field is used for various purposes inside
the dynamic overlay loader.&nbsp; The<TT> fname</TT> field has the offset of the address of a zero terminated string for the
name of the file containing the overlay section data and relocations (The segment value is the same as the overlay table).
&nbsp;If the top bit of the offset is on, then the file is the original EXE file rather than a separate overlay file, and
the overlay manager should use the program file name obtained from DOS (if the version is 3.0.&nbsp; or greater).&nbsp; The<TT>
disk_addr</TT> field gives the starting offset the overlay data in the overlay file.&nbsp; The segment relocation items immediately
follow the data.
<BR><BR>The end of the<TT> entries</TT> array is indicated when an element's<TT> flags_anc</TT> field contains the value 0xffff.
&nbsp;The remaining fields in that element contain garbage values.
</BODY>
