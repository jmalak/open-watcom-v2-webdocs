<HEAD>
<TITLE> Open Watcom 2.0 FORTRAN 77 User's Guide </TITLE>
</HEAD>
<BODY>
<H1 ID="Index_of_Topics"> Index of Topics </H1>
<DL>
<DT>- &quot; -
<DD><A HREF="#The__NO87__Environment_Variable">The &quot;NO87&quot; Environment Variable</A>
<DT>- 1 -
<DD><A HREF="#16Mbit_Assembly_Language_Considerations">16-bit Assembly Language Considerations</A>
<BR><A HREF="#16Mbit_Code_Models">16-bit Code Models</A>
<BR><A HREF="#16Mbit_Data_Models">16-bit Data Models</A>
<BR><A HREF="#16Mbit_Memory_Layout">16-bit Memory Layout</A>
<BR><A HREF="#16Mbit_Memory_Models">16-bit Memory Models</A>
<BR><A HREF="#16Mbit__16Mbit_Pragmas">16-bit:&nbsp; 16-bit Pragmas</A>
<BR><A HREF="#16Mbit__A_Subprogram_that_Never_Returns">16-bit:&nbsp; A Subprogram that Never Returns</A>
<BR><A HREF="#16Mbit__Alias_Names">16-bit:&nbsp; Alias Names</A>
<BR><A HREF="#16Mbit__Alternate_Method_of_Passing_Character_Arguments">16-bit:&nbsp; Alternate Method of Passing Character Arguments</A>
<BR><A HREF="#16Mbit__Alternate_Names_for_Symbols">16-bit:&nbsp; Alternate Names for Symbols</A>
<BR><A HREF="#16Mbit__Auxiliary_Pragmas">16-bit:&nbsp; Auxiliary Pragmas</A>
<BR><A HREF="#16Mbit__Auxiliary_Pragmas_and_the_80x87">16-bit:&nbsp; Auxiliary Pragmas and the 80x87</A>
<BR><A HREF="#16Mbit__Calling_Conventions">16-bit:&nbsp; Calling Conventions</A>
<BR><A HREF="#16Mbit__Character_Functions">16-bit:&nbsp; Character Functions</A>
<BR><A HREF="#16Mbit__Defining_Exported_Symbols_in_Dynamic_Link_Libraries">16-bit:&nbsp; Defining Exported Symbols in Dynamic Link Libraries</A>
<BR><A HREF="#16Mbit__Defining_Windows_Callback_Functions">16-bit:&nbsp; Defining Windows Callback Functions</A>
<BR><A HREF="#16Mbit__Describing_Argument_Information">16-bit:&nbsp; Describing Argument Information</A>
<BR><A HREF="#16Mbit__Describing_Calling_Information">16-bit:&nbsp; Describing Calling Information</A>
<BR><A HREF="#16Mbit__Describing_How_Subprograms_Use_Variables_in_Common">16-bit:&nbsp; Describing How Subprograms Use Variables in Common</A>
<BR><A HREF="#16Mbit__Describing_Subprogram_Return_Information">16-bit:&nbsp; Describing Subprogram Return Information</A>
<BR><A HREF="#16Mbit__Describing_the_Registers_Modified_by_a_Subprogram">16-bit:&nbsp; Describing the Registers Modified by a Subprogram</A>
<BR><A HREF="#16Mbit__Forcing_Arguments_into_Specific_Registers">16-bit:&nbsp; Forcing Arguments into Specific Registers</A>
<BR><A HREF="#16Mbit__Loading_Data_Segment_Register">16-bit:&nbsp; Loading Data Segment Register</A>
<BR><A HREF="#16Mbit__Memory_Layout">16-bit:&nbsp; Memory Layout</A>
<BR><A HREF="#16Mbit__Passing_Arguments_in_Registers">16-bit:&nbsp; Passing Arguments in Registers</A>
<BR><A HREF="#16Mbit__Passing_Arguments_in_Reverse_Order">16-bit:&nbsp; Passing Arguments in Reverse Order</A>
<BR><A HREF="#16Mbit__Passing_Arguments_to_InMLine_Subprograms">16-bit:&nbsp; Passing Arguments to In-Line Subprograms</A>
<BR><A HREF="#16Mbit__Passing_Arguments_to_nonMFORTRAN_Subprograms">16-bit:&nbsp; Passing Arguments to non-FORTRAN Subprograms</A>
<BR><A HREF="#16Mbit__Predefined____cdecl__Alias">16-bit:&nbsp; Predefined &quot;__cdecl&quot; Alias</A>
<BR><A HREF="#16Mbit__Predefined____pascal__Alias">16-bit:&nbsp; Predefined &quot;__pascal&quot; Alias</A>
<BR><A HREF="#16Mbit__Predefined____watcall__Alias">16-bit:&nbsp; Predefined &quot;__watcall&quot; Alias</A>
<BR><A HREF="#16Mbit__Predefined_Aliases">16-bit:&nbsp; Predefined Aliases</A>
<BR><A HREF="#16Mbit__Preserving_80x87_FloatingMPoint_Registers_Across_Calls">16-bit:&nbsp; Preserving 80x87 Floating-Point Registers Across Calls</A>
<BR><A HREF="#16Mbit__Processing_Alternate_Returns">16-bit:&nbsp; Processing Alternate Returns</A>
<BR><A HREF="#16Mbit__Processing_Function_Return_Values_Using_an_80x87">16-bit:&nbsp; Processing Function Return Values Using an 80x87</A>
<BR><A HREF="#16Mbit__Processing_Function_Return_Values_with_no_80x87">16-bit:&nbsp; Processing Function Return Values with no 80x87</A>
<BR><A HREF="#16Mbit__Removing_Arguments_from_the_Stack">16-bit:&nbsp; Removing Arguments from the Stack</A>
<BR><A HREF="#16Mbit__Returning_FloatingMPoint_Data">16-bit:&nbsp; Returning Floating-Point Data</A>
<BR><A HREF="#16Mbit__Returning_Structures_and_Complex_Numbers">16-bit:&nbsp; Returning Structures and Complex Numbers</A>
<BR><A HREF="#16Mbit__Returning_Subprogram_Values_in_Registers">16-bit:&nbsp; Returning Subprogram Values in Registers</A>
<BR><A HREF="#16Mbit__Returning_Values_from_Assembly_Language_Functions">16-bit:&nbsp; Returning Values from Assembly Language Functions</A>
<BR><A HREF="#16Mbit__Specifying_Symbol_Attributes">16-bit:&nbsp; Specifying Symbol Attributes</A>
<BR><A HREF="#16Mbit__Using_Pragmas_to_Specify_Default_Libraries">16-bit:&nbsp; Using Pragmas to Specify Default Libraries</A>
<BR><A HREF="#16Mbit__Using_the_80x87_to_Pass_Arguments">16-bit:&nbsp; Using the 80x87 to Pass Arguments</A>
<BR><A HREF="#16Mbit__Using_the_80x87_to_Return_Subprogram_Values">16-bit:&nbsp; Using the 80x87 to Return Subprogram Values</A>
<BR><A HREF="#16Mbit__Writing_Assembly_Language_Subprograms">16-bit:&nbsp; Writing Assembly Language Subprograms</A>
<DT>- 3 -
<DD><A HREF="#32Mbit_Assembly_Language_Considerations">32-bit Assembly Language Considerations</A>
<BR><A HREF="#32Mbit_Code_Models">32-bit Code Models</A>
<BR><A HREF="#32Mbit_Data_Models">32-bit Data Models</A>
<BR><A HREF="#32Mbit_Memory_Layout">32-bit Memory Layout</A>
<BR><A HREF="#32Mbit_Memory_Models">32-bit Memory Models</A>
<BR><A HREF="#32Mbit__32Mbit_Pragmas">32-bit:&nbsp; 32-bit Pragmas</A>
<BR><A HREF="#32Mbit__A_Subprogram_that_Never_Returns">32-bit:&nbsp; A Subprogram that Never Returns</A>
<BR><A HREF="#32Mbit__Alias_Names">32-bit:&nbsp; Alias Names</A>
<BR><A HREF="#32Mbit__Alternate_Method_of_Passing_Character_Arguments">32-bit:&nbsp; Alternate Method of Passing Character Arguments</A>
<BR><A HREF="#32Mbit__Alternate_Names_for_Symbols">32-bit:&nbsp; Alternate Names for Symbols</A>
<BR><A HREF="#32Mbit__Auxiliary_Pragmas">32-bit:&nbsp; Auxiliary Pragmas</A>
<BR><A HREF="#32Mbit__Auxiliary_Pragmas_and_the_80x87">32-bit:&nbsp; Auxiliary Pragmas and the 80x87</A>
<BR><A HREF="#32Mbit__Calling_Conventions">32-bit:&nbsp; Calling Conventions</A>
<BR><A HREF="#32Mbit__Character_Functions">32-bit:&nbsp; Character Functions</A>
<BR><A HREF="#32Mbit__Defining_Exported_Symbols_in_Dynamic_Link_Libraries">32-bit:&nbsp; Defining Exported Symbols in Dynamic Link Libraries</A>
<BR><A HREF="#32Mbit__Describing_Argument_Information">32-bit:&nbsp; Describing Argument Information</A>
<BR><A HREF="#32Mbit__Describing_Calling_Information">32-bit:&nbsp; Describing Calling Information</A>
<BR><A HREF="#32Mbit__Describing_How_Subprograms_Use_Variables_in_Common">32-bit:&nbsp; Describing How Subprograms Use Variables in Common</A>
<BR><A HREF="#32Mbit__Describing_Subprogram_Return_Information">32-bit:&nbsp; Describing Subprogram Return Information</A>
<BR><A HREF="#32Mbit__Describing_the_Registers_Modified_by_a_Subprogram">32-bit:&nbsp; Describing the Registers Modified by a Subprogram</A>
<BR><A HREF="#32Mbit__Forcing_Arguments_into_Specific_Registers">32-bit:&nbsp; Forcing Arguments into Specific Registers</A>
<BR><A HREF="#32Mbit__Loading_Data_Segment_Register">32-bit:&nbsp; Loading Data Segment Register</A>
<BR><A HREF="#32Mbit__Memory_Layout">32-bit:&nbsp; Memory Layout</A>
<BR><A HREF="#32Mbit__Passing_Arguments_in_Registers">32-bit:&nbsp; Passing Arguments in Registers</A>
<BR><A HREF="#32Mbit__Passing_Arguments_in_Reverse_Order">32-bit:&nbsp; Passing Arguments in Reverse Order</A>
<BR><A HREF="#32Mbit__Passing_Arguments_to_InMLine_Subprograms">32-bit:&nbsp; Passing Arguments to In-Line Subprograms</A>
<BR><A HREF="#32Mbit__Passing_Arguments_to_nonMFORTRAN_Subprograms">32-bit:&nbsp; Passing Arguments to non-FORTRAN Subprograms</A>
<BR><A HREF="#32Mbit__Predefined____cdecl__Alias">32-bit:&nbsp; Predefined &quot;__cdecl&quot; Alias</A>
<BR><A HREF="#32Mbit__Predefined____pascal__Alias">32-bit:&nbsp; Predefined &quot;__pascal&quot; Alias</A>
<BR><A HREF="#32Mbit__Predefined____stdcall__Alias">32-bit:&nbsp; Predefined &quot;__stdcall&quot; Alias</A>
<BR><A HREF="#32Mbit__Predefined____syscall__Alias">32-bit:&nbsp; Predefined &quot;__syscall&quot; Alias</A>
<BR><A HREF="#32Mbit__Predefined____watcall__Alias_Lregister_calling_conventionR">32-bit:&nbsp; Predefined &quot;__watcall&quot; Alias (register calling convention)</A>
<BR><A HREF="#32Mbit__Predefined____watcall__Alias_Lstack_calling_conventionR">32-bit:&nbsp; Predefined &quot;__watcall&quot; Alias (stack calling convention)</A>
<BR><A HREF="#32Mbit__Predefined_Aliases">32-bit:&nbsp; Predefined Aliases</A>
<BR><A HREF="#32Mbit__Preserving_80x87_FloatingMPoint_Registers_Across_Calls">32-bit:&nbsp; Preserving 80x87 Floating-Point Registers Across Calls</A>
<BR><A HREF="#32Mbit__Processing_Alternate_Returns">32-bit:&nbsp; Processing Alternate Returns</A>
<BR><A HREF="#32Mbit__Processing_Function_Return_Values_Using_an_80x87">32-bit:&nbsp; Processing Function Return Values Using an 80x87</A>
<BR><A HREF="#32Mbit__Processing_Function_Return_Values_with_no_80x87">32-bit:&nbsp; Processing Function Return Values with no 80x87</A>
<BR><A HREF="#32Mbit__Removing_Arguments_from_the_Stack">32-bit:&nbsp; Removing Arguments from the Stack</A>
<BR><A HREF="#32Mbit__Returning_FloatingMPoint_Data">32-bit:&nbsp; Returning Floating-Point Data</A>
<BR><A HREF="#32Mbit__Returning_Structures_and_Complex_Numbers">32-bit:&nbsp; Returning Structures and Complex Numbers</A>
<BR><A HREF="#32Mbit__Returning_Subprogram_Values_in_Registers">32-bit:&nbsp; Returning Subprogram Values in Registers</A>
<BR><A HREF="#32Mbit__Returning_Values_from_Assembly_Language_Functions">32-bit:&nbsp; Returning Values from Assembly Language Functions</A>
<BR><A HREF="#32Mbit__Specifying_Symbol_Attributes">32-bit:&nbsp; Specifying Symbol Attributes</A>
<BR><A HREF="#32Mbit__StackMBased_Calling_Convention">32-bit:&nbsp; Stack-Based Calling Convention</A>
<BR><A HREF="#32Mbit__Using_Pragmas_to_Specify_Default_Libraries">32-bit:&nbsp; Using Pragmas to Specify Default Libraries</A>
<BR><A HREF="#32Mbit__Using_the_80x87_to_Pass_Arguments">32-bit:&nbsp; Using the 80x87 to Pass Arguments</A>
<BR><A HREF="#32Mbit__Using_the_80x87_to_Return_Subprogram_Values">32-bit:&nbsp; Using the 80x87 to Return Subprogram Values</A>
<BR><A HREF="#32Mbit__Using_the_StackMBased_Calling_Convention">32-bit:&nbsp; Using the Stack-Based Calling Convention</A>
<BR><A HREF="#32Mbit__Writing_Assembly_Language_Subprograms">32-bit:&nbsp; Writing Assembly Language Subprograms</A>
<DT>- A -
<DD><A HREF="#About_This_Manual">About This Manual</A>
<BR><A HREF="#Attributes_of_Files">Attributes of Files</A>
<DT>- C -
<DD><A HREF="#CHARACTER_Data_Type">CHARACTER Data Type</A>
<BR><A HREF="#Compiler_Diagnostics">Compiler Diagnostics</A>
<BR><A HREF="#Compiler_Options">Compiler Options</A>
<BR><A HREF="#Compiler_Options_Relating_to_FloatingMpoint">Compiler Options Relating to Floating-point</A>
<BR><A HREF="#COMPLEXT16_Data_Type">COMPLEX*16 Data Type</A>
<BR><A HREF="#COMPLEX__COMPLEXT8__and_DOUBLE_COMPLEX_Data_Types">COMPLEX, COMPLEX*8, and DOUBLE COMPLEX Data Types</A>
<DT>- D -
<DD><A HREF="#Data_Representation_On_x86Mbased_Platforms">Data Representation On x86-based Platforms</A>
<BR><A HREF="#Debugging_statements_L_D__in_Column_1R">Debugging statements (&quot;D&quot; in Column 1)</A>
<BR><A HREF="#Default_Windowing_Functions">Default Windowing Functions</A>
<BR><A HREF="#The_DEFINE_Compiler_Directive">The DEFINE Compiler Directive</A>
<BR><A HREF="#DOUBLE_PRECISION_and_REALT8_Data_Types">DOUBLE PRECISION and REAL*8 Data Types</A>
<BR><A HREF="#dwfDeleteOnClose">dwfDeleteOnClose</A>
<BR><A HREF="#dwfSetAboutDlg">dwfSetAboutDlg</A>
<BR><A HREF="#dwfSetAppTitle">dwfSetAppTitle</A>
<BR><A HREF="#dwfSetConTitle">dwfSetConTitle</A>
<BR><A HREF="#dwfShutDown">dwfShutDown</A>
<BR><A HREF="#dwfYield">dwfYield</A>
<DT>- E -
<DD><A HREF="#The_EJECT_Compiler_Directive">The EJECT Compiler Directive</A>
<BR><A HREF="#The_ELSE_Compiler_Directive">The ELSE Compiler Directive</A>
<BR><A HREF="#The_ELSEIFDEF_and_ELSEIFNDEF_Compiler_Directive">The ELSEIFDEF and ELSEIFNDEF Compiler Directive</A>
<BR><A HREF="#Establishing_Connections_Between_Units_and_Files">Establishing Connections Between Units and Files</A>
<BR><A HREF="#Examples_of_FAT_File_Specifications">Examples of FAT File Specifications</A>
<BR><A HREF="#Examples_of_HPFS_File_Specifications">Examples of HPFS File Specifications</A>
<DT>- F -
<DD><A HREF="#File_Handling_Defaults">File Handling Defaults</A>
<BR><A HREF="#File_Names_in_the_FAT_File_System">File Names in the FAT File System</A>
<BR><A HREF="#File_Names_in_the_High_Performance_File_System">File Names in the High Performance File System</A>
<BR><A HREF="#File_Sharing">File Sharing</A>
<BR><A HREF="#Files_with_no_Record_Structure">Files with no Record Structure</A>
<BR><A HREF="#FINCLUDE">FINCLUDE</A>
<BR><A HREF="#Flat_Memory_Model">Flat Memory Model</A>
<BR><A HREF="#FloatingMpoint_Accuracy_On_x86Mbased_Platforms">Floating-point Accuracy On x86-based Platforms</A>
<BR><A HREF="#FloatingMpoint_Exception_Handling">Floating-point Exception Handling</A>
<BR><A HREF="#FloatingMpoint_Exceptions_On_x86Mbased_Platforms">Floating-point Exceptions On x86-based Platforms</A>
<BR><A HREF="#FORMATTED_Records">FORMATTED Records</A>
<BR><A HREF="#Functions_IARGC_and_IGETARG">Functions IARGC and IGETARG</A>
<DT>- G -
<DD><A HREF="#General_Notes_About_Compiler_Directives">General Notes About Compiler Directives</A>
<DT>- I -
<DD><A HREF="#The_IFDEF__IFNDEF_and_ENDIF_Compiler_Directive">The IFDEF, IFNDEF and ENDIF Compiler Directive</A>
<BR><A HREF="#The_INCLUDE_Compiler_Directive">The INCLUDE Compiler Directive</A>
<BR><A HREF="#InputDOutput_Buffer_Size">Input/Output Buffer Size</A>
<BR><A HREF="#INTEGER_and_INTEGERT4_Data_Types">INTEGER and INTEGER*4 Data Types</A>
<BR><A HREF="#INTEGER_Function_FGETCMD">INTEGER Function FGETCMD</A>
<BR><A HREF="#INTEGER_Function_FGETENV">INTEGER Function FGETENV</A>
<BR><A HREF="#INTEGER_Function_FILESIZE">INTEGER Function FILESIZE</A>
<BR><A HREF="#INTEGER_Function_FLUSHUNIT">INTEGER Function FLUSHUNIT</A>
<BR><A HREF="#INTEGER_Function_FNEXTRECL">INTEGER Function FNEXTRECL</A>
<BR><A HREF="#INTEGER_Function_FSIGNAL">INTEGER Function FSIGNAL</A>
<BR><A HREF="#INTEGER_Function_FSPAWN">INTEGER Function FSPAWN</A>
<BR><A HREF="#INTEGER_Function_FSYSTEM">INTEGER Function FSYSTEM</A>
<BR><A HREF="#INTEGER_Function_GROWHANDLES">INTEGER Function GROWHANDLES</A>
<BR><A HREF="#INTEGER_Function_SEEKUNIT">INTEGER Function SEEKUNIT</A>
<BR><A HREF="#INTEGER_Function_SETJMPDSubroutine_LONGJMP">INTEGER Function SETJMP/Subroutine LONGJMP</A>
<BR><A HREF="#INTEGER_Function_SETSYSHANDLE">INTEGER Function SETSYSHANDLE</A>
<BR><A HREF="#INTEGERT1_Data_Type">INTEGER*1 Data Type</A>
<BR><A HREF="#INTEGERT2_Data_Type">INTEGER*2 Data Type</A>
<BR><A HREF="#INTEGERT2_Function_SYSHANDLE">INTEGER*2 Function SYSHANDLE</A>
<DT>- L -
<DD><A HREF="#LFN">LFN</A>
<BR><A HREF="#LIB">LIB</A>
<BR><A HREF="#LIBDOS">LIBDOS</A>
<BR><A HREF="#LIBOS2">LIBOS2</A>
<BR><A HREF="#LIBPHAR">LIBPHAR</A>
<BR><A HREF="#LIBWIN">LIBWIN</A>
<BR><A HREF="#Linking_Applications_for_the_Various_16Mbit_Memory_Models">Linking Applications for the Various 16-bit Memory Models</A>
<BR><A HREF="#Linking_Applications_for_the_Various_32Mbit_Memory_Models">Linking Applications for the Various 32-bit Memory Models</A>
<BR><A HREF="#LOGICAL_and_LOGICALT4_Data_Types">LOGICAL and LOGICAL*4 Data Types</A>
<BR><A HREF="#Logical_File_Name_Support">Logical File Name Support</A>
<BR><A HREF="#LOGICALT1_Data_Type">LOGICAL*1 Data Type</A>
<DT>- M -
<DD><A HREF="#Math_Error_Functions">Math Error Functions</A>
<BR><A HREF="#Mixed_16Mbit_Memory_Model">Mixed 16-bit Memory Model</A>
<BR><A HREF="#Mixed_32Mbit_Memory_Model">Mixed 32-bit Memory Model</A>
<DT>- N -
<DD><A HREF="#NO87">NO87</A>
<DT>- O -
<DD><A HREF="#Open_Watcom_F77_Options_Summary">Open Watcom F77 Options Summary</A>
<BR><A HREF="#The_Open_Watcom_F77_Subprogram_Library">The Open Watcom F77 Subprogram Library</A>
<BR><A HREF="#Open_Watcom_FORTRAN_77_80x87_Emulator_Libraries">Open Watcom FORTRAN 77 80x87 Emulator Libraries</A>
<BR><A HREF="#Open_Watcom_FORTRAN_77_Command_Line_Examples">Open Watcom FORTRAN 77 Command Line Examples</A>
<BR><A HREF="#Open_Watcom_FORTRAN_77_Command_Line_Format">Open Watcom FORTRAN 77 Command Line Format</A>
<BR><A HREF="#The_Open_Watcom_FORTRAN_77_Compiler">The Open Watcom FORTRAN 77 Compiler</A>
<BR><A HREF="#Open_Watcom_FORTRAN_77_Compiler_Directives">Open Watcom FORTRAN 77 Compiler Directives</A>
<BR><A HREF="#Open_Watcom_FORTRAN_77_Compiler_Options">Open Watcom FORTRAN 77 Compiler Options</A>
<BR><A HREF="#Open_Watcom_FORTRAN_77_File_Handling">Open Watcom FORTRAN 77 File Handling</A>
<BR><A HREF="#Open_Watcom_FORTRAN_77_INCLUDE_File_Processing">Open Watcom FORTRAN 77 INCLUDE File Processing</A>
<BR><A HREF="#The_Open_Watcom_FORTRAN_77_Libraries">The Open Watcom FORTRAN 77 Libraries</A>
<DT>- P -
<DD><A HREF="#PATH">PATH</A>
<BR><A HREF="#The_PRAGMA_Compiler_Directive">The PRAGMA Compiler Directive</A>
<BR><A HREF="#A_Preconnection_Tutorial">A Preconnection Tutorial</A>
<BR><A HREF="#Print_File_Attributes">Print File Attributes</A>
<BR><A HREF="#Printer_Device_Support">Printer Device Support</A>
<DT>- R -
<DD><A HREF="#REAL_and_REALT4_Data_Types">REAL and REAL*4 Data Types</A>
<BR><A HREF="#REAL_Function_URAND">REAL Function URAND</A>
<BR><A HREF="#Record_Access">Record Access</A>
<BR><A HREF="#Record_Format">Record Format</A>
<BR><A HREF="#Record_Size">Record Size</A>
<BR><A HREF="#Record_Type">Record Type</A>
<DT>- S -
<DD><A HREF="#Serial_Device_Support">Serial Device Support</A>
<BR><A HREF="#Special_DOS_Device_Names">Special DOS Device Names</A>
<BR><A HREF="#Special_OSD2_Device_Names">Special OS/2 Device Names</A>
<BR><A HREF="#Storage_Organization_of_Data_Types">Storage Organization of Data Types</A>
<BR><A HREF="#Subroutine_FEXIT">Subroutine FEXIT</A>
<BR><A HREF="#Subroutine_FINTR_and_FINTRF">Subroutine FINTR and FINTRF</A>
<BR><A HREF="#Subroutine_FTRACEBACK">Subroutine FTRACEBACK</A>
<BR><A HREF="#Subroutine_GETDAT">Subroutine GETDAT</A>
<BR><A HREF="#Subroutine_GETTIM">Subroutine GETTIM</A>
<BR><A HREF="#Summary_of_16Mbit_Memory_Models">Summary of 16-bit Memory Models</A>
<BR><A HREF="#Summary_of_32Mbit_Memory_Models">Summary of 32-bit Memory Models</A>
<DT>- T -
<DD><A HREF="#Terminal_or_Console_Device_Support">Terminal or Console Device Support</A>
<BR><A HREF="#TMP">TMP</A>
<DT>- U -
<DD><A HREF="#The_UNDEFINE_Compiler_Directive">The UNDEFINE Compiler Directive</A>
<BR><A HREF="#UNFORMATTED_Records">UNFORMATTED Records</A>
<BR><A HREF="#Use_of_Environment_Variables">Use of Environment Variables</A>
<DT>- W -
<DD><A HREF="#WATCOM">WATCOM</A>
<BR><A HREF="#WCGMEMORY">WCGMEMORY</A>
<BR><A HREF="#WCL">WCL</A>
<BR><A HREF="#WCL386">WCL386</A>
<BR><A HREF="#WD">WD</A>
<BR><A HREF="#WDW">WDW</A>
<BR><A HREF="#WFC">WFC</A>
<BR><A HREF="#WFCDWFC386_Environment_Variables">WFC/WFC386 Environment Variables</A>
<BR><A HREF="#WFC386">WFC386</A>
<BR><A HREF="#WFL">WFL</A>
<BR><A HREF="#WFL386">WFL386</A>
<BR><A HREF="#WLANG">WLANG</A>
</DL>
<H1 ID="About_This_Manual"> About This Manual </H1>
<BR><IMG SRC="fguide.bmp">
<BR>This manual contains the following chapters:
<DL>
<DT>Chapter 1 -
<DD><A HREF="#About_This_Manual">About This Manual</A>.
<BR><BR>This chapter provides an overview of the contents of this guide.
<DT>Chapter 2 -
<DD><A HREF="#Open_Watcom_FORTRAN_77_Compiler_Options">Open Watcom FORTRAN 77 Compiler Options</A>.
<BR><BR>This chapter also provides a summary and reference section for the valid compiler options.
<DT>Chapter 3 -
<DD><A HREF="#The_Open_Watcom_FORTRAN_77_Compiler">The Open Watcom FORTRAN 77 Compiler</A>.
<BR><BR>This chapter describes how to compile an application from the command line, describes compiler environment variables,
provides examples of command line use of the compiler, and and describes compiler diagnostics.
<DT>Chapter 4 -
<DD><A HREF="#The_Open_Watcom_FORTRAN_77_Libraries">The Open Watcom FORTRAN 77 Libraries</A>.
<BR><BR>This chapter describes the Open Watcom FORTRAN 77 run-time libraries.
<DT>Chapter 5 -
<DD><A HREF="#Open_Watcom_FORTRAN_77_Compiler_Directives">Open Watcom FORTRAN 77 Compiler Directives</A>.
<BR><BR>This chapter describes compiler directives including INCLUDE file processing.
<DT>Chapter 6 -
<DD><A HREF="#Open_Watcom_FORTRAN_77_File_Handling">Open Watcom FORTRAN 77 File Handling</A>.
<BR><BR>This chapter describes run-time file handling.
<DT>Chapter 7 -
<DD><A HREF="#The_Open_Watcom_F77_Subprogram_Library">The Open Watcom F77 Subprogram Library</A>.
<BR><BR>This chapter describes subprograms available for special operations.
<DT>Chapter 8 -
<DD><A HREF="#16Mbit_Memory_Models">16-bit Memory Models</A>.
<BR><BR>This chapter describes the Open Watcom FORTRAN 77 memory models (including code and data models), the tiny memory
model, the mixed memory model, linking applications for the various memory models, creating a tiny memory model application,
and memory layout in an executable.
<DT>Chapter 9 -
<DD><A HREF="#16Mbit_Assembly_Language_Considerations">16-bit Assembly Language Considerations</A>.
<BR><BR>This chapter describes issues relating to 16-bit interfacing such as parameter passing conventions.
<DT>Chapter 10 -
<DD><A HREF="#16Mbit__16Mbit_Pragmas">16-bit:&nbsp; 16-bit Pragmas</A>.
<BR><BR>This chapter describes the use of pragmas with the 16-bit compilers.
<DT>Chapter 11 -
<DD><A HREF="#32Mbit_Memory_Models">32-bit Memory Models</A>.
<BR><BR>This chapter describes the Open Watcom FORTRAN 77 memory models (including code and data models), the flat memory
model, the mixed memory model, linking applications for the various memory models, and memory layout in an executable.
<DT>Chapter 12 -
<DD><A HREF="#32Mbit_Assembly_Language_Considerations">32-bit Assembly Language Considerations</A>.
<BR><BR>This chapter describes issues relating to 32-bit interfacing such as parameter passing conventions.
<DT>Chapter 13 -
<DD><A HREF="#32Mbit__32Mbit_Pragmas">32-bit:&nbsp; 32-bit Pragmas</A>.
<BR><BR>This chapter describes the use of pragmas with the 32-bit compilers.
<DT>Appendix A.&nbsp; -
<DD><A HREF="#Use_of_Environment_Variables">Use of Environment Variables</A>.
<BR><BR>This appendix describes all the environment variables used by the compilers and related tools.
</DL>
<H1 ID="Open_Watcom_FORTRAN_77_Compiler_Options"> Open Watcom FORTRAN 77 Compiler Options </H1>
<BR>Source files can be compiled using either the IDE, command-line compilers or IBM WorkFrame/2.&nbsp; This chapter describes
all the compiler options that are available.
<BR><BR>For information about compiling applications from the IDE, see the<B><I> Open Watcom Graphical Tools User's Guide.</I></B>
<BR><BR>For information about compiling applications from the command line, see the chapter entitled <A HREF="#The_Open_Watcom_FORTRAN_77_Compiler">The Open Watcom FORTRAN 77 Compiler</A>.
<BR><BR>For information about creating applications using IBM WorkFrame/2, refer to IBM's<B><I> OS/2 Programming Guide</I></B>
for more information.
<H2 ID="Open_Watcom_F77_Options_Summary"> Open Watcom F77 Options Summary </H2>
<BR>In this section, we present a terse summary of the Open Watcom F77 options.&nbsp; The next section describes these options
in more detail.&nbsp; This summary is displayed on the screen by simply entering the &quot;WFC&quot; or &quot;WFC386&quot;
command with no arguments.
<DL>
<DT><B><I>Compiler options:</I></B>
<DD><B><I>Description:</I></B>
<DT>0
<DD>(16-bit only) assume 8088/8086 processor
<DT>1
<DD>(16-bit only) assume 188/186 processor
<DT>2
<DD>(16-bit only) assume 286 processor
<DT>3
<DD>assume 386 processor
<DT>4
<DD>assume 486 processor
<DT>5
<DD>assume Pentium processor
<DT>6
<DD>assume Pentium Pro processor
<DT>[NO]ALign
<DD>align COMMON segments
<DT>[NO]AUtomatic
<DD>all local variables on the stack
<DT>BD
<DD>(32-bit only) dynamic link library
<DT>BM
<DD>(32-bit only) multithread application
<DT>[NO]BOunds
<DD>generate subscript bounds checking code
<DT>BW
<DD>(32-bit only) default windowed application
<DT>[NO]CC
<DD>carriage control recognition requested for output devices such as the console
<DT>CHInese
<DD>Chinese character set
<DT>[NO]COde
<DD>constants in code segment
<DT>D1
<DD>include line # debugging information
<DT>D2
<DD>include full debugging information
<DT>[NO]DEBug
<DD>perform run-time checking
<DT>DEFine=&lt;macro&gt;
<DD>define macro
<DT>[NO]DEPendency
<DD>generate file dependencies
<DT>[NO]DEScriptor
<DD>pass character arguments using string descriptor
<DT>DIsk
<DD>write listing file to disk
<DT>DT=&lt;size&gt;
<DD>set data threshold
<DT>[NO]ERrorfile
<DD>generate an error file
<DT>[NO]EXPlicit
<DD>declare type of all symbols
<DT>[NO]EXtensions
<DD>issue extension messages
<DT>[NO]EZ
<DD>(32-bit only) Easy OMF-386 object files
<DT>FO=&lt;obj_default&gt;
<DD>set default object file name
<DT>[NO]FORmat
<DD>relax format type checking
<DT>FPC
<DD>generate calls to floating-point library
<DT>FPD
<DD>enable generation of Pentium FDIV bug check code
<DT>FPI
<DD>generate inline 80x87 instructions with emulation
<DT>FPI87
<DD>generate inline 80x87 instructions
<DT>FPR
<DD>floating-point backward compatibility
<DT>FP2
<DD>generate inline 80x87 instructions
<DT>FP3
<DD>generate inline 80387 instructions
<DT>FP5
<DD>optimize floating-point for Pentium
<DT>FP6
<DD>optimize floating-point for Pentium Pro
<DT>[NO]FSfloats
<DD>FS not fixed
<DT>[NO]GSfloats
<DD>GS not fixed
<DT>HC
<DD>Codeview debugging information
<DT>HD
<DD>DWARF debugging information
<DT>HW
<DD>Open Watcom debugging information
<DT>[NO]INCList
<DD>write content of INCLUDE files to listing
<DT>INCPath=[d:]path
<DD>[d:]path...&nbsp; path for INCLUDE files
<DT>[NO]IPromote
<DD>promote INTEGER*1 and INTEGER*2 arguments to INTEGER*4
<DT>Japanese
<DD>Japanese character set
<DT>KOrean
<DD>Korean character set
<DT>[NO]LFwithff
<DD>LF with FF
<DT>[NO]LIBinfo
<DD>include default library information in object file
<DT>[NO]LISt
<DD>generate a listing file
<DT>[NO]MAngle
<DD>mangle COMMON segment names
<DT>MC
<DD>(32-bit only) compact memory model
<DT>MF
<DD>(32-bit only) flat memory model
<DT>MH
<DD>(16-bit only) huge memory model
<DT>ML
<DD>large memory model
<DT>MM
<DD>medium memory model
<DT>MS
<DD>(32-bit only) small memory model
<DT>OB
<DD>(32-bit only) base pointer optimizations
<DT>OBP
<DD>branch prediction
<DT>OC
<DD>do not convert &quot;call&quot; followed by &quot;ret&quot; to &quot;jmp&quot;
<DT>OD
<DD>disable optimizations
<DT>ODO
<DD>DO-variables do not overflow
<DT>OF
<DD>always generate a stack frame
<DT>OH
<DD>enable repeated optimizations (longer compiles)
<DT>OI
<DD>generate statement functions in-line
<DT>OK
<DD>enable control flow prologues and epilogues
<DT>OL
<DD>perform loop optimizations
<DT>OL+
<DD>perform loop optimizations with loop unrolling
<DT>OM
<DD>generate floating-point 80x87 math instructions in-line
<DT>ON
<DD>numeric optimizations
<DT>OP
<DD>precision optimizations
<DT>OR
<DD>instruction scheduling
<DT>OS
<DD>optimize for space
<DT>OT
<DD>optimize for time
<DT>OX
<DD>equivalent to OBP, ODO, OI, OK, OL, OM, OR, and OT (16-bit) or OB, OBP, ODO, OI, OK, OL, OM, OR, and OT (32-bit)
<DT>PRint
<DD>write listing file to printer
<DT>[NO]Quiet
<DD>operate quietly
<DT>[NO]Reference
<DD>issue unreferenced warning
<DT>[NO]RESource
<DD>messages in resource file
<DT>[NO]SAve
<DD>SAVE local variables
<DT>[NO]SC
<DD>(32-bit only) stack calling convention
<DT>[NO]SEpcomma
<DD>allow comma separator in formatted input
<DT>[NO]SG
<DD>(32-bit only) automatic stack growing
<DT>[NO]SHort
<DD>set default INTEGER/LOGICAL size to 2/1 bytes
<DT>[NO]SR
<DD>save/restore segment registers
<DT>[NO]SSfloats
<DD>(16-bit only) SS is not default data segment
<DT>[NO]STack
<DD>generate stack checking code
<DT>[NO]SYntax
<DD>syntax check only
<DT>[NO]TErminal
<DD>messages to terminal
<DT>[NO]TRace
<DD>generate code for run-time traceback
<DT>TYpe
<DD>write listing file to terminal
<DT>[NO]WArnings
<DD>issue warning messages
<DT>[NO]WILd
<DD>relax wild branch checking
<DT>[NO]WIndows
<DD>(16-bit only) compile code for Windows
<DT>[NO]XFloat
<DD>extend floating-point precision
<DT>[NO]XLine
<DD>extend line length to 132
</DL>
<BR>A summary of the option defaults follows:&nbsp; 
<DL>
<DT>0
<DD>16-bit only
<DT>5
<DD>32-bit only
<DT>ALign
<DD>
<DT>NOAUtomatic
<DD>
<DT>NOBOunds
<DD>
<DT>NOCC
<DD>
<DT>NOCOde
<DD>
<DT>NODEBug
<DD>
<DT>DEPendency
<DD>
<DT>DEScriptor
<DD>
<DT>DT=256
<DD>
<DT>ERrorfile
<DD>
<DT>NOEXPlicit
<DD>
<DT>NOEXtensions
<DD>
<DT>NOEZ
<DD>32-bit only
<DT>NOFORmat
<DD>
<DT>FPI
<DD>
<DT>FP2
<DD>16-bit only
<DT>FP3
<DD>32-bit only
<DT>NOFPD
<DD>
<DT>FSfloats
<DD>all but flat memory model
<DT>NOFSfloats
<DD>flat memory model only
<DT>GSfloats
<DD>
<DT>NOINCList
<DD>
<DT>NOIPromote
<DD>
<DT>NOLFwithff
<DD>
<DT>LIBinfo
<DD>
<DT>NOLISt
<DD>
<DT>NOMAngle
<DD>
<DT>ML
<DD>16-bit only
<DT>MF
<DD>32-bit only
<DT>NOQuiet
<DD>
<DT>Reference
<DD>
<DT>NORESource
<DD>
<DT>NOSAve
<DD>
<DT>NOSC
<DD>32-bit only
<DT>NOSEpcomma
<DD>
<DT>NOSG
<DD>32-bit only
<DT>NOSHort
<DD>
<DT>NOSR
<DD>
<DT>NOSSfloats
<DD>16-bit only
<DT>NOSTack
<DD>
<DT>NOSYntax
<DD>
<DT>TErminal
<DD>
<DT>NOTRace
<DD>
<DT>WArnings
<DD>
<DT>NOWILd
<DD>
<DT>NOWIndows
<DD>16-bit only
<DT>NOXFloat
<DD>
<DT>NOXLine
<DD>
</DL>
<H2 ID="Compiler_Options"> Compiler Options </H2>
<BR>Compiler options may be entered in one of two places.&nbsp; They may be included in the options list of the command line
or they may be included as comments of the form &quot;C$option&quot;, &quot;c$option&quot;, or &quot;*$option&quot; in the
source input stream.&nbsp; The compiler recognizes these special comments as compiler directives.
<BR><BR>Some options may only be specified in the options list of the command line.&nbsp; Unless otherwise stated, an option
can appear on the command line only.&nbsp; We also indicate what the default is for an option or group of options.
<BR><BR>When specifying options in the source file, it is possible to specify more than one option on a line.&nbsp; For example,
the following source line tells Open Watcom F77 to not issue any warning or extension messages.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$nowarn noext</TT>
<BR><BR>Note that only the first option must contain the &quot;*$&quot;, &quot;C$&quot;, or &quot;c$&quot; prefix.
<BR><BR>Short forms are indicated by upper case letters.
<DL>
<DT><B><I>Option:</I></B>
<DD><B><I>Description:</I></B>
<DT>0
<DD>(16-bit only) Open Watcom F77 will make use of only 8088/8086 instructions in the generated object code.&nbsp; The resulting
code will run on 8086 and all upward compatible processors.&nbsp; This is the default option for the 16-bit compiler.
<DT>1
<DD>(16-bit only) Open Watcom F77 will make use of 188/186 instructions in the generated object code whenever possible.&nbsp;
The resulting code probably will not run on 8086 compatible processors but it will run on 186 and all upward compatible processors.
<DT>2
<DD>(16-bit only) Open Watcom F77 will make use of 286 instructions in the generated object code whenever possible.&nbsp; The
resulting code probably will not run on 8086 or 186 compatible processors but it will run on 286 and all upward compatible
processors.
<DT>3
<DD>Open Watcom F77 will assume a 386 processor and will generate instructions based on 386 instruction timings.
<DT>4
<DD>Open Watcom F77 will assume a 486 processor and will generate 386 instructions based on 486 instruction timings.&nbsp; The
code is optimized for 486 processors rather than 386 processors.
<DT>5
<DD>Open Watcom F77 will assume a Pentium processor and will generate 386 instructions based on Pentium instruction timings.&nbsp;
The code is optimized for Pentium processors rather than 386 processors.&nbsp; This is the default option for the 32-bit compiler.
<DT>6
<DD>Open Watcom F77 will assume a Pentium Pro processor and will generate 386 instructions based on Pentium Pro instruction timings.
&nbsp;The code is optimized for Pentium Pro processors rather than 386 processors.
<DT>[NO]ALign
<DD>The &quot;align&quot; option tells the compiler to allocate all COMMON blocks on paragraph boundaries (multiples of 16).&nbsp;
If you do not want COMMON blocks to be aligned, specify &quot;noalign&quot;.&nbsp; The default is &quot;align&quot;.
<DT>[NO]AUtomatic
<DD>The &quot;automatic&quot; option tells the compiler to allocate all local variables, including arrays, on the stack.&nbsp;
This is particularly useful for recursive functions or subroutines that require a new set of local variables to be allocated
for each recursive invocation.&nbsp; Note that the &quot;automatic&quot; option may significantly increase the stack requirements
of your application.&nbsp; You can increase your stack size by using the &quot;STACK&quot; option when you link your application.
<DT>BD
<DD>(32-bit only, OS/2 and Windows NT only) This option causes the compiler to imbed the appropriate DLL library name in the object
file and to include the appropriate DLL initialization code sequence when the application is linked.
<DT>BM
<DD>(32-bit only, OS/2 and Windows NT only) This option causes the compiler to imbed the appropriate multi-thread library name
in the object file.
<DT>[NO]BOunds
<DD>The &quot;bounds&quot; option causes the generation of code that performs array subscript and character substring bounds checking.
&nbsp;Note that this option may significantly reduce the performance of your application but is an excellent way to eliminate
many programming errors.&nbsp; The default option is &quot;nobounds&quot;.
<DT>BW
<DD>(OS/2, Windows 3.x, and Windows NT only) This option causes the compiler to import a special symbol so that the default windowing
library code is linked into your application.
<DT>[NO]CC
<DD>The &quot;cc&quot; option specifies that the output to devices contains carriage control information that is to be interpreted
appropriately for the output device (e.g., console device).&nbsp; ASA carriage control characters are converted to ASCII vertical
spacing control characters.&nbsp; Note that a blank carriage control character will automatically be generated for list-directed
output and will be interpreted as a single-line spacing command.
<DT>CHInese
<DD>This option is part of the national language support provided by Open Watcom F77.&nbsp; It instructs the compiler that the
source code contains characters from the Traditional Chinese character set.&nbsp; This includes double-byte characters.&nbsp;
This option enables the use of Chinese variable names.&nbsp; The compiler's run-time system will ensure that character strings
are not split in the middle of a double-byte character when output spans record boundaries (as can happen in list-directed
output).
<DT>[NO]COde
<DD>The &quot;code&quot; option causes the code generator to place character and numeric constants in code segment.&nbsp; Data
generated for FORMAT statements will also be placed in the code segment.&nbsp; The default option is &quot;nocode&quot;.
<DT>D1
<DD>Line number information is included in the object file (&quot;type 1 debugging information&quot;).&nbsp; This option provides
additional information to Open Watcom Debugger (at the expense of larger object files and executable files).&nbsp; Line numbers
are handy when debugging your application with Open Watcom Debugger.
<DT>D2
<DD>In addition to line number information, local symbol and data type information is included in the object file (&quot;type
2 debugging information&quot;).&nbsp; Although global symbol information can be made available to Open Watcom Debugger through
a Open Watcom Linker option, local symbol and typing information must be requested when the source file is compiled.&nbsp;
This option provides additional information to Open Watcom Debugger (at the expense of larger object files and executable
files).&nbsp; However, it will make the debugging chore somewhat easier.
<DT>[NO]DEBug
<DD>The &quot;debug&quot; option causes the generation of run-time checking code.&nbsp; This includes subscript and substring
bounds checking as well as code that allows a run-time traceback to be issued when an error occurs.&nbsp; The default option
is &quot;nodebug&quot;.
<DT>DEFine=&lt;macro&gt;
<DD>This option is equivalent to specifying the following &quot;define&quot; compiler directive.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$define &lt;macro&gt;</TT>
<BR><BR>The macro specified by the &quot;define&quot; option or compiler directive becomes defined.&nbsp; The definition status
of the specified macro can be checked using the &quot;ifdef&quot;, &quot;ifndef&quot;, &quot;elseifdef&quot; or &quot;elseifndef&quot;
compiler directives.&nbsp; This allows source code to be conditionally compiled depending on the definition status of the
macro.&nbsp; 
<BR><BR>The macro<TT> __i86__</TT> is a special macro that is defined by the compiler and identifies the target as a 16-bit
Intel 80x86 compatible environment.
<BR><BR>The macro<TT> __386__</TT> is a special macro that is defined by the compiler and identifies the target as a 32-bit
Intel 386 compatible environment.
<BR><BR>The macro<TT> __stack_conventions__</TT> is a special macro that is defined by the 32-bit compiler when the &quot;sc&quot;
compiler option is specified to indicate that stack calling conventions are to be used for code generation.
<BR><BR>The macro<TT> __fpi__</TT> is a special macro that is defined by the compiler when one of the following floating-point
options is specified:&nbsp; &quot;fpi&quot; or &quot;fpi87&quot;.
<DT>[NO]DEPendency
<DD>The &quot;dependency&quot; option specifies that file dependencies are to be included in the object file.&nbsp; This is the
default option.&nbsp; This option is used by the Open Watcom Integrated Development Environment to determine if an object
file is up-to-date with respect to the source files used to build it.&nbsp; You can specify the &quot;nodependency&quot; option
if you do not want file dependencies to be included in the object file.
<DT>[NO]DEScriptor
<DD>The &quot;descriptor&quot; option specifies that string descriptors are to be passed for character arguments.&nbsp; This is
the default option.&nbsp; You can specify the &quot;nodescriptor&quot; option if you do not want string descriptors to be
passed for character arguments.&nbsp; Instead, the pointer to the actual character data and the length will be passed as two
arguments.&nbsp; The arguments for the length will be passed as additional arguments following the normal argument list.&nbsp;
For character functions, the pointer to the data and the length of the character function will be passed as the first two
arguments.
<DT>DIsk
<DD>When this option is used in conjunction with the &quot;list&quot; option, the listing file is written to the current directory
of the default disk.&nbsp; The listing file name will be the same as the source file name but the file extension will be<TT>
.lst</TT>.&nbsp; By default, listing files are written to disk.&nbsp; The &quot;disk&quot; option will override any previously
specified &quot;type&quot; or &quot;print&quot; option.
<DT>DT=&lt;size&gt;
<DD>The &quot;data threshold&quot; option is used to set the minimum size for data objects to be included in the default data
segment.&nbsp; Normally, all data objects smaller than 256 bytes in size are placed in the default data segment.&nbsp; When
there is a large amount of static data, it is often useful to set the data threshold size so that all objects of the specified
size or larger are placed into another segment.&nbsp; For example, the option:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /DT=100</TT>
<BR><BR>causes all data objects of 100 bytes or more to be placed in a far data segment.&nbsp; The &quot;data threshold&quot;
only applies to the large and huge memory models where there can be more than one data segment.&nbsp; The default data threshold
value is 256.
<DT>[NO]ERrorfile
<DD>This option is used to control whether error messages are output to a separate error file.&nbsp; The error file is a disk
file of type<TT> .err</TT> and is produced if any diagnostic messages are issued by the compiler.&nbsp; Specifying &quot;noerrorfile&quot;
prevents the creation of an error file.&nbsp; By default, an error file is created.
<BR><BR>If an error file exists before compilation begins, it will be erased.&nbsp; If no diagnostic messages are produced
then an error file will not be created even though the &quot;errorfile&quot; option is selected.&nbsp; This option has no
effect on the inclusion of diagnostic messages in the source listing file or the production of diagnostic messages on the
screen.
<DT>[NO]EXPlicit
<DD>The &quot;explicit&quot; option requires the type of all symbols to be explicitly declared.&nbsp; An error message will be
issued by the compiler if a symbol that does not appear in a type declaration statement is encountered.&nbsp; Specifying this
option is equivalent to using the<B><I> IMPLICIT NONE</I></B> statement.&nbsp; By default, symbols do not have to be explicitly
typed.
<DT>[NO]EXtensions
<DD>This option is used to control the printing of extension messages.&nbsp; This option may be specified on the command line
or it may be placed anywhere in the source input stream.&nbsp; In a source file, the option appears as a comment line and
takes the following form.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$[NO]EXtensions</TT>
<BR><BR>The &quot;extensions&quot; option enables the printing of extension messages, while &quot;noextensions&quot; disables
the printing of these messages.&nbsp; By default, extension messages are not printed.
<DT>[NO]EZ
<DD>(32-bit only) Open Watcom F77 will generate an object file in Phar Lap Easy OMF-386 (object module format) instead of the
default Microsoft OMF.&nbsp; The default option is &quot;noez&quot;.
<DT>FO=&lt;obj_default&gt;
<DD>By default, the object file name is constructed from the source file name.&nbsp; Using the &quot;fo&quot; option, the default
object file drive, path, file name and extension can be specified.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wfc386 report /fo=d:\programs\obj\</TT>
<BR><BR>A trailing &quot;\&quot; must be specified for directory names.&nbsp; If, for example, the option was specified as
&quot;/fo=d:\programs\obj&quot; then the object file would be called<TT> D:\PROGRAMS\OBJ.OBJ.</TT>
<BR><BR>A default extension must be preceded by a period (&quot;.&quot;).
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wfc386 report /fo=d:\programs\obj\.dbo</TT>
<DT>[NO]FORmat
<DD>The &quot;format&quot; option suppresses the run-time checking that ensures that the type of an input/output list item matches
the format edit descriptor in a format specification.&nbsp; This allows an input/output list item of type INTEGER to be formatted
using an F, E or D edit descriptor.&nbsp; It also allows an input/output list item of a floating-point type to be formatted
using an I edit descriptor.&nbsp; Normally, this generates an error.&nbsp; The &quot;format&quot; option is particularly useful
for applications that use integer arrays to store integer and floating-point data.&nbsp; The default option is &quot;noformat&quot;.
<DT>FPC
<DD>All floating-point arithmetic is done with calls to a floating-point emulation library.&nbsp; This option should be used when
speed of floating-point emulation is favoured over code size.
<DT>FPI
<DD>(16-bit only) Open Watcom F77 will generate in-line 80x87 numeric data processor instructions into the object code for floating-point
operations.&nbsp; Depending on which library the code is linked against, these instructions will be left as is or they will
be replaced by special interrupt instructions.&nbsp; In the latter case, floating-point will be emulated if an 80x87 is not
present.&nbsp; This is the default floating-point option if none is specified.
<BR><BR>(32-bit only) Open Watcom F77 will generate in-line 80x87 numeric data processor instructions into the object code
for floating-point operations.&nbsp; When any module containing floating-point operations is compiled with the &quot;fpi&quot;
option, coprocessor emulation software will be included in the application when it is linked.&nbsp; Thus, an 80x87 coprocessor
need not be present at run-time.&nbsp; This is the default floating-point option if none is specified.
<DT>FPI87
<DD>(16-bit only) Open Watcom F77 will generate in-line 80x87 numeric data processor instructions into the object code for floating-point
operations.&nbsp; An 80x87 coprocessor must be present at run-time.&nbsp; If the &quot;2&quot; option is used in conjunction
with this option, Open Watcom F77 will generate 287/387 compatible instructions; otherwise Open Watcom F77 will generate 8087
compatible instructions.
<BR><BR>(32-bit only) Open Watcom F77 will generate in-line 80x87 numeric data processor instructions into the object code
for floating-point operations.&nbsp; When the &quot;fpi87&quot; option is used exclusively, coprocessor emulation software
is not included in the application when it is linked.&nbsp; A 80x87 coprocessor must be present at run-time.&nbsp; 
<BR><BR><B>16-bit Notes:</B>
<OL>
<LI>When any module in an application is compiled with a particular &quot;floating-point&quot; option, then all modules must
be compiled with the same option.
<LI>Different math libraries are provided for applications which have been compiled with a particular floating-point option.
&nbsp;See the chapter entitled <A HREF="#The_Open_Watcom_FORTRAN_77_Libraries">The Open Watcom FORTRAN 77 Libraries</A>.
</OL>
<BR><B>32-bit Notes:</B>
<OL>
<LI>When any module in an application is compiled with the &quot;fpc&quot; option, then all modules must be compiled with
the &quot;fpc&quot; option.
<LI>When any module in an application is compiled with the &quot;fpi&quot; or &quot;fpi87&quot; option, then all modules must
be compiled with one of these two options.
<LI>If you wish to have floating-point emulation software included in the application, you should select the &quot;fpi&quot;
option.&nbsp; A 387 coprocessor need not be present at run-time.
<LI>Different math libraries are provided for applications which have been compiled with a particular floating-point option.
&nbsp;See the chapter entitled <A HREF="#The_Open_Watcom_FORTRAN_77_Libraries">The Open Watcom FORTRAN 77 Libraries</A>.
</OL>
<DT>FP2
<DD>Open Watcom F77 will generate in-line 80x87 numeric data processor instructions into the object code for floating-point operations.
&nbsp;For Open Watcom compilers generating 16-bit, this is the default.&nbsp; For 32-bit applications, use this option if
you wish to support those few 386 systems that are equipped with an 80287 numeric data processor (&quot;fp3&quot; is the default
for Open Watcom compilers generating 32-bit code).&nbsp; However, for 32-bit applications, the use of this option will reduce
execution performance.
<DT>FP3
<DD>Open Watcom F77 will generate in-line 387-compatible numeric data processor instructions into the object code for floating-point
operations.&nbsp; For 16-bit applications, the use of this option will limit the range of systems on which the application
will run but there are execution performance improvements.
<DT>FP5
<DD>Open Watcom F77 will generate in-line 387-compatible numeric data processor instructions into the object code for floating-point
operations.&nbsp; The sequence of floating-point instructions will be optimized for greatest possible performance on the Intel
Pentium processor.&nbsp; For 16-bit applications, the use of this option will limit the range of systems on which the application
will run but there are execution performance improvements.
<DT>FP6
<DD>Open Watcom F77 will generate in-line 387-compatible numeric data processor instructions into the object code for floating-point
operations.&nbsp; The sequence of floating-point instructions will be optimized for greatest possible performance on the Intel
Pentium Pro processor.&nbsp; For 16-bit applications, the use of this option will limit the range of systems on which the
application will run but there are execution performance improvements.
<DT>[NO]FPD
<DD>A subtle problem was detected in the FDIV instruction of Intel's original Pentium CPU.&nbsp; In certain rare cases, the result
of a floating-point divide could have less precision than it should.&nbsp; Contact Intel directly for more information on
the issue.
<BR><BR>As a result, the run-time system startup code has been modified to test for a faulty Pentium.&nbsp; If the FDIV instruction
is found to be flawed, the low order bit of the run-time system variable<TT> __chipbug</TT> will be set.
<BR><BR>If the FDIV instruction does not show the problem, the low order bit will be clear.&nbsp; If the Pentium FDIV flaw
is a concern for your application, there are two approaches that you could take:
<OL>
<LI>You may test the<TT> __chipbug</TT> variable in your code in all floating-point and memory models and take appropriate
action (such as display a warning message or discontinue the application).
<LI>Alternately, you can use the &quot;fpd&quot; option when compiling your code.&nbsp; This option directs the compiler to
generate additional code whenever an FDIV instruction is generated which tests the low order bit of<TT> __chipbug</TT> and,
if on, calls the software workaround code in the math libraries.&nbsp; If the bit is off, an in-line FDIV instruction will
be performed as before.
</OL>
<BR>If you know that your application will never run on a defective Pentium CPU, or your analysis shows that the FDIV problem
will not affect your results, you need not use the &quot;fpd&quot; option.
<DT>FPR
<DD>Use this option if you want to generate floating-point instructions that will be compatible with version 9.0 or earlier of
the compilers.&nbsp; For more information on floating-point conventions see the sections entitled <A HREF="#16Mbit__Using_the_80x87_to_Pass_Arguments">16-bit:&nbsp; Using the 80x87 to Pass Arguments</A>
and <A HREF="#32Mbit__Using_the_80x87_to_Pass_Arguments">32-bit:&nbsp; Using the 80x87 to Pass Arguments</A>.
<DT>[NO]FSfloats
<DD>The &quot;fsfloats&quot; option enables the use of the FS segment register in the generated code.&nbsp; This is the default
for all but the flat memory model.&nbsp; In the flat memory model, the default is &quot;nofsfloats&quot; (the FS segment register
is not used in the generated code).
<DT>[NO]GSfloats
<DD>The &quot;gsfloats&quot; option enables the use of the GS segment register in the generated code.&nbsp; This is the default.
&nbsp;If you would like to prevent the use of the GS segment register in the the generated code, specify the &quot;nogsfloats&quot;
option.
<DT>HC
<DD>The type of debugging information that is to be included in the object file is &quot;Codeview&quot;.&nbsp; The default type
of debugging information is &quot;Dwarf&quot; (HD).&nbsp; If you wish to use the Microsoft Codeview debugger, then choose
the &quot;HC&quot; option.&nbsp; When linking the application, you must also choose the appropriate Open Watcom Linker DEBUG
directive.&nbsp; See the<B><I> Open Watcom Linker User's Guide</I></B> for more information.
<DT>HD
<DD>The type of debugging information that is to be included in the object file is &quot;Dwarf&quot;.&nbsp; This is the default
type of debugging information.&nbsp; If you wish to use the Microsoft Codeview debugger, then choose the &quot;HC&quot; option.
&nbsp;When linking the application, you must also choose the appropriate Open Watcom Linker DEBUG directive.&nbsp; See the<B><I>
Open Watcom Linker User's Guide</I></B> for more information.
<DT>HW
<DD>The type of debugging information that is to be included in the object file is &quot;Open Watcom&quot;.&nbsp; The default
type of debugging information is &quot;Dwarf&quot; (HD).&nbsp; If you wish to use the Microsoft Codeview debugger, then choose
the &quot;HC&quot; option.&nbsp; When linking the application, you must also choose the appropriate Open Watcom Linker DEBUG
directive.&nbsp; See the<B><I> Open Watcom Linker User's Guide</I></B> for more information.
<DT>[NO]INCList
<DD>This option is used to control the listing of the contents of INCLUDE files to the listing file.&nbsp; The &quot;inclist&quot;
option enables the listing of INCLUDE files, while &quot;noinclist&quot; disables the listing of these files.&nbsp; The default
option is &quot;noinclist&quot;.
<DT>INCPath=[d:]path
<DD>[d:]path...&nbsp; This option is used to specify directories that are to be searched for include files.&nbsp; Each path is
separated from the previous by a semicolon (&quot;;&quot;).&nbsp; These directories are searched in the order listed before
those in the<B> FINCLUDE</B> environment variable.
<DT>[NO]IPromote
<DD>The &quot;ipromote&quot; option causes the compiler to promote the INTEGER*1 and INTEGER*2 arguments of some INTEGER*4 intrinsics
without issuing an error diagnostic.&nbsp; This allows code such as the following to be compiled without error:
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER I*1, J*2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I = 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; J = 2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, IDIM( I, J )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>This works for the following intrinsic functions:&nbsp; ABS(), IABS(), DIM(), IDIM(), SIGN(), ISIGN(), MAX(), AMAX0(),
MAX0(), MIN(), AMIN0(), and MIN0().&nbsp; When the &quot;ipromote&quot; option is specified, all integer arguments that are
passed to these functions are promoted to INTEGER*4.
<DT>Japanese
<DD>This option is part of the national language support provided by Open Watcom F77.&nbsp; It instructs the compiler that the
source code contains characters from the Japanese character set.&nbsp; This includes double-byte characters.&nbsp; This option
enables the use of Japanese variable names.&nbsp; The compiler's run-time system will ensure that character strings are not
split in the middle of a double-byte character when output spans record boundaries (as can happen in list-directed output).
<DT>KORean
<DD>This option is part of the national language support provided by Open Watcom F77.&nbsp; It instructs the compiler that the
source code contains characters from the Korean character set.&nbsp; This includes double-byte characters.&nbsp; This option
enables the use of Korean variable names.&nbsp; The compiler's run-time system will ensure that character strings are not
split in the middle of a double-byte character when output spans record boundaries (as can happen in list-directed output).
<DT>[NO]LFwithff
<DD>This option is used to control whether a line-feed character (LF=CHAR(10)) is to be emitted before a form-feed character (FF=CHAR(12))
is emitted.&nbsp; This option applies to carriage control handling.&nbsp; Normally, the run-time system will emit only a form-feed
character to cause a page eject when the ASA control character &quot;1&quot; is found in the first column of a record.&nbsp;
The &quot;lfwithff&quot; option will cause the run-time system to emit a line-feed character and then a form-feed character.
<BR><BR>The &quot;lfwithff&quot; option will have little effect on printers, but it will change the appearance of output to
the screen by eliminating overwritten text when form-feed characters are not handled by the output device.&nbsp; The default
option is &quot;nolfwithff&quot;.
<DT>[NO]LIBinfo
<DD>This option is used to control the inclusion of default library information in the object file.&nbsp; The &quot;libinfo&quot;
option enables the inclusion of default library information, while &quot;nolibinfo&quot; disables the inclusion of this information.
&nbsp;The default option is &quot;libinfo&quot;.
<DT>[NO]LISt
<DD>This option may be specified on the command line or it may be placed anywhere in the source input stream.&nbsp; On the command
line, this option is used to control the creation of a listing file.&nbsp; The &quot;list&quot; option causes a listing file
to be created while &quot;nolist&quot; requests that no listing file be created.&nbsp; The default option is &quot;nolist&quot;.
<BR><BR>In a source file, the option appears as a comment line and takes the following form.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$[NO]LISt</TT>
<BR><BR>Specifying *$LIST causes the source lines that follow this option to be listed in the source listing file while *$NOLIST
disables the listing of the source lines that follow.&nbsp; This option cannot appear on the same source line with other options.
<DT>[NO]MAngle
<DD>This option is used to alter COMMON block segment and class names.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REAL R, S</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; COMMON /BLK/ R, S</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>For a named COMMON block called &quot;BLK&quot;, the default convention is to name the segment &quot;BLK&quot; and
the class &quot;BLK&quot;.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; BLK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SEGMENT PARA
COMMON USE32 'BLK'</TT>
<BR><BR>When you use the &quot;mangle&quot; option, the segment is named &quot;_COMMON_BLK&quot; and the class is named &quot;_COMMON_BLK_DATA&quot;.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _COMMON_BLK&nbsp;&nbsp;&nbsp;&nbsp; SEGMENT PARA COMMON USE32 '_COMMON_BLK_DATA'</TT>
<DT>MC
<DD>(32-bit only) The &quot;compact&quot; memory model (small code, big data) is selected.&nbsp; The various models supported
by Open Watcom F77 are described in the chapters entitled <A HREF="#16Mbit_Memory_Models">16-bit Memory Models</A> and <A HREF="#32Mbit_Memory_Models">32-bit Memory Models</A>.
<DT>MF
<DD>(32-bit only) The &quot;flat&quot; memory model (code and data up to 4 gigabytes) is selected.&nbsp; The various models supported
by Open Watcom F77 are described in the chapters entitled <A HREF="#16Mbit_Memory_Models">16-bit Memory Models</A> and <A HREF="#32Mbit_Memory_Models">32-bit Memory Models</A>.
&nbsp;This is the default memory model option.
<DT>MH
<DD>(16-bit only) The &quot;huge&quot; memory model (big code, huge data) is selected.&nbsp; The various models supported by Open
Watcom F77 are described in the chapters entitled <A HREF="#16Mbit_Memory_Models">16-bit Memory Models</A> and <A HREF="#32Mbit_Memory_Models">32-bit Memory Models</A>.
<DT>ML
<DD>The &quot;large&quot; memory model (big code, big data) is selected.&nbsp; The various models supported by Open Watcom F77
are described in the chapters entitled <A HREF="#16Mbit_Memory_Models">16-bit Memory Models</A> and <A HREF="#32Mbit_Memory_Models">32-bit Memory Models</A>.
&nbsp;This is the default 16-bit memory model option.
<DT>MM
<DD>The &quot;medium&quot; memory model (big code, small data) is selected.&nbsp; The various models supported by Open Watcom
F77 are described in the chapters entitled <A HREF="#16Mbit_Memory_Models">16-bit Memory Models</A> and <A HREF="#32Mbit_Memory_Models">32-bit Memory Models</A>.
<DT>MS
<DD>(32-bit only) The &quot;small&quot; memory model (small code, small data) is selected.&nbsp; The various models supported
by Open Watcom F77 are described in the chapters entitled <A HREF="#16Mbit_Memory_Models">16-bit Memory Models</A> and <A HREF="#32Mbit_Memory_Models">32-bit Memory Models</A>.
<DT>OB
<DD>(32-bit only) This option allows the use of the ESP register as a base register to reference local variables and subprogram
arguments in the generated code.&nbsp; This can reduce the size of the prologue/epilogue sequences generated by the compiler
thus improving overall performance.&nbsp; Note that when this option is specified, the compiler will abort when there is not
enough memory to optimize the subprogram.&nbsp; By default, the code generator uses more memory-efficient algorithms when
a low-on-memory condition is detected.
<DT>OBP
<DD>This option causes the code generator to try to order the blocks of code emitted such that the &quot;expected&quot; execution
path (as determined by a set of simple heuristics) will be straight through, with other cases being handled by jumps to separate
blocks of code &quot;out of line&quot;.&nbsp; This will result in better cache utilization on the Pentium.&nbsp; If the heuristics
do not apply to your code, it could result in a performance decrease.
<DT>OC
<DD>This option may be used to disable the optimization where a &quot;CALL&quot; followed by a &quot;RET&quot; (return) is changed
into a &quot;JMP&quot; (jump) instruction.&nbsp; This option is required if you wish to link an overlayed program using the
Microsoft DOS Overlay Linker.&nbsp; The Microsoft DOS Overlay Linker will create overlay calls for a &quot;CALL&quot; instruction
only.&nbsp; This option is not required when using the Open Watcom Linker.&nbsp; This option is not assumed by default.
<DT>OD
<DD>Non-optimized code sequences are generated.&nbsp; The resulting code will be much easier to debug when using Open Watcom Debugger.
&nbsp;By default, Open Watcom F77 will select &quot;od&quot; if &quot;d2&quot; is specified.
<DT>ODO
<DD>Optimized DO-loop iteration code is generated.&nbsp; Caution should be exercised with the use of this option since the case
of an iterating value overflowing is assumed to never occur.&nbsp; The following example should not be compiled with this
option since the terminal value of<TT> IX</TT> wraps from a positive integer to a negative integer.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER*2 IX</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO IX=32766,32767</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDDO</TT>
<BR><BR>The values of<TT> IX</TT> are 32766, 32767, -32768, -32767, ...&nbsp; since<TT> IX</TT> is INTEGER*2 (a 16-bit signed
value) and it never exceeds the terminal value.
<DT>OF
<DD>This option selects the generation of traceable stack frames for those functions that contain calls or require stack frame
setup.&nbsp; To use Open Watcom's &quot;Dynamic Overlay Manager&quot; (DOS only), you must compile all modules using the &quot;of&quot;
option.&nbsp; For near functions, the following function prologue sequence is generated.
<BR><BR><B>16-bit:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push BP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp; BP,SP</TT>
<BR><BR><B>32-bit:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push EBP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp; EBP,ESP</TT>
<BR><BR>For far functions, the following function prologue sequence is generated.
<BR><BR><B>16-bit:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inc&nbsp; BP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push BP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp; BP,SP</TT>
<BR><BR><B>32-bit:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inc&nbsp; EBP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push EBP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp; EBP,ESP</TT>
<BR><BR>The BP/EBP value on the stack will be even or odd depending on the code model.&nbsp; For 16-bit DOS systems, the Dynamic
Overlay Manager uses this information to determine if the return address on the stack is a short address (16-bit offset) or
long address (32-bit segment:offset).&nbsp; This option is not assumed by default.
<DT>OH
<DD>This option enables repeated optimizations (which can result in longer compiles).
<DT>OI
<DD>This option causes code for statement functions to be generated in-line.
<DT>OK
<DD>This option enables flowing of register save (from prologue) down into the subprogram's flow graph.
<DT>OL
<DD>Loop optimizations are performed.&nbsp; This includes moving loop-invariant expressions outside the loops.&nbsp; This option
is not assumed by default.
<DT>OL+
<DD>Loop optimizations are performed including loop unrolling.&nbsp; This includes moving loop-invariant expressions outside the
loops and can cause loops to be turned into straight-line code.&nbsp; This option is not assumed by default.
<DT>OM
<DD>Generate inline 80x87 code for math functions like sin, cos, tan, etc.&nbsp; If this option is selected, it is the programmer's
responsibility to make sure that arguments to these functions are within the range accepted by the<TT> fsin, fcos,</TT> etc.
&nbsp;instructions since no run-time check is made.
<BR><BR>If the &quot;ot&quot; option is also specified, the<TT> exp</TT> function is generated inline as well.&nbsp; This
option is not assumed by default.
<DT>ON
<DD>This option allows the compiler to perform certain numerical calculations in a more efficient manner.&nbsp; Consider the following
example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Z1 = X1 / Y</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Z2 = X2 / Y</TT>
<BR><BR>If the &quot;on&quot; option is specified, the code generator will generate code that is equivalent to the following.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; T = 1 / Y</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Z1 = X1 * T</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Z2 = X2 * T</TT>
<BR><BR>Since floating-point multiplication is more efficient that division, the code generator decided to first compute the
reciprocal of Y and then multiply X1 and X2 by the reciprocal of Y.
<BR>Note that this optimization may produce less slightly different results since some, for certain values, precision is lost
when computing the reciprocal.&nbsp; By using this option, you are indicating that you are willing to accept the loss in precision
for the gain in performance.
<DT>OP
<DD>By default, floating-point variables may be cached in 80x87 floating-point registers across statements when compiling with
the &quot;fpi&quot; or &quot;fpi87&quot; options.&nbsp; Floating-point register temporaries use 64 bits of precision in the
mantissa whereas single and double-precision variables use fewer bits of precision in the mantissa.&nbsp; The use of this
option will force the result to be stored in memory after each FORTRAN statement is executed.&nbsp; This will produce less
accurate but more predictable floating-point results.&nbsp; The code produced will also be less efficient when the &quot;op&quot;
option is used.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; XMAX = X + Y / Z</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; YMAX = XMAX + Q</TT>
<BR><BR>When the &quot;op&quot; option is used in conjunction with the &quot;fpi&quot; or &quot;fpi87&quot; option, the compiler's
code generator will update<TT> XMAX</TT> before proceeding with the second statement.&nbsp; In the second statement, the compiler
will reload<TT> XMAX</TT> from memory rather than using the result of the previous statement.&nbsp; The effect of the &quot;op&quot;
option on the resulting code can be seen by the increased code size statistic as well as through the use of the Open Watcom
Disassembler.&nbsp; This option is not assumed by default.
<DT>OR
<DD>This option enables reordering of instructions (instruction scheduling) to achieve better performance on pipelined architectures
such as the 486.&nbsp; Selecting this option will make it slightly more difficult to debug because the assembly language instructions
generated for a source statement may be intermixed with instructions generated for surrounding statements.&nbsp; This option
is not assumed by default.
<DT>OS
<DD>Space is favoured over time when generating code (smaller code but possibly slower execution).&nbsp; By default, Open Watcom
F77 selects a balance between &quot;space&quot; and &quot;time&quot;.
<DT>OT
<DD>Time is favoured over space when generating code (faster execution but possibly larger code).&nbsp; By default, Open Watcom
F77 selects a balance between &quot;space&quot; and &quot;time&quot;.
<DT>OX
<DD>Specifying the &quot;ox&quot; option is equivalent to specifying the &quot;ob&quot; (32-bit only), &quot;obp&quot;, &quot;odo&quot;,
&quot;oi&quot;, &quot;ok&quot;, &quot;ol&quot;, &quot;om&quot;, &quot;or&quot;, and &quot;ot&quot; options.
<DT>PRint
<DD>This option is used to direct the listing file to the printer (device name &quot;PRN&quot;) instead of the disk.&nbsp; The
&quot;print&quot; option will override any previously specified &quot;type&quot; or &quot;disk&quot; option.&nbsp; The default
is to create a listing file on the disk.
<DT>[NO]Quiet
<DD>The &quot;quiet&quot; option suppresses the banner and summary information produced by the compiler.&nbsp; Only diagnostic
messages will be displayed.&nbsp; The default option is &quot;noquiet&quot;.
<DT>[NO]Reference
<DD>When the &quot;reference&quot; option is specified, warning messages will be issued for all unreferenced symbols.&nbsp; In
a source file, the option appears as a comment line and takes the following form.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$[NO]Reference</TT>
<BR><BR>This option is most useful when used in an include file that is included by several subprograms.&nbsp; Consider an
include file that defines many parameter constants and only a few are referenced by any one subprogram.&nbsp; If the first
line of the include file is
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$noreference</TT>
<BR><BR>and the last line is
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$reference</TT>
<BR><BR>warning messages for all unused parameter constants in the include file would be suppressed.&nbsp; The default option
is &quot;reference&quot;.
<DT>[NO]RESource
<DD>The &quot;resource&quot; option specifies that the run-time error messages are contained as resource information in the executable
file.&nbsp; All messages will be extracted from the resource area of the executable file when they are required; no messages
will be linked with the application.&nbsp; The default option is &quot;noresource&quot;.
<DT>[NO]SAve
<DD>The &quot;save&quot; option is used to instruct Open Watcom F77 to &quot;save&quot; all local variables of subprograms.&nbsp;
All local variables are treated as if they had appeared in FORTRAN 77<B><I> SAVE</I></B> statements.&nbsp; By default, local
variables are not saved unless named in a<B><I> SAVE</I></B> statement (i.e., &quot;nosave&quot; is the default option).
<DT>[NO]SC
<DD>(32-bit only) If the &quot;sc&quot; option is used, Open Watcom F77 will pass all arguments on the stack.&nbsp; The resulting
code will be larger than that which is generated for the register method of passing arguments.&nbsp; The default option is
&quot;nosc&quot;.
<DT>[NO]SEpcomma
<DD>The &quot;sepcomma&quot; option allows the comma (&quot;,&quot;) to be used as field separator in formatted input.&nbsp; Thus
the following code would work with the input described.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REAL R, S</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ(5,21) R, S</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, R, S</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 21&nbsp; FORMAT(2F11.3)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>Normally the following input would result in a run-time error message.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0.79,0.21</TT>
<DT>[NO]SG
<DD>(32-bit only) The &quot;sg&quot; option is useful for 32-bit OS/2 multi-threaded applications.&nbsp; It requests the code
generator to emit a run-time call at the start of any function that has more than 4K bytes of automatic variables (variables
located on the stack).&nbsp; Under 32-bit OS/2, the stack is grown automatically in 4K pages using the stack &quot;guard page&quot;
mechanism.&nbsp; The stack consists of in-use committed pages topped off with a special guard page.&nbsp; A memory reference
into the 4K guard page causes OS/2 to grow the stack by one 4K page and to add a new 4K guard page.&nbsp; This works fine
when there is less than 4K of automatic variables in a function.&nbsp; When there is more than 4K of automatic data, the stack
must be grown in an orderly fashion, 4K bytes at a time, until the stack has grown sufficiently to accommodate all the automatic
variable storage requirements.
<BR><BR>The &quot;stack growth&quot; run-time routine is called<TT> __GRO.</TT>
<BR><BR>The default option is &quot;nosg&quot;.
<DT>[NO]SHort
<DD>The &quot;short&quot; option is used to instruct Open Watcom F77 to set the default INTEGER size to 2 bytes and the default
LOGICAL size to 1 bytes.&nbsp; As required by the FORTRAN 77 language standard, the default INTEGER size is 4 bytes and the
default LOGICAL size is 4 bytes.&nbsp; The default option is &quot;noshort&quot;.
<DT>[NO]SR
<DD>The &quot;sr&quot; option instructs Open Watcom F77 to generate subprogram prologue and epilogue sequences that save and restore
any segment registers that are modified by the subprogram.&nbsp; Caution should be exercised when using this option.&nbsp;
If the value of the segment register being restored matches the value of a segment that was freed within the subprogram, a
general protection fault will occur in protected-mode environments.&nbsp; The default, &quot;nosr&quot;, does not save and
restore segment registers.
<DT>[NO]SSfloats
<DD>(16-bit only) The &quot;ssfloats&quot; option specifies that the segment register SS does not necessarily point to the default
data segment.&nbsp; The &quot;ssfloats&quot; option must be specified when compiling a module that is part of an OS/2 multi-threaded
application or dynamic link library.&nbsp; By default, it is assumed that the SS segment register contains the segment address
of the default data segment (i.e., &quot;nossfloats&quot;).
<DT>[NO]STack
<DD>If &quot;stack&quot; is specified, Open Watcom F77 will emit code at the beginning of every subprogram that will check for
the &quot;stack overflow&quot; condition.&nbsp; By default, stack overflow checking is omitted from the generated code (&quot;nostack&quot;).
<DT>[NO]SYntax
<DD>If &quot;syntax&quot; is specified, Open Watcom F77 will check the source code only and omit the generation of object code.
&nbsp;Syntax checking, type checking, and so on are performed as usual.&nbsp; By default, code is generated if there are no
source code errors (i.e., &quot;nosyntax&quot; is the default).
<DT>[NO]TErminal
<DD>The &quot;noterminal&quot; option may be used to suppress the display of diagnostic messages to the screen.&nbsp; By default,
diagnostic messages are displayed.
<DT>[NO]TRace
<DD>The &quot;trace&quot; option causes the generation of code that allows a traceback to be issued when an error occurs during
the execution of your program.&nbsp; The default option is &quot;notrace&quot;.
<DT>TYpe
<DD>This option is used to direct the listing file to the terminal (device name &quot;CON&quot;) instead of the disk.&nbsp; The
&quot;type&quot; option will override any previously specified &quot;print&quot; or &quot;disk&quot; option.&nbsp; The default
is to create a listing file on the disk.
<DT>[NO]WArnings
<DD>This option is used to control the printing of warning messages.&nbsp; By default, warning messages are printed.&nbsp; This
option may be specified on the command line or it may be placed anywhere in the source input stream.&nbsp; In a source file,
the option appears as a comment line and takes the following form.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$[NO]WArnings</TT>
<BR><BR>The &quot;warnings&quot; option enables the printing of warning messages, while &quot;nowarnings&quot; disables the
printing of these messages.
<DT>[NO]WILd
<DD>The &quot;wild&quot; option suppresses the compile-time checking that normally causes an error to be issued when an attempt
is made to transfer control into a block structure from outside the block structure and vice versa.&nbsp; For example, this
option will allow a transfer of control into an IF-block from outside the IF-block (which is normally prohibited).&nbsp; The
default option is &quot;nowild&quot;.
<BR><BR>Extreme caution should be exercised when using this option.&nbsp; For example, transfer of control into a DO-loop
from outside the DO-loop can cause unpredictable results.&nbsp; This programming style is not encouraged by this option.&nbsp;
The option has been made available so that existing programs that do not adhere to the branching restrictions imposed by the
FORTRAN 77 standard (i.e.&nbsp; mainframe applications that are being ported to the PC environment), can be compiled by Open
Watcom FORTRAN 77.
<DT>[NO]WIndows
<DD>(16-bit only) The &quot;windows&quot; option causes the compiler to generate the prologue/epilogue code sequences necessary
for use in Microsoft Windows applications.&nbsp; The default option is &quot;nowindows&quot;.
<DT>[NO]XFloat
<DD>The &quot;xfloat&quot; option specifies that all REAL variables are treated as if they had been declared as &quot;DOUBLE PRECISION&quot;.
&nbsp;This effectively increases the precision of REAL variables.&nbsp; Note that the &quot;xfloat&quot; option has implications
on the alignment of variables in common blocks.&nbsp; The default option is &quot;noxfloat&quot;.
<DT>[NO]Xline
<DD>The &quot;xline&quot; option informs the Open Watcom F77 compiler to extend the last column of the statement portion of a
line to column 132.&nbsp; The default is 72.
</DL>
<H1 ID="The_Open_Watcom_FORTRAN_77_Compiler"> The Open Watcom FORTRAN 77 Compiler </H1>
<BR>This chapter describes the following topics:
<UL>
<LI>Command line syntax (see <A HREF="#Open_Watcom_FORTRAN_77_Command_Line_Format">Open Watcom FORTRAN 77 Command Line Format</A>)
<LI>Environment variables used by the compilers (see <A HREF="#WFCDWFC386_Environment_Variables">WFC/WFC386 Environment Variables</A>)
<LI>Examples of command line syntax (see <A HREF="#Open_Watcom_FORTRAN_77_Command_Line_Examples">Open Watcom FORTRAN 77 Command Line Examples</A>)
<LI>Interpreting diagnostic messages (see <A HREF="#Compiler_Diagnostics">Compiler Diagnostics</A>)
<LI>Include file handling (see <A HREF="#Open_Watcom_FORTRAN_77_INCLUDE_File_Processing">Open Watcom FORTRAN 77 INCLUDE File Processing</A>)
</UL>
<H2 ID="Open_Watcom_FORTRAN_77_Command_Line_Format"> Open Watcom FORTRAN 77 Command Line Format </H2>
<BR>The formal Open Watcom FORTRAN 77 command line syntax is shown below.&nbsp; 
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; WFC [options] [d:][path]filename[.ext] [options]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; WFC386 [options] [d:][path]filename[.ext] [options]</TT>
<BR><BR>The square brackets [ ] denote items which are optional.
<DL>
<DT>WFC
<DD>is the name of the 16-bit Open Watcom F77 compiler.
<DT>WFC386
<DD>is the name of the 32-bit Open Watcom F77 compiler.
<DT>d:
<DD>is an optional drive specification such as &quot;A:&quot;, &quot;B:&quot;, etc.&nbsp; If not specified, the default drive
is assumed.
<DT>path
<DD>is an optional path specification such as<TT> \PROGRAMS\SRC\.</TT>&nbsp; If not specified, the current directory is assumed.
<DT>filename
<DD>is the file name of the file to be compiled.
<DT>ext
<DD>is the file extension of the file to be compiled.&nbsp; If omitted, a file extension of &quot;FOR&quot; is assumed.&nbsp;
If the period &quot;.&quot; is specified but not the extension, the file is assumed to have no file extension.
<DT>options
<DD>is a list of valid Open Watcom F77 options, each preceded by a slash (&quot;/&quot;) or a dash (&quot;-&quot;).&nbsp; Certain
options can include a &quot;no&quot; prefix to disable an option.&nbsp; Options may be specified in any order, with the rightmost
option taking precedence over any conflicting options specified to its left.
</DL>
<H2 ID="WFCDWFC386_Environment_Variables"> WFC/WFC386 Environment Variables </H2>
<BR>The<B> WFC</B> environment variable can be used to specify commonly used WFC options.&nbsp; The<B> WFC386</B> environment
variable can be used to specify commonly used WFC386 options.&nbsp; These options are processed before options specified on
the command line.&nbsp; 
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set wfc=-d1 -ot</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set wfc386=-d1 -ot</TT>
<BR><BR>The above example defines the default options to be &quot;d1&quot; (include line number debugging information in the
object file), and &quot;ot&quot; (favour time optimizations over size optimizations).
<BR><BR>Whenever you wish to specify an option that requires the use of an &quot;=&quot; character, you can use the &quot;#&quot;
character in its place.&nbsp; This is required by the syntax of the &quot;SET&quot; command.
<BR><BR>Once a particular environment variable has been defined, those options listed become the default each time the associated
compiler is used.&nbsp; The compiler command line can be used to override any options specified in the environment string.
<BR><BR>These environment variables are not examined by the Open Watcom Compile and Link utilities.&nbsp; Since the Open Watcom
Compile and Link utilities pass the relevant options found in their associated environment variables to the compiler command
line, their environment variable options take precedence over the options specified in the environment variables associated
with the compilers.
<BR><BR><B><I>Hint:</I></B>&nbsp; If you are running DOS and you use the same compiler options all the time, you may find
it handy to define the environment variable in your DOS system initialization file,<TT> AUTOEXEC.BAT.</TT>
<BR><BR>If you are running Windows NT, use the &quot;System&quot; icon in the<B> Control Panel</B> to define environment variables.
<BR><BR>If you are running OS/2 and you use the same compiler options all the time, you may find it handy to define the environment
variable in your OS/2 system initialization file,<TT> CONFIG.SYS.</TT>
<H2 ID="Open_Watcom_FORTRAN_77_Command_Line_Examples"> Open Watcom FORTRAN 77 Command Line Examples </H2>
<BR>The following are some examples of using Open Watcom FORTRAN 77 to compile FORTRAN 77 source programs.
<BR><BR><B>Example 1:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wfc386 report /d1 /stack</TT>
<BR><BR>The 32-bit Open Watcom F77 compiler processes<TT> REPORT.FOR</TT> producing an object file which contains source line
number information.&nbsp; Stack overflow checking code is included in the object code.
<BR><BR><B>Example 2:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wfc kwikdraw /2 /fpi87</TT>
<BR><BR>The 16-bit Open Watcom F77 compiler processes<TT> KWIKDRAW.FOR</TT> producing object code for an Intel 286 system
equipped with an Intel 287 numeric data processor (or any upward compatible 386/387, 486 or Intel Pentium system).&nbsp; While
the choice of these options narrows the number of microcomputer systems where this code will execute, the resulting code will
be highly optimized for this type of system.
<BR><BR><B>Example 3:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wfc ..\source\modabs /d2</TT>
<BR><BR>The 16-bit Open Watcom F77 compiler processes<TT> ..\SOURCE\MODABS.FOR</TT> (a file in a directory which is adjacent
to the current one).&nbsp; The object file is placed in the current directory.&nbsp; Included with the object code and data
is information on local symbols and data types.&nbsp; The code generated is straight-forward, unoptimized code which can be
readily debugged with Open Watcom Debugger.&nbsp; 
<BR><BR><B>Example 4:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wfc386 /mf calc</TT>
<BR><BR>The 32-bit Open Watcom F77 compiler compiles<TT> CALC.FOR</TT> for the &quot;flat&quot; memory model.&nbsp; 32-bit
memory models are described in the chapter entitled <A HREF="#32Mbit_Memory_Models">32-bit Memory Models</A>.&nbsp; 32-bit
argument passing conventions are described in the chapter entitled <A HREF="#32Mbit_Assembly_Language_Considerations">32-bit Assembly Language Considerations</A>.
<BR><BR><B>Example 5:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wfc386 kwikdraw /fpi87</TT>
<BR><BR>The 32-bit Open Watcom F77 compiler processes<TT> KWIKDRAW.FOR</TT> producing object code for an Intel 386 system
equipped with an Intel 80x87 numeric data processor.
<BR><BR><B>Example 6:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set wfc=/short /d2 /fo#*.dbj</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wfc ..\source\modabs</TT>
<BR><BR>The options<TT> /short, /d2</TT> and<TT> /fo=*.dbj</TT> are established as defaults using the<B> WFC</B> environment
variable.&nbsp; The 16-bit compiler processes<TT> ..\SOURCE\MODABS.FOR</TT> (a file in a directory which is adjacent to the
current one).&nbsp; The object file is placed in the current directory and it will have a default file extension of &quot;DBJ&quot;.
&nbsp;All INTEGER and LOGICAL variables will have a default type of INTEGER*2 and LOGICAL*1 unless explicitly typed as INTEGER*4
or LOGICAL*4.&nbsp; Source line number and local symbol information are included with the object file.
<H2 ID="Compiler_Diagnostics"> Compiler Diagnostics </H2>
<BR>If the Open Watcom F77 compiler prints diagnostic messages to the screen, it will also place a copy of these messages
in a file in your current directory (unless the &quot;noerrorfile&quot; option is specified).&nbsp; The file will have the
same file name as the source file and an extension of &quot;err&quot;.&nbsp; The compiler issues three types of diagnostic
messages, namely extensions, warnings and errors.&nbsp; An extension message indicates that you have used a feature which
is supported by Open Watcom F77 but that is not part of the FORTRAN 77 language standard.&nbsp; A warning message indicates
that the compiler has found a questionable problem in the source code (e.g., an unreachable statement, an unreferenced variable
or statement number, etc.).&nbsp; A warning message does not prevent the production of an object file.&nbsp; An error message
indicates that a problem is severe enough that it must be corrected before the compiler will produce an object file.&nbsp;
The error file is a handy reference when you wish to correct the errors in the source file.
<BR><BR>Just to illustrate the diagnostic features of Open Watcom F77, we will compile the following program called &quot;DEMO1&quot;.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * This program demonstrates the following features of</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Open Watcom's FORTRAN 77 compiler:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp; 1. Extensions to the FORTRAN 77 standard are flagged.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp; 2. Compile time error diagnostics are extensive.&nbsp; As many</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; errors as possible are diagnosed.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp; 3. Warning messages are displayed where potential problems</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; can arise.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PROGRAM MAIN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DIMENSION A(10)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO I=1,10</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A(I) = I</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I = I + 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDLOOP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GO TO 30</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; J = J + 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 30&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>If we compile this program with the &quot;extensions&quot; option, the following output appears on the screen.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wfc demo1 /exten</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; WATCOM FORTRAN 77/16 Optimizing Compiler Version 2.0 1997/07/16 09:22:47</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1984-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; demo1.for(14): *EXT* DO-05 this DO loop form is not FORTRAN 77 standard</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; demo1.for(16): *ERR* DO-07 column 13, DO variable cannot be redefined</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; while DO loop is active</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; demo1.for(17): *ERR* SP-19 ENDLOOP statement does not match with DO</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; statement</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; demo1.for(19): *WRN* ST-08 this statement will never be executed due to</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; the preceding branch</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; demo1.for: 9 statements, 0 bytes, 1 extensions, 1 warnings, 2 errors</TT>
<BR><BR>Here we see an example of the three types of messages, extension (*EXT*), error (*ERR*) and warning (*WRN*).
<BR><BR>Diagnostic messages are also included in the listing file if the &quot;list&quot; option is specified.&nbsp; If we
recompile our program and include the &quot;list&quot; option, a listing file will be created.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wfc demo1 /exten/list</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wfc386 demo1 /exten/list</TT>
<BR><BR>The contents of the listing file are:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; WATCOM FORTRAN 77/16 Optimizing Compiler Version 2.0 1997/07/16 09:22:47</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Copyright (c) 2002-2019 the Open Watcom Contributors. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Portions Copyright (c) 1984-2002 Sybase, Inc. All Rights Reserved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Source code is available under the Sybase Open Watcom Public License.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; See http://www.openwatcom.org/ for details.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Options: list,disk,errorfile,extensions,reference,warnings,fpi,oc,of,om,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; os,ot,ox,ml,0,terminal,dependency,fsfloats,gsfloats,libinfo,dt=256,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; align</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 * This program demonstrates the following features
of</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2 * Open Watcom's FORTRAN 77 compiler:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3 *</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 *&nbsp;&nbsp;&nbsp; 1. Extensions to the FORTRAN 77
standard are flagged.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5 *</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6 *&nbsp;&nbsp;&nbsp; 2. Compile time error diagnostics
are extensive.&nbsp; As many</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7 *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; errors as possible
are diagnosed.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8 *</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 9 *&nbsp;&nbsp;&nbsp; 3. Warning messages are displayed
where potential problems</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10 *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; can arise.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 11 *</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PROGRAM
MAIN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DIMENSION
A(10)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO I=1,10</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *EXT* DO-05 this DO loop form is not FORTRAN 77 standard</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; A(I) = I</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; I = I + 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; $</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *ERR* DO-07 DO variable cannot be redefined while DO loop is active</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 17&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDLOOP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *ERR* SP-19 ENDLOOP statement does not match with DO statement</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 18&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GO TO 30</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 19&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; J = J +
1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *WRN* ST-08 this statement will never be executed due to the preceding branch</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 20 30&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Code size (in bytes):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; 0&nbsp; Number of errors:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; 2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Compile time (in seconds):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp; Number
of warnings:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Number of statements compiled:&nbsp;&nbsp;&nbsp;&nbsp; 9&nbsp; Number of extensions:&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1</TT>
<BR><BR>As part of the diagnostic capability of Open Watcom F77, a &quot;$&quot; is often used to indicate the particular
place in the source line where an error has been detected.
<H2 ID="Open_Watcom_FORTRAN_77_INCLUDE_File_Processing"> Open Watcom FORTRAN 77 INCLUDE File Processing </H2>
<BR>For information on include file processing, see the section entitled <A HREF="#The_INCLUDE_Compiler_Directive">The INCLUDE Compiler Directive</A>
in the chapter entitled <A HREF="#Open_Watcom_FORTRAN_77_Compiler_Directives">Open Watcom FORTRAN 77 Compiler Directives</A>.
<H1 ID="The_Open_Watcom_FORTRAN_77_Libraries"> The Open Watcom FORTRAN 77 Libraries </H1>
<BR>The Open Watcom FORTRAN 77 library routines (intrinsic functions) are described in the<B> Open Watcom FORTRAN 77 Language
Reference</B> manual.&nbsp; Additional run-time routines are described in the chapter entitled <A HREF="#The_Open_Watcom_F77_Subprogram_Library">The Open Watcom F77 Subprogram Library</A>.
&nbsp;Since Open Watcom FORTRAN 77 supports two major architectures, the 286 architecture (which includes the 8088) and the
386 architecture (which includes the 486 and Pentium processors), libraries are grouped under two major directories.
<BR><BR>For the 286 architecture, the processor dependent libraries are placed under the<TT> \WATCOM\LIB286</TT> directory.
<BR><BR>For the 386 architecture, the processor dependent libraries are placed under the<TT> \WATCOM\LIB386</TT> directory.
<BR><BR>Since Open Watcom FORTRAN 77 also supports several operating systems, including DOS, Windows 3.x, Windows 95, Windows
NT, OS/2 and NetWare, system-dependent libraries are grouped under different directories underneath the processor-dependent
directories.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; System&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16-bit applications&nbsp;&nbsp;&nbsp;&nbsp; 32-bit applications</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ---------&nbsp;&nbsp; ---------------------&nbsp;&nbsp; ---------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DOS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \WATCOM\LIB286\DOS&nbsp;&nbsp;&nbsp;
&nbsp; \WATCOM\LIB386\DOS</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; OS/2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \WATCOM\LIB286\OS2&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;\WATCOM\LIB386\OS2</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Windows 3.x \WATCOM\LIB286\WIN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \WATCOM\LIB386\WIN</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Windows NT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \WATCOM\LIB386\NT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Windows 95</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; NetWare&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \WATCOM\LIB386\NETWARE</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; \watcom</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .-----------+----------------.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lib286&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lib386</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .-------+-------.&nbsp;&nbsp;&nbsp; .-------.-------+-------.-------.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;
&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; dos&nbsp;&nbsp;&nbsp;&nbsp; os2&nbsp;&nbsp;&nbsp;&nbsp; win&nbsp; dos&nbsp;&nbsp;&nbsp;&nbsp;
os2&nbsp;&nbsp;&nbsp;&nbsp; win&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nt&nbsp;&nbsp; netware</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;
&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><BR>Due to the many code generation strategies possible in the 80x86 family of processors, a number of versions of the
libraries are provided.&nbsp; You must use the libraries which coincide with the particular architecture, operating system,
and code generation strategy or model that you have selected.&nbsp; For the type of code generation strategy or model that
you intend to use, refer to the description of the &quot;m?&quot; memory model compiler option in the chapter entitled <A HREF="#Open_Watcom_FORTRAN_77_Compiler_Options">Open Watcom FORTRAN 77 Compiler Options</A>.
&nbsp;The various code models supported by Open Watcom FORTRAN 77 are described in the chapters entitled <A HREF="#16Mbit_Memory_Models">16-bit Memory Models</A>
and <A HREF="#32Mbit_Memory_Models">32-bit Memory Models</A>.
<BR><BR>We have selected a simple naming convention for the libraries that are provided with Open Watcom FORTRAN 77.&nbsp;
Letters are affixed to the file name to indicate the particular strategy with which the modules in the library have been compiled.
<DL>
<DT>M
<DD>denotes a version of the 16-bit Open Watcom FORTRAN 77 libraries which have been compiled for the &quot;medium&quot; memory
model (big code, small data).&nbsp; 
<DT>L
<DD>denotes a version of the 16-bit Open Watcom FORTRAN 77 libraries which have been compiled for the &quot;large&quot; or &quot;huge&quot;
memory models (big code, big data or huge data).&nbsp; 
<DT>7
<DD>denotes a version of the Open Watcom FORTRAN 77 libraries which should be used when compiling with the &quot;fpi&quot; or
&quot;fpi87&quot; option.&nbsp; Otherwise the libraries have been compiled using the &quot;fpc&quot; compiler option.&nbsp;

<DT>S
<DD>denotes a version of the 32-bit Open Watcom FORTRAN 77 libraries which have been compiled using the &quot;sc&quot; option
(stack calling conventions).
</DL>
<BR>The 16-bit Open Watcom FORTRAN 77 libraries are listed below by directory.
<BR><BR><B>Under</B><TT> \WATCOM\LIB286\DOS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; FLIBM.LIB&nbsp;&nbsp; (DOS medium model)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; FLIB7M.LIB&nbsp; (DOS medium model, in-line 80x87)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; FLIBL.LIB&nbsp;&nbsp; (DOS large/huge model)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; FLIB7L.LIB&nbsp; (DOS large/huge model, in-line 80x87)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CLIBM.LIB&nbsp;&nbsp; (DOS i/o system medium model)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CLIBL.LIB&nbsp;&nbsp; (DOS i/o system large/huge model)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; GRAPH.LIB&nbsp;&nbsp; (DOS graphics support)</TT>
<BR><BR><B>Under</B><TT> \WATCOM\LIB286\WIN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; FLIBM.LIB&nbsp;&nbsp; (Windows medium model)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; FLIB7M.LIB&nbsp; (Windows medium model, in-line 80x87)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; FLIBL.LIB&nbsp;&nbsp; (Windows large/huge model)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; FLIB7L.LIB&nbsp; (Windows large/huge model, in-line 80x87)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CLIBM.LIB&nbsp;&nbsp; (Windows i/o system medium model)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CLIBL.LIB&nbsp;&nbsp; (Windows i/o system large/huge model)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; WINDOWS.LIB (Windows API library)</TT>
<BR><BR><B>Under</B><TT> \WATCOM\LIB286\OS2</TT> 
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; FLIBM.LIB&nbsp;&nbsp; (OS/2 medium model)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; FLIB7M.LIB&nbsp; (OS/2 medium model, in-line 80x87)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; FLIBL.LIB&nbsp;&nbsp; (OS/2 large/huge model)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; FLIB7L.LIB&nbsp; (OS/2 large/huge model, in-line 80x87)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CLIBM.LIB&nbsp;&nbsp; (OS/2 i/o system medium model)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CLIBL.LIB&nbsp;&nbsp; (OS/2 i/o system large/huge model)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DOSPMM.LIB&nbsp; (Phar Lap 286 PM medium model)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DOSPML.LIB&nbsp; (Phar Lap 286 PM large/huge model)</TT>
<BR><BR>The 32-bit Open Watcom FORTRAN 77 libraries are listed below.
<BR><BR><B>Under</B><TT> \WATCOM\LIB386\DOS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; FLIB.LIB&nbsp;&nbsp;&nbsp;&nbsp; (floating-point calls)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; FLIB7.LIB&nbsp;&nbsp;&nbsp; (in-line 80x87)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; FLIBS.LIB&nbsp;&nbsp;&nbsp; (floating-point calls, stack conventions)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; FLIB7S.LIB&nbsp;&nbsp; (in-line 80x87, stack conventions)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CLIB3R.LIB&nbsp;&nbsp; (i/o system)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CLIB3S.LIB&nbsp;&nbsp; (i/o system, stack conventions)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; GRAPH.LIB&nbsp;&nbsp;&nbsp; (DOS graphics support)</TT>
<BR><BR>The graphics library<TT> GRAPH.LIB</TT> is independent of the argument passing conventions or floating-point model.
<BR><BR><B>Under</B><TT> \WATCOM\LIB386\WIN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; FLIB.LIB&nbsp;&nbsp;&nbsp;&nbsp; (floating-point calls)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; FLIB7.LIB&nbsp;&nbsp;&nbsp; (in-line 80x87)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; FLIBS.LIB&nbsp;&nbsp;&nbsp; (floating-point calls, stack conventions)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; FLIB7S.LIB&nbsp;&nbsp; (in-line 80x87, stack conventions)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CLIB3R.LIB&nbsp;&nbsp; (i/o system)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CLIB3S.LIB&nbsp;&nbsp; (i/o system, stack conventions)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; WIN386.LIB&nbsp;&nbsp; (32-bit Windows API)</TT>
<BR><BR><B>Under</B><TT> \WATCOM\LIB386\OS2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; FLIB.LIB&nbsp;&nbsp;&nbsp;&nbsp; (floating-point calls)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; FLIB7.LIB&nbsp;&nbsp;&nbsp; (in-line 80x87)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; FLIBS.LIB&nbsp;&nbsp;&nbsp; (floating-point calls, stack conventions)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; FLIB7S.LIB&nbsp;&nbsp; (in-line 80x87, stack conventions)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CLIB3R.LIB&nbsp;&nbsp; (i/o system)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CLIB3S.LIB&nbsp;&nbsp; (i/o system, stack conventions)</TT>
<BR><BR><B>Under</B><TT> \WATCOM\LIB386\NT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; FLIB.LIB&nbsp;&nbsp;&nbsp;&nbsp; (floating-point calls)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; FLIB7.LIB&nbsp;&nbsp;&nbsp; (in-line 80x87)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; FLIBS.LIB&nbsp;&nbsp;&nbsp; (floating-point calls, stack conventions)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; FLIB7S.LIB&nbsp;&nbsp; (in-line 80x87, stack conventions)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CLIB3R.LIB&nbsp;&nbsp; (i/o system)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CLIB3S.LIB&nbsp;&nbsp; (i/o system, stack conventions)</TT>
<H2 ID="Open_Watcom_FORTRAN_77_80x87_Emulator_Libraries"> Open Watcom FORTRAN 77 80x87 Emulator Libraries </H2>
<BR>One of the following libraries must be used if any of the modules of your application were compiled with the &quot;fpi&quot;
option.
<BR><BR><B>16-bit Libraries</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; NOEMU87.LIB</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DOS\EMU87.LIB (DOS dependent)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; WIN\EMU87.LIB (Windows dependent)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; OS2\EMU87.LIB (OS/2 dependent)</TT>
<BR><BR><B>32-bit Libraries</B>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; NOEMU387.LIB</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DOS\EMU387.LIB (DOS dependent)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; WIN\EMU387.LIB (Windows dependent)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; OS2\EMU387.LIB (OS/2 dependent)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; NT\EMU387.LIB (Windows NT dependent)</TT>
<BR><BR>The &quot;fpi&quot; option causes an 80x87 numeric data processor emulator to be linked into your application.&nbsp;
This emulator will decode and emulate 80x87 instructions when an 80x87 is not present in the system or if the environment
variable<B> NO87</B> has been set (this variable is described below).
<BR><BR>If you have compiled your application using the &quot;fpi&quot; option, you can also link with the 16-bit &quot;noemu87.lib&quot;
or 32-bit &quot;noemu387.lib&quot; library, depending on which compiler you are using.&nbsp; However, your application will
only run on a machine equipped with a 80x87 numeric data processor since the actual emulator is not linked into your application.
<BR><BR>When the &quot;fpi87&quot; option is used exclusively, the emulator is not included.&nbsp; In this case, the application
must be run on personal computer systems equipped with the numeric data processor.
<H2 ID="The__NO87__Environment_Variable"> The &quot;NO87&quot; Environment Variable </H2>
<BR>If you have a math coprocessor in your system but you wish to test a version of your application that will use floating-point
emulation (&quot;fpi&quot; option) or simulation (&quot;fpc&quot; option), you can define the<B> NO87</B> environment variable.
&nbsp;The 16-bit application must be compiled using the &quot;fpc&quot; (floating-point calls) option and linked with the
appropriate<TT> flib?.lib</TT> library or the &quot;fpi&quot; option (default) and linked with the appropriate<TT> flib7?.lib</TT>
and<TT> emu87.lib</TT> libraries.&nbsp; The 32-bit application must be compiled using the &quot;fpc&quot; (floating-point
calls) option and linked with the appropriate<TT> flib?.lib</TT> library or the &quot;fpi&quot; option (default) and linked
with the appropriate<TT> flib7?.lib</TT> and<TT> emu387.lib</TT> libraries.&nbsp; Using the &quot;SET&quot; command, define
the environment variable as follows:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;SET NO87=1</TT>
<BR><BR>Now, when you run your application, the 80x87 will be ignored.&nbsp; To undefine the environment variable, enter the
command:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;SET NO87=</TT>
<H1 ID="Open_Watcom_FORTRAN_77_Compiler_Directives"> Open Watcom FORTRAN 77 Compiler Directives </H1>
<BR>A number of compiler directives are available that allow, for example, conditional compilation of source code and the
inclusion of source code from other files.&nbsp; A compiler directive is specified by placing a comment character ('c', 'C',
or '*') in column one followed by a dollar sign ('$') immediately followed by the compiler directive.&nbsp; The following
lists all of the compiler directives available with Open Watcom F77.
<OL>
<LI>EJECT
<LI>INCLUDE
<LI>PRAGMA
<LI>DEFINE
<LI>UNDEFINE
<LI>IFDEF
<LI>IFNDEF
<LI>ENDIF
<LI>ELSE
<LI>ELIFDEF
<LI>ELIFNDEF
</OL>
<BR>These compiler directives will be described in the following sections.
<BR><BR>In addition to the above compiler directives, it is also possible to specify certain compiler options in the same
way.&nbsp; The following lists these options.
<OL>
<LI>[NO]EXTENSIONS
<LI>[NO]LIST
<LI>[NO]REFERENCE
<LI>[NO]WARNINGS
</OL>
<BR>For more information on these options, see the the chapter entitled <A HREF="#Open_Watcom_FORTRAN_77_Compiler_Options">Open Watcom FORTRAN 77 Compiler Options</A>.
<H2 ID="The_EJECT_Compiler_Directive"> The EJECT Compiler Directive </H2>
<BR>This compiler directive causes a form-feed to be generated in the listing file.&nbsp; The listing file is a carriage-control
file that is created by the compiler when the &quot;list&quot; compiler option is specified.&nbsp; In the following example,
a form-feed character will be generated immediately before the source for subroutine<TT> sub2</TT> and immediately before
the source for subroutine<TT> sub3.</TT>
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subroutine sub1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! source code</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$eject</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subroutine sub2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! source code</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$eject</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subroutine sub3</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! source code</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<H2 ID="The_INCLUDE_Compiler_Directive"> The INCLUDE Compiler Directive </H2>
<BR>The<B><I> INCLUDE</I></B> compiler directive or<B><I> INCLUDE</I></B> statement may be used to imbed source code into
the file being compiled.&nbsp; Either form may be used.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$INCLUDE DOS.FI</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INCLUDE 'DOS.FI'</TT>
<BR><BR>When the<B><I> INCLUDE</I></B> statement is used the name of the file must be placed inside single quotes (apostrophes).
&nbsp;The file name may include drive, path, and file extension.&nbsp; The default file extension is<TT> .for</TT>.
<BR><BR>It is not necessary to include the drive and path specifiers in the file specification when the file resides on a
different drive or in a different directory.&nbsp; Open Watcom F77 provides a mechanism for looking up include files which
may be located in various directories and disks of the computer system.&nbsp; When the drive and path are omitted from a file
specification, Open Watcom F77 searches directories for include files in the following order.&nbsp; 
<OL>
<LI>First, the current directory is searched.
<LI>Secondly, each directory listed with the &quot;INCPath&quot; option is searched (in the order that they were specified).
<LI>Thirdly, each directory listed in the<B> FINCLUDE</B> environment variable is searched (in the order that they were specified).
</OL>
<BR>The compiler will search the directories listed with the &quot;INCPath&quot; option or in the<B> FINCLUDE</B> environment
variable in a manner analogous to that which used by the operating system when searching for programs by using the<B> PATH</B>
environment variable.
<BR><BR>The &quot;INCPath&quot; option takes the following form.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -INCPath=[d:]path;[d:]path...</TT>
<BR><BR>The &quot;SET&quot; command is used to define an<B> FINCLUDE</B> environment variable that contains a list of directories.
&nbsp;A command of the form
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SET FINCLUDE=[d:]path;[d:]path...</TT>
<BR><BR>is issued before running Open Watcom F77 the first time.&nbsp; The brackets indicate that the drive<TT> d:</TT>&nbsp;
is optional and the ellipsis indicates that any number of paths may be specified.
<BR><BR>We illustrate the use of the<B><I> INCLUDE</I></B> statement in the following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subroutine ClearScreen()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; implicit none</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'dos.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer VIDEO_CALL, SCROLL_UP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameter (VIDEO_CALL=16, SCROLL_UP=6)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DS = ES = FS = GS = 0&nbsp;&nbsp;&nbsp;&nbsp; ! for safety
on 386 DOS extender</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AH = SCROLL_UP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; ! scroll up</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AL = 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! blank entire window</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CX = 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! set row,column of upper left</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DX = 24*256 + 80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; ! set row,column of lower right</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BH = 7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! attribute &quot;white on black&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call fintr( VIDEO_CALL, regs )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>The third line of this subroutine contains an<B><I> INCLUDE</I></B> statement for the file<TT> DOS.FI.</TT>&nbsp;
If the above source code is stored in the file<TT> CLRSCR.FOR</TT> in the current directory then we can issue the following
commands to compile the application.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set finclude=c:\watcom\src\fortran\dos</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wfc clsscr</TT>
<BR><BR>In the above example, the &quot;SET&quot; command is used to define the<B> FINCLUDE</B> environment variable.&nbsp;
It specifies that the<TT> \WATCOM\SRC\FORTRAN\DOS</TT> directory is to be searched for include files that cannot be located
in the current directory and that have no drive or path specified.&nbsp; The advantage of the<B> FINCLUDE</B> environment
variable is that drives and paths can be omitted from the INCLUDE file specifications in the source code.&nbsp; This allows
the source code to be independent of the disk/directory structure of your computer system.
<H2 ID="The_PRAGMA_Compiler_Directive"> The PRAGMA Compiler Directive </H2>
<BR>This compiler directive is described in the chapters entitled <A HREF="#16Mbit__16Mbit_Pragmas">16-bit:&nbsp; 16-bit Pragmas</A>
and <A HREF="#32Mbit__32Mbit_Pragmas">32-bit:&nbsp; 32-bit Pragmas</A>.
<H2 ID="The_DEFINE_Compiler_Directive"> The DEFINE Compiler Directive </H2>
<BR>The DEFINE compiler directive sets the definition status of a<B> macro</B> to defined.&nbsp; If a macro does not appear
in a DEFINE directive, its definition status is undefined.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$define debug</TT>
<BR><BR>In the above example, the macro<TT> debug</TT> is defined.
<BR><BR>The DEFINE compiler option can also be used to define a macro.&nbsp; 
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wfc /define=debug test</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wfc386 /define=debug test</TT>
<H2 ID="The_UNDEFINE_Compiler_Directive"> The UNDEFINE Compiler Directive </H2>
<BR>The UNDEFINE compiler directive sets the definition status of a<B> macro</B> to undefined.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$undefine debug</TT>
<BR><BR>In the above example, the definition status of the macro<TT> debug</TT> is set to undefined.
<H2 ID="The_IFDEF__IFNDEF_and_ENDIF_Compiler_Directive"> The IFDEF, IFNDEF and ENDIF Compiler Directive </H2>
<BR>The IFDEF and IFNDEF compiler directives check the definition status of a macro.&nbsp; If the macro appearing in an IFDEF
directive is defined or the macro appearing in an IFNDEF directive is not defined, then all source code up to the corresponding
ENDIF compiler directive will be compiled.&nbsp; Otherwise, it will be ignored.
<BR><BR>In the following example, the FORTRAN 77 statements represented by<TT> &lt;debugging_statements&gt;</TT> will be compiled.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$define debug</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$ifdef debug</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;debugging_statements&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$endif</TT>
<BR><BR>In the following example, the FORTRAN 77 statements represented by<TT> &lt;debugging_statements&gt;</TT> will not
be compiled.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$undefine debug</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$ifdef debug</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;debugging_statements&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$endif</TT>
<BR><BR>In the following example, the FORTRAN 77 statements represented by<TT> &lt;debugging_statements&gt;</TT> will be compiled.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$undefine debug</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$ifndef debug</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;debugging statements&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$endif</TT>
<H2 ID="The_ELSE_Compiler_Directive"> The ELSE Compiler Directive </H2>
<BR>The ELSE compiler directive must be preceded by an IFDEF, IFNDEF, ELSEIFDEF or ELSEIFNDEF compiler directive.&nbsp; If
the condition of the preceding compiler directive was satisfied, then all source code between the ELSE compiler directive
and the corresponding ENDIF compiler directive will be ignored.&nbsp; If the condition of the preceding compiler directive
was not satisfied, then all source code between the ELSE compiler directive and the corresponding ENDIF compiler directive
will be compiled.
<BR><BR>In the following example, the FORTRAN 77 statements represented by<TT> &lt;debugging_level_2_statements&gt;</TT> will
be compiled.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$undefine debug_level_1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$ifdef debug_level_1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;debugging_level_1_statements&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;debugging_level_2_statements&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$endif</TT>
<H2 ID="The_ELSEIFDEF_and_ELSEIFNDEF_Compiler_Directive"> The ELSEIFDEF and ELSEIFNDEF Compiler Directive </H2>
<BR>The ELSEIFDEF and ELSEIFNDEF compiler directives must be preceded by an IFDEF, IFNDEF, ELSEIFDEF or ELSEIFNDEF compiler
directive.&nbsp; If the condition of the preceding compiler directive was satisfied, then all source code between the ELSEIFDEF
or ELSEIFNDEF compiler directive and the corresponding ENDIF compiler directive will be ignored.&nbsp; If the condition of
the preceding compiler directive was not satisfied, then the definition status of the macro specified in the ELSEIFDEF or
ELSEIFNDEF compiler directive is checked.&nbsp; If the macro appearing in the ELSEIFDEF compiler directive is defined, or
the macro appearing in the ELSEIFNDEF compiler directive is not defined, then all source up to the next ELSEIFDEF, ELSEIFNDEF,
ELSE or ENDIF compiler directive will be compiled.
<BR><BR>In the following example, the FORTRAN 77 statements represented by<TT> &lt;debugging_level_2_statements&gt;</TT> will
be compiled.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$define debug_level_2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$ifdef debug_level_1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;debugging_level_1_statements&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$elseifdef debug_level_2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;debugging_level_2_statements&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$endif</TT>
<H2 ID="Debugging_statements_L_D__in_Column_1R"> Debugging statements (&quot;D&quot; in Column 1) </H2>
<BR>If the character &quot;D&quot; or &quot;d&quot; appears in column 1, that line will be conditionally compiled depending
on the definition status of the macro<TT> __debug__.</TT>&nbsp; Statements that contain a &quot;D&quot; or &quot;d&quot; in
column 1 are called debugging statements.&nbsp; If the<TT> __debug__</TT> macro is defined, the line will be compiled; otherwise
it will be ignored.&nbsp; The<TT> __debug__</TT> macro can be defined by using the DEFINE compiler directive or the &quot;define&quot;
option.&nbsp; In the following example, the &quot;define&quot; option is used to force compilation of debugging statements.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wfc /def=__debug__ test</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wfc386 /def=__debug__ test</TT>
<H2 ID="General_Notes_About_Compiler_Directives"> General Notes About Compiler Directives </H2>
<OL>
<LI>Compiler directives must not contain embedded blanks.&nbsp; The following is not a valid ENDIF compiler directive.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$end if</TT>
<LI>Nesting is allowed up to a maximum of 16 levels.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$ifdef sym1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;statements&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$ifdef sym2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;statements&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$endif</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$endif</TT>
<LI>The macro<TT> __i86__</TT> is a special macro that is defined by the compiler and identifies the target as a 16-bit Intel
80x86 compatible environment.
<LI>The macro<TT> __386__</TT> is a special macro that is defined by the compiler and identifies the target as a 32-bit Intel
80386 compatible environment.
<LI>The macro <TT> __stack_conventions__</TT> is a special macro that is defined by the 32-bit compiler when stack conventions
are used for code generation.&nbsp; Stack conventions are used when the &quot;sc&quot; or &quot;3s&quot; compiler options
are specified.
<LI>The macro <TT> __fpi__</TT> is a special macro that is defined by the compiler when one of the following floating-point
options is specified:&nbsp; &quot;fpi&quot; or &quot;fpi87&quot;.
<LI>The macro<TT> __debug__</TT> is a special macro that can be used to conditionally compile debugging statements.&nbsp;
A debugging statement is one that contains the character &quot;D&quot; or &quot;d&quot; in column one.
</OL>
<H1 ID="Open_Watcom_FORTRAN_77_File_Handling"> Open Watcom FORTRAN 77 File Handling </H1>
<BR>This chapter describes the file handling and naming conventions of Open Watcom F77.&nbsp; We discuss<B> files</B> and<B>
devices</B> which are used to store, retrieve and display data.&nbsp; For example, a disk can be used to store a file of student
marks.&nbsp; This file is accessible by other programs in order to produce summaries of the data such as marks reports.&nbsp;
A device such as a printer can also be treated as if it were a file, although it is only useful for displaying data; an attempt
to read information from this device is invalid.
<BR><BR>In the following sections, we shall describe:
<OL>
<LI>the techniques that Open Watcom F77 adopts for implementing<B> FORMATTED</B> and<B> UNFORMATTED</B> records and<B> SEQUENTIAL</B>
and<B> DIRECT</B> access to these records,
<LI>the handling of &quot;print&quot; files,
<LI>file naming conventions,
<LI>logical file names,
<LI>the preconnection of files to units, and
<LI>special device support.
</OL>
<H2 ID="Record_Access"> Record Access </H2>
<BR>Two types of record access are supported by Open Watcom F77:
<DL>
<DT>Sequential
<DD>Sequential access means that records in a file are accessed in order, starting with the first record in the file and proceeding
to the last.&nbsp; Sequential access is permitted to records in both variable-length and fixed-length record files.
<DT>Direct
<DD>Direct access means that records in a file are accessed in random order.&nbsp; For example, the fifth record could be accessed,
then the second, and then the tenth.&nbsp; Direct access is permitted for fixed-length record files only.
</DL>
<BR>The access method is described using the<B><I> ACCESS=</I></B> specifier of the FORTRAN<B><I> OPEN</I></B> statement.
&nbsp;The default access is &quot;SEQUENTIAL&quot;.
<H2 ID="Record_Format"> Record Format </H2>
<BR>There are two record formats, &quot;FORMATTED&quot; and &quot;UNFORMATTED&quot;, which are supported by Open Watcom F77.
&nbsp;The record format is described using the<B><I> FORM=</I></B> specifier of the FORTRAN<B><I> OPEN</I></B> statement.
&nbsp;The default format is &quot;FORMATTED&quot; for files connected for sequential access and &quot;UNFORMATTED&quot; for
files connected for direct access.
<BR><BR>In describing these two formats, we also refer to the two methods of record access, &quot;SEQUENTIAL&quot; and &quot;DIRECT&quot;,
which are supported by Open Watcom F77.
<H3 ID="FORMATTED_Records"> FORMATTED Records </H3>
<BR>A<B> FORMATTED</B> record is one that contains an arbitrary number of ASCII characters.&nbsp; The end of a record is marked
by an ASCII &quot;LF&quot; (line feed) character optionally preceded by an ASCII &quot;CR&quot; (carriage return) character.
&nbsp;Thus this special sequence may not appear in the middle of a record.
<BR><BR>FORMATTED records may vary in length.&nbsp; If all the records in the file have the same length then the records may
be accessed both &quot;sequentially&quot; and &quot;directly&quot;.&nbsp; If the records vary in length then it is only possible
to access the records sequentially.
<BR><BR>For direct access, the length of the records is specified by the<B><I> RECL=</I></B> specifier of the FORTRAN<B><I>
OPEN</I></B> statement.&nbsp; The specified length must not include the record separator since it does not form part of the
record.
<BR><BR>As an extension to the FORTRAN 77 language standard, Open Watcom F77 also supports the use of the<B><I> RECL=</I></B>
specifier for sequential access.&nbsp; The maximum length of the records may be specified by the<B><I> RECL=</I></B> specifier
of the FORTRAN<B><I> OPEN</I></B> statement.&nbsp; The specified length must not include the record separator since it does
not form part of the record.&nbsp; The length is used to allocate a record buffer for sequential access.&nbsp; If the record
length is not specified, a default maximum length of 1024 characters is assumed.
<H3 ID="UNFORMATTED_Records"> UNFORMATTED Records </H3>
<BR>An<B> UNFORMATTED</B> record is one that contains an arbitrary number of binary storage units.&nbsp; The interpretation
of the data in such a record depends on the FORTRAN program that is processing the record.&nbsp; An UNFORMATTED record may
contain integers, real numbers, character strings, or any other type of FORTRAN data.
<BR><BR>UNFORMATTED records may also vary in length.&nbsp; If all records in the file have the same length then the records
may be accessed both &quot;sequentially&quot; and &quot;directly&quot;.&nbsp; If the records vary in length then it is only
possible to access the records sequentially.
<BR><BR>When a file containing UNFORMATTED records is accessed sequentially, each record must begin and end with a descriptor
that contains the length of the record.&nbsp; The length of the record is represented in 32 bits or 4 bytes (INTEGER*4).&nbsp;
The UNFORMATTED records of a file which are written using sequential access will be automatically supplied with the appropriate
length descriptors.&nbsp; When such a file is read, it is assumed that each record has the appropriate length descriptors.
<BR><BR>Depending on the record length, the output produced by a single unformatted sequential<B><I> WRITE</I></B> statement
may cause multiple records to be written.&nbsp; As previously mentioned, each record begins and ends with a length descriptor.
&nbsp;The length descriptors for the first record contain the length of the record.&nbsp; The length descriptors for the remaining
records contain the length of the record with the high bit (bit 31) set to one.&nbsp; In this way, an unformatted sequential
file can be viewed as a number of logical records (a logical record corresponding to the output produced by a<B><I> WRITE</I></B>
statement) with each logical record composed of a number of physical records.&nbsp; Files created in this way cannot be accessed
directly unless each logical record is composed of a single physical record and each record is the same size.
<BR><BR>As an extension to the FORTRAN 77 language standard, Open Watcom F77 also supports the use of the<B><I> RECL=</I></B>
specifier for sequential access.&nbsp; The maximum length of the records may be specified by the<B><I> RECL=</I></B> specifier
of the FORTRAN<B><I> OPEN</I></B> statement.&nbsp; The specified length must not include the length descriptors since they
do not form part of the record.&nbsp; The length is used to allocate a record buffer for sequential access.&nbsp; If the record
length is not specified, a default maximum length of 1024 characters is assumed.
<BR><BR>When a file containing UNFORMATTED records is accessed directly, each record must be the same length.&nbsp; In this
case, the length of the records is specified by the<B><I> RECL=</I></B> specifier of the FORTRAN<B><I> OPEN</I></B> statement.
&nbsp;If the file was originally created with sequential access then the specified length must include any length descriptors
which form part of the record.&nbsp; In the direct access mode, no interpretation is placed on any of the data in an UNFORMATTED
record and the programmer must account for any record length descriptors which may form part of the record.
<BR><BR>Any records which are written using direct access must include record length descriptors if the file is to be accessed
sequentially at a later time.&nbsp; As an alternative, you may specify<TT> RECORDTYPE='VARIABLE'</TT> in the FORTRAN<B><I>
OPEN</I></B> statement.&nbsp; This specifier is an extension to the FORTRAN 77 language standard and will cause length descriptors
to be generated automatically.&nbsp; In this case, the record length should not include the record length descriptors.
<H3 ID="Files_with_no_Record_Structure"> Files with no Record Structure </H3>
<BR>Certain files, for example a file created by a program written in another language, do not have any internal record structure
that matches any of the record structures supported by Open Watcom F77.&nbsp; These files are simply streams of data.&nbsp;
There are two ways in which these files can be processed.
<OL>
<LI>You can use unformatted direct access.&nbsp; In this case, the value specified by the<B><I> RECL=</I></B> specifier in
the<B><I> OPEN</I></B> statement determines the amount of data read or written by a<B><I> READ</I></B> or<B><I> WRITE</I></B>
statement.
<LI>Alternatively, you can use unformatted sequential access.&nbsp; In this case, the amount of data read or written to the
file is determined by the items in the input/output list of the<B><I> READ</I></B> or<B><I> WRITE</I></B> statement.&nbsp;
When using unformatted sequential access, you must specify<TT> RECORDTYPE='FIXED'</TT> to indicate that no record boundaries
are present.&nbsp; Otherwise, the default value of<TT> 'VARIABLE'</TT> will be used.
</OL>
<H2 ID="Attributes_of_Files"> Attributes of Files </H2>
<BR>The file system does not retain any information on the contents of a file.&nbsp; Unlike more sophisticated file systems,
it cannot report whether a file consists of fixed-length or variable-length records, how records are delimited in a file,
the maximum length of the records, etc.&nbsp; Therefore, we have provided a mechanism which will allow you to specify additional
information about a file.&nbsp; This mechanism should be used when the default assumptions about records in a file are not
true for the file in question.
<BR><BR>The<B><I> RECORDTYPE=</I></B> specifier of the FORTRAN<B><I> OPEN</I></B> statement can be used to specify additional
information about the type of records in the file.&nbsp; This specifier is an extension to the FORTRAN 77 language standard.
<BR><BR>The<B><I> RECL=</I></B> specifier of the FORTRAN<B><I> OPEN</I></B> statement can be used to specify additional information
about the length of records in the file.&nbsp; When used with sequential access, this specifier is an extension to the FORTRAN
77 language standard.
<BR><BR>The<B><I> CARRIAGECONTROL=</I></B> specifier of the FORTRAN<B><I> OPEN</I></B> statement can be used to specify additional
information about the handling of ASA carriage control characters for an output file.&nbsp; This specifier is an extension
to the FORTRAN 77 language standard.
<BR><BR>The<B><I> BLOCKSIZE=</I></B> specifier of the FORTRAN<B><I> OPEN</I></B> statement can be used to specify the size
of the internal input/output buffer.&nbsp; A buffer reduces the number of system input/output calls during input/output to
a particular file and hence improves the overall performance of a program.&nbsp; The default buffer size is 4K.&nbsp; This
specifier is an extension to the FORTRAN 77 language standard.
<BR><BR>The following sections describe the attributes of records supported by the Open Watcom F77 run-time system.
<H3 ID="Record_Type"> Record Type </H3>
<BR>The<B><I> RECORDTYPE=</I></B> specifier of the FORTRAN<B><I> OPEN</I></B> statement can be used to specify additional
information about the type of records in the file.&nbsp; This specifier is an extension to the FORTRAN 77 language standard.
&nbsp;The following types may be specified.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; RECORDTYPE='TEXT'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; RECORDTYPE='VARIABLE'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; RECORDTYPE='FIXED'</TT>
<DL>
<DT>TEXT
<DD>indicates that the file contains variable-length or fixed-length records of ASCII characters separated by an ASCII &quot;LF&quot;
(line feed) character optionally preceded with an ASCII &quot;CR&quot; (carriage return) character.&nbsp; By default, the
Open Watcom F77 run-time system assumes that<B><I> FORMATTED</I></B> records are of<B><I> TEXT</I></B> format in both the<B>
sequential</B> and<B> direct</B> access modes.
<BR><BR>By default, the Open Watcom F77 run-time system uses variable-length record<B><I> TEXT</I></B> files to implement<B><I>
FORMATTED</I></B> records in the<B> sequential</B> access mode.&nbsp; Of course, all records may be the same length.&nbsp;
The record separator is not included in calculating the maximum size of records in the file.
<BR><BR>By default, the Open Watcom F77 run-time system uses fixed-length record<B><I> TEXT</I></B> files to implement<B><I>
FORMATTED</I></B> records in the<B> direct</B> access mode.&nbsp; Each record must be the same length.&nbsp; The record separator
is not included in calculating the size of records in the file.
<DT>VARIABLE
<DD>indicates that the file contains variable-length or fixed-length records in which special descriptors are employed to describe
the length of each record.&nbsp; The length of each record is contained in a doubleword (INTEGER*4 item) at the beginning
and end of the record.&nbsp; These descriptors determine the bounds of the records.
<BR><BR>By default, the Open Watcom F77 run-time system uses<B><I> VARIABLE</I></B> format files to implement<B><I> UNFORMATTED</I></B>
records in the<B> sequential</B> access mode.&nbsp; The length descriptors are required to support the FORTRAN<B><I> BACKSPACE</I></B>
statement since no other method exists for determining the bounds of a variable-length unformatted record in a file.
<DT>FIXED
<DD>indicates that the file contains no extra information that determines the record structure.&nbsp; If the file is a direct
access file, the value specified by the<B><I> RECL=</I></B> specifier determines the size of each record in the file.
<BR><BR>By default, the Open Watcom F77 run-time system uses<B><I> FIXED</I></B> format files to implement<B><I> UNFORMATTED</I></B>
records in the<B> direct</B> access mode.
<BR><BR>If you specify<B><I> FIXED</I></B> with an unformatted sequential file, the size of the records is determined by the
items in the input/output list.
</DL>
<H3 ID="Record_Size"> Record Size </H3>
<BR>When access is<B> direct,</B> the record length must be specified in the<B><I> RECL=</I></B> specifier of the FORTRAN<B><I>
OPEN</I></B> statement.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; OPEN( UNIT=1, FILE='TEST.DAT', ACCESS='DIRECT', RECL=size, ... )</TT>
<BR><BR>As an extension to the FORTRAN 77 language standard, the record length may also be specified when the access is<B>
sequential.</B>&nbsp; This should be done whenever access is &quot;sequential&quot; and the maximum record length is greater
than the default.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; OPEN( UNIT=1, FILE='TEST.DAT', ACCESS='SEQUENTIAL', RECL=size, ... )</TT>
<BR><BR>The record length specified by<B> size</B> should not include record separators such as CR and LF, nor should it include
record length descriptors when sequentially accessing a file containing unformatted records.&nbsp; However, for all files,
records longer than the size specified will be truncated.&nbsp; The default record size is 1024.&nbsp; The maximum record
size is 65535 for the 16-bit run-time system.&nbsp; Since record buffers are allocated in the dynamic storage region, the
size will be restricted to the amount of dynamic storage available.
<H3 ID="Print_File_Attributes"> Print File Attributes </H3>
<BR>When the first character of each record written to a file will contain an ASA (American Standards Association) carriage
control character, the<B><I> CARRIAGECONTROL=</I></B> specifier of the FORTRAN<B><I> OPEN</I></B> statement should be used.
&nbsp;This specifier is an extension to the FORTRAN 77 language standard.&nbsp; The ASA character is used for vertical spacing
control.&nbsp; The valid characters and their interpretation are:
<DL>
<DT>&quot;1&quot;
<DD>Advance to Top of Page
<DT>&quot;+&quot;
<DD>Advance Zero Lines (overprint)
<DT>&quot; &quot;
<DD>Advance 1 Line
<DT>&quot;0&quot;
<DD>Advance 2 Lines
<DT>&quot;-&quot;
<DD>Advance 3 Lines
</DL>
<BR>If<TT> CARRIAGECONTROL='YES'</TT> is specified then the Open Watcom F77 run-time system will automatically allocate an
extra character at the beginning of a record for the vertical spacing control.
<BR><BR>Upon transmitting a record to a file which has the &quot;carriage&quot; attribute, the Open Watcom F77 run-time system
will substitute the appropriate ASCII carriage control characters as follows.
<DL>
<DT>&quot;1&quot;
<DD>Substitute a FF (form feed) for the &quot;1&quot;.
<DT>&quot;+&quot;
<DD>Append only a CR (carriage return ) to the previous record.
<DT>&quot; &quot;
<DD>Throw away the blank character.
<DT>&quot;0&quot;
<DD>Substitute CR (carriage return) and LF (line feed) for the &quot;0&quot;.
<DT>&quot;-&quot;
<DD>Substitute two pairs of CR and LF for the &quot;-&quot;.
<BR><BR>Any other character in this position will be treated as if a blank character had been found (i.e., it will be discarded).
</DL>
<BR>If the &quot;carriage&quot; attribute is not specified for a file then records will be written to the file without placing
any interpretation on the first character position of the record.
<H3 ID="InputDOutput_Buffer_Size"> Input/Output Buffer Size </H3>
<BR>The<B><I> BLOCKSIZE=</I></B> specifier is optional.&nbsp; However if you would like to change the default buffer size
of 16K for 32-bit applications and 4K for 16-bit applications, you must specify the buffer size in the<B><I> BLOCKSIZE=</I></B>
specifier of the<B><I> OPEN</I></B> statement.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; OPEN( UNIT=1, FILE='TEST.DAT', BLOCKSIZE=1024, ... )</TT>
<H3 ID="File_Sharing"> File Sharing </H3>
<BR>On systems that support multi-tasking or networking, it is possible for for a file to be accessed simultaneously by more
that one process.&nbsp; There are two specifiers in the<B><I> OPEN</I></B> statement that can be used to control the way in
which files are shared between processes.
<BR><BR>The<B><I> ACTION=</I></B> specifier indicates the way in which the file is initially accessed.&nbsp; That is, the
way in which the first process to open the file accesses the file.&nbsp; The values allowed for the<B><I> ACTION=</I></B>
specifier are the following.
<DL>
<DT>'READ'
<DD>the file is opened for read-only access
<DT>'WRITE'
<DD>the file is opened for write-only access
<DT>'READWRITE'
<DD>the file is opened for both read and write access
</DL>
<BR>The<B><I> SHARE=</I></B> specifier can be used to indicate the manner in which subsequent processes are allowed to access
the file while the file is open.&nbsp; The values allowed for the<B><I> SHARE=</I></B> specifier are the following.
<DL>
<DT>'COMPAT'
<DD>no other process may open the file
<DT>'DENYRW'
<DD>other processes are denied read and write access
<DT>'DENYWR'
<DD>other process are denied write access (allowed read-only access)
<DT>'DENYRD'
<DD>other process are denied read access (allowed write-only access)
<DT>'DENYNONE'
<DD>other processes are allowed read and write access
</DL>
<BR>Let us consider the following scenario.&nbsp; Suppose you want several processes to read a file and prevent any process
that is reading the file from changing its contents.&nbsp; We first must establish the method of access for the first process
that opens the file.&nbsp; In this case, we want read-only access so the<TT> ACTION='READ'</TT> specifier must be used.&nbsp;
Next, we must establish the method of access for subsequent processes.&nbsp; In our example, we do not want any process to
make changes to the file.&nbsp; Therefore, we use the<TT> SHARE='DENYWR'</TT> specifier.&nbsp; The file would be opened using
the following<B><I> OPEN</I></B> statement.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; OPEN( UNIT=1, FILE='TEST.DAT', ACTION='READ', SHARE='DENYWR', ... )</TT>
<H2 ID="File_Names_in_the_FAT_File_System"> File Names in the FAT File System </H2>
<BR>The FAT file system is supported by DOS and OS/2.&nbsp; OS/2 also supports the High Performance File System (HPFS) which
will be discussed in a later section.&nbsp; File naming conventions are used to form file designations in a given file system.
&nbsp;The file designation for a FAT file system has the following form.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [d:][path]filename[.ext]</TT>
<DL>
<DT>[]
<DD>The square brackets denote items which are optional.&nbsp; 
<DT>d:
<DD>is the<B> drive name.</B>&nbsp; If omitted, the default drive is assumed.
<BR><BR>Examples of drive names are:<TT>&nbsp; a:</TT>,<TT> b:</TT>,<TT> c:</TT>, and<TT> d:</TT>.&nbsp; 
<DT>path
<DD>is called a &quot;path&quot; specification.&nbsp; The path may be used to refer to files that are stored in sub-directories
of the disk.&nbsp; The complete file specification (including drive, path and file name) cannot exceed 143 characters.
<BR><BR>Some examples of path specifications are:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; \plot\</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; \bench\tools\</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; \fortran\pgms\</TT>
<BR><BR>Your operating system manuals can tell you more about directories:&nbsp; how to create them, how to store files in
them, how to specify a path, etc.&nbsp; 
<DT>filename
<DD>is the main part of the file's name.&nbsp; The filename can contain up to 8 characters.&nbsp; If more than 8 characters are
used, only the first 8 are meaningful.&nbsp; For example, &quot;COUNTRIES&quot; and &quot;COUNTRIE&quot; are treated as the
same name for a file.&nbsp; 
<DT>ext
<DD>is an optional<B> extension</B> consisting of 1 to 3 characters (e.g., DOC).&nbsp; If an extension is specified, it is separated
from the filename by a period.&nbsp; Extensions are normally used to indicate the type of information stored in the file.
&nbsp;For example, a file extension of<TT> for</TT> is a common convention for FORTRAN programs.
</DL>
<HR>
<BR><B><I>&nbsp; Note:</I></B>&nbsp; The file specification is case insensitive in that upper and lower case letters can be
used interchangeably.
<HR>
<H3 ID="Special_DOS_Device_Names"> Special DOS Device Names </H3>
<BR>Certain file names are reserved for devices.&nbsp; These special device names are:&nbsp; 
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CON&nbsp;&nbsp; the console (or terminal)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; AUX&nbsp;&nbsp; the serial port</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; COM1&nbsp; another name for the serial port</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; COM2&nbsp; a second serial port</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; PRN&nbsp;&nbsp; the parallel printer</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; LPT1&nbsp; another name for the printer</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; LPT2&nbsp; a second parallel printer</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; LPT3&nbsp; a third parallel printer</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; NUL&nbsp;&nbsp; nonexistent device</TT>
<BR><BR>When using one of these special device names, no other part of the file designation should be specified.&nbsp; A common
mistake is to attempt to create a disk file such as<TT> PRN.DAT</TT> and attempt to write records to it.&nbsp; If you do not
have a parallel printer attached to your PC, there may be a long delay before the output operation times out.
<H3 ID="Examples_of_FAT_File_Specifications"> Examples of FAT File Specifications </H3>
<BR>The following are some examples of valid file specifications.
<OL>
<LI>The following file designation refers to a file in the current directory of the default disk.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; OPEN( UNIT=1, FILE='DATA.FIL', ... )</TT>
<LI>The following file designation refers to a print file in the current directory of drive<TT> c:</TT>.&nbsp; ASA carriage
control characters will be converted to the appropriate ASCII control codes.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; OPEN( UNIT=2, FILE='</TT><TT>c:report.lst</TT><TT>',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CARRIAGECONTROL='YES', ... )</TT>
<LI>The file specification below indicates that the file is to have fixed format records of length 80.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; OPEN( UNIT=3, FILE='</TT><TT>final.tst</TT><TT>',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RECL=80, RECORDTYPE='FIXED', ... )</TT>
<LI>The file specification below indicates that the file is to have variable format records of maximum length 145.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; OPEN( UNIT=4, FILE='</TT><TT>term.rpt</TT><TT>',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RECL=145, RECORDTYPE='VARIABLE', ... )</TT>
<LI>The file designation below indicates that the file resides in the<TT> records</TT> directory of drive<TT> b:</TT>.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; OPEN( UNIT=5, FILE='</TT><TT>b:\records\customers.dat</TT><TT>', ... )</TT>
<BR><BR>Note that the trailing &quot;S&quot; in the file name will be ignored.&nbsp; Thus the following designation is equivalent.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; OPEN( UNIT=5, FILE='</TT><TT>b:\records\customer.dat</TT><TT>', ... )</TT>
<LI>The file designation below refers to the second serial port.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; OPEN( UNIT=6, FILE='</TT><TT>com2</TT><TT>', ... )</TT>
<LI>The file designation below refers to a second parallel printer.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; OPEN( UNIT=7, FILE='</TT><TT>lpt2</TT><TT>', ... )</TT>
</OL>
<H2 ID="File_Names_in_the_High_Performance_File_System"> File Names in the High Performance File System </H2>
<BR>OS/2, in addition to supporting the FAT file system, also supports the High Performance File System (HPFS).&nbsp; The
rules for forming file names in the High Performance File System are different from those used to form file names in the FAT
file system.&nbsp; In HPFS, file names and directory names can be up to 254 characters in length.&nbsp; However, the complete
path (including drive, directories and file name) cannot exceed 259 characters.&nbsp; The period is a valid file name character
and can appear in a file name or directory name as many times as required; HPFS file names do not require file extensions
as in the FAT file system.&nbsp; However, many applications still use the period to denote file extensions.
<BR><BR>The HPFS preserves case in file names only in directory listings but ignores case in file searches and other system
operations.&nbsp; For example, a directory cannot have more than one file whose names differ only in case.
<H3 ID="Special_OSD2_Device_Names"> Special OS/2 Device Names </H3>
<BR>The OS/2 operating system has reserved certain file names for character devices.&nbsp; These special device names are:
&nbsp;
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CLOCK$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Clock</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; COM1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; First serial port</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; COM2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Second serial port</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; COM3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Third serial port</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; COM4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fourth serial port</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CON&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console keyboard
and screen</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; KBD$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Keyboard</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; LPT1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; First parallel printer</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; LPT2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Second parallel printer</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; LPT3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Third parallel printer</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; MOUSE$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Mouse</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; NUL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Nonexistent (dummy)
device</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; POINTER$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Pointer draw device (mouse screen support)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; PRN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The default printer,
usually LPT1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SCREEN$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Screen</TT>
<BR><BR>When using one of these special device names, no other part of the file designation should be specified.
<H3 ID="Examples_of_HPFS_File_Specifications"> Examples of HPFS File Specifications </H3>
<BR>The following are some examples of valid file specifications.
<OL>
<LI>The following file designation refers to a file in the current directory of the default disk.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; OPEN( UNIT=1, FILE='DATA.FIL', ... )</TT>
<LI>The following file designation refers to a print file in the current directory of drive<TT> c:</TT>.&nbsp; ASA carriage
control characters will be converted to the appropriate ASCII control codes.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; OPEN( UNIT=2, FILE='</TT><TT>c:report.lst</TT><TT>',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CARRIAGECONTROL='YES', ... )</TT>
<LI>The file specification below indicates that the file is to have fixed format records of length 80.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; OPEN( UNIT=3, FILE='</TT><TT>final.tst</TT><TT>',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RECL=80, RECORDTYPE='FIXED', ... )</TT>
<LI>The file specification below indicates that the file is to have variable format records of maximum length 145.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; OPEN( UNIT=4, FILE='</TT><TT>term.rpt</TT><TT>',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RECL=145, RECORDTYPE='VARIABLE', ... )</TT>
<LI>The file designation below indicates that the file resides in the<TT> records</TT> directory of drive<TT> b:</TT>.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; OPEN( UNIT=5, FILE='</TT><TT>b:\records\customers.dat</TT><TT>', ... )</TT>
<BR><BR>Note that the trailing &quot;S&quot; in the file name is not ignored as is the case in a FAT file system.
<LI>The file designation below refers to the second serial port.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; OPEN( UNIT=6, FILE='</TT><TT>com2</TT><TT>', ... )</TT>
<LI>The file designation below refers to a second parallel printer.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; OPEN( UNIT=7, FILE='</TT><TT>lpt2</TT><TT>', ... )</TT>
</OL>
<H2 ID="Establishing_Connections_Between_Units_and_Files"> Establishing Connections Between Units and Files </H2>
<BR>Using Open Watcom F77, FORTRAN unit numbers may range from 0 to 999.&nbsp; Input/output statements such as<B><I> READ</I></B>
and<B><I> WRITE</I></B> refer to files by a unit number.&nbsp; All input/output statements except<B><I> OPEN</I></B> ,<B><I>
CLOSE</I></B> , and<B><I> INQUIRE</I></B> must refer to a unit that is connected to a file.&nbsp; The Open Watcom F77 run-time
system automatically establishes the connection of a unit to a file if no connection previously existed.&nbsp; Any connection
between a unit and a file that is established before execution begins is called a preconnection.
<BR><BR>The Open Watcom F77 run-time system defines a preconnection of the unit designated by &quot;*&quot; to the standard
input and output devices (by this we generally mean the keyboard and screen of the personal computer but input/output can
be redirected from/to a file using the standard input/output redirectors &quot;&lt;&quot; and &quot;&gt;&quot; on the command
line).&nbsp; This preconnection cannot be altered in any way.&nbsp; Unit &quot;*&quot; is explicitly or implicitly referred
to by the following input statements:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; READ, ...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; READ *, ...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; READ format-spec, ...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; READ(*,...) ...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; READ(UNIT=*,...) ...</TT>
<BR><BR>Unit &quot;*&quot; is explicitly or implicitly referred to by the following output statements:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; PRINT, ...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, ...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; PRINT format-spec, ...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; WRITE(*,...) ...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; WRITE(UNIT=*,...) ...</TT>
<BR><BR>The Open Watcom F77 run-time system also defines a preconnection of unit 5 to the standard input device (by this we
generally mean the keyboard of the personal computer but input can be redirected from a file using the standard input redirector
&quot;&lt;&quot; on the command line).
<BR><BR>The Open Watcom F77 run-time system also defines a preconnection of unit 6 to the standard output device (by this
we generally mean the screen of the personal computer but output can be redirected to a file using the standard output redirector
&quot;&gt;&quot; on the command line).
<BR><BR>For all other allowable units, a default preconnection between unit number &quot;nnn&quot; and the file<TT> FORnnn</TT>
is assumed when no connection between a unit and a file has been established.<B>&nbsp; nnn</B> is a three-digit FORTRAN unit
number.&nbsp; Unit 0 is &quot;000&quot;, unit 1 is &quot;001&quot;, unit 2 is &quot;002&quot;, and so on.&nbsp; There is no
file extension in this case.&nbsp; In other words, a default file name is constructed for any unit number for which no other
connection has been established.&nbsp; Input/output statements of the following forms refer to these units.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CLOSE(nnn,...)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPEN(nnn,...)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CLOSE(UNIT=nnn,...)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPEN(UNIT=nnn,...)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; BACKSPACE nnn&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ(nnn,...)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; BACKSPACE(nnn)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ(UNIT=nnn,...)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; BACKSPACE(UNIT=nnn)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REWIND nnn</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ENDFILE nnn&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
REWIND(nnn)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ENDFILE(nnn)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REWIND(UNIT=nnn)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ENDFILE(UNIT=nnn)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WRITE(nnn,...) ...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; INQUIRE(nnn,...)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WRITE(UNIT=nnn,...) ...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; INQUIRE(UNIT=nnn,...)</TT>
<BR><BR>Of course, it is unlikely that one would be satisfied with using such undistinguished file names such as<TT> for000</TT>,<TT>
for001</TT>, and so on.&nbsp; Therefore, the Open Watcom F77 run-time system provides additional ways of establishing a preconnection
between a FORTRAN<B><I> UNIT</I></B> and a file.
<BR><BR>The Open Watcom F77 run-time system supports the use of the &quot;SET&quot; command to establish a connection between
a unit and a file.&nbsp; The &quot;SET&quot; command is used to create, modify and remove &quot;Environment Variables&quot;.
&nbsp;The &quot;SET&quot; command must be issued before running a program.&nbsp; The format for a preconnection using the
&quot;SET&quot; command is:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SET unit=file_spec</TT>
<DL>
<DT>where
<DD><B>description</B>
<DT>unit
<DD>is a FORTRAN unit number in the range 0 to 999.
<BR><BR>If this form of the &quot;SET&quot; command is used then FORTRAN unit number<B> unit</B> is preconnected to the specified
file.&nbsp; FORTRAN input/output statements which refer to the unit number will access the records in the specified file.
<DT>file_spec
<DD>is the file specification of the preconnected file.
</DL>
<BR>Here are some sample &quot;SET&quot; commands.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set 1=input.dat</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set 2=output.dat</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set 3=d:\database\customer.fil</TT>
<BR><BR>The above example establishes the following preconnections:
<OL>
<LI>Between unit 1 and the file<TT> input.dat</TT> which resides (or will reside) in the current directory.
<LI>Between unit 2 and the file<TT> output.dat</TT> which resides (or will reside) in the current directory.
<LI>Between unit 3 and the file<TT> d:\database\customer.fil</TT> which resides (or will reside) in another disk and directory.
</OL>
<BR>Any FORTRAN input/output statements which refer to units 1, 2 or 3 will act upon one of these 3 data files.
<BR><BR><B>Notes:</B>
<OL>
<LI>The &quot;SET&quot; command must be issued before running the program.
<LI>No spaces should be placed before or after the &quot;=&quot; in the &quot;SET&quot; command.&nbsp; The following two examples
are quite distinct from each other:
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set 55=testbed.dat</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set 55 = testbed.dat</TT>
<BR><BR>To verify this, simply enter the two commands and then enter the &quot;SET&quot; command again with no arguments.
&nbsp;The current environment strings will be displayed.&nbsp; You should find two entries, one for &quot;55&quot; and one
for &quot;55 &quot;.
<LI>Since the number in front of the &quot;=&quot; is simply a character string, you should not specify any leading zeroes
either.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set 01=input.dat</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set 1=input.dat</TT>
<BR><BR>In this case, we again have two distinct environment variables.&nbsp; The variable &quot;01&quot; will be ignored
by the Open Watcom F77 run-time system.
<LI>An environment variable will remain in effect until you explicitly remove it or you turn off the personal computer.&nbsp;
To discontinue the preconnection between a unit number and a file, you must issue a &quot;SET&quot; command of the following
form.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set &lt;unit&gt;=</TT>
<BR><BR>In the above command,<TT> &lt;unit&gt;</TT> is the unit number for which the preconnection is to be discontinued.
<BR><BR>By omitting the character string after the &quot;=&quot;, the environment variable will be removed.&nbsp; For example,
to remove the environment variable &quot;01&quot; from the list, reenter the &quot;SET&quot; command specifying everything
up to and including the &quot;=&quot; character.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set 01=</TT>
<LI>Any time you wish to see the current list of environment strings, simply enter the &quot;SET&quot; command with no arguments.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; PROMPT=$d $t $p$_$n$g</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; COMSPEC=d:\dos\command.com</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; PATH=G:\;E:\CMDS;C:\WATCOM\BIN;D:\DOS;D:\BIN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; LIB=c:\watcom\lib286\dos</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 1=input.dat</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 2=output.dat</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 3=d:\database\customer.fil</TT>
<LI>An alternative to preconnecting files is provided by the FORTRAN<B><I> OPEN</I></B> statement which allows files to be
connected at execution time.
<LI>The preconnection of units 5 and 6 may be overridden using preconnection specifications or the FORTRAN<B><I> OPEN</I></B>
statement.&nbsp; The precedence of a connection between a unit number and a file is as follows:
<DL>
<DT><B><I>Precedence:</I></B>
<DD><B><I>User option:</I></B>
<DT>Lowest
<DD>Preconnection Specifications
<DT>Highest
<DD>OPEN statement
</DL>
<BR>In other words, the<B><I> OPEN</I></B> statement overrides a preconnection.
</OL>
<H2 ID="A_Preconnection_Tutorial"> A Preconnection Tutorial </H2>
<BR>In this section, we will look at some examples of how to establish the link between a file and a FORTRAN unit.
<BR><BR><B>Exhibit 1:</B>
<BR><BR>Consider the following example which reads pairs of numbers from a file and writes out the numbers and their sum.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * File 'iodemo.for'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 10&nbsp;&nbsp;&nbsp; READ( 1, *, END=99 ) X1, X2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WRITE( 6, 20 ) X1, X2, X1 + X2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GO TO 10</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 20&nbsp;&nbsp;&nbsp; FORMAT( 3F6.2 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 99&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>The FORTRAN<B><I> READ</I></B> statement will read records from a file connected to unit 1.&nbsp; The FORTRAN<B><I>
WRITE</I></B> statement will write records to a file connected to unit 6.&nbsp; As we described in the previous section, unit
6 is preconnected by the Open Watcom F77 run-time system to the screen.
<BR><BR>What file will be read when the<B><I> READ</I></B> statement refers to unit 1?&nbsp; By default, we know that it will
read a file called<TT> for001</TT>.&nbsp; However, suppose the data was actually stored in the file called<TT> numbers.dat</TT>.
&nbsp;We can direct the program to read the data in this file by using a &quot;SET&quot; command before running the program.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set 1=numbers.dat</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;iodemo</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.40&nbsp; 2.50&nbsp; 3.90</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3.90&nbsp; 8.70 12.60</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.10&nbsp; 9.90 11.00</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8.30&nbsp; 7.10 15.40</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8.20&nbsp; 3.50 11.70</TT>
<BR><BR><B>Exhibit 2:</B>
<BR><BR>Suppose that we now wish to write the output from the above program to a disk file instead of the screen.&nbsp; We
can do this without modifying the program.&nbsp; Since we know that the<B><I> WRITE</I></B> statement refers to unit 6, we
can alter the default preconnection of unit 6 to the screen by issuing another &quot;SET&quot; command.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set 6=numbers.rpt</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;iodemo</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;type numbers.rpt</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.40&nbsp; 2.50&nbsp; 3.90</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3.90&nbsp; 8.70 12.60</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.10&nbsp; 9.90 11.00</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8.30&nbsp; 7.10 15.40</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8.20&nbsp; 3.50 11.70</TT>
<BR><BR>Now any time a program writes or prints to unit 6, the output will be written to the disk file<TT> numbers.rpt</TT>.
&nbsp;If you are going to run other programs, it would be wise to remove the connection between unit 6 and this file so that
it is not accidentally overwritten.&nbsp; This can be done by issuing the following command.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set 6=</TT>
<BR><BR>You should also do the same for unit 1.
<BR><BR><B>Exhibit 3:</B>
<BR><BR>Must we always use &quot;SET&quot; commands to establish the connection between a unit and a file?&nbsp; Suppose that
you want to run the program quite often and that you do not want to issue &quot;SET&quot; commands every time.&nbsp; We can
do this by modifying the program to include FORTRAN<B><I> OPEN</I></B> statements.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * File 'iodemo.for'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPEN( 1, FILE='NUMBERS.DAT' )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPEN( 6, FILE='NUMBERS.RPT' )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 10&nbsp;&nbsp;&nbsp; READ( 1, *, END=99 ) X1, X2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WRITE( 6, 20 ) X1, X2, X1 + X2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GO TO 10</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 20&nbsp;&nbsp;&nbsp; FORMAT( 3F6.2 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 99&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>This is an example of a connection that is established at execution time.&nbsp; The connection that is established
by the<B><I> OPEN</I></B> statement overrides any preconnection that we might have established using a &quot;SET&quot; command.
&nbsp;We say that the<B><I> OPEN</I></B> statement has a higher precedence.&nbsp; However, even the<B><I> OPEN</I></B> statement
does not have the final word on which files will be accessed.&nbsp; You may wish to read the next section on the Open Watcom
F77 run-time system logical file name support to find out why this is so.
<H2 ID="Logical_File_Name_Support"> Logical File Name Support </H2>
<BR>The Open Watcom F77 run-time system supports logical or symbolic file names using the &quot;SET&quot; command.&nbsp; The
&quot;SET&quot; command may be used to define a logical file name and its corresponding actual file name.&nbsp; The format
for defining a logical file name is as follows:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SET name=file_spec</TT>
<DL>
<DT>where
<DD><B>description</B>
<DT>name
<DD>is any character string.&nbsp; The letters in &quot;name&quot; may be specified in upper or lower case.&nbsp; Lower case letters
are treated as if they had been specified in upper case.&nbsp; Thus &quot;SYSINPUT&quot; and &quot;sysinput&quot; are equivalent.
&nbsp;Note, however, that blank characters must not be specified before and after the &quot;=&quot; character.
<DT>file_spec
<DD>is the file specification of logical file.
</DL>
<BR><B>Notes and Examples:</B>
<OL>
<LI>A logical file name may be used in the<B><I> FILE=</I></B> specifier of the FORTRAN<B><I> OPEN</I></B> and<B><I> INQUIRE</I></B>
statements.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * File 'iodemo.for'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPEN( 1, FILE='SYSINPUT' )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 10&nbsp;&nbsp;&nbsp; READ( 1, *, END=99 ) X1, X2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WRITE( 6, 20 ) X1, X2, X1 + X2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GO TO 10</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 20&nbsp;&nbsp;&nbsp; FORMAT( 3F6.2 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 99&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>In the following example, we define the logical file name &quot;SYSINPUT&quot; to correspond to the file<TT> numbers.dat</TT>.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set sysinput=numbers.dat</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;iodemo</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.40&nbsp; 2.50&nbsp; 3.90</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3.90&nbsp; 8.70 12.60</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.10&nbsp; 9.90 11.00</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8.30&nbsp; 7.10 15.40</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8.20&nbsp; 3.50 11.70</TT>
<LI>If the name in a<B><I> FILE=</I></B> specifier is not included in one of the environment variable names then it is assumed
to be the actual name of a file.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; OPEN( 2, FILE='SYSOUT' )</TT>
<LI>The logical file name feature can also be used to provide additional information regarding the file name at execution
time.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * File 'iodemo.for'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPEN( 1, FILE='numbers.dat' )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 10&nbsp;&nbsp;&nbsp; READ( 1, *, END=99 ) X1, X2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WRITE( 6, 20 ) X1, X2, X1 + X2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GO TO 10</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 20&nbsp;&nbsp;&nbsp; FORMAT( 3F6.2 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 99&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>In the following example, the actual location (and name) of the file<TT> numbers.dat</TT> is described through the
use of an environment variable.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set numbers.dat=b:\data\input.dat</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;iodemo</TT>
<BR><BR>As you can see, a logical file name can resemble an actual file name.
<BR><BR>Of course, the entire file name could have been specified in the FORTRAN program.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; OPEN( 1, FILE='b:\data\input.dat' )</TT>
<LI>Only one level of lookup is performed.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * File 'iodemo.for'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPEN( 1, FILE='sysinput' )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 10&nbsp;&nbsp;&nbsp; READ( 1, *, END=99 ) X1, X2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WRITE( 6, 20 ) X1, X2, X1 + X2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GO TO 10</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 20&nbsp;&nbsp;&nbsp; FORMAT( 3F6.2 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 99&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>This is illustrated by the following commands.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set sysinput=datafile</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set datafile=input.dat</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;iodemo</TT>
<BR><BR>In the above example, unit 1 is connected to the file<TT> datafile</TT> and not the file<TT> input.dat</TT>.&nbsp;

<LI>Logical file names can be used to direct output normally intended for one device to another device.&nbsp; Consider the
following examples.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set lpt1=lpt2</TT>
<BR><BR>If the FORTRAN program specifies the name &quot;LPT1&quot; in an<B><I> OPEN</I></B> or<B><I> INQUIRE</I></B> statement,
the Open Watcom F77 run-time system will map this name to &quot;LPT2&quot;.&nbsp; In an<B><I> INQUIRE</I></B> statement, the<B><I>
NAME=</I></B> specifier will return the name &quot;LPT2&quot;.
<LI>As we mentioned earlier, the case of the name does not matter.&nbsp; Upper or lower case can be used interchangeably.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set sysinput=b:\data\input.dat</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set SYSINPUT=b:\data\input.dat</TT>
<LI>No spaces should be placed before or after the &quot;=&quot; in the &quot;SET&quot; command.&nbsp; The following two examples
are considered quite distinct from each other:
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set sysinput=testbed.dat</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set sysinput = testbed.dat</TT>
<BR><BR>This example will define two variables, &quot;SYSINPUT&quot; and &quot;SYSINPUT &quot;.
<LI>An environment variable will remain in effect until you explicitly remove it or you turn off the personal computer.&nbsp;
To remove an environment variable from the list, reenter the &quot;SET&quot; command specifying everything up to and including
the &quot;=&quot; character.&nbsp; For example, to remove the definition for &quot;SYSINPUT&quot;, the following command can
be issued.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set sysinput=</TT>
<LI>Any time you wish to see the current list of environment strings, simply enter the &quot;SET&quot; command with no arguments.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; PROMPT=$d $t $p$_$n$g</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; COMSPEC=d:\dos\command.com</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; PATH=G:\;E:\CMDS;C:\WATCOM\BIN;D:\DOS;D:\BIN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; LIB=c:\watcom\lib286\dos</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 1=input.dat</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 2=output.dat</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 3=d:\database\customer.fil</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SYSINPUT=b:\data\input.dat</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; LPT1=lpt2</TT>
</OL>
<H2 ID="Terminal_or_Console_Device_Support"> Terminal or Console Device Support </H2>
<BR>Input can come from the console or output can be written to the console by using the console device name<TT> con</TT>
as the file name.&nbsp; The console can be specified in a &quot;SET&quot; command or through the<B><I> FILE=</I></B> specifier
of the FORTRAN<B><I> OPEN</I></B> statement.
<BR><BR>The default action for any file is to open the file for both read and write access (i.e., ACTION='READWRITE').&nbsp;
Under Win32, there is a problem accessing the console device<TT> con</TT> for both read and write access.&nbsp; This problem
is overcome by using the<B><I> ACTION=</I></B> specifier in the<B><I> OPEN</I></B> statement.&nbsp; The<B><I> ACTION=</I></B>
specifier indicates the way in which the file is initially accessed.&nbsp; The values allowed for the<B><I> ACTION=</I></B>
specifier are the following.
<DL>
<DT>'READ'
<DD>the file is opened for read-only access
<DT>'WRITE'
<DD>the file is opened for write-only access
<DT>'READWRITE'
<DD>the file is opened for both read and write access
</DL>
<BR>To open the console device under Win32, you must specify whether you are going to &quot;READ&quot; or &quot;WRITE&quot;
to the file.&nbsp; If you wish to do both reading and writing, then you must use two separate units.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; OPEN( UNIT=1, FILE='CON', ACTION='READ')</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; OPEN( UNIT=2, FILE='CON', ACTION='WRITE')</TT>
<BR><BR>The console can be treated as a carriage control device.&nbsp; This is requested by using the<TT> CARRIAGECONTROL='YES'</TT>
specifier of the FORTRAN<B><I> OPEN</I></B> statement.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; OPEN( UNIT=1, FILE='con', CARRIAGECONTROL='YES' )</TT>
<BR><BR>Carriage control handling is described in the section entitled <A HREF="#Print_File_Attributes">Print File Attributes</A>.
<BR><BR>The console is not capable of supporting carriage control in a fashion identical to a printer.&nbsp; For example,
overprinting of records on the console is destructive in that the previous characters are erased.
<BR><BR>End of file is signalled by first pressing the Ctrl/Z key combination and then the line entering key.&nbsp; End of
file may be handled by using the<B><I> END=</I></B> specification of the FORTRAN<B><I> READ</I></B> statement.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ( UNIT=*, FMT=*, END=100 ) X, Y</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 100&nbsp;&nbsp;&nbsp; code to handle &quot;End of File&quot;</TT>
<BR><BR>End of file may also be handled by using the<B><I> IOSTAT=</I></B> specifier of the FORTRAN<B><I> READ</I></B> statement.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; READ( UNIT=*, FMT=*, IOSTAT=IOS ) X, Y</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; IF( IOS .NE. 0 )THEN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; code to handle &quot;End of File&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ENDIF</TT>
<H2 ID="Printer_Device_Support"> Printer Device Support </H2>
<BR>Output can be written to a printer by using a printer device name as the file name.&nbsp; A printer can be specified in
a &quot;SET&quot; command or through the<B><I> FILE=</I></B> specifier of the FORTRAN<B><I> OPEN</I></B> statement.&nbsp;
Several device names may be used:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; prn or lpt1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; lpt2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; lpt3</TT>
<BR><BR>The printer can be treated as a carriage control device.&nbsp; This is requested by using the<TT> CARRIAGECONTROL='YES'</TT>
specifier of the FORTRAN<B><I> OPEN</I></B> statement.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; OPEN( UNIT=1, FILE='prn', CARRIAGECONTROL='YES' )</TT>
<BR><BR>Carriage control handling is described in the section entitled <A HREF="#Print_File_Attributes">Print File Attributes</A>.
<H2 ID="Serial_Device_Support"> Serial Device Support </H2>
<BR>Output can be written to a serial port by using a serial device name as the file name.&nbsp; A serial device can be specified
in a &quot;SET&quot; command or through the<B><I> FILE=</I></B> specifier of the FORTRAN<B><I> OPEN</I></B> statement.&nbsp;
Three device names may be used:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; aux or com1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; com2</TT>
<BR><BR>The serial device can be treated as a carriage control device.&nbsp; This is requested by using the<TT> CARRIAGECONTROL='YES'</TT>
specifier of the FORTRAN<B><I> OPEN</I></B> statement.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; OPEN( UNIT=1, FILE='com1', CARRIAGECONTROL='YES' )</TT>
<BR><BR>Carriage control handling is described in the section entitled <A HREF="#Print_File_Attributes">Print File Attributes</A>.
<BR><BR>To set serial characteristics such as speed, parity, and word length, the &quot;MODE&quot; command may be used.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;mode com1:9600,n,8,1</TT>
<BR><BR>The above example sets serial port 1 to a speed of 9600 BAUD with no parity, a word length of 8 and 1 stop bit.
<H2 ID="File_Handling_Defaults"> File Handling Defaults </H2>
<BR>The following defaults apply to file specifications:
<UL>
<LI>The following table indicates the default<B> record type</B> for the allowable access methods and forms.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; File&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; Form</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Access&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Formatted&nbsp;&nbsp; Unformatted</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-----------+-----------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Sequential&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; Text&nbsp;&nbsp;&nbsp; | Variable&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-----------+-----------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Direct&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; Text&nbsp;&nbsp;&nbsp; | Fixed
&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-----------+-----------+</TT>
<BR><BR>Unless the record type of the file does not correspond to the default assumed by Open Watcom F77, the record type
attribute should not be specified.
<LI>Unless otherwise stated, the default<B> record length</B> for a file is 1024 characters.&nbsp; When access is &quot;direct&quot;,
the record length must be specified in the<B><I> RECL=</I></B> specifier of the FORTRAN<B><I> OPEN</I></B> statement.&nbsp;
The record length may also be specified when the access is &quot;sequential&quot;.&nbsp; This should be done whenever access
is &quot;sequential&quot; and the maximum record length is greater than the default.
<LI>The default<B> record access</B> is &quot;sequential&quot;.
<LI>When reading from or writing to a unit for which no preconnection has been specified or no &quot;FILE=&quot; form of the
FORTRAN<B><I> OPEN</I></B> statement has been executed, the default<B> file name</B> takes the form:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; FORnnn</TT>
<BR><BR><B>nnn</B> is a three-digit FORTRAN unit number.&nbsp; Unit 0 is &quot;000&quot;, unit 1 is &quot;001&quot;, unit
2 is &quot;002&quot;, and so on.&nbsp; There is no file extension in this case.
<LI>If the connection between a unit number and a file is discontinued through use of the FORTRAN<B><I> CLOSE</I></B> statement,
the same rule for constructing a file name will apply on the next attempt to read from or write to the specified unit.
</UL>
<H1 ID="The_Open_Watcom_F77_Subprogram_Library"> The Open Watcom F77 Subprogram Library </H1>
<BR>Open Watcom FORTRAN 77 includes additional FORTRAN subprograms which can be called from programs compiled by Open Watcom
F77.&nbsp; The following sections describe these subprograms.
<H2 ID="Subroutine_FEXIT"> Subroutine FEXIT </H2>
<BR>The subroutine<TT> FEXIT</TT> allows an application to terminate execution with a return code.&nbsp; It requires one argument
of type INTEGER that represents the value to be returned to the system.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INCLUDE 'FSUBLIB.FI'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALL FEXIT( -1 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR><B>Notes:</B>
<OL>
<LI>The FORTRAN include file<TT> fsublib.fi</TT>, located in the<TT> \watcom\src\fortran</TT> directory, contains typing and
calling information for this subprogram.&nbsp; The<TT> \watcom\src\fortran</TT> directory should be included in the<B> FINCLUDE</B>
environment variable so that the compiler can locate the include file.
</OL>
<H2 ID="INTEGER_Function_FGETCMD"> INTEGER Function FGETCMD </H2>
<BR>The INTEGER function<TT> FGETCMD</TT> allows an application to obtain the command line from within an executing program.
<BR><BR>The function<TT> FGETCMD</TT> requires one argument of type CHARACTER and returns the length of the command line.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INCLUDE 'FSUBLIB.FI'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER CMDLEN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*128 CMDLIN</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CMDLEN = FGETCMD( CMDLIN )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'Command length = ', CMDLEN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'Command line&nbsp;&nbsp; = ', CMDLIN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR><B>Notes:</B>
<OL>
<LI>The FORTRAN include file<TT> fsublib.fi</TT>, located in the<TT> \watcom\src\fortran</TT> directory, contains typing and
calling information for this subprogram.&nbsp; The<TT> \watcom\src\fortran</TT> directory should be included in the<B> FINCLUDE</B>
environment variable so that the compiler can locate the include file.
<LI>If the argument to<TT> FGETCMD</TT> is not long enough then only the first part of the command line is returned.
</OL>
<H2 ID="INTEGER_Function_FGETENV"> INTEGER Function FGETENV </H2>
<BR>The INTEGER function<TT> FGETENV</TT> allows an application to obtain the value of an environment string from within an
executing program.
<BR><BR>The function<TT> FGETENV</TT> requires two arguments of type CHARACTER.&nbsp; The first argument is the character
string to look for.<TT>&nbsp; FGETENV</TT> places the associated environment string value in the second argument and returns
the length of the environment string.&nbsp; If no such string is defined, the length returned is zero.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INCLUDE 'FSUBLIB.FI'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER STRLEN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*80 STRVAL</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STRLEN = FGETENV( 'PATH', STRVAL )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'Environment string length = ', STRLEN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'Environment string value&nbsp; = ', STRVAL</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR><B>Notes:</B>
<OL>
<LI>The FORTRAN include file<TT> fsublib.fi</TT>, located in the<TT> \watcom\src\fortran</TT> directory, contains typing and
calling information for this subprogram.&nbsp; The<TT> \watcom\src\fortran</TT> directory should be included in the<B> FINCLUDE</B>
environment variable so that the compiler can locate the include file.
<LI>If the second argument to<TT> FGETENV</TT> is not long enough then only the first part of the value is returned.
</OL>
<H2 ID="INTEGER_Function_FILESIZE"> INTEGER Function FILESIZE </H2>
<BR>The INTEGER function<TT> FILESIZE</TT> allows an application to determine the size of a file connected to a specified
unit.
<BR><BR>The function<TT> FILESIZE</TT> requires one argument of type INTEGER, the unit number and returns the size, in bytes,
of the file.&nbsp; If no file is connected to the specified unit, a value of -1 is returned.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INCLUDE 'FSUBLIB.FI'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPEN( UNIT=1, FILE='sample.fil' )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, FILESIZE( 1 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR><B>Notes:</B>
<OL>
<LI>The FORTRAN include file<TT> fsublib.fi</TT>, located in the<TT> \watcom\src\fortran</TT> directory, contains typing and
calling information for this subprogram.&nbsp; The<TT> \watcom\src\fortran</TT> directory should be included in the<B> FINCLUDE</B>
environment variable so that the compiler can locate the include file.
</OL>
<H2 ID="Subroutine_FINTR_and_FINTRF"> Subroutine FINTR and FINTRF </H2>
<BR>The subroutine<TT> FINTR</TT> and<TT> FINTRF</TT> allow the user to execute any software interrupt from a FORTRAN 77 program.
<HR>
<BR><B><I>&nbsp; Note:</I></B>&nbsp; These subroutines are only supported by the DOS and Windows libraries.
<HR>
<BR>The subroutine<TT> FINTR</TT> and<TT> FINTRF</TT> require two arguments.
<OL>
<LI>The first argument is an interrupt number.&nbsp; These subroutines will generate the software interrupt given by the this
argument.&nbsp; The type must be<TT> INTEGER.</TT>
<LI>The second argument is an<TT> INTEGER</TT> array of ten elements.
</OL>
<BR>When<TT> FINTR</TT> and<TT> FINTRF</TT> are called, the array contains the values to be assigned to the registers prior
to issuing the software interrupt.&nbsp; When control is returned from<TT> FINTR</TT> or<TT> FINTRF</TT> , it contains the
values of the registers after the software interrupt has completed.&nbsp; The registers are mapped onto the array<TT> REGS</TT>
as follows.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 31&nbsp;&nbsp;&nbsp;
&nbsp; 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; REGS(1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EAX</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; REGS(2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EBX</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; REGS(3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ECX</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; REGS(4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EDX</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; REGS(5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EBP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; REGS(6)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ESI</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; REGS(7)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EDI</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; REGS(8)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FS | DS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; REGS(9)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GS | ES</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; REGS(10)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eflags</TT>
<BR><BR>For 16-bit systems (e.g., 8088, 8086, 186, 286), only the low-order 16 bits of each register contain meaningful results.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 31&nbsp;&nbsp;&nbsp;
&nbsp; 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; REGS(1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AX</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; REGS(2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BX</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; REGS(3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CX</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; REGS(4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DX</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; REGS(5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; REGS(6)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SI</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; REGS(7)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DI</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; REGS(8)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; REGS(9)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ES</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; REGS(10)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; flags</TT>
<BR><BR>Difference between<TT> FINTR</TT> and<TT> FINTRF</TT> is that<TT> FINTR</TT> reset CPU flags before generate the software
interrupt, but<TT> FINTRF</TT> set it from REGS(10) element.
<BR><BR>The file<TT> dos.fi</TT>, located in the<TT> \WATCOM\src\fortran\dos</TT> directory, defines a set of equivalences
for ease of use.&nbsp; The contents of this file are reproduced below.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Define registers: These correspond to the element of an</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * array which is to contain the values of the registers.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 regd(10), regs(10)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 regw(2*10)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*1 regb(4*4)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 EAX,EBX,ECX,EDX,EBP,EDI,ESI,EFLAGS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 AX,BX,CX,DX,BP,DI,SI,DS,ES,FS,GS,FLAGS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*1 AH,AL,BH,BL,CH,CL,DH,DL</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; equivalence (regd,regs),(regd,regw),(regd,regb),</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1(EAX,regd(1)), (EBX,regd(2)), (ECX,regd(3)), (EDX,regd(4)),</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2(EBP,regd(5)), (EDI,regd(6)), (ESI,regd(7)), (EFLAGS,regd(10)),</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3(AX,regw(1)),&nbsp; (BX,regw(3)),&nbsp; (CX,regw(5)),&nbsp;
(DX,regw(7)),</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4(BP,regw(9)),&nbsp; (DI,regw(11)), (SI,regw(13)), (DS,regw(15)),</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5(FS,regw(16)), (ES,regw(17)), (GS,regw(18)), (FLAGS,regw(19)),</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6(AL,regb(1)),&nbsp; (AH,regb(2)),&nbsp; (BL,regb(5)),&nbsp;
(BH,regb(6)),</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7(CL,regb(9)),&nbsp; (CH,regb(10)), (DL,regb(13)), (DH,regb(14))</TT>
<BR><BR>The following is extracted from the &quot;CALENDAR&quot; program.&nbsp; It demonstrates the use of the<TT> FINTR</TT>
subroutine.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subroutine ClearScreen()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$noextensions</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; implicit none</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'dos.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Define BIOS functions.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer VIDEO_CALL, SCROLL_UP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameter (VIDEO_CALL=16, SCROLL_UP=6)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DS = ES = FS = GS = 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AH = SCROLL_UP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; ! scroll up</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AL = 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! blank entire window</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CX = 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! set row,column of upper left</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DX = 24*256 + 80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; ! set row,column of lower right</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BH = 7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! attribute &quot;white on black&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call fintr( VIDEO_CALL, regs )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<H2 ID="INTEGER_Function_FLUSHUNIT"> INTEGER Function FLUSHUNIT </H2>
<BR>The INTEGER function<TT> FLUSHUNIT</TT> flushes the internal input/output buffer for a specified unit.&nbsp; Each file,
except special devices such as<TT> con</TT>, has an internal buffer.&nbsp; Buffered input/output is much more efficient since
it reduces the number of system calls which are usually quite expensive.&nbsp; For example, many<B><I> WRITE</I></B> operations
may be required before filling the internal file buffer and data is physically transferred to the file.
<BR><BR>This function is particularly useful for applications that call non-FORTRAN subroutines or functions that wish to
perform input/output to a FORTRAN file.
<BR><BR>The function<TT> FLUSHUNIT</TT> requires one argument, the unit number, of type INTEGER.&nbsp; It returns an INTEGER
value representing the return code of the input/output operation.&nbsp; A return value of 0 indicates success; otherwise an
error occurred.
<BR><BR>The following example will flush the contents of the internal input/output buffer for unit 7.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INCLUDE 'FSUBLIB.FI'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER ISTAT</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ISTAT = FLUSHUNIT( 7 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( ISTAT .NE. 0 )THEN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'Error in FLUSHUNIT'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END IF</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR><B>Notes:</B>
<OL>
<LI>The FORTRAN include file<TT> fsublib.fi</TT>, located in the<TT> \watcom\src\fortran</TT> directory, contains typing and
calling information for this subprogram.&nbsp; The<TT> \watcom\src\fortran</TT> directory should be included in the<B> FINCLUDE</B>
environment variable so that the compiler can locate the include file.
</OL>
<H2 ID="INTEGER_Function_FNEXTRECL"> INTEGER Function FNEXTRECL </H2>
<BR>The INTEGER function<TT> FNEXTRECL</TT> reports the record length of the next unformatted record to be read sequentially
from the specified unit.
<BR><BR>The function<TT> FNEXTRECL</TT> requires one argument, the unit number, of type INTEGER.&nbsp; It returns an INTEGER
value representing the size of the next record to be read.
<BR><BR>The following example creates an unformatted file and then reads the records in the file sequentially.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INCLUDE 'FSUBLIB.FI'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*80 INPUT</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPEN(UNIT=2, FILE='UNFORM.TXT', FORM='UNFORMATTED',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp; ACCESS='SEQUENTIAL' )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WRITE( UNIT=2 ) 'A somewhat longish first record'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WRITE( UNIT=2 ) 'A short second record'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WRITE( UNIT=2 ) 'A very, very much longer third record'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CLOSE( UNIT=2 )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPEN(UNIT=2, FILE='UNFORM.TXT', FORM='UNFORMATTED',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp; ACCESS='SEQUENTIAL' )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I = FNEXTRECL( 2 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'Record length=', I</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ( UNIT=2 ) INPUT(1:I)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, INPUT(1:I)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I = FNEXTRECL( 2 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'Record length=', I</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ( UNIT=2 ) INPUT(1:I)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, INPUT(1:I)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I = FNEXTRECL( 2 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'Record length=', I</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ( UNIT=2 ) INPUT(1:I)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, INPUT(1:I)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CLOSE( UNIT=2 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR><B>Notes:</B>
<OL>
<LI>The FORTRAN include file<TT> fsublib.fi</TT>, located in the<TT> \watcom\src\fortran</TT> directory, contains typing and
calling information for this subprogram.&nbsp; The<TT> \watcom\src\fortran</TT> directory should be included in the<B> FINCLUDE</B>
environment variable so that the compiler can locate the include file.
</OL>
<H2 ID="INTEGER_Function_FSIGNAL"> INTEGER Function FSIGNAL </H2>
<BR>The INTEGER function<TT> FSIGNAL</TT> allows your application to respond to certain events that occur during execution.
<DL>
<DT><B><I>Event</I></B>
<DD><B><I>Meaning</I></B>
<DT>SIGBREAK
<DD>an interactive attention (Ctrl/Break on keyboard) is signalled
<DT>SIGFPE
<DD>an erroneous floating-point operation occurs (such as division by zero, overflow and underflow)
<DT>SIGILL
<DD>illegal instruction encountered
<DT>SIGINT
<DD>an interactive attention (Ctrl/C on keyboard) is signalled
<DT>SIGSEGV
<DD>an illegal memory reference is detected
<DT>SIGTERM
<DD>a termination request is sent to the program
<DT>SIGIDIVZ
<DD>integer division by zero
<DT>SIGIOVFL
<DD>integer overflow
</DL>
<BR>The function<TT> FSIGNAL</TT> requires two arguments.&nbsp; The first argument is an INTEGER argument and must be one
of the events described above.&nbsp; The second argument, called the handler, is one of the following.
<OL>
<LI>a subprogram that is called when the event occurs
<LI>the value SIG_DFL, causing the default action to be taken when the event occurs
<LI>the value SIG_IGN, causing the event to be ignored
</OL>
<BR><TT>FSIGNAL</TT> returns SIG_ERR if the request could not be processed, or the previous event handler.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INCLUDE 'FSIGNAL.FI'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EXTERNAL BREAK_HANDLER</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOGICAL BREAK_FLAG</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; COMMON BREAK_FLAG</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BREAK_FLAG = .FALSE.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALL FSIGNAL( SIGBREAK, BREAK_HANDLER )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WHILE( .NOT. VOLATILE( BREAK_FLAG ) ) CONTINUE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'Program Interrupted'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SUBROUTINE BREAK_HANDLER()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOGICAL BREAK_FLAG</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; COMMON BREAK_FLAG</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BREAK_FLAG = .TRUE.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR><B>Notes:</B>
<OL>
<LI>The FORTRAN include file<TT> fsignal.fi</TT> contains typing and calling information for<TT> FSIGNAL</TT> and should be
included when using this function.&nbsp; This file is located in the<TT> \watcom\src\fortran</TT> directory.&nbsp; The<TT>
\watcom\src\fortran</TT> directory should be included in the<B> FINCLUDE</B> environment variable so that the compiler can
locate the include file.
<LI>The intrinsic function<TT> VOLATILE</TT> is used to indicate that the reference to the variable<TT> break_flag</TT> is
volatile.&nbsp; A volatile reference prevents the compiler from caching a variable in a register.&nbsp; In this case, we want
to retrieve the value of<TT> break_flag</TT> from memory each time the loop is iterated.
</OL>
<H2 ID="INTEGER_Function_FSPAWN"> INTEGER Function FSPAWN </H2>
<BR>The INTEGER function<TT> FSPAWN</TT> allows an application to run another program as a subprocess.&nbsp; When the program
completes, execution is returned to the invoking application.&nbsp; There must be enough available free memory to start the
subprocess.
<BR><BR>The function<TT> FSPAWN</TT> requires two arguments of type CHARACTER.&nbsp; The first argument is a character string
representing the name of the program to be run.&nbsp; The string must end in a NULL character (i.e., a character with the
binary value 0).
<BR><BR>The second argument is a character string argument list to be passed to the program.&nbsp; The first character of
the second argument must contain, in binary, the length of the remainder of the argument list.&nbsp; For example, if the argument
is the string &quot;HELLO&quot; then the first character would be CHAR(5) and the remaining characters would be &quot;HELLO&quot;
(see the example below).
<BR><BR><TT>FSPAWN</TT> returns an INTEGER value representing the status of subprocess execution.&nbsp; If the value is negative
then the program could not be run.&nbsp; If the value is positive then the value represents the program's return code.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INCLUDE 'FSUBLIB.FI'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER CMDLEN, STATUS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER CMD*128, CMDLIN*128</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * COMSPEC will tell us where DOS 'COMMAND.COM' is hiding</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CMDLEN = FGETENV( 'COMSPEC', CMD )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CMD(CMDLEN+1:CMDLEN+1) = CHAR( 0 )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CMDLIN = '/c dir *.for'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CMDLIN(13:13) = CHAR( 0 )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STATUS = FSPAWN( CMD, CMDLIN )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'Program status = ', STATUS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR><B>Notes:</B>
<OL>
<LI>The FORTRAN include file<TT> fsublib.fi</TT>, located in the<TT> \watcom\src\fortran</TT> directory, contains typing and
calling information for this subprogram.&nbsp; The<TT> \watcom\src\fortran</TT> directory should be included in the<B> FINCLUDE</B>
environment variable so that the compiler can locate the include file.
<LI>The INTEGER function<TT> FSYSTEM,</TT> which is described in a later section, implements a more general form of the example
given above.&nbsp; We recommend its use.
</OL>
<H2 ID="INTEGER_Function_FSYSTEM"> INTEGER Function FSYSTEM </H2>
<BR>The INTEGER function<TT> FSYSTEM</TT> allows an application to run another program or execute an operating system command.
<BR><BR>The function<TT> FSYSTEM</TT> requires one argument of type CHARACTER.&nbsp; This argument represents a operating
system command or a program name together with any arguments.<TT>&nbsp; FSYSTEM</TT> returns an INTEGER value representing
the status of subprocess execution.&nbsp; If the value is negative, the operating system command interpreter or shell could
not be run (an attempt is made to invoke the system command interpreter to run the program).&nbsp; If the value is positive,
the value represents the program's return code.
<BR><BR>In the following example, a &quot;COPY&quot; command is executed and then a hypothetical sorting program is run.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INCLUDE 'FSUBLIB.FI'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER STATUS</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STATUS = FSYSTEM( 'COPY *.FOR \BACKUP\FOR\SRC' )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'Status of COPY command = ', STATUS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STATUS = FSYSTEM( 'SORTFILE/IN=INP.DAT/OUT=OUT.DAT' )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'Status of SORT program = ', STATUS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR><B>Notes:</B>
<OL>
<LI>The FORTRAN include file<TT> fsublib.fi</TT>, located in the<TT> \watcom\src\fortran</TT> directory, contains typing and
calling information for this subprogram.&nbsp; The<TT> \watcom\src\fortran</TT> directory should be included in the<B> FINCLUDE</B>
environment variable so that the compiler can locate the include file.
</OL>
<H2 ID="Subroutine_FTRACEBACK"> Subroutine FTRACEBACK </H2>
<BR>The subroutine<TT> FTRACEBACK</TT> allows your application to generate a run-time traceback.&nbsp; The application must
be compiled with the &quot;DEBUG&quot; or &quot;TRACE&quot; option.&nbsp; It is useful when you wish to disclose a problem
in an application and provide an informative report of where the problem occurred in the application.
<BR><BR>The<TT> FTRACEBACK</TT> subroutine requires no arguments.&nbsp; The<TT> FTRACEBACK</TT> subroutine does not terminate
program execution.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SUBROUTINE READREC( UN )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INCLUDE 'FSUBLIB.FI'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER UN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER RLEN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*35 INPUT</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RLEN = FNEXTRECL( UN )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( RLEN .GT. 35 )THEN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'Error: Record too long', RLEN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALL FTRACEBACK</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STOP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ELSE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'Record length=', RLEN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ( UNIT=UN ) INPUT(1:RLEN)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, INPUT(1:RLEN)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDIF</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR><B>Notes:</B>
<OL>
<LI>The FORTRAN include file<TT> fsublib.fi</TT>, located in the<TT> \watcom\src\fortran</TT> directory, contains typing and
calling information for this subprogram.&nbsp; The<TT> \watcom\src\fortran</TT> directory should be included in the<B> FINCLUDE</B>
environment variable so that the compiler can locate the include file.
</OL>
<H2 ID="Subroutine_GETDAT"> Subroutine GETDAT </H2>
<BR>The subroutine<TT> GETDAT</TT> allows an application to obtain the current date.
<BR><BR>The subroutine<TT> GETDAT</TT> has three arguments of type<TT> INTEGER*2.</TT>&nbsp; When control is returned from<TT>
GETDAT,</TT> they contain the year, month and day of the current date.
<BR><BR>The following program prints the current date in the form &quot;YY-MM-DD&quot;.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INCLUDE 'FSUBLIB.FI'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER*2 YEAR, MONTH, DAY</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALL GETDAT( YEAR, MONTH, DAY )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT 100, YEAR, MONTH, DAY</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 100&nbsp;&nbsp; FORMAT( 1X, I4, '-', I2.2, '-', I2.2 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR><B>Notes:</B>
<OL>
<LI>The FORTRAN include file<TT> fsublib.fi</TT>, located in the<TT> \watcom\src\fortran</TT> directory, contains typing and
calling information for this subprogram.&nbsp; The<TT> \watcom\src\fortran</TT> directory should be included in the<B> FINCLUDE</B>
environment variable so that the compiler can locate the include file.
<LI>The arguments to<TT> GETDAT</TT> must be of type INTEGER*2 in order to obtain correct results.
</OL>
<H2 ID="Subroutine_GETTIM"> Subroutine GETTIM </H2>
<BR>The subroutine<TT> GETTIM</TT> allows an application to obtain the current time.
<BR><BR>The subroutine<TT> GETTIM</TT> has four arguments of type<TT> INTEGER*2.</TT>&nbsp; When control is returned from<TT>
GETTIM,</TT> they contain the hours, minutes, seconds, and hundredths of seconds of the current time.
<BR><BR>The following program prints the current time in the form &quot;HH:MM:SS.TT&quot;.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INCLUDE 'FSUBLIB.FI'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER*2 HRS, MINS, SECS, HSECS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALL GETTIM( HRS, MINS, SECS, HSECS )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT 100, HRS, MINS, SECS, HSECS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 100&nbsp;&nbsp; FORMAT( 1X, I2.2, ':', I2.2, ':', I2.2, '.', I2.2 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR><B>Notes:</B>
<OL>
<LI>The FORTRAN include file<TT> fsublib.fi</TT>, located in the<TT> \watcom\src\fortran</TT> directory, contains typing and
calling information for this subprogram.&nbsp; The<TT> \watcom\src\fortran</TT> directory should be included in the<B> FINCLUDE</B>
environment variable so that the compiler can locate the include file.
<LI>The arguments to<TT> GETTIM</TT> must be of type INTEGER*2 in order to obtain correct results.
</OL>
<H2 ID="INTEGER_Function_GROWHANDLES"> INTEGER Function GROWHANDLES </H2>
<BR>The INTEGER function<TT> GROWHANDLES</TT> allows an application to increase the maximum number of files that can be opened.
&nbsp;It requires one argument of type INTEGER representing the maximum number of files that can be opened and returns an
INTEGER value representing the actual limit.&nbsp; The actual limit may differ from the specified limit.&nbsp; For example,
memory constraints or system parameters may be such that the request cannot be satisfied.
<BR><BR>The following example attempts to increase the limit on the number of open files to sixty-four.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INCLUDE 'FSUBLIB.FI'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER NEW_LIMIT</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NEW_LIMIT = GROWHANDLES( 64 )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR><B>Notes:</B>
<OL>
<LI>The FORTRAN include file<TT> fsublib.fi</TT>, located in the<TT> \watcom\src\fortran</TT> directory, contains typing and
calling information for this subprogram.&nbsp; The<TT> \watcom\src\fortran</TT> directory should be included in the<B> FINCLUDE</B>
environment variable so that the compiler can locate the include file.
</OL>
<H2 ID="Functions_IARGC_and_IGETARG"> Functions IARGC and IGETARG </H2>
<BR>The function<TT> IARGC</TT> allows an application to determine the number of arguments (including the program name) used
to invoke the program.&nbsp; The function<TT> IGETARG</TT> can be used to retrieve an argument.
<BR><BR>Arguments supplied to a program are assigned indices.&nbsp; Argument zero is the program name, argument one is the
first argument, etc.&nbsp; The function<TT> IGETARG</TT> requires two arguments.&nbsp; The first argument is the index of
the argument to retrieve and is of type INTEGER.&nbsp; The second argument is of type CHARACTER and is used to return the
argument.&nbsp; The size of the argument (number of characters) is returned.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INCLUDE 'FSUBLIB.FI'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*128 ARG</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER ARGC, ARGLEN</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARGC = IARGC()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARGLEN = IGETARG( 0, ARG )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'Program name is ', ARG(1:ARGLEN)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO I = 1, ARGC - 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARGLEN = IGETARG( I, ARG )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT '(A, I2, 2A)', 'Argument
', I, ' is ',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARG(1:ARGLEN)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END DO</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR><B>Notes:</B>
<OL>
<LI>The FORTRAN include file<TT> fsublib.fi</TT>, located in the<TT> \watcom\src\fortran</TT> directory, contains typing and
calling information for this subprogram.&nbsp; The<TT> \watcom\src\fortran</TT> directory should be included in the<B> FINCLUDE</B>
environment variable so that the compiler can locate the include file.
</OL>
<H2 ID="Math_Error_Functions"> Math Error Functions </H2>
<BR>Math error functions are called when an error is detected in a math library function.&nbsp; For example, if the second
argument to the<TT> AMOD</TT> intrinsic function is zero, a math error function will be called.&nbsp; A number of math error
functions are defined in the FORTRAN run-time libraries and perform default actions when an error is detected.&nbsp; These
actions typically produce an error message to the screen.
<BR><BR>It is possible to replace the FORTRAN run-time library version of the math error functions with your own versions.
&nbsp;The file<TT> _matherr.for</TT> located in the<TT> \watcom\src\fortran</TT> directory can be used as a template for defining
your own math error functions.&nbsp; The following functions represent the set of math error functions.
<OL>
<LI>The function<TT> __imath2err</TT> is called for math functions of type INTEGER that take two arguments of type INTEGER.
&nbsp;The first argument represents the error information and is an argument of type INTEGER that is passed by value.&nbsp;
The second argument is a pointer to the first argument passed to the math function and the third argument is a pointer to
the second argument passed to the math function.&nbsp; The error function returns a value that is then used as the return
value for the math function.
<LI>The function<TT> __amath1err</TT> is called for math functions of type REAL that take one argument of type REAL.&nbsp;
The first argument represents the error information and is an argument of type INTEGER that is passed by value.&nbsp; The
second argument is a pointer to the argument passed to the math function.&nbsp; The error function returns a value that is
then used as the return value for the math function.
<LI>The function<TT> __amath2err</TT> is called for math functions of type REAL that take two arguments of type REAL.&nbsp;
The first argument represents the error information and is an argument of type INTEGER that is passed by value.&nbsp; The
second argument is a pointer to the first argument passed to the math function and the third argument is a pointer to the
second argument passed to the math function.&nbsp; The error function returns a value that is then used as the return value
for the math function.
<LI>The function<TT> __math1err</TT> is called for math functions of type DOUBLE PRECISION that take one argument of type
DOUBLE PRECISION.&nbsp; The first argument represents the error information and is an argument of type INTEGER that is passed
by value.&nbsp; The second argument is a pointer to the argument passed to the math function.&nbsp; The error function returns
a value that is then used as the return value for the math function.
<LI>The function<TT> __math2err</TT> is called for math functions of type DOUBLE PRECISION that take two arguments of type
DOUBLE PRECISION.&nbsp; The first argument represents the error information and is an argument of type INTEGER that is passed
by value.&nbsp; The second argument is a pointer to the first argument passed to the math function and the third argument
is a pointer to the second argument passed to the math function.&nbsp; The error function returns a value that is then used
as the return value for the math function.
<LI>The function<TT> __zmath2err</TT> is called for math functions of type COMPLEX that take two arguments of type COMPLEX.
&nbsp;The first argument represents the error information and is an argument of type INTEGER that is passed by value.&nbsp;
The second argument is a pointer to the first argument passed to the math function and the third argument is a pointer to
the second argument passed to the math function.&nbsp; The error function returns a value that is then used as the return
value for the math function.
<LI>The function<TT> __qmath2err</TT> is called for math functions of type DOUBLE COMPLEX that take two arguments of type
DOUBLE COMPLEX.&nbsp; The first argument represents the error information and is an argument of type INTEGER that is passed
by value.&nbsp; The second argument is a pointer to the first argument passed to the math function and the third argument
is a pointer to the second argument passed to the math function.&nbsp; The error function returns a value that is then used
as the return value for the math function.
</OL>
<BR>The include file<TT> mathcode.fi</TT> is included by the file<TT> _matherr.for</TT> and is located in the<TT> \watcom\src\fortran</TT>
directory.&nbsp; It defines the information that is contained in the error information argument that is passed to all math
error functions.
<H2 ID="INTEGER_Function_SEEKUNIT"> INTEGER Function SEEKUNIT </H2>
<BR>The INTEGER function<TT> SEEKUNIT</TT> permits seeking to a particular byte offset within a file connected to a FORTRAN
unit.&nbsp; The file must be opened with the following attributes:
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp; FORM='UNFORMATTED'
<BR>&nbsp;&nbsp;&nbsp;&nbsp; ACCESS='SEQUENTIAL'
<BR>&nbsp;&nbsp;&nbsp;&nbsp; RECORDTYPE='FIXED'
<BR><BR>The function<TT> SEEKUNIT</TT> requires three arguments of type INTEGER, the unit number, the offset to seek, and
the type of positioning to do.&nbsp; The seek positioning may be absolute (indicated by 0) or relative to the current position
(indicated by 1).&nbsp; It returns an INTEGER value representing the new offset in the file.&nbsp; A returned value of -1
indicates that the function call failed.
<BR><BR>This function is particularly useful for applications that wish to change the input/output position for a file connected
to a unit.
<BR><BR>The following example will set the current input/output position of the file connected to the specified unit.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EXTERNAL SEEKUNIT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER SEEKUNIT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER SEEK_SET, SEEK_CUR</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PARAMETER (SEEK_SET=0, SEEK_CUR=1)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER POSITION</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*80 RECORD</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPEN( UNIT=8, FILE='file', FORM='UNFORMATTED',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ACCESS='SEQUENTIAL',
RECORDTYPE='FIXED' )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; POSITION = SEEKUNIT( 8, 10, SEEK_SET )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( POSITION .NE. -1 )THEN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'New position is', POSITION</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ( UNIT=8 ) RECORD</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, RECORD</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDIF</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR><B>Notes:</B>
<OL>
<LI>The FORTRAN include file<TT> fsublib.fi</TT>, located in the<TT> \watcom\src\fortran</TT> directory, contains typing and
calling information for this subprogram.&nbsp; The<TT> \watcom\src\fortran</TT> directory should be included in the<B> FINCLUDE</B>
environment variable so that the compiler can locate the include file.
<LI>A value of -1 is returned if the requested positioning cannot be done.
</OL>
<H2 ID="INTEGER_Function_SETJMPDSubroutine_LONGJMP"> INTEGER Function SETJMP/Subroutine LONGJMP </H2>
<BR>The INTEGER function<TT> SETJMP</TT> saves the current executing environment, making it possible to restore that environment
by subsequently calling the<TT> LONGJMP</TT> subroutine.&nbsp; For example, it is possible to implement error handling by
using<TT> SETJMP</TT> to record the point to which a return will occur following an error.&nbsp; When an error is detected
in a called subprogram, that subprogram uses<TT> LONGJMP</TT> to jump back to the recorded position.&nbsp; The original subprogram
which called<TT> SETJMP</TT> must still be active (it cannot have returned to the subprogram which called it).
<BR><BR>The<TT> SETJMP</TT> function requires one argument.&nbsp; The argument is a structure of type<TT> jmp_buf</TT> and
is used to save the current environment.&nbsp; The return value is an integer and is zero when initially called.&nbsp; It
is non-zero if the return is the result of a call to the<TT> LONGJMP</TT> subroutine.&nbsp; An<B><I> IF</I></B> statement
is often used to handle these two cases.&nbsp; This is demonstrated in the following example.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'fsignal.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'setjmp.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /jmp_buf/ jmp_buf</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; common jmp_buf</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; external break_handler</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer rc</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call fsignal( SIGBREAK, break_handler )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc = setjmp( jmp_buf )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( rc .eq. 0 )then</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call do_it()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, 'abnormal termination:',
rc</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endif</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subroutine do_it()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; loop</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end loop</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subroutine break_handler()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'setjmp.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /jmp_buf/ jmp_buf</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; common jmp_buf</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call longjmp( jmp_buf, -1 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR><B>Notes:</B>
<OL>
<LI>The FORTRAN include file<TT> setjmp.fi</TT> contains typing and calling information for<TT> SETJMP</TT> and<TT> LONGJMP</TT>
and must be included.&nbsp; Similarly,<TT> fsignal.fi</TT> must be included when using the<TT> FSIGNAL</TT> function.&nbsp;
These files are located in the<TT> \watcom\src\fortran</TT> directory.&nbsp; The<TT> \watcom\src\fortran</TT> directory should
be included in the<B> FINCLUDE</B> environment variable so that the compiler can locate these include files.
</OL>
<H2 ID="INTEGER_Function_SETSYSHANDLE"> INTEGER Function SETSYSHANDLE </H2>
<BR>The INTEGER function<TT> SETSYSHANDLE</TT> allows an application to set the system file handle for a specified unit.
<BR><BR>The function<TT> SETSYSHANDLE</TT> requires an argument of type INTEGER, the unit number, and an argument of type
INTEGER*2, the handle, and returns an INTEGER value representing the success or fail status of the function call.&nbsp; A
returned value of -1 indicates that the function call failed and 0 indicates that the function call succeeded.
<BR><BR>This function is particularly useful for applications that wish to set the system file handle for a unit.&nbsp; The
system file handle may have been obtained from a non-FORTRAN subroutine or function.
<BR><BR>The following example will set the system file handle for a paricular unit.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INCLUDE 'FSUBLIB.FI'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER STDIN, STDOUT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PARAMETER (STDIN=0, STDOUT=1)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPEN( UNIT=8, FORM='FORMATTED' )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I = SYSHANDLE( 8 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'Old handle was', I</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I = SETSYSHANDLE( 8, STDOUT )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( I .EQ. 0 )THEN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WRITE( UNIT=8, FMT=* ) 'Output
to UNIT 8 which is stdout'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDIF</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR><B>Notes:</B>
<OL>
<LI>The FORTRAN include file<TT> fsublib.fi</TT>, located in the<TT> \watcom\src\fortran</TT> directory, contains typing and
calling information for this subprogram.&nbsp; The<TT> \watcom\src\fortran</TT> directory should be included in the<B> FINCLUDE</B>
environment variable so that the compiler can locate the include file.
<LI>A value of -1 is returned if the unit is not connected to a file.
<LI>Units 5 and 6 are preconnected to the standard input and standard output devices respectively.
</OL>
<H2 ID="INTEGERT2_Function_SYSHANDLE"> INTEGER*2 Function SYSHANDLE </H2>
<BR>The INTEGER*2 function<TT> SYSHANDLE</TT> allows an application to obtain the system file handle for a specified unit.
<BR><BR>The function<TT> SYSHANDLE</TT> requires one argument of type INTEGER, the unit number.&nbsp; and returns an INTEGER*2
value representing the system file handle.
<BR><BR>This function is particularly useful for applications that wish to pass the system file handle to non-FORTRAN subroutines
or functions that wish to perform input/output to a FORTRAN 77 file.
<BR><BR>The following example will print the system file handles for the standard input and standard output devices.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INCLUDE 'FSUBLIB.FI'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'Unit 5 file handle is', SYSHANDLE( 5 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'Unit 6 file handle is', SYSHANDLE( 6 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR><B>Notes:</B>
<OL>
<LI>The FORTRAN include file<TT> fsublib.fi</TT>, located in the<TT> \watcom\src\fortran</TT> directory, contains typing and
calling information for this subprogram.&nbsp; The<TT> \watcom\src\fortran</TT> directory should be included in the<B> FINCLUDE</B>
environment variable so that the compiler can locate the include file.
<LI>A value of -1 is returned if the unit is not connected to a file.
<LI>Units 5 and 6 are preconnected to the standard input and standard output devices respectively.
</OL>
<H2 ID="REAL_Function_URAND"> REAL Function URAND </H2>
<BR>The REAL function<TT> URAND</TT> returns pseudo-random numbers in the range (0,1).
<BR><BR>The function<TT> URAND</TT> requires one argument of type INTEGER, the initial seed.&nbsp; The seed can contain any
integer value.<TT>&nbsp; URAND</TT> returns a REAL value which is a pseudo-random number in the range (0.0,1.0).
<BR><BR>In the following example, 100 random numbers are printed.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REAL URAND</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER SEED</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SEED = 75347</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO I = 1, 100</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, URAND( SEED )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDDO</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR><B>Notes:</B>
<OL>
<LI>Upon each invocation of<TT> URAND,</TT> the seed argument is updated by the random number generator.&nbsp; Therefore,
the argument must not be a constant and, once the seed value has been set, it must<B> not</B> be modified by the programmer.
</OL>
<H2 ID="Default_Windowing_Functions"> Default Windowing Functions </H2>
<BR>The functions described in the following sections provide the capability to manipulate attributes of various windows created
by Open Watcom's default windowing system for Microsoft Windows 3.x, Windows 95, Windows NT, and IBM OS/2.&nbsp; A simple
default windowing FORTRAN application can be built using the following command(s):
<DL>
<DT>16-bit Windows
<DD><TT> C&gt;wfl [fn1] [fn2] ...&nbsp; /bw /windows /l=windows</TT>
<DT>32-bit Windows
<DD><TT> C&gt;wfl386 [fn1] [fn2] ...&nbsp; /bw /l=win386</TT>
<BR><BR><TT>C&gt;wbind -n [fn1]</TT>
<DT>32-bit Windows NT or Windows 95
<DD><TT> C&gt;wfl386 [fn1] [fn2] ...&nbsp; /bw /l=nt_win</TT>
<DT>32-bit OS/2 Presentation Manager
<DD><TT> C&gt;wfl386 [fn1] [fn2] ...&nbsp; /bw /l=os2v2_pm</TT>
</DL>
<DL>
<DT>Note:
<DD>At present, a restriction in Windows NT prevents you from opening the console device (CON) for both read and write access.
&nbsp;Therefore, it is not possible to open additional windows for both input and output under Windows NT.&nbsp; They must
be either read-only or write-only windows.
</DL>
<H3 ID="dwfDeleteOnClose"> dwfDeleteOnClose </H3>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; integer function dwfDeleteOnClose( unit )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; integer unit</TT>
<BR><BR>The dwfDeleteOnClose function tells the console window that it should close itself when the corresponding file is
closed.&nbsp; The argument<TT> unit</TT> is the unit number associated with the opened console.
<BR><BR>This function is one of the support functions that can be called from an application using Open Watcom's default windowing
support.
<BR><BR>The dwfDeleteOnClose function returns 1 if it was successful and 0 if not.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PROGRAM main</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INCLUDE 'FSUBLIB.FI'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER rc</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER response</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc = dwfSetAboutDlg( 'Hello World About Dialog',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'About Hello World'//CHAR(13)//</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'Copyright 1994 by WATCOM'//CHAR(13) )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc = dwfSetAppTitle( 'Hello World Application Title'
)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc = dwfSetConTitle( 5, 'Hello World Console Title' )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'Hello World'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPEN( unit=3, file='CON' )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc = dwfSetConTitle( 3, 'Hello World Second Console Title'
)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc = dwfDeleteOnClose( 3 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WRITE( unit=3, fmt=* ) 'Hello to second console'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WRITE( unit=3, fmt=* ) 'Press Enter to close this console'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ( unit=3, fmt='(A)', end=100, err=100 ) response</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 100&nbsp;&nbsp; CLOSE( unit=3 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<H3 ID="dwfSetAboutDlg"> dwfSetAboutDlg </H3>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; integer function dwfSetAboutDlg( title, text )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; character*(*) title</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; character*(*) text</TT>
<BR><BR>The dwfSetAboutDlg function sets the &quot;About&quot; dialog box of the default windowing system.&nbsp; The argument<TT>
title</TT> is a character string that will replace the current title.&nbsp; If<TT> title</TT> is CHAR(0) then the title will
not be replaced.&nbsp; The argument<TT> text</TT> is a character string which will be placed in the &quot;About&quot; box.
&nbsp;To get multiple lines, embed a new line character (CHAR(13)) after each logical line in the string.&nbsp; If<TT> text</TT>
is CHAR(0), then the current text in the &quot;About&quot; box will not be replaced.
<BR><BR>This function is one of the support functions that can be called from an application using Open Watcom's default windowing
support.
<BR><BR>The dwfSetAboutDlg function returns 1 if it was successful and 0 if not.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PROGRAM main</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INCLUDE 'FSUBLIB.FI'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER rc</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER response</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc = dwfSetAboutDlg( 'Hello World About Dialog',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'About Hello World'//CHAR(13)//</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'Copyright 1994 by WATCOM'//CHAR(13) )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc = dwfSetAppTitle( 'Hello World Application Title'
)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc = dwfSetConTitle( 5, 'Hello World Console Title' )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'Hello World'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPEN( unit=3, file='CON' )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc = dwfSetConTitle( 3, 'Hello World Second Console Title'
)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc = dwfDeleteOnClose( 3 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WRITE( unit=3, fmt=* ) 'Hello to second console'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WRITE( unit=3, fmt=* ) 'Press Enter to close this console'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ( unit=3, fmt='(A)', end=100, err=100 ) response</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 100&nbsp;&nbsp; CLOSE( unit=3 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<H3 ID="dwfSetAppTitle"> dwfSetAppTitle </H3>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; integer function dwfSetAppTitle( title )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; character*(*) title</TT>
<BR><BR>The dwfSetAppTitle function sets the main window's title.&nbsp; The argument<TT> title</TT> is a character string
that will replace the current title.
<BR><BR>This function is one of the support functions that can be called from an application using Open Watcom's default windowing
support.
<BR><BR>The dwfSetAppTitle function returns 1 if it was successful and 0 if not.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PROGRAM main</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INCLUDE 'FSUBLIB.FI'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER rc</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER response</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc = dwfSetAboutDlg( 'Hello World About Dialog',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'About Hello World'//CHAR(13)//</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'Copyright 1994 by WATCOM'//CHAR(13) )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc = dwfSetAppTitle( 'Hello World Application Title'
)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc = dwfSetConTitle( 5, 'Hello World Console Title' )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'Hello World'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPEN( unit=3, file='CON' )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc = dwfSetConTitle( 3, 'Hello World Second Console Title'
)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc = dwfDeleteOnClose( 3 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WRITE( unit=3, fmt=* ) 'Hello to second console'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WRITE( unit=3, fmt=* ) 'Press Enter to close this console'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ( unit=3, fmt='(A)', end=100, err=100 ) response</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 100&nbsp;&nbsp; CLOSE( unit=3 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<H3 ID="dwfSetConTitle"> dwfSetConTitle </H3>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; integer function dwfSetConTitle( unit, title )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; integer unit</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; character*(*) title</TT>
<BR><BR>The dwfSetConTitle function sets the console window's title which corresponds to the unit number passed to it.&nbsp;
The argument<TT> unit</TT> is the unit number associated with the opened console.&nbsp; The argument<TT> title</TT> is the
character string that will replace the current title.
<BR><BR>This function is one of the support functions that can be called from an application using Open Watcom's default windowing
support.
<BR><BR>The dwfSetConTitle function returns 1 if it was successful and 0 if not.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PROGRAM main</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INCLUDE 'FSUBLIB.FI'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER rc</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER response</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc = dwfSetAboutDlg( 'Hello World About Dialog',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'About Hello World'//CHAR(13)//</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'Copyright 1994 by WATCOM'//CHAR(13) )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc = dwfSetAppTitle( 'Hello World Application Title'
)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc = dwfSetConTitle( 5, 'Hello World Console Title' )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'Hello World'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPEN( unit=3, file='CON' )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc = dwfSetConTitle( 3, 'Hello World Second Console Title'
)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc = dwfDeleteOnClose( 3 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WRITE( unit=3, fmt=* ) 'Hello to second console'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WRITE( unit=3, fmt=* ) 'Press Enter to close this console'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ( unit=3, fmt='(A)', end=100, err=100 ) response</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 100&nbsp;&nbsp; CLOSE( unit=3 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<H3 ID="dwfShutDown"> dwfShutDown </H3>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; integer function dwfShutDown()</TT>
<BR><BR>The dwfShutDown function shuts down the default windowing I/O system.&nbsp; The application will continue to execute
but no windows will be available for output.&nbsp; Care should be exercised when using this function since any subsequent
output may cause unpredictable results.
<BR><BR>When the application terminates, it will not be necessary to manually close the main window.
<BR><BR>This function is one of the support functions that can be called from an application using Open Watcom's default windowing
support.
<BR><BR>The dwfShutDown function returns 1 if it was successful and 0 if not.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PROGRAM main</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INCLUDE 'FSUBLIB.FI'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER rc</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER response</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc = dwfSetAboutDlg( 'Hello World About Dialog',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'About Hello World'//CHAR(13)//</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'Copyright 1994 by WATCOM'//CHAR(13) )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc = dwfSetAppTitle( 'Hello World Application Title'
)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc = dwfSetConTitle( 5, 'Hello World Console Title' )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'Hello World'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPEN( unit=3, file='CON' )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc = dwfSetConTitle( 3, 'Hello World Second Console Title'
)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc = dwfDeleteOnClose( 3 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WRITE( unit=3, fmt=* ) 'Hello to second console'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WRITE( unit=3, fmt=* ) 'Press Enter to close this console'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ( unit=3, fmt='(A)', end=100, err=100 ) response</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 100&nbsp;&nbsp; CLOSE( unit=3 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc = dwfShutDown()</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp; do more computing that does not involve console input/output</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<H3 ID="dwfYield"> dwfYield </H3>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; integer function dwf veld()</TT>
<BR><BR>The dwfYield function yields control back to the operating system, thereby giving other processes a chance to run.
<BR><BR>This function is one of the support functions that can be called from an application using Open Watcom's default windowing
support.
<BR><BR>The dwfYield function returns 1 if it was successful and 0 if not.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PROGRAM main</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INCLUDE 'FSUBLIB.FI'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER rc</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER response</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER i</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc = dwfSetAboutDlg( 'Hello World About Dialog',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'About Hello World'//CHAR(13)//</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'Copyright 1994 by WATCOM'//CHAR(13) )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc = dwfSetAppTitle( 'Hello World Application Title'
)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc = dwfSetConTitle( 5, 'Hello World Console Title' )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'Hello World'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPEN( unit=3, file='CON' )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc = dwfSetConTitle( 3, 'Hello World Second Console Title'
)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc = dwfDeleteOnClose( 3 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WRITE( unit=3, fmt=* ) 'Hello to second console'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WRITE( unit=3, fmt=* ) 'Press Enter to close this console'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ( unit=3, fmt='(A)', end=100, err=100 ) response</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 100&nbsp;&nbsp; CLOSE( unit=3 )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO i = 0, 1000</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc = dwfYield()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do CPU-intensive calculation</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDDO</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, i</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<H1 ID="Data_Representation_On_x86Mbased_Platforms"> Data Representation On x86-based Platforms </H1>
<BR>This chapter describes the internal or machine representation of the basic types supported by Open Watcom F77.&nbsp; The
following table summarizes these data types.
<BR><BR>&nbsp; Data Type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FORTRAN 77&nbsp; 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (in&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR>bytes)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Standard&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><BR>&nbsp; LOGICAL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR>&nbsp; LOGICAL*1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (extension)

<BR>&nbsp; LOGICAL*4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (extension)

<BR>&nbsp; INTEGER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR>&nbsp; INTEGER*1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (extension)

<BR>&nbsp; INTEGER*2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (extension)

<BR>&nbsp; INTEGER*4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (extension)

<BR>&nbsp; REAL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR>&nbsp; REAL*4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;(extension) 
<BR>&nbsp; REAL*8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;(extension) 
<BR>&nbsp; DOUBLE PRECISION&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; 
<BR>&nbsp; COMPLEX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR>&nbsp; COMPLEX*8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (extension)

<BR>&nbsp; COMPLEX*16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16&nbsp;&nbsp;&nbsp;&nbsp; (extension) 
<BR>&nbsp; DOUBLE COMPLEX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16&nbsp;&nbsp;&nbsp;&nbsp; (extension) 
<BR>&nbsp; CHARACTER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR>&nbsp; CHARACTER*n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<H2 ID="LOGICALT1_Data_Type"> LOGICAL*1 Data Type </H2>
<BR><BR>An item of type<B> LOGICAL*1</B> occupies 1 byte of storage.&nbsp; It can only have two values, namely .TRUE.&nbsp;
(a value of 1) and .FALSE.&nbsp; (a value of 0).
<H2 ID="LOGICAL_and_LOGICALT4_Data_Types"> LOGICAL and LOGICAL*4 Data Types </H2>
<BR>An item of type<B> LOGICAL</B> or<B> LOGICAL*4</B> occupies 4 bytes of storage.&nbsp; It can only have two values, namely
.TRUE.&nbsp; (a value of 1) and .FALSE.&nbsp; (a value of 0).
<H2 ID="INTEGERT1_Data_Type"> INTEGER*1 Data Type </H2>
<BR>An item of type<B> INTEGER*1</B> occupies 1 byte of storage.&nbsp; Its value is in the following range.&nbsp; An integer<B>
n</B> can be represented in 1 byte if
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -128 &lt;= n &lt;= 127</TT>
<H2 ID="INTEGERT2_Data_Type"> INTEGER*2 Data Type </H2>
<BR>An item of type<B> INTEGER*2</B> occupies 2 bytes of storage.&nbsp; An integer<B> n</B> can be represented in 2 bytes
if
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -32768 &lt;= n &lt;= 32767</TT>
<H2 ID="INTEGER_and_INTEGERT4_Data_Types"> INTEGER and INTEGER*4 Data Types </H2>
<BR>An item of type<B> INTEGER</B> or<B> INTEGER*4</B> occupies 4 bytes of storage (one numeric storage unit).&nbsp; An integer<B>
n</B> can be represented in 4 bytes if
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -2147483648 &lt;= n &lt;= 2147483647</TT>
<H2 ID="REAL_and_REALT4_Data_Types"> REAL and REAL*4 Data Types </H2>
<BR>An item of type<B> REAL</B> or<B> REAL*4</B> is an approximate representation of a real number and occupies 4 bytes (one
numeric storage unit).&nbsp; If<TT> m</TT> is the magnitude of a real number<TT> x,</TT> then<TT> x</TT> can be approximated
if
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -126&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 128</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp; &lt;= m &lt; 2</TT>
<BR><BR>or in more approximate terms if
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 1.175494e-38 &lt;= m &lt;= 3.402823e38</TT>
<BR><BR>Items of type<B> REAL</B> or<B> REAL*4</B> are represented internally as follows.&nbsp; Note that bytes are stored
in memory with the least significant byte first and the most significant byte last.
<BR><BR> S&nbsp;&nbsp;&nbsp; Biased&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Significand&nbsp;&nbsp;&nbsp;
&nbsp; 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exponent&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><BR> 31&nbsp;&nbsp; 30-23&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 22-0
<DL>
<DT>S
<DD>S = Sign bit (0=positive, 1=negative)
<DT>Exponent
<DD>The exponent bias is 127 (i.e., exponent value 1 represents 2**-126; exponent value 127 represents 2**0; exponent value 254
represents 2**127; etc.).&nbsp; The exponent field is 8 bits long.
<DT>Significand
<DD>The leading bit of the significand is always 1, hence it is not stored in the significand field.&nbsp; Thus the significand
is always &quot;normalized&quot;.&nbsp; The significand field is 23 bits long.
<DT>Zero
<DD>A real zero quantity occurs when the sign bit, exponent, and significand are all zero.
<DT>Infinity
<DD>When the exponent field is all 1 bits and the significand field is all zero bits then the quantity represents positive or
negative infinity, depending on the sign bit.
<DT>Not Numbers
<DD>When the exponent field is all 1 bits and the significand field is non-zero then the quantity is a special value called a
NAN (Not-A-Number).
<BR><BR>When the exponent field is all 0 bits and the significand field is non-zero then the quantity is a special value called
a &quot;denormal&quot; or nonnormal number.
</DL>
<H2 ID="DOUBLE_PRECISION_and_REALT8_Data_Types"> DOUBLE PRECISION and REAL*8 Data Types </H2>
<BR>An item of type<B> DOUBLE PRECISION</B> or<B> REAL*8</B> is an approximate representation of a real number, occupies 8
bytes (two numeric storage units) and has precision greater than or equal to that of an item of type<B> REAL</B> or<B> REAL*4</B>.
&nbsp;If<TT> m</TT> is the magnitude of a real number<TT> x,</TT> then<TT> x</TT> can be approximated if
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -1022&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1024</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;= m &lt; 2</TT>
<BR><BR>or in more approximate terms if
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 2.2250738585072e-308 &lt;= m &lt;= 1.79769313486232e308</TT>
<BR><BR>Items of type<B> DOUBLE PRECISION</B> or<B> REAL*8</B> are represented internally as follows.&nbsp; Note that bytes
are stored in memory with the least significant byte first and the most significant byte last.
<BR><BR> S&nbsp;&nbsp;&nbsp; Biased&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; Significand&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exponent&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><BR> 63&nbsp;&nbsp; 62-52&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; 51-0
<DL>
<DT>S
<DD>S = Sign bit (0=positive, 1=negative)
<DT>Exponent
<DD>The exponent bias is 1023 (i.e., exponent value 1 represents 2**-1022; exponent value 1023 represents 2**0; exponent value
2046 represents 2**1023; etc.).&nbsp; The exponent field is 11 bits long.
<DT>Significand
<DD>The leading bit of the significand is always 1, hence it is not stored in the significand field.&nbsp; Thus the significand
is always &quot;normalized&quot;.&nbsp; The significand field is 52 bits long.
<DT>Zero
<DD>A double precision zero quantity occurs when the sign bit, exponent, and significand are all zero.
<DT>Infinity
<DD>When the exponent field is all 1 bits and the significand field is all zero bits then the quantity represents positive or
negative infinity, depending on the sign bit.
<DT>Not Numbers
<DD>When the exponent field is all 1 bits and the significand field is non-zero then the quantity is a special value called a
NAN (Not-A-Number).
<BR><BR>When the exponent field is all 0 bits and the significand field is non-zero then the quantity is a special value called
a &quot;denormal&quot; or nonnormal number.
</DL>
<H2 ID="COMPLEX__COMPLEXT8__and_DOUBLE_COMPLEX_Data_Types"> COMPLEX, COMPLEX*8, and DOUBLE COMPLEX Data Types </H2>
<BR>An item of type<B> COMPLEX</B> or<B> COMPLEX*8</B> is an approximate representation of a complex number.&nbsp; The representation
is an ordered pair of real numbers, the first representing the real part of the complex number and the second representing
the imaginary part of the complex number.&nbsp; Each item of type<B> COMPLEX</B> or<B> COMPLEX*8</B> occupies 8 bytes (two
consecutive numeric storage units), the first being the real part and the second the imaginary part.&nbsp; The approximation
of the real and imaginary parts of a complex number is the same degree of approximation used for items of type<B> REAL</B>.
<H2 ID="COMPLEXT16_Data_Type"> COMPLEX*16 Data Type </H2>
<BR>An item of type<B> COMPLEX*16</B> is an approximate representation of a complex number.&nbsp; The representation is an
ordered pair of real numbers, the first representing the real part of the complex number and the second representing the imaginary
part of the complex number.&nbsp; Each item of type<B> COMPLEX*16</B> occupies 16 bytes (four consecutive numeric storage
units), the first two being the real part and the last two the imaginary part.&nbsp; The approximation of the real and imaginary
parts of a complex number is the same degree of approximation used for items of type<B> DOUBLE PRECISION</B>.
<H2 ID="CHARACTER_Data_Type"> CHARACTER Data Type </H2>
<BR>An item of type<B> CHARACTER</B> represents a sequence of characters.&nbsp; Each character occupies 1 byte of storage
(1 character storage unit).&nbsp; The length of an item of type<B> CHARACTER</B> is the number of characters it contains.
&nbsp;Each character is assigned an integer that represents its position.&nbsp; Characters are numbered from 1 to<B> n</B>
starting from the left,<B> n</B> being the number of characters.
<BR><BR>Items of type<B> CHARACTER</B> are represented by a<B> string descriptor.</B>&nbsp; A string descriptor has the following
format.
<BR><BR>&nbsp;&nbsp; Offset
<BR><BR>&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pointer to data
<BR><BR>&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; length of data
<BR><BR>The pointer to the actual data is a 32-bit offset in the default data segment.&nbsp; The length is represented as
a 32-bit unsigned integer.
<H2 ID="Storage_Organization_of_Data_Types"> Storage Organization of Data Types </H2>
<BR>The following illustrates the relative size of the data types in terms of bytes.<B>&nbsp; LOGICAL</B> is equivalent to<B>
LOGICAL*4</B>,<B> INTEGER</B> is equivalent to<B> INTEGER*4</B>,<B> DOUBLE PRECISION</B> is equivalent to<B> REAL*8</B>, and<B>
COMPLEX</B> is equivalent to<B> COMPLEX*8</B>.&nbsp; If the &quot;short&quot; option is used,<B> LOGICAL</B> is equivalent
to<B> LOGICAL*1</B> and<B> INTEGER</B> is equivalent to<B> INTEGER*2</B>.
<BR><BR>Offset&nbsp;&nbsp;&nbsp; 0 1 2 3 4 5 6 7 8 9 10&nbsp; 11&nbsp; 12&nbsp; 13 14&nbsp;&nbsp; 15
<BR><BR>in bytes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><BR>LOGICAL*1&nbsp;&nbsp;&nbsp; 
<BR><BR>LOGICAL*4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><BR>INTEGER*1&nbsp;&nbsp;&nbsp; 
<BR><BR>INTEGER*2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><BR>INTEGER*4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><BR>REAL*4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><BR>REAL*8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; 
<BR><BR>COMPLEX*8&nbsp;&nbsp;&nbsp; real&nbsp;&nbsp; imaginary
<BR><BR>COMPLEX*16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real part&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; imaginary part
<H2 ID="FloatingMpoint_Accuracy_On_x86Mbased_Platforms"> Floating-point Accuracy On x86-based Platforms </H2>
<BR><BR>There are a number of issues surrounding floating-point accuracy, calculations, exceptions, etc.&nbsp; on the x86-based
personal computer platform that we will address in the following sections.&nbsp; Some result from differences in the behaviour
of standard-conforming FORTRAN 77 compilers.&nbsp; Other result from idiosyncrasies of the IEEE Standard 754 floating-point
that is supported on the x86 platform.
<BR><BR>Some FORTRAN 77 compilers extend the precision of single-precision constants in DATA statement initialization lists
when the corresponding variable is double precision.&nbsp; This is permitted by the FORTRAN 77 Standard.&nbsp; Open Watcom
FORTRAN 77, however, does not do this.&nbsp; This is illustrated by the following example.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double precision pi1, pi2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data pi1 /3.141592653589793/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data pi2 /3.141592653589793d0/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write(unit=*,fmt='(1x,z16,1x,f18.15)') pi1, pi1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write(unit=*,fmt='(1x,z16,1x,f18.15)') pi2, pi2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>The output produces two very different results for our pi variables.&nbsp; The variable<TT> PI1</TT> is initialized
with a single precision (i.e., REAL) constant.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 400921FB60000000&nbsp; 3.141592741012573</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 400921FB54442D18&nbsp; 3.141592653589793</TT>
<BR><BR>A single precision datum has 23 bits in the mantissa; a double precision datum has 52 bits in the mantissa.&nbsp;
Hence<TT> PI1</TT> has 29 fewer bits of accuracy in the mantissa (the difference between 52 and 23) since it is initialized
with a single precision constant.&nbsp; You can verify this by examining the hexadecimal output of the two pi's.&nbsp; The
bottom 29 bits of the mantissa in<TT> PI1</TT> are all zero.
<BR><BR>To be on the safe side, the rule is always use double precision constants (even in DATA statements) if you want as
much accuracy as possible.
<BR><BR>This behaviour treats DATA statement initialization as equivalent to simple assignment as shown in the following example.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double precision pi1, pi2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pi1 = 3.141592653589793</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pi2 = 3.141592653589793d0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write(unit=*,fmt='(1x,z16,1x,f18.15)') pi1, pi1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write(unit=*,fmt='(1x,z16,1x,f18.15)') pi2, pi2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>The output follows:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 400921FB60000000&nbsp; 3.141592741012573</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 400921FB54442D18&nbsp; 3.141592653589793</TT>
<BR><BR>A second consideration is illustrated by the next example.&nbsp; On some computer architectures, there is no difference
in the exponent range between single and double precision floating-point representation.&nbsp; One such architecture is the
IBM mainframe computer (e.g., IBM System/370).&nbsp; When a double precision result is assigned to a single precision (REAL)
variable, only precision in the mantissa is lost.
<BR><BR>The x86 platform uses the IEEE Standard 754 floating-point representation.&nbsp; In this representation, the range
of exponent values is greater in double precision than in single precision.&nbsp; As described in the section entitled <A HREF="#REAL_and_REALT4_Data_Types">REAL and REAL*4 Data Types</A>,
the range for single precision (REAL, REAL*4) numbers is:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 1.175494e-38 &lt;= m &lt;= 3.402823e38</TT>
<BR><BR>On the other hand, the range for double precision (DOUBLE PRECISION, REAL*8) numbers is:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 2.2250738585072e-308 &lt;= m &lt;= 1.79769313486232e308</TT>
<BR><BR>Double precision is described in the section entitled <A HREF="#DOUBLE_PRECISION_and_REALT8_Data_Types">DOUBLE PRECISION and REAL*8 Data Types</A>.
&nbsp;So you can see that a number like 1.0E234 can easily be represented in double precision but not in single precision
since the maximum positive exponent value for single precision is 38.
<H2 ID="FloatingMpoint_Exceptions_On_x86Mbased_Platforms"> Floating-point Exceptions On x86-based Platforms </H2>
<BR>The following types of exceptions can be enabled/disabled on PC's with an 80x87 floating-point unit (either a real FPU
or a true emulator).
<DL>
<DT>DENORMAL
<DD>The result has become denormalized.&nbsp; When the exponent field is all 0 bits and the significand field is non-zero then
the quantity is a special value called a &quot;denormal&quot; or nonnormal number.&nbsp; By providing a significand with leading
zeros, the range of possible negative exponents can be extended by the number of bits in the significand.&nbsp; Each leading
zero is a bit of lost accuracy, so the extended exponent range is obtained by reducing significance.
<DT>ZERODIVIDE
<DD>A division by zero was attempted.&nbsp; A real zero quantity occurs when the sign bit, exponent, and significand are all zero.
<DT>OVERFLOW
<DD>The result has overflowed.&nbsp; The correct answer is finite, but has a magnitude too great to be represented in the destination
floating-point format.
<DT>UNDERFLOW
<DD>The result has numerically underflowed.&nbsp; The correct answer is non-zero but has a magnitude too small to be represented
as a normal number in the destination floating-point format.&nbsp; IEEE Standard 754 specifies that an attempt be made to
represent the number as a denormal.&nbsp; This denormalization may result in a loss of significant bits from the significand.
<DT>PRECISION
<DD>A calculation does not return an exact answer.&nbsp; This exception is usually masked (disabled) and ignored.&nbsp; It is
used in extremely critical applications, when the user must know if the results are exact.&nbsp; The precision exception is
called &quot;inexact&quot; in IEEE Standard 754.
<DT>INVALID
<DD>This is the exception condition that covers all cases not covered by the other exceptions.&nbsp; Included are FPU stack overflow
and underflow, NAN inputs, illegal infinite inputs, out-of-range inputs, and inputs in unsupported formats.
</DL>
<BR>Which exceptions does Open Watcom FORTRAN 77 catch and which ones does it ignore by default?&nbsp; We can determine the
answer to this with the following program.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * This program uses the C Library routine &quot;_control87&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * to obtain the math coprocessor exception mask.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; implicit none</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'fsignal.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character*8 status</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer fp_cw, bits</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fp_cw = _control87( 0, 0 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bits = IAND( fp_cw, MCW_EM )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print '(a,1x,z4)', 'Interrupt exception mask', bits</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *,'Invalid operation exception ', status(bits,
EM_INVALID)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *,'Denormalized exception ', status(bits, EM_DENORMAL)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *,'Divide by 0 exception ', status(bits, EM_ZERODIVIDE)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *,'Overflow exception ', status(bits, EM_OVERFLOW)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *,'Underflow exception ', status(bits, EM_UNDERFLOW)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *,'Precision exception ', status(bits, EM_PRECISION)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character*8 function status( bits, mask )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer bits, mask</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( IAND(bits,mask) .eq. 0 ) then</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; status = 'enabled'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; status = 'disabled'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endif</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>If you compile and run this program, the following output is produced.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Interrupt exception mask 0032</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Invalid operation exception enabled</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Denormalized exception disabled</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Divide by 0 exception enabled</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Overflow exception enabled</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Underflow exception disabled</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Precision exception disabled</TT>
<BR><BR>So, by default, the Open Watcom FORTRAN 77 run-time system will catch &quot;invalid operation&quot;, &quot;divide
by 0&quot;, and &quot;overflow&quot; exceptions.&nbsp; It ignores &quot;denormal&quot;, &quot;underflow&quot;, and &quot;precision&quot;
exceptions.&nbsp; Thus calculations that produce very small results trend towards zero.&nbsp; Also, calculations that produce
inexact results (a very common occurrence in floating-point calculations) are allowed to continue.
<BR><BR>Suppose that you were interested in flagging calculations that result in denormalized or underflowed results.&nbsp;
To do this, we need to enable both DENORMAL and UNDERFLOW exceptions.&nbsp; This following program illustrates how to do this.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$ifdef __386__</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$ifdef __stack_conventions__</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux _clear87 &quot;!&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux _clear87 &quot;!_&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$endif</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux _clear87 &quot;!_&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$endif</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; implicit none</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'fsignal.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character*8 status</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer fp_cw, fp_mask, bits</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; get rid of any errors so we don't cause an instant exception</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _clear87</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; fp_mask determines the bits to enable and/or disable</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fp_mask = 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + EM_DENORMAL</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + EM_UNDERFLOW</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; fp_cw determines whether to enable(0) or disable(1)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; (in this case, nothing is disabled)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fp_cw = '0000'x</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fp_cw = _control87( fp_cw, fp_mask )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bits = IAND( fp_cw, MCW_EM )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print '(a,1x,z4)', 'Interrupt exception mask', bits</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *,'Invalid operation exception ', status(bits,
EM_INVALID)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *,'Denormalized exception ', status(bits, EM_DENORMAL)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *,'Divide by 0 exception ', status(bits, EM_ZERODIVIDE)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *,'Overflow exception ', status(bits, EM_OVERFLOW)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *,'Underflow exception ', status(bits, EM_UNDERFLOW)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *,'Precision exception ', status(bits, EM_PRECISION)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character*8 function status( bits, mask )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer bits, mask</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( IAND(bits,mask) .eq. 0 ) then</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; status = 'enabled'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; status = 'disabled'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endif</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>If you compile and run this program, the following output is produced.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Interrupt exception mask 0020</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Invalid operation exception enabled</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Denormalized exception enabled</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Divide by 0 exception enabled</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Overflow exception enabled</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Underflow exception enabled</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Precision exception disabled</TT>
<H2 ID="Compiler_Options_Relating_to_FloatingMpoint"> Compiler Options Relating to Floating-point </H2>
<BR>Let us take the program that we developed in the previous section and test it out.&nbsp; If you introduce the variable<TT>
FLT</TT> to the program and calculate the expression &quot;2e-38 x 2e-38&quot;, you would expect to see 0.0 printed when underflow
exceptions are disabled and a run-time diagnostic when underflow exceptions are enabled.&nbsp; The statements that you would
add are show in the following.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real flt</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; flt=2e-38</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, flt*flt</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * code to enable exceptions goes here</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, flt*flt</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>If you compile the modified program with default options and run it, the result is as follows.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.0000000</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Interrupt exception mask 0020</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Invalid operation exception enabled</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Denormalized exception enabled</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Divide by 0 exception enabled</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Overflow exception enabled</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Underflow exception enabled</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Precision exception disabled</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.0000000</TT>
<BR><BR>This is not what we expected.&nbsp; Evaluation of the second expression did not produce the run-time diagnostic that
we expected.&nbsp; The reason this happened is related to the compiler's processing of the source code.&nbsp; By default,
the compiler optimized the generated code by evaluating the expression &quot;2e-38 x 2e-38&quot; at compile time producing
0.0 as the result (due to the underflow).
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; flt=2e-38</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, flt*flt</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; reduces to</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, 2e-28*2e-38</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; which further reduces to</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, 0.0</TT>
<BR><BR>Recompile the program using the &quot;OP&quot; option and run it.&nbsp; The result is as follows.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.0000000</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Interrupt exception mask 0020</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Invalid operation exception enabled</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Denormalized exception enabled</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Divide by 0 exception enabled</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Overflow exception enabled</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Underflow exception enabled</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Precision exception disabled</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *ERR* KO-03 floating-point underflow</TT>
<BR><BR>The use of the &quot;OP&quot; option will force the result to be stored in memory after each FORTRAN statement is
executed.&nbsp; Thus, the source code is not optimized across statements.&nbsp; Compile-time versus run-time evaluation of
expressions can lead to different results.&nbsp; It is very instructive to compile and then run your application with a variety
of compile-time options to see the effect of optimizations.&nbsp; See the chapter entitled <A HREF="#Open_Watcom_FORTRAN_77_Compiler_Options">Open Watcom FORTRAN 77 Compiler Options</A>
for more information on compiler options.
<BR><BR>Before we end this section, there is another important aspect of floating-point exceptions to consider.&nbsp; A floating-point
exception is triggered upon the execution of the next FPU instruction following the one that caused the exception.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; implicit none</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real*4 a</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real*8 b</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b=12.0d123</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a=b*b</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b=1.0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a=b/2.0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, a, b</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>Compile this program with the &quot;OP&quot; and &quot;DEBUG&quot; options and then run it.&nbsp; The result is displayed
next.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *ERR* KO-02 floating-point overflow</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - Executing line 9 in file pi4.for</TT>
<BR><BR>Line 9 is the line containing the statement<TT> a=b/2.0</TT> which could not possibly be responsible for an overflow.
&nbsp;However, it contains the first floating-point instruction following the instruction in line 7 where the overflow actually
occurred.&nbsp; To see this, it helps to disassemble the object file.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a=b*b</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0029&nbsp;&nbsp;&nbsp; B8 07 00 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; eax,0x00000007</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 002E&nbsp;&nbsp;&nbsp; E8 00 00 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call&nbsp;&nbsp;&nbsp;
&nbsp; RT@SetLine</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0033&nbsp;&nbsp;&nbsp; DD 45 F4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;fld&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qword ptr -0xc[ebp]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0036&nbsp;&nbsp;&nbsp; D8 C8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; fmul&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st,st</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0038&nbsp;&nbsp;&nbsp; D9 5D FC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;fstp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dword ptr -0x4[ebp]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b=1.0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 003B&nbsp;&nbsp;&nbsp; B8 09 00 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; eax,0x00000009</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0040&nbsp;&nbsp;&nbsp; E8 00 00 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call&nbsp;&nbsp;&nbsp;
&nbsp; RT@SetLine</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0045&nbsp;&nbsp;&nbsp; 31 DB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; xor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ebx,ebx</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0047&nbsp;&nbsp;&nbsp; 89 5D F4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -0xc[ebp],ebx</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 004A&nbsp;&nbsp;&nbsp; C7 45 F8 00 00 F0 3F</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dword ptr
-0x8[ebp],0x3ff00000</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a=b/2.0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0051&nbsp;&nbsp;&nbsp; B8 0A 00 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; eax,0x0000000a</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0056&nbsp;&nbsp;&nbsp; E8 00 00 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call&nbsp;&nbsp;&nbsp;
&nbsp; RT@SetLine</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 005B&nbsp;&nbsp;&nbsp; DD 45 F4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;fld&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qword ptr -0xc[ebp]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 005E&nbsp;&nbsp;&nbsp; DC 0D 08 00 00 00</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fmul&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qword ptr L$2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0064&nbsp;&nbsp;&nbsp; D9 5D FC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;fstp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dword ptr -0x4[ebp]</TT>
<BR><BR>The overflow occurred when the &quot;fstp&quot; was executed but is signalled when the subsequent &quot;fld&quot;
is executed.&nbsp; The overflow could also be signalled while executing down in a run-time routine.&nbsp; This behaviour of
the FPU can be somewhat exasperating.
<H2 ID="FloatingMpoint_Exception_Handling"> Floating-point Exception Handling </H2>
<BR>In certain situations, you want to handle floating-point exceptions in the application itself rather than let the run-time
system terminate your application.&nbsp; The following example illustrates how to do this by installing a FORTRAN subroutine
as a floating-point exception handler.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; implicit none</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'fsignal.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real flt</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; external fpehandler</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signal_count, signal_number,
signal_type</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; common /fpe/ signal_count, signal_number, signal_type</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; begin the signal handling process for floating-point exceptions</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call fsignal( SIGFPE, fpehandler )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp; main body of application goes here</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; flt = 2.0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, 'number of signals', volatile( signal_count
)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, flt / 0.0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, 'number of signals', volatile( signal_count
)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$ifdef __386__</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$ifdef __stack_conventions__</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux _clear87 &quot;!&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux _clear87 &quot;!_&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$endif</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux _clear87 &quot;!_&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$endif</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux fpehandler parm( value, value )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subroutine fpehandler( sig_num, fpe_type )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; implicit none</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; sig_num and fpe_type are passed by value, not by reference</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer sig_num, fpe_type</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'fsignal.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signal_count,
signal_number, signal_type</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; common /fpe/ signal_count, signal_number, signal_type</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; we could add this to our common block</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signal_split( FPE_INVALID:FPE_IOVERFLOW
)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signal_count = signal_count + 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signal_number = sig_num</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signal_type = fpe_type</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; floating-point exception types</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; FPE_INVALID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
= 129 (0)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; FPE_DENORMAL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 130 (1)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; FPE_ZERODIVIDE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 131 (2)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; FPE_OVERFLOW&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 132 (3)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; FPE_UNDERFLOW&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 133 (4)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; FPE_INEXACT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 134
(5)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; FPE_UNEMULATED&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 135 (6)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; FPE_SQRTNEG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 136
(7)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; undefined&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;= 138 (8)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; FPE_STACKOVERFLOW&nbsp;&nbsp; = 137 (9)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; FPE_STACKUNDERFLOW&nbsp; = 138 (10)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; FPE_EXPLICITGEN&nbsp;&nbsp;&nbsp;&nbsp; = 139 (11)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; FPE_IOVERFLOW&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 140 (12)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; log the type of error for interest only */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signal_split( fpe_type ) =</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1signal_split( fpe_type ) + 1</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; get rid of any errors</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _clear87</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; resignal for more exceptions</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call fsignal( SIGFPE, fpehandler )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; if we don't then a subsequent exception will</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; cause an abnormal program termination</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>Note the use of the<TT> VOLATILE</TT> intrinsic function to obtain up-to-date contents of the variable<TT> SIGNAL_COUNT.</TT>
<H1 ID="16Mbit_Memory_Models"> 16-bit Memory Models </H1>
<BR>This chapter describes the various 16-bit memory models supported by Open Watcom F77.&nbsp; Each memory model is distinguished
by two properties; the code model used to implement subprogram calls and the data model used to reference data.
<H2 ID="16Mbit_Code_Models"> 16-bit Code Models </H2>
<BR>There are two code models;
<OL>
<LI>the small code model and
<LI>the big code model.
</OL>
<BR>A small code model is one in which all calls to subprograms are made with<B> near calls.</B>&nbsp; In a near call, the
destination address is 16 bits and is relative to the segment value in segment register CS.&nbsp; Hence, in a small code model,
all code comprising your program, including library subprograms, must be less than 64K.&nbsp; Open Watcom F77 does not support
the small code model.
<BR><BR>A big code model is one in which all calls to subprograms are made with<B> far calls.</B>&nbsp; In a far call, the
destination address is 32 bits (a segment value and an offset relative to the segment value).&nbsp; This model allows the
size of the code comprising your program to exceed 64K.
<H2 ID="16Mbit_Data_Models"> 16-bit Data Models </H2>
<BR>There are three data models;
<OL>
<LI>the small data model,
<LI>the big data model and
<LI>the huge data model.
</OL>
<BR>A small data model is one in which all references to data are made with<B> near pointers.</B>&nbsp; Near pointers are
16 bits; all data references are made relative to the segment value in segment register DS.&nbsp; Hence, in a small data model,
all data comprising your program must be less than 64K.
<BR><BR>A big data model is one in which all references to data are made with<B> far pointers.</B>&nbsp; Far pointers are
32 bits (a segment value and an offset relative to the segment value).&nbsp; This removes the 64K limitation on data size
imposed by the small data model.&nbsp; However, when a far pointer is incremented, only the offset is adjusted.&nbsp; Open
Watcom F77 assumes that the offset portion of a far pointer will not be incremented beyond 64K.&nbsp; The compiler will assign
an object to a new segment if the grouping of data in a segment will cause the object to cross a segment boundary.&nbsp; Implicit
in this is the requirement that no individual object exceed 64K bytes.&nbsp; For example, an array containing 40,000 integers
does not fit into the big data model.&nbsp; An object such as this should be described as<B> huge.</B>
<BR><BR>A huge data model is one in which all references to data are made with far pointers.&nbsp; This is similar to the
big data model.&nbsp; However, in the huge data model, incrementing a far pointer will adjust the offset<B> and</B> the segment
if necessary.&nbsp; The limit on the size of an object pointed to by a far pointer imposed by the big data model is removed
in the huge data model.
<BR><BR><B>Notes:</B>
<OL>
<LI>The huge data model has the same characteristics as the big data model, but formal array arguments are assumed to exceed
64K bytes.&nbsp; You should use the huge data model whenever any arrays in your application exceed 64K bytes in size.
<LI>If your program contains less than 64K of data, you should use the small data model.&nbsp; This will result in smaller
and faster code since references using near pointers produce fewer instructions.
<LI>The huge data model should be used only if needed.&nbsp; The code generated in the huge data model is not very efficient
since a run-time routine is called in order to increment far pointers.&nbsp; This increases the size of the code significantly
and increases execution time.
</OL>
<H2 ID="Summary_of_16Mbit_Memory_Models"> Summary of 16-bit Memory Models </H2>
<BR>As previously mentioned, a memory model is a combination of a code model and a data model.&nbsp; The following table describes
the memory models supported by Open Watcom F77.&nbsp; 
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Memory&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Code&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Data
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Default&nbsp;&nbsp;&nbsp;&nbsp; Default</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Model&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Model&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Model
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Code&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Data</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Pointer
&nbsp;&nbsp;&nbsp; Pointer</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; --------&nbsp;&nbsp;&nbsp; --------&nbsp;&nbsp;&nbsp; --------&nbsp;&nbsp;&nbsp; --------
&nbsp;&nbsp; --------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; medium&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; big&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
small&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; far&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; near</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; large&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; big&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
big&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; far&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; far</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; huge&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; big&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;huge&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; far&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; huge</TT>
<H2 ID="Mixed_16Mbit_Memory_Model"> Mixed 16-bit Memory Model </H2>
<BR>A mixed memory model application combines elements from the various code and data models.&nbsp; A mixed memory model application
might be characterized as one that includes arrays which are larger than 64K bytes.
<BR><BR>For example, a medium memory model application that uses some arrays which exceed 64K bytes in total size can be described
as a mixed memory model.&nbsp; In an application such as this, most of the data is in a 64K segment (DGROUP) and hence can
be referenced with near pointers relative to the segment value in segment register DS.&nbsp; This results in more efficient
code being generated and better execution times than one can expect from a big data model.
<H2 ID="Linking_Applications_for_the_Various_16Mbit_Memory_Models"> Linking Applications for the Various 16-bit Memory Models </H2>
<BR>Each memory model requires different run-time and floating-point libraries.&nbsp; Each library assumes a particular memory
model and should be linked only with modules that have been compiled with the same memory model.&nbsp; The following table
lists the libraries that are to be used to link an application that has been compiled for a particular memory model.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Library&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Memory&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; Floating-point</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;model&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; model</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -------&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ------&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; --------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; flibm.lib&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /mm&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /fpc</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; flibl.lib&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /ml, /mh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; /fpc</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; flib7m.lib&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /mm&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; /fpi, /fpi87</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; flib7l.lib&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /ml, /mh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;/fpi, /fpi87</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; clibm.lib&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /mm&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /fpc, /fpi, /fpi87</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; clibl.lib&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /ml, /mh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; /fpc, /fpi, /fpi87</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; mathm.lib&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /mm,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; /fpc</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; mathl.lib&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /ml, /mh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; /fpc</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; math87m.lib&nbsp;&nbsp;&nbsp;&nbsp; /mm,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; /fpi, /fpi87</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; math87l.lib&nbsp;&nbsp;&nbsp;&nbsp; /ml, /mh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/fpi, /fpi87</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; emu87.lib&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /mm, /ml, /mh&nbsp;&nbsp;&nbsp; /fpi</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; noemu87.lib&nbsp;&nbsp;&nbsp;&nbsp; /mm, /ml, /mh&nbsp;&nbsp;&nbsp; /fpi87</TT>
<H2 ID="16Mbit_Memory_Layout"> 16-bit Memory Layout </H2>
<BR>The following describes the segment ordering of an application linked by the Open Watcom Linker.&nbsp; Note that this
assumes that the &quot;DOSSEG&quot; linker option has been specified.&nbsp; 
<OL>
<LI>all segments not belonging to group &quot;DGROUP&quot; with class &quot;CODE&quot;
<LI>all other segments not belonging to group &quot;DGROUP&quot;
<LI>all segments belonging to group &quot;DGROUP&quot; with class &quot;BEGDATA&quot;
<LI>all segments belonging to group &quot;DGROUP&quot; not with class &quot;BEGDATA&quot;, &quot;BSS&quot; or &quot;STACK&quot;
<LI>all segments belonging to group &quot;DGROUP&quot; with class &quot;BSS&quot;
<LI>all segments belonging to group &quot;DGROUP&quot; with class &quot;STACK&quot;
</OL>
<BR>A special segment belonging to class &quot;BEGDATA&quot; is defined when linking with Open Watcom run-time libraries.
&nbsp;This segment is initialized with the hexadecimal byte pattern &quot;01&quot; and is the first segment in group &quot;DGROUP&quot;
so that storing data at location 0 can be detected.
<BR><BR>Segments belonging to class &quot;BSS&quot; contain uninitialized data.&nbsp; Note that this only includes uninitialized
data in segments belonging to group &quot;DGROUP&quot;.&nbsp; Segments belonging to class &quot;STACK&quot; are used to define
the size of the stack used for your application.&nbsp; Segments belonging to the classes &quot;BSS&quot; and &quot;STACK&quot;
are last in the segment ordering so that uninitialized data need not take space in the executable file.
<BR><BR>In addition to these special segments, the following conventions are used by Open Watcom F77.
<OL>
<LI>The &quot;CODE&quot; class contains the executable code for your application.&nbsp; In a small code model, this consists
of the segment &quot;_TEXT&quot;.&nbsp; In a big code model, this consists of the segments &quot;&lt;subprogram&gt;_TEXT&quot;
where &lt;subprogram&gt; is the name of a subprogram.
<LI>The &quot;FAR_DATA&quot; class consists of the following:
<DL>
<DT>(a)
<DD>arrays whose size exceeds the data threshold in large data memory models (the data threshold is 256 bytes unless changed using
the &quot;dt&quot; compiler option)
<DT>(b)
<DD>equivalenced variables in large data memory models
</DL>
</OL>
<H1 ID="16Mbit_Assembly_Language_Considerations"> 16-bit Assembly Language Considerations </H1>
<BR>This chapter will deal with the following topics.
<OL>
<LI>The memory layout of a program compiled by Open Watcom F77.
<LI>The method for passing arguments and returning values.
<LI>The two methods for passing floating-point arguments and returning floating-point values.
<BR><BR>One method is used when one of the Open Watcom F77 &quot;fpi&quot;, &quot;fpi87&quot; or &quot;fpi387&quot; options
is specified for the generation of in-line 80x87 instructions.&nbsp; When the &quot;fpi&quot; option is specified, an 80x87
emulator is included from a math library if the application includes floating-point operations.&nbsp; When the &quot;fpi87&quot;
or &quot;fpi387&quot; option is used exclusively, the 80x87 emulator will not be included.
<BR><BR>The other method is used when the Open Watcom F77 &quot;fpc&quot; option is specified.&nbsp; In this case, the compiler
generates calls to floating-point support routines in the alternate math libraries.
</OL>
<BR>An understanding of the Intel 80x86 architecture is assumed.
<H2 ID="16Mbit__Calling_Conventions"> 16-bit:&nbsp; Calling Conventions </H2>
<BR>The following sections describe the method used by Open Watcom F77 to pass arguments.
<BR><BR>The FORTRAN 77 language specifically requires that arguments be passed by reference.&nbsp; This means that instead
of passing the value of an argument, its address is passed.&nbsp; This allows a called subprogram to modify the value of the
actual arguments.&nbsp; The following illustrates the method used to pass arguments.
<BR><BR> Type of Argument&nbsp;&nbsp;&nbsp; Method Used to Pass Argument
<BR><BR> non-character&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR>constant&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; address of constant 
<BR> non-character&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR>expression&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; address of value of expression
<BR> non-character&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR>variable&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; address of variable 
<BR> character constant&nbsp; address of string descriptor
<BR> character&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR>expression&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; address of string descriptor
<BR> character variable&nbsp; address of string descriptor
<BR> non-character array address of array&nbsp;&nbsp;&nbsp; 
<BR> non-character array&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; 
<BR>element&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; address of array&nbsp;&nbsp;&nbsp;

<BR> character array&nbsp;&nbsp;&nbsp;&nbsp; address of string descriptor
<BR> character array&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR>element&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; address of string descriptor
<BR> character substring address of string descriptor
<BR> subprogram&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; address of subprogram
<BR> alternate return&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR>specifier&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; no argument passed&nbsp; 
<BR> user-defined&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR>structure&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; address of structure
<BR><BR>When passing a character array as an argument, the string descriptor contains the address of the first element of
the array and the length of an element of the array.
<BR><BR>The address of arguments are either passed in registers or on the stack.&nbsp; The registers used to pass the address
of arguments to a subprogram are AX, BX, CX and DX.&nbsp; The address of arguments are passed in the following way.
<OL>
<LI>For memory models with a big data model, address of arguments consist of a 16-bit offset and a 16-bit segment.&nbsp; Hence,
two registers are required to pass the address of an argument.&nbsp; The first argument will be passed in registers DX:AX
with register DX containing the segment and register AX containing the offset.&nbsp; The second argument will be passed in
registers CX:BX with register CX containing the segment and register BX containing the offset.
<LI>For memory models with a small data model, address of arguments consists of only a 16-bit offset into the default data
segment.&nbsp; Hence, only a single register is required to pass the address of an argument.&nbsp; The first argument is passed
in register AX, the second argument is passed in register DX, the third argument is passed in register BX, and the fourth
argument is passed in register CX.
<LI>For any remaining arguments, their address is passed on the stack.&nbsp; Note that addresses of arguments are pushed on
the stack from right to left.
</OL>
<H3 ID="16Mbit__Processing_Function_Return_Values_with_no_80x87"> 16-bit:&nbsp; Processing Function Return Values with no 80x87 </H3>
<BR>The way in which function values are returned is also dependent on the data type of the function.&nbsp; The following
describes the method used to return function values.
<OL>
<LI><B> LOGICAL*1</B> values are returned in register AL.
<LI><B> LOGICAL*4</B> values are returned in registers DX:AX.
<LI><B> INTEGER*1</B> values are returned in register AL.
<LI><B> INTEGER*2</B> values are returned in register AX.
<LI><B> INTEGER*4</B> values are returned in registers DX:AX.
<LI><B> REAL*4</B> values are returned in registers DX:AX.
<LI><B> REAL*8</B> values are returned in registers AX:BX:CX:DX.
<LI>For<B> COMPLEX*8</B> functions, space is allocated on the stack by the caller for the return value.&nbsp; Register SI
is set to point to the destination of the result.&nbsp; The called function places the result at the location pointed to by
register SI.
<LI>For<B> COMPLEX*16</B> functions, space is allocated on the stack by the caller for the return value.&nbsp; Register SI
is set to point to the destination of the result.&nbsp; The called function places the result at the location pointed to by
register SI.
<LI>For<B> CHARACTER</B> functions, an additional argument is passed.&nbsp; This argument is the address of the string descriptor
for the result.&nbsp; Note that the address of the string descriptor can be passed in any of the registers that are used to
pass actual arguments.
<LI>For functions that return a user-defined structure, space is allocated on the stack by the caller for the return value.
&nbsp;Register SI is set to point to the destination of the result.&nbsp; The called function places the result at the location
pointed to by register SI.&nbsp; Note that a structure of size 1, 2 or 4 bytes is returned in register AL, AX or DX:AX respectively.
</OL>
<H3 ID="16Mbit__Processing_Function_Return_Values_Using_an_80x87"> 16-bit:&nbsp; Processing Function Return Values Using an 80x87 </H3>
<BR>The following describes the method used to return function values when your application is compiled using the &quot;fpi87&quot;
or &quot;fpi&quot; option.
<OL>
<LI>For<B> REAL*4</B> functions, the result is returned in floating-point register ST(0).
<LI>For<B> REAL*8</B> functions, the result is returned in floating-point register ST(0).
<LI>All other function values are returned in the way described in the previous section.
</OL>
<H3 ID="16Mbit__Processing_Alternate_Returns"> 16-bit:&nbsp; Processing Alternate Returns </H3>
<BR>Alternate returns are processed by the caller and are only allowed in subroutines.&nbsp; The called subroutine places
the value specified in the<B><I> RETURN</I></B> statement in register AX.&nbsp; Note that the value returned in register AX
is ignored if there are no alternate return specifiers in the actual argument list.
<H3 ID="16Mbit__Alternate_Method_of_Passing_Character_Arguments"> 16-bit:&nbsp; Alternate Method of Passing Character Arguments </H3>
<BR>As previously described, character arguments are passed using string descriptors.&nbsp; Recall that a string descriptor
contains a pointer to the actual character data and the length of the character data.&nbsp; When passing character data, both
a pointer and length are required by the subprogram being called.&nbsp; When using a string descriptor, this information can
be passed using a single argument, namely the pointer to the string descriptor.
<BR><BR>An alternate method of passing character arguments is also supported and is selected when the &quot;nodescriptor&quot;
option is specified.&nbsp; In this method, the pointer to the character data and the length of the character data are passed
as two separate arguments.&nbsp; The character argument lengths are appended to the end of the actual argument list.
<BR><BR>Let us consider the following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; INTEGER A, C</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER B, D</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CALL SUB( A, B, C, D )</TT>
<BR><BR>In the above example, the first argument is of type INTEGER, the second argument is of type CHARACTER, the third argument
is of type INTEGER, and the fourth argument is of type CHARACTER.&nbsp; If the character arguments were passed by descriptor,
the argument list would resemble the following.
<OL>
<LI>The first argument would be the address of<TT> A.</TT>
<LI>The second argument would be the address of the string descriptor for<TT> B.</TT>
<LI>The third argument would be the address of<TT> C.</TT>
<LI>The fourth argument would be the address of the string descriptor for<TT> D.</TT>
</OL>
<BR>If we specified the &quot;nodescriptor&quot; option, the argument list would be as follows.
<OL>
<LI>The first argument would be the address of<TT> A.</TT>
<LI>The second argument would be the address of the character data for<TT> B.</TT>
<LI>The third argument would be the address of<TT> C.</TT>
<LI>The fourth argument would be the address of the character data for<TT> D.</TT>
<LI>A hidden argument for the length of<TT> B</TT> would be the fifth argument.
<LI>A hidden argument for the length of<TT> D</TT> would be the sixth argument.
</OL>
<BR>Note that the arguments corresponding to the length of the character arguments are passed as INTEGER*2 arguments.
<H4 ID="16Mbit__Character_Functions"> 16-bit:&nbsp; Character Functions </H4>
<BR>By default, when a character function is called, a hidden argument is passed at the end of the actual argument list.&nbsp;
This hidden argument is a pointer to the string descriptor used for the return value of the character function.&nbsp; When
the alternate method of passing character arguments is specified by using the &quot;nodescriptor&quot; option, the string
descriptor for the return value is passed to the function as two hidden arguments, similar to the way character arguments
were passed.&nbsp; However the two hidden arguments for the return value of the character function are placed at the beginning
of the actual argument list.&nbsp; The first argument is the the pointer to the storage immediately followed by the size of
the storage.
<H2 ID="16Mbit__Memory_Layout"> 16-bit:&nbsp; Memory Layout </H2>
<BR>The following describes the segment ordering of an application linked by the Open Watcom Linker.&nbsp; Note that this
assumes that the &quot;DOSSEG&quot; linker option has been specified.&nbsp; 
<OL>
<LI>all segments not belonging to group &quot;DGROUP&quot; with class &quot;CODE&quot;
<LI>all other segments not belonging to group &quot;DGROUP&quot;
<LI>all segments belonging to group &quot;DGROUP&quot; with class &quot;BEGDATA&quot;
<LI>all segments belonging to group &quot;DGROUP&quot; not with class &quot;BEGDATA&quot;, &quot;BSS&quot; or &quot;STACK&quot;
<LI>all segments belonging to group &quot;DGROUP&quot; with class &quot;BSS&quot;
<LI>all segments belonging to group &quot;DGROUP&quot; with class &quot;STACK&quot;
</OL>
<BR>A special segment belonging to class &quot;BEGDATA&quot; is defined when linking with Open Watcom run-time libraries.
&nbsp;This segment is initialized with the hexadecimal byte pattern &quot;01&quot; and is the first segment in group &quot;DGROUP&quot;
so that storing data at location 0 can be detected.
<BR><BR>Segments belonging to class &quot;BSS&quot; contain uninitialized data.&nbsp; Note that this only includes uninitialized
data in segments belonging to group &quot;DGROUP&quot;.&nbsp; Segments belonging to class &quot;STACK&quot; are used to define
the size of the stack used for your application.&nbsp; Segments belonging to the classes &quot;BSS&quot; and &quot;STACK&quot;
are last in the segment ordering so that uninitialized data need not take space in the executable file.
<BR><BR>In addition to these special segments, the following conventions are used by Open Watcom F77.
<OL>
<LI>The &quot;CODE&quot; class contains the executable code for your application.&nbsp; In a small code model, this consists
of the segment &quot;_TEXT&quot;.&nbsp; In a big code model, this consists of the segments &quot;&lt;subprogram&gt;_TEXT&quot;
where &lt;subprogram&gt; is the name of a subprogram.
<LI>The &quot;FAR_DATA&quot; class consists of the following:
<DL>
<DT>(a)
<DD>arrays whose size exceeds the data threshold in large data memory models (the data threshold is 256 bytes unless changed using
the &quot;dt&quot; compiler option)
<DT>(b)
<DD>equivalenced variables in large data memory models
</DL>
</OL>
<H2 ID="16Mbit__Writing_Assembly_Language_Subprograms"> 16-bit:&nbsp; Writing Assembly Language Subprograms </H2>
<BR>When writing assembly language subprograms, use the following guidelines.
<OL>
<LI>All used registers must be saved on entry and restored on exit except those used to pass arguments and return values.
&nbsp;Note that segment registers only have to be saved and restored if you are compiling your application with the &quot;sr&quot;
option.
<LI>The direction flag must be clear before returning to the caller.
<LI>In a small code model, any segment containing executable code must belong to the segment &quot;_TEXT&quot; and the class
&quot;CODE&quot;.&nbsp; The segment &quot;_TEXT&quot; must have a &quot;combine&quot; type of &quot;PUBLIC&quot;.&nbsp; On
entry, register CS contains the segment address of the segment &quot;_TEXT&quot;.&nbsp; In a big code model there is no restriction
on the naming of segments which contain executable code.
<LI>In a small data model, segment register DS contains the segment address of the default data segment (group &quot;DGROUP&quot;).
&nbsp;In a big data model, segment register SS (not DS) contains the segment address of the default data segment (group &quot;DGROUP&quot;).
<LI>When writing assembly language subprograms for the small code model, you must declare them as &quot;near&quot;.&nbsp;
If you wish to write assembly language subprograms for the big code model, you must declare them as &quot;far&quot;.
<LI>Use the &quot;.8087&quot; pseudo-op so that floating-point constants are in the correct format.
<LI>The called subprogram must remove arguments that were passed on the stack in the &quot;ret&quot; instruction.
<LI>In general, when naming segments for your code or data, you should follow the conventions described in the section entitled
&quot;Memory Layout&quot; in this chapter.
</OL>
<BR>Consider the following example.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER HRS, MINS, SECS, HSECS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALL GETTIM( HRS, MINS, SECS, HSECS )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT 100, HRS, MINS, SECS, HSECS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 100&nbsp;&nbsp; FORMAT( 1X,I2.2,':',I2.2,':',I2.2,'.',I2.2 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<HR>
<BR><TT>GETTIM</TT> is an assembly language subroutine that gets the current time.&nbsp; It requires four integer arguments.
&nbsp;The arguments are passed by reference so that the subroutine can return the hour, minute, seconds and hundredths of
a second for the current time.&nbsp; These arguments will be passed to<TT> GETTIM</TT> in the following way.
<OL>
<LI>The address of the first argument will be passed in registers DX:AX.
<LI>The address of the second argument will be passed in registers CX:BX.
<LI>The address of the third argument will be passed on the stack.
<LI>The address of the fourth argument will be passed on the stack.
</OL>
<BR>The following is an assembly language subprogram which implements<TT> GETTIM.</TT>
<BR><BR><B>Large Memory Model (big code, big data)</B>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; GETTIM_TEXT segment byte public 'CODE'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assume&nbsp; CS:GETTIM_TEXT</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public&nbsp; GETTIM</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; GETTIM&nbsp; proc&nbsp;&nbsp;&nbsp; far</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; DI&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; save register(s)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; ES&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; ...</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; DS&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; ...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; BP&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; get addressability to arguments</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; BP,SP&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; ; ...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ES,DX&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; ; ES:DI points to hours</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; DI,AX&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; ; ...</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; DS,CX&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; ; DS:BX points to minutes</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; AH,2ch&nbsp;
&nbsp;&nbsp;&nbsp; ; set DOS &quot;get time&quot; function</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; 21h&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; issue DOS function call</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; AL,CH&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; ; get hours</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cbw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; ...</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ES:[DI],AX
&nbsp;; return hours</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sub&nbsp;&nbsp;&nbsp;&nbsp; AX,AX&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; ; ...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ES:2[DI],AX ;
...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; AL,CL&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; ; get minutes</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cbw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; ...</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; [BX],AX&nbsp;
&nbsp;&nbsp; ; return minutes</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sub&nbsp;&nbsp;&nbsp;&nbsp; AX,AX&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; ; ...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; 2[BX],AX&nbsp;
&nbsp; ; ...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; DS,14[BP]&nbsp;
&nbsp;; get address of seconds</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; DI,12[BP]&nbsp;
&nbsp;; ...</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; AL,DH&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; ; get seconds</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cbw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; ...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; [DI],AX&nbsp;
&nbsp;&nbsp; ; return seconds</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sub&nbsp;&nbsp;&nbsp;&nbsp; AX,AX&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; ; ...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; 2[DI],AX&nbsp;
&nbsp; ; ...</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; DS,18[BP]
&nbsp; ; get address of ticks</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; DI,16[BP]&nbsp;
&nbsp;; ...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; AL,DL&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; ; get ticks</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cbw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; ...</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cwd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; ...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; [DI],AX&nbsp;
&nbsp;&nbsp; ; return ticks</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; 2[DI],DX&nbsp;
&nbsp; ; ...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;&nbsp;&nbsp; BP&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; restore register(s)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;&nbsp;&nbsp; DS&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; ...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;&nbsp;&nbsp; ES&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; ...</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;&nbsp;&nbsp; DI&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; ...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret&nbsp;&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; return</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; GETTIM&nbsp; endp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; GETTIM_TEXT ends</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR><B>Notes:</B>
<OL>
<LI>Two arguments were passed on the stack so a &quot;ret 8&quot; instruction is used to return to the caller.
<LI>Registers AX, BX, CX and DX were not saved and restored since they were used to pass arguments.&nbsp; However, registers
DS, ES, DI and BP were modified in the subprogram and hence must be saved and restored.
</OL>
<BR>Let us look at the stack upon entry to<TT> GETTIM.</TT>
<BR><BR><B>Large Model (big code, big data)</B>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Offset</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; +----------------+ &lt;- SP points here</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | return address |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | argument #3&nbsp;&nbsp;&nbsp;
|</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | argument #4&nbsp;&nbsp;&nbsp;
|</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 12&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><BR><B>Notes:</B>
<OL>
<LI>The top element of the stack is a segment/offset pair forming a 32-bit return address.&nbsp; Hence, the third argument
will be at offset 4 from the top of the stack and the fourth argument at offset 8.
</OL>
<BR>Register SP cannot be used as a base register to address the arguments on the stack.&nbsp; Register BP is normally used
to address arguments on the stack.&nbsp; Upon entry to the subroutine, registers that are modified (except those used to pass
arguments) are saved and register BP is set to point to the stack.&nbsp; After performing this prologue sequence, the stack
looks like this.
<BR><BR><B>Large Model (big code, big data)</B>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Offset</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; +----------------+ &lt;- BP and SP point
here</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | saved BP&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | saved DS&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | saved ES&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | saved DI&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | return address |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 12&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | argument #3&nbsp;&nbsp;&nbsp;
|</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | argument #4&nbsp;&nbsp;&nbsp;
|</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 20&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><BR>As the above diagram shows, the third argument is at offset 12 from register BP and the fourth argument is at offset
16.
<H3 ID="16Mbit__Returning_Values_from_Assembly_Language_Functions"> 16-bit:&nbsp; Returning Values from Assembly Language Functions </H3>
<BR>The following illustrates the way function values are to be returned from assembly language functions.
<OL>
<LI>A<B> LOGICAL*1</B> function.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; L1_TEXT segment byte public 'CODE'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assume&nbsp; CS:L1_TEXT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public&nbsp; L1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; L1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; proc&nbsp;&nbsp;&nbsp; far</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; AL,1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; L1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; L1_TEXT ends</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<LI>A<B> LOGICAL*4</B> function.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; L4_TEXT segment byte public 'CODE'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assume&nbsp; CS:L4_TEXT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public&nbsp; L4</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; L4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; proc&nbsp;&nbsp;&nbsp; far</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; AX,0</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cwd</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; L4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; L4_TEXT ends</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<LI>An<B> INTEGER*1</B> function.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; I1_TEXT segment byte public 'CODE'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assume&nbsp; CS:I1_TEXT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public&nbsp; I1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; I1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; proc&nbsp;&nbsp;&nbsp; far</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; AL,73</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; I1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; I1_TEXT ends</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<LI>An<B> INTEGER*2</B> function.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; I2_TEXT segment byte public 'CODE'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assume&nbsp; CS:I2_TEXT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public&nbsp; I2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; I2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; proc&nbsp;&nbsp;&nbsp; far</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; AX,7143</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; I2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; I2_TEXT ends</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<LI>An<B> INTEGER*4</B> function.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; I4_TEXT segment byte public 'CODE'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assume&nbsp; CS:I4_TEXT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public&nbsp; I4</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; I4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; proc&nbsp;&nbsp;&nbsp; far</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; AX,383</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cwd</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; I4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; I4_TEXT ends</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<LI>A<B> REAL*4</B> function.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; .8087</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DGROUP&nbsp; group R4_DATA</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; R4_TEXT segment byte public 'CODE'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assume&nbsp; CS:R4_TEXT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assume&nbsp; SS:DGROUP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public&nbsp; R4</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; R4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; proc&nbsp;&nbsp;&nbsp; far</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; AX,word ptr
SS:R4Val</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; DX,word ptr SS:R4Val+2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; R4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; R4_TEXT ends</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; R4_DATA segment byte public 'DATA'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; R4Val&nbsp;&nbsp; dd 1314.3</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; R4_DATA ends</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<LI>A<B> REAL*8</B> function.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; .8087</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DGROUP&nbsp; group R8_DATA</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; R8_TEXT segment byte public 'CODE'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assume&nbsp; CS:R8_TEXT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assume&nbsp; SS:DGROUP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public&nbsp; R8</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; R8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; proc&nbsp;&nbsp;&nbsp; far</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; DX,word ptr SS:R8Val</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; CX,word ptr
SS:R8Val+2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; BX,word ptr SS:R8Val+4</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; AX,word ptr SS:R8Val+6</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; R8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; R8_TEXT ends</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; R8_DATA segment byte public 'DATA'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; R8Val&nbsp;&nbsp; dq 103.3</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; R8_DATA ends</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<LI>A<B> COMPLEX*8</B> function.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; .8087</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DGROUP&nbsp; group C8_DATA</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C8_TEXT segment byte public 'CODE'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assume&nbsp; CS:C8_TEXT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assume&nbsp; SS:DGROUP</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public&nbsp; C8</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; proc&nbsp;&nbsp;&nbsp; far</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; DI</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; ES</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xchg&nbsp;&nbsp;&nbsp; DI,SI</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; SS</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;&nbsp;&nbsp; ES</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; SI,offset SS:C8Val</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movsw</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movsw</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movsw</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movsw</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;&nbsp;&nbsp; ES</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;&nbsp;&nbsp; DI</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C8_TEXT ends</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C8_DATA segment byte public 'DATA'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C8Val&nbsp;&nbsp; dd 2.2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dd 2.2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C8_DATA ends</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<LI>A<B> COMPLEX*16</B> function.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; .8087</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DGROUP&nbsp; group C16_DATA</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C16_TEXT segment byte public 'CODE'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assume&nbsp; CS:C16_TEXT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assume&nbsp; SS:DGROUP</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public&nbsp; C16</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C16&nbsp;&nbsp;&nbsp;&nbsp; proc&nbsp;&nbsp;&nbsp; far</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; DI</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; ES</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; CX</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xchg&nbsp;&nbsp;&nbsp; DI,SI</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; SS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;&nbsp;&nbsp; ES</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; SI,offset SS:C16Val</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; CX,8</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; repe&nbsp;&nbsp;&nbsp; movsw</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;&nbsp;&nbsp; CX</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;&nbsp;&nbsp; ES</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;&nbsp;&nbsp; DI</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C16&nbsp;&nbsp;&nbsp;&nbsp; endp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C16_TEXT ends</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C16_DATA segment byte public 'DATA'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C16Val&nbsp; dq 3.3</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dq 3.3</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C16_DATA ends</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<LI>A<B> CHARACTER</B> function.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CHR_TEXT segment byte public 'CODE'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assume&nbsp; CS:CHR_TEXT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public&nbsp; CHR</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CHR&nbsp;&nbsp;&nbsp;&nbsp; proc&nbsp;&nbsp;&nbsp; far</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; DI</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; ES</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ES,DX</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; DI,AX</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; les&nbsp;&nbsp;&nbsp;&nbsp; DI,ES:[DI]</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; byte ptr
ES:[DI],'F'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;&nbsp;&nbsp; ES</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;&nbsp;&nbsp; DI</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CHR&nbsp;&nbsp;&nbsp;&nbsp; endp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CHR_TEXT ends</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<LI>A function returning a user-defined structure.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DGROUP&nbsp; group STRUCT_DATA</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; STRUCT_TEXT segment byte public 'CODE'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assume&nbsp; CS:STRUCT_TEXT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assume&nbsp; SS:DGROUP</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public&nbsp; C16</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; STRUCT&nbsp; proc&nbsp;&nbsp;&nbsp; far</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; DI</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; ES</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; CX</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xchg&nbsp;&nbsp;&nbsp; DI,SI</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; SS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;&nbsp;&nbsp; ES</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; SI,offset SS:StructVal</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; CX,4</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; repe&nbsp;&nbsp;&nbsp; movsw</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;&nbsp;&nbsp; CX</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;&nbsp;&nbsp; ES</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;&nbsp;&nbsp; DI</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; STRUCT&nbsp; endp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; STRUCT_TEXT ends</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; STRUCT_DATA segment byte public 'DATA'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; StructVal dd 7</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dd 3</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; STRUCT_DATA ends</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</OL>
<BR>If you are using an 80x87 to return floating-point values, only assembly language functions of type<B> REAL*4</B> and<B>
REAL*8</B> need to be modified.
<OL>
<LI>A<B> REAL*4</B> function using an 80x87.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; .8087</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DGROUP&nbsp; group R4_DATA</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; R4_TEXT segment byte public 'CODE'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assume&nbsp; CS:R4_TEXT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assume&nbsp; SS:DGROUP</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public&nbsp; R4</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; R4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; proc&nbsp;&nbsp;&nbsp; far</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fld&nbsp;&nbsp;&nbsp;&nbsp; dword ptr SS:R4Val</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; R4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; R4_TEXT ends</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; R4_DATA segment byte public 'DATA'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; R4Val&nbsp;&nbsp; dd 1314.3</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; R4_DATA ends</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<LI>A<B> REAL*8</B> function using an 80x87.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; .8087</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DGROUP&nbsp; group R8_DATA</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; R8_TEXT segment byte public 'CODE'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assume&nbsp; CS:R8_TEXT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assume&nbsp; SS:DGROUP</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public&nbsp; R8</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; R8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; proc&nbsp;&nbsp;&nbsp; far</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fld&nbsp;&nbsp;&nbsp;&nbsp; qword ptr SS:R8Val</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; R8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; R8_TEXT ends</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; R8_DATA segment byte public 'DATA'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; R8Val&nbsp;&nbsp; dq 103.3</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; R8_DATA ends</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</OL>
<BR><B>Notes:</B>
<OL>
<LI>The &quot;.8087&quot; pseudo-op must be specified so that all floating-point constants are generated in 8087 format.
<LI>When returning values on the stack, remember to use a segment override to the stack segment (SS).
</OL>
<BR>The following is an example of a Open Watcom F77 program calling the above assembly language subprograms.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; logical l1*1, l4*4</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer i1*1, i2*2, i4*4</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real r4*4, r8*8</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; complex c8*8, c16*16</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character chr</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; structure /coord/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer x, y</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end structure</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /coord/ struct</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, l1()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, l4()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, i1()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, i2()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, i4()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, r4()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, r8()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, c8()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, c16()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, chr()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, struct()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<H1 ID="16Mbit__16Mbit_Pragmas"> 16-bit:&nbsp; 16-bit Pragmas </H1>
<BR>A pragma is a compiler directive that provides the following capabilities.
<UL>
<LI>Pragmas can be used to direct the Open Watcom F77 code generator to emit specialized sequences of code for calling functions
which use argument passing and value return techniques that differ from the default used by Open Watcom F77.
<LI>Pragmas can be used to describe attributes of functions (such as side effects) that are not possible at the FORTRAN 77
language level.&nbsp; The code generator can use this information to generate more efficient code.
<LI>Any sequence of in-line machine language instructions, including DOS and BIOS function calls, can be generated in the
object code.
</UL>
<BR>Pragmas are specified in the source file using the<B><I> pragma</I></B> directive.&nbsp; A pragma operator of the form,<B><I>
_Pragma</I></B> ( string-literal ) is an alternative method of specifying<B><I> pragma</I></B> directives.
<BR><BR>For example, the following two statements are equivalent.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _Pragma( &quot;library (\&quot;kernel32.lib\&quot;)&quot; )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma library (&quot;kernel32.lib&quot;)</TT>
<BR><BR>The<B><I> _Pragma</I></B> operator can be used in macro definition.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; # define LIBRARY(X) PRAGMA(library (#X))</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; # define PRAGMA(X) _Pragma(#X)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; LIBRARY(kernel32.lib)&nbsp; // same as #pragma library (&quot;kernel32.lib&quot;)</TT>
<BR><BR>The following notation is used to describe the syntax of pragmas.
<DL>
<DT>keywords
<DD>A<TT> keyword</TT> is shown in a mono-spaced courier font.
<DT>program-item
<DD>A<B><I> program-item</I></B> is shown in a roman bold-italics font.&nbsp; A<B><I> program-item</I></B> is a symbol name or
numeric value supplied by the programmer.
<DT>punctuation
<DD>A<TT> punctuation character</TT> shown in a mono-spaced courier font must be entered as is.
<BR><BR>A<B><I> punctuation character</I></B> shown in a roman bold-italics font is used to describe syntax.&nbsp; The following
syntactical notation is used.
<DL>
<DT>[abc]
<DD>The item<B> abc</B> is optional.
<DT>{abc}
<DD>The item<B> abc</B> may be repeated zero or more times.
<DT>a|b|c
<DD>One of<B> a, b</B> or<B> c</B> may be specified.
<DT>a ::= b
<DD>The item<B> a</B> is defined in terms of<B> b.</B>
<DT>(a)
<DD>Item<B> a</B> is evaluated first.
</DL>
</DL>
<BR>The following classes of pragmas are supported.
<UL>
<LI>pragmas that specify default libraries
<LI>pragmas that provide auxiliary information used for code generation
</UL>
<H2 ID="16Mbit__Using_Pragmas_to_Specify_Default_Libraries"> 16-bit:&nbsp; Using Pragmas to Specify Default Libraries </H2>
<BR>Default libraries are specified in special object module records.&nbsp; Library names are extracted from these special
records by the Open Watcom Linker.&nbsp; When unresolved references remain after processing all object modules specified in
linker &quot;FILE&quot; directives, these default libraries are searched after all libraries specified in linker &quot;LIBRARY&quot;
directives have been searched.
<BR><BR>By default, that is if no library pragma is specified, the Open Watcom F77 compiler generates, in the object file
defining the main program, default libraries corresponding to the memory model and floating-point model used to compile the
file.&nbsp; For example, if you have compiled the source file containing the main program for the medium memory model and
the floating-point calls floating-point model, the library &quot;flibm&quot; will be placed in the object file.
<BR><BR>If you wish to add your own default libraries to this list, you can do so with a library pragma.&nbsp; Consider the
following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma library mylib</TT>
<BR><BR>The name &quot;mylib&quot; will be added to the list of default libraries specified in the object file.
<BR><BR>If you wish to specify more than one library in a library pragma you must separate them with spaces as in the following
example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma library mylib \watcom\lib286\dos\graph.lib</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma library mylib \watcom\lib386\dos\graph.lib</TT>
<BR><BR>If no libraries are specified as in the following example,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma library</TT>
<BR><BR>the run-time libraries corresponding to the memory and floating-point models used to compile the file will be generated.
<H2 ID="16Mbit__Auxiliary_Pragmas"> 16-bit:&nbsp; Auxiliary Pragmas </H2>
<BR>The following sections describe the capabilities provided by auxiliary pragmas.
<BR><BR>The backslash character ('\') is used to continue a pragma on the next line.&nbsp; Text following the backslash character
is ignored.&nbsp; The line continuing the pragma must start with a comment character ('c', 'C' or '*').
<H3 ID="16Mbit__Specifying_Symbol_Attributes"> 16-bit:&nbsp; Specifying Symbol Attributes </H3>
<BR>Auxiliary pragmas are used to describe attributes that affect code generation.&nbsp; Initially, the compiler defines a
default set of attributes.&nbsp; Each auxiliary pragma refers to one of the following.
<OL>
<LI>a symbol (such as a variable or function)
<LI>the default set of attributes defined by the compiler
</OL>
<BR>When an auxiliary pragma refers to a particular symbol, a copy of the current set of default attributes is made and merged
with the attributes specified in the auxiliary pragma.&nbsp; The resulting attributes are assigned to the specified symbol
and can only be changed by another auxiliary pragma that refers to the same symbol.
<BR><BR>When &quot;default&quot; is specified instead of a symbol name, the attributes specified by the auxiliary pragma change
the default set of attributes.&nbsp; The resulting attributes are used by all symbols that have not been specifically referenced
by a previous auxiliary pragma.
<BR><BR>Note that all auxiliary pragmas are processed before code generation begins.&nbsp; Consider the following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; code in which symbol x is referenced</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux y &lt;attrs_1&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; code in which symbol y is referenced</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; code in which symbol z is referenced</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux default &lt;attrs_2&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux x &lt;attrs_3&gt;</TT>
<BR><BR>Auxiliary attributes are assigned to<TT> x, y</TT> and<TT> z</TT> in the following way.
<OL>
<LI>Symbol<TT> x</TT> is assigned the initial default attributes merged with the attributes specified by<TT> &lt;attrs_2&gt;</TT>
and<TT> &lt;attrs_3&gt;.</TT>
<LI>Symbol<TT> y</TT> is assigned the initial default attributes merged with the attributes specified by<TT> &lt;attrs_1&gt;.</TT>
<LI>Symbol<TT> z</TT> is assigned the initial default attributes merged with the attributes specified by<TT> &lt;attrs_2&gt;.</TT>
</OL>
<H3 ID="16Mbit__Alias_Names"> 16-bit:&nbsp; Alias Names </H3>
<BR>When a symbol referred to by an auxiliary pragma includes an alias name, the attributes of the alias name are also assumed
by the specified symbol.
<BR><BR>There are two methods of specifying alias information.&nbsp; In the first method, the symbol assumes only the attributes
of the alias name; no additional attributes can be specified.&nbsp; The second method is more general since it is possible
to specify an alias name as well as additional auxiliary information.&nbsp; In this case, the symbol assumes the attributes
of the alias name as well as the attributes specified by the additional auxiliary information.
<BR><BR>The simple form of the auxiliary pragma used to specify an alias is as follows.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux ( </TT><B>sym</B><TT>, </TT><B>alias</B><TT> ) </TT>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is any valid FORTRAN 77 identifier.
<DT>alias
<DD>is the alias name and is any valid FORTRAN 77 identifier.
</DL>
<BR>Consider the following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux value_args parm (value) </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux ( rtn, value_args ) </TT>
<BR><BR>The routine<TT> rtn</TT> assumes the attributes of the alias name<TT> push_args</TT> which specifies that the arguments
to<TT> rtn</TT> are passed by value.
<BR><BR>The general form of an auxiliary pragma that can be used to specify an alias is as follows.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux ( </TT><B>alias</B><TT> ) </TT><B>sym</B><TT> </TT><B>aux_attrs</B><TT> </TT>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>alias
<DD>is the alias name and is any valid FORTRAN 77 identifier.
<DT>sym
<DD>is any valid FORTRAN 77 identifier.
<DT>aux_attrs
<DD>are attributes that can be specified with the auxiliary pragma.
</DL>
<BR>Consider the following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux WC &quot;*_&quot; parm (value)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux (WC) rtn1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux (WC) rtn2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux (WC) rtn3</TT>
<BR><BR>The routines<TT> rtn1, rtn2</TT> and<TT> rtn3</TT> assume the same attributes as the alias name<TT> WC</TT> which
defines the calling convention used by the Open Watcom C compiler.&nbsp; Whenever calls are made to<TT> rtn1, rtn2</TT> and<TT>
rtn3,</TT> the Open Watcom C calling convention will be used.&nbsp; Note that arguments must be passed by value.&nbsp; By
default, Open Watcom F77 passes arguments by reference.
<BR><BR>Note that if the attributes of<TT> WC</TT> change, only one pragma needs to be changed.&nbsp; If we had not used an
alias name and specified the attributes in each of the three pragmas for<TT> rtn1, rtn2</TT> and<TT> rtn3,</TT> we would have
to change all three pragmas.&nbsp; This approach also reduces the amount of memory required by the compiler to process the
source file.
<HR>
<BR><B><I>&nbsp; WARNING!</I></B>&nbsp; The alias name<TT> WC</TT> is just another symbol.&nbsp; If<TT> WC</TT> appeared in
your source code, it would assume the attributes specified in the pragma for<TT> WC.</TT>
<HR>
<H3 ID="16Mbit__Predefined_Aliases"> 16-bit:&nbsp; Predefined Aliases </H3>
<BR>A number of symbols are predefined by the compiler with a set of attributes that describe a particular calling convention.
&nbsp;These symbols can be used as aliases.&nbsp; The following is a list of these symbols.
<DL>
<DT>__cdecl
<DD><TT> __cdecl</TT> defines the calling convention used by Microsoft compilers.
<DT>__fastcall
<DD><TT> __fastcall</TT> defines the calling convention used by Microsoft compilers.
<DT>__fortran
<DD><TT> __fortran</TT> defines the calling convention used by Open Watcom FORTRAN compilers.
<DT>__pascal
<DD><TT> __pascal</TT> defines the calling convention used by OS/2 1.x and Windows 3.x API functions.
<DT>__stdcall
<DD><TT> __stdcall</TT> defines the calling convention used by Microsoft compilers.
<DT>__watcall
<DD><TT> __watcall</TT> defines the calling convention used by Open Watcom compilers.
</DL>
<BR>The following describes the attributes of the above alias names.
<H4 ID="16Mbit__Predefined____cdecl__Alias"> 16-bit:&nbsp; Predefined &quot;__cdecl&quot; Alias </H4>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux __cdecl &quot;_*&quot; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parm caller [] \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value struct float struct routine
[ax] \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; modify [ax bx cx dx es]</TT>
<BR><BR><B>Notes:</B>
<OL>
<LI>All symbols are preceded by an underscore character.
<LI>Arguments are pushed on the stack from right to left.&nbsp; That is, the last argument is pushed first.&nbsp; The calling
routine will remove the arguments from the stack.
<LI>Floating-point values are returned in the same way as structures.&nbsp; When a structure is returned, the called routine
allocates space for the return value and returns a pointer to the return value in register AX.
<LI>Registers AX, BX, CX and DX, and segment register ES are not saved and restored when a call is made.
</OL>
<H4 ID="16Mbit__Predefined____pascal__Alias"> 16-bit:&nbsp; Predefined &quot;__pascal&quot; Alias </H4>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux __pascal &quot;^&quot; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parm reverse routine [] \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value struct float struct caller
[] \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; modify [ax bx cx dx es]</TT>
<BR><BR><B>Notes:</B>
<OL>
<LI>All symbols are mapped to upper case.
<LI>Arguments are pushed on the stack in reverse order.&nbsp; That is, the first argument is pushed first, the second argument
is pushed next, and so on.&nbsp; The routine being called will remove the arguments from the stack.
<LI>Floating-point values are returned in the same way as structures.&nbsp; When a structure is returned, the caller allocates
space on the stack.&nbsp; The address of the allocated space will be pushed on the stack immediately before the call instruction.
&nbsp;Upon returning from the call, register AX will contain address of the space allocated for the return value.
<LI>Registers AX, BX, CX and DX, and segment register ES are not saved and restored when a call is made.
</OL>
<H4 ID="16Mbit__Predefined____watcall__Alias"> 16-bit:&nbsp; Predefined &quot;__watcall&quot; Alias </H4>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux __watcall &quot;*_&quot; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parm routine [ax bx cx dx]
\</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value struct caller</TT>
<BR><BR><B>Notes:</B>
<OL>
<LI>Symbol names are followed by an underscore character.
<LI>Arguments are processed from left to right.&nbsp; The leftmost arguments are passed in registers and the rightmost arguments
are passed on the stack (if the registers used for argument passing have been exhausted).&nbsp; Arguments that are passed
on the stack are pushed from right to left.&nbsp; The calling routine will remove the arguments if any were pushed on the
stack.
<LI>When a structure is returned, the caller allocates space on the stack.&nbsp; The address of the allocated space is put
into SI register.&nbsp; The called routine then places the return value there.&nbsp; Upon returning from the call, register
AX will contain address of the space allocated for the return value.
<LI>Floating-point values are returned using 80x86 registers (&quot;fpc&quot; option) or using 80x87 floating-point registers
(&quot;fpi&quot; or &quot;fpi87&quot; option).
<LI>All registers must be preserved by the called routine.
</OL>
<H3 ID="16Mbit__Alternate_Names_for_Symbols"> 16-bit:&nbsp; Alternate Names for Symbols </H3>
<BR>The following form of the auxiliary pragma can be used to describe the mapping of a symbol from its source form to its
object form.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux </TT><B>sym</B><TT> </TT><B>obj_name</B><TT> </TT>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is any valid FORTRAN 77 identifier.
<DT>obj_name
<DD>is any character string enclosed in double quotes.
</DL>
<BR>When specifying<TT> obj_name,</TT> some characters have a special meaning:
<DL>
<DT>where
<DD><B>description</B>
<DT>*
<DD>is unmodified symbol name
<DT>^
<DD>is symbol name converted to uppercase
<DT>!
<DD>is symbol name converted to lowercase
<DT>#
<DD>is a placeholder for &quot;@nnn&quot;, where nnn is size of all function parameters on the stack; it is ignored for functions
with variable argument lists, or for symbols that are not functions
<DT>\
<DD>next character is treated as literal
</DL>
<BR>Several examples of source to object form symbol name translation follow:&nbsp; By default, the upper case version &quot;MYRTN&quot;
or &quot;MYVAR&quot; is placed in the object file.
<BR><BR>In the following example, the name &quot;MyRtn&quot; will be replaced by &quot;MYRTN_&quot; in the object file.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux MyRtn &quot;^_&quot;</TT>
<BR><BR>In the following example, the name &quot;MyVar&quot; will be replaced by &quot;_MYVAR&quot; in the object file.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux MyVar &quot;_^&quot;</TT>
<BR><BR>In the following example, the lower case version &quot;myrtn&quot; will be placed in the object file.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux MyRtn &quot;!&quot;</TT>
<BR><BR>In the following example, the name &quot;MyRtn&quot; will be replaced by &quot;_MyRtn@nnn&quot; in the object file.
&nbsp;&quot;nnn&quot; represents the size of all function parameters.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux MyRtn &quot;_*#&quot;</TT>
<BR><BR>In the following example, the name &quot;MyRtn&quot; will be replaced by &quot;_MyRtn#&quot; in the object file.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux MyRtn &quot;_*\#&quot;</TT>
<BR><BR>The default mapping for all symbols can also be changed as illustrated by the following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux default &quot;_^_&quot;</TT>
<BR><BR>The above auxiliary pragma specifies that all names will be prefixed and suffixed by an underscore character ('_').
<H3 ID="16Mbit__Describing_Calling_Information"> 16-bit:&nbsp; Describing Calling Information </H3>
<BR>The following form of the auxiliary pragma can be used to describe the way a subprogram is to be called.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux </TT><B>sym</B><TT> far</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux </TT><B>sym</B><TT> near</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux </TT><B>sym</B><TT> = </TT><B>in_line</B>
<BR><BR><B>&nbsp;&nbsp;&nbsp;&nbsp; in_line ::= { const | </B><TT>&quot;</TT><B>asm</B><TT>&quot;</TT><B> | (</B><TT>float</TT><B>
fpinst) }</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a subprogram name.
<DT>const
<DD>is a valid FORTRAN 77 hexadecimal constant.
<DT>fpinst
<DD>is a sequence of bytes that forms a valid 80x87 instruction.&nbsp; The keyword<B><I> float</I></B> must precede<TT> fpinst</TT>
so that special fixups are applied to the 80x87 instruction.
<DT>asm
<DD>is an assembly language instruction or directive.
</DL>
<BR>In the following example, Open Watcom F77 will generate a far call to the subprogram<TT> myrtn.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux myrtn far</TT>
<BR><BR>Note that this overrides the calling sequence that would normally be generated for a particular memory model.&nbsp;
In other words, a far call will be generated even if you are compiling for a memory model with a small code model.
<BR><BR>In the following example, Open Watcom F77 will generate a near call to the subprogram<TT> myrtn.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux myrtn near</TT>
<BR><BR>Note that this overrides the calling sequence that would normally be generated for a particular memory model.&nbsp;
In other words, a near call will be generated even if you are compiling for a memory model with a big code model.
<BR><BR>In the following DOS example, Open Watcom F77 will generate the sequence of bytes following the &quot;=&quot; character
in the auxiliary pragma whenever a call to<TT> mode4</TT> is encountered.<TT>&nbsp; mode4</TT> is called an in-line subprogram.
&nbsp;
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux mode4 =&nbsp;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp; zb4 z00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\ mov AH,0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp; zb0 z04&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\ mov AL,4</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp; zcd z10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\ int 10h</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp; modify [ AH AL ]</TT>
<BR><BR>The sequence in the above DOS example represents the following lines of assembly language instructions.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp; AH,0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; select function &quot;set mode&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp; AL,4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; specify mode (mode 4)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; 10H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; BIOS video call</TT>
<BR><BR>The above example demonstrates how to generate BIOS function calls in-line without writing an assembly language function
and calling it from your FORTRAN 77 program.
<BR><BR>The following DOS example is equivalent to the above example but mnemonics for the assembly language instructions
are used instead of the binary encoding of the assembly language instructions.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux mode4 =&nbsp;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp; &quot;mov AH,0&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp; &quot;mov AL,4&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp; &quot;int 10H&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp; modify [ AH AL ]</TT>
<BR><BR>If a sequence of in-line assembly language instructions contains 80x87 floating-point instructions, each floating-point
instruction must be preceded by &quot;float&quot;.&nbsp; Note that this is only required if you have specified the &quot;fpi&quot;
compiler option; otherwise it will be ignored.
<BR><BR>The following example generates the 80x87 &quot;square root&quot; instruction.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux mysqrt parm( value ) [8087] = \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float zd9fa</TT>
<H4 ID="16Mbit__Loading_Data_Segment_Register"> 16-bit:&nbsp; Loading Data Segment Register </H4>
<BR>An application may have been compiled so that the segment register DS does not contain the segment address of the default
data segment (group &quot;DGROUP&quot;).&nbsp; This is usually the case if you are using a large data memory model.&nbsp;
Suppose you wish to call a subprogram that assumes that the segment register DS contains the segment address of the default
data segment.&nbsp; It would be very cumbersome if you were forced to compile your application so that the segment register
DS contained the default data segment (a small data memory model).
<BR><BR>The following form of the auxiliary pragma will cause the segment register DS to be loaded with the segment address
of the default data segment before calling the specified subprogram.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux </TT><B>sym</B><TT> parm loadds </TT>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a subprogram name.
</DL>
<BR>Alternatively, the following form of the auxiliary pragma will cause the segment register DS to be loaded with the segment
address of the default data segment as part of the prologue sequence for the specified subprogram.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux </TT><B>sym</B><TT> loadds </TT>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a subprogram name.
</DL>
<H4 ID="16Mbit__Defining_Exported_Symbols_in_Dynamic_Link_Libraries"> 16-bit:&nbsp; Defining Exported Symbols in Dynamic Link Libraries </H4>
<BR>An exported symbol in a dynamic link library is a symbol that can be referenced by an application that is linked with
that dynamic link library.&nbsp; Normally, symbols in dynamic link libraries are exported using the Open Watcom Linker &quot;EXPORT&quot;
directive.&nbsp; An alternative method is to use the following form of the auxiliary pragma.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux </TT><B>sym</B><TT> export </TT>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a subprogram name.
</DL>
<H4 ID="16Mbit__Defining_Windows_Callback_Functions"> 16-bit:&nbsp; Defining Windows Callback Functions </H4>
<BR>When compiling a Microsoft Windows application, you must use the &quot;windows&quot; option so that special prologue/epilogue
sequences are generated.&nbsp; Furthermore, callback functions require larger prologue/epilogue sequences than those generated
when the &quot;windows&quot; compiler option is specified.&nbsp; The following form of the auxiliary pragma will cause a callback
prologue/epilogue sequence to be generated for a callback function when compiled using the &quot;windows&quot; option.&nbsp;

<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux </TT><B>sym</B><TT> export </TT>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a callback function name.
</DL>
<H3 ID="16Mbit__Describing_Argument_Information"> 16-bit:&nbsp; Describing Argument Information </H3>
<BR>Using auxiliary pragmas, you can describe the calling convention that Open Watcom F77 is to use for calling subprograms.
&nbsp;This is particularly useful when interfacing to subprograms that have been compiled by other compilers or subprograms
written in other programming languages.
<BR><BR>The general form of an auxiliary pragma that describes argument passing is the following.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux </TT><B>sym</B><TT> parm </TT><B>{ arg_info | pop_info | </B><TT>reverse</TT><B>
{reg_set} }</B>
<BR><BR><B>&nbsp;&nbsp;&nbsp;&nbsp; arg_info ::=</B><TT> ( </TT><B>arg_attr</B><TT> </TT><B>{</B><TT>, </TT><B>arg_attr}</B><TT>
)</TT>
<BR><BR><B>&nbsp;&nbsp;&nbsp;&nbsp; arg_attr ::=</B><TT> value </TT><B>[v_attr]</B>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;</TT><B>|</B><TT> reference </TT><B>[r_attr]</B>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;</TT><B>|</B><TT> data_reference </TT><B>[d_attr]</B>
<BR><BR><B>&nbsp;&nbsp;&nbsp;&nbsp; v_attr ::=</B><TT> far </TT><B>|</B><TT> near </TT><B>|</B><TT> *1 </TT><B>|</B><TT> *2
</TT><B>|</B><TT> *4 </TT><B>|</B><TT> *8</TT>
<BR><BR><B>&nbsp;&nbsp;&nbsp;&nbsp; r_attr ::=</B><TT> </TT><B>[</B><TT>far </TT><B>|</B><TT> near</TT><B>]</B><TT> </TT><B>[</B><TT>descriptor
</TT><B>|</B><TT> nodescriptor</TT><B>]</B>
<BR><BR><B>&nbsp;&nbsp;&nbsp;&nbsp; d_attr ::=</B><TT> </TT><B>[</B><TT>far </TT><B>|</B><TT> near</TT><B>]</B>
<BR><BR><B>&nbsp;&nbsp;&nbsp;&nbsp; pop_info ::=</B><TT> caller </TT><B>|</B><TT> routine</TT>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a subprogram name.
<DT>reg_set
<DD>is called a register set.&nbsp; The register sets specify the registers that are to be used for argument passing.&nbsp; A
register set is a list of registers separated by spaces and enclosed in square brackets.
</DL>
<H4 ID="16Mbit__Passing_Arguments_to_nonMFORTRAN_Subprograms"> 16-bit:&nbsp; Passing Arguments to non-FORTRAN Subprograms </H4>
<BR>When calling a subprogram written in a different language, it may be necessary to provide the arguments in a form different
than the default methods used by Open Watcom F77.&nbsp; For example, C functions require scalar arguments to be passed by
value instead of by reference.&nbsp; For information on the methods Open Watcom F77 uses to pass arguments, see the chapter
entitled &quot;Assembly Language Considerations&quot;.
<BR><BR>The following form of the auxiliary pragma can be used to alter the default calling mechanism used for passing arguments.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux </TT><B>sym</B><TT> parm ( </TT><B>arg_attr</B><TT> </TT><B>{</B><TT>, </TT><B>arg_attr}</B><TT>
)</TT>
<BR><BR><B>&nbsp;&nbsp;&nbsp;&nbsp; arg_attr ::=</B><TT> value </TT><B>[v_attr]</B>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;</TT><B>|</B><TT> reference </TT><B>[r_attr]</B>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;</TT><B>|</B><TT> data_reference </TT><B>[d_attr]</B>
<BR><BR><B>&nbsp;&nbsp;&nbsp;&nbsp; v_attr ::=</B><TT> far </TT><B>|</B><TT> near </TT><B>|</B><TT> *1 </TT><B>|</B><TT> *2
</TT><B>|</B><TT> *4 </TT><B>|</B><TT> *8</TT>
<BR><BR><B>&nbsp;&nbsp;&nbsp;&nbsp; r_attr ::=</B><TT> </TT><B>[</B><TT>far </TT><B>|</B><TT> near</TT><B>]</B><TT> </TT><B>[</B><TT>descriptor
</TT><B>|</B><TT> nodescriptor</TT><B>]</B>
<BR><BR><B>&nbsp;&nbsp;&nbsp;&nbsp; d_attr ::=</B><TT> </TT><B>[</B><TT>far </TT><B>|</B><TT> near</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a subprogram name.
<DT>REFERENCE
<DD>specifies that arguments are to be passed by reference.&nbsp; For non-character arguments, the address is a pointer to the
data.&nbsp; For character arguments, the address is a pointer to a string descriptor.&nbsp; See the chapter entitled &quot;Assembly
Language Considerations&quot; for a description of a string descriptor.&nbsp; This is the default calling mechanism.&nbsp;
If &quot;NEAR&quot; or &quot;FAR&quot; is specified, a near pointer or far pointer is passed regardless of the memory model
used at compile-time.
<BR><BR>If the &quot;DESCRIPTOR&quot; attribute is specified, a pointer to the string descriptor is passed.&nbsp; This is
the default.&nbsp; If the &quot;NODESCRIPTOR&quot; attribute is specified, a pointer to the the actual character data is passed
instead of a pointer to the string descriptor.
<DT>DATA_REFERENCE
<DD>specifies that arguments are to be passed by data reference.&nbsp; For non-character items, this is identical to passing by
reference.&nbsp; For character items, a pointer to the actual character data (instead of the string descriptor) is passed.
&nbsp;If &quot;NEAR&quot; or &quot;FAR&quot; is specified, a near pointer or far pointer is passed regardless of the memory
model used at compile-time.
<DT>VALUE
<DD>specifies that arguments are to be passed by value.&nbsp; Character arguments are treated specially when passed by value.
&nbsp;Instead of passing a pointer to a string descriptor, a pointer to the actual character data is passed.&nbsp; See the
chapter entitled &quot;Assembly Language Considerations&quot; for a description of a string descriptor.
</DL>
<BR><B>Notes:</B>
<OL>
<LI>Arrays and subprograms are always passed by reference, regardless of the argument attribute specified.
<LI>When character arguments are passed by reference, the address of a string descriptor is passed.&nbsp; The string descriptor
contains the address of the actual character data and the number of characters.&nbsp; When character arguments are passed
by value or data reference, the address of the actual character data is passed instead of the address of a string descriptor.
&nbsp;Character arguments are passed by value by specifying the &quot;VALUE&quot; or &quot;DATA_REFERENCE&quot; attribute.
&nbsp;If &quot;NEAR&quot; or &quot;FAR&quot; is specified, a near pointer or far pointer to the character data is passed regardless
of the memory model used at compile-time.
<LI>When complex arguments are passed by value, the real part and the imaginary part are passed as two separate arguments.
<LI>When an argument is a user-defined structure and is passed by value, a copy of the structure is made and passed as an
argument.
<LI>For scalar arguments, arguments of type<B> INTEGER*1</B>,<B> INTEGER*2</B>,<B> INTEGER*4</B> ct ,<B> REAL</B> or<B> DOUBLE
PRECISION</B>, a length specification can be specified when the &quot;VALUE&quot; attribute is specified to pass the argument
by value.&nbsp; This length specification refers to the size of the argument; the compiler will convert the actual argument
to a type that matches the size.&nbsp; For example, if an argument of type<B> REAL</B> is passed to a subprogram that has
an argument attribute of &quot;VALUE*8&quot;, the argument will be converted to<B> DOUBLE PRECISION</B>.&nbsp; If an argument
of type<B> DOUBLE PRECISION</B> is passed to a subprogram that has an argument attribute of &quot;VALUE*4&quot;, the argument
will be converted to<B> REAL</B>.&nbsp; If an argument of type<B> INTEGER*4</B> is passed to a subprogram that has an argument
attribute of &quot;VALUE*2&quot; or VALUE*1, the argument will be converted to<B> INTEGER*2</B> or<B> INTEGER*1</B>.&nbsp;
If an argument of type<B> INTEGER*2</B> is passed to a subprogram that has an argument attribute of &quot;VALUE*4 or VALUE*1&quot;,
the argument will be converted to<B> INTEGER*4</B> or<B> INTEGER*1</B>.&nbsp; If an argument of type<B> INTEGER*1</B> is passed
to a subprogram that has an argument attribute of &quot;VALUE*4 or VALUE*2&quot;, the argument will be converted to<B> INTEGER*4</B>
or<B> INTEGER*2</B>.
<LI>If the number of arguments exceeds the number of entries in the argument-attribute list, the last attribute will be assumed
for the remaining arguments.
</OL>
<BR>Consider the following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux printf &quot;*_&quot; parm (value) caller []</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character cr/z0d/, nullchar/z00/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call printf( 'values: %ld, %ld'//cr//nullchar,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; 77, 31410 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>The C &quot;printf&quot; function is called with three arguments.&nbsp; The first argument is of type<B> CHARACTER</B>
and is passed as a C string (address of actual data terminated by a null character).&nbsp; The second and third arguments
are passed by value.&nbsp; Also note that &quot;printf&quot; is a function that takes a variable number of arguments, all
passed on the stack (an empty register set was specified), and that the caller must remove the arguments from the stack.
<H4 ID="16Mbit__Passing_Arguments_in_Registers"> 16-bit:&nbsp; Passing Arguments in Registers </H4>
<BR>The following form of the auxiliary pragma can be used to specify the registers that are to be used to pass arguments
to a particular subprogram.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux </TT><B>sym</B><TT> parm </TT><B>{reg_set}</B><TT> </TT>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a subprogram name.
<DT>reg_set
<DD>is called a register set.&nbsp; The register sets specify the registers that are to be used for argument passing.&nbsp; A
register set is a list of registers separated by spaces and enclosed in square brackets.
</DL>
<BR>Register sets establish a priority for register allocation during argument list processing.&nbsp; Register sets are processed
from left to right.&nbsp; However, within a register set, registers are chosen in any order.&nbsp; Once all register sets
have been processed, any remaining arguments are pushed on the stack.
<BR><BR>Note that regardless of the register sets specified, only certain combinations of registers will be selected for arguments
of a particular type.
<BR><BR>Note that arguments of type<B> REAL</B> and<B> DOUBLE PRECISION</B> are always pushed on the stack when the &quot;fpi&quot;
or &quot;fpi87&quot; option is used.
<DL>
<DT>DOUBLE PRECISION
<DD>Arguments of type<B> DOUBLE PRECISION</B>, when passed by value, can only be passed in the following register combination:
&nbsp;AX:BX:CX:DX.&nbsp; For example, if the following register set was specified for a routine having an argument of type<B>
DOUBLE PRECISION</B>,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [AX BX SI DI]</TT>
<BR><BR>the argument would be pushed on the stack since a valid register combination for 8-byte arguments is not contained
in the register set.&nbsp; Note that this method for passing arguments of type<B> DOUBLE PRECISION</B> is supported only when
the &quot;fpc&quot; option is used.&nbsp; Note that this argument passing method does not include arguments of type<B> COMPLEX*8</B>
or user-defined structures whose size is 8 bytes when these arguments are passed by value.
<DT>far pointer
<DD>A far pointer can only be passed in one of the following register pairs:&nbsp; DX:AX, CX:BX, CX:AX, CX:SI, DX:BX, DI:AX, CX:DI,
DX:SI, DI:BX, SI:AX, CX:DX, DX:DI, DI:SI, SI:BX, BX:AX, DS:CX, DS:DX, DS:DI, DS:SI, DS:BX, DS:AX, ES:CX, ES:DX, ES:DI, ES:SI,
ES:BX or ES:AX.&nbsp; For example, if a far pointer is passed to a function with the following register set,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [ES BP]</TT>
<BR><BR>the argument would be pushed on the stack since a valid register combination for a far pointer is not contained in
the register set.&nbsp; Far pointers are used to pass arguments by reference in a big data memory model.
<DT>INTEGER*4, REAL
<DD>The only registers that will be assigned to 4-byte arguments (e.g., arguments of type<B> INTEGER*4</B>, when passed by value)
are:&nbsp; DX:AX, CX:BX, CX:AX, CX:SI, DX:BX, DI:AX, CX:DI, DX:SI, DI:BX, SI:AX, CX:DX, DX:DI, DI:SI, SI:BX and BX:AX.&nbsp;
For example, if the following register set was specified for a routine with one argument of type<B> INTEGER*4</B>,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [ES DI]</TT>
<BR><BR>the argument would be pushed on the stack since a valid register combination for 4-byte arguments is not contained
in the register set.&nbsp; Note that this argument passing method includes arguments of type<B> REAL</B> but only when the
&quot;fpc&quot; option is used.
<DT>INTEGER*2
<DD>The only registers that will be assigned to 2-byte arguments (e.g., arguments of type<B> INTEGER*2</B> when passed by value
or arguments passed by reference in a small data memory model) are:&nbsp; AX, BX, CX, DX, SI and DI.&nbsp; For example, if
the following register set was specified for a routine with one argument of type<B> INTEGER*2</B>,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [BP]</TT>
<BR><BR>the argument would be pushed on the stack since a valid register combination for 2-byte arguments is not contained
in the register set.
<DT>INTEGER*1
<DD>Arguments whose size is 1 byte (e.g., arguments of type<B> INTEGER*1</B> when passed by value) are promoted to 2 bytes and
are then assigned registers as if they were 2-byte arguments.
<DT>others
<DD>Arguments that do not fall into one of the above categories cannot be passed in registers and are pushed on the stack.&nbsp;
Once an argument has been assigned a position on the stack, all remaining arguments will be assigned a position on the stack
even if all register sets have not yet been exhausted.
</DL>
<BR><B>Notes:</B>
<OL>
<LI>The default register set is [AX BX CX DX].
<LI>Specifying registers AH and AL is equivalent to specifying register AX.&nbsp; Specifying registers DH and DL is equivalent
to specifying register DX.&nbsp; Specifying registers CH and CL is equivalent to specifying register CX.&nbsp; Specifying
registers BH and BL is equivalent to specifying register BX.
<LI>If you are compiling for a memory model with a small data model, any register combination containing register DS becomes
illegal.&nbsp; In a small data model, segment register DS must remain unchanged as it points to the program's data segment.
</OL>
<BR>Consider the following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux myrtn parm (value) \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ax bx cx dx] [bp si]</TT>
<BR><BR>Suppose<TT> myrtn</TT> is a routine with 3 arguments each of type<B> INTEGER</B>.&nbsp; Note that the arguments are
passed by value.
<OL>
<LI>The first argument will be passed in the register pair DX:AX.
<LI>The second argument will be passed in the register pair CX:BX.
<LI>The third argument will be pushed on the stack since BP:SI is not a valid register pair for arguments of type<B> INTEGER</B>.
</OL>
<BR>It is possible for registers from the second register set to be used before registers from the first register set are
used.&nbsp; Consider the following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux myrtn parm (value) \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ax bx cx dx] [si di]</TT>
<BR><BR>Suppose<TT> myrtn</TT> is a routine with 3 arguments, the first of type<B> INTEGER</B> and the second and third of
type<B> INTEGER</B>.&nbsp; Note that all arguments are passed by value.
<OL>
<LI>The first argument will be passed in the register AX.
<LI>The second argument will be passed in the register pair CX:BX.
<LI>The third argument will be passed in the register set DI:SI.
</OL>
<BR>Note that registers are no longer selected from a register set after registers are selected from subsequent register sets,
even if all registers from the original register set have not been exhausted.
<BR><BR>An empty register set is permitted.&nbsp; All subsequent register sets appearing after an empty register set are ignored;
all remaining arguments are pushed on the stack.
<BR><BR><B>Notes:</B>
<OL>
<LI>If a single empty register set is specified, all arguments are passed on the stack.
<LI>If no register set is specified, the default register set [AX BX CX DX] is used.
</OL>
<H4 ID="16Mbit__Forcing_Arguments_into_Specific_Registers"> 16-bit:&nbsp; Forcing Arguments into Specific Registers </H4>
<BR>It is possible to force arguments into specific registers.&nbsp; Suppose you have a subprogram, say &quot;mycopy&quot;,
that copies data.&nbsp; The first argument is the source, the second argument is the destination, and the third argument is
the length to copy.&nbsp; If we want the first argument to be passed in the register SI, the second argument to be passed
in register DI and the third argument to be passed in register CX, the following auxiliary pragma can be used.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux mycopy parm (value) \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [SI] [DI] [CX]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character*10&nbsp; dst</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call mycopy( dst, '0123456789', 10 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>Note that you must be aware of the size of the arguments to ensure that the arguments get passed in the appropriate
registers.
<H4 ID="16Mbit__Passing_Arguments_to_InMLine_Subprograms"> 16-bit:&nbsp; Passing Arguments to In-Line Subprograms </H4>
<BR>For subprograms whose code is generated by Open Watcom F77 and whose argument list is described by an auxiliary pragma,
Open Watcom F77 has some freedom in choosing how arguments are assigned to registers.&nbsp; Since the code for in-line subprograms
is specified by the programmer, the description of the argument list must be very explicit.&nbsp; To achieve this, Open Watcom
F77 assumes that each register set corresponds to an argument.&nbsp; Consider the following DOS example of an in-line subprogram
called<TT> scrollactivepgup.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux scrollactivepgup =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp; &quot;mov AH,6&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp; &quot;int 10h&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp; parm (value)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ch] [cl] [dh] [dl] [al] [bh] \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp; modify [ah]</TT>
<BR><BR>The BIOS video call to scroll the active page up requires the following arguments.
<OL>
<LI>The row and column of the upper left corner of the scroll window is passed in registers CH and CL respectively.
<LI>The row and column of the lower right corner of the scroll window is passed in registers DH and DL respectively.
<LI>The number of lines blanked at the bottom of the window is passed in register AL.
<LI>The attribute to be used on the blank lines is passed in register BH.
</OL>
<BR>When passing arguments, Open Watcom F77 will convert the argument so that it fits in the register(s) specified in the
register set for that argument.&nbsp; For example, in the above example, if the first argument to<TT> scrollactivepgup</TT>
was called with an argument whose type was<B> INTEGER</B>, it would first be converted to<B> INTEGER*1</B> before assigning
it to register CH.&nbsp; Similarly, if an in-line subprogram required its argument in register pair DX:AX and the argument
was of type<B> INTEGER*2</B>, the argument would be converted to<B> INTEGER*4</B> before assigning it to register pair DX:AX.
<BR><BR>In general, Open Watcom F77 assigns the following types to register sets.
<OL>
<LI>A register set consisting of a single 8-bit register (1 byte) is assigned a type of<B> INTEGER*1</B>.
<LI>A register set consisting of a single 16-bit register (2 bytes) is assigned a type of<B> INTEGER*2</B>.
<LI>A register set consisting of two 16-bit registers (4 bytes) is assigned a type of<B> INTEGER*4</B>.
<LI>A register set consisting of four 16-bit registers (8 bytes) is assigned a type of<B> DOUBLE PRECISION</B>.
</OL>
<BR>If the size of an integer argument is larger than the size specified by the register set, the argument will be truncated
to the required size.&nbsp; If the size of an integer argument is smaller than the size specified by the register set, the
argument will be padded (to the left) with zeros.
<H4 ID="16Mbit__Removing_Arguments_from_the_Stack"> 16-bit:&nbsp; Removing Arguments from the Stack </H4>
<BR>The following form of the auxiliary pragma specifies who removes from the stack arguments that were pushed on the stack.
&nbsp;
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux </TT><B>sym</B><TT> parm </TT><B>(</B><TT>caller </TT><B>|</B><TT> routine</TT><B>)</B><TT>
</TT>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a subprogram name.
</DL>
<BR>&quot;caller&quot; specifies that the caller will pop the arguments from the stack; &quot;routine&quot; specifies that
the called routine will pop the arguments from the stack.&nbsp; If &quot;caller&quot; or &quot;routine&quot; is omitted, &quot;routine&quot;
is assumed unless the default has been changed in a previous auxiliary pragma, in which case the new default is assumed.
<BR><BR>Consider the following example.&nbsp; It describes the pragma required to call the C &quot;printf&quot; function.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux printf &quot;*_&quot; parm (value) caller []</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character cr/z0d/, nullchar/z00/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call printf( 'value is %ld'//cr//nullchar,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; 7143 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>The first argument must be passed as a C string, a pointer to the actual character data terminated by a null character.
&nbsp;By default, the address of a string descriptor is passed for arguments of type<B> CHARACTER</B>.&nbsp; See the chapter
entitled &quot;Assembly Language Considerations&quot; for more information on string descriptors.&nbsp; The second argument
is of type<B> INTEGER</B> and is passed by value.&nbsp; Also note that &quot;printf&quot; is a function that takes a variable
number of arguments, all pushed on the stack (an empty register set was specified).
<H4 ID="16Mbit__Passing_Arguments_in_Reverse_Order"> 16-bit:&nbsp; Passing Arguments in Reverse Order </H4>
<BR>The following form of the auxiliary pragma specifies that arguments are passed in the reverse order.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux </TT><B>sym</B><TT> parm reverse </TT>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a subprogram name.
</DL>
<BR>Normally, arguments are processed from left to right.&nbsp; The leftmost arguments are passed in registers and the rightmost
arguments are passed on the stack (if the registers used for argument passing have been exhausted).&nbsp; Arguments that are
passed on the stack are pushed from right to left.
<BR><BR>When arguments are reversed, the rightmost arguments are passed in registers and the leftmost arguments are passed
on the stack (if the registers used for argument passing have been exhausted).&nbsp; Arguments that are passed on the stack
are pushed from left to right.
<BR><BR>Reversing arguments is most useful for subprograms that require arguments to be passed on the stack in an order opposite
from the default.&nbsp; The following auxiliary pragma demonstrates such a subprogram.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux rtn parm reverse []</TT>
<H3 ID="16Mbit__Describing_Subprogram_Return_Information"> 16-bit:&nbsp; Describing Subprogram Return Information </H3>
<BR>Using auxiliary pragmas, you can describe the way functions are to return values.&nbsp; This is particularly useful when
interfacing to functions that have been compiled by other compilers or functions written in other programming languages.
<BR><BR>The general form of an auxiliary pragma that describes the way a function returns its value is the following.&nbsp;

<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux </TT><B>sym</B><TT> value </TT><B>{</B><TT>no8087 </TT><B>|</B><TT> </TT><B>reg_set</B><TT>
</TT><B>|</B><TT> </TT><B>struct_info}</B><TT> </TT>
<BR><BR><B>&nbsp;&nbsp;&nbsp;&nbsp; struct_info ::=</B><TT> struct </TT><B>{</B><TT>float </TT><B>|</B><TT> struct </TT><B>|</B><TT>
</TT><B>(</B><TT>routine </TT><B>|</B><TT> caller</TT><B>)</B><TT> </TT><B>|</B><TT> </TT><B>reg_set}</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a function name.
<DT>reg_set
<DD>is called a register set.&nbsp; The register sets specify the registers that are to be used for argument passing.&nbsp; A
register set is a list of registers separated by spaces and enclosed in square brackets.
</DL>
<H4 ID="16Mbit__Returning_Subprogram_Values_in_Registers"> 16-bit:&nbsp; Returning Subprogram Values in Registers </H4>
<BR>The following form of the auxiliary pragma can be used to specify the registers that are to be used to return a function's
value.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux </TT><B>sym</B><TT> value </TT><B>reg_set</B><TT> </TT>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a subprogram name.
<DT>reg_set
<DD>is a register set.
</DL>
<BR>Note that the method described below for returning values of type<B> REAL</B> or<B> DOUBLE PRECISION</B> is supported
only when the &quot;fpc&quot; option is used.
<BR><BR>Depending on the type of the return value, only certain registers are allowed in<B> reg_set.</B>
<DL>
<DT>1-byte
<DD>For 1-byte return values, only the following registers are allowed:&nbsp; AL, AH, DL, DH, BL, BH, CL or CH.&nbsp; If no register
set is specified, register AL will be used.
<DT>2-byte
<DD>For 2-byte return values, only the following registers are allowed:&nbsp; AX, DX, BX, CX, SI or DI.&nbsp; If no register set
is specified, register AX will be used.
<DT>4-byte
<DD>For 4-byte return values (except far pointers), only the following register pairs are allowed:&nbsp; DX:AX, CX:BX, CX:AX,
CX:SI, DX:BX, DI:AX, CX:DI, DX:SI, DI:BX, SI:AX, CX:DX, DX:DI, DI:SI, SI:BX or BX:AX.&nbsp; If no register set is specified,
registers DX:AX will be used.&nbsp; This form of the auxiliary pragma is legal for functions of type<B> REAL</B> when using
the &quot;fpc&quot; option only.
<DT>far pointer
<DD>For functions that return far pointers, the following register pairs are allowed:&nbsp; DX:AX, CX:BX, CX:AX, CX:SI, DX:BX,
DI:AX, CX:DI, DX:SI, DI:BX, SI:AX, CX:DX, DX:DI, DI:SI, SI:BX, BX:AX, DS:CX, DS:DX, DS:DI, DS:SI, DS:BX, DS:AX, ES:CX, ES:DX,
ES:DI, ES:SI, ES:BX or ES:AX.&nbsp; If no register set is specified, the registers DX:AX will be used.
<DT>8-byte
<DD>For 8-byte return values (including functions of type<B> DOUBLE PRECISION</B>), only the following register combination is
allowed:&nbsp; AX:BX:CX:DX.&nbsp; If no register set is specified, the registers AX:BX:CX:DX will be used.&nbsp; This form
of the auxiliary pragma is legal for functions of type<B> DOUBLE PRECISION</B> when using the &quot;fpc&quot; option only.
</DL>
<BR><B>Notes:</B>
<OL>
<LI>An empty register set is not allowed.
<LI>If you are compiling for a memory model which has a small data model, any of the above register combinations containing
register DS becomes illegal.&nbsp; In a small data model, segment register DS must remain unchanged as it points to the program's
data segment.
</OL>
<H4 ID="16Mbit__Returning_Structures_and_Complex_Numbers"> 16-bit:&nbsp; Returning Structures and Complex Numbers </H4>
<BR>Typically, structures and complex numbers are not returned in registers.&nbsp; Instead, the caller allocates space on
the stack for the return value and sets register SI to point to it.&nbsp; The called routine then places the return value
at the location pointed to by register SI.
<BR><BR>Complex numbers are not scalars but rather an ordered pair of real numbers.&nbsp; One can also view complex numbers
as a<B> structure</B> containing two real numbers.
<BR><BR>The following form of the auxiliary pragma can be used to specify the register that is to be used to point to the
return value.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux </TT><B>sym</B><TT> value struct </TT><B>(</B><TT>caller</TT><B>|</B><TT>routine</TT><B>)</B><TT>
</TT><B>reg_set</B><TT> </TT>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a subprogram name.
<DT>reg_set
<DD>is a register set.
</DL>
<BR>&quot;caller&quot; specifies that the caller will allocate memory for the return value.&nbsp; The address of the memory
allocated for the return value is placed in the register specified in the register set by the caller before the function is
called.&nbsp; If an empty register set is specified, the address of the memory allocated for the return value will be pushed
on the stack immediately before the call and will be returned in register AX by the called routine.&nbsp; It is assumed that
the memory for the return value is allocated from the stack segment (the stack segment is contained in segment register SS).
<BR><BR>&quot;routine&quot; specifies that the called routine will allocate memory for the return value.&nbsp; Upon returning
to the caller, the register specified in the register set will contain the address of the return value.&nbsp; An empty register
set is not allowed.
<BR><BR>Only the following registers are allowed in the register set:&nbsp; AX, DX, BX, CX, SI or DI.&nbsp; Note that in a
big data model, the address in the return register is assumed to be in the segment specified by the value in the SS segment
register.
<BR><BR>If the size of the structure being returned is 1, 2 or 4 bytes, it will be returned in registers.&nbsp; The return
register will be selected from the register set in the following way.
<OL>
<LI>A 1-byte structure will be returned in one of the following registers:&nbsp; AL, AH, DL, DH, BL, BH, CL or CH.&nbsp; If
no register set is specified, register AL will be used.
<LI>A 2-byte structure will be returned in one of the following registers:&nbsp; AX, DX, BX, CX, SI or DI.&nbsp; If no register
set is specified, register AX will be used.
<LI>A 4-byte structure will be returned in one of the following register pairs:&nbsp; DX:AX, CX:BX, CX:AX, CX:SI, DX:BX, DI:AX,
CX:DI, DX:SI, DI:BX, SI:AX, CX:DX, DX:DI, DI:SI, SI:BX or BX:AX.&nbsp; If no register set is specified, register pair DX:AX
will be used.
</OL>
<BR>The following form of the auxiliary pragma can be used to specify that structures whose size is 1, 2 or 4 bytes are not
to be returned in registers.&nbsp; Instead, the caller will allocate space on the stack for the structure return value and
point register SI to it.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux </TT><B>sym</B><TT> value struct struct </TT>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a subprogram name.
</DL>
<H4 ID="16Mbit__Returning_FloatingMPoint_Data"> 16-bit:&nbsp; Returning Floating-Point Data </H4>
<BR>There are a few ways available for specifying how the value for a function whose type is<B> REAL</B> or<B> DOUBLE PRECISION</B>
is to be returned.
<BR><BR>The following form of the auxiliary pragma can be used to specify that function return values whose type is<B> REAL</B>
or<B> DOUBLE PRECISION</B> are not to be returned in registers.&nbsp; Instead, the caller will allocate space on the stack
for the return value and point register SI to it.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux </TT><B>sym</B><TT> value struct float </TT>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a function name.
</DL>
<BR>In other words, floating-point values are to be returned in the same way complex numbers are returned.
<BR><BR>The following form of the auxiliary pragma can be used to specify that function return values whose type is<B> REAL</B>
or<B> DOUBLE PRECISION</B> are not to be returned in 80x87 registers when compiling with the &quot;fpi&quot; or &quot;fpi87&quot;
option.&nbsp; Instead, the value will be returned in 80x86 registers.&nbsp; This is the default behaviour for the &quot;fpc&quot;
option.&nbsp; Function return values whose type is<B> REAL</B> will be returned in registers DX:AX.&nbsp; Function return
values whose type is<B> DOUBLE PRECISION</B> will be returned in registers AX:BX:CX:DX.&nbsp; This is the default method for
the &quot;fpc&quot; option.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux </TT><B>sym</B><TT> value no8087 </TT>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a function name.
</DL>
<BR>The following form of the auxiliary pragma can be used to specify that function return values whose type is<B> REAL</B>
or<B> DOUBLE PRECISION</B> are to be returned in ST(0) when compiling with the &quot;fpi&quot; or &quot;fpi87&quot; option.
&nbsp;This form of the auxiliary pragma is not legal for the &quot;fpc&quot; option.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux </TT><B>sym</B><TT> value [8087] </TT>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a function name.
</DL>
<H3 ID="16Mbit__A_Subprogram_that_Never_Returns"> 16-bit:&nbsp; A Subprogram that Never Returns </H3>
<BR>The following form of the auxiliary pragma can be used to describe a subprogram that does not return to the caller.&nbsp;

<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux </TT><B>sym</B><TT> aborts </TT>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a subprogram name.
</DL>
<BR>Consider the following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux exitrtn aborts</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call exitrtn()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR><TT>exitrtn</TT> is defined to be a function that does not return.&nbsp; For example, it may call<TT> exit</TT> to
return to the system.&nbsp; In this case, Open Watcom F77 generates a &quot;jmp&quot; instruction instead of a &quot;call&quot;
instruction to invoke<TT> exitrtn.</TT>
<H3 ID="16Mbit__Describing_How_Subprograms_Use_Variables_in_Common"> 16-bit:&nbsp; Describing How Subprograms Use Variables in Common </H3>
<BR>The following form of the auxiliary pragma can be used to describe a subprogram that does not modify any variable that
appears in a common block defined by the caller.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux </TT><B>sym</B><TT> modify nomemory </TT>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a subprogram name.
</DL>
<BR>Consider the following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer i</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; common /blk/ i</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( i .lt. 1000 )do</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = i + 383</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endwhile</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call myrtn()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = i + 13143</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; block data</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; common /blk/ i</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer i/1033/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>To compile the above program, &quot;rtn.for&quot;, we issue the following command.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wfc rtn -mm -d1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wfc386 rtn -d1</TT>
<BR><BR>The &quot;d1&quot; compiler option is specified so that the object file produced by Open Watcom F77 contains source
line information.
<BR><BR>We can generate a file containing a disassembly of<TT> rtn.obj</TT> by issuing the following command.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wdis rtn -l -s -r</TT>
<BR><BR>The &quot;s&quot; option is specified so that the listing file produced by the Open Watcom Disassembler contains source
lines taken from<TT> rtn.for.</TT>&nbsp; The listing file<TT> rtn.lst</TT> appears as follows.
<BR><BR>Let us add the following auxiliary pragma to the source file.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux myrtn modify nomemory</TT>
<BR><BR>If we compile the source file with the above pragma and disassemble the object file using the Open Watcom Disassembler,
we get the following listing file.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Module: rtn.for</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Group: 'DGROUP' _DATA,LDATA,CDATA,BLK</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Segment: 'FMAIN_TEXT' BYTE&nbsp; 00000024 bytes</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux myrtn modify nomemory</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 i</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; common /blk/ i</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0000&nbsp; 52&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; FMAIN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; dx</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0001&nbsp; 8b 16 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; dx,L3</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( i .lt. 1000 )do</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0005&nbsp; 81 fa e8 03&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; L1&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmp&nbsp;&nbsp;&nbsp;&nbsp; dx,03e8H</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0009&nbsp; 7d 06&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jge&nbsp;&nbsp;&nbsp;&nbsp;
L2</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = i + 383</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endwhile</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 000b&nbsp; 81 c2 7f 01&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add&nbsp;&nbsp;&nbsp;&nbsp; dx,017fH</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 000f&nbsp; eb f4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jmp&nbsp;&nbsp;&nbsp;&nbsp;
L1</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call myrtn()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0011&nbsp; 89 16 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; L2&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; L3,dx</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0015&nbsp; 9a 00 00 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call&nbsp;&nbsp;&nbsp; far MYRTN</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = i + 13143</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 001a&nbsp; 81 c2 57 33&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add&nbsp;&nbsp;&nbsp;&nbsp; dx,3357H</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 001e&nbsp; 89 16 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; L3,dx</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; block data</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; common /blk/ i</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 i/1033/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0022&nbsp; 5a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;
&nbsp; dx</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0023&nbsp; cb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; retf</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; No disassembly errors</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; List of external symbols</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Symbol</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ----------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; MYRTN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 00000016</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ------------------------------------------------------------</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Segment: 'BLK' PARA&nbsp; 00000002 bytes</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0000&nbsp; 09 04&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; L3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - ..</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; No disassembly errors</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ------------------------------------------------------------</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; List of public symbols</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SYMBOL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GROUP&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SEGMENT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ADDRESS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ---------------------------------------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; FMAIN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FMAIN_TEXT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 00000000</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ------------------------------------------------------------</TT>
<BR><BR>Notice that the value of<TT> i</TT> is in register DX after completion of the &quot;while&quot; loop.&nbsp; After
the call to<TT> myrtn,</TT> the value of<TT> i</TT> is not loaded from memory into a register to perform the final addition.
&nbsp;The auxiliary pragma informs the compiler that<TT> myrtn</TT> does not modify any variable that appears in a common
block defined by<TT> Rtn</TT> and hence register DX contains the correct value of<TT> i.</TT>
<BR><BR>The preceding auxiliary pragma deals with routines that modify variables in common.&nbsp; Let us consider the case
where routines reference variables in common.&nbsp; The following form of the auxiliary pragma can be used to describe a subprogram
that does not reference any variable that appears in a common block defined by the caller.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux </TT><B>sym</B><TT> parm nomemory modify nomemory </TT>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a subprogram name.
</DL>
<BR><B>Notes:</B>
<OL>
<LI>You must specify both &quot;parm nomemory&quot; and &quot;modify nomemory&quot;.
</OL>
<BR>Let us replace the auxiliary pragma in the above example with the following auxiliary pragma.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux myrtn parm nomemory modify nomemory</TT>
<BR><BR>If you now compile our source file and disassemble the object file using WDIS, the result is the following listing
file.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Module: rtn.for</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Group: 'DGROUP' _DATA,LDATA,CDATA,BLK</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Segment: 'FMAIN_TEXT' BYTE&nbsp; 00000020 bytes</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux myrtn parm nomemory modify nomemory</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 i</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; common /blk/ i</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0000&nbsp; 52&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; FMAIN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; dx</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0001&nbsp; 8b 16 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; dx,L3</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( i .lt. 1000 )do</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0005&nbsp; 81 fa e8 03&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; L1&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmp&nbsp;&nbsp;&nbsp;&nbsp; dx,03e8H</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0009&nbsp; 7d 06&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jge&nbsp;&nbsp;&nbsp;&nbsp;
L2</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = i + 383</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endwhile</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 000b&nbsp; 81 c2 7f 01&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add&nbsp;&nbsp;&nbsp;&nbsp; dx,017fH</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 000f&nbsp; eb f4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jmp&nbsp;&nbsp;&nbsp;&nbsp;
L1</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call myrtn()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0011&nbsp; 9a 00 00 00 00&nbsp;&nbsp;&nbsp; L2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call&nbsp;&nbsp;&nbsp; far MYRTN</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = i + 13143</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0016&nbsp; 81 c2 57 33&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add&nbsp;&nbsp;&nbsp;&nbsp; dx,3357H</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 001a&nbsp; 89 16 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; L3,dx</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; block data</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; common /blk/ i</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 i/1033/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 001e&nbsp; 5a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;
&nbsp; dx</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 001f&nbsp; cb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; retf</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; No disassembly errors</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; List of external symbols</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Symbol</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ----------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; MYRTN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 00000012</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ------------------------------------------------------------</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Segment: 'BLK' PARA&nbsp; 00000002 bytes</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0000&nbsp; 09 04&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; L3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - ..</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; No disassembly errors</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ------------------------------------------------------------</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; List of public symbols</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SYMBOL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GROUP&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SEGMENT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ADDRESS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ---------------------------------------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; FMAIN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FMAIN_TEXT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 00000000</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ------------------------------------------------------------</TT>
<BR><BR>Notice that after completion of the &quot;while&quot; loop we did not have to update<TT> i</TT> with the value in
register DX before calling<TT> myrtn.</TT>&nbsp; The auxiliary pragma informs the compiler that<TT> myrtn</TT> does not reference
any variable that appears in a common block defined by<TT> myrtn</TT> so updating<TT> i</TT> was not necessary before calling<TT>
myrtn.</TT>
<H3 ID="16Mbit__Describing_the_Registers_Modified_by_a_Subprogram"> 16-bit:&nbsp; Describing the Registers Modified by a Subprogram </H3>
<BR>The following form of the auxiliary pragma can be used to describe the registers that a subprogram will use without saving.
&nbsp;
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux </TT><B>sym</B><TT> modify </TT><B>[</B><TT>exact</TT><B>]</B><TT> </TT><B>reg_set</B><TT>
</TT>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a subprogram name.
<DT>reg_set
<DD>is a register set.
</DL>
<BR>Specifying a register set informs Open Watcom F77 that the registers belonging to the register set are modified by the
subprogram.&nbsp; That is, the value in a register before calling the subprogram is different from its value after execution
of the subprogram.
<BR><BR>Registers that are used to pass arguments are assumed to be modified and hence do not have to be saved and restored
by the called subprogram.&nbsp; Also, since the AX register is frequently used to return a value, it is always assumed to
be modified.&nbsp; If necessary, the caller will contain code to save and restore the contents of registers used to pass arguments.
&nbsp;Note that saving and restoring the contents of these registers may not be necessary if the called subprogram does not
modify them.&nbsp; The following form of the auxiliary pragma can be used to describe exactly those registers that will be
modified by the called subprogram.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux </TT><B>sym</B><TT> modify exact </TT><B>reg_set</B><TT> </TT>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a subprogram name.
<DT>reg_set
<DD>is a register set.
</DL>
<BR>The above form of the auxiliary pragma tells Open Watcom F77 not to assume that the registers used to pass arguments will
be modified by the called subprogram.&nbsp; Instead, only the registers specified in the register set will be modified.&nbsp;
This will prevent generation of the code which unnecessarily saves and restores the contents of the registers used to pass
arguments.
<BR><BR>Also, any registers that are specified in the<TT> value</TT> register set are assumed to be unmodified unless explicitly
listed in the<TT> exact</TT> register set.&nbsp; In the following example, the code generator will not generate code to save
and restore the value of the stack pointer register since we have told it that &quot;GetSP&quot; does not modify any register
whatsoever.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$ifdef __386__</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux GetSP = value [esp] modify exact []</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux GetSP = value [sp] modify exact []</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$endif</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; program main</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer GetSP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, 'Current SP =', GetSP()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<H3 ID="16Mbit__Auxiliary_Pragmas_and_the_80x87"> 16-bit:&nbsp; Auxiliary Pragmas and the 80x87 </H3>
<BR>This section deals with those aspects of auxiliary pragmas that are specific to the 80x87.&nbsp; The discussion in this
chapter assumes that one of the &quot;fpi&quot; or &quot;fpi87&quot; options is used to compile subprograms.&nbsp; The following
areas are affected by the use of these options.
<OL>
<LI>passing floating-point arguments to functions,
<LI>returning floating-point values from functions and
<LI>which 80x87 floating-point registers are allowed to be modified by the called routine.
</OL>
<H4 ID="16Mbit__Using_the_80x87_to_Pass_Arguments"> 16-bit:&nbsp; Using the 80x87 to Pass Arguments </H4>
<BR>By default, floating-point arguments are passed on the 80x86 stack.&nbsp; The 80x86 registers are never used to pass floating-point
arguments when a subprogram is compiled with the &quot;fpi&quot; or &quot;fpi87&quot; option.&nbsp; However, they can be used
to pass arguments whose type is not floating-point such as arguments of type &quot;int&quot;.
<BR><BR>The following form of the auxiliary pragma can be used to describe the registers that are to be used to pass arguments
to subprograms.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux </TT><B>sym</B><TT> parm </TT><B>{reg_set}</B><TT> </TT>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a subprogram name.
<DT>reg_set
<DD>is a register set.&nbsp; The register set can contain 80x86 registers and/or the string &quot;8087&quot;.
</DL>
<BR><B>Notes:</B>
<OL>
<LI>If an empty register set is specified, all arguments, including floating-point arguments, will be passed on the 80x86
stack.
</OL>
<BR>When the string &quot;8087&quot; appears in a register set, it simply means that floating-point arguments can be passed
in 80x87 floating-point registers if the source file is compiled with the &quot;fpi&quot; or &quot;fpi87&quot; option.&nbsp;
Before discussing argument passing in detail, some general notes on the use of the 80x87 floating-point registers are given.
<BR><BR>The 80x87 contains 8 floating-point registers which essentially form a stack.&nbsp; The stack pointer is called ST
and is a number between 0 and 7 identifying which 80x87 floating-point register is at the top of the stack.&nbsp; ST is initially
0.&nbsp; 80x87 instructions reference these registers by specifying a floating-point register number.&nbsp; This number is
then added to the current value of ST.&nbsp; The sum (taken modulo 8) specifies the 80x87 floating-point register to be used.
&nbsp;The notation ST(n), where &quot;n&quot; is between 0 and 7, is used to refer to the position of an 80x87 floating-point
register relative to ST.
<BR><BR>When a floating-point value is loaded onto the 80x87 floating-point register stack, ST is decremented (modulo 8),
and the value is loaded into ST(0).&nbsp; When a floating-point value is stored and popped from the 80x87 floating-point register
stack, ST is incremented (modulo 8) and ST(1) becomes ST(0).&nbsp; The following illustrates the use of the 80x87 floating-point
registers as a stack, assuming that the value of ST is 4 (4 values have been loaded onto the 80x87 floating-point register
stack).
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; | 4th from top&nbsp;&nbsp;
|&nbsp; ST(4)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp; | 5th from top&nbsp;&nbsp;
|&nbsp; ST(5)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp; | 6th from top&nbsp;&nbsp;
|&nbsp; ST(6)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp; | 7th from top&nbsp;&nbsp;
|&nbsp; ST(7)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ST -&gt; 4&nbsp;&nbsp;&nbsp;&nbsp; | top of stack&nbsp;&nbsp; |&nbsp; ST(0)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5&nbsp;&nbsp;&nbsp;&nbsp; | 1st from top&nbsp;&nbsp;
|&nbsp; ST(1)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6&nbsp;&nbsp;&nbsp;&nbsp; | 2nd from top&nbsp;&nbsp;
|&nbsp; ST(2)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7&nbsp;&nbsp;&nbsp;&nbsp; | 3rd from top&nbsp;&nbsp;
|&nbsp; ST(3)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><BR>Starting with version 9.5, the Open Watcom compilers use all eight of the 80x87 registers as a stack.&nbsp; The initial
state of the 80x87 register stack is empty before a program begins execution.
<DL>
<DT>Note:
<DD>For compatibility with code compiled with version 9.0 and earlier, you can compile with the &quot;fpr&quot; option.&nbsp;
In this case only four of the eight 80x87 registers are used as a stack.&nbsp; These four registers were used to pass arguments.
&nbsp;The other four registers form what was called the 80x87 cache.&nbsp; The cache was used for local floating-point variables.
&nbsp;The state of the 80x87 registers before a program began execution was as follows.
<OL>
<LI>The four 80x87 floating-point registers that form the stack are uninitialized.
<LI>The four 80x87 floating-point registers that form the 80x87 cache are initialized with zero.
</OL>
<BR>Hence, initially the 80x87 cache was comprised of ST(0), ST(1), ST(2) and ST(3).&nbsp; ST had the value 4 as in the above
diagram.&nbsp; When a floating-point value was pushed on the stack (as is the case when passing floating-point arguments),
it became ST(0) and the 80x87 cache was comprised of ST(1), ST(2), ST(3) and ST(4).&nbsp; When the 80x87 stack was full, ST(0),
ST(1), ST(2) and ST(3) formed the stack and ST(4), ST(5), ST(6) and ST(7) formed the 80x87 cache.&nbsp; Version 9.5 and later
no longer use this strategy.
</DL>
<BR>The rules for passing arguments are as follows.
<OL>
<LI>If the argument is not floating-point, use the procedure described earlier in this chapter.
<LI>If the argument is floating-point, and a previous argument has been assigned a position on the 80x86 stack (instead of
the 80x87 stack), the floating-point argument is also assigned a position on the 80x86 stack.&nbsp; Otherwise proceed to the
next step.
<LI>If the string &quot;8087&quot; appears in a register set in the pragma, and if the 80x87 stack is not full, the floating-point
argument is assigned floating-point register ST(0) (the top element of the 80x87 stack).&nbsp; The previous top element (if
there was one) is now in ST(1).&nbsp; Since arguments are pushed on the stack from right to left, the leftmost floating-point
argument will be in ST(0).&nbsp; Otherwise the floating-point argument is assigned a position on the 80x86 stack.
</OL>
<BR>Consider the following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux myrtn parm (value) [8087];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real x</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double precision y</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 i</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer j</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = 7.7</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = 7</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y = 77.77</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j = 77</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call myrtn( x, i, y, j )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR><TT>myrtn</TT> is an assembly language subprogram that requires four arguments.&nbsp; The first argument of type<B>
REAL</B> (4 bytes), the second argument is of type<B> INTEGER*2</B> (2 bytes), the third argument is of type<B> DOUBLE PRECISION</B>
(8 bytes) and the fourth argument is of type<B> INTEGER*4</B> (4 bytes).&nbsp; These arguments will be passed to<TT> myrtn</TT>
in the following way.
<OL>
<LI>Since &quot;8087&quot; was specified in the register set, the first argument, being of type<B> REAL</B>, will be passed
in an 80x87 floating-point register.
<LI>The second argument will be passed on the stack since no 80x86 registers were specified in the register set.
<LI>The third argument will also be passed on the stack.&nbsp; Remember the following rule:&nbsp; once an argument is assigned
a position on the stack, all remaining arguments will be assigned a position on the stack.&nbsp; Note that the above rule
holds even though there are some 80x87 floating-point registers available for passing floating-point arguments.
<LI>The fourth argument will also be passed on the stack.
</OL>
<BR>Let us change the auxiliary pragma in the above example as follows.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux myrtn parm [ax 8087]</TT>
<BR><BR>The arguments will now be passed to<TT> myrtn</TT> in the following way.
<OL>
<LI>Since &quot;8087&quot; was specified in the register set, the first argument, being of type<B> REAL</B> will be passed
in an 80x87 floating-point register.
<LI>The second argument will be passed in register AX, exhausting the set of available 80x86 registers for argument passing.
<LI>The third argument, being of type<B> DOUBLE PRECISION</B>, will also be passed in an 80x87 floating-point register.
<LI>The fourth argument will be passed on the stack since no 80x86 registers remain in the register set.
</OL>
<H4 ID="16Mbit__Using_the_80x87_to_Return_Subprogram_Values"> 16-bit:&nbsp; Using the 80x87 to Return Subprogram Values </H4>
<BR>The following form of the auxiliary pragma can be used to describe a subprogram that returns a floating-point value in
ST(0).&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux </TT><B>sym</B><TT> value </TT><B>reg_set</B><TT> </TT>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a subprogram name.
<DT>reg_set
<DD>is a register set containing the string &quot;8087&quot;, i.e.&nbsp; [8087].
</DL>
<H4 ID="16Mbit__Preserving_80x87_FloatingMPoint_Registers_Across_Calls"> 16-bit:&nbsp; Preserving 80x87 Floating-Point Registers Across Calls </H4>
<BR>The code generator assumes that all eight 80x87 floating-point registers are available for use within a subprogram unless
the &quot;fpr&quot; option is used to generate backward compatible code (older Open Watcom compilers used four registers as
a cache).&nbsp; The following form of the auxiliary pragma specifies that the floating-point registers in the 80x87 cache
may be modified by the specified subprogram.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux </TT><B>sym</B><TT> modify </TT><B>reg_set</B><TT> </TT>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a subprogram name.
<DT>reg_set
<DD>is a register set containing the string &quot;8087&quot;, i.e.&nbsp; [8087].
</DL>
<BR>This instructs Open Watcom F77 to save any local variables that are located in the 80x87 cache before calling the specified
routine.
<H1 ID="32Mbit_Memory_Models"> 32-bit Memory Models </H1>
<BR><BR>This chapter describes the various 32-bit memory models supported by Open Watcom F77.&nbsp; Each memory model is distinguished
by two properties; the code model used to implement subprogram calls and the data model used to reference data.
<H2 ID="32Mbit_Code_Models"> 32-bit Code Models </H2>
<BR>There are two code models;
<OL>
<LI>the small code model and
<LI>the big code model.
</OL>
<BR>A small code model is one in which all calls to subprograms are made with<B> near calls.</B>&nbsp; In a near call, the
destination address is 32 bits and is relative to the segment value in segment register CS.&nbsp; Hence, in a small code model,
all code comprising your program, including library subprograms, must be less than 4GB.
<BR><BR>A big code model is one in which all calls to subprograms are made with<B> far calls.</B>&nbsp; In a far call, the
destination address is 48 bits (a 16-bit segment value and a 32-bit offset relative to the segment value).&nbsp; This model
allows the size of the code comprising your program to exceed 4GB.
<HR>
<BR><B><I>&nbsp; Note:</I></B>&nbsp; If your program contains less than 4GB of code, you should use a memory model that employs
the small code model.&nbsp; This will result in smaller and faster code since near calls are smaller instructions and are
processed faster by the CPU.
<HR>
<H2 ID="32Mbit_Data_Models"> 32-bit Data Models </H2>
<BR>There are two data models;
<OL>
<LI>the small data model and
<LI>the big data model.
</OL>
<BR>A small data model is one in which all references to data are made with<B> near pointers.</B>&nbsp; Near pointers are
32 bits; all data references are made relative to the segment value in segment register DS.&nbsp; Hence, in a small data model,
all data comprising your program must be less than 4GB.
<BR><BR>A big data model is one in which all references to data are made with<B> far pointers.</B>&nbsp; Far pointers are
48 bits (a 16-bit segment value and a 32-bit offset relative to the segment value).&nbsp; This removes the 4GB limitation
on data size imposed by the small data model.&nbsp; However, when a far pointer is incremented, only the offset is adjusted.
&nbsp;Open Watcom F77 assumes that the offset portion of a far pointer will not be incremented beyond 4GB.&nbsp; The compiler
will assign an object to a new segment if the grouping of data in a segment will cause the object to cross a segment boundary.
&nbsp;Implicit in this is the requirement that no individual object exceed 4GB.
<HR>
<BR><B><I>&nbsp; Note:</I></B>&nbsp; If your program contains less than 4GB of data, you should use the small data model.
&nbsp;This will result in smaller and faster code since references using near pointers produce fewer instructions.
<HR>
<H2 ID="Summary_of_32Mbit_Memory_Models"> Summary of 32-bit Memory Models </H2>
<BR>As previously mentioned, a memory model is a combination of a code model and a data model.&nbsp; The following table describes
the memory models supported by Open Watcom F77.&nbsp; 
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Memory&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Code&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Data
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Default&nbsp;&nbsp;&nbsp;&nbsp; Default</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Model&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Model&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Model
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Code&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Data</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Pointer
&nbsp;&nbsp;&nbsp; Pointer</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; --------&nbsp;&nbsp;&nbsp; --------&nbsp;&nbsp;&nbsp; --------&nbsp;&nbsp;&nbsp; --------
&nbsp;&nbsp; --------</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; flat&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; small&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
small&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; near&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; near</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; small&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; small&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; small
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; near&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; near</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; medium&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; big&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
small&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; far&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; near</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; compact&nbsp;&nbsp;&nbsp;&nbsp; small&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; big&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; near&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; far</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; large&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; big&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;big&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; far&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; far</TT>
<H2 ID="Flat_Memory_Model"> Flat Memory Model </H2>
<BR>In the flat memory model, the application's code and data must total less than 4GB in size.&nbsp; Segment registers CS,
DS, SS and ES point to the same linear address space (this does not imply that the segment registers contain the same value).
&nbsp;That is, a given offset in one segment refers to the same memory location as that offset in another segment.&nbsp; Essentially,
a flat model operates as if there were no segments.
<H2 ID="Mixed_32Mbit_Memory_Model"> Mixed 32-bit Memory Model </H2>
<BR>A mixed memory model application combines elements from the various code and data models.&nbsp; A mixed memory model application
might be characterized as one that includes arrays which are larger than 4GB.
<BR><BR>For example, a medium memory model application that uses some arrays which exceed 4GB in total size can be described
as a mixed memory model.&nbsp; In an application such as this, most of the data is in a 4GB segment (DGROUP) and hence can
be referenced with near pointers relative to the segment value in segment register DS.&nbsp; This results in more efficient
code being generated and better execution times than one can expect from a big data model.
<H2 ID="Linking_Applications_for_the_Various_32Mbit_Memory_Models"> Linking Applications for the Various 32-bit Memory Models </H2>
<BR>Each memory model requires different run-time and floating-point libraries.&nbsp; Each library assumes a particular memory
model and should be linked only with modules that have been compiled with the same memory model.&nbsp; The following table
lists the libraries that are to be used to link an application that has been compiled for a particular memory model.&nbsp;
Currently, only libraries for the flat/small memory model are provided.&nbsp; The following table lists the run-time libraries
used by FORTRAN 77 and the compiler options that cause their use.
<OL>
<LI>The &quot;Library&quot; column specified the library name.
<LI>The &quot;Memory model&quot; column indicates the compiler options that specify the memory model of the library.
<LI>The &quot;Floating-point column&quot; indicates the compiler options that specify the floating-point model of the library.
<LI>The &quot;Calling convention&quot; column indicates the compiler option that specifies the calling convention of the library
(register-based or stack-based).
</OL>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Library&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Memory&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Floating-point&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Calling</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;model&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; model&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; convention</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -------&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ------&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
--------------&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ----------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; flib.lib&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /mf, /ms&nbsp;&nbsp;&nbsp; /fpc</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; flibs.lib&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /mf, /ms&nbsp;&nbsp;&nbsp; /fpc&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /sc</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; flib7.lib&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /mf, /ms&nbsp;&nbsp;&nbsp; /fpi, /fpi87</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; flib7s.lib&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /mf, /ms&nbsp;&nbsp;&nbsp; /fpi, /fpi87&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /sc</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; clib3r.lib&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /mf, /ms&nbsp;&nbsp;&nbsp; /fpc, /fpi, /fpi87</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; clib3r.lib&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /mf, /ms&nbsp;&nbsp;&nbsp; /fpc, /fpi, /fpi87&nbsp;
&nbsp; /sc</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; math387r.lib&nbsp;&nbsp;&nbsp; /mf, /ms&nbsp;&nbsp;&nbsp; /fpi, /fpi87</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; math387s.lib&nbsp;&nbsp;&nbsp; /mf, /ms&nbsp;&nbsp;&nbsp; /fpi, /fpi87&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /sc</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; math3r.lib&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /mf, /ms&nbsp;&nbsp;&nbsp; /fpc</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; math3s.lib&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /mf, /ms&nbsp;&nbsp;&nbsp; /fpc&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /sc</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; emu387.lib&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /mf, /ms&nbsp;&nbsp;&nbsp; /fpi</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; noemu387.lib&nbsp;&nbsp;&nbsp; /mf, /ms&nbsp;&nbsp;&nbsp; /fpi87</TT>
<H2 ID="32Mbit_Memory_Layout"> 32-bit Memory Layout </H2>
<BR>The following describes the segment ordering of an application linked by the Open Watcom Linker.&nbsp; Note that this
assumes that the &quot;DOSSEG&quot; linker option has been specified.&nbsp; 
<OL>
<LI>all &quot;USE16&quot; segments.&nbsp; These segments are present in applications that execute in both real mode and protected
mode.&nbsp; They are first in the segment ordering so that the &quot;REALBREAK&quot; option of the &quot;RUNTIME&quot; directive
can be used to separate the real-mode part of the application from the protected-mode part of the application.&nbsp; Currently,
the &quot;RUNTIME&quot; directive is valid for Phar Lap executables only.
<LI>all segments not belonging to group &quot;DGROUP&quot; with class &quot;CODE&quot;
<LI>all other segments not belonging to group &quot;DGROUP&quot;
<LI>all segments belonging to group &quot;DGROUP&quot; with class &quot;BEGDATA&quot;
<LI>all segments belonging to group &quot;DGROUP&quot; not with class &quot;BEGDATA&quot;, &quot;BSS&quot; or &quot;STACK&quot;
<LI>all segments belonging to group &quot;DGROUP&quot; with class &quot;BSS&quot;
<LI>all segments belonging to group &quot;DGROUP&quot; with class &quot;STACK&quot;
</OL>
<BR>Segments belonging to class &quot;BSS&quot; contain uninitialized data.&nbsp; Note that this only includes uninitialized
data in segments belonging to group &quot;DGROUP&quot;.&nbsp; Segments belonging to class &quot;STACK&quot; are used to define
the size of the stack used for your application.&nbsp; Segments belonging to the classes &quot;BSS&quot; and &quot;STACK&quot;
are last in the segment ordering so that uninitialized data need not take space in the executable file.
<BR><BR>In addition to these special segments, the following conventions are used by Open Watcom F77.
<OL>
<LI>The &quot;CODE&quot; class contains the executable code for your application.&nbsp; In a small code model, this consists
of the segment &quot;_TEXT&quot;.&nbsp; In a big code model, this consists of the segments &quot;&lt;subprogram&gt;_TEXT&quot;
where &lt;subprogram&gt; is the name of a subprogram.
<LI>The &quot;FAR_DATA&quot; class consists of the following:
<DL>
<DT>(a)
<DD>arrays whose size exceeds the data threshold in large data memory models (the data threshold is 256 bytes unless changed using
the &quot;dt&quot; compiler option)
<DT>(b)
<DD>equivalenced variables in large data memory models
</DL>
</OL>
<H1 ID="32Mbit_Assembly_Language_Considerations"> 32-bit Assembly Language Considerations </H1>
<BR>This chapter will deal with the following topics.
<OL>
<LI>The memory layout of a program compiled by Open Watcom F77.
<LI>The method for passing arguments and returning values.
<LI>The two methods for passing floating-point arguments and returning floating-point values.
<BR><BR>One method is used when one of the Open Watcom F77 &quot;fpi&quot;, &quot;fpi87&quot; or &quot;fpi287&quot; options
is specified for the generation of in-line 80x87 instructions.&nbsp; When the &quot;fpi&quot; option is specified, an 80x87
emulator is included from a math library if the application includes floating-point operations.&nbsp; When the &quot;fpi87&quot;
or &quot;fpi287&quot; option is used exclusively, the 80x87 emulator will not be included.
<BR><BR>The other method is used when the Open Watcom F77 &quot;fpc&quot; option is specified.&nbsp; In this case, the compiler
generates calls to floating-point support routines in the alternate math libraries.
</OL>
<BR>An understanding of the Intel 80x86 architecture is assumed.
<H2 ID="32Mbit__Calling_Conventions"> 32-bit:&nbsp; Calling Conventions </H2>
<BR>The following sections describe the method used by Open Watcom F77 to pass arguments.
<BR><BR>The FORTRAN 77 language specifically requires that arguments be passed by reference.&nbsp; This means that instead
of passing the value of an argument, its address is passed.&nbsp; This allows a called subprogram to modify the value of the
actual arguments.&nbsp; The following illustrates the method used to pass arguments.
<BR><BR> Type of Argument&nbsp;&nbsp;&nbsp; Method Used to Pass Argument
<BR><BR> non-character&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR>constant&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; address of constant 
<BR> non-character&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR>expression&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; address of value of expression
<BR> non-character&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR>variable&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; address of variable 
<BR> character constant&nbsp; address of string descriptor
<BR> character&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR>expression&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; address of string descriptor
<BR> character variable&nbsp; address of string descriptor
<BR> non-character array address of array&nbsp;&nbsp;&nbsp; 
<BR> non-character array&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; 
<BR>element&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; address of array&nbsp;&nbsp;&nbsp;

<BR> character array&nbsp;&nbsp;&nbsp;&nbsp; address of string descriptor
<BR> character array&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR>element&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; address of string descriptor
<BR> character substring address of string descriptor
<BR> subprogram&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; address of subprogram
<BR> alternate return&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR>specifier&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; no argument passed&nbsp; 
<BR> user-defined&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR>structure&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; address of structure
<BR><BR>When passing a character array as an argument, the string descriptor contains the address of the first element of
the array and the length of an element of the array.
<BR><BR>The address of arguments are either passed in registers or on the stack.&nbsp; The registers used to pass the address
of arguments to a subprogram are EAX, EBX, ECX and EDX.&nbsp; The address of arguments are passed in the following way.
<OL>
<LI>The first argument is passed in register EAX, the second argument is passed in register EDX, the third argument is passed
in register EBX, and the fourth argument is passed in register ECX.
<LI>For any remaining arguments, their address is passed on the stack.&nbsp; Note that addresses of arguments are pushed on
the stack from right to left.
</OL>
<H3 ID="32Mbit__StackMBased_Calling_Convention"> 32-bit:&nbsp; Stack-Based Calling Convention </H3>
<BR>The previous section described a register-based calling convention in which registers were used to pass arguments to subprograms.
&nbsp;A stack-based calling convention is another method that can be used to pass arguments.&nbsp; The calling convention
is selected when the &quot;sc&quot; compiler option is specified.
<BR><BR>The most significant difference between the stack-based calling convention and the register-based calling convention
is the way the arguments are passed.&nbsp; When using the stack-based calling conventions, no registers are used to pass arguments.
&nbsp;Instead, all arguments are passed on the stack.
<H3 ID="32Mbit__Processing_Function_Return_Values_with_no_80x87"> 32-bit:&nbsp; Processing Function Return Values with no 80x87 </H3>
<BR>The way in which function values are returned is also dependent on the data type of the function.&nbsp; The following
describes the method used to return function values.
<OL>
<LI><B> LOGICAL*1</B> values are returned in register AL.
<LI><B> LOGICAL*4</B> values are returned in register EAX.
<LI><B> INTEGER*1</B> values are returned in register AL.
<LI><B> INTEGER*2</B> values are returned in register AX.
<LI><B> INTEGER*4</B> values are returned in register EAX.
<LI><B> REAL*4</B> values are returned in register EAX.
<LI><B> REAL*8</B> values are returned in registers EDX:EAX.
<LI>For<B> COMPLEX*8</B> functions, space is allocated on the stack by the caller for the return value.&nbsp; Register ESI
is set to point to the destination of the result.&nbsp; The called function places the result at the location pointed to by
register ESI.
<LI>For<B> COMPLEX*16</B> functions, space is allocated on the stack by the caller for the return value.&nbsp; Register ESI
is set to point to the destination of the result.&nbsp; The called function places the result at the location pointed to by
register ESI.
<LI>For<B> CHARACTER</B> functions, an additional argument is passed.&nbsp; This argument is the address of the string descriptor
for the result.&nbsp; Note that the address of the string descriptor can be passed in any of the registers that are used to
pass actual arguments.
<LI>For functions that return a user-defined structure, space is allocated on the stack by the caller for the return value.
&nbsp;Register ESI is set to point to the destination of the result.&nbsp; The called function places the result at the location
pointed to by register ESI.&nbsp; Note that a structure of size 1, 2 or 4 bytes is returned in register AL, AX or EAX respectively.
</OL>
<HR>
<BR><B><I>&nbsp; Note:</I></B>&nbsp; The way in which a function returns its value does not change when the stack-based calling
convention is used.
<HR>
<H3 ID="32Mbit__Processing_Function_Return_Values_Using_an_80x87"> 32-bit:&nbsp; Processing Function Return Values Using an 80x87 </H3>
<BR>The following describes the method used to return function values when your application is compiled using the &quot;fpi87&quot;
or &quot;fpi&quot; option.
<OL>
<LI>For<B> REAL*4</B> functions, the result is returned in floating-point register ST(0).
<LI>For<B> REAL*8</B> functions, the result is returned in floating-point register ST(0).
<LI>All other function values are returned in the way described in the previous section.
</OL>
<HR>
<BR><B><I>&nbsp; Note:</I></B>&nbsp; When the stack-based calling convention is used, floating-point values are not returned
using the 80x87.<B>&nbsp; REAL*4</B> values are returned in register EAX.<B>&nbsp; REAL*8</B> values are returned in registers
EDX:EAX.
<HR>
<H3 ID="32Mbit__Processing_Alternate_Returns"> 32-bit:&nbsp; Processing Alternate Returns </H3>
<BR>Alternate returns are processed by the caller and are only allowed in subroutines.&nbsp; The called subroutine places
the value specified in the<B><I> RETURN</I></B> statement in register EAX.&nbsp; Note that the value returned in register
EAX is ignored if there are no alternate return specifiers in the actual argument list.
<HR>
<BR><B><I>&nbsp; Note:</I></B>&nbsp; The way in which a alternate returns are processed does not change when the stack-based
calling convention is used.
<HR>
<H3 ID="32Mbit__Alternate_Method_of_Passing_Character_Arguments"> 32-bit:&nbsp; Alternate Method of Passing Character Arguments </H3>
<BR>As previously described, character arguments are passed using string descriptors.&nbsp; Recall that a string descriptor
contains a pointer to the actual character data and the length of the character data.&nbsp; When passing character data, both
a pointer and length are required by the subprogram being called.&nbsp; When using a string descriptor, this information can
be passed using a single argument, namely the pointer to the string descriptor.
<BR><BR>An alternate method of passing character arguments is also supported and is selected when the &quot;nodescriptor&quot;
option is specified.&nbsp; In this method, the pointer to the character data and the length of the character data are passed
as two separate arguments.&nbsp; The character argument lengths are appended to the end of the actual argument list.
<BR><BR>Let us consider the following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; INTEGER A, C</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER B, D</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CALL SUB( A, B, C, D )</TT>
<BR><BR>In the above example, the first argument is of type INTEGER, the second argument is of type CHARACTER, the third argument
is of type INTEGER, and the fourth argument is of type CHARACTER.&nbsp; If the character arguments were passed by descriptor,
the argument list would resemble the following.
<OL>
<LI>The first argument would be the address of<TT> A.</TT>
<LI>The second argument would be the address of the string descriptor for<TT> B.</TT>
<LI>The third argument would be the address of<TT> C.</TT>
<LI>The fourth argument would be the address of the string descriptor for<TT> D.</TT>
</OL>
<BR>If we specified the &quot;nodescriptor&quot; option, the argument list would be as follows.
<OL>
<LI>The first argument would be the address of<TT> A.</TT>
<LI>The second argument would be the address of the character data for<TT> B.</TT>
<LI>The third argument would be the address of<TT> C.</TT>
<LI>The fourth argument would be the address of the character data for<TT> D.</TT>
<LI>A hidden argument for the length of<TT> B</TT> would be the fifth argument.
<LI>A hidden argument for the length of<TT> D</TT> would be the sixth argument.
</OL>
<BR>Note that the arguments corresponding to the length of the character arguments are passed as INTEGER*4 arguments.
<H4 ID="32Mbit__Character_Functions"> 32-bit:&nbsp; Character Functions </H4>
<BR>By default, when a character function is called, a hidden argument is passed at the end of the actual argument list.&nbsp;
This hidden argument is a pointer to the string descriptor used for the return value of the character function.&nbsp; When
the alternate method of passing character arguments is specified by using the &quot;nodescriptor&quot; option, the string
descriptor for the return value is passed to the function as two hidden arguments, similar to the way character arguments
were passed.&nbsp; However the two hidden arguments for the return value of the character function are placed at the beginning
of the actual argument list.&nbsp; The first argument is the the pointer to the storage immediately followed by the size of
the storage.
<H2 ID="32Mbit__Memory_Layout"> 32-bit:&nbsp; Memory Layout </H2>
<BR>The following describes the segment ordering of an application linked by the Open Watcom Linker.&nbsp; Note that this
assumes that the &quot;DOSSEG&quot; linker option has been specified.&nbsp; 
<OL>
<LI>all &quot;USE16&quot; segments.&nbsp; These segments are present in applications that execute in both real mode and protected
mode.&nbsp; They are first in the segment ordering so that the &quot;REALBREAK&quot; option of the &quot;RUNTIME&quot; directive
can be used to separate the real-mode part of the application from the protected-mode part of the application.&nbsp; Currently,
the &quot;RUNTIME&quot; directive is valid for Phar Lap executables only.
<LI>all segments not belonging to group &quot;DGROUP&quot; with class &quot;CODE&quot;
<LI>all other segments not belonging to group &quot;DGROUP&quot;
<LI>all segments belonging to group &quot;DGROUP&quot; with class &quot;BEGDATA&quot;
<LI>all segments belonging to group &quot;DGROUP&quot; not with class &quot;BEGDATA&quot;, &quot;BSS&quot; or &quot;STACK&quot;
<LI>all segments belonging to group &quot;DGROUP&quot; with class &quot;BSS&quot;
<LI>all segments belonging to group &quot;DGROUP&quot; with class &quot;STACK&quot;
</OL>
<BR>Segments belonging to class &quot;BSS&quot; contain uninitialized data.&nbsp; Note that this only includes uninitialized
data in segments belonging to group &quot;DGROUP&quot;.&nbsp; Segments belonging to class &quot;STACK&quot; are used to define
the size of the stack used for your application.&nbsp; Segments belonging to the classes &quot;BSS&quot; and &quot;STACK&quot;
are last in the segment ordering so that uninitialized data need not take space in the executable file.
<BR><BR>In addition to these special segments, the following conventions are used by Open Watcom F77.
<OL>
<LI>The &quot;CODE&quot; class contains the executable code for your application.&nbsp; In a small code model, this consists
of the segment &quot;_TEXT&quot;.&nbsp; In a big code model, this consists of the segments &quot;&lt;subprogram&gt;_TEXT&quot;
where &lt;subprogram&gt; is the name of a subprogram.
<LI>The &quot;FAR_DATA&quot; class consists of the following:
<DL>
<DT>(a)
<DD>arrays whose size exceeds the data threshold in large data memory models (the data threshold is 256 bytes unless changed using
the &quot;dt&quot; compiler option)
<DT>(b)
<DD>equivalenced variables in large data memory models
</DL>
</OL>
<H2 ID="32Mbit__Writing_Assembly_Language_Subprograms"> 32-bit:&nbsp; Writing Assembly Language Subprograms </H2>
<BR>When writing assembly language subprograms, use the following guidelines.
<OL>
<LI>All used registers must be saved on entry and restored on exit except those used to pass arguments and return values.
&nbsp;Note that segment registers only have to be saved and restored if you are compiling your application with the &quot;sr&quot;
option.
<LI>The direction flag must be clear before returning to the caller.
<LI>In a small code model, any segment containing executable code must belong to the segment &quot;_TEXT&quot; and the class
&quot;CODE&quot;.&nbsp; The segment &quot;_TEXT&quot; must have a &quot;combine&quot; type of &quot;PUBLIC&quot;.&nbsp; On
entry, register CS contains the segment address of the segment &quot;_TEXT&quot;.&nbsp; In a big code model there is no restriction
on the naming of segments which contain executable code.
<LI>In a small data model, segment register DS contains the segment address of the default data segment (group &quot;DGROUP&quot;).
&nbsp;In a big data model, segment register SS (not DS) contains the segment address of the default data segment (group &quot;DGROUP&quot;).
<LI>When writing assembly language subprograms for the small code model, you must declare them as &quot;near&quot;.&nbsp;
If you wish to write assembly language subprograms for the big code model, you must declare them as &quot;far&quot;.
<LI>Use the &quot;.8087&quot; pseudo-op so that floating-point constants are in the correct format.
<LI>The called subprogram must remove arguments that were passed on the stack in the &quot;ret&quot; instruction.
<LI>In general, when naming segments for your code or data, you should follow the conventions described in the section entitled
&quot;Memory Layout&quot; in this chapter.
</OL>
<BR>Consider the following example.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER HRS, MINS, SECS, HSECS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALL GETTIM( HRS, MINS, SECS, HSECS )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT 100, HRS, MINS, SECS, HSECS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 100&nbsp;&nbsp; FORMAT( 1X,I2.2,':',I2.2,':',I2.2,'.',I2.2 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<HR>
<BR><TT>GETTIM</TT> is an assembly language subroutine that gets the current time.&nbsp; It requires four integer arguments.
&nbsp;The arguments are passed by reference so that the subroutine can return the hour, minute, seconds and hundredths of
a second for the current time.&nbsp; These arguments will be passed to<TT> GETTIM</TT> in the following way.
<OL>
<LI>The address of the first argument will be passed in register EAX.
<LI>The address of the second argument will be passed in register EDX.
<LI>The address of the third argument will be passed in register EBX.
<LI>The address of the fourth argument will be passed in register ECX.
</OL>
<BR>The following is an assembly language subprogram which implements<TT> GETTIM.</TT>
<BR><BR><B>Small or Flat Memory Model (small code, small data)</B>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXT&nbsp;&nbsp; segment byte public 'CODE'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assume&nbsp; CS:_TEXT</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public&nbsp; GETTIM</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; GETTIM&nbsp; proc&nbsp;&nbsp;&nbsp; near</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; EAX&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; ; save registers modified by</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; ECX&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; ; ... DOS function call</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; EDX&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; ; ...</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; AH,2ch&nbsp;
&nbsp; ; set DOS &quot;get time&quot; function</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; 21h&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; ; issue DOS function call</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movzx&nbsp;&nbsp; EAX,DH&nbsp;&nbsp;&nbsp;
; get seconds</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; [EBX],EAX ; return
seconds</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;&nbsp;&nbsp; EBX&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; ; get address of minutes</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movzx&nbsp;&nbsp; EAX,CL&nbsp;&nbsp;
&nbsp;; get minutes</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; [EBX],EAX ; return
minutes</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;&nbsp;&nbsp; EBX&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; ; get address of ticks</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movzx&nbsp;&nbsp; EAX,DL&nbsp;&nbsp;&nbsp;
; get ticks</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; [EBX],EAX
; return ticks</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;&nbsp;&nbsp; EBX&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; ; get address of hours</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movzx&nbsp;&nbsp; EAX,CH&nbsp;&nbsp;&nbsp;
; get hours</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; [EBX],EAX ; return
hours</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; return</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; GETTIM&nbsp; endp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXT&nbsp;&nbsp; ends</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR><B>Notes:</B>
<OL>
<LI>No arguments were passed on the stack so a simple &quot;ret&quot; instruction is used to return to the caller.&nbsp; If
a single argument was passed on the stack, a &quot;ret 4&quot; instruction would be required to return to the caller.
<LI>Registers EAX, EBX, ECX and EDX were not saved and restored since they were used to pass arguments.
</OL>
<H3 ID="32Mbit__Using_the_StackMBased_Calling_Convention"> 32-bit:&nbsp; Using the Stack-Based Calling Convention </H3>
<BR>When writing assembly language subprograms that use the stack-based calling convention, use the following guidelines.
<OL>
<LI>All used registers, except registers EAX, ECX and EDX must be saved on entry and restored on exit.&nbsp; Also, if segment
registers ES and DS are used, they must be saved on entry and restored on exit.&nbsp; Note that segment registers only have
to be saved and restored if you are compiling your application with the &quot;sr&quot; option.
<LI>The direction flag must be clear before returning to the caller.
<LI>In a small code model, any segment containing executable code must belong to the segment &quot;_TEXT&quot; and the class
&quot;CODE&quot;.&nbsp; The segment &quot;_TEXT&quot; must have a &quot;combine&quot; type of &quot;PUBLIC&quot;.&nbsp; On
entry, register CS contains the segment address of the segment &quot;_TEXT&quot;.&nbsp; In a big code model there is no restriction
on the naming of segments which contain executable code.
<LI>In a small data model, segment register DS contains the segment address of the default data segment (group &quot;DGROUP&quot;).
&nbsp;In a big data model, segment register SS (not DS) contains the segment address of the default data segment (group &quot;DGROUP&quot;).
<LI>When writing assembly language subprograms for the small code model, you must declare them as &quot;near&quot;.&nbsp;
If you wish to write assembly language subprograms for the big code model, you must declare them as &quot;far&quot;.
<LI>Use the &quot;.8087&quot; pseudo-op so that floating-point constants are in the correct format.
<LI>The caller will remove arguments that were passed on the stack.
<LI>In general, when naming segments for your code or data, you should follow the conventions described in the section entitled
&quot;Memory Layout&quot; in this chapter.
</OL>
<BR>Consider the following example.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER HRS, MINS, SECS, HSECS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALL GETTIM( HRS, MINS, SECS, HSECS )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT 100, HRS, MINS, SECS, HSECS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 100&nbsp;&nbsp; FORMAT( 1X,I2.2,':',I2.2,':',I2.2,'.',I2.2 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<HR>
<BR><TT>GETTIM</TT> is an assembly language subroutine that gets the current time.&nbsp; It requires four integer arguments.
&nbsp;The arguments are passed by reference so that the subroutine can return the hour, minute, seconds and hundredths of
a second for the current time.&nbsp; These arguments will be passed to<TT> GETTIM</TT> on the stack.
<BR><BR>The following is an assembly language subprogram which implements<TT> GETTIM.</TT>
<BR><BR><B>Small or Flat Memory Model (small code, small data)</B>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXT&nbsp;&nbsp; segment byte public 'CODE'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assume&nbsp; CS:_TEXT</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public&nbsp; GETTIM</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; GETTIM&nbsp; proc&nbsp;&nbsp;&nbsp; near</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; EBP&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; ; save registers</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; EBP,ESP&nbsp;
&nbsp; ; ...</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; ESI&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; ; ...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; AH,2ch&nbsp;
&nbsp;&nbsp; ; set DOS &quot;get time&quot; function</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; 21h&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; ; issue DOS function call</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movzx&nbsp;&nbsp; EAX,CH&nbsp;&nbsp;&nbsp;
&nbsp;; get hours</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ESI,8[EBP] ;
get address of hours</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; [ESI],EAX
&nbsp;; return hours</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movzx&nbsp;&nbsp; EAX,CL&nbsp;&nbsp;&nbsp;
&nbsp;; get minutes</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ESI,12[BP] ;
get address of minutes</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; [ESI],EAX&nbsp;
; return minutes</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movzx&nbsp;&nbsp; EAX,DH&nbsp;&nbsp;&nbsp;
&nbsp;; get seconds</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ESI,16[BP]
; get address of seconds</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; [ESI],EAX&nbsp;
; return seconds</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movzx&nbsp;&nbsp; EAX,DL&nbsp;&nbsp;&nbsp;
&nbsp;; get ticks</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ESI,20[BP] ;
get address of ticks</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; [ESI],EAX&nbsp;
; return ticks</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;&nbsp;&nbsp; ESI&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; restore registers</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ESP,EBP&nbsp;
&nbsp; ; ...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;&nbsp;&nbsp; EBP&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; ; ...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; return</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; GETTIM&nbsp; endp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXT&nbsp;&nbsp; ends</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR><B>Notes:</B>
<OL>
<LI>The four arguments that were passed on the stack will be removed by the caller.
<LI>Registers ESI and EBP were saved and restored since they were used in<TT> GETTIM.</TT>
</OL>
<BR>Let us look at the stack upon entry to<TT> GETTIM.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Offset</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; +----------------+ &lt;- ESP points here</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | return address |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | argument #1&nbsp;&nbsp;&nbsp;
|</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | argument #2&nbsp;&nbsp;&nbsp;
|</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 12&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | argument #3&nbsp;&nbsp;&nbsp;
|</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | argument #4&nbsp;&nbsp;&nbsp;
|</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 20&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><BR><B>Notes:</B>
<OL>
<LI>The top element of the stack is a the 32-bit return address.&nbsp; The first argument is at offset 4 from the top of the
stack, the second argument at offset 8, the third argument at offset 12, and the fourth argument at offset 16.
</OL>
<BR>Register EBP is normally used to address arguments on the stack.&nbsp; Upon entry to the subroutine, registers that are
modified (except registers EAX, ECX and EDX) are saved and register EBP is set to point to the stack.&nbsp; After performing
this prologue sequence, the stack looks like this.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Offset from EBP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -4&nbsp;&nbsp;&nbsp;&nbsp; +----------------+ &lt;- ESP point here</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | saved ESI&nbsp;&nbsp;&nbsp;
&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; +----------------+ &lt;- EBP point here</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | saved EBP&nbsp;&nbsp;&nbsp;
&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | return address |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | argument #1&nbsp;&nbsp;&nbsp;
|</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 12&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | argument #2&nbsp;&nbsp;&nbsp;
|</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | argument #3&nbsp;&nbsp;&nbsp;
|</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 20&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | argument #4&nbsp;&nbsp;&nbsp;
|</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 24&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><BR>As the above diagram shows, the first argument is at offset 8 from register EBP, the second argument is at offset
12, the third argument is at offset 16, and the fourth argument is at offset 20.
<H3 ID="32Mbit__Returning_Values_from_Assembly_Language_Functions"> 32-bit:&nbsp; Returning Values from Assembly Language Functions </H3>
<BR>The following illustrates the way function values are to be returned from assembly language functions.
<HR>
<BR><B><I>&nbsp; Note:</I></B>&nbsp; The way in which a function returns its value does not change when the stack-based calling
convention is used.
<HR>
<OL>
<LI>A<B> LOGICAL*1</B> function.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXT&nbsp;&nbsp; segment byte public 'CODE'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assume&nbsp; CS:_TEXT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public&nbsp; L1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; L1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; proc&nbsp;&nbsp;&nbsp; near</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; AL,1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; L1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXT&nbsp;&nbsp; ends</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<LI>A<B> LOGICAL*4</B> function.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXT&nbsp;&nbsp; segment byte public 'CODE'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assume&nbsp; CS:_TEXT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public&nbsp; L4</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; L4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; proc&nbsp;&nbsp;&nbsp; near</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; EAX,0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; L4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXT&nbsp;&nbsp; ends</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<LI>An<B> INTEGER*1</B> function.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXT&nbsp;&nbsp; segment byte public 'CODE'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assume&nbsp; CS:_TEXT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public&nbsp; I1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; I1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; proc&nbsp;&nbsp;&nbsp; near</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; AL,73</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; I1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXT&nbsp;&nbsp; ends</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<LI>An<B> INTEGER*2</B> function.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXT&nbsp;&nbsp; segment byte public 'CODE'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assume&nbsp; CS:_TEXT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public&nbsp; I2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; I2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; proc&nbsp;&nbsp;&nbsp; near</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; AX,7143</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; I2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXT&nbsp;&nbsp; ends</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<LI>An<B> INTEGER*4</B> function.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXT&nbsp;&nbsp; segment byte public 'CODE'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assume&nbsp; CS:_TEXT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public&nbsp; I4</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; I4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; proc&nbsp;&nbsp;&nbsp; near</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; EAX,383</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; I4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXT&nbsp;&nbsp; ends</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<LI>A<B> REAL*4</B> function.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; .8087</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DGROUP&nbsp; group R4_DATA</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXT&nbsp;&nbsp; segment byte public 'CODE'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assume&nbsp; CS:_TEXT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assume&nbsp; DS:DGROUP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public&nbsp; R4</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; R4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; proc&nbsp;&nbsp;&nbsp; near</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; EAX,dword
ptr R4Val</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; R4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXT&nbsp;&nbsp; ends</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; R4_DATA segment byte public 'DATA'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; R4Val&nbsp;&nbsp; dd 1314.3</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; R4_DATA ends</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<LI>A<B> REAL*8</B> function.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; .8087</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DGROUP&nbsp; group R8_DATA</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXT&nbsp;&nbsp; segment byte public 'CODE'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assume&nbsp; CS:_TEXT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assume&nbsp; DS:DGROUP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public&nbsp; R8</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; R8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; proc&nbsp;&nbsp;&nbsp; near</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; EAX,dword ptr
R8Val</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; EDX,dword ptr
R8Val+4</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; R8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXT&nbsp;&nbsp; ends</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; R8_DATA segment byte public 'DATA'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; R8Val&nbsp;&nbsp; dq 103.3</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; R8_DATA ends</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<LI>A<B> COMPLEX*8</B> function.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; .8087</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DGROUP&nbsp; group C8_DATA</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXT&nbsp;&nbsp; segment byte public 'CODE'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assume&nbsp; CS:_TEXT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assume&nbsp; DS:DGROUP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public&nbsp; C8</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; proc&nbsp;&nbsp;&nbsp; near</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; EAX</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; EAX,C8Val</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; [ESI],EAX</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; EAX,C8Val+4</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; 4[ESI],EAX</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;&nbsp;&nbsp; EAX</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXT&nbsp;&nbsp; ends</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C8_DATA segment byte public 'DATA'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C8Val&nbsp;&nbsp; dd 2.2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dd 2.2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C8_DATA ends</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<LI>A<B> COMPLEX*16</B> function.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; .8087</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DGROUP&nbsp; group C16_DATA</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXT&nbsp;&nbsp; segment byte public 'CODE'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assume&nbsp; CS:_TEXT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assume&nbsp; DS:DGROUP</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public&nbsp; C16</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C16&nbsp;&nbsp;&nbsp;&nbsp; proc&nbsp;&nbsp;&nbsp; near</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; EAX</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; EAX,dword ptr
C16Val</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; [ESI],EAX</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; EAX,dword
ptr C16Val+4</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; 4[ESI],EAX</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; EAX,dword ptr
C16Val+8</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; 8[ESI],EAX</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; EAX,dword
ptr C16Val+12</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; 12[ESI],EAX</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;&nbsp;&nbsp; EAX</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C16&nbsp;&nbsp;&nbsp;&nbsp; endp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXT&nbsp;&nbsp; ends</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C16_DATA segment byte public 'DATA'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C16Val&nbsp; dq 3.3</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dq 3.3</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C16_DATA ends</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<LI>A<B> CHARACTER</B> function.
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXT&nbsp;&nbsp; segment byte public 'CODE'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assume&nbsp; CS:_TEXT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public&nbsp; CHR</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CHR&nbsp;&nbsp;&nbsp;&nbsp; proc&nbsp;&nbsp;&nbsp; near</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; EAX</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; EAX,[EAX]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; byte ptr [EAX],'F'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;&nbsp;&nbsp; EAX</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CHR&nbsp;&nbsp;&nbsp;&nbsp; endp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXT&nbsp;&nbsp; ends</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>Remember, if you are using stack calling conventions (i.e., you specified the &quot;sc&quot; compiler option), arguments
will be passed on the stack.&nbsp; The above character function must be modified as follows.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXT&nbsp;&nbsp; segment byte public 'CODE'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assume&nbsp; CS:_TEXT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public&nbsp; CHR</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CHR&nbsp;&nbsp;&nbsp;&nbsp; proc&nbsp;&nbsp;&nbsp; near</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; EAX</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; EAX,8[ESP]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; EAX,[EAX]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; byte ptr [EAX],'F'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;&nbsp;&nbsp; EAX</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CHR&nbsp;&nbsp;&nbsp;&nbsp; endp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXT&nbsp;&nbsp; ends</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<LI>A function returning a user-defined structure.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DGROUP&nbsp; group STRUCT_DATA</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXT&nbsp;&nbsp; segment byte public 'CODE'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assume&nbsp; CS:_TEXT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assume&nbsp; DS:DGROUP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public&nbsp; STRUCT</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; STRUCT&nbsp; proc&nbsp;&nbsp;&nbsp; near</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; EAX</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; EAX,dword ptr
StructVal</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; [ESI],EAX</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; EAX,dword
ptr StructVal+4</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; 4[ESI],EAX</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;&nbsp;&nbsp; EAX</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; STRUCT&nbsp; endp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXT&nbsp;&nbsp; ends</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; STRUCT_DATA segment byte public 'DATA'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; StructVal dd 7</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dd 3</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; STRUCT_DATA ends</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</OL>
<BR>If you are using an 80x87 to return floating-point values, only<B> REAL*4</B> and<B> REAL*8</B> assembly language functions
need to be modified.&nbsp; <B> Remember, this does not apply if you are using the stack-based calling convention.</B>
<OL>
<LI>A<B> REAL*4</B> function using an 80x87.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; .8087</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DGROUP&nbsp; group R4_DATA</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXT&nbsp;&nbsp; segment byte public 'CODE'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assume&nbsp; CS:_TEXT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assume&nbsp; DS:DGROUP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public&nbsp; R4</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; R4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; proc&nbsp;&nbsp;&nbsp; near</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fld&nbsp;&nbsp;&nbsp;&nbsp; dword ptr R4Val</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; R4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXT&nbsp;&nbsp; ends</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; R4_DATA segment byte public 'DATA'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; R4Val&nbsp;&nbsp; dd 1314.3</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; R4_DATA ends</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<LI>A<B> REAL*8</B> function using an 80x87.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; .8087</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DGROUP&nbsp; group R8_DATA</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXT&nbsp;&nbsp; segment byte public 'CODE'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assume&nbsp; CS:_TEXT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assume&nbsp; DS:DGROUP</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public&nbsp; R8</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; R8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; proc&nbsp;&nbsp;&nbsp; near</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fld&nbsp;&nbsp;&nbsp;&nbsp; qword ptr R8Val</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; R8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXT&nbsp;&nbsp; ends</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; R8_DATA segment byte public 'DATA'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; R8Val&nbsp;&nbsp; dq 103.3</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; R8_DATA ends</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</OL>
<BR>The following is an example of a Open Watcom F77 program calling the above assembly language subprograms.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; logical l1*1, l4*4</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer i1*1, i2*2, i4*4</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real r4*4, r8*8</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; complex c8*8, c16*16</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character chr</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; structure /coord/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer x, y</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end structure</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /coord/ struct</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, l1()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, l4()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, i1()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, i2()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, i4()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, r4()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, r8()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, c8()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, c16()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, chr()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, struct()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<H1 ID="32Mbit__32Mbit_Pragmas"> 32-bit:&nbsp; 32-bit Pragmas </H1>
<BR>A pragma is a compiler directive that provides the following capabilities.
<UL>
<LI>Pragmas can be used to direct the Open Watcom F77 code generator to emit specialized sequences of code for calling functions
which use argument passing and value return techniques that differ from the default used by Open Watcom F77.
<LI>Pragmas can be used to describe attributes of functions (such as side effects) that are not possible at the FORTRAN 77
language level.&nbsp; The code generator can use this information to generate more efficient code.
<LI>Any sequence of in-line machine language instructions, including DOS and BIOS function calls, can be generated in the
object code.
</UL>
<BR>Pragmas are specified in the source file using the<B><I> pragma</I></B> directive.&nbsp; A pragma operator of the form,<B><I>
_Pragma</I></B> ( string-literal ) is an alternative method of specifying<B><I> pragma</I></B> directives.
<BR><BR>For example, the following two statements are equivalent.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _Pragma( &quot;library (\&quot;kernel32.lib\&quot;)&quot; )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma library (&quot;kernel32.lib&quot;)</TT>
<BR><BR>The<B><I> _Pragma</I></B> operator can be used in macro definition.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; # define LIBRARY(X) PRAGMA(library (#X))</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; # define PRAGMA(X) _Pragma(#X)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; LIBRARY(kernel32.lib)&nbsp; // same as #pragma library (&quot;kernel32.lib&quot;)</TT>
<BR><BR>The following notation is used to describe the syntax of pragmas.
<DL>
<DT>keywords
<DD>A<TT> keyword</TT> is shown in a mono-spaced courier font.
<DT>program-item
<DD>A<B><I> program-item</I></B> is shown in a roman bold-italics font.&nbsp; A<B><I> program-item</I></B> is a symbol name or
numeric value supplied by the programmer.
<DT>punctuation
<DD>A<TT> punctuation character</TT> shown in a mono-spaced courier font must be entered as is.
<BR><BR>A<B><I> punctuation character</I></B> shown in a roman bold-italics font is used to describe syntax.&nbsp; The following
syntactical notation is used.
<DL>
<DT>[abc]
<DD>The item<B> abc</B> is optional.
<DT>{abc}
<DD>The item<B> abc</B> may be repeated zero or more times.
<DT>a|b|c
<DD>One of<B> a, b</B> or<B> c</B> may be specified.
<DT>a ::= b
<DD>The item<B> a</B> is defined in terms of<B> b.</B>
<DT>(a)
<DD>Item<B> a</B> is evaluated first.
</DL>
</DL>
<BR>The following classes of pragmas are supported.
<UL>
<LI>pragmas that specify default libraries
<LI>pragmas that provide auxiliary information used for code generation
</UL>
<H2 ID="32Mbit__Using_Pragmas_to_Specify_Default_Libraries"> 32-bit:&nbsp; Using Pragmas to Specify Default Libraries </H2>
<BR>Default libraries are specified in special object module records.&nbsp; Library names are extracted from these special
records by the Open Watcom Linker.&nbsp; When unresolved references remain after processing all object modules specified in
linker &quot;FILE&quot; directives, these default libraries are searched after all libraries specified in linker &quot;LIBRARY&quot;
directives have been searched.
<BR><BR>By default, that is if no library pragma is specified, the Open Watcom F77 compiler generates, in the object file
defining the main program, default libraries corresponding to the memory model and floating-point model used to compile the
file.&nbsp; For example, if you have compiled the source file containing the main program for the flat memory model and the
floating-point calls floating-point model, the library &quot;flib&quot; will be placed in the object file.
<BR><BR>If you wish to add your own default libraries to this list, you can do so with a library pragma.&nbsp; Consider the
following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma library mylib</TT>
<BR><BR>The name &quot;mylib&quot; will be added to the list of default libraries specified in the object file.
<BR><BR>If you wish to specify more than one library in a library pragma you must separate them with spaces as in the following
example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma library mylib \watcom\lib286\dos\graph.lib</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma library mylib \watcom\lib386\dos\graph.lib</TT>
<BR><BR>If no libraries are specified as in the following example,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma library</TT>
<BR><BR>the run-time libraries corresponding to the memory and floating-point models used to compile the file will be generated.
<H2 ID="32Mbit__Auxiliary_Pragmas"> 32-bit:&nbsp; Auxiliary Pragmas </H2>
<BR>The following sections describe the capabilities provided by auxiliary pragmas.
<BR><BR>The backslash character ('\') is used to continue a pragma on the next line.&nbsp; Text following the backslash character
is ignored.&nbsp; The line continuing the pragma must start with a comment character ('c', 'C' or '*').
<H3 ID="32Mbit__Specifying_Symbol_Attributes"> 32-bit:&nbsp; Specifying Symbol Attributes </H3>
<BR>Auxiliary pragmas are used to describe attributes that affect code generation.&nbsp; Initially, the compiler defines a
default set of attributes.&nbsp; Each auxiliary pragma refers to one of the following.
<OL>
<LI>a symbol (such as a variable or function)
<LI>the default set of attributes defined by the compiler
</OL>
<BR>When an auxiliary pragma refers to a particular symbol, a copy of the current set of default attributes is made and merged
with the attributes specified in the auxiliary pragma.&nbsp; The resulting attributes are assigned to the specified symbol
and can only be changed by another auxiliary pragma that refers to the same symbol.
<BR><BR>When &quot;default&quot; is specified instead of a symbol name, the attributes specified by the auxiliary pragma change
the default set of attributes.&nbsp; The resulting attributes are used by all symbols that have not been specifically referenced
by a previous auxiliary pragma.
<BR><BR>Note that all auxiliary pragmas are processed before code generation begins.&nbsp; Consider the following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; code in which symbol x is referenced</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux y &lt;attrs_1&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; code in which symbol y is referenced</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; code in which symbol z is referenced</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux default &lt;attrs_2&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux x &lt;attrs_3&gt;</TT>
<BR><BR>Auxiliary attributes are assigned to<TT> x, y</TT> and<TT> z</TT> in the following way.
<OL>
<LI>Symbol<TT> x</TT> is assigned the initial default attributes merged with the attributes specified by<TT> &lt;attrs_2&gt;</TT>
and<TT> &lt;attrs_3&gt;.</TT>
<LI>Symbol<TT> y</TT> is assigned the initial default attributes merged with the attributes specified by<TT> &lt;attrs_1&gt;.</TT>
<LI>Symbol<TT> z</TT> is assigned the initial default attributes merged with the attributes specified by<TT> &lt;attrs_2&gt;.</TT>
</OL>
<H3 ID="32Mbit__Alias_Names"> 32-bit:&nbsp; Alias Names </H3>
<BR>When a symbol referred to by an auxiliary pragma includes an alias name, the attributes of the alias name are also assumed
by the specified symbol.
<BR><BR>There are two methods of specifying alias information.&nbsp; In the first method, the symbol assumes only the attributes
of the alias name; no additional attributes can be specified.&nbsp; The second method is more general since it is possible
to specify an alias name as well as additional auxiliary information.&nbsp; In this case, the symbol assumes the attributes
of the alias name as well as the attributes specified by the additional auxiliary information.
<BR><BR>The simple form of the auxiliary pragma used to specify an alias is as follows.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux ( </TT><B>sym</B><TT>, </TT><B>alias</B><TT> ) </TT>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is any valid FORTRAN 77 identifier.
<DT>alias
<DD>is the alias name and is any valid FORTRAN 77 identifier.
</DL>
<BR>Consider the following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux value_args parm (value) </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux ( rtn, value_args ) </TT>
<BR><BR>The routine<TT> rtn</TT> assumes the attributes of the alias name<TT> push_args</TT> which specifies that the arguments
to<TT> rtn</TT> are passed by value.
<BR><BR>The general form of an auxiliary pragma that can be used to specify an alias is as follows.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux ( </TT><B>alias</B><TT> ) </TT><B>sym</B><TT> </TT><B>aux_attrs</B><TT> </TT>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>alias
<DD>is the alias name and is any valid FORTRAN 77 identifier.
<DT>sym
<DD>is any valid FORTRAN 77 identifier.
<DT>aux_attrs
<DD>are attributes that can be specified with the auxiliary pragma.
</DL>
<BR>Consider the following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux WC &quot;*_&quot; parm (value)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux (WC) rtn1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux (WC) rtn2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux (WC) rtn3</TT>
<BR><BR>The routines<TT> rtn1, rtn2</TT> and<TT> rtn3</TT> assume the same attributes as the alias name<TT> WC</TT> which
defines the calling convention used by the Open Watcom C compiler.&nbsp; Whenever calls are made to<TT> rtn1, rtn2</TT> and<TT>
rtn3,</TT> the Open Watcom C calling convention will be used.&nbsp; Note that arguments must be passed by value.&nbsp; By
default, Open Watcom F77 passes arguments by reference.
<BR><BR>Note that if the attributes of<TT> WC</TT> change, only one pragma needs to be changed.&nbsp; If we had not used an
alias name and specified the attributes in each of the three pragmas for<TT> rtn1, rtn2</TT> and<TT> rtn3,</TT> we would have
to change all three pragmas.&nbsp; This approach also reduces the amount of memory required by the compiler to process the
source file.
<HR>
<BR><B><I>&nbsp; WARNING!</I></B>&nbsp; The alias name<TT> WC</TT> is just another symbol.&nbsp; If<TT> WC</TT> appeared in
your source code, it would assume the attributes specified in the pragma for<TT> WC.</TT>
<HR>
<H3 ID="32Mbit__Predefined_Aliases"> 32-bit:&nbsp; Predefined Aliases </H3>
<BR>A number of symbols are predefined by the compiler with a set of attributes that describe a particular calling convention.
&nbsp;These symbols can be used as aliases.&nbsp; The following is a list of these symbols.
<DL>
<DT>__cdecl
<DD><TT> __cdecl</TT> defines the calling convention used by Microsoft compilers.
<DT>__fastcall
<DD><TT> __fastcall</TT> defines the calling convention used by Microsoft compilers.
<DT>__fortran
<DD><TT> __fortran</TT> defines the calling convention used by Open Watcom FORTRAN compilers.
<DT>__pascal
<DD><TT> __pascal</TT> defines the calling convention used by OS/2 1.x and Windows 3.x API functions.
<DT>__stdcall
<DD><TT> __stdcall</TT> defines a special calling convention used by the Win32 API functions.
<DT>__syscall
<DD><TT> __syscall</TT> defines the calling convention used by the 32-bit OS/2 API functions.
<DT>__watcall
<DD><TT> __watcall</TT> defines the calling convention used by Open Watcom compilers.
</DL>
<BR>The following describes the attributes of the above alias names.
<H4 ID="32Mbit__Predefined____cdecl__Alias"> 32-bit:&nbsp; Predefined &quot;__cdecl&quot; Alias </H4>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux __cdecl &quot;_*&quot; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parm caller [] \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value struct float struct routine
[eax] \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; modify [eax ecx edx]</TT>
<BR><BR><B>Notes:</B>
<OL>
<LI>All symbols are preceded by an underscore character.
<LI>Arguments are pushed on the stack from right to left.&nbsp; That is, the last argument is pushed first.&nbsp; The calling
routine will remove the arguments from the stack.
<LI>Floating-point values are returned in the same way as structures.&nbsp; When a structure is returned, the called routine
allocates space for the return value and returns a pointer to the return value in register EAX.
<LI>Registers EAX, ECX and EDX are not saved and restored when a call is made.
</OL>
<H4 ID="32Mbit__Predefined____pascal__Alias"> 32-bit:&nbsp; Predefined &quot;__pascal&quot; Alias </H4>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux __pascal &quot;^&quot; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parm reverse routine [] \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value struct float struct caller
[] \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; modify [eax ebx ecx edx]</TT>
<BR><BR><B>Notes:</B>
<OL>
<LI>All symbols are mapped to upper case.
<LI>Arguments are pushed on the stack in reverse order.&nbsp; That is, the first argument is pushed first, the second argument
is pushed next, and so on.&nbsp; The routine being called will remove the arguments from the stack.
<LI>Floating-point values are returned in the same way as structures.&nbsp; When a structure is returned, the caller allocates
space on the stack.&nbsp; The address of the allocated space will be pushed on the stack immediately before the call instruction.
&nbsp;Upon returning from the call, register EAX will contain address of the space allocated for the return value.
<LI>Registers EAX, EBX, ECX and EDX are not saved and restored when a call is made.
</OL>
<H4 ID="32Mbit__Predefined____stdcall__Alias"> 32-bit:&nbsp; Predefined &quot;__stdcall&quot; Alias </H4>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux __stdcall &quot;_*@nnn&quot; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parm routine [] \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value struct struct caller
[] \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; modify [eax ecx edx]</TT>
<BR><BR><B>Notes:</B>
<OL>
<LI>All symbols are preceded by an underscore character.
<LI>All C symbols (extern &quot;C&quot; symbols in C++) are suffixed by &quot;@nnn&quot; where &quot;nnn&quot; is the sum
of the argument sizes (each size is rounded up to a multiple of 4 bytes so that char and short are size 4).&nbsp; When the
argument list contains &quot;...&quot;, the &quot;@nnn&quot; suffix is omitted.
<LI>Arguments are pushed on the stack from right to left.&nbsp; That is, the last argument is pushed first.&nbsp; The called
routine will remove the arguments from the stack.
<LI>When a structure is returned, the caller allocates space on the stack.&nbsp; The address of the allocated space will be
pushed on the stack immediately before the call instruction.&nbsp; Upon returning from the call, register EAX will contain
address of the space allocated for the return value.&nbsp; Floating-point values are returned in 80x87 register ST(0).
<LI>Registers EAX, ECX and EDX are not saved and restored when a call is made.
</OL>
<H4 ID="32Mbit__Predefined____syscall__Alias"> 32-bit:&nbsp; Predefined &quot;__syscall&quot; Alias </H4>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux __syscall &quot;*&quot; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parm caller [] \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value struct struct caller
[] \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; modify [eax ecx edx]</TT>
<BR><BR><B>Notes:</B>
<OL>
<LI>Symbols names are not modified, that is, they are not adorned with leading or trailing underscores.
<LI>Arguments are pushed on the stack from right to left.&nbsp; That is, the last argument is pushed first.&nbsp; The calling
routine will remove the arguments from the stack.
<LI>When a structure is returned, the caller allocates space on the stack.&nbsp; The address of the allocated space will be
pushed on the stack immediately before the call instruction.&nbsp; Upon returning from the call, register EAX will contain
address of the space allocated for the return value.&nbsp; Floating-point values are returned in 80x87 register ST(0).
<LI>Registers EAX, ECX and EDX are not saved and restored when a call is made.
</OL>
<H4 ID="32Mbit__Predefined____watcall__Alias_Lregister_calling_conventionR"> 32-bit:&nbsp; Predefined &quot;__watcall&quot; Alias (register calling convention) </H4>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux __watcall &quot;*_&quot; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parm routine [eax ebx ecx edx]
\</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value struct caller</TT>
<BR><BR><B>Notes:</B>
<OL>
<LI>Symbol names are followed by an underscore character.
<LI>Arguments are processed from left to right.&nbsp; The leftmost arguments are passed in registers and the rightmost arguments
are passed on the stack (if the registers used for argument passing have been exhausted).&nbsp; Arguments that are passed
on the stack are pushed from right to left.&nbsp; The calling routine will remove the arguments if any were pushed on the
stack.
<LI>When a structure is returned, the caller allocates space on the stack.&nbsp; The address of the allocated space is put
into ESI register.&nbsp; The called routine then places the return value there.&nbsp; Upon returning from the call, register
EAX will contain address of the space allocated for the return value.
<LI>Floating-point values are returned using 80x86 registers (&quot;fpc&quot; option) or using 80x87 floating-point registers
(&quot;fpi&quot; or &quot;fpi87&quot; option).
<LI>All registers must be preserved by the called routine.
</OL>
<H4 ID="32Mbit__Predefined____watcall__Alias_Lstack_calling_conventionR"> 32-bit:&nbsp; Predefined &quot;__watcall&quot; Alias (stack calling convention) </H4>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux __watcall &quot;*&quot; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parm caller [] \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value no8087 struct caller
\</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; modify [eax ecx edx 8087]</TT>
<BR><BR><B>Notes:</B>
<OL>
<LI>All symbols appear in object form as they do in source form.
<LI>Arguments are pushed on the stack from right to left.&nbsp; That is, the last argument is pushed first.&nbsp; The calling
routine will remove the arguments from the stack.
<LI>When a structure is returned, the caller allocates space on the stack.&nbsp; The address of the allocated space will be
pushed on the stack immediately before the call instruction.&nbsp; Upon returning from the call, register EAX will contain
address of the space allocated for the return value.
<LI>Floating-point values are returned only using 80x86 registers.
<LI>Registers EAX, ECX and EDX are not preserved by the called routine.
<LI>Any local variables that are located in the 80x87 cache are not preserved by the called routine.
</OL>
<H3 ID="32Mbit__Alternate_Names_for_Symbols"> 32-bit:&nbsp; Alternate Names for Symbols </H3>
<BR>The following form of the auxiliary pragma can be used to describe the mapping of a symbol from its source form to its
object form.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux </TT><B>sym</B><TT> </TT><B>obj_name</B><TT> </TT>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is any valid FORTRAN 77 identifier.
<DT>obj_name
<DD>is any character string enclosed in double quotes.
</DL>
<BR>When specifying<TT> obj_name,</TT> some characters have a special meaning:
<DL>
<DT>where
<DD><B>description</B>
<DT>*
<DD>is unmodified symbol name
<DT>^
<DD>is symbol name converted to uppercase
<DT>!
<DD>is symbol name converted to lowercase
<DT>#
<DD>is a placeholder for &quot;@nnn&quot;, where nnn is size of all function parameters on the stack; it is ignored for functions
with variable argument lists, or for symbols that are not functions
<DT>\
<DD>next character is treated as literal
</DL>
<BR>Several examples of source to object form symbol name translation follow:&nbsp; By default, the upper case version &quot;MYRTN&quot;
or &quot;MYVAR&quot; is placed in the object file.
<BR><BR>In the following example, the name &quot;MyRtn&quot; will be replaced by &quot;MYRTN_&quot; in the object file.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux MyRtn &quot;^_&quot;</TT>
<BR><BR>In the following example, the name &quot;MyVar&quot; will be replaced by &quot;_MYVAR&quot; in the object file.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux MyVar &quot;_^&quot;</TT>
<BR><BR>In the following example, the lower case version &quot;myrtn&quot; will be placed in the object file.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux MyRtn &quot;!&quot;</TT>
<BR><BR>In the following example, the name &quot;MyRtn&quot; will be replaced by &quot;_MyRtn@nnn&quot; in the object file.
&nbsp;&quot;nnn&quot; represents the size of all function parameters.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux MyRtn &quot;_*#&quot;</TT>
<BR><BR>In the following example, the name &quot;MyRtn&quot; will be replaced by &quot;_MyRtn#&quot; in the object file.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux MyRtn &quot;_*\#&quot;</TT>
<BR><BR>The default mapping for all symbols can also be changed as illustrated by the following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux default &quot;_^_&quot;</TT>
<BR><BR>The above auxiliary pragma specifies that all names will be prefixed and suffixed by an underscore character ('_').
<H3 ID="32Mbit__Describing_Calling_Information"> 32-bit:&nbsp; Describing Calling Information </H3>
<BR>The following form of the auxiliary pragma can be used to describe the way a subprogram is to be called.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux </TT><B>sym</B><TT> far</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux </TT><B>sym</B><TT> far16</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux </TT><B>sym</B><TT> near</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux </TT><B>sym</B><TT> = </TT><B>in_line</B>
<BR><BR><B>&nbsp;&nbsp;&nbsp;&nbsp; in_line ::= { const | </B><TT>&quot;</TT><B>asm</B><TT>&quot;</TT><B> }</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a subprogram name.
<DT>const
<DD>is a valid FORTRAN 77 hexadecimal constant.
<DT>asm
<DD>is an assembly language instruction or directive.
</DL>
<BR>In the following example, Open Watcom F77 will generate a far call to the subprogram<TT> myrtn.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux myrtn far</TT>
<BR><BR>Note that this overrides the calling sequence that would normally be generated for a particular memory model.&nbsp;
In other words, a far call will be generated even if you are compiling for a memory model with a small code model.
<BR><BR>In the following example, Open Watcom F77 will generate a near call to the subprogram<TT> myrtn.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux myrtn near</TT>
<BR><BR>Note that this overrides the calling sequence that would normally be generated for a particular memory model.&nbsp;
In other words, a near call will be generated even if you are compiling for a memory model with a big code model.
<BR><BR>In the following DOS example, Open Watcom F77 will generate the sequence of bytes following the &quot;=&quot; character
in the auxiliary pragma whenever a call to<TT> mode4</TT> is encountered.<TT>&nbsp; mode4</TT> is called an in-line subprogram.
&nbsp;
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux mode4 =&nbsp;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp; zb4 z00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\ mov AH,0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp; zb0 z04&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\ mov AL,4</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp; zcd z10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\ int 10h</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp; modify [ AH AL ]</TT>
<BR><BR>The sequence in the above DOS example represents the following lines of assembly language instructions.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp; AH,0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; select function &quot;set mode&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp; AL,4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; specify mode (mode 4)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; 10H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; BIOS video call</TT>
<BR><BR>The above example demonstrates how to generate BIOS function calls in-line without writing an assembly language function
and calling it from your FORTRAN 77 program.
<BR><BR>The following DOS example is equivalent to the above example but mnemonics for the assembly language instructions
are used instead of the binary encoding of the assembly language instructions.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux mode4 =&nbsp;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp; &quot;mov AH,0&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp; &quot;mov AL,4&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp; &quot;int 10H&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp; modify [ AH AL ]</TT>
<BR><BR>The<TT> __far16</TT> attribute should only be used on systems that permit the calling of 16-bit code from 32-bit code.
&nbsp;Currently, the only supported operating system that allows this is 32-bit OS/2.&nbsp; If you have any libraries of subprograms
or APIs that are only available as 16-bit code and you wish to access these subprograms and APIs from 32-bit code, you must
specify the<TT> __far16</TT> attribute.&nbsp; If the<TT> __far16</TT> attribute is specified, the compiler will generate special
code which allows the 16-bit code to be called from 32-bit code.&nbsp; Note that a<TT> __far16</TT> function must be a function
whose attributes are those specified by one of the alias names<TT> __cdecl</TT> or<TT> __pascal</TT> .&nbsp; These alias names
will be described in a later section.
<BR><BR>The file<TT> bsesub.fap</TT> in the<TT> \watcom\src\fortran\os2</TT> directory contains examples of pragmas that use
the<TT> far16</TT> attribute to describe the 16-bit VIO, KBD and MOU subsystems available in 32-bit OS/2.
<H4 ID="32Mbit__Loading_Data_Segment_Register"> 32-bit:&nbsp; Loading Data Segment Register </H4>
<BR>An application may have been compiled so that the segment register DS does not contain the segment address of the default
data segment (group &quot;DGROUP&quot;).&nbsp; This is usually the case if you are using a large data memory model.&nbsp;
Suppose you wish to call a subprogram that assumes that the segment register DS contains the segment address of the default
data segment.&nbsp; It would be very cumbersome if you were forced to compile your application so that the segment register
DS contained the default data segment (a small data memory model).
<BR><BR>The following form of the auxiliary pragma will cause the segment register DS to be loaded with the segment address
of the default data segment before calling the specified subprogram.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux </TT><B>sym</B><TT> parm loadds </TT>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a subprogram name.
</DL>
<BR>Alternatively, the following form of the auxiliary pragma will cause the segment register DS to be loaded with the segment
address of the default data segment as part of the prologue sequence for the specified subprogram.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux </TT><B>sym</B><TT> loadds </TT>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a subprogram name.
</DL>
<H4 ID="32Mbit__Defining_Exported_Symbols_in_Dynamic_Link_Libraries"> 32-bit:&nbsp; Defining Exported Symbols in Dynamic Link Libraries </H4>
<BR>An exported symbol in a dynamic link library is a symbol that can be referenced by an application that is linked with
that dynamic link library.&nbsp; Normally, symbols in dynamic link libraries are exported using the Open Watcom Linker &quot;EXPORT&quot;
directive.&nbsp; An alternative method is to use the following form of the auxiliary pragma.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux </TT><B>sym</B><TT> export </TT>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a subprogram name.
</DL>
<H3 ID="32Mbit__Describing_Argument_Information"> 32-bit:&nbsp; Describing Argument Information </H3>
<BR>Using auxiliary pragmas, you can describe the calling convention that Open Watcom F77 is to use for calling subprograms.
&nbsp;This is particularly useful when interfacing to subprograms that have been compiled by other compilers or subprograms
written in other programming languages.
<BR><BR>The general form of an auxiliary pragma that describes argument passing is the following.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux </TT><B>sym</B><TT> parm </TT><B>{ arg_info | pop_info | </B><TT>reverse</TT><B>
{reg_set} }</B>
<BR><BR><B>&nbsp;&nbsp;&nbsp;&nbsp; arg_info ::=</B><TT> ( </TT><B>arg_attr</B><TT> </TT><B>{</B><TT>, </TT><B>arg_attr}</B><TT>
)</TT>
<BR><BR><B>&nbsp;&nbsp;&nbsp;&nbsp; arg_attr ::=</B><TT> value </TT><B>[v_attr]</B>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;</TT><B>|</B><TT> reference </TT><B>[r_attr]</B>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;</TT><B>|</B><TT> data_reference </TT><B>[d_attr]</B>
<BR><BR><B>&nbsp;&nbsp;&nbsp;&nbsp; v_attr ::=</B><TT> far </TT><B>|</B><TT> near </TT><B>|</B><TT> *1 </TT><B>|</B><TT> *2
</TT><B>|</B><TT> *4 </TT><B>|</B><TT> *8</TT>
<BR><BR><B>&nbsp;&nbsp;&nbsp;&nbsp; r_attr ::=</B><TT> </TT><B>[</B><TT>far </TT><B>|</B><TT> near</TT><B>]</B><TT> </TT><B>[</B><TT>descriptor
</TT><B>|</B><TT> nodescriptor</TT><B>]</B>
<BR><BR><B>&nbsp;&nbsp;&nbsp;&nbsp; d_attr ::=</B><TT> </TT><B>[</B><TT>far </TT><B>|</B><TT> near</TT><B>]</B>
<BR><BR><B>&nbsp;&nbsp;&nbsp;&nbsp; pop_info ::=</B><TT> caller </TT><B>|</B><TT> routine</TT>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a subprogram name.
<DT>reg_set
<DD>is called a register set.&nbsp; The register sets specify the registers that are to be used for argument passing.&nbsp; A
register set is a list of registers separated by spaces and enclosed in square brackets.
</DL>
<H4 ID="32Mbit__Passing_Arguments_to_nonMFORTRAN_Subprograms"> 32-bit:&nbsp; Passing Arguments to non-FORTRAN Subprograms </H4>
<BR>When calling a subprogram written in a different language, it may be necessary to provide the arguments in a form different
than the default methods used by Open Watcom F77.&nbsp; For example, C functions require scalar arguments to be passed by
value instead of by reference.&nbsp; For information on the methods Open Watcom F77 uses to pass arguments, see the chapter
entitled &quot;Assembly Language Considerations&quot;.
<BR><BR>The following form of the auxiliary pragma can be used to alter the default calling mechanism used for passing arguments.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux </TT><B>sym</B><TT> parm ( </TT><B>arg_attr</B><TT> </TT><B>{</B><TT>, </TT><B>arg_attr}</B><TT>
)</TT>
<BR><BR><B>&nbsp;&nbsp;&nbsp;&nbsp; arg_attr ::=</B><TT> value </TT><B>[v_attr]</B>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;</TT><B>|</B><TT> reference </TT><B>[r_attr]</B>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;</TT><B>|</B><TT> data_reference </TT><B>[d_attr]</B>
<BR><BR><B>&nbsp;&nbsp;&nbsp;&nbsp; v_attr ::=</B><TT> far </TT><B>|</B><TT> near </TT><B>|</B><TT> *1 </TT><B>|</B><TT> *2
</TT><B>|</B><TT> *4 </TT><B>|</B><TT> *8</TT>
<BR><BR><B>&nbsp;&nbsp;&nbsp;&nbsp; r_attr ::=</B><TT> </TT><B>[</B><TT>far </TT><B>|</B><TT> near</TT><B>]</B><TT> </TT><B>[</B><TT>descriptor
</TT><B>|</B><TT> nodescriptor</TT><B>]</B>
<BR><BR><B>&nbsp;&nbsp;&nbsp;&nbsp; d_attr ::=</B><TT> </TT><B>[</B><TT>far </TT><B>|</B><TT> near</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a subprogram name.
<DT>REFERENCE
<DD>specifies that arguments are to be passed by reference.&nbsp; For non-character arguments, the address is a pointer to the
data.&nbsp; For character arguments, the address is a pointer to a string descriptor.&nbsp; See the chapter entitled &quot;Assembly
Language Considerations&quot; for a description of a string descriptor.&nbsp; This is the default calling mechanism.&nbsp;
If &quot;NEAR&quot; or &quot;FAR&quot; is specified, a near pointer or far pointer is passed regardless of the memory model
used at compile-time.
<BR><BR>If the &quot;DESCRIPTOR&quot; attribute is specified, a pointer to the string descriptor is passed.&nbsp; This is
the default.&nbsp; If the &quot;NODESCRIPTOR&quot; attribute is specified, a pointer to the the actual character data is passed
instead of a pointer to the string descriptor.
<DT>DATA_REFERENCE
<DD>specifies that arguments are to be passed by data reference.&nbsp; For non-character items, this is identical to passing by
reference.&nbsp; For character items, a pointer to the actual character data (instead of the string descriptor) is passed.
&nbsp;If &quot;NEAR&quot; or &quot;FAR&quot; is specified, a near pointer or far pointer is passed regardless of the memory
model used at compile-time.
<DT>VALUE
<DD>specifies that arguments are to be passed by value.&nbsp; Character arguments are treated specially when passed by value.
&nbsp;Instead of passing a pointer to a string descriptor, a pointer to the actual character data is passed.&nbsp; See the
chapter entitled &quot;Assembly Language Considerations&quot; for a description of a string descriptor.
</DL>
<BR><B>Notes:</B>
<OL>
<LI>Arrays and subprograms are always passed by reference, regardless of the argument attribute specified.
<LI>When character arguments are passed by reference, the address of a string descriptor is passed.&nbsp; The string descriptor
contains the address of the actual character data and the number of characters.&nbsp; When character arguments are passed
by value or data reference, the address of the actual character data is passed instead of the address of a string descriptor.
&nbsp;Character arguments are passed by value by specifying the &quot;VALUE&quot; or &quot;DATA_REFERENCE&quot; attribute.
&nbsp;If &quot;NEAR&quot; or &quot;FAR&quot; is specified, a near pointer or far pointer to the character data is passed regardless
of the memory model used at compile-time.
<LI>When complex arguments are passed by value, the real part and the imaginary part are passed as two separate arguments.
<LI>When an argument is a user-defined structure and is passed by value, a copy of the structure is made and passed as an
argument.
<LI>For scalar arguments, arguments of type<B> INTEGER*1</B>,<B> INTEGER*2</B>,<B> INTEGER*4</B> ct ,<B> REAL</B> or<B> DOUBLE
PRECISION</B>, a length specification can be specified when the &quot;VALUE&quot; attribute is specified to pass the argument
by value.&nbsp; This length specification refers to the size of the argument; the compiler will convert the actual argument
to a type that matches the size.&nbsp; For example, if an argument of type<B> REAL</B> is passed to a subprogram that has
an argument attribute of &quot;VALUE*8&quot;, the argument will be converted to<B> DOUBLE PRECISION</B>.&nbsp; If an argument
of type<B> DOUBLE PRECISION</B> is passed to a subprogram that has an argument attribute of &quot;VALUE*4&quot;, the argument
will be converted to<B> REAL</B>.&nbsp; If an argument of type<B> INTEGER*4</B> is passed to a subprogram that has an argument
attribute of &quot;VALUE*2&quot; or VALUE*1, the argument will be converted to<B> INTEGER*2</B> or<B> INTEGER*1</B>.&nbsp;
If an argument of type<B> INTEGER*2</B> is passed to a subprogram that has an argument attribute of &quot;VALUE*4 or VALUE*1&quot;,
the argument will be converted to<B> INTEGER*4</B> or<B> INTEGER*1</B>.&nbsp; If an argument of type<B> INTEGER*1</B> is passed
to a subprogram that has an argument attribute of &quot;VALUE*4 or VALUE*2&quot;, the argument will be converted to<B> INTEGER*4</B>
or<B> INTEGER*2</B>.
<LI>If the number of arguments exceeds the number of entries in the argument-attribute list, the last attribute will be assumed
for the remaining arguments.
</OL>
<BR>Consider the following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux printf &quot;*_&quot; parm (value) caller []</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character cr/z0d/, nullchar/z00/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call printf( 'values: %ld, %ld'//cr//nullchar,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; 77, 31410 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>The C &quot;printf&quot; function is called with three arguments.&nbsp; The first argument is of type<B> CHARACTER</B>
and is passed as a C string (address of actual data terminated by a null character).&nbsp; The second and third arguments
are passed by value.&nbsp; Also note that &quot;printf&quot; is a function that takes a variable number of arguments, all
passed on the stack (an empty register set was specified), and that the caller must remove the arguments from the stack.
<H4 ID="32Mbit__Passing_Arguments_in_Registers"> 32-bit:&nbsp; Passing Arguments in Registers </H4>
<BR>The following form of the auxiliary pragma can be used to specify the registers that are to be used to pass arguments
to a particular subprogram.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux </TT><B>sym</B><TT> parm </TT><B>{reg_set}</B><TT> </TT>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a subprogram name.
<DT>reg_set
<DD>is called a register set.&nbsp; The register sets specify the registers that are to be used for argument passing.&nbsp; A
register set is a list of registers separated by spaces and enclosed in square brackets.
</DL>
<BR>Register sets establish a priority for register allocation during argument list processing.&nbsp; Register sets are processed
from left to right.&nbsp; However, within a register set, registers are chosen in any order.&nbsp; Once all register sets
have been processed, any remaining arguments are pushed on the stack.
<BR><BR>Note that regardless of the register sets specified, only certain combinations of registers will be selected for arguments
of a particular type.
<BR><BR>Note that arguments of type<B> REAL</B> and<B> DOUBLE PRECISION</B> are always pushed on the stack when the &quot;fpi&quot;
or &quot;fpi87&quot; option is used.
<DL>
<DT>DOUBLE PRECISION
<DD>Arguments of type<B> DOUBLE PRECISION</B>, when passed by value, can only be passed in one of the following register pairs:
&nbsp;EDX:EAX, ECX:EBX, ECX:EAX, ECX:ESI, EDX:EBX, EDI:EAX, ECX:EDI, EDX:ESI, EDI:EBX, ESI:EAX, ECX:EDX, EDX:EDI, EDI:ESI,
ESI:EBX or EBX:EAX.&nbsp; For example, if the following register set was specified for a routine having an argument of type<B>
DOUBLE PRECISION</B>,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [EBP EBX]</TT>
<BR><BR>the argument would be pushed on the stack since a valid register combination for 8-byte arguments is not contained
in the register set.&nbsp; Note that this method for passing arguments of type<B> DOUBLE PRECISION</B> is supported only when
the &quot;fpc&quot; option is used.&nbsp; Note that this argument passing method does not include arguments of type<B> COMPLEX*8</B>
or user-defined structures whose size is 8 bytes when these arguments are passed by value.
<DT>far pointer
<DD>A far pointer can only be passed in one of the following register pairs:&nbsp; DX:EAX, CX:EBX, CX:EAX, CX:ESI, DX:EBX, DI:EAX,
CX:EDI, DX:ESI, DI:EBX, SI:EAX, CX:EDX, DX:EDI, DI:ESI, SI:EBX, BX:EAX, FS:ECX, FS:EDX, FS:EDI, FS:ESI, FS:EBX, FS:EAX, GS:ECX,
GS:EDX, GS:EDI, GS:ESI, GS:EBX, GS:EAX, DS:ECX, DS:EDX, DS:EDI, DS:ESI, DS:EBX, DS:EAX, ES:ECX, ES:EDX, ES:EDI, ES:ESI, ES:EBX
or ES:EAX.&nbsp; For example, if a far pointer is passed to a function with the following register set,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [ES EBP]</TT>
<BR><BR>the argument would be pushed on the stack since a valid register combination for a far pointer is not contained in
the register set.&nbsp; Far pointers are used to pass arguments by reference in a big data memory model.
<DT>INTEGER
<DD>The only registers that will be assigned to 4-byte arguments (e.g., arguments of type<B> INTEGER</B> when passed by value
or arguments passed by reference in a small data memory model) are:&nbsp; EAX, EBX, ECX, EDX, ESI and EDI.&nbsp; For example,
if the following register set was specified for a routine with one argument of type<B> INTEGER</B>,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [EBP]</TT>
<BR><BR>the argument would be pushed on the stack since a valid register combination for 4-byte arguments is not contained
in the register set.&nbsp; Note that this argument passing method also includes arguments of type<B> REAL</B> but only when
the &quot;fpc&quot; option is used.
<DT>INTEGER*1, INTEGER*2
<DD>Arguments whose size is 1 byte or 2 bytes (e.g., arguments of type<B> INTEGER*1</B> and<B> INTEGER*2</B> as well as 2-byte
structures when passed by value) are promoted to 4 bytes and are then assigned registers as if they were 4-byte arguments.
<DT>others
<DD>Arguments that do not fall into one of the above categories cannot be passed in registers and are pushed on the stack.&nbsp;
Once an argument has been assigned a position on the stack, all remaining arguments will be assigned a position on the stack
even if all register sets have not yet been exhausted.
</DL>
<BR><B>Notes:</B>
<OL>
<LI>The default register set is [EAX EBX ECX EDX].
<LI>Specifying registers AH and AL is equivalent to specifying register AX.&nbsp; Specifying registers DH and DL is equivalent
to specifying register DX.&nbsp; Specifying registers CH and CL is equivalent to specifying register CX.&nbsp; Specifying
registers BH and BL is equivalent to specifying register BX.&nbsp; Specifying register EAX implies that register AX has been
specified.&nbsp; Specifying register EBX implies that register BX has been specified.&nbsp; Specifying register ECX implies
that register CX has been specified.&nbsp; Specifying register EDX implies that register DX has been specified.&nbsp; Specifying
register EDI implies that register DI has been specified.&nbsp; Specifying register ESI implies that register SI has been
specified.&nbsp; Specifying register EBP implies that register BP has been specified.&nbsp; Specifying register ESP implies
that register SP has been specified.
<LI>If you are compiling for a memory model with a small data model, any register combination containing register DS becomes
illegal.&nbsp; In a small data model, segment register DS must remain unchanged as it points to the program's data segment.
<LI>If you are compiling for the flat memory model, any register combination containing DS or ES becomes illegal.&nbsp; In
a flat memory model, code and data reside in the same segment.&nbsp; Segment registers DS and ES point to this segment and
must remain unchanged.
</OL>
<BR>Consider the following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux myrtn parm (value) \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [eax ebx ecx edx] [ebp esi]</TT>
<BR><BR>Suppose<TT> myrtn</TT> is a routine with 3 arguments each of type<B> DOUBLE PRECISION</B>.&nbsp; Note that the arguments
are passed by value.
<OL>
<LI>The first argument will be passed in the register pair EDX:EAX.
<LI>The second argument will be passed in the register pair ECX:EBX.
<LI>The third argument will be pushed on the stack since EBP:ESI is not a valid register pair for arguments of type<B> DOUBLE
PRECISION</B>.
</OL>
<BR>It is possible for registers from the second register set to be used before registers from the first register set are
used.&nbsp; Consider the following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux myrtn parm (value) \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [eax ebx ecx edx] [esi edi]</TT>
<BR><BR>Suppose<TT> myrtn</TT> is a routine with 3 arguments, the first of type<B> INTEGER</B> and the second and third of
type<B> DOUBLE PRECISION</B>.&nbsp; Note that all arguments are passed by value.
<OL>
<LI>The first argument will be passed in the register EAX.
<LI>The second argument will be passed in the register pair ECX:EBX.
<LI>The third argument will be passed in the register set EDI:ESI.
</OL>
<BR>Note that registers are no longer selected from a register set after registers are selected from subsequent register sets,
even if all registers from the original register set have not been exhausted.
<BR><BR>An empty register set is permitted.&nbsp; All subsequent register sets appearing after an empty register set are ignored;
all remaining arguments are pushed on the stack.
<BR><BR><B>Notes:</B>
<OL>
<LI>If a single empty register set is specified, all arguments are passed on the stack.
<LI>If no register set is specified, the default register set [EAX EBX ECX EDX] is used.
</OL>
<H4 ID="32Mbit__Forcing_Arguments_into_Specific_Registers"> 32-bit:&nbsp; Forcing Arguments into Specific Registers </H4>
<BR>It is possible to force arguments into specific registers.&nbsp; Suppose you have a subprogram, say &quot;mycopy&quot;,
that copies data.&nbsp; The first argument is the source, the second argument is the destination, and the third argument is
the length to copy.&nbsp; If we want the first argument to be passed in the register ESI, the second argument to be passed
in register EDI and the third argument to be passed in register ECX, the following auxiliary pragma can be used.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux mycopy parm (value) \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ESI] [EDI] [ECX]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character*10&nbsp; dst</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call mycopy( dst, '0123456789', 10 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>Note that you must be aware of the size of the arguments to ensure that the arguments get passed in the appropriate
registers.
<H4 ID="32Mbit__Passing_Arguments_to_InMLine_Subprograms"> 32-bit:&nbsp; Passing Arguments to In-Line Subprograms </H4>
<BR>For subprograms whose code is generated by Open Watcom F77 and whose argument list is described by an auxiliary pragma,
Open Watcom F77 has some freedom in choosing how arguments are assigned to registers.&nbsp; Since the code for in-line subprograms
is specified by the programmer, the description of the argument list must be very explicit.&nbsp; To achieve this, Open Watcom
F77 assumes that each register set corresponds to an argument.&nbsp; Consider the following DOS example of an in-line subprogram
called<TT> scrollactivepgup.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux scrollactivepgup =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp; &quot;mov AH,6&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp; &quot;int 10h&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp; parm (value)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ch] [cl] [dh] [dl] [al] [bh] \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp; modify [ah]</TT>
<BR><BR>The BIOS video call to scroll the active page up requires the following arguments.
<OL>
<LI>The row and column of the upper left corner of the scroll window is passed in registers CH and CL respectively.
<LI>The row and column of the lower right corner of the scroll window is passed in registers DH and DL respectively.
<LI>The number of lines blanked at the bottom of the window is passed in register AL.
<LI>The attribute to be used on the blank lines is passed in register BH.
</OL>
<BR>When passing arguments, Open Watcom F77 will convert the argument so that it fits in the register(s) specified in the
register set for that argument.&nbsp; For example, in the above example, if the first argument to<TT> scrollactivepgup</TT>
was called with an argument whose type was<B> INTEGER</B>, it would first be converted to<B> INTEGER*1</B> before assigning
it to register CH.&nbsp; Similarly, if an in-line subprogram required its argument in register EAX and the argument was of
type<B> INTEGER*2</B>, the argument would be converted to<B> INTEGER*4</B> before assigning it to register EAX.
<BR><BR>In general, Open Watcom F77 assigns the following types to register sets.
<OL>
<LI>A register set consisting of a single 8-bit register (1 byte) is assigned a type of<B> INTEGER*1</B>.
<LI>A register set consisting of a single 16-bit register (2 bytes) is assigned a type of<B> INTEGER*2</B>.
<LI>A register set consisting of a single 32-bit register (4 bytes) is assigned a type of<B> INTEGER*4</B>.
<LI>A register set consisting of two 32-bit registers (8 bytes) is assigned a type of<B> DOUBLE PRECISION</B>.
</OL>
<BR>If the size of an integer argument is larger than the size specified by the register set, the argument will be truncated
to the required size.&nbsp; If the size of an integer argument is smaller than the size specified by the register set, the
argument will be padded (to the left) with zeros.
<H4 ID="32Mbit__Removing_Arguments_from_the_Stack"> 32-bit:&nbsp; Removing Arguments from the Stack </H4>
<BR>The following form of the auxiliary pragma specifies who removes from the stack arguments that were pushed on the stack.
&nbsp;
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux </TT><B>sym</B><TT> parm </TT><B>(</B><TT>caller </TT><B>|</B><TT> routine</TT><B>)</B><TT>
</TT>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a subprogram name.
</DL>
<BR>&quot;caller&quot; specifies that the caller will pop the arguments from the stack; &quot;routine&quot; specifies that
the called routine will pop the arguments from the stack.&nbsp; If &quot;caller&quot; or &quot;routine&quot; is omitted, &quot;routine&quot;
is assumed unless the default has been changed in a previous auxiliary pragma, in which case the new default is assumed.
<BR><BR>Consider the following example.&nbsp; It describes the pragma required to call the C &quot;printf&quot; function.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux printf &quot;*_&quot; parm (value) caller []</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character cr/z0d/, nullchar/z00/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call printf( 'value is %ld'//cr//nullchar,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; 7143 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>The first argument must be passed as a C string, a pointer to the actual character data terminated by a null character.
&nbsp;By default, the address of a string descriptor is passed for arguments of type<B> CHARACTER</B>.&nbsp; See the chapter
entitled &quot;Assembly Language Considerations&quot; for more information on string descriptors.&nbsp; The second argument
is of type<B> INTEGER</B> and is passed by value.&nbsp; Also note that &quot;printf&quot; is a function that takes a variable
number of arguments, all pushed on the stack (an empty register set was specified).
<H4 ID="32Mbit__Passing_Arguments_in_Reverse_Order"> 32-bit:&nbsp; Passing Arguments in Reverse Order </H4>
<BR>The following form of the auxiliary pragma specifies that arguments are passed in the reverse order.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux </TT><B>sym</B><TT> parm reverse </TT>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a subprogram name.
</DL>
<BR>Normally, arguments are processed from left to right.&nbsp; The leftmost arguments are passed in registers and the rightmost
arguments are passed on the stack (if the registers used for argument passing have been exhausted).&nbsp; Arguments that are
passed on the stack are pushed from right to left.
<BR><BR>When arguments are reversed, the rightmost arguments are passed in registers and the leftmost arguments are passed
on the stack (if the registers used for argument passing have been exhausted).&nbsp; Arguments that are passed on the stack
are pushed from left to right.
<BR><BR>Reversing arguments is most useful for subprograms that require arguments to be passed on the stack in an order opposite
from the default.&nbsp; The following auxiliary pragma demonstrates such a subprogram.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux rtn parm reverse []</TT>
<H3 ID="32Mbit__Describing_Subprogram_Return_Information"> 32-bit:&nbsp; Describing Subprogram Return Information </H3>
<BR>Using auxiliary pragmas, you can describe the way functions are to return values.&nbsp; This is particularly useful when
interfacing to functions that have been compiled by other compilers or functions written in other programming languages.
<BR><BR>The general form of an auxiliary pragma that describes the way a function returns its value is the following.&nbsp;

<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux </TT><B>sym</B><TT> value </TT><B>{</B><TT>no8087 </TT><B>|</B><TT> </TT><B>reg_set</B><TT>
</TT><B>|</B><TT> </TT><B>struct_info}</B><TT> </TT>
<BR><BR><B>&nbsp;&nbsp;&nbsp;&nbsp; struct_info ::=</B><TT> struct </TT><B>{</B><TT>float </TT><B>|</B><TT> struct </TT><B>|</B><TT>
</TT><B>(</B><TT>routine </TT><B>|</B><TT> caller</TT><B>)</B><TT> </TT><B>|</B><TT> </TT><B>reg_set}</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a function name.
<DT>reg_set
<DD>is called a register set.&nbsp; The register sets specify the registers that are to be used for argument passing.&nbsp; A
register set is a list of registers separated by spaces and enclosed in square brackets.
</DL>
<H4 ID="32Mbit__Returning_Subprogram_Values_in_Registers"> 32-bit:&nbsp; Returning Subprogram Values in Registers </H4>
<BR>The following form of the auxiliary pragma can be used to specify the registers that are to be used to return a function's
value.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux </TT><B>sym</B><TT> value </TT><B>reg_set</B><TT> </TT>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a subprogram name.
<DT>reg_set
<DD>is a register set.
</DL>
<BR>Note that the method described below for returning values of type<B> REAL</B> or<B> DOUBLE PRECISION</B> is supported
only when the &quot;fpc&quot; option is used.
<BR><BR>Depending on the type of the return value, only certain registers are allowed in<B> reg_set.</B>
<DL>
<DT>1-byte
<DD>For 1-byte return values, only the following registers are allowed:&nbsp; AL, AH, DL, DH, BL, BH, CL or CH.&nbsp; If no register
set is specified, register AL will be used.
<DT>2-byte
<DD>For 2-byte return values, only the following registers are allowed:&nbsp; AX, DX, BX, CX, SI or DI.&nbsp; If no register set
is specified, register AX will be used.
<DT>4-byte
<DD>For 4-byte return values (including near pointers), only the following register are allowed:&nbsp; EAX, EDX, EBX, ECX, ESI
or EDI.&nbsp; If no register set is specified, register EAX will be used.&nbsp; This form of the auxiliary pragma is legal
for functions of type<B> REAL</B> when using the &quot;fpc&quot; option only.
<DT>far pointer
<DD>For functions that return far pointers, the following register pairs are allowed:&nbsp; DX:EAX, CX:EBX, CX:EAX, CX:ESI, DX:EBX,
DI:EAX, CX:EDI, DX:ESI, DI:EBX, SI:EAX, CX:EDX, DX:EDI, DI:ESI, SI:EBX, BX:EAX, FS:ECX, FS:EDX, FS:EDI, FS:ESI, FS:EBX, FS:EAX,
GS:ECX, GS:EDX, GS:EDI, GS:ESI, GS:EBX, GS:EAX, DS:ECX, DS:EDX, DS:EDI, DS:ESI, DS:EBX, DS:EAX, ES:ECX, ES:EDX, ES:EDI, ES:ESI,
ES:EBX or ES:EAX.&nbsp; If no register set is specified, the registers DX:EAX will be used.
<DT>8-byte
<DD>For 8-byte return values (including functions of type<B> DOUBLE PRECISION</B>), only the following register pairs are allowed:
&nbsp;EDX:EAX, ECX:EBX, ECX:EAX, ECX:ESI, EDX:EBX, EDI:EAX, ECX:EDI, EDX:ESI, EDI:EBX, ESI:EAX, ECX:EDX, EDX:EDI, EDI:ESI,
ESI:EBX or EBX:EAX.&nbsp; If no register set is specified, the registers EDX:EAX will be used.&nbsp; This form of the auxiliary
pragma is legal for functions of type<B> DOUBLE PRECISION</B> when using the &quot;fpc&quot; option only.
</DL>
<BR><B>Notes:</B>
<OL>
<LI>An empty register set is not allowed.
<LI>If you are compiling for a memory model which has a small data model, any of the above register combinations containing
register DS becomes illegal.&nbsp; In a small data model, segment register DS must remain unchanged as it points to the program's
data segment.
<LI>If you are compiling for the flat memory model, any register combination containing DS or ES becomes illegal.&nbsp; In
a flat memory model, code and data reside in the same segment.&nbsp; Segment registers DS and ES point to this segment and
must remain unchanged.
</OL>
<H4 ID="32Mbit__Returning_Structures_and_Complex_Numbers"> 32-bit:&nbsp; Returning Structures and Complex Numbers </H4>
<BR>Typically, structures and complex numbers are not returned in registers.&nbsp; Instead, the caller allocates space on
the stack for the return value and sets register ESI to point to it.&nbsp; The called routine then places the return value
at the location pointed to by register ESI.
<BR><BR>Complex numbers are not scalars but rather an ordered pair of real numbers.&nbsp; One can also view complex numbers
as a<B> structure</B> containing two real numbers.
<BR><BR>The following form of the auxiliary pragma can be used to specify the register that is to be used to point to the
return value.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux </TT><B>sym</B><TT> value struct </TT><B>(</B><TT>caller</TT><B>|</B><TT>routine</TT><B>)</B><TT>
</TT><B>reg_set</B><TT> </TT>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a subprogram name.
<DT>reg_set
<DD>is a register set.
</DL>
<BR>&quot;caller&quot; specifies that the caller will allocate memory for the return value.&nbsp; The address of the memory
allocated for the return value is placed in the register specified in the register set by the caller before the function is
called.&nbsp; If an empty register set is specified, the address of the memory allocated for the return value will be pushed
on the stack immediately before the call and will be returned in register EAX by the called routine.
<BR><BR>&quot;routine&quot; specifies that the called routine will allocate memory for the return value.&nbsp; Upon returning
to the caller, the register specified in the register set will contain the address of the return value.&nbsp; An empty register
set is not allowed.
<BR><BR>Only the following registers are allowed in the register set:&nbsp; EAX, EDX, EBX, ECX, ESI or EDI.&nbsp; Note that
in a big data model, the address in the return register is assumed to be in the segment specified by the value in the SS segment
register.
<BR><BR>If the size of the structure being returned is 1, 2 or 4 bytes, it will be returned in registers.&nbsp; The return
register will be selected from the register set in the following way.
<OL>
<LI>A 1-byte structure will be returned in one of the following registers:&nbsp; AL, AH, DL, DH, BL, BH, CL or CH.&nbsp; If
no register set is specified, register AL will be used.
<LI>A 2-byte structure will be returned in one of the following registers:&nbsp; AX, DX, BX, CX, SI or DI.&nbsp; If no register
set is specified, register AX will be used.
<LI>A 4-byte structure will be returned in one of the following registers:&nbsp; EAX, EDX, EBX, ECX, ESI or EDI.&nbsp; If
no register set is specified, register EAX will be used.
</OL>
<BR>The following form of the auxiliary pragma can be used to specify that structures whose size is 1, 2 or 4 bytes are not
to be returned in registers.&nbsp; Instead, the caller will allocate space on the stack for the structure return value and
point register ESI to it.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux </TT><B>sym</B><TT> value struct struct </TT>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a subprogram name.
</DL>
<H4 ID="32Mbit__Returning_FloatingMPoint_Data"> 32-bit:&nbsp; Returning Floating-Point Data </H4>
<BR>There are a few ways available for specifying how the value for a function whose type is<B> REAL</B> or<B> DOUBLE PRECISION</B>
is to be returned.
<BR><BR>The following form of the auxiliary pragma can be used to specify that function return values whose type is<B> REAL</B>
or<B> DOUBLE PRECISION</B> are not to be returned in registers.&nbsp; Instead, the caller will allocate space on the stack
for the return value and point register ESI to it.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux </TT><B>sym</B><TT> value struct float </TT>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a function name.
</DL>
<BR>In other words, floating-point values are to be returned in the same way complex numbers are returned.
<BR><BR>The following form of the auxiliary pragma can be used to specify that function return values whose type is<B> REAL</B>
or<B> DOUBLE PRECISION</B> are not to be returned in 80x87 registers when compiling with the &quot;fpi&quot; or &quot;fpi87&quot;
option.&nbsp; Instead, the value will be returned in 80x86 registers.&nbsp; This is the default behaviour for the &quot;fpc&quot;
option.&nbsp; Function return values whose type is<B> REAL</B> will be returned in register EAX.&nbsp; Function return values
whose type is<B> DOUBLE PRECISION</B> will be returned in registers EDX:EAX.&nbsp; This is the default method for the &quot;fpc&quot;
option.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux </TT><B>sym</B><TT> value no8087 </TT>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a function name.
</DL>
<BR>The following form of the auxiliary pragma can be used to specify that function return values whose type is<B> REAL</B>
or<B> DOUBLE PRECISION</B> are to be returned in ST(0) when compiling with the &quot;fpi&quot; or &quot;fpi87&quot; option.
&nbsp;This form of the auxiliary pragma is not legal for the &quot;fpc&quot; option.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux </TT><B>sym</B><TT> value [8087] </TT>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a function name.
</DL>
<H3 ID="32Mbit__A_Subprogram_that_Never_Returns"> 32-bit:&nbsp; A Subprogram that Never Returns </H3>
<BR>The following form of the auxiliary pragma can be used to describe a subprogram that does not return to the caller.&nbsp;

<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux </TT><B>sym</B><TT> aborts </TT>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a subprogram name.
</DL>
<BR>Consider the following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux exitrtn aborts</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call exitrtn()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR><TT>exitrtn</TT> is defined to be a function that does not return.&nbsp; For example, it may call<TT> exit</TT> to
return to the system.&nbsp; In this case, Open Watcom F77 generates a &quot;jmp&quot; instruction instead of a &quot;call&quot;
instruction to invoke<TT> exitrtn.</TT>
<H3 ID="32Mbit__Describing_How_Subprograms_Use_Variables_in_Common"> 32-bit:&nbsp; Describing How Subprograms Use Variables in Common </H3>
<BR>The following form of the auxiliary pragma can be used to describe a subprogram that does not modify any variable that
appears in a common block defined by the caller.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux </TT><B>sym</B><TT> modify nomemory </TT>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a subprogram name.
</DL>
<BR>Consider the following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer i</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; common /blk/ i</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( i .lt. 1000 )do</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = i + 383</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endwhile</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call myrtn()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = i + 13143</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; block data</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; common /blk/ i</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer i/1033/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>To compile the above program, &quot;rtn.for&quot;, we issue the following command.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wfc rtn -mm -d1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wfc386 rtn -d1</TT>
<BR><BR>The &quot;d1&quot; compiler option is specified so that the object file produced by Open Watcom F77 contains source
line information.
<BR><BR>We can generate a file containing a disassembly of<TT> rtn.obj</TT> by issuing the following command.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wdis rtn -l -s -r</TT>
<BR><BR>The &quot;s&quot; option is specified so that the listing file produced by the Open Watcom Disassembler contains source
lines taken from<TT> rtn.for.</TT>&nbsp; The listing file<TT> rtn.lst</TT> appears as follows.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Module: rtn.for</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Group: 'DGROUP' _DATA,LDATA,CDATA,BLK</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Segment: 'FMAIN_TEXT' BYTE USE32&nbsp; 00000036 bytes</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer i</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; common /blk/ i</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0000&nbsp; 52&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; FMAIN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; edx</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0001&nbsp; 8b 15 00 00 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; edx,L3</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( i .lt. 1000 )do</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0007&nbsp; 81 fa e8 03 00 00 L1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; cmp&nbsp;&nbsp;&nbsp;&nbsp; edx,000003e8H</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 000d&nbsp; 7d 08&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jge&nbsp;&nbsp;&nbsp;&nbsp;
L2</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = i + 383</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endwhile</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 000f&nbsp; 81 c2 7f 01 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add&nbsp;&nbsp;&nbsp;&nbsp; edx,0000017fH</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0015&nbsp; eb f0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jmp&nbsp;&nbsp;&nbsp;&nbsp;
L1</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call myrtn()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0017&nbsp; 89 15 00 00 00 00 L2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; L3,edx</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 001d&nbsp; e8 00 00 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call&nbsp;&nbsp;&nbsp; MYRTN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0022&nbsp; 8b 15 00 00 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; edx,L3</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = i + 13143</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0028&nbsp; 81 c2 57 33 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add&nbsp;&nbsp;&nbsp;&nbsp; edx,00003357H</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 002e&nbsp; 89 15 00 00 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; L3,edx</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; block data</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; common /blk/ i</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer i/1033/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0034&nbsp; 5a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;
&nbsp; edx</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0035&nbsp; c3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; No disassembly errors</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; List of external symbols</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Symbol</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ----------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; MYRTN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0000001e</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ------------------------------------------------------------</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Segment: 'BLK' PARA USE32&nbsp; 00000004 bytes</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0000&nbsp; 09 04 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; L3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - ....</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; No disassembly errors</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ------------------------------------------------------------</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; List of public symbols</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SYMBOL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GROUP&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SEGMENT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ADDRESS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ---------------------------------------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; FMAIN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FMAIN_TEXT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 00000000</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ------------------------------------------------------------</TT>
<BR><BR>Let us add the following auxiliary pragma to the source file.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux myrtn modify nomemory</TT>
<BR><BR>If we compile the source file with the above pragma and disassemble the object file using the Open Watcom Disassembler,
we get the following listing file.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Module: rtn.for</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Group: 'DGROUP' _DATA,LDATA,CDATA,BLK</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Segment: 'FMAIN_TEXT' BYTE USE32&nbsp; 00000030 bytes</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux myrtn modify nomemory</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer i</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; common /blk/ i</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0000&nbsp; 52&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; FMAIN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; edx</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0001&nbsp; 8b 15 00 00 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; edx,L3</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( i .lt. 1000 )do</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0007&nbsp; 81 fa e8 03 00 00 L1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; cmp&nbsp;&nbsp;&nbsp;&nbsp; edx,000003e8H</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 000d&nbsp; 7d 08&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jge&nbsp;&nbsp;&nbsp;&nbsp;
L2</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = i + 383</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endwhile</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 000f&nbsp; 81 c2 7f 01 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add&nbsp;&nbsp;&nbsp;&nbsp; edx,0000017fH</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0015&nbsp; eb f0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jmp&nbsp;&nbsp;&nbsp;&nbsp;
L1</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call myrtn()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0017&nbsp; 89 15 00 00 00 00 L2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; L3,edx</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 001d&nbsp; e8 00 00 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call&nbsp;&nbsp;&nbsp; MYRTN</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = i + 13143</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0022&nbsp; 81 c2 57 33 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add&nbsp;&nbsp;&nbsp;&nbsp; edx,00003357H</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0028&nbsp; 89 15 00 00 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; L3,edx</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; block data</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; common /blk/ i</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer i/1033/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 002e&nbsp; 5a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;
&nbsp; edx</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 002f&nbsp; c3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; No disassembly errors</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; List of external symbols</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Symbol</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ----------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; MYRTN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0000001e</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ------------------------------------------------------------</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Segment: 'BLK' PARA USE32&nbsp; 00000004 bytes</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0000&nbsp; 09 04 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; L3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - ....</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; No disassembly errors</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ------------------------------------------------------------</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; List of public symbols</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SYMBOL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GROUP&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SEGMENT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ADDRESS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ---------------------------------------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; FMAIN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FMAIN_TEXT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 00000000</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ------------------------------------------------------------</TT>
<BR><BR>Notice that the value of<TT> i</TT> is in register EDX after completion of the &quot;while&quot; loop.&nbsp; After
the call to<TT> myrtn,</TT> the value of<TT> i</TT> is not loaded from memory into a register to perform the final addition.
&nbsp;The auxiliary pragma informs the compiler that<TT> myrtn</TT> does not modify any variable that appears in a common
block defined by<TT> Rtn</TT> and hence register EDX contains the correct value of<TT> i.</TT>
<BR><BR>The preceding auxiliary pragma deals with routines that modify variables in common.&nbsp; Let us consider the case
where routines reference variables in common.&nbsp; The following form of the auxiliary pragma can be used to describe a subprogram
that does not reference any variable that appears in a common block defined by the caller.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux </TT><B>sym</B><TT> parm nomemory modify nomemory </TT>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a subprogram name.
</DL>
<BR><B>Notes:</B>
<OL>
<LI>You must specify both &quot;parm nomemory&quot; and &quot;modify nomemory&quot;.
</OL>
<BR>Let us replace the auxiliary pragma in the above example with the following auxiliary pragma.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux myrtn parm nomemory modify nomemory</TT>
<BR><BR>If you now compile our source file and disassemble the object file using WDIS, the result is the following listing
file.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Module: rtn.for</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Group: 'DGROUP' _DATA,LDATA,CDATA,BLK</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Segment: 'FMAIN_TEXT' BYTE USE32&nbsp; 0000002a bytes</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux myrtn parm nomemory modify nomemory</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer i</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; common /blk/ i</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0000&nbsp; 52&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; FMAIN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; edx</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0001&nbsp; 8b 15 00 00 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; edx,L3</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( i .lt. 1000 )do</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0007&nbsp; 81 fa e8 03 00 00 L1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; cmp&nbsp;&nbsp;&nbsp;&nbsp; edx,000003e8H</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 000d&nbsp; 7d 08&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jge&nbsp;&nbsp;&nbsp;&nbsp;
L2</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = i + 383</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endwhile</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 000f&nbsp; 81 c2 7f 01 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add&nbsp;&nbsp;&nbsp;&nbsp; edx,0000017fH</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0015&nbsp; eb f0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jmp&nbsp;&nbsp;&nbsp;&nbsp;
L1</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call myrtn()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0017&nbsp; e8 00 00 00 00&nbsp;&nbsp;&nbsp; L2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call&nbsp;&nbsp;&nbsp; MYRTN</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = i + 13143</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 001c&nbsp; 81 c2 57 33 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add&nbsp;&nbsp;&nbsp;&nbsp; edx,00003357H</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0022&nbsp; 89 15 00 00 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; L3,edx</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; block data</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; common /blk/ i</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer i/1033/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0028&nbsp; 5a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;
&nbsp; edx</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0029&nbsp; c3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; No disassembly errors</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; List of external symbols</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Symbol</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ----------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; MYRTN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 00000018</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ------------------------------------------------------------</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Segment: 'BLK' PARA USE32&nbsp; 00000004 bytes</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0000&nbsp; 09 04 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; L3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - ....</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; No disassembly errors</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ------------------------------------------------------------</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; List of public symbols</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SYMBOL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GROUP&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SEGMENT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ADDRESS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ---------------------------------------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; FMAIN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FMAIN_TEXT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 00000000</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ------------------------------------------------------------</TT>
<BR><BR>Notice that after completion of the &quot;while&quot; loop we did not have to update<TT> i</TT> with the value in
register EDX before calling<TT> myrtn.</TT>&nbsp; The auxiliary pragma informs the compiler that<TT> myrtn</TT> does not reference
any variable that appears in a common block defined by<TT> myrtn</TT> so updating<TT> i</TT> was not necessary before calling<TT>
myrtn.</TT>
<H3 ID="32Mbit__Describing_the_Registers_Modified_by_a_Subprogram"> 32-bit:&nbsp; Describing the Registers Modified by a Subprogram </H3>
<BR>The following form of the auxiliary pragma can be used to describe the registers that a subprogram will use without saving.
&nbsp;
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux </TT><B>sym</B><TT> modify </TT><B>[</B><TT>exact</TT><B>]</B><TT> </TT><B>reg_set</B><TT>
</TT>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a subprogram name.
<DT>reg_set
<DD>is a register set.
</DL>
<BR>Specifying a register set informs Open Watcom F77 that the registers belonging to the register set are modified by the
subprogram.&nbsp; That is, the value in a register before calling the subprogram is different from its value after execution
of the subprogram.
<BR><BR>Registers that are used to pass arguments are assumed to be modified and hence do not have to be saved and restored
by the called subprogram.&nbsp; Also, since the EAX register is frequently used to return a value, it is always assumed to
be modified.&nbsp; If necessary, the caller will contain code to save and restore the contents of registers used to pass arguments.
&nbsp;Note that saving and restoring the contents of these registers may not be necessary if the called subprogram does not
modify them.&nbsp; The following form of the auxiliary pragma can be used to describe exactly those registers that will be
modified by the called subprogram.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux </TT><B>sym</B><TT> modify exact </TT><B>reg_set</B><TT> </TT>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a subprogram name.
<DT>reg_set
<DD>is a register set.
</DL>
<BR>The above form of the auxiliary pragma tells Open Watcom F77 not to assume that the registers used to pass arguments will
be modified by the called subprogram.&nbsp; Instead, only the registers specified in the register set will be modified.&nbsp;
This will prevent generation of the code which unnecessarily saves and restores the contents of the registers used to pass
arguments.
<BR><BR>Also, any registers that are specified in the<TT> value</TT> register set are assumed to be unmodified unless explicitly
listed in the<TT> exact</TT> register set.&nbsp; In the following example, the code generator will not generate code to save
and restore the value of the stack pointer register since we have told it that &quot;GetSP&quot; does not modify any register
whatsoever.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$ifdef __386__</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux GetSP = value [esp] modify exact []</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux GetSP = value [sp] modify exact []</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$endif</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; program main</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer GetSP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print *, 'Current SP =', GetSP()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<H3 ID="32Mbit__Auxiliary_Pragmas_and_the_80x87"> 32-bit:&nbsp; Auxiliary Pragmas and the 80x87 </H3>
<BR>This section deals with those aspects of auxiliary pragmas that are specific to the 80x87.&nbsp; The discussion in this
chapter assumes that one of the &quot;fpi&quot; or &quot;fpi87&quot; options is used to compile subprograms.&nbsp; The following
areas are affected by the use of these options.
<OL>
<LI>passing floating-point arguments to functions,
<LI>returning floating-point values from functions and
<LI>which 80x87 floating-point registers are allowed to be modified by the called routine.
</OL>
<H4 ID="32Mbit__Using_the_80x87_to_Pass_Arguments"> 32-bit:&nbsp; Using the 80x87 to Pass Arguments </H4>
<BR>By default, floating-point arguments are passed on the 80x86 stack.&nbsp; The 80x86 registers are never used to pass floating-point
arguments when a subprogram is compiled with the &quot;fpi&quot; or &quot;fpi87&quot; option.&nbsp; However, they can be used
to pass arguments whose type is not floating-point such as arguments of type &quot;int&quot;.
<BR><BR>The following form of the auxiliary pragma can be used to describe the registers that are to be used to pass arguments
to subprograms.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux </TT><B>sym</B><TT> parm </TT><B>{reg_set}</B><TT> </TT>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a subprogram name.
<DT>reg_set
<DD>is a register set.&nbsp; The register set can contain 80x86 registers and/or the string &quot;8087&quot;.
</DL>
<BR><B>Notes:</B>
<OL>
<LI>If an empty register set is specified, all arguments, including floating-point arguments, will be passed on the 80x86
stack.
</OL>
<BR>When the string &quot;8087&quot; appears in a register set, it simply means that floating-point arguments can be passed
in 80x87 floating-point registers if the source file is compiled with the &quot;fpi&quot; or &quot;fpi87&quot; option.&nbsp;
Before discussing argument passing in detail, some general notes on the use of the 80x87 floating-point registers are given.
<BR><BR>The 80x87 contains 8 floating-point registers which essentially form a stack.&nbsp; The stack pointer is called ST
and is a number between 0 and 7 identifying which 80x87 floating-point register is at the top of the stack.&nbsp; ST is initially
0.&nbsp; 80x87 instructions reference these registers by specifying a floating-point register number.&nbsp; This number is
then added to the current value of ST.&nbsp; The sum (taken modulo 8) specifies the 80x87 floating-point register to be used.
&nbsp;The notation ST(n), where &quot;n&quot; is between 0 and 7, is used to refer to the position of an 80x87 floating-point
register relative to ST.
<BR><BR>When a floating-point value is loaded onto the 80x87 floating-point register stack, ST is decremented (modulo 8),
and the value is loaded into ST(0).&nbsp; When a floating-point value is stored and popped from the 80x87 floating-point register
stack, ST is incremented (modulo 8) and ST(1) becomes ST(0).&nbsp; The following illustrates the use of the 80x87 floating-point
registers as a stack, assuming that the value of ST is 4 (4 values have been loaded onto the 80x87 floating-point register
stack).
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; | 4th from top&nbsp;&nbsp;
|&nbsp; ST(4)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp; | 5th from top&nbsp;&nbsp;
|&nbsp; ST(5)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp; | 6th from top&nbsp;&nbsp;
|&nbsp; ST(6)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp; | 7th from top&nbsp;&nbsp;
|&nbsp; ST(7)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ST -&gt; 4&nbsp;&nbsp;&nbsp;&nbsp; | top of stack&nbsp;&nbsp; |&nbsp; ST(0)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5&nbsp;&nbsp;&nbsp;&nbsp; | 1st from top&nbsp;&nbsp;
|&nbsp; ST(1)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6&nbsp;&nbsp;&nbsp;&nbsp; | 2nd from top&nbsp;&nbsp;
|&nbsp; ST(2)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7&nbsp;&nbsp;&nbsp;&nbsp; | 3rd from top&nbsp;&nbsp;
|&nbsp; ST(3)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><BR>Starting with version 9.5, the Open Watcom compilers use all eight of the 80x87 registers as a stack.&nbsp; The initial
state of the 80x87 register stack is empty before a program begins execution.
<DL>
<DT>Note:
<DD>For compatibility with code compiled with version 9.0 and earlier, you can compile with the &quot;fpr&quot; option.&nbsp;
In this case only four of the eight 80x87 registers are used as a stack.&nbsp; These four registers were used to pass arguments.
&nbsp;The other four registers form what was called the 80x87 cache.&nbsp; The cache was used for local floating-point variables.
&nbsp;The state of the 80x87 registers before a program began execution was as follows.
<OL>
<LI>The four 80x87 floating-point registers that form the stack are uninitialized.
<LI>The four 80x87 floating-point registers that form the 80x87 cache are initialized with zero.
</OL>
<BR>Hence, initially the 80x87 cache was comprised of ST(0), ST(1), ST(2) and ST(3).&nbsp; ST had the value 4 as in the above
diagram.&nbsp; When a floating-point value was pushed on the stack (as is the case when passing floating-point arguments),
it became ST(0) and the 80x87 cache was comprised of ST(1), ST(2), ST(3) and ST(4).&nbsp; When the 80x87 stack was full, ST(0),
ST(1), ST(2) and ST(3) formed the stack and ST(4), ST(5), ST(6) and ST(7) formed the 80x87 cache.&nbsp; Version 9.5 and later
no longer use this strategy.
</DL>
<BR>The rules for passing arguments are as follows.
<OL>
<LI>If the argument is not floating-point, use the procedure described earlier in this chapter.
<LI>If the argument is floating-point, and a previous argument has been assigned a position on the 80x86 stack (instead of
the 80x87 stack), the floating-point argument is also assigned a position on the 80x86 stack.&nbsp; Otherwise proceed to the
next step.
<LI>If the string &quot;8087&quot; appears in a register set in the pragma, and if the 80x87 stack is not full, the floating-point
argument is assigned floating-point register ST(0) (the top element of the 80x87 stack).&nbsp; The previous top element (if
there was one) is now in ST(1).&nbsp; Since arguments are pushed on the stack from right to left, the leftmost floating-point
argument will be in ST(0).&nbsp; Otherwise the floating-point argument is assigned a position on the 80x86 stack.
</OL>
<BR>Consider the following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux myrtn parm (value) [8087];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real x</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double precision y</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer i</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer j</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = 7.7</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = 7</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y = 77.77</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j = 77</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call myrtn( x, i, y, j )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR><TT>myrtn</TT> is an assembly language subprogram that requires four arguments.&nbsp; The first argument of type<B>
REAL</B> (4 bytes), the second argument is of type<B> INTEGER</B> (4 bytes), the third argument is of type<B> DOUBLE PRECISION</B>
(8 bytes) and the fourth argument is of type<B> INTEGER*4</B> (4 bytes).&nbsp; These arguments will be passed to<TT> myrtn</TT>
in the following way.
<OL>
<LI>Since &quot;8087&quot; was specified in the register set, the first argument, being of type<B> REAL</B>, will be passed
in an 80x87 floating-point register.
<LI>The second argument will be passed on the stack since no 80x86 registers were specified in the register set.
<LI>The third argument will also be passed on the stack.&nbsp; Remember the following rule:&nbsp; once an argument is assigned
a position on the stack, all remaining arguments will be assigned a position on the stack.&nbsp; Note that the above rule
holds even though there are some 80x87 floating-point registers available for passing floating-point arguments.
<LI>The fourth argument will also be passed on the stack.
</OL>
<BR>Let us change the auxiliary pragma in the above example as follows.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux myrtn parm [eax 8087]</TT>
<BR><BR>The arguments will now be passed to<TT> myrtn</TT> in the following way.
<OL>
<LI>Since &quot;8087&quot; was specified in the register set, the first argument, being of type<B> REAL</B> will be passed
in an 80x87 floating-point register.
<LI>The second argument will be passed in register EAX, exhausting the set of available 80x86 registers for argument passing.
<LI>The third argument, being of type<B> DOUBLE PRECISION</B>, will also be passed in an 80x87 floating-point register.
<LI>The fourth argument will be passed on the stack since no 80x86 registers remain in the register set.
</OL>
<H4 ID="32Mbit__Using_the_80x87_to_Return_Subprogram_Values"> 32-bit:&nbsp; Using the 80x87 to Return Subprogram Values </H4>
<BR>The following form of the auxiliary pragma can be used to describe a subprogram that returns a floating-point value in
ST(0).&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux </TT><B>sym</B><TT> value </TT><B>reg_set</B><TT> </TT>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a subprogram name.
<DT>reg_set
<DD>is a register set containing the string &quot;8087&quot;, i.e.&nbsp; [8087].
</DL>
<H4 ID="32Mbit__Preserving_80x87_FloatingMPoint_Registers_Across_Calls"> 32-bit:&nbsp; Preserving 80x87 Floating-Point Registers Across Calls </H4>
<BR>The code generator assumes that all eight 80x87 floating-point registers are available for use within a subprogram unless
the &quot;fpr&quot; option is used to generate backward compatible code (older Open Watcom compilers used four registers as
a cache).&nbsp; The following form of the auxiliary pragma specifies that the floating-point registers in the 80x87 cache
may be modified by the specified subprogram.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$pragma aux </TT><B>sym</B><TT> modify </TT><B>reg_set</B><TT> </TT>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a subprogram name.
<DT>reg_set
<DD>is a register set containing the string &quot;8087&quot;, i.e.&nbsp; [8087].
</DL>
<BR>This instructs Open Watcom F77 to save any local variables that are located in the 80x87 cache before calling the specified
routine.
<H1 ID="Use_of_Environment_Variables"> Use of Environment Variables </H1>
<BR>In the Open Watcom FORTRAN 77 software development package, a number of environment variables are used.&nbsp; This appendix
summarizes their use with a particular component of the package.
<H2 ID="FINCLUDE"> FINCLUDE </H2>
<BR>The<B> FINCLUDE</B> environment variable describes the location of the Open Watcom FORTRAN 77 include files.&nbsp; This
variable is used by Open Watcom FORTRAN 77.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SET FINCLUDE=[d:][path];[d:][path]...</TT>
<BR><BR>The<B> FINCLUDE</B> environment string is like the<B> PATH</B> string in that you can specify one or more directories
separated by semicolons (&quot;;&quot;).
<H2 ID="LFN"> LFN </H2>
<BR>The<B> LFN</B> environment variable is checked by the Open Watcom run-time C libraries and it is used to control DOS LFN
(DOS Long File Name) support.&nbsp; Normally, these libraries will use DOS LFN support if it is available on host OS.&nbsp;
If you don't wish to use DOS LFN support, you can define the<B> LFN</B> environment variable and setup it's value to 'N'.
&nbsp;Using the &quot;SET&quot; command, define the environment variable as follows:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SET LFN=N</TT>
<BR><BR>Now, when you run your application, the DOS LFN support will be ignored.&nbsp; To undefine the environment variable,
enter the command:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SET LFN=</TT>
<H2 ID="LIB"> LIB </H2>
<BR>The use of the<B> WATCOM</B> environment variable and the Open Watcom Linker &quot;SYSTEM&quot; directive is recommended
over the use of this environment variable.
<BR><BR>The<B> LIB</B> environment variable is used to select the libraries that will be used when the application is linked.
&nbsp;This variable is used by the Open Watcom Linker (WLINK.EXE).&nbsp; The<B> LIB</B> environment string is like the<B>
PATH</B> string in that you can specify one or more directories separated by semicolons (&quot;;&quot;).
<BR><BR>If you have the 286 development system, 16-bit applications can be linked for DOS, Microsoft Windows, OS/2, and QNX
depending on which libraries are selected.&nbsp; If you have the 386 development system, 32-bit applications can be linked
for DOS Extender systems, Microsoft Windows and QNX.
<H2 ID="LIBDOS"> LIBDOS </H2>
<BR>The use of the<B> WATCOM</B> environment variable and the Open Watcom Linker &quot;SYSTEM&quot; directive is recommended
over the use of this environment variable.
<BR><BR>If you are developing a DOS application, the<B> LIBDOS</B> environment variable must include the location of the 16-bit
Open Watcom F77 DOS library files (files with the &quot;.lib&quot; filename extension).&nbsp; This variable is used by the
Open Watcom Linker (WLINK.EXE).&nbsp; The default installation directory for the 16-bit Open Watcom F77 DOS libraries is<TT>
\WATCOM\LIB286\DOS.</TT>
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set libdos=c:\watcom\lib286\dos</TT>
<H2 ID="LIBWIN"> LIBWIN </H2>
<BR>The use of the<B> WATCOM</B> environment variable and the Open Watcom Linker &quot;SYSTEM&quot; directive is recommended
over the use of this environment variable.
<BR><BR>If you are developing a 16-bit Microsoft Windows application, the<B> LIBWIN</B> environment variable must include
the location of the 16-bit Open Watcom F77 Windows library files (files with the &quot;.lib&quot; filename extension).&nbsp;
This variable is used by the Open Watcom Linker (WLINK.EXE).&nbsp; If you are developing a 32-bit Microsoft Windows application,
see the description of the<B> LIBPHAR</B> environment variable.&nbsp; The default installation directory for the 16-bit Open
Watcom F77 Windows libraries is<TT> \WATCOM\LIB286\WIN.</TT>
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set libwin=c:\watcom\lib286\win</TT>
<H2 ID="LIBOS2"> LIBOS2 </H2>
<BR>The use of the<B> WATCOM</B> environment variable and the Open Watcom Linker &quot;SYSTEM&quot; directive is recommended
over the use of this environment variable.
<BR><BR>If you are developing an OS/2 application, the<B> LIBOS2</B> environment variable must include the location of the
16-bit Open Watcom F77 OS/2 library files (files with the &quot;.lib&quot; filename extension).&nbsp; This variable is used
by the Open Watcom Linker (WLINK.EXE).&nbsp; The default installation directory for the 16-bit Open Watcom F77 OS/2 libraries
is<TT> \WATCOM\LIB286\OS2.</TT>&nbsp; The<B> LIBOS2</B> environment variable must also include the directory of the OS/2<TT>
DOSCALLS.LIB</TT> file which is usually<TT> \OS2.</TT>
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set libos2=c:\watcom\lib286\os2;c:\os2</TT>
<H2 ID="LIBPHAR"> LIBPHAR </H2>
<BR>The use of the<B> WATCOM</B> environment variable and the Open Watcom Linker &quot;SYSTEM&quot; directive is recommended
over the use of this environment variable.
<BR><BR>If you are developing a 32-bit Windows or DOS Extender application, the<B> LIBPHAR</B> environment variable must include
the location of the 32-bit Open Watcom F77 DOS Extender library files or the 32-bit Open Watcom F77 Windows library files
(files with the &quot;.lib&quot; filename extension).&nbsp; This variable is used by the Open Watcom Linker (WLINK.EXE).&nbsp;
The default installation directory for the 32-bit Open Watcom F77 DOS Extender libraries is<TT> \WATCOM\LIB386\DOS.</TT>&nbsp;
The default installation directory for the 32-bit Open Watcom F77 Windows libraries is<TT> \WATCOM\LIB386\WIN.</TT>
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set libphar=c:\watcom\lib386\dos</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set libphar=c:\watcom\lib386\win</TT>
<H2 ID="NO87"> NO87 </H2>
<BR>The<B> NO87</B> environment variable is checked by the Open Watcom FORTRAN 77 run-time libraries that include floating-point
emulation support.&nbsp; Normally, these libraries will detect the presence of a numeric data processor (80x87) and use it.
&nbsp;If you have a numeric data processor in your system but you wish to test a version of your application that will use
floating-point emulation, you can define the<B> NO87</B> environment variable.&nbsp; Using the &quot;SET&quot; command, define
the environment variable as follows:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SET NO87=1</TT>
<BR><BR>Now, when you run your application, the 80x87 will be ignored.&nbsp; To undefine the environment variable, enter the
command:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SET NO87=</TT>
<H2 ID="PATH"> PATH </H2>
<BR>The<B> PATH</B> environment variable is used by DOS &quot;COMMAND.COM&quot; or OS/2 &quot;CMD.EXE&quot; to locate programs.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; PATH [d:][path];[d:][path]...</TT>
<BR><BR>The<B> PATH</B> environment variable should include the disk and directory of the Open Watcom FORTRAN 77 binary program
files when using Open Watcom FORTRAN 77 and its related tools.
<BR><BR><B>If your host system is DOS:</B>
<BR><BR>The default installation directory for 16-bit Open Watcom F77 and 32-bit Open Watcom F77 DOS binaries is called<TT>
\WATCOM\BINW.</TT>
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;path c:\watcom\binw;c:\dos;c:\windows</TT>
<BR><BR><B>If your host system is OS/2:</B>
<BR><BR>The default installation directories for 16-bit Open Watcom F77 and 32-bit Open Watcom F77 OS/2 binaries are called<TT>
\WATCOM\BINP</TT> and<TT> \WATCOM\BINW.</TT>
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [C:\]path c:\watcom\binp;c:\watcom\binw</TT>
<BR><BR><B>If your host system is Windows NT:</B>
<BR><BR>The default installation directories for 16-bit Open Watcom F77 and 32-bit Open Watcom F77 Windows NT binaries are
called<TT> \WATCOM\BINNT</TT> and<TT> \WATCOM\BINW.</TT>
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;path c:\watcom\binnt;c:\watcom\binw</TT>
<BR><BR>The<B> PATH</B> environment variable is also used by the following programs in the described manner.
<OL>
<LI>Open Watcom Compile and Link to locate the 16-bit Open Watcom F77 and 32-bit Open Watcom F77 compilers and the Open Watcom
Linker.
<LI>&quot;WD.EXE&quot; to locate programs and debugger command files.
</OL>
<H2 ID="TMP"> TMP </H2>
<BR>The<B> TMP</B> environment variable describes the location (disk and path) for temporary files created by the 16-bit Open
Watcom F77 and 32-bit Open Watcom F77 compilers and the Open Watcom Linker.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SET TMP=[d:][path]</TT>
<BR><BR>Normally, Open Watcom FORTRAN 77 will create temporary spill files in the current directory.&nbsp; However, by defining
the<B> TMP</B> environment variable to be a certain disk and directory, you can tell Open Watcom FORTRAN 77 where to place
its temporary files.&nbsp; The same is true of the Open Watcom Linker temporary file.
<BR><BR>Consider the following definition of the<B> TMP</B> environment variable.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set tmp=d:\watcom\tmp</TT>
<BR><BR>The Open Watcom FORTRAN 77 compiler and Open Watcom Linker will create its temporary files in<TT> d:\watcom\tmp.</TT>
<H2 ID="WATCOM"> WATCOM </H2>
<BR>In order for the Open Watcom Linker to locate the 16-bit Open Watcom F77 and 32-bit Open Watcom F77 library files, the<B>
WATCOM</B> environment variable should be defined.&nbsp; The<B> WATCOM</B> environment variable is used to locate the libraries
that will be used when the application is linked.&nbsp; The default directory for 16-bit Open Watcom F77 and 32-bit Open Watcom
F77 files is &quot;\WATCOM&quot;.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set watcom=c:\watcom</TT>
<H2 ID="WCL"> WCL </H2>
<BR>The<B> WCL</B> environment variable can be used to specify commonly-used WFL options.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SET WCL=-option1 -option2 ...</TT>
<BR><BR>These options are processed before options specified on the command line.&nbsp; The following example defines the
default options to be &quot;mm&quot; (compile code for medium memory model), &quot;d1&quot; (include line number debug information
in the object file), and &quot;ox&quot; (compile for maximum number of code optimizations).
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set wcl=-mm -d1 -ox</TT>
<BR><BR>Once the<B> WCL</B> environment variable has been defined, those options listed become the default each time the WFL
command is used.
<H2 ID="WCL386"> WCL386 </H2>
<BR>The<B> WCL386</B> environment variable can be used to specify commonly-used WFL386 options.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SET WCL386=-option1 -option2 ...</TT>
<BR><BR>These options are processed before options specified on the command line.&nbsp; The following example defines the
default options to be &quot;3s&quot; (compile code for stack-based argument passing convention), &quot;d1&quot; (include line
number debug information in the object file), and &quot;ox&quot; (compile for maximum number of code optimizations).
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set wcl386=-3s -d1 -ox</TT>
<BR><BR>Once the<B> WCL386</B> environment variable has been defined, those options listed become the default each time the
WFL386 command is used.
<H2 ID="WCGMEMORY"> WCGMEMORY </H2>
<BR>The<B> WCGMEMORY</B> environment variable may be used to request a report of the amount of memory used by the compiler's
code generator for its work area.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set WCGMEMORY=?</TT>
<BR><BR>When the memory amount is &quot;?&quot; then the code generator will report how much memory was used to generate the
code.
<BR><BR>It may also be used to instruct the compiler's code generator to allocate a fixed amount of memory for a work area.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set WCGMEMORY=128</TT>
<BR><BR>When the memory amount is &quot;nnn&quot; then exactly &quot;nnnK&quot; bytes will be used.&nbsp; In the above example,
128K bytes is requested.&nbsp; If less than &quot;nnnK&quot; is available then the compiler will quit with a fatal error message.
&nbsp;If more than &quot;nnnK&quot; is available then only &quot;nnnK&quot; will be used.
<BR><BR>There are two reasons why this second feature may be quite useful.&nbsp; In general, the more memory available to
the code generator, the more optimal code it will generate.&nbsp; Thus, for two personal computers with different amounts
of memory, the code generator may produce different (although correct) object code.&nbsp; If you have a software quality assurance
requirement that the same results (i.e., code) be produced on two different machines then you should use this feature.&nbsp;
To generate identical code on two personal computers with different memory configurations, you must ensure that the<B> WCGMEMORY</B>
environment variable is set identically on both machines.
<BR><BR>The second reason where this feature is useful is on virtual memory paging systems (e.g., OS/2) where an unlimited
amount of memory can be used by the code generator.&nbsp; If a very large module is being compiled, it may take a very long
time to compile it.&nbsp; The code generator will continue to allocate more and more memory and cause an excessive amount
of paging.&nbsp; By restricting the amount of memory that the code generator can use, you can reduce the amount of time required
to compile a routine.
<H2 ID="WD"> WD </H2>
<BR>The<B> WD</B> environment variable can be used to specify commonly-used Open Watcom Debugger options.&nbsp; This environment
variable is not used by the Windows version of the debugger, WDW.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SET WD=-option1 -option2 ...</TT>
<BR><BR>These options are processed before options specified on the command line.&nbsp; The following example defines the
default options to be &quot;noinvoke&quot; (do not execute the<TT> profile.dbg</TT> file) and &quot;reg=10&quot; (retain up
to 10 register sets while tracing).
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set wd=-noinvoke -reg#10</TT>
<BR><BR>Once the<B> WD</B> environment variable has been defined, those options listed become the default each time the WD
command is used.
<H2 ID="WDW"> WDW </H2>
<BR>The<B> WDW</B> environment variable can be used to specify commonly-used Open Watcom Debugger options.&nbsp; This environment
variable is used by the Windows version of the debugger, WDW.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SET WDW=-option1 -option2 ...</TT>
<BR><BR>These options are processed before options specified in the WDW prompt dialogue box.&nbsp; The following example defines
the default options to be &quot;noinvoke&quot; (do not execute the<TT> profile.dbg</TT> file) and &quot;reg=10&quot; (retain
up to 10 register sets while tracing).
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set wdw=-noinvoke -reg#10</TT>
<BR><BR>Once the<B> WDW</B> environment variable has been defined, those options listed become the default each time the WDW
command is used.
<H2 ID="WFC"> WFC </H2>
<BR>The<B> WFC</B> environment variable can be used to specify commonly-used Open Watcom F77 options.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SET WFC=-option1 -option2 ...</TT>
<BR><BR>These options are processed before options specified on the command line.&nbsp; The following example defines the
default options to be &quot;d1&quot; (include line number debug information in the object file) and &quot;om&quot; (compile
with math optimizations).
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set wfc=-d1 -om</TT>
<BR><BR>Once the<B> WFC</B> environment variable has been defined, those options listed become the default each time the WFC
command is used.
<H2 ID="WFC386"> WFC386 </H2>
<BR>The<B> WFC386</B> environment variable can be used to specify commonly-used Open Watcom F77 options.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SET WFC386=-option1 -option2 ...</TT>
<BR><BR>These options are processed before options specified on the command line.&nbsp; The following example defines the
default options to be &quot;d1&quot; (include line number debug information in the object file) and &quot;om&quot; (compile
with math optimizations).
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set wfc386=-d1 -om</TT>
<BR><BR>Once the<B> WFC386</B> environment variable has been defined, those options listed become the default each time the
WFC386 command is used.
<H2 ID="WFL"> WFL </H2>
<BR>The<B> WFL</B> environment variable can be used to specify commonly-used WFL options.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SET WFL=-option1 -option2 ...</TT>
<BR><BR>These options are processed before options specified on the command line.&nbsp; The following example defines the
default options to be &quot;mm&quot; (compile code for medium memory model), &quot;d1&quot; (include line number debug information
in the object file), and &quot;ox&quot; (default optimizations).
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set wfl=-mm -d1 -ox</TT>
<BR><BR>Once the<B> WFL</B> environment variable has been defined, those options listed become the default each time the WFL
command is used.
<H2 ID="WFL386"> WFL386 </H2>
<BR>The<B> WFL386</B> environment variable can be used to specify commonly-used WFL386 options.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SET WFL386=-option1 -option2 ...</TT>
<BR><BR>These options are processed before options specified on the command line.&nbsp; The following example defines the
default options to be &quot;mf&quot; (flat memory model), &quot;d1&quot; (include line number debug information in the object
file), and &quot;ox&quot; (default optimizations).
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set wfl386=-mf -d1 -ox</TT>
<BR><BR>Once the<B> WFL386</B> environment variable has been defined, those options listed become the default each time the
WFL386 command is used.
<H2 ID="WLANG"> WLANG </H2>
<BR>The<B> WLANG</B> environment variable can be used to control which language is used to display diagnostic and program
usage messages by various Open Watcom software tools.&nbsp; The two currently-supported values for this variable are &quot;English&quot;
or &quot;Japanese&quot;.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SET WLANG=English</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SET WLANG=Japanese</TT>
<BR><BR>Alternatively, a numeric value of 0 (for English) or 1 (for Japanese) can be specified.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set wlang=0</TT>
<BR><BR>By default, Japanese messages are displayed when the current codepage is 932 and English messages are displayed otherwise.
&nbsp;Normally, use of the<B> WLANG</B> environment variable should not be required.
</BODY>
