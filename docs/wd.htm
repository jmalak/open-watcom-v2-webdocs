<HEAD>
<TITLE> Open Watcom 2.0 Debugger Guide </TITLE>
</HEAD>
<BODY>
<H1 ID="Index_of_Topics"> Index of Topics </H1>
<DL>
<DT>- &quot; -
<DD><A HREF="#_operator__Functions_in_the_CPP_Grammar">&quot;operator&quot; Functions in the C++ Grammar</A>
<BR><A HREF="#The__this__Operator_for_the_CPP_Grammar">The &quot;this&quot; Operator for the C++ Grammar</A>
<DT>- A -
<DD><A HREF="#Accelerate">Accelerate</A>
<BR><A HREF="#The_Accelerator_Window">The Accelerator Window</A>
<BR><A HREF="#Accelerators">Accelerators</A>
<BR><A HREF="#The_Action_Menu">The Action Menu</A>
<BR><A HREF="#Ambiguity_Resolution_in_the_CPP_Grammar">Ambiguity Resolution in the C++ Grammar</A>
<BR><A HREF="#ArithmeticDLogical_Shift_Operators_for_the_C_Grammar">Arithmetic/Logical Shift Operators for the C Grammar</A>
<BR><A HREF="#ArithmeticDLogical_Shift_Operators_for_the_FORTRAN_Grammar">Arithmetic/Logical Shift Operators for the FORTRAN Grammar</A>
<BR><A HREF="#Assembly_Level_Debugging">Assembly Level Debugging</A>
<BR><A HREF="#The_Assembly_Options">The Assembly Options</A>
<BR><A HREF="#The_Assembly_Window">The Assembly Window</A>
<BR><A HREF="#Assignment_Operators_for_the_C_Grammar">Assignment Operators for the C Grammar</A>
<BR><A HREF="#Assignment_Operators_for_the_FORTRAN_Grammar">Assignment Operators for the FORTRAN Grammar</A>
<DT>- B -
<DD><A HREF="#Binary_Address_Operator_for_the_C_Grammar">Binary Address Operator for the C Grammar</A>
<BR><A HREF="#Binary_Address_Operator_for_the_FORTRAN_Grammar">Binary Address Operator for the FORTRAN Grammar</A>
<BR><A HREF="#Binary_Arithmetic_Operators_for_the_C_Grammar">Binary Arithmetic Operators for the C Grammar</A>
<BR><A HREF="#Binary_Arithmetic_Operators_for_the_FORTRAN_Grammar">Binary Arithmetic Operators for the FORTRAN Grammar</A>
<BR><A HREF="#Bit_Operators_for_the_C_Grammar">Bit Operators for the C Grammar</A>
<BR><A HREF="#Bit_Operators_for_the_FORTRAN_Grammar">Bit Operators for the FORTRAN Grammar</A>
<BR><A HREF="#Break">Break</A>
<BR><A HREF="#The_Break_Menu">The Break Menu</A>
<BR><A HREF="#The_Break_Window">The Break Window</A>
<BR><A HREF="#The_Breakpoint_Dialog">The Breakpoint Dialog</A>
<BR><A HREF="#Breakpoints">Breakpoints</A>
<BR><A HREF="#Buttons">Buttons</A>
<DT>- C -
<DD><A HREF="#Call">Call</A>
<BR><A HREF="#The_Calls_Window">The Calls Window</A>
<BR><A HREF="#CAPture">CAPture</A>
<BR><A HREF="#Change_Directory_M_CHDIR__CD">Change Directory - CHDIR, CD</A>
<BR><A HREF="#Character_Constant_LC_OnlyR">Character Constant (C Only)</A>
<BR><A HREF="#Character_String_Constant_LFORTRAN_OnlyR">Character String Constant (FORTRAN Only)</A>
<BR><A HREF="#Clearing__Disabling__and_Enabling_Breakpoints">Clearing, Disabling, and Enabling Breakpoints</A>
<BR><A HREF="#The_Code_Menu">The Code Menu</A>
<BR><A HREF="#Command_Summary">Command Summary</A>
<BR><A HREF="#Common_Menu_Items">Common Menu Items</A>
<BR><A HREF="#Common_Switches">Common Switches</A>
<BR><A HREF="#Compiler_Debugging_Options">Compiler Debugging Options</A>
<BR><A HREF="#Complex_Constant_LFORTRAN_OnlyR">Complex Constant (FORTRAN Only)</A>
<BR><A HREF="#Concatenation_Operator_for_the_FORTRAN_Grammar">Concatenation Operator for the FORTRAN Grammar</A>
<BR><A HREF="#COnfigfile">COnfigfile</A>
<BR><A HREF="#Constants">Constants</A>
<BR><A HREF="#ConstructorDDestructor_Functions_in_the_CPP_Grammar">Constructor/Destructor Functions in the C++ Grammar</A>
<BR><A HREF="#Context_Sensitive_Menus">Context Sensitive Menus</A>
<BR><A HREF="#Context_Sensitive_PopMup_Menus">Context Sensitive Pop-up Menus</A>
<BR><A HREF="#Controlling_Program_Execution">Controlling Program Execution</A>
<BR><A HREF="#Controlling_the_Size_and_Location_of_Windows">Controlling the Size and Location of Windows</A>
<BR><A HREF="#Copy_Files_M_COPY">Copy Files - COPY</A>
<BR><A HREF="#The_CPU_Register_Window">The CPU Register Window</A>
<BR><A HREF="#The_Current_Window">The Current Window</A>
<DT>- D -
<DD><A HREF="#The_Data_Menu">The Data Menu</A>
<BR><A HREF="#Debugger_Commands">Debugger Commands</A>
<BR><A HREF="#Debugger_Settings">Debugger Settings</A>
<BR><A HREF="#Debugger_Windows">Debugger Windows</A>
<BR><A HREF="#Debugging_32Mbit_DOS_Extender_Applications">Debugging 32-bit DOS Extender Applications</A>
<BR><A HREF="#Debugging_a_Novell_NLM">Debugging a Novell NLM</A>
<BR><A HREF="#Debugging_CauseWay_32Mbit_DOS_Extender_Applications">Debugging CauseWay 32-bit DOS Extender Applications</A>
<BR><A HREF="#Debugging_DOSD4GLWR_32Mbit_DOS_Extender_Applications">Debugging DOS/4G(W) 32-bit DOS Extender Applications</A>
<BR><A HREF="#Debugging_Dynamic_Link_Libraries">Debugging Dynamic Link Libraries</A>
<BR><A HREF="#Debugging_Graphics_Applications">Debugging Graphics Applications</A>
<BR><A HREF="#Debugging_Phar_Lap_32Mbit_DOS_Extender_Applications">Debugging Phar Lap 32-bit DOS Extender Applications</A>
<BR><A HREF="#Debugging_Under_Linux">Debugging Under Linux</A>
<BR><A HREF="#Debugging_Under_QNX">Debugging Under QNX</A>
<BR><A HREF="#Debugging_Under_QNX_Using_the_Postmortem_Dump_Facility">Debugging Under QNX Using the Postmortem Dump Facility</A>
<BR><A HREF="#Debugging_Windows_3_x_Applications">Debugging Windows 3.x Applications</A>
<BR><A HREF="#Default_Accelerators">Default Accelerators</A>
<BR><A HREF="#Dialogs">Dialogs</A>
<BR><A HREF="#Disabling_Use_of_386D486_Debug_Registers">Disabling Use of 386/486 Debug Registers</A>
<BR><A HREF="#Display">Display</A>
<BR><A HREF="#Display_File_Contents_M_TYPE">Display File Contents - TYPE</A>
<BR><A HREF="#DO_Lor_DR">DO (or /)</A>
<BR><A HREF="#DOS">DOS</A>
<BR><A HREF="#DOS_and_Windows_Options">DOS and Windows Options</A>
<BR><A HREF="#DOS_Specific_Options">DOS Specific Options</A>
<DT>- E -
<DD><A HREF="#Entering_Search_Strings">Entering Search Strings</A>
<BR><A HREF="#Environment_Variables">Environment Variables</A>
<BR><A HREF="#Erase_File_M_ERASE__DEL">Erase File - ERASE, DEL</A>
<BR><A HREF="#ERror">ERror</A>
<BR><A HREF="#Examine">Examine</A>
<BR><A HREF="#Examining_and_Modifying_the_Program_State">Examining and Modifying the Program State</A>
<BR><A HREF="#Exit_from_RFX_M_EXIT">Exit from RFX - EXIT</A>
<DT>- F -
<DD><A HREF="#The_File_Menu">The File Menu</A>
<BR><A HREF="#The_File_Options">The File Options</A>
<BR><A HREF="#The_File_Window">The File Window</A>
<BR><A HREF="#Flip">Flip</A>
<BR><A HREF="#Following_Linked_Lists">Following Linked Lists</A>
<BR><A HREF="#FOnt">FOnt</A>
<BR><A HREF="#The_FPU_Registers_Window">The FPU Registers Window</A>
<BR><A HREF="#The_Functions_and_Globals_Options">The Functions and Globals Options</A>
<BR><A HREF="#The_Functions_Window">The Functions Window</A>
<DT>- G -
<DD><A HREF="#General_Rules_of_Expression_Handling">General Rules of Expression Handling</A>
<BR><A HREF="#The_Globals_Window">The Globals Window</A>
<BR><A HREF="#Go">Go</A>
<DT>- H -
<DD><A HREF="#Help">Help</A>
<BR><A HREF="#The_Help_Menu">The Help Menu</A>
<BR><A HREF="#HOok">HOok</A>
<BR><A HREF="#How_to_Use_Breakpoints_during_a_Debugging_Session">How to Use Breakpoints during a Debugging Session</A>
<DT>- I -
<DD><A HREF="#The_IDO_Ports_Window">The I/O Ports Window</A>
<BR><A HREF="#IF">IF</A>
<BR><A HREF="#The_Images_Window">The Images Window</A>
<BR><A HREF="#Integer_Constants">Integer Constants</A>
<BR><A HREF="#Interrupting_a_Running_Program">Interrupting a Running Program</A>
<BR><A HREF="#INvoke_Lor_XR">INvoke (or &lt;)</A>
<DT>- L -
<DD><A HREF="#Language_Independent_Variables_and_Constants">Language Independent Variables and Constants</A>
<BR><A HREF="#Line_Numbers">Line Numbers</A>
<BR><A HREF="#Link_Descriptions">Link Descriptions</A>
<BR><A HREF="#Linker_Debugging_Options">Linker Debugging Options</A>
<BR><A HREF="#Linux">Linux</A>
<BR><A HREF="#Linux_Options">Linux Options</A>
<BR><A HREF="#List_Directory_M_DIR">List Directory - DIR</A>
<BR><A HREF="#Log_Lor_YR">Log (or &gt;)</A>
<BR><A HREF="#The_Log_Window">The Log Window</A>
<BR><A HREF="#Logical_Operators_for_the_C_Grammar">Logical Operators for the C Grammar</A>
<BR><A HREF="#Logical_Operators_for_the_FORTRAN_Grammar">Logical Operators for the FORTRAN Grammar</A>
<DT>- M -
<DD><A HREF="#Make_Directory_M_MKDIR__MD">Make Directory - MKDIR, MD</A>
<BR><A HREF="#The_Memory_and_Stack_Windows">The Memory and Stack Windows</A>
<BR><A HREF="#Memory_References">Memory References</A>
<BR><A HREF="#Menus">Menus</A>
<BR><A HREF="#The_MMX_Registers_Window">The MMX Registers Window</A>
<BR><A HREF="#MOdify">MOdify</A>
<BR><A HREF="#The_Modules_Options">The Modules Options</A>
<BR><A HREF="#The_Modules_Window">The Modules Window</A>
<BR><A HREF="#Moving_Windows">Moving Windows</A>
<DT>- N -
<DD><A HREF="#Navigating_Through_a_Program">Navigating Through a Program</A>
<BR><A HREF="#NET_LNetBIOSR">NET (NetBIOS)</A>
<BR><A HREF="#NetWare">NetWare</A>
<BR><A HREF="#NEW">NEW</A>
<BR><A HREF="#New_Features">New Features</A>
<BR><A HREF="#NMP_LNamed_PipesR">NMP (Named Pipes)</A>
<BR><A HREF="#NOV_LNovell_SPXR">NOV (Novell SPX)</A>
<DT>- O -
<DD><A HREF="#Open_Watcom_Debugger_Command_Line">Open Watcom Debugger Command Line</A>
<BR><A HREF="#The_Open_Watcom_Debugger_Environment">The Open Watcom Debugger Environment</A>
<BR><A HREF="#Open_Watcom_Debugger_Expression_Handling">Open Watcom Debugger Expression Handling</A>
<BR><A HREF="#Operating_System_Specifics">Operating System Specifics</A>
<BR><A HREF="#Operators_for_the_C_Grammar">Operators for the C Grammar</A>
<BR><A HREF="#Operators_for_the_CPP_Grammar">Operators for the C++ Grammar</A>
<BR><A HREF="#Operators_for_the_FORTRAN_Grammar">Operators for the FORTRAN Grammar</A>
<BR><A HREF="#The_Options_Dialog">The Options Dialog</A>
<BR><A HREF="#OSD2">OS/2</A>
<BR><A HREF="#Overview">Overview</A>
<DT>- P -
<DD><A HREF="#PAint">PAint</A>
<BR><A HREF="#PAR_LParallelR">PAR (Parallel)</A>
<BR><A HREF="#Parallel_Port_Wiring_Considerations">Parallel Port Wiring Considerations</A>
<BR><A HREF="#Predefined_Debugger_Variables">Predefined Debugger Variables</A>
<BR><A HREF="#Predefined_Symbols">Predefined Symbols</A>
<BR><A HREF="#Preparing_a_Program_to_be_Debugged">Preparing a Program to be Debugged</A>
<BR><A HREF="#Primary_Expression_Operators_for_the_C_Grammar">Primary Expression Operators for the C Grammar</A>
<BR><A HREF="#Primary_Expression_Operators_for_the_FORTRAN_Grammar">Primary Expression Operators for the FORTRAN Grammar</A>
<BR><A HREF="#Print_Lor__R">Print (or ?)</A>
<DT>- Q -
<DD><A HREF="#QNX">QNX</A>
<BR><A HREF="#QNX_Options">QNX Options</A>
<BR><A HREF="#Quit">Quit</A>
<DT>- R -
<DD><A HREF="#Real_Constants">Real Constants</A>
<BR><A HREF="#RECord">RECord</A>
<BR><A HREF="#Register">Register</A>
<BR><A HREF="#Register_Aggregates">Register Aggregates</A>
<BR><A HREF="#Relational_Operators_for_the_C_Grammar">Relational Operators for the C Grammar</A>
<BR><A HREF="#Relational_Operators_for_the_FORTRAN_Grammar">Relational Operators for the FORTRAN Grammar</A>
<BR><A HREF="#REMark_Lor_TR">REMark (or *)</A>
<BR><A HREF="#Remote_Debugging">Remote Debugging</A>
<BR><A HREF="#Remote_File_Operations_LDOS__NT__OSD2_OnlyR">Remote File Operations (DOS, NT, OS/2 Only)</A>
<BR><A HREF="#Remove_Directory_M_RMDIR__RD">Remove Directory - RMDIR, RD</A>
<BR><A HREF="#Rename_M_RENAME__REN">Rename - RENAME, REN</A>
<BR><A HREF="#Replay">Replay</A>
<BR><A HREF="#The_Replay_Window">The Replay Window</A>
<BR><A HREF="#Resizing_Windows">Resizing Windows</A>
<BR><A HREF="#Reverse_Execution">Reverse Execution</A>
<BR><A HREF="#RFX_Commands">RFX Commands</A>
<BR><A HREF="#RFX_Sample_Session">RFX Sample Session</A>
<BR><A HREF="#The_Run_Menu">The Run Menu</A>
<DT>- S -
<DD><A HREF="#Scope_Operator______for_the_CPP_Grammar">Scope Operator &quot;::&quot; for the C++ Grammar</A>
<BR><A HREF="#The_Search_Menu">The Search Menu</A>
<BR><A HREF="#Search_Order_for_Open_Watcom_Debugger_Support_Files_under_Linux">Search Order for Open Watcom Debugger Support Files under Linux</A>
<BR><A HREF="#Search_Order_for_Open_Watcom_Debugger_Support_Files_under_QNX">Search Order for Open Watcom Debugger Support Files under QNX</A>
<BR><A HREF="#SER_LSerialR">SER (Serial)</A>
<BR><A HREF="#Serial_Port_Wiring_Considerations">Serial Port Wiring Considerations</A>
<BR><A HREF="#Set">Set</A>
<BR><A HREF="#Set_Current_Drive_M_drive_">Set Current Drive - drive:</A>
<BR><A HREF="#Setting_Simple_Breakpoints">Setting Simple Breakpoints</A>
<BR><A HREF="#SHow">SHow</A>
<BR><A HREF="#Simplified_Breakpoints">Simplified Breakpoints</A>
<BR><A HREF="#SKip">SKip</A>
<BR><A HREF="#The_Source_Window">The Source Window</A>
<BR><A HREF="#Special_Unary_Operators_for_the_C_Grammar">Special Unary Operators for the C Grammar</A>
<BR><A HREF="#Special_Unary_Operators_for_the_FORTRAN_Grammar">Special Unary Operators for the FORTRAN Grammar</A>
<BR><A HREF="#Specifying_Files_on_Remote_and_Local_Machines">Specifying Files on Remote and Local Machines</A>
<BR><A HREF="#Stack_Unwinding">Stack Unwinding</A>
<BR><A HREF="#STackpos_XintexprY">STackpos &lt;intexpr&gt;</A>
<BR><A HREF="#Starting_Up_the_Debugger">Starting Up the Debugger</A>
<BR><A HREF="#The_Status_Window">The Status Window</A>
<BR><A HREF="#Symbol_Names">Symbol Names</A>
<BR><A HREF="#Syntax_Definitions">Syntax Definitions</A>
<BR><A HREF="#SYstem_Lor__R">SYstem (or !)</A>
<DT>- T -
<DD><A HREF="#TCPDIP_LInternet_PacketsR">TCP/IP (Internet Packets)</A>
<BR><A HREF="#Text_Selection">Text Selection</A>
<BR><A HREF="#THread_Lor___R">THread (or ]</A>
<BR><A HREF="#The_Thread_Window">The Thread Window</A>
<BR><A HREF="#The_Toolbar">The Toolbar</A>
<BR><A HREF="#Trace">Trace</A>
<BR><A HREF="#Traversing_Arrays">Traversing Arrays</A>
<BR><A HREF="#Turbo_Emulation_Accelerators">Turbo Emulation Accelerators</A>
<DT>- U -
<DD><A HREF="#Unary_Arithmetic_Operators_for_the_C_Grammar">Unary Arithmetic Operators for the C Grammar</A>
<BR><A HREF="#Unary_Arithmetic_Operators_for_the_FORTRAN_Grammar">Unary Arithmetic Operators for the FORTRAN Grammar</A>
<BR><A HREF="#Undo">Undo</A>
<BR><A HREF="#The_Undo_Menu">The Undo Menu</A>
<BR><A HREF="#User_Interface">User Interface</A>
<DT>- V -
<DD><A HREF="#Variable_and_Watch_Windows">Variable and Watch Windows</A>
<BR><A HREF="#The_Variables_Options">The Variables Options</A>
<BR><A HREF="#VDM_LVirtual_DOS_MachineR">VDM (Virtual DOS Machine)</A>
<BR><A HREF="#View">View</A>
<DT>- W -
<DD><A HREF="#WD_Environment_Variable">WD Environment Variable</A>
<BR><A HREF="#WD_Environment_Variable_in_Linux">WD Environment Variable in Linux</A>
<BR><A HREF="#WD_Environment_Variable_in_QNX">WD Environment Variable in QNX</A>
<BR><A HREF="#While">While</A>
<BR><A HREF="#WIN_LWindows_3_xD9x_Virtual_DOS_MachineR">WIN (Windows 3.x/9x Virtual DOS Machine)</A>
<BR><A HREF="#WIndow">WIndow</A>
<BR><A HREF="#Window_Controls">Window Controls</A>
<BR><A HREF="#The_Window_Menu">The Window Menu</A>
<BR><A HREF="#The_Window_Options_Dialog">The Window Options Dialog</A>
<BR><A HREF="#Windows_3_x">Windows 3.x</A>
<BR><A HREF="#Windows_NT__Windows_95">Windows NT, Windows 95</A>
<BR><A HREF="#Windows_Specific_Options">Windows Specific Options</A>
<BR><A HREF="#Wiring_For_Remote_Debugging">Wiring For Remote Debugging</A>
<DT>- X -
<DD><A HREF="#The_XMM_Registers_Window">The XMM Registers Window</A>
<DT>- Z -
<DD><A HREF="#Zooming_Windows">Zooming Windows</A>
</DL>
<H1 ID="Overview"> Overview </H1>
<BR>The Open Watcom Debugger is a powerful debugging tool that helps you analyse your programs and find out why they are not
behaving as you expect.&nbsp; It allows you to single step through your code, set break points based on complex conditions,
modify variables and memory, expand structures and classes and much more.&nbsp; With the debugger you can debug programs that
run on the following platforms:&nbsp; 
<UL>
<LI>DOS
<LI>CauseWay DOS Extender
<LI>Tenberry Software DOS/4G Extender
<LI>Phar Lap DOS Extender
<LI>Windows 3.x
<LI>Windows NT/2000/XP
<LI>Windows 9x
<LI>16 and 32-bit OS/2
<LI>GNU/Linux
<LI>QNX 4
<LI>QNX 6 (Neutrino)
<LI>Novell NetWare
</UL>
<H2 ID="New_Features"> New Features </H2>
<BR>The latest version of the debugger contains many new features that you should know about.
<H3 ID="User_Interface"> User Interface </H3>
<BR>The debugger's user interface has been redesigned.&nbsp; There are GUI versions of the debugger that run under Windows
3.x, Windows NT/2000/XP, Windows 9x, and 32-bit OS/2.&nbsp; There are also character mode versions that run under DOS, Windows
3.x, OS/2, Linux and QNX 4.&nbsp; All versions share a common user interface incorporating powerful features like context
sensitive menus, eliminating the need for command oriented debugging.
<H3 ID="Reverse_Execution"> Reverse Execution </H3>
<BR>The debugger keeps a history of your interactions that modify the state of the program you are debugging.&nbsp; This includes
the effects of statements in your program that you trace.&nbsp; The size of this history is limited only by available memory.
&nbsp;Undo and Redo allow you to step backward and forward through this history.&nbsp; This allows you to reverse the effects
of tracing over simple statements in your program.&nbsp; You can also reverse any accidental interactions that affect your
program's state.&nbsp; See <A HREF="#The_Undo_Menu">The Undo Menu</A>.
<H3 ID="Replay"> Replay </H3>
<BR>The debugger keeps a history of all interactions that affect the execution of your program such as setting break points
and tracing.&nbsp; Replay allows you to restart the application and run the application back to a previous point.&nbsp; This
is particularly useful when you accidentally trace over a call.&nbsp; This replay information may be saved to a file in order
to resume a debugging session at a later date.&nbsp; See <A HREF="#The_Replay_Window">The Replay Window</A>.
<H3 ID="Stack_Unwinding"> Stack Unwinding </H3>
<BR>You can navigate up and down the program's call stack to see where the currently executing routine was called from.&nbsp;
As you do this, all other windows in the debugger update automatically.&nbsp; Local variables in the calling routines will
be displayed along with their correct values.&nbsp; See <A HREF="#The_Undo_Menu">The Undo Menu</A>.
<H3 ID="Simplified_Breakpoints"> Simplified Breakpoints </H3>
<BR>The debugger allows you to set breakpoints when code is executed or data is modified.&nbsp; These breakpoints may be conditional
based on an expression or a countdown.&nbsp; Simple breakpoints are created with a keystroke or single mouse click.&nbsp;
More complex breakpoints are entered using a dialog.&nbsp; See <A HREF="#The_Breakpoint_Dialog">The Breakpoint Dialog</A>.
<H3 ID="Context_Sensitive_Menus"> Context Sensitive Menus </H3>
<BR>Context sensitive menus are present in each debugger window.&nbsp; To use them, you select an item from the the screen
using the right mouse button.&nbsp; A menu containing a list of actions appropriate for that item is displayed.&nbsp; You
can use this capability to perform actions such as displaying the value of an expression which you have selected from the
source window.
<H3 ID="Buttons"> Buttons </H3>
<BR>The debugger contains small buttons that appear on the left side of some windows.&nbsp; These buttons are shortcuts for
the most common operations.&nbsp; For example, you can set and clear a breakpoint by clicking on the button to the left of
a source line.
<H2 ID="Common_Menu_Items"> Common Menu Items </H2>
<BR>The debugger's context sensitive menus contain many useful menu items.&nbsp; Each of these items behave differently depending
upon the selected item.&nbsp; A description of some of the commonly found menu items follows:
<DL>
<DT>Inspect
<DD>Inspect displays the selected item.&nbsp; The debugger determines how to best display the selected item based on its type.
&nbsp;If you inspect a variable or an expression, the debugger opens a new window showing its value.&nbsp; If you inspect
a function, the debugger positions the source code window at the function definition.&nbsp; If you inspect a hexadecimal address
from the assembly window, a window showing memory at that address is opened, and so on.&nbsp; Experimenting with inspect will
help you learn to use the debugger effectively.&nbsp; 
<DT>Modify
<DD>Modify lets you change the selected item.&nbsp; You will normally be prompted for a new value.&nbsp; For example, select the
name of a variable from any window and choose Modify to change its value.&nbsp; 
<DT>New
<DD>New adds another item to a list of items displayed in a window.&nbsp; For example, choosing New in the Break Point window
lets you create a new breakpoint.&nbsp; 
<DT>Delete
<DD>Delete removes the selected item from the window.&nbsp; For example, you can use Delete to remove a variable from the Watches
window.&nbsp; 
<DT>Source
<DD>Source displays the source code associated with the selected item.&nbsp; The debugger will reposition the source code window
at the appropriate line.&nbsp; Selecting a module name and choosing Source will display the module's source code.&nbsp; 
<DT>Assembly
<DD>Assembly positions the assembly code window at the code associated with the selected item.&nbsp; 
<DT>Functions
<DD>Functions shows a list of all functions associated with the selected item or window.&nbsp; For example, choose Functions in
the source window to see a list of all functions defined in that module.&nbsp; 
<DT>Watch
<DD>Watch adds the selected variable or expression to the Watches window.&nbsp; This allows you to watch its value change as the
program runs.<B><I>&nbsp; Note that this is not a watchpoint.&nbsp; Execution will not stop when the variable changes.</I></B>
&nbsp;See the chapter entitled <A HREF="#Breakpoints">Breakpoints</A> for information about setting watchpoints.&nbsp; 
<DT>Break
<DD>Break sets a breakpoint based on the selected item.&nbsp; If a variable is selected, the program will stop when the variable
is modified.&nbsp; If a function is selected, the program will stop when the function executes.&nbsp; 
<DT>Globals
<DD>Globals shows a list of global variables associated with the selected item.&nbsp; 
<DT>Show
<DD>Show will present a cascaded menu that let's you show things related to the selected item.&nbsp; For example, you can use<B><I>
Line</I></B> from the<B><I> Show</I></B> menu in the source code window to see the line number of the selected line.&nbsp;

<DT>Type
<DD>Type will present a cascaded menu that allows you to change the display type of the window or selected item.
</DL>
<H1 ID="Preparing_a_Program_to_be_Debugged"> Preparing a Program to be Debugged </H1>
<BR>Before you can debug a program, you must put<B> debugging information</B> into the code.
<BR><BR>There are three different formats of debugging information that can be put into the code - &quot;Watcom&quot;, &quot;DWARF&quot;
or &quot;CodeView&quot;.&nbsp; Starting with version 11.0 (and continuing in the Open Watcom 1.0 and later compilers), the
default format is &quot;DWARF&quot;.&nbsp; In earlier releases, the default was &quot;Watcom&quot;.&nbsp; Although the debugger
supports all three formats, it is best if you allow the default format to be generated.
<BR><BR>To produce an executable that has debugging information, you need to:
<OL>
<LI>specify the correct compiler options when you compile, and
<LI>specify the correct linker options when you link.
</OL>
<BR>During development, use the<B> d2</B> option of the compiler and use the<B> debug all</B> directive at the beginning of
your linker command line or at the beginning of your linker directive file.&nbsp; This will ensure that maximum debugging
information is available during your debugging session.&nbsp; Change to the<B> d1</B> option when you need to create a distribution
version of your product.&nbsp; This is necessary since the<B> d2</B> option disables most compiler optimizations, whereas<B>
d1</B> will not affect the quality of generated code.&nbsp; During production, you can use the linker's<B> symfile</B> option
to put the<B> d1</B> debugging information into a separate file.&nbsp; This lets you distribute a production quality executable
yet still have the luxury of source line debugging when bugs are reported.
<H2 ID="Compiler_Debugging_Options"> Compiler Debugging Options </H2>
<DL>
<DT>d0
<DD>The<B> d0</B> option will generate no debugging information.&nbsp; This is the default option.
<DT>d1
<DD>The<B> d1</B> option will generate debugging information for global symbols and line numbers.
<DT>d1+
<DD>The<B> d1+</B> option will generate debugging information for global symbols and line numbers, and typing information for
local structs and arrays.
<DT>d2
<DD>The<B> d2</B> option will generate the most debugging information that is normally needed, including global information, line
numbers, types, and local variables.
<DT>d2i
<DD>The<B> d2i</B> option is identical to<B> d2</B> but does not permit inlining of functions.&nbsp; This option can result in
larger object and/or executable files (we are discussing both &quot;code&quot; and &quot;file&quot; size here).
<DT>d2t
<DD>The<B> d2t</B> option is identical to<B> d2</B> but does not include type name debugging information.&nbsp; This option can
result in smaller object and/or executable files (we are discussing &quot;file&quot; size here).
<DT>d3
<DD>The<B> d3</B> option will generate all debugging information generated by<B> d2.</B>&nbsp; In addition, it will generate information
about all types defined in a compilation unit, regardless of whether they are used in that compilation unit.<B><I>&nbsp; This
option will create very large objects and executable files.&nbsp; Do not use it unless you want to have access to types that
have no variables associated with them.</I></B>
</DL>
<H2 ID="Linker_Debugging_Options"> Linker Debugging Options </H2>
<BR>The linker is the tool that puts together a complete program and sets up the debugging information for all the modules
in the executable file.&nbsp; There is a linker directive that tells the linker when it should include debugging information
from the modules.
<BR><BR>The directive you should use in the general case is:
<DL>
<DT>DEBUG ALL
<DD>
</DL>
<BR>This directive will include all debugging information in the default format.&nbsp; You should always use this directive
except in the rare cases when you need debugging information in a format other than the default.
<BR><BR>For &quot;DWARF&quot; format debugging information, the directive is:
<DL>
<DT>DEBUG DWARF
<DD>
</DL>
<BR>For &quot;Watcom&quot; format debugging information, there are two levels of debugging information that you should collect
during the link.&nbsp; They are:
<DL>
<DT>DEBUG WATCOM LINES
<DD>global names, source line numbers
<DT>DEBUG WATCOM ALL
<DD>global names, source line numbers, local variables, typing information
</DL>
<BR>Linker DEBUG directives are position dependent so you must make sure that the directive<B> precedes</B> the object files
and libraries that require debugging information.
<BR><BR>For instance, if the file &quot;mylink.lnk&quot; contained:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; # invoke with: wlink @mylink</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; file main</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; debug watcom lines</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; file input, output</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; debug watcom all</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; file process</TT>
<BR><BR>then the files<B> input</B> and<B> output</B> will have global names and source line information available during
debugging.&nbsp; All debugging information in the file<B> process</B> is available during debugging.&nbsp; No information
is available for<B> main</B> except global names.
<BR><BR>If you use a DEBUG directive anywhere, all files, including<B> main,</B> will have global name information.
<H2 ID="Debugger_Settings"> Debugger Settings </H2>
<BR>You may encounter problems if the debugger does not know where to find the source code associated with your executable.
&nbsp;The name of the source file included in the debugging information is the path and the original name from the compiler's
command line.&nbsp; If the original filename is no longer valid (i.e., you have moved the source to another directory), you
must tell the debugger where to find the source files by choosing<B><I> Source Path</I></B> from the<B><I> File</I></B> menu.
<H1 ID="Starting_Up_the_Debugger"> Starting Up the Debugger </H1>
<BR>The following topics are discussed:
<UL>
<LI><A HREF="#Open_Watcom_Debugger_Command_Line">Open Watcom Debugger Command Line</A>
<LI><A HREF="#Common_Switches">Common Switches</A>
<LI><A HREF="#DOS_and_Windows_Options">DOS and Windows Options</A>
<LI><A HREF="#DOS_Specific_Options">DOS Specific Options</A>
<LI><A HREF="#Windows_Specific_Options">Windows Specific Options</A>
<LI><A HREF="#Linux_Options">Linux Options</A>
<LI><A HREF="#QNX_Options">QNX Options</A>
<LI><A HREF="#Environment_Variables">Environment Variables</A>
</UL>
<H2 ID="Open_Watcom_Debugger_Command_Line"> Open Watcom Debugger Command Line </H2>
<BR>There are several versions of the debugger.
<DL>
<DT>binw\wd.exe
<DD>This is the DOS character-mode debugger.
<DT>binw\wdc.exe
<DD>This is the Windows 3.x character-mode debugger.
<DT>binw\wdw.exe
<DD>This is the Windows 3.x windowed (GUI) debugger.
<DT>binnt\wd.exe
<DD>This is the Windows NT/9x character-mode debugger.
<DT>binnt\wdw.exe
<DD>This is the Windows NT/9x windowed (GUI) debugger.
<DT>binp\wd.exe
<DD>This is the OS/2 character-mode debugger.
<DT>binp\wdw.exe
<DD>This is the OS/2 windowed (GUI) debugger.
<DT>wd
<DD>This is the name of the debugger used on UNIX platforms.
</DL>
<BR>See the sections entitled <A HREF="#Operating_System_Specifics">Operating System Specifics</A> and <A HREF="#Remote_Debugging">Remote Debugging</A>
for information on which version to select for your situation.
<BR><BR>On the debugger command line, you can specify options that you want to use during your debugging session.&nbsp; Acceptable
option short forms are indicated in capital letters.&nbsp; For example, the<B> /TRap</B> option may be shortened to<B> /tr.</B>
<H2 ID="Common_Switches"> Common Switches </H2>
<BR>The following switches are applicable to all operating systems.
<DL>
<DT>/TRap=trap_file[;trap_parm]
<DD>specifies an executable helper program that the debugger uses to control the application being debugged, or to communicate
across a remote link.&nbsp; It is called a &quot;trap file&quot; since the interrupts used for debugging are sometimes called
&quot;traps&quot;.&nbsp; The<B> trap</B> option selects the appropriate trap file to use.<B><I>&nbsp; This option must be
specified when remote debugging, debugging DOS extender applications or debugging OS/2 exception handlers.</I></B>
<BR><BR>The remote trap files themselves have startup parameters.&nbsp; This is specified following the semi-colon.&nbsp;
See <A HREF="#Remote_Debugging">Remote Debugging</A>.&nbsp; Normally you do not have to specify a trap file.&nbsp; If you
do not specify the<B> trap</B> option, the default trap file that supports local debugging is loaded.&nbsp; There are several
exceptions.
<OL>
<LI>To debug a CauseWay 32-bit application, you must use<B> /TRAP=CW.</B>
<LI>To debug a Tenberry Software 32-bit DOS/4G(W) application, you must use<B> /TRAP=RSI.</B>
<LI>To debug a Phar Lap 32-bit application, you must use<B> /TRAP=PLS.</B>
<LI>To debug an OS/2 exception handler, you must use<B> /TRAP=STD</B> 2 which tells the debugger to catch exceptions only
on the second chance (normally it would be the debugger that traps the exception).
<LI>To debug an OS/2 16-bit application under Phar Lap's RUN286 DOS extender, you must use<B> /TRAP=STD16.</B>
</OL>
<DT>/LInes=n
<DD>controls the number of lines used by a character mode debugger.&nbsp; The number of lines available depends on the operating
system and your video card.&nbsp; The values 25, 43 and 50 are often supported.
<DT>/COlumns=n
<DD>controls the number of columns used by a character mode debugger.&nbsp; The number of columns available depends on the operating
system and your video card.&nbsp; If your system does not support the requested number of columns, this option is ignored
<DT>/Invoke=file
<DD>may be used to specify an alternate name for the debugger configuration file which is to be used at start-up time.&nbsp; The
default file name is &quot;WD.DBG&quot;.&nbsp; Debugger configuration files are found in the current directory or one of the
directories in your<B> PATH</B> .
<DT>/NOInvoke
<DD>specifies that the default debugger configuration file is not to be invoked.
<DT>/NOMouse
<DD>requests that the debugger ignore any attached mouse.&nbsp; <B><I> This may be necessary if you are trying to debug mouse
events received by your application.</I></B>&nbsp; This option ensures that the debugger will not interfere with the mouse.
<DT>/DYnamic=number
<DD>specifies the amount of dynamic storage that the debugger is to set aside for its own use on startup.&nbsp; The default amount
that is set aside is 500K bytes.&nbsp; The larger the amount, the less memory will be available for the application to be
debugged.<B><I>&nbsp; You only need to use this option if the debugger runs out of memory, or is causing your application
to run out of memory.</I></B>&nbsp; If you are using the remote debugging feature, the debugger will use as much available
memory as available.
<DT>/NOExports
<DD>specifies that no exports (system symbols) should be loaded.&nbsp; It helps to speed up load time when debugging remotely
and marginally so when debugging locally.
<DT>/LOcalinfo=local_file
<DD>is used primarily, but not exclusively, in conjunction with the remote debugging capabilities of the debugger.&nbsp; It causes
the debugger to use one or more local files as sources of debugging information if the right conditions are met.&nbsp; When
the debugger observes that an executable file or Dynamic Link Library (DLL) is being loaded with the same name (i.e., the
path and extension have been stripped) as one of the<B> /localinfo</B> files, then the named local file is used as a source
of debugging information.&nbsp; The named file can be an executable file, a DLL file (.dll), a symbolic information file (.sym),
or any other file with debugging information attached.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; wd /local=c:\dlls\mydll.sym /local=c:\exes\myexe.exe /tr=par myexe</TT>
<BR><BR>In the above example, the debugger would obtain debugging information for any executable or DLL called<TT> myexe</TT>
or<TT> mydll</TT> from<TT> c:\exes\myexe.exe</TT> or<TT> c:\dlls\mydll.sym</TT> respectively.&nbsp; Note that no path searching
is done for local files.&nbsp; The debugger tries to open the file exactly as specified in the<B> localinfo</B> option.
<BR><BR>See the section entitled <A HREF="#Remote_Debugging">Remote Debugging</A> for an explanation of remote debugging.
<DT>/DOwnload
<DD>specifies that executable file to be debugged is to be downloaded to the task machine from the debugger machine.&nbsp; The
debugger searches for the executable file in the local path, and downloads it to the debug server's current working directory
on the remote machine before starting to debug.&nbsp; Debugging information is not downloaded, but is obtained locally, as
in the<B> localinfo</B> option.&nbsp; Note:&nbsp; Only the executable is downloaded; any required DLLs must be present on
the remote machine.&nbsp; Downloading is relatively fast if you are using one of the TCP/IP (TCP) or Netware (NOV) remote
links.&nbsp; Be sure to specify the file extension if it is not &quot;.exe&quot;.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; wd /tr=nov;john /download sample.exe</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; wd /tr=nov;john /download sample.nlm</TT>
<BR><BR>The debugger does not erase the file when the debugging session ends.&nbsp; So if you debug the application again,
it will check the timestamp, and if the file is up-to-date, it doesn't bother re-downloading it.
<BR><BR>See the section entitled <A HREF="#Remote_Debugging">Remote Debugging</A> for an explanation of remote debugging.
<DT>/REMotefiles
<DD>is used in conjunction with the remote debugging capabilities of the debugger.&nbsp; It causes the debugger to look for all
source files and debugger files on the remote machine.&nbsp; When<B> remotefiles</B> is specified, all debugger files (except
&quot;trap&quot; files) and application source files are opened on the task machine rather than the debugger machine.&nbsp;
The trap file must be located on the debugger machine.
<BR><BR>The<B> PATH</B> environment variable on the task machine is always used in locating executable image files.&nbsp;
When<B> remotefiles</B> is specified, the debugger also uses the task machine's<B> PATH</B> environment variable to locate
debugger command files.&nbsp; See the section entitled <A HREF="#Remote_Debugging">Remote Debugging</A> for an explanation
of remote debugging.&nbsp; See the section entitled <A HREF="#Specifying_Files_on_Remote_and_Local_Machines">Specifying Files on Remote and Local Machines</A>
for an explanation of remote and local file names.
<DT>/NOFpu
<DD>requests that the debugger ignore the presence of a math coprocessor.
<DT>/NOSYmbols
<DD>requests that the debugger omit all debugging information when loading an executable image.<B><I>&nbsp; This option is useful
if the debugger detects and tries to load debugging information which is not valid.</I></B>
<DT>/DIp=dipname
<DD>used to load a non-default Debug Information Processor (DIP).&nbsp; This option is generally not needed since the debugger
loads all DIPs that it finds by default.&nbsp; See <A HREF="#The_Images_Window">The Images Window</A>.
</DL>
<H2 ID="DOS_and_Windows_Options"> DOS and Windows Options </H2>
<BR>The following switches apply to the DOS (binw\wd) and Windows 3.x character-mode (binw\wdc) debuggers.&nbsp; Refer to
the sections called <A HREF="#DOS_Specific_Options">DOS Specific Options</A> and <A HREF="#Windows_Specific_Options">Windows Specific Options</A>
for more switches relating to these environments.
<DL>
<DT>/Monochrome
<DD>When two display devices are present in the system, this option indicates that the Monochrome display is to be used as the
debugger's output device, leaving the Color display for the application to use.&nbsp; Use this option in conjunction with
the<B> Two</B> option described below.
<DT>/Color, /Colour
<DD>When two display devices are present in the system, this option indicates that the Colour display is to be used as the debugger's
output device.&nbsp; This option is used in conjunction with the<B> Two</B> option described below.
<DT>/Ega43
<DD>When an Enhanced Graphics Adapter (EGA) is present, 43 lines of output are displayed by a character mode debugger.
<DT>/Vga50
<DD>When a Video Graphics Array (VGA) is present, 50 lines of output are displayed by a character mode debugger.
<DT>/Overwrite
<DD>specifies that the debugger's output can overwrite program output.&nbsp; In this mode, the application and the debugger are
forced to share the same display area.
<BR><BR><B><I>Do not use this option if you wish to debug a DOS graphics-mode application.</I></B>
<DT>/Two
<DD>specifies that a second monitor is connected to the system.&nbsp; If the monitor type<B> (Monochrome, Color, Colour, Ega43,
Vga50)</B> is not specified then the monitor that is not currently being used is selected for the debugger's screen.&nbsp;
If the monitor type is specified then the monitor corresponding to that type is used for the debugger's screen.<B><I>&nbsp;
This option may be used when debugging a DOS graphics-mode application on the same machine and a second monitor is available.</I></B>
</DL>
<H2 ID="DOS_Specific_Options"> DOS Specific Options </H2>
<BR>Use the following switches for the DOS debuggers.&nbsp; For more DOS options, refer to the section called <A HREF="#DOS_and_Windows_Options">DOS and Windows Options</A>.
<DL>
<DT>/Page
<DD>specifies that page 0 of screen memory is to be used for the application's screen and that page 1 of screen memory should
be used for the debugger's screen.&nbsp; This option may be selected when using a graphics adapter such as the CGA, EGA or
VGA.&nbsp; Using the<B> Page</B> option results in faster switching between the application and debugger screens and makes
use of the extra screen memory available with the adapter.&nbsp; This is the default display option.<B><I>&nbsp; Do not use
this option if you wish to debug a DOS graphics-mode application.</I></B>
<DT>/Swap
<DD>specifies that the application's screen memory and the debugger's screen memory are to be swapped back and forth using a single
page.&nbsp; The debugger allocates an area in its own data space for the inactive screen.&nbsp; This reduces the amount of
memory available to the application.&nbsp; It also takes more time to switch between the application and debugger screens.<B><I>
&nbsp;This option MUST be used when debugging a DOS graphics-mode application and a second monitor is not available.</I></B>
<BR><BR>The default display options are:
<OL>
<LI>If you have a two display system, the debugger uses both displays with the program output appearing on the active monitor
and the debugger output appearing on the alternate monitor.&nbsp; In other words, the<B> Two</B> option is selected by default.
<LI>If you have one of the CGA, EGA or VGA graphics adapters installed in your system then the debugger selects the<B> Page</B>
option by default.
<LI>Under all other circumstances, the debugger selects the<B> Swap</B> option by default.
</OL>
<DT>/CHecksize=number
<DD>specifies the minimum amount of storage, in kilobytes, that the debugger is to provide to DOS for the purpose of spawning
a program while the debugger is active.<B><I>&nbsp; This option is useful when the application that is being debugged uses
up most or all of available storage, leaving insufficient memory to spawn secondary programs.</I></B>&nbsp; In order to provide
the requested amount of free memory to DOS, the debugger will checkpoint as much of the application as required.
<BR><BR>Checkpointing involves temporarily storing a portion of the memory-resident application on disk and then reusing the
part of memory that it occupied for the spawned program.&nbsp; When the spawned program terminates, the checkpointed part
of the application is restored to memory.
<BR><BR>The default amount is 0K bytes.&nbsp; In this case, the spawned program may or may not be run depending on how much
free storage is available to DOS to run the program.
<DL>
<DT>Warning:
<DD>If the application being debugged installs one or more interrupt handlers, the use of this option could hang your system.
&nbsp;Your system could lock up if the debugger checkpoints a portion of the application's code that contains an interrupt
handler.
</DL>
<DT>/NOCHarremap
<DD>turns off the character re-mapping that the DOS debugger uses for displaying dialogs and window frames.<B><I>&nbsp; Use this
option when trying to debug in an environment where character remapping is not available.</I></B>&nbsp; Windowed DOS boxes
under OS/2 do not support character re-mapping.
<DT>/NOGraphicsmouse
<DD>Turn off the graphics mouse emulation code that makes the mouse cursor look like an arrow instead of a block.<B><I>&nbsp;
Use this option if the mouse cursor appears as 4 line drawing characters instead of an arrow.</I></B>
</DL>
<H2 ID="Windows_Specific_Options"> Windows Specific Options </H2>
<BR>Use the following switches for the Windows character-mode debugger.&nbsp; Refer to the section called <A HREF="#DOS_and_Windows_Options">DOS and Windows Options</A>
for more Windows options.
<DL>
<DT>/Fastswap
<DD>specifies that Windows 3.x screen memory and the debugger's screen memory are to be swapped back and forth using a technique
that is faster than the default method of screen swapping but not guaranteed to work for all video adapters.&nbsp; This option
applies to Windows 3.x only.&nbsp; By default, the Windows 3.x version of the debugger uses a more conservative (and slower)
method that works with all video adapters.
</DL>
<H2 ID="Linux_Options"> Linux Options </H2>
<BR>You can use the following switch for the Linux debugger.
<DL>
<DT>-Console=console_spec
<DD>specifies the virtual console to use for debugger windows.&nbsp; This may be a console number as in the following example.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -console=2</TT>
<BR><BR>You may also use a full device name.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -console=/dev/tty</TT>
<BR><BR>In this case, the debugger will use that device for its input and output.&nbsp; The debugger/application screen flipping
features will be disabled.
<BR><BR>You can also optionally follow the device name with a colon and a terminal type.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -con=/dev/tty:vt240</TT>
<BR><BR>This will let the debugger know what kind of terminal it's talking to so it can initialize the user interface appropriately.
<DT>-COlumns=n
<DD>specifies the number of columns of the screen/window that the debugger should attempt to establish.
<DT>-XConfig=string
<DD>specifies a set of X Windows configuration options to pass to<B> xterm</B>.&nbsp; The following example sets the<B> xterm</B>
font size to 12 point.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -xc=-fs -xc=12</TT>
</DL>
<H2 ID="QNX_Options"> QNX Options </H2>
<BR>You can use the following switch for the QNX debugger.
<DL>
<DT>-Console=console_spec
<DD>specifies the virtual console to use for debugger windows.&nbsp; This may be a console number as in the following example.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -console=2</TT>
<BR><BR>You may also use a full device name.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -console=//23/dev/ser1</TT>
<BR><BR>In this case, the debugger will use that device for its input and output.&nbsp; The debugger/application screen flipping
features will be disabled.
<BR><BR>You can also optionally follow the device name with a colon and a terminal type.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -con=/dev/ttyp1:vt240</TT>
<BR><BR>This will let the debugger know what kind of terminal it's talking to so it can initialize the user interface appropriately.
<DT>-COlumns=n
<DD>specifies the number of columns of the screen/window that the debugger should attempt to establish.
<DT>-XConfig=string
<DD>specifies a set of X Windows configuration options to pass to<B> xqsh</B>.
</DL>
<H2 ID="Environment_Variables"> Environment Variables </H2>
<BR>You can use the<B> WD</B> environment variable to specify default options to be used by the debugger.&nbsp; Once you have
defined the environment variable, those options are used each time you start the debugger.
<H3 ID="WD_Environment_Variable"> WD Environment Variable </H3>
<BR>If the specification of an option involves the use of an &quot;=&quot; character, use the &quot;#&quot; character in its
place.&nbsp; This is required by the syntax of the &quot;SET&quot; command.&nbsp; Options found in the environment variable
are processed before options specified on the command line.&nbsp; The following example illustrates how to define default
options for the debugger:&nbsp; 
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set wd=/swap/lines#50</TT>
<H3 ID="WD_Environment_Variable_in_Linux"> WD Environment Variable in Linux </H3>
<BR>The following example illustrates how to define default options for the debugger under Linux:
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; $ export WD=&quot;-lines=50 -columns=100&quot;</TT>
<BR><BR>Under Linux, care must be taken to specify the environment variable name entirely in uppercase letters.
<H3 ID="WD_Environment_Variable_in_QNX"> WD Environment Variable in QNX </H3>
<BR>The following example illustrates how to define default options for the debugger under QNX:
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; $ export &quot;WD=-nofpu -console=3&quot;</TT>
<BR><BR>Under QNX, care must be taken to specify the environment variable name entirely in uppercase letters.
<H1 ID="The_Open_Watcom_Debugger_Environment"> The Open Watcom Debugger Environment </H1>
<BR>This chapter describes the interactions you need in order to use the debugger.
<H2 ID="Debugger_Windows"> Debugger Windows </H2>
<BR>The debugger displays its information in windows.&nbsp; Both the character and the GUI-based debuggers use similar conventions
for window manipulation.
<H3 ID="Window_Controls"> Window Controls </H3>
<BR>Each window has the following controls
<DL>
<DT>Minimize, Maximize, Restore
<DD>You can control the size of each window using the Minimize, Maximize, and Restore buttons.&nbsp; The buttons appear on the
top right corner of the window.&nbsp; The Minimize button is the down arrow.&nbsp; When you click on the down arrow, the window
becomes an icon at the bottom of the screen.&nbsp; The Maximize button is the up arrow.&nbsp; When you click on the up arrow,
the window fills the whole screen.&nbsp; The Restore button appears only when the window is maximized.&nbsp; It is an up and
down arrow.&nbsp; Click on the Restore button to put the window back to its original size.
<DT>Close
<DD>Each window has a Close button in the top left corner.&nbsp; Double-click on this button to close the window.
<DT>System Menu
<DD>The<B><I> System Menu</I></B> contains menu items that operate on the window.&nbsp; It contains:
<UL>
<LI><B><I> Restore</I></B>
<LI><B><I> Move</I></B>
<LI><B><I> Size</I></B>
<LI><B><I> Minimize</I></B>
<LI><B><I> Maximize</I></B>
</UL>
<BR>You can activate the System Menu of the main window by clicking once on the System Menu button (top, left-hand corner)
or by typing ALT-Space.&nbsp; For Microsoft Windows, you can type ALT-Hyphen to activate a child window's System Menu.
<DT>Scroll Bars
<DD>Windows that contain information that cannot fit in the window have scroll bars.&nbsp; Use the scroll bars to reposition the
window so the information you want to see is visible.&nbsp; The small box in the scroll bar indicates the current scroll position
in the window.
<DT>Title
<DD>Each window is titled so that you know what information it contains.&nbsp; The title appears in the bar at the top of the
window.
<DT>Buttons
<DD>Many windows have small buttons on the left hand side.&nbsp; These buttons are short forms for performing the most common
operations.
</DL>
<H3 ID="The_Current_Window"> The Current Window </H3>
<BR>The current window is the one whose title bar is coloured.&nbsp; Press CTRL-TAB to move from window to window.
<H3 ID="Controlling_the_Size_and_Location_of_Windows"> Controlling the Size and Location of Windows </H3>
<BR>The following window operations are possible.
<UL>
<LI><A HREF="#Moving_Windows">Moving Windows</A>
<LI><A HREF="#Resizing_Windows">Resizing Windows</A>
<LI><A HREF="#Zooming_Windows">Zooming Windows</A>
<LI><A HREF="#Context_Sensitive_PopMup_Menus">Context Sensitive Pop-up Menus</A>
<LI><A HREF="#Text_Selection">Text Selection</A>
</UL>
<H4 ID="Moving_Windows"> Moving Windows </H4>
<BR>To move a window, click in the Title bar and drag it to a new location.&nbsp; You can also choose<B><I> Move</I></B> from
the<B><I> System Menu</I></B> and use the cursor keys to reposition the window, pressing ENTER when the window is in the right
spot.
<H4 ID="Resizing_Windows"> Resizing Windows </H4>
<BR>In the GUI-based version of the debugger, you can resize a window's width, height, or both.&nbsp; Refer to the system
documentation for details.
<BR><BR>In the character-based version of the debugger, you can only resize a window from the corners.&nbsp; Move the cursor
to any corner of the window.&nbsp; Click and drag the mouse to resize the window.
<BR><BR>You can also choose<B><I> Size</I></B> from the<B><I> System Menu</I></B> to change the size of a window.&nbsp; Use
the cursor keys to resize the window, press ENTER when the window is the right size.
<H4 ID="Zooming_Windows"> Zooming Windows </H4>
<BR>Choose<B><I> Zoom</I></B> from the<B><I> Window</I></B> menu to toggle a window between its maximized and normal sizes.
<H4 ID="Context_Sensitive_PopMup_Menus"> Context Sensitive Pop-up Menus </H4>
<BR>The debugger has context sensitive pop-up menus for each window in the application.<B><I>&nbsp; You can access the menu
either by pressing the right mouse button in the window or by typing the period (.) key.</I></B>&nbsp; You can then choose
a menu item by typing the highlighted character or by clicking the mouse on it.
<BR><BR>If you have memorized the highlighted menu character, you can bypass the menu and activate the menu item directly
by pressing the CTRL key in conjunction with that character.&nbsp; The items that appear in the menu depend on the current
window.&nbsp; These menus are described in detail throughout this document.
<DL>
<DT>Note
<DD>The<B><I> Action</I></B> item in the main menu is identical to the the context sensitive pop-up menu for the current window
and may be used instead of pop-up menus.
</DL>
<BR>For more information on the choices presented in the pop-up menus, see the section entitled <A HREF="#Variable_and_Watch_Windows">Variable and Watch Windows</A>.
<H4 ID="Text_Selection"> Text Selection </H4>
<BR>Some windows, such as the Source and Assembly windows, allow you to select text.&nbsp; For example, you might want to
select a variable name or expression.&nbsp; Menu items will act on the selected item.
<BR><BR>You can select text with either the left or right mouse button.&nbsp; If you use the right button, the pop-up menu
appears when you release the button.&nbsp; With the keyboard, hold SHIFT while using the cursor keys.&nbsp; You can select
a single character and the debugger will automatically extend the selection to include the entire surrounding word.
<H2 ID="Menus"> Menus </H2>
<BR>At the top of the debugger window are a number of menu items.&nbsp; You can select a menu item with the mouse or by pressing
ALT and the highlighted character from the menu title.
<BR><BR>Many menu items have accelerators or keyboard equivalents.&nbsp; They appear to the right of the menu item.&nbsp;
As you learn the debugger, take time to learn the accelerators.&nbsp; They will help you to use the debugger more effectively.
<H2 ID="The_Toolbar"> The Toolbar </H2>
<BR><TT><IMG SRC="dbgshot.bmp" ALIGN=MIDDLE></TT>
<BR><B><I>Figure 1.</I></B><B><I></I></B><B> The Debugger Window</B>
<BR><BR>The Toolbar appears under the menu in the GUI-based debugger.&nbsp; The buttons in the Toolbar are equivalent to menu
selections.&nbsp; There are eight buttons in the toolbar.&nbsp; Listed from left to right, they are:
<UL>
<LI><B><I> Go</I></B> from the<B><I> Run</I></B> menu
<LI><B><I> Step Over</I></B> from the<B><I> Run</I></B> menu
<LI><B><I> Trace Into</I></B> from the<B><I> Run</I></B> menu
<LI><B><I> Until Return</I></B> from the<B><I> Run</I></B> menu
<LI><B><I> Undo</I></B> from the<B><I> Undo</I></B> menu
<LI><B><I> Redo</I></B> from the<B><I> Undo</I></B> menu
<LI><B><I> Unwind Stack</I></B> from the<B><I> Undo</I></B> menu
<LI><B><I> Rewind Stack</I></B> from the<B><I> Undo</I></B> menu
<LI><B><I> Home</I></B> from the<B><I> Undo</I></B> menu
</UL>
<BR>See the sections entitled <A HREF="#The_Run_Menu">The Run Menu</A> and <A HREF="#The_Undo_Menu">The Undo Menu</A> for
details.
<H2 ID="Dialogs"> Dialogs </H2>
<BR><TT><IMG SRC="dlgbrk.bmp" ALIGN=MIDDLE></TT>
<BR><B><I>Figure 2.</I></B><B><I></I></B><B> A Typical Dialog</B>
<BR><BR>Dialogs appear when you choose a menu item that does not perform an immediate action.&nbsp; They allow you to make
choices and set options.&nbsp; The dialogs contain the following:
<DL>
<DT>Edit fields
<DD>These are fields in which you can type information.
<DT>Buttons
<DD>You can click on buttons to perform actions.
<DT>Default button
<DD>The default button in a dialog is highlighted.&nbsp; You can select this button by pressing ENTER.
<DT>Cancel
<DD>All dialogs contain a cancel button.&nbsp; Choose the Cancel button or press ESC to leave a dialog without saving or implementing
changes you have made to the dialog.
<DT>Check Boxes
<DD>Check boxes are used to control settings in the debugger.&nbsp; Click on the field, or TAB to it and press SPACE to toggle
the option between on and off.
<DT>Radio Buttons
<DD>Radio buttons present a set of mutually exclusive choices.&nbsp; Click on a radio button to turn it on or press TAB to move
to the group of radio buttons and use the cursor keys to select a radio button.&nbsp; If this does not work, use the accelerator
key to turn on the desired radio button.&nbsp; Only one radio button is on at all times.&nbsp; When you select a different
radio button, the currently selected one is turned off.
<DT>List boxes
<DD>A list box contains a list of applicable items.
<DT>Drop-down List boxes
<DD>A drop down list box is a list that does not appear on the screen until you click on the down arrow on the right of the box.
&nbsp;You may then select from a list of options.
</DL>
<H2 ID="Accelerators"> Accelerators </H2>
<BR>Accelerators are keys that you can press in place of selecting a menu item or typing commands.&nbsp; The debugger comes
with a standard set of accelerators that you can view by choosing<B><I> Accelerators</I></B> from the<B><I> Window</I></B>
menu.
<BR><BR>If you are used to the CodeView debugger, you should be comfortable with the Open Watcom Debugger's default set of
accelerators.&nbsp; If you are used to using Turbo Debugger, you can select accelerators which are similar to its accelerator
definitions.&nbsp; To select Turbo accelerators, choose<B><I> Accelerator</I></B> from the<B><I> Window</I></B> menu then
select<B><I> TD Keys</I></B> from the<B><I> Action</I></B> menu.
<H3 ID="Default_Accelerators"> Default Accelerators </H3>
<BR>The default accelerators are:
<DL>
<DT>/
<DD>Search/Find...
<DT>ALT-/
<DD>Search/Next
<DT>CTRL-\
<DD>Search/Next
<DT>?
<DD>add a new expression to the Watch window
<DT>F1
<DD>invoke help facility
<DT>F2
<DD>Data/Registers
<DT>F3
<DD>toggle between source level and assembly level debugging
<DT>F4
<DD>Window/Application
<DT>F5
<DD>Run/Go
<DT>F6
<DD>Window/Next
<DT>F7
<DD>Run/Run to Cursor
<DT>F8
<DD>Run/Trace Into
<DT>F9
<DD>Break/Toggle
<DT>F10
<DD>Run/Step Over
<DT>SHIFT-F9
<DD>add a new item to the Watch window
<DT>CTRL-F4
<DD>close the current window
<DT>CTRL-F5
<DD>restore the current window to its normal size
<DT>CTRL-F6
<DD>rotate the current window
<DT>CTRL-F9
<DD>minimize the current window
<DT>CTRL-F10
<DD>maximize the current window
<DT>ALT-F10
<DD>display the floating pop-up menu for the current window
<DT>CTRL-TAB
<DD>rotate the current window
<DT>CTRL-LEFT
<DD>Undo/Undo
<DT>CTRL-RIGHT
<DD>Undo/Redo 
<DT>CTRL-UP
<DD>Undo/Unwind Stack
<DT>CTRL-DOWN
<DD>Undo/Rewind Stack
<DT>CTRL-BACKSPACE
<DD>Undo/Home
<DT>ALT-1
<DD>Data/Locals
<DT>ALT-2
<DD>Data/Watches
<DT>ALT-3
<DD>Code/Source
<DT>ALT-4
<DD>File/View...
<DT>ALT-5
<DD>Data/Memory at...
<DT>ALT-6
<DD>Data/Memory at...
<DT>ALT-7
<DD>Data/Registers
<DT>ALT-8
<DD>Data/80x87 FPU
<DT>ALT-9
<DD>File/Command...
<DT>CTRL-z
<DD>Window/Zoom
<DT>SPACE
<DD>Run/Step Over
<DT>.
<DD>display the floating pop-up menu for the current window
<DT>:
<DD>File/Command...
<DT>=
<DD>Search/Match
<DT>n
<DD>Search/Next
<DT>N
<DD>Search/Previous
<DT>u
<DD>Undo/Undo
<DT>U
<DD>Undo/Redo
<DT>b
<DD>Break/At Cursor
<DT>e
<DD>Data/Memory at...
<DT>g
<DD>Run/Execute to...
<DT>h
<DD>move cursor left one
<DT>i
<DD>Run/Trace Into
<DT>j
<DD>move cursor down one
<DT>k
<DD>move cursor up one
<DT>l
<DD>move cursor right one
<DT>t
<DD>Break/Toggle
<DT>x
<DD>Run/Next Sequential
</DL>
<H3 ID="Turbo_Emulation_Accelerators"> Turbo Emulation Accelerators </H3>
<BR>The Turbo emulation accelerators are:
<DL>
<DT>F2
<DD>Break/Toggle
<DT>F3
<DD>Code/Modules
<DT>F4
<DD>Run/Run to Cursor
<DT>F5
<DD>Window/Zoom
<DT>F6
<DD>Window/Next
<DT>F7
<DD>Run/Trace Into
<DT>F8
<DD>Run/Step Over
<DT>F9
<DD>Run/Go
<DT>ALT-F2
<DD>Break/New...
<DT>ALT-F3
<DD>close the current window
<DT>ALT-F4
<DD>Undo/Undo
<DT>ALT-F5
<DD>Window/Application
<DT>ALT-F7
<DD>trace one assembly instruction
<DT>ALT-F8
<DD>Run/Until Return
<DT>ALT-F9
<DD>Run/Execute to...
<DT>ALT-F10
<DD>activate the pop-up menu for the current window
<DT>CTRL-F2
<DD>Run/Restart
<DT>CTRL-F4
<DD>open a new Watch window
<DT>CTRL-F7
<DD>add a new item to the Watch window
</DL>
<H2 ID="The_File_Menu"> The File Menu </H2>
<BR>The<B><I> File</I></B> menu contains items that allow you to perform file operations, such as:
<DL>
<DT>Open
<DD>Start debugging a new program, or to restart the current program with new arguments.&nbsp; 
<DT>View
<DD>Display a file in a window.&nbsp; 
<DT>Command
<DD>Enter a debugger command.&nbsp; For a description of debugger commands, refer to the section entitled <A HREF="#Debugger_Commands">Debugger Commands</A>.
&nbsp;
<DT>Options
<DD>Set the global debugging options.&nbsp; For a full description of these options, refer to the section entitled <A HREF="#The_Options_Dialog">The Options Dialog</A>.
&nbsp;
<DT>Window Options
<DD>Set the options for the debugger's various windows.&nbsp; For a full description of these options, refer to the section entitled
<A HREF="#The_Window_Options_Dialog">The Window Options Dialog</A>.&nbsp; 
<DT>Save Setup
<DD>Save the debugger's current configuration.&nbsp; This saves the positions and sizes of all windows as well as all options
and settings.&nbsp; By default, this information is saved into the file<TT> setup.dbg</TT>, however, you can save this information
into another file to create alternate debugger configurations.&nbsp; 
<DT>Load Setup
<DD>Load a configuration previously saved using<B><I> Save Setup.</I></B>&nbsp; 
<DT>Source Path
<DD>Modify the list of directories which will be searched when the debugger is searching for source files.&nbsp; 
<DT>System
<DD>The menu item appears only in the character-based version of the debugger.&nbsp; It spawns a new operating system shell.&nbsp;

<DT>Exit
<DD>Close the debugger.
</DL>
<H3 ID="The_Options_Dialog"> The Options Dialog </H3>
<BR><TT><IMG SRC="dlgopt.bmp" ALIGN=MIDDLE></TT>
<BR><B><I>Figure 3.</I></B><B><I></I></B><B> The Options Dialog</B>
<BR><BR>The Options dialog allows you to change the following settings:
<DL>
<DT>Auto configuration save
<DD>When this option is on, the debugger automatically saves its configuration upon exit.&nbsp; 
<DT>Warning Bell
<DD>When this option is on, the debugger will beep when a warning or error is issued.&nbsp; 
<DT>Implicit Invoke
<DD>If this option is on, the debugger will treat an unknown command as the name of a command file and automatically try to invoke
it.&nbsp; If this option is off, you must use the invoke command to invoke a command file.
<BR><BR>Under UNIX, a conflict is possible when Invoke is on.&nbsp; A path specified for a command file name is confused with
the short form of the DO command (/).&nbsp; A similar problem occurs under DOS, OS/2, Windows 3.x, Windows NT, or Windows
95 when a drive specifier forms part of the file name.&nbsp; 
<DT>Recursion Check
<DD>Use this option to control the way tracing over recursive function calls is handled.&nbsp; When this option is on, and you
trace over a function call, the debugger will not stop if the function executes recursively.&nbsp; 
<DT>Break on write (not change)
<DD>Use this option (if available with the selected trap) to enable true break-on-write breakpoints.&nbsp; This will break on
any write access; not just when a watch point has changed.
<DT>Screen flip on execution
<DD>Use this option to control whether the debugger automatically flips the display to the application's screen upon execution.<B><I>
&nbsp;Leave this option on if you are using the character mode debugger to debug a Windows 3.x application.</I></B>
<DT>Ignore case
<DD>This option controls whether or not case is ignored or respected when the debugger is searching for a string.
<DT>Do not expand hex numbers
<DD>This option controls whether or not hexadecimal values are displayed in their natural size (zero preceded) or displayed in
their most compact form.&nbsp; The default is to display the value in its full natural size.&nbsp; 
<DT>Default Radix
<DD>Use this option to define the default radix used by the debugger.&nbsp; The debugger associates a radix with each action automatically.
&nbsp;For example, if you are asked to enter an address, the debugger assumes base 16.&nbsp; If you double click on a decimal
value, you will be prompted for a decimal replacement value but there are occasions when the debugger must use the default
radix.&nbsp; If you add an arbitrary expression to the Watches window, the default radix is used when interpreting that expression.
&nbsp;You can specify any radix between 2 and 36.
<DT>Double click mS
<DD>This option sets the amount of time in milliseconds allowed between two clicks for the debugger to accept it as a double click.
&nbsp;Enter a larger value if you are having trouble with double clicks.
</DL>
<H3 ID="The_Window_Options_Dialog"> The Window Options Dialog </H3>
<BR><TT><IMG SRC="dlgwopt.bmp" ALIGN=MIDDLE></TT>
<BR><B><I>Figure 4.</I></B><B><I></I></B><B> The Window Options Dialog</B>
<BR><BR>Use the Window Options dialog to define options related to the debugger's various windows.&nbsp; All of these options
appear in a dialog when you choose<B><I> Window Options</I></B> from the<B><I> File</I></B> menu.
<BR><BR>The Window Options dialog allows you to set options for the following windows:
<UL>
<LI>Source
<LI>Modules
<LI>Functions
<LI>Assembly
<LI>Watches
<LI>Locals
<LI>File Variables
<LI>Globals
<LI>Variable
</UL>
<H4 ID="The_Assembly_Options"> The Assembly Options </H4>
<BR>The Assembly options allow you to define how your assembly code appears.&nbsp; You can set the following options:
<DL>
<DT>Show Source
<DD>Turn on this option if you want source code intermixed with assembly code.
<DT>Hexadecimal
<DD>Turn on this option if you want immediate operands and values to be displayed in hexadecimal.
</DL>
<H4 ID="The_Variables_Options"> The Variables Options </H4>
<BR>Use the Variable options to set display options and to specify which members of a class you want displayed when a structure
or class is expanded.&nbsp; You can set:
<DL>
<DT>Protected
<DD>Display protected members in expanded classes.
<DT>Private
<DD>Display private members in expanded classes.
<DT>Whole Expression
<DD>Turn this option on to show the whole expression used to access fields and array elements instead of just the element number
or field name itself.
<DT>Functions
<DD>Display C++ member functions in expanded classes.
<DT>Inherited
<DD>Display inherited members in expanded classes.
<DT>Compiler
<DD>Display the compiler-generated members.&nbsp; You will usually not want this option turned on.
<DT>Members
<DD>Display members of the 'this' pointer as if they were local variables declared within the member function.
<DT>Static
<DD>Display static members.
</DL>
<H4 ID="The_File_Options"> The File Options </H4>
<BR>You can set the display width of a tab in the File options section.&nbsp; This value defaults to 8 spaces.
<H4 ID="The_Functions_and_Globals_Options"> The Functions and Globals Options </H4>
<BR>For both Functions and Global Variables windows, you can turn on the<B><I> Typed Symbols</I></B> option.&nbsp; This restricts
the list of symbols to those that are defined in modules compiled with full debugging information (d2 option).
<H4 ID="The_Modules_Options"> The Modules Options </H4>
<BR>You can turn on<B><I> Show All</I></B> to allow the Modules window to display all modules in your program, not just those
which have been compiled with the d2 option.
<H2 ID="The_Code_Menu"> The Code Menu </H2>
<BR>The<B><I> Code</I></B> menu allows you to display windows that show different information related to your code.&nbsp;
It contains the following items:
<DL>
<DT>Source
<DD>Open the Source window.&nbsp; It shows source code at the currently executing location.&nbsp; See <A HREF="#The_Source_Window">The Source Window</A>.
&nbsp;
<DT>Modules
<DD>Display a sorted list of modules contained in the current program.&nbsp; See <A HREF="#The_Modules_Window">The Modules Window</A>.
&nbsp;
<DT>Functions
<DD>Open a sorted list of all functions in the program.&nbsp; See <A HREF="#The_Functions_Window">The Functions Window</A>.&nbsp;

<DT>Calls
<DD>Open the Call History window.&nbsp; This window displays the program's call stack.&nbsp; See <A HREF="#The_Calls_Window">The Calls Window</A>.
&nbsp;
<DT>Assembly
<DD>Open the Assembly window.&nbsp; It shows assembly code at the currently executing location.&nbsp; See <A HREF="#The_Assembly_Window">The Assembly Window</A>.
&nbsp;
<DT>Threads
<DD>Open a list of all threads in your program and their current state.&nbsp; See <A HREF="#The_Thread_Window">The Thread Window</A>.
&nbsp;
<DT>Images
<DD>Open a list of the executable images which are related to the program being debugged.&nbsp; This includes a list of all loaded
DLLs.&nbsp; See <A HREF="#The_Images_Window">The Images Window</A>.&nbsp; 
<DT>Replay
<DD>Open the program execution Replay window.&nbsp; This window allows you to restart your application and replay your debugging
session to any point.&nbsp; See <A HREF="#The_Replay_Window">The Replay Window</A>.
</DL>
<H2 ID="The_Data_Menu"> The Data Menu </H2>
<BR>The<B><I> Data</I></B> menu contains a number of windows that you can open to view the state of your program's data.&nbsp;
It contains the following items:
<DL>
<DT>Watches
<DD>Open a Watches window.&nbsp; You can add and delete variables from the Watches window and use it to evaluate complex expressions
and perform typecasting.&nbsp; See <A HREF="#Variable_and_Watch_Windows">Variable and Watch Windows</A>.&nbsp; 
<DT>Locals
<DD>Open a Locals window.&nbsp; It displays the local variables of the currently executing function.&nbsp; See <A HREF="#Variable_and_Watch_Windows">Variable and Watch Windows</A>.
&nbsp;
<DT>File Variables
<DD>Open a File Variables window.&nbsp; It contains a list of variables defined at file scope in the current module.&nbsp; See
<A HREF="#Variable_and_Watch_Windows">Variable and Watch Windows</A>.&nbsp; 
<DT>Globals
<DD>Open a sorted sorted list of all global variables in your program.&nbsp; Values are not displayed since it would make this
window very expensive to update, but you can select variables from this window and add them to a Watches window.&nbsp; See
<A HREF="#The_Globals_Window">The Globals Window</A>.&nbsp; 
<DT>Registers
<DD>Displays the CPU registers and their values.&nbsp; See <A HREF="#The_CPU_Register_Window">The CPU Register Window</A>.&nbsp;

<DT>FPU Registers
<DD>Displays the FPU registers and their values.&nbsp; See <A HREF="#The_FPU_Registers_Window">The FPU Registers Window</A>.&nbsp;

<DT>MMX Registers
<DD>Displays the MMX (multi-media extension) registers and their values.&nbsp; See <A HREF="#The_MMX_Registers_Window">The MMX Registers Window</A>.
&nbsp;
<DT>XMM Registers
<DD>Displays the XMM (SSE) registers and their values.&nbsp; See <A HREF="#The_XMM_Registers_Window">The XMM Registers Window</A>.
&nbsp;
<DT>Stack
<DD>Displays memory at the stack pointer.&nbsp; See <A HREF="#The_Memory_and_Stack_Windows">The Memory and Stack Windows</A>.
&nbsp;
<DT>I/O Ports
<DD>Open a window that lets you manipulate the I/O address space of the machine.&nbsp; See <A HREF="#The_IDO_Ports_Window">The I/O Ports Window</A>.
&nbsp;
<DT>Memory at...
<DD>Display memory at a given address.&nbsp; See <A HREF="#The_Memory_and_Stack_Windows">The Memory and Stack Windows</A>.&nbsp;

<DT>Log
<DD>Displays debugger messages and the output from debugger commands.&nbsp; See <A HREF="#The_Log_Window">The Log Window</A>.
</DL>
<H2 ID="The_Window_Menu"> The Window Menu </H2>
<BR>The<B><I> Window</I></B> menu allows you to control and arrange the windows on your screen.
<BR><BR>The<B><I> Window</I></B> menu contains the following items:
<DL>
<DT>Application
<DD>Switch to the output screen of the application.&nbsp; Press any key to return to the debugger.&nbsp; 
<DT>To Log
<DD>Save the current window's contents to the log window.&nbsp; Open the Log window to see the contents.&nbsp; 
<DT>To File
<DD>Save the contents of the current window to a file.&nbsp; You must enter a file name and choose the drive and directory to
which you want to save the information.&nbsp; This is useful for comparing program state between debugging sessions.&nbsp;

<DT>Zoom
<DD>Change the size of the current window.&nbsp; Zoom toggles the current window between its normal and maximum sizes.&nbsp; 
<DT>Next
<DD>Rotate through the windows, choosing a new current window.&nbsp; 
<DT>Accelerator
<DD>Open the Accelerator window.&nbsp; This window allows you to inspect and modify the debugger's keyboard shortcut keys.
</DL>
<H2 ID="The_Action_Menu"> The Action Menu </H2>
<BR>Most windows in the debugger have a context sensitive pop-up menu.&nbsp; The<B><I> Action</I></B> menu will contain the
same menu items as the current window's pop-up menu.&nbsp; It may be used as an alternative to the pop-up menus.&nbsp; As
an alternative to selecting text with the right mouse button and using the pop-up menu, you can select text with the left
mouse button or keyboard and use the<B><I> Action</I></B> menu.&nbsp; For more information on the choices presented in the
pop-up menus, see the section entitled <A HREF="#Variable_and_Watch_Windows">Variable and Watch Windows</A>.
<H2 ID="The_Help_Menu"> The Help Menu </H2>
<BR>The<B><I> Help</I></B> menu contains items that let you use the on-line help facility.&nbsp; They are:
<DL>
<DT>Contents
<DD>Show the main table of contents of the on-line help information.&nbsp; This is equivalent to pressing F1.&nbsp; 
<DT>On Help
<DD>Display help about how to use the on-line help facility.&nbsp; This menu item is not available in character-mode versions
of the debugger.&nbsp; 
<DT>Search
<DD>Search the on-line help for a topic.&nbsp; This menu item is not available in character-mode versions of the debugger.&nbsp;

<DT>About
<DD>Display the &quot;about box&quot;.&nbsp; It contains the copyright and version information of the debugger.
</DL>
<H2 ID="The_Status_Window"> The Status Window </H2>
<BR>The Status window appears at the bottom of the debugger screen.&nbsp; As you drag the mouse over a menu item, descriptive
text about that menu item appears in the toolbar.&nbsp; Messages about the current status of the program and debugger warning
messages also appear in the Status window.
<H2 ID="The_Log_Window"> The Log Window </H2>
<BR><TT><IMG SRC="dbglog.bmp" ALIGN=MIDDLE></TT>
<BR><B><I>Figure 5.</I></B><B><I></I></B><B> The Log Window</B>
<BR><BR>Choose<B><I> Log</I></B> from the<B><I> Data</I></B> menu to see the Log window.&nbsp; The Log window displays several
different types of messages, including:
<UL>
<LI>status messages such as break point notification
<LI>warning and error messages
<LI>output from debugger commands
</UL>
<BR>You can send the contents of any window to the Log window by selecting<B><I> To Log</I></B> from the<B><I> Window</I></B>
menu.&nbsp; This allows you to save a window's contents and review it later.
<H2 ID="The_Accelerator_Window"> The Accelerator Window </H2>
<BR><TT><IMG SRC="dbgacc.bmp" ALIGN=MIDDLE></TT>
<BR><B><I>Figure 6.</I></B><B><I></I></B><B> The Accelerator Window</B>
<BR><BR>The Accelerator window allows you to control the accelerators or keyboard equivalents used by the debugger.&nbsp;
Choose<B><I> Accelerator</I></B> from the<B><I> Window</I></B> menu to open this window.&nbsp; The window displays 4 items
relating to each accelerator definition.&nbsp; They are the key name, the window to which the accelerator applies, the type
of action that the accelerator defines, and the specifics of that action.
<BR><BR>Accelerators may either apply to all windows or to a specific window.&nbsp; You could define F2 to perform a different
action depending upon which window is current.&nbsp; Accelerators which apply to all windows will have a window type of<B>
all.</B>
<BR><BR>An accelerator can define one of three action types.&nbsp; They are:
<DL>
<DT>pop-up
<DD>Activate a pop-up menu item in the current window.
<DT>menu
<DD>Activate an item from the main menu.
<DT>command
<DD>Perform an arbitrary debugger command.
</DL>
<BR>You can modify an element of an accelerator definition by double-clicking on it, or by cursoring to it and pressing ENTER.
&nbsp;Press the right mouse button to access the following menu items:
<DL>
<DT>Modify
<DD>Change the currently selected element of an accelerator assignment.&nbsp; If the key name is selected, the you will be prompted
to type a new key.&nbsp; If the window name is selected, you will be presented with a list of possible window classes.&nbsp;
If the action type or details are selected, you will be presented with a menu in order to pick the menu item which will be
attached to the accelerator.&nbsp; 
<DT>New
<DD>Add a new accelerator assignment.&nbsp; You will be prompted for all details.&nbsp; 
<DT>Delete
<DD>Delete the selected accelerator.&nbsp; 
<DT>TD Keys
<DD>Use an approximation of Borland Turbo Debugger's accelerators.&nbsp; 
<DT>WD Keys
<DD>Use the default set of accelerators.&nbsp; If you are familiar with CodeView, you will be comfortable with these key assignments.
</DL>
<H1 ID="Navigating_Through_a_Program"> Navigating Through a Program </H1>
<BR>This section describes how to use the debugger to browse through your program.
<H2 ID="The_Search_Menu"> The Search Menu </H2>
<BR>The<B><I> Search</I></B> menu allows you to search a window for a given string.&nbsp; It contains the following items:
<DL>
<DT>Find
<DD>Search the current window for the first appearance of a given string.&nbsp; You will be prompted for the string.&nbsp; See
<A HREF="#Entering_Search_Strings">Entering Search Strings</A>.&nbsp; 
<DT>Next
<DD>Find a subsequent occurrence of a search string.&nbsp; 
<DT>Previous
<DD>Find a previous occurrence of a search string.&nbsp; 
<DT>All Modules
<DD>This will search through the source code of all the modules contained in your program for a given string.&nbsp; See <A HREF="#Entering_Search_Strings">Entering Search Strings</A>.
&nbsp;
<DT>Match
<DD>Find a string in a sorted window by incremental matching.&nbsp; Once you select match, the text you type appears in the status
window, and the window you are searching repositions itself as you type each character.&nbsp; Press ESC to leave this mode.
</DL>
<H3 ID="Entering_Search_Strings"> Entering Search Strings </H3>
<BR><TT><IMG SRC="dlgsrch.bmp" ALIGN=MIDDLE></TT>
<BR><B><I>Figure 7.</I></B><B><I></I></B><B> Entering a search string</B>
<BR><BR>When you choose<B><I> Find</I></B> from the<B><I> Search</I></B> menu or<B><I> All Modules</I></B> from the<B><I>
Search</I></B> menu, you must enter the search string that you are looking for and set the parameters for the search.&nbsp;
The Search screen consists of the following items:
<DL>
<DT>Enter Search String
<DD>Enter the string to be found in this edit box.&nbsp; The larger list below shows other strings that you have searched for
during this debugging session.&nbsp; You can select these by clicking on them or by using the up and down arrow keys.&nbsp;
The most recent search string appears at the top of the list.
<DT>Regular Expression
<DD>Check this box if the string is to be interpreted as a regular expression.&nbsp; You can click on the Edit button to edit
the set of regular expression characters that will be used.&nbsp; For a description of regular expressions, see the Editor
manual.
<DT>Ignore Case
<DD>Check this box if you want the debugger to match the search string regardless of case.
</DL>
<H2 ID="The_Source_Window"> The Source Window </H2>
<BR><TT><IMG SRC="dbgsrc.bmp" ALIGN=MIDDLE></TT>
<BR><B><I>Figure 8.</I></B><B><I></I></B><B> The Source Window</B>
<BR><BR>The Source window displays your program's source code.&nbsp; As you trace through your program, it repositions itself
at the currently execution location.&nbsp; If you have an Assembly window open, the Source and Assembly windows will always
be positioned at the same code.&nbsp; If you scroll in one, the other follows.
<BR><BR>Source lines that have code associated with them have a button at the left of the screen.&nbsp; You can click on this
button to set, disable and clear break points.
<BR><BR>You can Inspect any item displayed in the source window by double-clicking on it, or by cursoring to it and pressing
ENTER.&nbsp; Press the right mouse button to access the following pop-up menu items:
<DL>
<DT>Inspect
<DD>Inspect the selected item in an appropriate window.&nbsp; You can select function names, variable names, or any valid expression.
&nbsp;
<DT>Run to Cursor
<DD>Resume program execution until the selected line is executed.&nbsp; 
<DT>Break
<DD>Add a breakpoint based on the selected text.&nbsp; If a variable is selected, the program will stop when its value changes.
&nbsp;If a function name is selected the program will stop when that function is executed.<B><I>&nbsp; This does not set a
break at the current line.</I></B>&nbsp; Use<B><I> Toggle</I></B> from the<B><I> Break</I></B> menu or<B><I> At Cursor</I></B>
from the<B><I> Break</I></B> menu to set a breakpoint at the current line.&nbsp; 
<DT>Enter Function
<DD>Resume program execution until the selected function is entered.&nbsp; 
<DT>Watch
<DD>Add the selected item to the Watches window for further inspection or modification.&nbsp; 
<DT>Find
<DD>Search for other occurrences of the selected string in the Source window.&nbsp; 
<DT>Home
<DD>Reposition the window to show the currently executing location.&nbsp; The cursor will move to the next line of the program
to be executed.&nbsp; 
<DT>Show/Assembly
<DD>Show the assembly code associated with the selected line.&nbsp; 
<DT>Show/Functions
<DD>Show the list of all functions contained in the source file.&nbsp; 
<DT>Show/Address
<DD>Reposition the window at a new address.&nbsp; You will be prompted for an expression.&nbsp; Normally you would type a function
name but you can type any expression that resolves to a code address.&nbsp; For example, you might type the name of a variable
that contains a pointer to a function.&nbsp; See <A HREF="#Open_Watcom_Debugger_Expression_Handling">Open Watcom Debugger Expression Handling</A>.
&nbsp;
<DT>Show/Module
<DD>Show the code for a different module.&nbsp; You will be prompted for its name in a dialog.&nbsp; As a shortcut, you can type
the beginning of a module name and click the Module...&nbsp; button.&nbsp; This will display a list of all modules that start
with the text you typed.&nbsp; 
<DT>Show/Line
<DD>Move to a different source line.&nbsp; You can also find out what line you are looking at.&nbsp; The edit field will be initialized
with the current line number.
</DL>
<H2 ID="The_File_Window"> The File Window </H2>
<BR>A File window is Similar to a source window except that it displays a file which is not part of the program being debugged.
&nbsp;Menu items related to execution such as<B><I> Break</I></B> from the pop-up menu are not available.
<H2 ID="The_Modules_Window"> The Modules Window </H2>
<BR><TT><IMG SRC="dbgmod.bmp" ALIGN=MIDDLE></TT>
<BR><B><I>Figure 9.</I></B><B><I></I></B><B> The Modules Window</B>
<BR><BR>The Modules window displays a list of the modules that make up the current program.&nbsp; To open the Modules window,
choose<B><I> Modules</I></B> from the<B><I> Code</I></B> menu.
<BR><BR>Three items are displayed for each module.&nbsp; At the left, there is a button.&nbsp; You can click the mouse on
it to see the source or assembly associated with the module.&nbsp; This can also be accomplished by double-clicking on the
module name or cursoring to it and pressing ENTER.&nbsp; Next is the module name.&nbsp; Third, if the module is contained
in an executable image other than the one being debugged, is the name of that image.
<BR><BR>Since this window is sorted<B><I> Match</I></B> from the<B><I> Search</I></B> menu can be used to find a module.&nbsp;
Choose<B><I> Match</I></B> from the<B><I> Search</I></B> menu (or press =) and begin typing the name of the module.
<BR><BR>Press the right mouse button to access the following pop-up menu items:
<DL>
<DT>Source
<DD>Show the source code associated with the selected module.&nbsp; 
<DT>Assembly
<DD>Show the assembly code associated with the selected module.&nbsp; 
<DT>Functions
<DD>Show the list of all functions contained in this module.&nbsp; 
<DT>Break All
<DD>Set a breakpoint at each function in this module.&nbsp; 
<DT>Clear All
<DD>Delete all breakpoints which are set at addresses with this module.&nbsp; This does not affect break-on-write break points.
&nbsp;
<DT>Show All
<DD>Toggle between showing all modules and just modules which were compiled with full debugging information (d2).&nbsp; This menu
item sets options on a per-window basis, overriding the global settings.&nbsp; When you use the menu item to change these
settings, they will not be saved between debugging sessions.&nbsp; To change an option permanently, see <A HREF="#The_Window_Options_Dialog">The Window Options Dialog</A>.
</DL>
<H2 ID="The_Globals_Window"> The Globals Window </H2>
<BR><TT><IMG SRC="dbgglob.bmp" ALIGN=MIDDLE></TT>
<BR><B><I>Figure 10.</I></B><B><I></I></B><B> The Globals Window</B>
<BR><BR>You can open the Globals window by choosing<B><I> Globals</I></B> from the<B><I> Data</I></B> menu.&nbsp; This window
displays the names of all global variables defined in the program.&nbsp; You can add a variable to the Watches window by double-clicking
on it, or cursoring to it and pressing ENTER.
<BR><BR>Press the right mouse button to access the following pop-up menu items:
<DL>
<DT>Watch
<DD>Add the selected variable to the Watches window.&nbsp; 
<DT>Raw Memory
<DD>Display the memory associated with the selected variable.&nbsp; 
<DT>Typed Symbols
<DD>Toggle between showing all symbols and just those defined in modules compiled with the d2 option.&nbsp; Variables from the
C/C++ library and assembly code are suppressed.&nbsp; This menu item sets options on a per-window basis, overriding the global
settings.&nbsp; When you use the menu item to change these settings, they will not be saved between debugging sessions.&nbsp;
To change an option permanently, see <A HREF="#The_Window_Options_Dialog">The Window Options Dialog</A>.
</DL>
<H2 ID="The_Functions_Window"> The Functions Window </H2>
<BR><TT><IMG SRC="dbgfunc.bmp" ALIGN=MIDDLE></TT>
<BR><B><I>Figure 11.</I></B><B><I></I></B><B> The Functions Window</B>
<BR><BR>The Functions window can display a list of all functions contained in a module, executable image or program.&nbsp;
To the left of each function name is a button.&nbsp; You can click on these buttons to set and clear breakpoints at the various
functions.&nbsp; This can also be accomplished by double-clicking on the function name or cursoring to a function and pressing
ENTER.
<BR><BR>Press the right mouse button to access the following pop-up menu items:
<DL>
<DT>Break
<DD>Set a breakpoint at the selected function.&nbsp; A dialog will appear so that you can fill in detailed breakpoint information.
&nbsp;For more information, refer to the section entitled <A HREF="#The_Breakpoint_Dialog">The Breakpoint Dialog</A>.&nbsp;

<DT>Source
<DD>Show the source code for the selected function.&nbsp; 
<DT>Assembly
<DD>Show the assembly code associated with the selected function.&nbsp; 
<DT>Typed Symbols
<DD>Toggle between showing all symbols and just those defined in modules compiled with the d2 option.&nbsp; Variables from the
C/C++ library and assembly code are suppressed.&nbsp; This menu item sets options on a per-window basis, overriding the global
settings.&nbsp; When you use the menu item to change these settings, they will not be saved between debugging sessions.&nbsp;
To change an option permanently, see <A HREF="#The_Window_Options_Dialog">The Window Options Dialog</A>.
</DL>
<H2 ID="The_Images_Window"> The Images Window </H2>
<BR><TT><IMG SRC="dbgimg.bmp" ALIGN=MIDDLE></TT>
<BR><B><I>Figure 12.</I></B><B><I></I></B><B> The Images Window</B>
<BR><BR>Choose<B><I> Images</I></B> from the<B><I> Code</I></B> menu to open the Images window.&nbsp; It displays a list of
executable images associated with the program that you are currently debugging.&nbsp; Executable images include the program
executable, DLLs (Windows, OS/2 and Windows NT), and NLMs (NetWare).&nbsp; This window displays the name of the executable
image, the name of the symbolic debugging information file (if available), and the debugging information type.
<BR><BR>Different debugging information types are generated by different compilers.
<BR><BR>Valid information types are:
<DL>
<DT>DWARF
<DD>This information is generated by the Open Watcom compilers.
<DT>Watcom
<DD>This information is optionally generated by the Open Watcom compilers.
<DT>CodeView
<DD>In addition to Open Watcom compilers, several other products, including Microsoft's, can generate CodeView style information.
<DT>MAPSYM
<DD>This information is generated by Microsoft's or IBM's MAPSYM utility.&nbsp; MAPSYM processes linker map file and outputs a
.sym file.&nbsp; Symbol files in MAPSYM format are often available for OS/2 system DLLs.&nbsp; MAPSYM files only contain information
about global symbols, but usually provide much more detail than just exports information.
<DT>EXPORTS
<DD>This information is contained in the executable file itself, and is used by the operating system.&nbsp; Under OS/2, Windows
and Windows NT, DLLs have export tables which define the names and addresses of entry points.&nbsp; Exports information lets
you see the names of system entry points and APIs.&nbsp; Novell NLMs also have entry point tables.&nbsp; In addition, they
may have Novell style debugging information, created with Novell's linker (NLMLINK) or using the Open Watcom Linker's &quot;debug
novell&quot; option.&nbsp; This information is made available to the debugger.
</DL>
<BR>You can add new debugging information to an image by double-clicking on the image name or cursoring to it and pressing
ENTER.
<BR><BR>Press the right mouse button to access the following pop-up menu items:
<DL>
<DT>New Symbols
<DD>Add symbolic debugging information for the selected image.&nbsp; This is useful if you know that a separate debug information
file contains the appropriate debugging information that was not found by the debugger.&nbsp; 
<DT>Delete Symbols
<DD>Delete any symbolic debugging information associated with the selected image.&nbsp; 
<DT>Modules
<DD>Show a list of modules contained in the selected image.&nbsp; 
<DT>Functions
<DD>Show a list of functions contained in the selected image.&nbsp; 
<DT>Globals
<DD>Show a list of all global variables contained in the selected image.
</DL>
<H1 ID="Controlling_Program_Execution"> Controlling Program Execution </H1>
<BR>This section describes how you can control the execution of your program as you debug it.
<H2 ID="The_Run_Menu"> The Run Menu </H2>
<BR>The<B><I> Run</I></B> menu controls how your program executes.&nbsp; It contains the following items.
<DL>
<DT>Go
<DD>Start or resume program execution.&nbsp; Execution resumes at the current location and will not stop until a breakpoint is
encountered, an error occurs, or your program terminates.&nbsp; 
<DT>Run to Cursor
<DD>Resume program execution until it executes the location of the cursor in the Source or Assembly window.&nbsp; Execution will
stop before the cursor position if a breakpoint is encountered or an error occurs.&nbsp; 
<DT>Execute to
<DD>Resume program execution until it executes a specified address.&nbsp; You will be prompted to enter an address.&nbsp; It can
be the name of a function or an expression that resolves to a code address.&nbsp; See <A HREF="#Open_Watcom_Debugger_Expression_Handling">Open Watcom Debugger Expression Handling</A>.
&nbsp;In the dialog, you can click the Symbols...&nbsp; button as a shortcut.&nbsp; You can type a partial symbol name like<TT>
foo</TT> and the Symbol button will show you a list of symbols that start with<TT> foo.</TT>&nbsp; You can then choose one
of these symbols by clicking on it or hitting ENTER.&nbsp; Note that the first time you use the Symbols...&nbsp; in a debugging
session, it will take a while as the debugger sorts the symbol table for the program.
<BR><BR>If your program encounters a breakpoint or an error occurs before the specified address is executed, your request
to stop at the given address is ignored.&nbsp; 
<DT>Step Over
<DD>Trace a single source or assembly line depending on whether the source or assembly window is current.&nbsp; Step Over will
not step into any function calls.&nbsp; 
<DT>Trace Into
<DD>This is similar to<B><I> Step Over</I></B> except that it will step into any function calls.&nbsp; 
<DT>Next Sequential
<DD>Run until the program executes the next sequential source line or assembly instruction.&nbsp; This is useful if the program
is executing the last statement in a loop and you wish to execute until the loop terminates.&nbsp; When using this command,
be sure that the execution path will eventually execute the next statement or instruction.&nbsp; If execution fails to reach
this point then the program may continue to execute until completion.&nbsp; This situation is like setting a breakpoint at
a statement or assembly instruction which will never be executed and then issuing a GO command.&nbsp; In this situation, the
application would execute until an error occurred or another breakpoint was encountered.&nbsp; 
<DT>Until Return
<DD>Resume program execution until the currently executing function returns.&nbsp; Execution terminates prior to this if an error
occurs or a breakpoint is encountered.&nbsp; 
<DT>Skip to Cursor
<DD>Reposition the instruction pointer at the cursor position, &quot;skipping&quot; all instructions in between.&nbsp; When you
continue execution, the program continues from this point.&nbsp; This is useful if you want to skip an offending line or re-execute
something.<B><I>&nbsp; Use this menu item with caution.&nbsp; If you skip to an instruction which is not in the current function
or skip to code that expects a different program state, your program could crash.</I></B>&nbsp; 
<DT>Restart
<DD>Restart your program from the beginning.&nbsp; All breakpoints in your program will be preserved.&nbsp; Breakpoints in DLLs
will not be preserved.&nbsp; 
<DT>Debug Startup
<DD>Restart your program from the beginning but stop before system initialization.&nbsp; Normally the debugger puts you at the
main (fmain, winmain, etc.) entry point in your application.&nbsp; This option will allow you to break much earlier in the
initialization process.&nbsp; This feature is useful for debugging run-time startup code, initializers, and constructors for
static C++ objects.
<BR><BR>For DOS, Windows 3.x and Netware, the debugger will put you at the assembly entry point of your application (i.e.,
it doesn't run the &quot;progstart&quot; hook).
<BR><BR>Windows 3.x runs each DLL's startup code as it loads it, and the static DLLs are really loaded by the run-time startup
code, so, to debug the startup code for a statically linked Windows 3.x DLL, you need to do the following.
<OL>
<LI>Select<B><I> Debug Startup</I></B> from the<B><I> Run</I></B> menu.
<LI>Select<B><I> On Image Load</I></B> from the<B><I> Break</I></B> menu.&nbsp; Type the name of the DLL in which you are
interested.
<LI>Select<B><I> Go</I></B> from the<B><I> Run</I></B> menu
</OL>
<BR>For OS/2 and Windows NT, the debugger will put you at a point after all DLLs have been loaded, but before any DLL initialization
routines are called.&nbsp; This enables you to set breakpoints in your statically referenced DLL's startup code.
<BR><BR>If you have hard-coded int3 instructions in your DLL startup, the debugger will skip them, unless you use<B><I> Debug
Startup</I></B> from the<B><I> Run</I></B> menu.
<BR><BR>All breakpoints in your program will be preserved.&nbsp; Breakpoints in DLLs will not be preserved.&nbsp; 
<DT>Save
<DD>Save the current debugging session to a file.&nbsp; The file contains commands that will allow the debugger to play your debugging
session back to its current point in a later session.&nbsp; See <A HREF="#The_Replay_Window">The Replay Window</A>.&nbsp;

<DT>Restore
<DD>Restore a saved debugging session.&nbsp; If you run the program with different input or if the program is a multi-threaded
application, this option may not work properly since external factors may have affected program execution.&nbsp; See <A HREF="#The_Replay_Window">The Replay Window</A>.
</DL>
<H2 ID="The_Undo_Menu"> The Undo Menu </H2>
<BR>The debugger keeps an execution history as you debug your program.&nbsp; This history is accessible using the<B><I> Undo</I></B>
menu.&nbsp; The effect of program statements as you single step through your program are recorded.&nbsp; All interactions
that allow you to modify the state of your program including modifying variable values, changing memory and registers are
also recorded.&nbsp; Undo and Redo let you browse backward and forward through this execution history.&nbsp; As you use these
menu items, all recorded effects are undone or redone, and each of the debugger's windows are updated accordingly.
<BR><BR>You can resume program execution at any previous point in the history.&nbsp; The program history has no size restrictions
aside from the amount of memory available to the debugger, so theoretically you could single step through your entire program
and then execute it in reverse.&nbsp; There are several practical problems that get in the way of this.&nbsp; When you single
step over a call or interrupt instruction, or let the program run normally, the debugger has no way of knowing what kind of
side effects occurred.&nbsp; No attempt is made to discover and record these side effects, but the fact that you did step
over a call is recorded.&nbsp; If you try to resume program execution from a point prior to a side effect, the debugger will
give you a the option to continue or back out of the operation.&nbsp; Use caution if you choose to continue.&nbsp; If an important
side effect is duplicated, you program could crash.&nbsp; Of course reversing execution over functions with no side effects
is harmless, and can be a useful debugging technique.&nbsp; If you have accidentally stepped over a call that does have a
side effect, you can use<B><I> Replay</I></B> to restore your program state.
<BR><BR>Unwind and Rewind move the debugger's state up and down the call stack.&nbsp; Like Undo, all windows are updated as
you browse up and down the stack, and you can resume execution from a point up the call stack.&nbsp; A warning will be issued
if you try resuming from a point up the call stack since the debugger cannot completely undo the effects of the call.
<BR><BR>Unwind is particularly useful when your program crashes in a routine that does not contain debugging information.
&nbsp;strcpy() is a good example of this.&nbsp; You can use Unwind to find the call site and inspect the parameters that caused
the problem.
<BR><BR>The runtime library detects certain classes of errors and diagnoses them as fatal runtime errors.&nbsp; If this occurs
when you are debugging, the debugger will be activated and the error message will be displayed.&nbsp; For example, throwing
an exception in C++ without having a catch in place is a fatal runtime error.&nbsp; In C, the abort() and assert() functions
are fatal errors.&nbsp; When this happens, you will be positioned in an internal C library call.&nbsp; You can use Unwind
to find the point in your source code that initiated the error condition.
<BR><BR>When Unwind and Undo are used in conjunction, Undo is the primary operation and Unwind is secondary.&nbsp; You can
Undo to a previous point in the history and then Unwind the stack.&nbsp; If you Unwind the stack first and then use Undo,
the Unwind has no effect.
<BR><BR>If you modify the machine state in any way when you are browsing backward through the execution history, all forward
information from that point is discarded.&nbsp; If you have browsed backward over a side effect the debugger will give you
the option of canceling any such operation.
<BR><BR>The Undo menu contains the following items.
<DL>
<DT>Undo
<DD>Browse backwards through the program execution history.&nbsp; 
<DT>Redo
<DD>Browse forward through the program execution history.&nbsp; 
<DT>Unwind Stack
<DD>Move up the call stack one level.&nbsp; 
<DT>Rewind Stack
<DD>Move down the call stack one level.&nbsp; 
<DT>Home
<DD>Return to the currently executing location, reversing the effects of all Undo and Unwind operations.
</DL>
<H2 ID="The_Replay_Window"> The Replay Window </H2>
<BR><TT><IMG SRC="dbgrep.bmp" ALIGN=MIDDLE></TT>
<BR><B><I>Figure 13.</I></B><B><I></I></B><B> The Replay Window</B>
<BR><BR>Choose<B><I> Replay</I></B> from the<B><I> Code</I></B> menu to open the Replay window.&nbsp; This window displays
each of the steps that you have performed during this debugging session that might have affected program flow.&nbsp; There
are three items displayed in the replay window.&nbsp; First is the address the program was executing when you took some action
that could affect the program.&nbsp; These actions include setting break points, tracing and modifying memory.&nbsp; Second
is the source or assembly code found at that address.&nbsp; Third is a command in the debugger's command language that will
duplicate the action you took.&nbsp; The most common use for Replay is when you accidentally step over a function call, or
the program unexpectedly runs to completion.&nbsp; If this happens, you can open the replay window, and replay you debugging
session up to any point prior to the last action you took.
<BR><BR>There are special cases where replay will not perform as expected.&nbsp; Since replay is essentially the same as playing
your keystrokes and mouse interactions back to the debugger, your program must behave identically on a subsequent run.&nbsp;
Any keyboard or mouse interaction that your program expects must be entered the same way.&nbsp; If your program expects an
input file, you must run it on the same data set.&nbsp; Your program should not behave randomly or handle asynchronous events.
&nbsp;Finally, your program should not be multi-threaded.&nbsp; If you have just been tracing one thread, your program will
replay correctly, but multiple threads may not be scheduled the same way on a subsequent run.
<BR><BR>You can replay program execution to any point by double clicking on that line or by cursoring to it and pressing ENTER.
&nbsp;Select any line and press the right mouse button to see the following pop-up menu items:
<DL>
<DT>Goto
<DD>Replay the program until it returns to the selected level in the replay history.&nbsp; 
<DT>Source
<DD>Position the source window at the selected line.&nbsp; 
<DT>Assembly
<DD>Show the assembly code for the selected line.
</DL>
<H2 ID="The_Calls_Window"> The Calls Window </H2>
<BR><TT><IMG SRC="dbgcall.bmp" ALIGN=MIDDLE></TT>
<BR><B><I>Figure 14.</I></B><B><I></I></B><B> The Calls Window</B>
<BR><BR>Choose<B><I> Calls</I></B> from the<B><I> Code</I></B> menu menu to display the Calls window.&nbsp; This window displays
the program's call stack.&nbsp; Each line contains the name of the function that was executing, and the source or assembly
code at the call site.&nbsp; You can use Unwind and Rewind to obtain this information, but the calls windows will show you
the entire call stack.
<BR><BR>You can Unwind to any point in the call stack by double-clicking on a line, or by cursoring to it and pressing ENTER.
&nbsp;Select a line and press the right mouse button to access the following pop-up menu items:
<DL>
<DT>Unwind
<DD>Unwind the stack to the level of the selected code.&nbsp; This is equivalent to using<B><I> Unwind</I></B> from the<B><I>
Undo</I></B> menu or<B><I> Rewind</I></B> from the<B><I> Undo</I></B> menu.&nbsp; 
<DT>Break
<DD>Set a breakpoint at the return from the selected call.&nbsp; 
<DT>Goto
<DD>Execute until the program returns from the selected call.
</DL>
<H2 ID="The_Thread_Window"> The Thread Window </H2>
<BR><TT><IMG SRC="dbgthrd.bmp" ALIGN=MIDDLE></TT>
<BR><B><I>Figure 15.</I></B><B><I></I></B><B> The Thread Window</B>
<BR><BR>Choose<B><I> Thread</I></B> from the<B><I> Code</I></B> menu to display Thread window.&nbsp; This window displays
the system ID of each thread, the state of the thread, and under some operating systems, system specific information about
the thread including its name and scheduling priority.&nbsp; The state of each thread can be:
<DL>
<DT>current
<DD>This is the thread that was running when the debugger was entered.&nbsp; It is the thread that hit a break point or error.
&nbsp;When you trace through the application,<B><I> only the current thread is allowed to run.</I></B>
<DT>runnable
<DD>This thread will be allowed to run whenever you let your program run, but will not run when you trace the program.
<DT>frozen
<DD>This thread will not be allowed to run when you resume your program.
<DT>dead
<DD>Under some operating systems, threads that have been terminated still show up in the list of threads.&nbsp; A dead thread
will never execute again.
</DL>
<BR>You can make any thread current by double clicking on it or cursoring to it and pressing ENTER.&nbsp; All other debugger
windows update accordingly.&nbsp; Press the right mouse button to access the following pop-up menu items:
<DL>
<DT>Switch to
<DD>Make the selected thread current.&nbsp; 
<DT>Freeze
<DD>Change the state of the selected thread to be<B><I> frozen</I></B>.&nbsp; You cannot freeze the current thread.&nbsp; 
<DT>Thaw
<DD>Change the state of the selected thread to be<B><I> runnable.</I></B>.&nbsp; The current thread is always runnable.
</DL>
<H1 ID="Examining_and_Modifying_the_Program_State"> Examining and Modifying the Program State </H1>
<BR>The following topics are discussed:
<UL>
<LI><A HREF="#Variable_and_Watch_Windows">Variable and Watch Windows</A>
<LI><A HREF="#The_Memory_and_Stack_Windows">The Memory and Stack Windows</A>
</UL>
<H2 ID="Variable_and_Watch_Windows"> Variable and Watch Windows </H2>
<BR><TT><IMG SRC="dbgvar.bmp" ALIGN=MIDDLE></TT>
<BR><B><I>Figure 16.</I></B><B><I></I></B><B> The Watch and Variable Window</B>
<BR><BR>Windows that display variables come in several different varieties.&nbsp; They are:
<UL>
<LI>Locals 
<LI>File Variables 
<LI>Watches 
<LI>Variable 
</UL>
<BR>They are collectively called variable windows.&nbsp; You use the same interactions in all variable windows to display,
modify and browse your variables and data structures.&nbsp; The only difference between these windows are the variables that
they display.&nbsp; The values in each window are updated as you trace through your program.&nbsp; The windows display the
following information:
<DL>
<DT>Locals
<DD>Contains the list of variables which are local to the current routine.&nbsp; Choose<B><I> Locals</I></B> from the<B><I> Data</I></B>
menu to open this window.
<DT>File Variables
<DD>Contains a list of all variables which are defined at file scope in the current module.&nbsp; This includes external and static
symbols.&nbsp; Choose<B><I> File Variables</I></B> from the<B><I> Data</I></B> menu to open this window.
<DT>Watches
<DD>The Watches windows allows you to add and delete variables and expressions.&nbsp; In other windows you can choose<B><I> Watch</I></B>
from the pop-up menu.&nbsp; This will open the watches window add the text which is selected in another window to the watches
window.&nbsp; You can use<B><I> New</I></B> from the pop-up menu to add any expression to the Watches window.&nbsp; Once entered,
you can choose<B><I> Edit</I></B> from the pop-up menu to edit the expressions or typecast the variables.
<DT>Variable
<DD>This is another instance of a Watches window.&nbsp; A variable window is created when you select a variable or expression
in a window and use<B><I> Inspect</I></B> from the pop-up menu.
</DL>
<BR>Each line of a variable window has three elements.&nbsp; On the left is a button.&nbsp; The button changes depending on
the type of the variable or expression.&nbsp; it changes based on the type of the item:
<DL>
<DT>structs (classes) (unions)
<DD>Structures may be opened and closed by clicking on the button at the left.&nbsp; When you open a structure or class, one line
is added to the window for each field of the structure.&nbsp; These new lines are indented.&nbsp; If you click on the button
again, the structure is closed and the window is returned to its original state.
<DT>arrays
<DD>Like structs, arrays may be opened and closed.&nbsp; When you open an array, one line is added to the window for each element
of the array.&nbsp; The debugger will display at most 1000 elements of an array.&nbsp; If it contains more you can use<B><I>
Type/Array...</I></B>&nbsp; to open different ranges.&nbsp; Multi dimensional arrays are treated like an array of arrays.
&nbsp;When you open the first dimension, the lines that are added will also be arrays which you can open.
<DT>pointers
<DD>When the variable is a pointer, you can click on the button and the debugger will follow the pointer and change the line to
represent the item which is the result of the pointer reference.&nbsp; For example, if you have a pointer to an integer and
click on the button, the integer value will be displayed.&nbsp; The button then changes to indicate so that you can undo the
operation by clicking on it again.
<BR><BR>In the case of pointers to pointers, clicking on the button will follow the pointers one level each time you click
on the button until a non-pointer value is reached.&nbsp; Clicking on the button at this point will undo take you back to
the original state.&nbsp; When the pointer points to a struct, the structure will automatically be opened when you click on
the button.&nbsp; If a pointer is really an array, you can use<B><I> Type/Array...</I></B>&nbsp; from the pop-up menu to open
it as an array.
</DL>
<BR>Next comes the name of the variable, field or array element being displayed.&nbsp; Finally, the value is displayed.&nbsp;
If the item being displayed is not a scalar item, the value displayed is an indication that it is a complex data type.&nbsp;
If the value changes when you run your program, it will be highlighted.&nbsp; If a variable goes out of scope, or a pointer
value becomes invalid, the value will be displayed as question marks.
<BR><BR>You can modify a variable's value by double clicking on the value field, or by cursoring to it and pressing enter.
&nbsp;Double clicking or pressing enter on the name field is equivalent to clicking on the button.&nbsp; Press the right mouse
button to access the following pop-up menu items:
<DL>
<DT>Modify...
<DD>Modify the value of the selected item.&nbsp; 
<DT>Break
<DD>Set a breakpoint so that execution stops when the selected item's value changes.&nbsp; This is the same as setting a breakpoint
on the object.&nbsp; See <A HREF="#Breakpoints">Breakpoints</A>.
<DT>--------
<DD>
<DT>Inspect
<DD>Open a new Variable window containing the selected item.&nbsp; If the item is a compound object (array, class, or structure),
it will be opened automatically.&nbsp; 
<DT>Watch
<DD>Add the selected item to the Watch window.&nbsp; 
<DT>Show/Raw Memory
<DD>Display raw memory at the address of this variable.&nbsp; This lets you examine the actual binary representation of a variable.
&nbsp;
<DT>Show/Pointer Memory
<DD>Display the memory that the item points to.&nbsp; This is useful when you have a pointer to a block of memory that does not
have a type associated with it.&nbsp; 
<DT>Show/Pointer Code
<DD>Display the code that the variable points to.&nbsp; If the item being displayed is a pointer to function, you can use this
menu item to see the definition of that function.&nbsp; 
<DT>Show/Type
<DD>Display the type of the variable in an information message box.&nbsp; Select &quot;OK&quot; to dismiss the information box
and resume debugging.
<DT>--------
<DD>
<DT>Edit
<DD>Open a dialog box in which you can edit an expression in the Watch window.&nbsp; This is useful for typecasting variables
or evaluating expressions.&nbsp; See <A HREF="#Open_Watcom_Debugger_Expression_Handling">Open Watcom Debugger Expression Handling</A>.
&nbsp;
<DT>New
<DD>Add a new variable or expression to the window.&nbsp; You will be prompted for the expression to add.&nbsp; 
<DT>Delete
<DD>Delete the selected item from the window.
<DT>--------
<DD>
<DT>FieldOnTop
<DD>Display the value of this member at the top of the structure/class.&nbsp; You can selectively add or remove items from the
list that is displayed &quot;on top&quot;.&nbsp; For example, say you have a<TT> struct Point</TT> displayed as:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [-] point</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 30</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; other&nbsp; &quot;asdf&quot;</TT>
<BR><BR>If you toggle<B><I> FieldOnTop</I></B> for both<TT> x</TT> and<TT> y</TT> then<TT> point</TT> would be displayed like
this:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [-] point { 10, 30 }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 30</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; other&nbsp; &quot;asdf&quot;</TT>
<BR><BR>Furthermore, if you closed the struct (or pointer to struct) then you would see:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [+] point { 10, 30 }</TT>
<BR><BR>This carries to structs containing structs (and so on) as shown in the following struct containing two<TT> Point</TT>
structures.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [-] rect { { 10, 10 }, { 30, 30 } }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; top_left { 10, 10 }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bot_right { 30, 30 }</TT>
<BR><BR>If you close it, then you will see:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [+] rect { { 10, 10 }, { 30, 30 } }</TT>
<DT>Class/Show Functions
<DD>Display function members of this object.&nbsp; If this option is not selected, no functions are displayed.&nbsp; This option
works in conjunction with other<B><I> Class</I></B> selections to display &quot;Inherited&quot;, &quot;Generated&quot;, &quot;Private&quot;
and &quot;Protected&quot; functions.&nbsp; 
<DT>Class/Show Inherited
<DD>Display inherited members of this object.&nbsp; To see inherited functions, you must also select<B><I> Class/Show Functions.</I></B>
&nbsp;
<DT>Class/Show Generated
<DD>Display compiled-generated members of this object.&nbsp; To see generated functions, you must also select<B><I> Class/Show
Functions.</I></B>&nbsp; 
<DT>Class/Show Private
<DD>Display private members of this object.&nbsp; To see private functions, you must also select<B><I> Class/Show Functions.</I></B>
&nbsp;
<DT>Class/Show Protected
<DD>Display protected members of this object.&nbsp; To see protected functions, you must also select<B><I> Class/Show Functions.</I></B>
&nbsp;
<DT>Class/Show Static
<DD>Display static members of this object.&nbsp; 
<DT>Type/All Hex
<DD>This item is only available when the display item is an array or a fake array (a pointer changed to display as if it were
an array using<B><I> Type/Array</I></B> ).&nbsp; Change the value of all sibling array entries to be displayed in hexadecimal.
&nbsp;
<DT>Type/Hex
<DD>Change the value to be displayed in hexadecimal.&nbsp; 
<DT>Type/All Decimal
<DD>This item is only available when the display item is an array or a fake array (a pointer changed to display as if it were
an array using<B><I> Type/Array</I></B> ).&nbsp; Change the value of all sibling array entries to be displayed in decimal.
&nbsp;
<DT>Type/Decimal
<DD>Change the value to be displayed in decimal.&nbsp; 
<DT>Type/Character
<DD>Change the value to be displayed as a single character constant.&nbsp; This useful when you have a one byte variable that
really contains a character.&nbsp; The debugger will often display it as an integer by default.&nbsp; 
<DT>Type/String
<DD>The debugger automatically detects pointers to strings in the variable windows and displays the string rather than the raw
pointer value.&nbsp; In the string is not null terminated, contains non-printable characters, or is not typed as a pointer
to 'char', this mechanism will not work.<B><I>&nbsp; Type/String</I></B> overrides the automatic string detecting and displays
the pointer as a string regardless of its type.&nbsp; 
<DT>Type/Pointer
<DD>This will undo the effects of<B><I> Type/String</I></B> or<B><I> Type/Array</I></B>.&nbsp; It will also let you see the raw
pointer value when the debugger has automatically displayed a pointer to char as a string.&nbsp; 
<DT>Type/Array...
<DD>Use this menu item to display a pointer as if it were an array, or to display ranges of an array's elements.&nbsp; You will
be prompted for the first and last element to display.&nbsp; 
<DT>Options/Whole Expression
<DD>Select this option to show the whole expression used to access fields and array elements instead of just the element number
or field name itself.&nbsp; 
<DT>Options/Expand 'this'
<DD>Do not display members of the 'this' pointer as if they were local variables declared within the member function.
</DL>
<H2 ID="The_Memory_and_Stack_Windows"> The Memory and Stack Windows </H2>
<BR><TT><IMG SRC="dbgmem.bmp" ALIGN=MIDDLE></TT>
<BR><B><I>Figure 17.</I></B><B><I></I></B><B> The Memory Window</B>
<BR><BR>Use the Memory window or the Stack window to examine memory in raw form.&nbsp; To open a Memory window, choose<B><I>
Memory At</I></B> from the<B><I> Data</I></B> menu.&nbsp; The<B> Enter Memory Address</B> dialog appears.&nbsp; Enter the
memory address and press Return to see the Memory window.&nbsp; You can also use one of the Show/Pointer Memory or Show/Raw
Memory items in a variable window to display the memory associated with a variable.
<BR><BR>The Stack Window always shows the memory at the stack pointer.&nbsp; It is moved as your program executes to track
the top of the stack.&nbsp; The stack pointer location will be at the top of the window.&nbsp; The location of the BP or EBP
register will also be indicated.&nbsp; Choose<B><I> Stack</I></B> from the<B><I> Data</I></B> menu to open the Stack window.
<BR><BR>You can modify memory by double-clicking on a value in the Memory or Stack window, or by cursoring to it and pressing
enter.&nbsp; You will be prompted for a new value.
<BR><BR>Memory windows allow you to follow data structures in the absence of debugging information.&nbsp; The<B><I> Follow</I></B>
menu items will reposition the memory window to the address that is found under the cursor.&nbsp; The<B><I> Repeat</I></B>
and<B><I> Previous</I></B> items will let you repeat a follow action.&nbsp; This makes it simple to follow linked lists.&nbsp;
Press the right mouse button to access the following pop-up menu items:
<DL>
<DT>Modify
<DD>Modify the value at the selected address.&nbsp; You will be prompted for a new value.&nbsp; You should enter the value in
the same radix as the window is currently displaying.&nbsp; You are not limited to typing constants values.&nbsp; You can
enter an arbitrary expression to be used for the new value.&nbsp; 
<DT>Break on Write
<DD>Set a breakpoint to stop execution when the selected value changes.&nbsp; See <A HREF="#Breakpoints">Breakpoints</A>.
<DT>--------
<DD>
<DT>Near Follow
<DD>Displays the memory that the selected memory points to, treating it as a near pointer.&nbsp; The new offset to be displayed
will be xxxx where xxxx is the word under the cursor.&nbsp; DGROUP will be used as the segment if it can be located.&nbsp;
The program's initial stack segment will be used otherwise.&nbsp; When you are debugging a 16-bit or 32-bit application, the
appropriate word size is used.&nbsp; 
<DT>Far Follow
<DD>Displays the memory that the selected memory points to, treating it as a far pointer.&nbsp; The new address to be displayed
will be the the segment and offset found at the cursor location.&nbsp; Note that pointers are stored in memory with the offset
value first and the segment value second.&nbsp; 
<DT>Segment Follow
<DD>Display the segment that the selected memory points to, treating it as a segment selector.&nbsp; The new address to be displayed
will be xxxx:0 where xxxx is the two byte word under the cursor.&nbsp; 
<DT>Cursor Follow
<DD>Make the selected position the new starting address in the window.&nbsp; This means that the first byte in the memory window
will become the byte that the cursor was pointing to.&nbsp; This is useful for navigating through an array when no debugging
information is available.&nbsp; 
<DT>Repeat
<DD>Repeat the previous Follow operation.&nbsp; The new address that will be used is at the same offset relative to the beginning
of the window as it was in the original Follow operation.&nbsp; Repeating a pointer or segment follow is a linked list traversal.
&nbsp;Repeating a Cursor Follow operation advances to the next element in an array.&nbsp; 
<DT>Previous
<DD>Back out of a Follow or Repeat operation.&nbsp; This will display the memory window you were previously viewing.&nbsp; Essentially,
this undoes a Follow operation.&nbsp; You can back all the way out to the first memory location you were examining.&nbsp;

<DT>Home
<DD>Undo all Follow and Repeat operations.&nbsp; This will take you back to the very first location window you were examining.
&nbsp;It is equivalent to using Previous repeatedly.
<DT>--------
<DD>
<DT>Left
<DD>Scroll the window backward through memory by the size of the displayed memory items.&nbsp; 
<DT>Right
<DD>Scroll the window forward through memory by the size of the displayed memory items.
<DT>--------
<DD>
<DT>Address
<DD>Position the window at a new address.&nbsp; You will be prompted to type in a new address.&nbsp; You can type an arbitrary
expression.&nbsp; See <A HREF="#Open_Watcom_Debugger_Expression_Handling">Open Watcom Debugger Expression Handling</A>.&nbsp;
If you type the name of a variable, the<B> address</B> of that variable is used.&nbsp; If the expression you type does not
contain a segment value DGROUP will be used as the segment if it can be located.&nbsp; The program's initial stack segment
will be used otherwise.&nbsp; 
<DT>Assembly
<DD>Position the assembly window to the address of the memory under the cursor.&nbsp; This is useful if you have incorrectly displayed
a pointer as data and wish to look at the code instead.&nbsp; 
<DT>Type/Byte
<DD>Display as hexadecimal bytes.&nbsp; 
<DT>Type/Word
<DD>Display as hexadecimal 16-bit words.&nbsp; 
<DT>Type/Dword
<DD>Display as hexadecimal 32-bit words.&nbsp; 
<DT>Type/Qword
<DD>Display as hexadecimal 64-bit words.&nbsp; 
<DT>Type/Char
<DD>Display as signed 8-bit integers.&nbsp; 
<DT>Type/Short
<DD>Display as signed 16-bit integers.&nbsp; 
<DT>Type/Long
<DD>Display as signed 32-bit integers.&nbsp; 
<DT>Type/__int64
<DD>Display as signed 64-bit integers.&nbsp; 
<DT>Type/Unsigned Char
<DD>Display as unsigned 8-bit integers.&nbsp; 
<DT>Type/Unsigned Short
<DD>Display as unsigned 16-bit integers.&nbsp; 
<DT>Type/Unsigned Long
<DD>Display as unsigned 32-bit integers.&nbsp; 
<DT>Type/Unsigned __int64
<DD>Display as unsigned 64-bit integers.&nbsp; 
<DT>Type/0:16 Pointer
<DD>Display as 16-bit near pointers (16-bit offset).&nbsp; 
<DT>Type/16:16 Pointer
<DD>Display as 32-bit far pointers (16-bit segment, 16-bit offset).&nbsp; 
<DT>Type/0:32 Pointer
<DD>Display as 32-bit near pointers (32-bit offset).&nbsp; 
<DT>Type/16:32 Pointer
<DD>Display as 48-bit far pointers (16-bit segment, 32-bit offset).&nbsp; 
<DT>Type/Float
<DD>Display as 32-bit floating-point values.&nbsp; 
<DT>Type/Double
<DD>Display as 64-bit floating-point values.&nbsp; 
<DT>Type/Extended Float
<DD>Display as 80-bit floating-point values.
</DL>
<H3 ID="Following_Linked_Lists"> Following Linked Lists </H3>
<BR>Use the memory window to display the memory address of the first node of your linked list.&nbsp; Move to the &quot;next&quot;
field of your structure and use the Near (or Far) Follow command.&nbsp; The next node of your linked list will be displayed.
&nbsp;Now by using the Repeat command you can traverse the linked list.
<H3 ID="Traversing_Arrays"> Traversing Arrays </H3>
<BR>Display the memory address of your array.&nbsp; Select the first byte of the second element of your array then use the
Cursor Follow command to move the second element of your array to the beginning of the memory window.&nbsp; By using the Repeat
command you can traverse your array.
<H1 ID="Breakpoints"> Breakpoints </H1>
<BR><BR>The Open Watcom Debugger uses the single term breakpoint to refer to the group of functions that other debuggers often
call breakpoints, watchpoints, and tracepoints.
<BR><BR>A breakpoint is traditionally defined as a place in your program where you want execution to stop so that you can
examine program variables and data structures.&nbsp; A watchpoint causes your program to be executed one instruction or source
line at a time, watching for the value of an expression to become true.&nbsp; Do not confuse a watchpoint with the watch window.
&nbsp;A tracepoint causes your program to be executed one instruction or source line at a time, watching for the value of
certain program variables or memory-referencing expressions to change.
<BR><BR>In the Open Watcom Debugger:&nbsp; 
<UL>
<LI>Break-on-execute refers to the traditional breakpoint
<LI>Break-on-write refers to the traditional tracepoint
<LI>A traditional watchpoint is a break-on-execute or break-on-write that is coupled with a condition 
</UL>
<BR>The Open Watcom Debugger unifies these three concepts by defining three parts to a breakpoint:
<UL>
<LI>the location in the program where the breakpoint occurs
<LI>the condition under which the breakpoint is triggered
<LI>the action that takes place when the breakpoint triggers
</UL>
<BR>You can specify a countdown, which means that a condition must be true a designated number of times before the breakpoint
is triggered.&nbsp; 
<BR><BR>When a breakpoint is triggered, several things can happen:
<UL>
<LI>program execution is stopped (a breakpoint)
<LI>an expression is executed (code splice)
<LI>a group of breakpoints is enabled or disabled
</UL>
<BR>In this chapter, you will learn about the breakpoint including how to set simple breakpoints, conditional breakpoints,
and how to set breakpoints that watch for the exact moment when a program variable, expression, or data object changes value.
<H2 ID="How_to_Use_Breakpoints_during_a_Debugging_Session"> How to Use Breakpoints during a Debugging Session </H2>
<BR>The following topics are discussed:
<UL>
<LI><A HREF="#Setting_Simple_Breakpoints">Setting Simple Breakpoints</A>
<LI><A HREF="#Clearing__Disabling__and_Enabling_Breakpoints">Clearing, Disabling, and Enabling Breakpoints</A>
</UL>
<H3 ID="Setting_Simple_Breakpoints"> Setting Simple Breakpoints </H3>
<BR>When debugging, you will often want to set a few simple breakpoints to make your program pause execution when it executes
certain code.&nbsp; You can set or clear a breakpoint at any location in your program by placing the cursor on the source
code line and selecting<B><I> Toggle</I></B> from the<B><I> Break</I></B> menu or by clicking on the button to the left of
the source line.&nbsp; You can set breakpoints in the assembly window in a similar fashion.&nbsp; Setting a break-on-write
breakpoint is equally simple.&nbsp; Select the variable with the right mouse button and choose<B><I> Break</I></B> from the
pop-up menu.
<BR><BR>Break points have three states.&nbsp; They are:
<UL>
<LI>enabled
<LI>disabled
<LI>cleared (non-existent)
</UL>
<BR>The button for an enabled break point is a stop sign or [!].&nbsp; The button for a disabled break point is a grey stop
sign or [.].&nbsp; A green diamond or [ ] appears when no breakpoint exists at the given line.&nbsp; The same buttons also
appear in the Assembly window and the Break window to indicate the status of a break point.
<DL>
<DT>Note:
<DD>Some lines in your program do not contain any machine code to execute and therefore, you cannot set a breakpoint on them.
&nbsp;The compiler does not generate machine code for comments and some C constructs.&nbsp; All lines of code in your program
that can have a breakpoint on them have a button to the left of the source line.&nbsp; You can click on them to change their
current status.
</DL>
<H3 ID="Clearing__Disabling__and_Enabling_Breakpoints"> Clearing, Disabling, and Enabling Breakpoints </H3>
<BR>Choosing<B><I> Toggle</I></B> from the<B><I> Break</I></B> menu (F9) toggles between the three different breakpoint states:
<UL>
<LI>enabled
<LI>disabled
<LI>cleared (non-existent)
</UL>
<H2 ID="The_Break_Menu"> The Break Menu </H2>
<BR>You can use the<B><I> Break</I></B> menu to control your breakpoints.&nbsp; Operations including creating new breakpoints,
changing a breakpoint's status, and viewing a list of all break points.
<DL>
<DT>Toggle
<DD>Change the status of the breakpoint at the current line in the source or assembly window.&nbsp; The status alternates between
enabled, disabled and cleared.&nbsp; The button on the source or assembly line will be updated to reflect the status of the
breakpoint.
<DL>
<DT>Note:
<DD>Disabled and cleared breakpoints are not the same.&nbsp; If you disable a breakpoint, you can re-enable it and retain the
information about the breakpoint (i.e., conditions, countdown, and actions).&nbsp; When you clear a breakpoint, you lose all
information about the breakpoint.&nbsp; If you disable a breakpoint, and press F9 twice to enable, you will lose the information
about the breakpoint because you cleared it before you re-enabled it.&nbsp; To enable a disabled breakpoint without losing
the breakpoint information, use the Breakpoint Option dialog or the Breakpoint window.
</DL>
<DT>At Cursor
<DD>Set a breakpoint at the current line in the source or assembly window.&nbsp; If the current line does not contain any executable
code, the breakpoint is set on the closest preceding line of code that does contain executable code.&nbsp; When you choose<B><I>
At Cursor</I></B>, the Breakpoint dialog appears.&nbsp; 
<DT>New
<DD>This allows you to create any type of breakpoint using a dialog.&nbsp; You must specify the address in the dialog.&nbsp; 
<DT>On Image Load...
<DD>Cause program execution to stop when an executable image (DLL) is dynamically loaded.&nbsp; The menu item is only available
when debugging an Win32 or OS/2 executable.&nbsp; A dialogue will appear allowing you to add and delete image names from the
list.&nbsp; You only need to type a substring of the actual image name.&nbsp; You can identify the file &quot;C:\PATH\IMAGE.DLL&quot;
with any substring, for example &quot;IMAGE&quot;, &quot;IMAGE.DLL&quot; or &quot;ATH\IMAGE.DLL&quot;.&nbsp; Case is ignored
in the image names.&nbsp; 
<DT>On Debug Message
<DD>When checked, cause program execution to stop whenever Windows 3.1, Windows NT, or Windows 95 prints a debug string.&nbsp;
A debug string is printed whenever the application or debug Kernel calls the<B><I> OutputDebugString</I></B> function.&nbsp;
This option is toggled each time it is selected from the<B><I> Break</I></B> menu.&nbsp; 
<DT>View All
<DD>Open the breakpoint window.&nbsp; This window will show a list of all breakpoints.&nbsp; You can use the window to create,
delete and modify breakpoints.&nbsp; 
<DT>Clear All
<DD>Clear all breakpoints.&nbsp; 
<DT>Disable All
<DD>Disable all breakpoints, but do not delete them.&nbsp; 
<DT>Enable All
<DD>Enable all breakpoints that are disabled.&nbsp; 
<DT>Save
<DD>Save all breakpoint information to a file.&nbsp; This is useful when you are creating complicated breakpoints.&nbsp; You can
save and restore them in a later debugging session.&nbsp; 
<DT>Restore
<DD>Restore a set of breakpoints that were saved by using<B><I> Save</I></B> from the<B><I> Break</I></B> menu.
</DL>
<H2 ID="The_Break_Window"> The Break Window </H2>
<BR><TT><IMG SRC="dbgbrk.bmp" ALIGN=MIDDLE></TT>
<BR><B><I>Figure 18.</I></B><B><I></I></B><B> The Break Window</B>
<BR><BR>The Break window displays each breakpoint and its status.&nbsp; It appears when you select the<B><I> View All</I></B>
from the<B><I> Break</I></B> menu A breakpoint button appears at the left of each line.&nbsp; You can click on this button
to enable and disable a breakpoint.&nbsp; Unlike the source and assembly windows, the button will not clear the breakpoint.
&nbsp;Next appears the address of the breakpoint.&nbsp; Finally, for break-on-execute breakpoints, the source or assembly
code at the break point location is displayed.&nbsp; For break-on-write breakpoints, the current value of the location is
displayed in hex.
<BR><BR>You can modify any break point by double clicking on it, or by cursoring to it and pressing enter.&nbsp; The Breakpoint
Options dialog will appear to allow you to modify the break point.&nbsp; Press the right mouse button to access the following
pop-up menu items:
<DL>
<DT>Modify
<DD>Change the definition of the selected breakpoint.&nbsp; The Breakpoint dialog will appear.&nbsp; 
<DT>New
<DD>Add a new breakpoint.&nbsp; An empty Breakpoint dialog will appear.&nbsp; You must specify the address of the new Breakpoint.
&nbsp;Refer to the section entitled <A HREF="#The_Breakpoint_Dialog">The Breakpoint Dialog</A> for a description of the items
in the which appear in the dialog.&nbsp; 
<DT>Delete
<DD>Delete the selected breakpoint.&nbsp; 
<DT>Enable
<DD>Enable the selected breakpoint.&nbsp; 
<DT>Disable
<DD>Disable the selected breakpoint.&nbsp; 
<DT>Source
<DD>Display the source code associated with the break point.&nbsp; This operation only makes sense for break-on-execute breakpoints.
&nbsp;
<DT>Assembly
<DD>Display the assembly code associated with the selected line.&nbsp; This operation only makes sense for break-on-execute breakpoints.
</DL>
<H2 ID="The_Breakpoint_Dialog"> The Breakpoint Dialog </H2>
<BR><TT><IMG SRC="dlgbrk.bmp" ALIGN=MIDDLE></TT>
<BR><B><I>Figure 19.</I></B><B><I></I></B><B> The Breakpoint Dialog</B>
<BR><BR>The breakpoint dialog appears when you select<B><I> At Cursor</I></B> from the<B><I> Break</I></B> menu or<B><I> New</I></B>
from the<B><I> Break</I></B> menu and whenever you attempt to modify a break point.&nbsp; It allows you to define the breakpoint
and set all of its conditions.&nbsp; A description of the items in the dialog follows.
<DL>
<DT>Address
<DD>This edit field displays the address tag associated with the selected breakpoint.
<BR><BR>When you choose<B><I> At Cursor</I></B> this field already contains an address that describes the line of code that
the cursor is on.&nbsp; The format of the address tag is<TT> symbol+offset</TT> where<TT> symbol</TT> is the name of the nearest
function and<TT> offset</TT> is distance in bytes past that symbol where the break point is defined.&nbsp; It is normally
best NOT to edit this field.&nbsp; To change the line of source code, leave the dialog, move the cursor to where you want
the breakpoint, and use the<B><I> At Cursor</I></B> command again.
<BR><BR>When you choose<B><I> New</I></B>, this field is empty.&nbsp; You can type any valid address expression in this field.
&nbsp;It can be the name of a function, global variable.&nbsp; Refer to the section entitled <A HREF="#Open_Watcom_Debugger_Expression_Handling">Open Watcom Debugger Expression Handling</A>
for more information about address expressions.&nbsp; In the dialog, you can click the Symbols...&nbsp; button as a shortcut.
&nbsp;You can type a partial symbol name like<TT> foo</TT> and the Symbol button will show you a list of symbols that start
with<TT> foo.</TT>&nbsp; You can then choose one of these symbols by clicking on it or hitting ENTER.&nbsp; Note that the
first time you use the Symbols...&nbsp; in a debugging session, it will take a while as the debugger sorts the symbol table
for the program.
<DL>
<DT>Note:
<DD>Be careful when using local (stack) variables for a break-on-write breakpoint.&nbsp; As soon as execution leaves the scope
of the variable, the memory will change at random since the variable does not really exist any more and the memory will be
used for other variables.&nbsp; Also, if execution enters that variable's scope again, the variable may not have the same
memory address.
</DL>
<DT>Condition
<DD>Use this field to enter a conditions that must be met before a breakpoint will trigger.&nbsp; The condition can be an arbitrary
debugger expression.&nbsp; These include statements in the language you are debugging.&nbsp; A valid example for the C language
is<TT> i == 1.</TT>
<DT>Break on Execute
<DD>Check this field to create a break-on-execute breakpoints.&nbsp; If you choose Execute, be sure that the address field contains
a code address (function name or code line number) and not a variable address.&nbsp; Variable are never executed.&nbsp; If
the address field names a variable, the breakpoint will never trigger.
<DT>Break on 1 Byte/2 Bytes/4 Bytes/8 Bytes...
<DD>Check one of these fields to create break-on-write breakpoints.&nbsp; If you choose one of these options, be sure that the
Address field contains a variable address and not a code address.&nbsp; A code address will never be written to, so the breakpoint
will never trigger.&nbsp; The size of the memory location is defined by the checkbox you use as follows:
<DL>
<DT>1 Byte
<DD>The breakpoint will trigger only when the first byte of the memory address is written to.
<DT>2 Bytes
<DD>The breakpoint will trigger when either of the first two bytes at the memory address are written to.
<DT>4 Bytes
<DD>The breakpoint will trigger if any of the first four bytes of the memory address are written to.
<DT>8 Bytes
<DD>The breakpoint will trigger if any of the first eight bytes of the memory address are written to.&nbsp; This option is only
supported by certain trap files and will be grayed out if the selected trap file does not support it.
</DL>
<DL>
<DT>Note:
<DD>In older versions of the debugger and traps, the break on write feature is really a break on change:&nbsp; the debugger will
only stop execution if the breakpoint is hit and the value of the watched data has been changed.&nbsp; For the current version
of the debugger this is the still the default behaviour but can be modified.&nbsp; Refer to <A HREF="#The_Options_Dialog">The Options Dialog</A>
to change the breakpoint behaviour to true break-on-write.
</DL>
<DT>Countdown
<DD>Use this field to enter the number of times an address must be hit before the breakpoint triggers.&nbsp; Every time the breakpoint
conditions are met, the countdown decreases by one.&nbsp; The breakpoint will trigger only after the countdown is at zero.
&nbsp;Once the countdown reaches zero, the breakpoint will trigger each time the conditions are met.&nbsp; If you have also
set a condition, the countdown will only decrease by one when the condition is true.
<DT>Total Hits
<DD>This field displays the total number of times an address has been hit.&nbsp; This includes the times the breakpoint does not
trigger because a condition failed or the countdown has not yet hit zero.
<DT>Reset
<DD>Click on this button to reset the Total Hits field to zero.
<DT>Execute when Hit
<DD>Use this field to enter a debugger command.&nbsp; When the breakpoint is triggered, the debugger will execute this command.
&nbsp;You can use this field to execute arbitrary C statements, change a variable or register, or even set other breakpoints.
&nbsp;For a more detailed description of commands that can be entered in this field, refer to the section called <A HREF="#Debugger_Commands">Debugger Commands</A>.
&nbsp;If you want to use this field to execute a statement in the language you are debugging, you need to use a DO command
in front of the statement.&nbsp; For example, you could enter<TT> DO i = 10</TT> to have the value of 10 assigned to i each
time the breakpoint triggered.
<DT>Resume
<DD>Check this field if you want the program to resume execution after the<B> Execute when Hit</B> command has been completed.
&nbsp;This capability can be used to patch your code.
<DT>Enabled
<DD>This field displays the current status of the breakpoint.&nbsp; If it is checked, the breakpoint is enabled.&nbsp; If it is
unchecked, the breakpoint is disabled.
<DT>Value
<DD>For Break-on-Execute breakpoints this field displays the source line or the assembly line at which the break point is defined.
&nbsp;For Break-on-Write breakpoints, this field displays the memory contents.
<DT>Clear
<DD>Click on the clear button to clear the breakpoint and close the dialog.
</DL>
<H1 ID="Assembly_Level_Debugging"> Assembly Level Debugging </H1>
<BR>This chapter addresses the following assembly language level debugging features:
<UL>
<LI><A HREF="#The_CPU_Register_Window">The CPU Register Window</A>
<LI><A HREF="#The_Assembly_Window">The Assembly Window</A>
<LI><A HREF="#The_IDO_Ports_Window">The I/O Ports Window</A>
<LI><A HREF="#The_FPU_Registers_Window">The FPU Registers Window</A>
<LI><A HREF="#The_MMX_Registers_Window">The MMX Registers Window</A>
<LI><A HREF="#The_XMM_Registers_Window">The XMM Registers Window</A>
</UL>
<H2 ID="The_CPU_Register_Window"> The CPU Register Window </H2>
<BR><TT><IMG SRC="dbgreg.bmp" ALIGN=MIDDLE></TT>
<BR><B><I>Figure 20.</I></B><B><I></I></B><B> The CPU Register Window</B>
<BR><BR>You can open the CPU Register window by choosing<B><I> Register</I></B> from the<B><I> Data</I></B> menu.&nbsp; The
register names and values are displayed in this window.&nbsp; As you execute your program, registers that have changed since
the last trace or breakpoint will be highlighted.
<BR><BR>You can modify a register value by double clicking on the value, or by cursoring to it and pressing ENTER.&nbsp; Press
the right mouse button to access the following pop-up menu items:
<DL>
<DT>Modify
<DD>Change the value of the selected register.&nbsp; 
<DT>Inspect
<DD>Open a Memory window displaying the memory contents of the address specified by the register.&nbsp; If a segment register
is selected, memory at offset 0 in the segment will be displayed.&nbsp; 
<DT>Hex
<DD>Toggles the register window display format between hexadecimal and decimal.&nbsp; 
<DT>Extended
<DD>Displays the Extended 386 register set.&nbsp; This menu item sets options on a per-window basis, overriding the global settings.
&nbsp;When you use the menu item to change these settings, they will not be saved between debugging sessions.&nbsp; To change
an option permanently, see <A HREF="#The_Window_Options_Dialog">The Window Options Dialog</A>.
</DL>
<H2 ID="The_Assembly_Window"> The Assembly Window </H2>
<BR><TT><IMG SRC="dbgass.bmp" ALIGN=MIDDLE></TT>
<BR><B><I>Figure 21.</I></B><B><I></I></B><B> The Assembly Window</B>
<BR><BR>You can open the Assembly window by choosing<B><I> Assembly</I></B> from the<B><I> Code</I></B> menu.&nbsp; You can
Inspect an item in by double-clicking on it, or by cursoring to it and pressing ENTER.&nbsp; Press the right mouse button
to access the following pop-up menu items:
<DL>
<DT>Inspect
<DD>When you selecting a memory address, register or operand and use Inspect, the debugger opens a Memory Window displaying the
selected memory address.&nbsp; 
<DT>Break
<DD>If a code address is selected this command will set a break-on-execute breakpoint at the selected code address.&nbsp; If a
variable address is selected, this command will set a break-on-write breakpoint on the selected address.<B><I>&nbsp; this
does not set a break at the current line.</I></B>&nbsp; Use<B><I> Toggle</I></B> from the<B><I> Break</I></B> menu or<B><I>
At Cursor</I></B> from the<B><I> Break</I></B> menu to set a breakpoint at the current line.&nbsp; 
<DT>Enter Function
<DD>Resume program execution until the selected function is executed.&nbsp; 
<DT>Show/Source
<DD>Display the source code associated with the selected assembly line.&nbsp; 
<DT>Show/Functions
<DD>Show the list of all functions defined in the current module.&nbsp; 
<DT>Show/Address
<DD>Reposition the window at a new address.&nbsp; You will be prompted for an expression.&nbsp; Normally you would type a function
name but you can type any expression that resolves to a code address.&nbsp; For example, you might type the name of a variable
that contains a pointer to a function.&nbsp; See <A HREF="#Open_Watcom_Debugger_Expression_Handling">Open Watcom Debugger Expression Handling</A>.
&nbsp;
<DT>Show/Module...
<DD>Show a different module.&nbsp; You will be prompted for its name in a dialog.&nbsp; As a shortcut, you can type the beginning
of a module name and click the Module...&nbsp; button.&nbsp; This will display a list of all modules that start with the text
you typed.&nbsp; 
<DT>Home
<DD>Reposition the window to the currently executing location.&nbsp; The cursor will move to the next line of the program to be
executed.&nbsp; 
<DT>No source
<DD>Toggle the Assembly window display between only assembly code and assembly code intermixed with source lines.&nbsp; This menu
item sets options on a per-window basis, overriding the global settings.&nbsp; When you use the menu item to change these
settings, they will not be saved between debugging sessions.&nbsp; To change an option permanently, see <A HREF="#The_Window_Options_Dialog">The Window Options Dialog</A>.
&nbsp;
<DT>Hex
<DD>Toggle the Assembly window display between hexadecimal and decimal.&nbsp; This menu item sets options on a per-window basis,
overriding the global settings.&nbsp; When you use the menu item to change these settings, they will not be saved between
debugging sessions.&nbsp; To change an option permanently, see <A HREF="#The_Window_Options_Dialog">The Window Options Dialog</A>.
</DL>
<H2 ID="The_IDO_Ports_Window"> The I/O Ports Window </H2>
<BR><TT><IMG SRC="dbgio.bmp" ALIGN=MIDDLE></TT>
<BR><B><I>Figure 22.</I></B><B><I></I></B><B> The I/O Window</B>
<BR><BR>Use the I/O window to manipulate I/O ports.&nbsp; This is only supported when the operating system allows application
software to use<B> IN</B> and<B> OUT</B> instructions.&nbsp; I/O ports can be added to the window, and typed as a byte, word
(2 bytes) or dword (4 bytes).&nbsp; Use<B><I> New</I></B> from the pop-up menu to add a new port to the window.&nbsp; Once
you have done this, four items will appear on the line.&nbsp; First appears the read button which appears as an open book,
or [r].&nbsp; Second appears the write button.&nbsp; It is a pencil or [w].&nbsp; Third appears the port address, and finally
the value.&nbsp; When you first enter a port address the value appears as question marks.&nbsp; The debugger does not automatically
read or write the value since this can have side effects.&nbsp; In order to read the displayed value from the port, click
on the read button.&nbsp; To write the displayed value back, click on the write button.&nbsp; You can change the value by
double clicking on it, or by cursoring to it and pressing ENTER.&nbsp; Press the right mouse button to access the following
pop-up menu items:
<DL>
<DT>Modify
<DD>Change the selected item.&nbsp; You can change either the value field or the address field.<B><I>&nbsp; This does not write
the value back to the port.</I></B>&nbsp; You must choose<B><I> Write</I></B> to write to the port.&nbsp; 
<DT>New
<DD>Add a new line to the window.&nbsp; You can have several I/O ports displayed at once.&nbsp; 
<DT>Delete
<DD>Delete the selected line from the window.&nbsp; 
<DT>Read
<DD>Read the displayed value from the port.&nbsp; 
<DT>Write
<DD>Write the displayed value to the port.&nbsp; 
<DT>Type
<DD>Change the display type of the value.&nbsp; The size of this type determines how much is read from or written to the I/O port.
</DL>
<H2 ID="The_FPU_Registers_Window"> The FPU Registers Window </H2>
<BR><TT><IMG SRC="dbgfpu.bmp" ALIGN=MIDDLE></TT>
<BR><B><I>Figure 23.</I></B><B><I></I></B><B> The FPU Registers Window</B>
<BR><BR>Choose<B><I> FPU Registers</I></B> from the<B><I> Data</I></B> menu to open the FPU window.&nbsp; This window displays
the current value and status of all the FPU registers.&nbsp; If you are debugging a program that uses Intel 8087 emulation,
this window display the contents of the emulator's data area.&nbsp; You can change a value by double-clicking on, it or by
cursoring to it and pressing ENTER.&nbsp; Press the right mouse button to access the following pop-up menu items:
<DL>
<DT>Modify
<DD>Change the value of the selected register, or bit.&nbsp; You will be prompted for a new value, unless you are modifying a
bit.&nbsp; A bit will toggle between 0 and 1.&nbsp; 
<DT>Hex
<DD>Toggle the FPU window display between hexadecimal and floating-point display.&nbsp; This menu item sets options on a per-window
basis, overriding the global settings.&nbsp; When you use the menu item to change these settings, they will not be saved between
debugging sessions.&nbsp; To change an option permanently, see <A HREF="#The_Window_Options_Dialog">The Window Options Dialog</A>.
</DL>
<H2 ID="The_MMX_Registers_Window"> The MMX Registers Window </H2>
<BR><TT><IMG SRC="dbgmmxb.bmp" ALIGN=MIDDLE></TT>
<BR><B><I>Figure 24.</I></B><B><I></I></B><B> The MMX Registers Window</B>
<BR><BR>Choose<B><I> MMX Registers</I></B> from the<B><I> Data</I></B> menu to open the MMX window.&nbsp; This window displays
the current values of all the MMX registers.&nbsp; You can change a value by double-clicking on, it or by cursoring to it
and pressing ENTER.&nbsp; Press the right mouse button to access the following pop-up menu items:
<DL>
<DT>Modify
<DD>Change the value of the selected register component.&nbsp; You will be prompted for a new value.&nbsp; The same action can
be performed by pressing ENTER or double-clicking as described above.&nbsp; 
<DT>Inspect
<DD>This item has no function in the MMX register window.&nbsp; 
<DT>Hex
<DD>Toggle the MMX register window display between hexadecimal and floating-point display.&nbsp; This menu item sets options on
a per-window basis, overriding the global settings.&nbsp; When you use the menu item to change these settings, they will not
be saved between debugging sessions.&nbsp; To change an option permanently, see <A HREF="#The_Window_Options_Dialog">The Window Options Dialog</A>.
&nbsp;
<DT>Signed
<DD>Toggle the display of the contents of the MMX registers as signed or unsigned quantities.&nbsp; When &quot;signed&quot; is
enabled, each byte, word, doubleword or quadword is displayed as a signed quantity.&nbsp; When &quot;signed&quot; is disabled,
each byte, word, doubleword or quadword is displayed as an unsigned quantity.&nbsp; 
<DT>Byte
<DD>Display the contents of the MMX registers as a series of 8 bytes.&nbsp; 
<DT>Word
<DD>Display the contents of the MMX registers as a series of 4 words.&nbsp; 
<DT>DWord
<DD>Display the contents of the MMX registers as a series of 2 doublewords.&nbsp; 
<DT>QWord
<DD>Display the contents of the MMX registers as single quadwords.&nbsp; 
<DT>Float
<DD>Display the contents of the MMX registers as a series of 2 IEEE single-precision floating-point values.
</DL>
<H2 ID="The_XMM_Registers_Window"> The XMM Registers Window </H2>
<BR><TT><IMG SRC="dbgxmmb.bmp" ALIGN=MIDDLE></TT>
<BR><B><I>Figure 25.</I></B><B><I></I></B><B> The XMM Registers Window</B>
<BR><BR>Choose<B><I> XMM Registers</I></B> from the<B><I> Data</I></B> menu to open the XMM window.&nbsp; This window displays
the current values of all the XMM registers, as well as the contents of XMM status registers.&nbsp; You can change a value
by double-clicking on, it or by cursoring to it and pressing ENTER.&nbsp; Press the right mouse button to access the following
pop-up menu items:
<DL>
<DT>Modify
<DD>Change the value of the selected register component.&nbsp; You will be prompted for a new value.&nbsp; The same action can
be performed by pressing ENTER or double-clicking as described above.&nbsp; 
<DT>Inspect
<DD>This item has no function in the XMM register window.&nbsp; 
<DT>Hex
<DD>Toggle the XMM register window display between hexadecimal and floating-point display.&nbsp; This menu item sets options on
a per-window basis, overriding the global settings.&nbsp; When you use the menu item to change these settings, they will not
be saved between debugging sessions.&nbsp; To change an option permanently, see <A HREF="#The_Window_Options_Dialog">The Window Options Dialog</A>.
&nbsp;
<DT>Signed
<DD>Toggle the display of the contents of the XMM registers as signed or unsigned quantities.&nbsp; When &quot;signed&quot; is
enabled, each byte, word, doubleword or quadword is displayed as a signed quantity.&nbsp; When &quot;signed&quot; is disabled,
each byte, word, doubleword or quadword is displayed as an unsigned quantity.&nbsp; 
<DT>Byte
<DD>Display the contents of the XMM registers as a series of 16 bytes.&nbsp; 
<DT>Word
<DD>Display the contents of the XMM registers as a series of 8 words.&nbsp; 
<DT>DWord
<DD>Display the contents of the XMM registers as a series of 4 doublewords.&nbsp; 
<DT>QWord
<DD>Display the contents of the XMM registers as a series of 2 quadwords.&nbsp; 
<DT>Float
<DD>Display the contents of the XMM registers as a series of 4 single-precision floating-point values.&nbsp; 
<DT>Double
<DD>Display the contents of the XMM registers as a series of 2 double-precision floating-point values.
</DL>
<H1 ID="Remote_Debugging"> Remote Debugging </H1>
<BR>Remote debugging allows you to run the debugger on one side of a communication link and the application being debugged
on the other.&nbsp; Remote debugging is required when there is not enough memory to run both the debugger and the application
on the same machine.&nbsp; Remote debugging may also be required for debugging graphical applications.
<BR><BR>The DOS debugger runs in protected mode (above the 1M mark), with a small memory footprint in the first 640k.&nbsp;
Newer operating systems such as OS/2 and Windows NT/9x have eliminated the 640k barrier, so there is little need for remote
debugging due to memory limitations alone.&nbsp; However, remote debugging is often helpful when debugging graphical or interactive
application where the debugger interferes with the user application.&nbsp; Remote debugging is also required to debug Novell
NetWare applications, or specialized embedded systems that cannot run the entire debugger.
<BR><BR>There are many different communication links supported.&nbsp; Some communicate between two machines.&nbsp; In this
case an external communication medium is used.&nbsp; Some links communicate between two operating systems shells on the same
machine.&nbsp; In either case, the concepts are the same.
<BR><BR>While remote debugging, you may want to reference a file that is found on one machine or the other.&nbsp; See the
section entitled <A HREF="#Specifying_Files_on_Remote_and_Local_Machines">Specifying Files on Remote and Local Machines</A>
for details about remote and local file names.
<BR><BR>The debugger is broken down into 4 parts.
<DL>
<DT>The Debugger
<DD>This is the portion of the debugger that contains the user interface.&nbsp; It is the largest part of the debugger.&nbsp;
Its name is either WD.EXE, WDW.EXE or WDC.EXE
<DT>The Debug Kernel
<DD>The debugger interprets your requests and sends low level requests to the debug kernel.&nbsp; It is a small executable that
is dynamically loaded by the debugger or a remote debug server and used to control your application.&nbsp; It can be called
STD.TRP, STD.DLL, RSI.TRP or PLS.TRP
<DT>Remote Trap Files-
<DD>These are versions of the debug kernel file that take requests and send them across a communications link to a remote debug
server.&nbsp; You choose a trap file using the debugger's &quot;trap&quot; option.&nbsp; See <A HREF="#Common_Switches">Common Switches</A>.
&nbsp;Trap files have a 3 letter file name that represents the name of the communications layer being used.&nbsp; The file
extension is TRP or DLL.
<DT>Remote Debug Servers-
<DD>These executable files receive requests from a communications link and pass them to a debug kernel.&nbsp; Remote debug server
names all start with ???SERV.&nbsp; The first 3 letters represent the communication layer being used and correspond to the
trap file that is used on the other side of the link.
</DL>
<BR>In the following examples,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; A&gt;cmd1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; B&gt;cmd2</TT>
<BR><BR>indicates that<TT> cmd1</TT> is to be run on one machine and<TT> cmd2</TT> is to be run on the other.
<BR><BR>A normal non-remote debugging session just uses the user interface and the debug kernel.&nbsp; All components run
on the same machine.&nbsp; This simple debugging session would be started with the command:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; A&gt;wd app</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +-----------+ +----------+&nbsp;&nbsp;&nbsp;&nbsp; +----------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; WD.EXE&nbsp;&nbsp; | | STD.TRP&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; | APP.EXE&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / /&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \ \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | |&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +-----------+ +----------+&nbsp;&nbsp;&nbsp;&nbsp; +----------+</TT>
<BR><BR>Debugging a Tenberry Software DOS/4GW (32-bit extended DOS) application is the same except you must use a different
trap file to control the application.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; A&gt;wd /trap=rsi app</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +-----------+ +----------+&nbsp;&nbsp;&nbsp;&nbsp; +----------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; WD.EXE&nbsp;&nbsp; | | RSI.TRP&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; | APP.EXE&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / /&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \ \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | |&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +-----------+ +----------+&nbsp;&nbsp;&nbsp;&nbsp; +----------+</TT>
<BR><BR>A remote debugging session adds a remote debug server and a remote trap file as well.&nbsp; For example, using the
parallel port to debug between two machines would be accomplished using the following components:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; A&gt;parserv</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; B&gt;wd /tr=par app</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +-----------+ +----------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; WD.EXE&nbsp;&nbsp; | | PAR.TRP&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / /&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \ \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | |&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +-----------+ +----------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-- parallel --+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; cable</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +-----------+ +----------+&nbsp;&nbsp;&nbsp;&nbsp; +----------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; PARSERV&nbsp; | | STD.TRP&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; | APP.EXE&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; .EXE&nbsp;&nbsp;&nbsp; / /&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \ \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | |&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +-----------+ +----------+&nbsp;&nbsp;&nbsp;&nbsp; +----------+</TT>
<BR><BR>In order to start the above remote debugging session, you must follow these steps.
<OL>
<LI>Connect the two machines with a parallel cable.&nbsp; See <A HREF="#Wiring_For_Remote_Debugging">Wiring For Remote Debugging</A>.
<LI>Start the remote debug server (PARSERV) on one machine.
<LI>Start the debugger with the option &quot;/trap=PAR&quot; on the other machine.&nbsp; This causes the debugger to load
the remote trap file (PAR).&nbsp; This will communicate across the remote link to PARSERV.EXE, which will in turn communicate
with the debug kernel (STD) in order to debug the application.
</OL>
<BR>The rest of the debugger command line is identical to the command you would type if you were debugging the application
locally.
<BR><BR>You must start the remote debug server first.&nbsp; If you do not, the remote trap file will not be able to establish
a communication link and the debugger will refuse to start.
<BR><BR>It is important to realize that the application to be debugged must reside on the debug server machine.&nbsp; It must
be possible for the debug server to locate the application to be debugged.&nbsp; It can be in the current working directory
of the debugger server machine, or in the<B> PATH,</B> or a path to locate the application on the debug server machine can
be specified on the debugger command line.&nbsp; Alternatively, you can ask the debugger to download the application to the
debug server machine if the application resides on the debugger machine.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; A&gt;parserv</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; B&gt;wd /down /tr=par app</TT>
<BR><BR>See the description of the &quot;download&quot; option in the section entitled <A HREF="#Common_Switches">Common Switches</A>.
<BR><BR>If you are remote debugging a 32-bit application, you must<B><I> use the correct trap file on the remote debug server
side</I></B> of the link.&nbsp; The trap file specification must come first before any other arguments on the command line.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; A&gt;serserv /tr=rsi</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; B&gt;wd /tr=ser app</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +-----------+ +----------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; WD.EXE&nbsp;&nbsp; | | SER.TRP&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / /&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \ \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | |&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +-----------+ +----------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +--- serial ---+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp; cable</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +-----------+ +----------+&nbsp;&nbsp;&nbsp;&nbsp; +----------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; SERSERV&nbsp; | | RSI.TRP&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; | APP.EXE&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; .EXE&nbsp;&nbsp;&nbsp; / /&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \ \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | |&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +-----------+ +----------+&nbsp;&nbsp;&nbsp;&nbsp; +----------+</TT>
<BR><BR>Following is an example of an internal remote link.&nbsp; This example shows you how to use the OS/2 version of the
debugger to debug a DOS application.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +-----------+ +----------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; WD.EXE&nbsp;&nbsp; | | NMP.DLL&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / /&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \ \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | |&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +-----------+ +----------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-- OS/2 NP API --+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +-----------+ +----------+&nbsp;&nbsp;&nbsp;&nbsp; +----------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; NMPSERV&nbsp; | | STD.DLL&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; | APP.EXE&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; .EXE&nbsp;&nbsp;&nbsp; / /&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \ \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | |&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +-----------+ +----------+&nbsp;&nbsp;&nbsp;&nbsp; +----------+</TT>
<BR><BR>The communication medium employed in this case is OS/2 Named Pipes.
<BR><BR>The debugger provides the following remote link capabilities:
<DL>
<DT>NOV
<DD>This link uses Novell's SPX layer for communication.&nbsp; Supported under DOS, OS/2, Windows 3.x, Windows NT/2000/XP and
NetWare.
<DT>NET
<DD>This link uses NetBIOS to communicate.&nbsp; If your network software supports NetBIOS, you can use this link.&nbsp; Supported
under DOS, OS/2, Windows 3.x, and NetWare.
<DT>PAR
<DD>This link supports communication using the parallel or printer port.&nbsp; Several different cable configurations are supported.
&nbsp;See <A HREF="#Wiring_For_Remote_Debugging">Wiring For Remote Debugging</A>.&nbsp; Supported under DOS, OS/2, Windows
3.x, Windows 9x, Windows NT/2000/XP, NetWare, Linux and QNX 4.
<DT>SER
<DD>This link uses a serial port to communicate.&nbsp; Rates of up to 115K BAUD are supported.&nbsp; See <A HREF="#Wiring_For_Remote_Debugging">Wiring For Remote Debugging</A>.
&nbsp;Supported under DOS, OS/2, Windows 9x, Windows NT/2000/XP and QNX 4.
<DT>WIN
<DD>This link will communicate between two Windows DOS boxes.&nbsp; Supported under Windows 3.x and Windows 9x (for DOS applications
only).
<DT>NMP
<DD>This link will use Named Pipes to communicate internally between OS/2 sessions.&nbsp; OS/2, DOS and Win-OS/2 sessions are
supported.&nbsp; If your network supports Named Pipes, and you have at least one OS/2 machine on the network, you can communicate
between OS/2, DOS and Windows 3.x machines on the network.&nbsp; Supported under OS/2 (DOS, OS/2 and Windows 3.x applications).
<DT>VDM
<DD>This link is a subset of the NMP link.&nbsp; It is supported under OS/2 and Windows NT.&nbsp; The application being debugged
must be a DOS or seamless Win-OS/2 application.&nbsp; Supported under OS/2 and Windows NT (DOS, OS/2 and Windows 3.x applications).
<DT>TCP
<DD>This link will use TCP/IP to communicate internally or over a network between sessions.&nbsp; Supported under DOS, OS/2, Windows
9x, Windows NT/2000/XP, Linux and QNX.
</DL>
<BR>Communication parameters may be passed to the remote trap file and the remote server.&nbsp; They are passed to the remote
trap file by following the name of the trap file with a semi-colon and the parameter.&nbsp; For example:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; A&gt;serserv 2.4800</TT>
<BR><BR>passes the parameter 2.4800 to the remote debug server.&nbsp; To pass the same parameter to the remote trap file,
use:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; B&gt;wd /tr=ser;2.4800 app</TT>
<BR><BR>These link parameters are specific to each remote link and are described in the following section.
<BR><BR>Each of the debug servers can accept an optional &quot;Once&quot; parameter.&nbsp; The &quot;Once&quot; parameter
is used by the Open Watcom Integrated Development Environment.&nbsp; Usually, a server stays running until terminated by the
user.&nbsp; If the &quot;Once&quot; option is specified, the remote server will terminate itself as soon as the debugger disconnects
from it.
<H2 ID="Link_Descriptions"> Link Descriptions </H2>
<BR>The following communication links are described:
<UL>
<LI><A HREF="#NOV_LNovell_SPXR">NOV (Novell SPX)</A>
<LI><A HREF="#NET_LNetBIOSR">NET (NetBIOS)</A>
<LI><A HREF="#PAR_LParallelR">PAR (Parallel)</A>
<LI><A HREF="#SER_LSerialR">SER (Serial)</A>
<LI><A HREF="#WIN_LWindows_3_xD9x_Virtual_DOS_MachineR">WIN (Windows 3.x/9x Virtual DOS Machine)</A>
<LI><A HREF="#NMP_LNamed_PipesR">NMP (Named Pipes)</A>
<LI><A HREF="#VDM_LVirtual_DOS_MachineR">VDM (Virtual DOS Machine)</A>
<LI><A HREF="#TCPDIP_LInternet_PacketsR">TCP/IP (Internet Packets)</A>
</UL>
<H3 ID="NOV_LNovell_SPXR"> NOV (Novell SPX) </H3>
<BR>This link communicates over a Novell Network.&nbsp; In order to use this link, you must have a NetWare requester installed
on both machines.&nbsp; Be sure that it is configured to include the SPX option.&nbsp; Consult your NetWare documentation
for details.
<BR><BR>The parameter to this link is an arbitrary name to be used for the connection.&nbsp; This allows multiple network
users users to remote debug simultaneously.&nbsp; The default name is NovLink.&nbsp; If the remote server will not start,
try specifying a different name for the link.&nbsp; The following example shows how to use the default link parameters:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; A&gt;novserv</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; B&gt;wd /tr=nov app</TT>
<BR><BR>The following example shows how to name &quot;john&quot; as a link parameter:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; A&gt;novserv john</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; B&gt;wd /tr=nov;john app</TT>
<H3 ID="NET_LNetBIOSR"> NET (NetBIOS) </H3>
<BR>This link communicates over NetBIOS.&nbsp; In order to use this link, you must have NetBIOS installed on both machines.
&nbsp;Consult your network documentation for details.
<BR><BR>The parameter to this link is an arbitrary name to be used for the connection.&nbsp; This allows multiple network
users users to remote debug simultaneously.&nbsp; The default name is NetLink.&nbsp; The following example shows how to use
the default link parameters.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; A&gt;netserv</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; B&gt;wd /tr=net app</TT>
<BR><BR>The following example shows how to use the name &quot;tammy&quot; as a link parameter.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; A&gt;netserv tammy</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; B&gt;wd /tr=net;tammy app</TT>
<H3 ID="PAR_LParallelR"> PAR (Parallel) </H3>
<BR>This link communicates over the parallel port.&nbsp; Three different cable types may be used.&nbsp; They are called the
LapLink, Flying Dutchman, and Watcom cables.&nbsp; Although the Watcom cable will communicate considerably faster than the
other two, we have found it to be unreliable on some printer cards.&nbsp; See <A HREF="#Wiring_For_Remote_Debugging">Wiring For Remote Debugging</A>.
<BR><BR>The parameter to this link is a number from 1 to 3 or the letter &quot;p&quot; followed by a hexadecimal printer I/O
port address.&nbsp; This tells the software which parallel port the cable is connected to (LPT1, LPT2, LPT3).&nbsp; The default
is 1.&nbsp; The parameter used on each side of the link depends on which printer port the cable is plugged into on that machine.
&nbsp;It need not be the same on both sides.&nbsp; The following example shows how to debug across a parallel cable plugged
into printer port 3 on one machine and port 2 on the other.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; A&gt;parserv 3</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; B&gt;wd /tr=par;2 app</TT>
<BR><BR>As an alternative, you can specify a port address to use.&nbsp; It is less convenient than specifying a port number
but will work on systems like OS/2 where the actual I/O port address cannot be obtained from the system.&nbsp; The following
example shows how to debug across a parallel cable plugged into I/O port 0x378 on one machine and port 2 on the other.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; A&gt;parserv p378</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; B&gt;wd /tr=par;2 app</TT>
<BR><BR>Windows NT Note:&nbsp; Under Windows NT/2000/XP you must have the dbgport.sys device driver installed and loaded on
your machine before the host debugger will be able to access the parallel port.&nbsp; To install this file manually, first
copy it from %WATCOM%\binnt\dbgport.sys to %WINDOWS%\system32\drivers.&nbsp; Once the file has been copied, run the %WATCOM%\binnt\dbginst.exe
program to install the device driver and activate it.&nbsp; You will need to have system administrator permissions in order
to be able to run the dbginst.exe program.&nbsp; Once these two steps are done, the parallel port debugger can work.&nbsp;
Note also that if you wish to do parallel port debuging on a target machine running Windows NT/2000/XP, you will need to follow
the same set of steps on the target machine as well.
<BR><BR>If you are going to debug a DOS extender application, then you must also specify a trap file to the server program.
&nbsp;The trap file must be specified before the port number.&nbsp; The following example shows how to debug a 32-bit DOS/4GW
application across a parallel cable plugged into printer port 2 on one machine and port 3 on the other.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; A&gt;parserv /tr=rsi 2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; B&gt;wd /tr=par;3 app</TT>
<BR><BR>The &quot;RSI&quot; trap file is specified for DOS/4G(W) applications.&nbsp; You can specify other trap files for
the other DOS extenders (e.g., &quot;CW&quot; for CauseWay).&nbsp; Do not forget to include other required files in the path.
<DL>
<DT>CW
<DD>Both &quot;CWSTUB.EXE&quot; and the loader help file &quot;CWHELP.EXE&quot; must also be located in one of the directories
listed in the DOS<B> PATH</B> environment variable.&nbsp; See the section entitled <A HREF="#Debugging_CauseWay_32Mbit_DOS_Extender_Applications">Debugging CauseWay 32-bit DOS Extender Applications</A>
for more information on debugging applications that use the CauseWay DOS extender.
<DT>RSI
<DD>Both &quot;DOS4GW.EXE&quot; and the loader help file &quot;RSIHELP.EXP&quot; must also be located in one of the directories
listed in the DOS<B> PATH</B> environment variable.&nbsp; See the section entitled <A HREF="#Debugging_DOSD4GLWR_32Mbit_DOS_Extender_Applications">Debugging DOS/4G(W) 32-bit DOS Extender Applications</A>
for more information on debugging applications that use the DOS/4GW DOS extender.
<DT>PLS
<DD>One or more of &quot;RUN386.EXE&quot; (or &quot;TNT.EXE&quot;), &quot;DBGLIB.REX&quot;, &quot;PLSHELP.EXP&quot;, and &quot;PEDHELP.EXP&quot;
must be located in one of the directories listed in the DOS<B> PATH</B> environment variable.&nbsp; See the section entitled
<A HREF="#Debugging_Phar_Lap_32Mbit_DOS_Extender_Applications">Debugging Phar Lap 32-bit DOS Extender Applications</A> for
more information on debugging applications that use the Phar Lap DOS extender.
</DL>
<H3 ID="SER_LSerialR"> SER (Serial) </H3>
<BR>This link communicates over the serial port.&nbsp; See the appendix entitled <A HREF="#Wiring_For_Remote_Debugging">Wiring For Remote Debugging</A>
for wiring details.&nbsp; The debugger and server will automatically synchronize on a communications speed.&nbsp; They may
communicate at rates as high as 115kB.&nbsp; The DOS and OS/2 &quot;mode&quot; command or the QNX &quot;stty&quot; commands
need not be used.
<BR><BR>The parameter to this link takes the form
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; port_number.baud_rate</TT>
<BR><BR><TT>port_number</TT> is a number from 1 to 3 indicating which serial port the cable is connected to.&nbsp; The default
is 1.
<BR><BR><TT>baud_rate</TT> is the maximum BAUD rate at which to communicate.&nbsp; If you already know the maximum BAUD rate
at which the two machines will communicate, this parameter will speed up the connection time by eliminating some of the synchronization
protocol.
<BR><BR><TT>baud_rate</TT> may be any of 115200, 57600, 38400, 19200, 9600, 4800, 2400, or 1200.&nbsp; It may be shortened
to the first 2 digits.
<BR><BR>A special BAUD rate of 0 is also allowed.&nbsp; This should be used if the serial port has been pre-assigned using
the &quot;mode&quot; or &quot;stty&quot; commands.&nbsp; The pre-assigned BAUD rate is used and the BAUD rate negotiation
is avoided.&nbsp; This will allow you to debug over a modem.
<BR><BR>The following example shows how to debug across a serial cable using default settings:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; A&gt;serserv</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; B&gt;wd /tr=ser app</TT>
<BR><BR>The following example shows how to debug across a serial cable using serial port 2 on each machine setting the maximum
BAUD rate to 9600:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; A&gt;serserv 2.9600</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; B&gt;wd /tr=ser;2.9600 app</TT>
<DL>
<DT>QNX 4 Note:
<DD>Under QNX 4, a node id may be specified followed by a comma if the serial port is not located on the current node.&nbsp; The
command &quot;serserv 3,1.9600&quot; would use the device //3/dev/ser1 at a BAUD rate of 9600.&nbsp; Alternatively, you can
specify a device such as /dev/foobar.&nbsp; To specify the maximum line speed, you can specify something like /dev/foobar.56.
&nbsp;Of course, you can also include a node id such as //5/dev/foobar.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; A&gt;serserv //3/dev/ser2.9600</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; B&gt;wd /tr=ser;//5/dev/ser2.9600 app</TT>
</DL>
<BR>If you are going to debug a DOS extender application, then you must also specify a trap file to the server program.&nbsp;
The trap file must be specified before the port number and BAUD rate.&nbsp; The following example shows how to debug a 32-bit
DOS/4GW application across a serial cable using serial port 1 on one machine and serial port 2 on the other machine setting
the maximum BAUD rate to 9600 for each:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; A&gt;serserv /tr=rsi 1.9600</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; B&gt;wd /tr=ser;2.9600 app</TT>
<BR><BR>The &quot;RSI&quot; trap file is specified for DOS/4G(W) applications.&nbsp; You can specify other trap files for
the other DOS extenders (e.g., &quot;CW&quot; for CauseWay).&nbsp; Do not forget to include other required files in the path.
<DL>
<DT>CW
<DD>Both &quot;CWSTUB.EXE&quot; and the loader help file &quot;CWHELP.EXE&quot; must also be located in one of the directories
listed in the DOS<B> PATH</B> environment variable.&nbsp; See the section entitled <A HREF="#Debugging_CauseWay_32Mbit_DOS_Extender_Applications">Debugging CauseWay 32-bit DOS Extender Applications</A>
for more information on debugging applications that use the CauseWay DOS extender.
<DT>RSI
<DD>Both &quot;DOS4GW.EXE&quot; and the loader help file &quot;RSIHELP.EXP&quot; must also be located in one of the directories
listed in the DOS<B> PATH</B> environment variable.&nbsp; See the section entitled <A HREF="#Debugging_DOSD4GLWR_32Mbit_DOS_Extender_Applications">Debugging DOS/4G(W) 32-bit DOS Extender Applications</A>
for more information on debugging applications that use the DOS/4GW DOS extender.
<DT>PLS
<DD>One or more of &quot;RUN386.EXE&quot; (or &quot;TNT.EXE&quot;), &quot;DBGLIB.REX&quot;, &quot;PLSHELP.EXP&quot;, and &quot;PEDHELP.EXP&quot;
must be located in one of the directories listed in the DOS<B> PATH</B> environment variable.&nbsp; See the section entitled
<A HREF="#Debugging_Phar_Lap_32Mbit_DOS_Extender_Applications">Debugging Phar Lap 32-bit DOS Extender Applications</A> for
more information on debugging applications that use the Phar Lap DOS extender.
</DL>
<H3 ID="WIN_LWindows_3_xD9x_Virtual_DOS_MachineR"> WIN (Windows 3.x/9x Virtual DOS Machine) </H3>
<BR>This link communicates between 2 Windows DOS boxes.&nbsp; In order to use this link, you must have Windows 3.x or Windows
95 installed on your machine.&nbsp; You must run Windows 3.x in enhanced mode.&nbsp; You must also include the &quot;device&quot;
specification listed below in the [386Enh] section of your &quot;SYSTEM.INI&quot; file (this line is usually added during
the Open Watcom software installation process).
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DEVICE=C:\WATCOM\BINW\WDEBUG.386</TT>
<BR><BR>In order for this link to work properly, you must ensure that this link runs in a DOS box that has background execution
enabled.
<BR><BR>The parameter to this link is an arbitrary name to be used for the connection.&nbsp; This allows you to have multiple
remote debug sessions active simultaneously.&nbsp; The default name is WinLink.&nbsp; The following examples show how to use
the default name or specify a link name using the Windows 3.x/95 VDM link.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; A&gt;winserv</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; B&gt;wd /tr=win app</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; A&gt;winserv whats_in_a_name</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; B&gt;wd /tr=win;whats_in_a_name app</TT>
<BR><BR>The following examples show how to debug a 32-bit extended DOS application using the Windows 3.x/95 VDM link.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; A&gt;winserv /tr=rsi</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; B&gt;wd /tr=win app</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; A&gt;winserv /tr=rsi whats_in_a_name</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; B&gt;wd /tr=win;whats_in_a_name app</TT>
<BR><BR>The &quot;RSI&quot; trap file is specified for DOS/4G(W) applications.&nbsp; You can specify other trap files for
the other DOS extenders (e.g., &quot;CW&quot; for CauseWay).&nbsp; Do not forget to include other required files in the path.
<DL>
<DT>CW
<DD>Both &quot;CWSTUB.EXE&quot; and the loader help file &quot;CWHELP.EXE&quot; must also be located in one of the directories
listed in the DOS<B> PATH</B> environment variable.&nbsp; See the section entitled <A HREF="#Debugging_CauseWay_32Mbit_DOS_Extender_Applications">Debugging CauseWay 32-bit DOS Extender Applications</A>
for more information on debugging applications that use the CauseWay DOS extender.
<DT>RSI
<DD>Both &quot;DOS4GW.EXE&quot; and the loader help file &quot;RSIHELP.EXP&quot; must also be located in one of the directories
listed in the DOS<B> PATH</B> environment variable.&nbsp; See the section entitled <A HREF="#Debugging_DOSD4GLWR_32Mbit_DOS_Extender_Applications">Debugging DOS/4G(W) 32-bit DOS Extender Applications</A>
for more information on debugging applications that use the DOS/4GW DOS extender.
<DT>PLS
<DD>One or more of &quot;RUN386.EXE&quot; (or &quot;TNT.EXE&quot;), &quot;DBGLIB.REX&quot;, &quot;PLSHELP.EXP&quot;, and &quot;PEDHELP.EXP&quot;
must be located in one of the directories listed in the DOS<B> PATH</B> environment variable.&nbsp; See the section entitled
<A HREF="#Debugging_Phar_Lap_32Mbit_DOS_Extender_Applications">Debugging Phar Lap 32-bit DOS Extender Applications</A> for
more information on debugging applications that use the Phar Lap DOS extender.
</DL>
<H3 ID="NMP_LNamed_PipesR"> NMP (Named Pipes) </H3>
<BR>The named pipes link allows you to communicate between any two sessions on an OS/2 machine.&nbsp; You can also debug remotely
between DOS, Windows 3.x and OS/2 machines if you have installed remote named pipe support on these machines.&nbsp; See your
network documentation for details on remote named pipes.
<BR><BR>In order to use named pipes, you must first run the NMPBIND program.&nbsp; This may run any OS/2 machine on the network.
&nbsp;It can be run detached, by putting the following line into your OS/2 CONFIG.SYS.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; RUN=C:\WATCOM\BINP\NMPBIND.EXE</TT>
<BR><BR>If you run NMPSERVW under Win-OS/2, it must be run as a seamless Windows session.&nbsp; This is due to the fact that
full screen Win-OS/2 sessions may not get any processor time when they are not in the foreground.
<BR><BR>The parameter to this link can take the following forms:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; name</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; name@machine</TT>
<BR><BR><TT>name</TT> is an arbitrary name to be used for the connection.&nbsp; This allows you to have multiple remote debug
sessions active simultaneously.&nbsp; The default name is NMPLink.
<BR><BR><TT>machine</TT> is the name of the machine on which the NMPBIND program is running.&nbsp; This allows you to use
remote named pipes.
<BR><BR>The following example shows you how to use the named pipe link between two sessions on the same OS/2 machine.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; A&gt;nmpserv</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; B&gt;wd /tr=nmp app</TT>
<BR><BR>The following example assumes that there is a machine named HAL with a remote named pipe server on the network which
is running NMPBIND.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; A&gt;nmpserv mylink@hal</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; B&gt;wd /tr=nmp;mylink@hal app</TT>
<H3 ID="VDM_LVirtual_DOS_MachineR"> VDM (Virtual DOS Machine) </H3>
<BR>VDM is actually a limited version of named pipes that does not require the NMPBIND program to be running.&nbsp; It has
several restrictions however.
<OL>
<LI>It does not support network debugging.
<LI>Under OS/2, the debugger (user interface) must run in an OS/2 (not a DOS) session.&nbsp; The debugger may also be started
under Windows NT but not Windows 95 since it does not support named pipes.
<LI>Under OS/2, the remote debug server must run in a seamless Win-OS/2 or a DOS session.
<LI>Under Windows NT, the remote debug server will be run in a Windows NT Virtual DOS Machine.
<LI>Under Windows 95, the remote debug server can be started but since Windows 95 does not support named pipes it will not
work properly.&nbsp; See the section entitled <A HREF="#WIN_LWindows_3_xD9x_Virtual_DOS_MachineR">WIN (Windows 3.x/9x Virtual DOS Machine)</A>
for an alternative.
<LI>If you are running VDMSERVW under Win-OS/2, it must be run as a seamless Windows session.&nbsp; This is due to the fact
that full screen Win-OS/2 sessions may not get any processor time when they are not in the foreground.
</OL>
<BR>The parameter to this link is an arbitrary name to be used for the connection.&nbsp; This allows you to have multiple
VDM debug sessions active simultaneously.&nbsp; The default name is VDMLink.&nbsp; The following example shows how to use
the VDM link:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; A&gt;vdmserv</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; B&gt;wd /tr=vdm app</TT>
<BR><BR>The following example shows how to use the VDM link specifying &quot;brian&quot; as the link name.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; A&gt;vdmserv brian</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; B&gt;wd /tr=vdm;brian app</TT>
<H3 ID="TCPDIP_LInternet_PacketsR"> TCP/IP (Internet Packets) </H3>
<BR>The TCP/IP link allows you to communicate between any two sessions using TCP/IP if you have installed TCP/IP support.
&nbsp;You can also debug remotely between OS/2 and Windows NT/95 machines if you have installed TCP/IP support on these machines.
&nbsp;See your network documentation for details on installing TCP/IP support.&nbsp; To use TCP/IP support under DOS, you
need to configure the WATTCP client and install a packet driver for your network card.
<BR><BR>In order to use TCP/IP to remotely debug a program, you must start the TCPSERV server program first.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; A&gt;tcpserv</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Socket port number: 3563</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom TCP/IP Debug Server Version 2.0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;cpyrit 1988</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Press 'q' to exit</TT>
<BR><BR>The server program displays an available socket port number on the screen.
<BR><BR>You may specify a TCP/IP &quot;service&quot; as an argument on the command line.&nbsp; TCPSERV will check the TCP/IP
services list to find a matching service.&nbsp; If no argument is specified on the command line, TCPSERV uses &quot;tcplink&quot;
as the service name.&nbsp; If no matching service name is found, TCPSERV attempts to convert the argument to a numeric port
number and use that.&nbsp; If the argument can not be converted to a number, port number 3563 is used.
<BR><BR>The TCP/IP services list is stored in different places depending on the operating system.
<DL>
<DT>OS/2
<DD><TT> d:\TCPIP\ETC\SERVICES</TT> depending on the drive where TCP/IP is installed
<DT>Linux and QNX
<DD><TT> /etc/services</TT>
<DT>Windows 9x
<DD><TT> d:\windows\SERVICES</TT> depending on the drive and directory where Windows 95 is installed
<DT>Windows NT
<DD><TT> d:\WINNT\SYSTEM32\DRIVERS\ETC\SERVICES</TT> depending on the drive where Windows NT is installed
</DL>
<BR>You will also need to know the Internet Protocol (IP) address of the machine running the TCPSERV program.&nbsp; This can
be in alphanumeric or numeric form (e.g., jdoe.watcom.on.ca or 172.31.0.99).&nbsp; With the alphanumeric form, it is not necessary
to specify the domain name portion if the two machines are in the same domain.
<BR><BR>To use the remote TCP/IP server, you must specify the TCP/IP trap file name to the debugger along with an argument
consisting of your IP address, optionally followed by a &quot;:&quot; and the service name or socket port number used by TCPSERV.
&nbsp;You must also include the name of the application you wish to run and debug on the remote machine.
<BR><BR><B>Example1:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; A&gt;tcpserv</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; B&gt;wd /tr=tcp;jdoe app</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; B&gt;wd /tr=tcp;172.31.0.99 app</TT>
<BR><BR><B>Example2:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; A&gt;tcpserv 1024</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; B&gt;wd /tr=tcp;jdoe:1024 app</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; B&gt;wd /tr=tcp;jdoe.watcom.on.ca:1024 app</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; B&gt;wd /tr=tcp;172.31.0.99:1024 app</TT>
<BR><BR><B>Example3:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; A&gt;tcpserv dbgservice</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; B&gt;wd /tr=tcp;jdoe:dbgservice app</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; B&gt;wd /tr=tcp;jdoe.watcom.on.ca:dbgservice app</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; B&gt;wd /tr=tcp;172.31.0.99:dbgservice app</TT>
<BR><BR>The TCP/IP remote debug service permits debugging of applications anywhere on the Internet.&nbsp; However, response
will vary with the distances involved.
<H2 ID="Specifying_Files_on_Remote_and_Local_Machines"> Specifying Files on Remote and Local Machines </H2>
<BR>In order to identify files on either the local or remote machine, two special prefixes are supported.
<DL>
<DT>@L
<DD>The &quot;@L&quot; prefix is used to indicate that the file resides on the local machine (the one on which the debugger is
running).
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; @L[d:][path]filename[.ext]</TT>
<BR><BR>When &quot;[path]&quot; is not specified, the current directory of the specified drive of the local machine is assumed.
&nbsp;When &quot;[d:]&quot; is not specified, the current drive of the local machine is assumed.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; @LOUTPUT.LOG</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; @LD:\CMDS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; @LD:\CMDS\DATA.TMP</TT>
<DT>@R
<DD>The &quot;@R&quot; prefix is used to indicate that the file resides on the remote machine.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; @R[d:][path]filename[.ext]</TT>
<BR><BR>When &quot;[path]&quot; is not specified, the current directory of the specified drive of the remote machine is assumed.
&nbsp;When &quot;[d:]&quot; is not specified, the current drive of the remote machine is assumed.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; @RMYAPPL.DAT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; @RD:\PROGRAMS\EXE\MYAPPL.LNK</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; @R\PROGRAMS\SRC</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; @R\PROGRAMS\SRC\UILIB.C</TT>
</DL>
<BR>Thus a file may be identified in three different ways.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [d:][path]filename[.ext]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; @L[d:][path]filename[.ext]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; @R[d:][path]filename[.ext]</TT>
<BR><BR>A file of the first form resides on either the local or remote machine depending on whether the current drive is a
local or remote drive.&nbsp; A file of the second form always resides on the local machine.&nbsp; A file of the third form
always resides on the remote machine.
<BR><BR><B>Notes:</B>
<OL>
<LI>In the each form, the omission of &quot;[d:]&quot; indicates the current drive.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [path]filename[.ext]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; @L[path]filename[.ext]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; @R[path]filename[.ext]</TT>
<LI>In the each form, the omission of &quot;[path]&quot; indicates the current path of the specified drive.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [d:]filename[.ext]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; @L[d:]filename[.ext]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; @R[d:]filename[.ext]</TT>
<BR><BR>Observe that if &quot;[d:]&quot; is omitted also then the following forms are obtained:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; filename[.ext]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; @Lfilename[.ext]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; @Rfilename[.ext]</TT>
<LI>The special drive prefixes &quot;@L&quot; and &quot;@R&quot; cannot be used in your own application to reference files
on two different machines.&nbsp; These prefixes are recognized by the Open Watcom Debugger only.&nbsp; Should the situation
arise where one of your filenames begins with the same prefix (&quot;@L&quot;, &quot;@l&quot;, &quot;@R&quot; or &quot;@r&quot;)
then &quot;@@&quot; can be used.&nbsp; For example, if your wish to refer to the file on disk called &quot;@link@&quot; then
you could specify &quot;@@link@&quot;.&nbsp; Note that &quot;.\@link@&quot; would also suffice.
</OL>
<H1 ID="Interrupting_a_Running_Program"> Interrupting a Running Program </H1>
<BR>It is not unusual for your code to contain an endless loop that results in the program getting stuck in one spot.&nbsp;
You then want to interrupt the program so that you can see where it's getting stuck.&nbsp; The process to give control back
to the debugger is different for each operating system.
<H2 ID="DOS"> DOS </H2>
<BR>Press the Print Screen key.&nbsp; This will work if the program is stuck in a loop.&nbsp; If it has misbehaved in some
other way, Print Screen may have no effect since a misbehaved application may overwrite code, data, the debugger, or operating
system code.&nbsp; 
<BR><BR>When debugging with the CauseWay DOS extender, by default the running program can be interrupted by pressing CTRL-ALT.
&nbsp;The key combination is configurable in the CWHELP.CFG file (located in &quot;BINW&quot; directory).
<H2 ID="Windows_3_x"> Windows 3.x </H2>
<BR>Press CTRL-ALT-F.&nbsp; Windows must be running in enhanced mode and the device WDEBUG.386 must be installed the [386Enh]
section of SYSTEM.INI for this to work.&nbsp; You cannot interrupt a running program under Win-OS/2.
<H2 ID="Windows_NT__Windows_95"> Windows NT, Windows 95 </H2>
<BR>If you are using the non-GUI version of the debugger, switch focus to the debugger screen and press CTRL-BREAK.
<BR><BR>If you are using the GUI-based version of the debugger or one of the remote debug servers, switch focus to the debugger
or debug server screen and click anywhere.&nbsp; When you switch to the debugger screen, you will see a pop-up stating that:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; The debugger cannot be used while the application is</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; running.&nbsp; Do you want to interrupt the application?</TT>
<BR><BR>If you select &quot;Yes&quot;, the debugger will attempt to interrupt the application.&nbsp; If you select &quot;No&quot;,
the debugger will resume waiting for the application to hit a breakpoint or terminate.
<BR><BR>If you select &quot;Yes&quot; and the debugger cannot interrupt the application, you can click on the debugger again
and it will display a pop-up asking:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; The debugger could not sucessfully interrupt your</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; application.&nbsp; Do you want to terminate the application?</TT>
<BR><BR>If you select &quot;Yes&quot;, the debugger will terminate your application.&nbsp; If you select &quot;No&quot;, the
debugger will resume waiting for the program to hit a breakpoint or terminate.
<DL>
<DT>Note:
<DD>Under Windows 95, it is very difficult to interrupt a program that is in an infinite loop or spending most of its time in
system API's.&nbsp; Under Windows 95, you can only interrupt a program that is responding to messages (or looping in its own
thread code).&nbsp; If your program is an infinite loop, interrupting the program will likely fail.&nbsp; The only option
in this case is to terminate the program.
<BR><BR>This is not an issue under Windows NT which has a superior debug API.
</DL>
<BR>If you press CTRL-BREAK when the application has focus, you will terminate the application being debugged rather than
interrupting it.
<H2 ID="OSD2"> OS/2 </H2>
<BR>Use the program manager to switch focus to the debugger screen then press CTRL-BREAK.&nbsp; If you press CTRL-BREAK when
the application has focus, you will terminate the application being debugged rather than interrupting it.
<H2 ID="NetWare"> NetWare </H2>
<BR>On the NetWare file server console, press ALT-ESCAPE while holding down both SHIFT keys.&nbsp; In some instances, this
may cause the system debugger to become active instead of the Open Watcom Debugger.
<H2 ID="Linux"> Linux </H2>
<BR>Switch focus to the debugger console and press CTRL-C.&nbsp; Alternatively, you may send any unhandled signal to the application
being debugged.&nbsp; Consult your Linux documentation for details.
<H2 ID="QNX"> QNX </H2>
<BR>Switch focus to the debugger console and press CTRL-BREAK.&nbsp; Alternatively, you may send any unhandled signal to the
application being debugged.&nbsp; Consult your QNX system documentation for details.
<H1 ID="Operating_System_Specifics"> Operating System Specifics </H1>
<BR>This section discusses the following topics:
<DL>
<DT>DOS Extender debugging
<DD>See the section entitled <A HREF="#Debugging_32Mbit_DOS_Extender_Applications">Debugging 32-bit DOS Extender Applications</A>.
<DT>NLM debugging
<DD>See the section entitled <A HREF="#Debugging_a_Novell_NLM">Debugging a Novell NLM</A>.
<DT>Graphics programs
<DD>See the section entitled <A HREF="#Debugging_Graphics_Applications">Debugging Graphics Applications</A>.
<DT>Windows 3.x debugging
<DD>See the section entitled <A HREF="#Debugging_Windows_3_x_Applications">Debugging Windows 3.x Applications</A>.
<DT>DLL debugging
<DD>See the section entitled <A HREF="#Debugging_Dynamic_Link_Libraries">Debugging Dynamic Link Libraries</A>.
<DT>Disabling 386/486 debug registers
<DD>See the section entitled <A HREF="#Disabling_Use_of_386D486_Debug_Registers">Disabling Use of 386/486 Debug Registers</A>.
<DT>Linux debugging
<DD>See the section entitled <A HREF="#Debugging_Under_Linux">Debugging Under Linux</A>.
<DT>QNX debugging
<DD>See the section entitled <A HREF="#Debugging_Under_QNX">Debugging Under QNX</A>.
</DL>
<H2 ID="Debugging_32Mbit_DOS_Extender_Applications"> Debugging 32-bit DOS Extender Applications </H2>
<BR>The Open Watcom Debugger supports debugging of 32-bit applications developed with Open Watcom C/C++(32), Open Watcom FORTRAN
77/32, and assembly language.&nbsp; A DOS extender must be used to run the application.&nbsp; The following DOS extenders
are supported.
<DL>
<DT>CauseWay DOS Extender
<DD>a public domain DOS extender included in the Open Watcom C/C++(32) and Open Watcom FORTRAN 77/32 packages.&nbsp; Note that
this DOS extender is largely compatible with DOS/4GW and can often be used interchangeably.
<DT>DOS/4GW
<DD>a DOS extender from Tenberry Software, Inc.&nbsp; DOS/4GW is a subset of Tenberry Software's DOS/4G product.&nbsp; DOS/4GW
is customized for use with Open Watcom C/C++(32) and Open Watcom FORTRAN 77/32 and is included in these packages.
<DT>386|DOS-Extender
<DD>(version 2.2d or later) a DOS extender from Phar Lap Software, Inc.
</DL>
<H3 ID="Debugging_CauseWay_32Mbit_DOS_Extender_Applications"> Debugging CauseWay 32-bit DOS Extender Applications </H3>
<BR>When using the CauseWay DOS extender, the &quot;CWSTUB.EXE&quot; file must be located in one of the directories listed
in the DOS<B> PATH</B> environment variable.&nbsp; The &quot;CWSTUB.EXE&quot; file will usually be stored in the &quot;BINW&quot;
directory of the Open Watcom compiler package.&nbsp; You must also use the<B> TRap=CW</B> option.&nbsp; The &quot;CW.TRP&quot;
file will usually be stored in the &quot;BINW&quot; directory of the Open Watcom compiler package.&nbsp; You should ensure
that this &quot;BINW&quot; directory is included in the DOS<B> PATH</B> environment variable.&nbsp; Otherwise, you must specify
the full path name for the trap file.
<BR><BR>The help file &quot;CWHELP.EXE&quot; must also be located in one of the directories listed in the DOS<B> PATH</B>
environment variable.&nbsp; It will usually be stored in the &quot;BINW&quot; directory of the Open Watcom compiler package.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wd /trap=cw hello</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set wd=/trap#cw</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wd hello</TT>
<H3 ID="Debugging_DOSD4GLWR_32Mbit_DOS_Extender_Applications"> Debugging DOS/4G(W) 32-bit DOS Extender Applications </H3>
<BR>When using the Tenberry Software DOS extender, the &quot;DOS4GW.EXE&quot; or &quot;DOS4G.EXE&quot; file must be located
in one of the directories listed in the DOS<B> PATH</B> environment variable.&nbsp; The &quot;DOS4GW.EXE&quot; file will usually
be stored in the &quot;BINW&quot; directory of the Open Watcom compiler package.&nbsp; You must also use the<B> TRap=RSI</B>
option.&nbsp; The &quot;RSI.TRP&quot; file will usually be stored in the &quot;BINW&quot; directory of the Open Watcom compiler
package.&nbsp; You should ensure that this &quot;BINW&quot; directory is included in the DOS<B> PATH</B> environment variable.
&nbsp;Otherwise, you must specify the full path name for the trap file.
<BR><BR>The help file &quot;RSIHELP.EXP&quot; must also be located in one of the directories listed in the DOS<B> PATH</B>
environment variable.&nbsp; It will usually be stored in the &quot;BINW&quot; directory of the Open Watcom compiler package.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wd /trap=rsi hello</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set wd=/trap#rsi</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wd hello</TT>
<H3 ID="Debugging_Phar_Lap_32Mbit_DOS_Extender_Applications"> Debugging Phar Lap 32-bit DOS Extender Applications </H3>
<BR>When using the Phar Lap Software, Inc.&nbsp; DOS extender, the &quot;RUN386.EXE&quot; (or &quot;TNT.EXE&quot;), &quot;DBGLIB.REX&quot;,
&quot;PLSHELP.EXP&quot;, and &quot;PEDHELP.EXP&quot; files must be located in one of the directories listed in the DOS<B>
PATH</B> environment variable.&nbsp; You must also use the<B> TRap=PLS</B> option.&nbsp; The &quot;PLS.TRP&quot;, &quot;PLSHELP.EXP&quot;
and &quot;PEDHELP.EXP&quot; files will usually be stored in the &quot;BINW&quot; directory of the Open Watcom compiler package.
&nbsp;You should ensure that this &quot;BINW&quot; directory is included in the DOS<B> PATH</B> environment variable.&nbsp;
Otherwise, you must specify the full path name for the trap file.
<BR><BR>Parameters are passed to the &quot;RUN386&quot; or &quot;TNT&quot; DOS extender using the<B> TRap</B> option.&nbsp;
The entire parameter must be placed within braces.&nbsp; The following example illustrates how to debug a Phar Lap application
passing the -maxreal switch to RUN386.EXE or TNT.EXE.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wd /trap=pls;{-maxreal 512} hello</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set wd=/trap#pls;{-maxreal 512}</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wd hello</TT>
<H2 ID="Debugging_a_Novell_NLM"> Debugging a Novell NLM </H2>
<BR>Novell NLM's may only be debugged remotely.&nbsp; You must use either the serial, parallel, or Novell SPX link.&nbsp;
There are 5 NLM's distributed in the Open Watcom package.&nbsp; The following table describes their use:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;NetWare 3.11/3.12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NetWare 4.01</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Serial&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; serserv4.nlm</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Parallel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parserv3.nlm&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parserv4.nlm</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SPX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; novserv3.nlm
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; novserv4.nlm</TT>
<BR><BR>To start remote debugging, you load one of the above NLMs at the NetWare file server console.&nbsp; The debugger is
then invoked as in any remote debugging session.&nbsp; See the chapter entitled <A HREF="#Remote_Debugging">Remote Debugging</A>
for parameter details.&nbsp; See the appendix entitled <A HREF="#Wiring_For_Remote_Debugging">Wiring For Remote Debugging</A>
for parallel/serial cable details.
<BR><BR>For example, on a NetWare 4.01 server type:<TT>&nbsp; load novserv4</TT>
<BR><BR>On a workstation, type:<TT> WD /tr=nov mynlm</TT>
<BR><BR>Debugging information for every running NLM is available.&nbsp; You can debug any NLM in the system as if it were
part of your application, as long as you created it with debug information.&nbsp; If the NLM does not have Watcom style debugging
information, the debugger will attempt to use any debugging information created by Novell's linker (NLMLINK).
<H2 ID="Debugging_Graphics_Applications"> Debugging Graphics Applications </H2>
<BR>When debugging a graphics application, there are a number of Open Watcom Debugger command line options that could be specified
depending on your situation.
<OL>
<LI>If you only have one monitor attached to your system, use the<B> Swap</B> option.&nbsp; The<B> Swap</B> option specifies
that the application's screen memory and the debugger's screen memory are to be swapped back and forth using a single page.
<LI>If you have two monitors attached to your system then the<B> Two</B> and<B> Monochrome</B> options should be used.&nbsp;
The<B> Two</B> option specifies that a second monitor is connected to the system.&nbsp; Note that if the monitor type (<B>
Monochrome, Color, Colour, Ega43, Vga50</B>) is not specified then the monitor that is not currently being used is selected
for the debugger's screen.&nbsp; If you specify<B> Monochrome</B> then the monochrome monitor will be used for the debugger's
screen.
<LI>If you are debugging the graphics application using a second personal computer and the remote debugging feature of the
Open Watcom Debugger then the choice of display and operation mode for the Open Watcom Debugger is irrelevant.&nbsp; If one
system is equipped with a graphics display and the other with a monochrome display then you will undoubtedly use the system
equipped with the monochrome display to run the Open Watcom Debugger.
</OL>
<H2 ID="Debugging_Windows_3_x_Applications"> Debugging Windows 3.x Applications </H2>
<BR>Both a character mode and a GUI debugger are supplied that run in the Windows environment.&nbsp; You must choose which
of these debuggers you are going to use.&nbsp; They both have advantages and disadvantages.&nbsp; When your application is
suspended, the GUI and character mode debuggers behave differently.&nbsp; The GUI debugger allows other applications to continue
running.&nbsp; The character mode debugger does not.&nbsp; Although the GUI debugger has a much nicer looking user interface,
you should not use it under some circumstances.&nbsp; You can always use the character mode debugger.&nbsp; You should be
aware of the following restrictions:
<OL>
<LI>If you are trying to debug an applications that uses DDE you should<B><I> not</I></B> use the GUI debugger.
<LI>Do<B><I> not</I></B> try to use the GUI debugger to debug system modal dialogs.
<LI>If you hit a break-point in a dialog callback procedure or in your window procedure when it is receiving certain events
(e.g., WM_MENUSELECT), the GUI debugger will lock input to itself.&nbsp; When this happens, you will not be able to switch
away from the debugger, and no other application will repaint themselves.&nbsp; When this happens, pop-up menus will not draw
correctly and you will have to use the<B><I> Action</I></B> menu instead.&nbsp; You should not try to quit the debugger when
it is in this state.
<LI>Do<B><I> not</I></B> try to use either of the Windows debuggers in a seamless Win-OS/2 session.
</OL>
<BR>If you find that the Windows debugger starts too slowly, try using the<B> DIp=DWARF</B> option.&nbsp; This prevents the
debugger from searching each DLL in the system for debugging information.&nbsp; It will start up faster, but you will not
be able to see the name of the Windows API calls.
<BR><BR>To start the Open Watcom Debugger, select the program group in which you have installed the Open Watcom Debugger.
&nbsp;One of the icons presented is used to start the debugger.&nbsp; Double-click on the Open Watcom Debugger icon.
<BR><BR>You can make special versions of the Open Watcom Debugger icon using<B><I> Properties</I></B> from the<B><I> File</I></B>
menu of the Windows &quot;Program Manager&quot;.&nbsp; For example, you can add any options you wish to the &quot;Command
Line&quot; field of the &quot;Properties&quot; window.&nbsp; When you click on the newly created icon, the options specified
in the &quot;Command Line&quot; field are the defaults.&nbsp; As long as no executable file name was specified in the &quot;Command
Line&quot; field, the Open Watcom Debugger will present its prompt window.&nbsp; In the prompt window, you can specify an
executable file name and arguments.
<BR><BR>If you are debugging the same program over and over again, you might wish to create an icon that includes the name
of the file you wish to debug in the &quot;Command Line&quot; field.&nbsp; Each time you click on that icon, the Open Watcom
Debugger is started and it automatically loads the program you wish to debug.
<H2 ID="Debugging_Dynamic_Link_Libraries"> Debugging Dynamic Link Libraries </H2>
<BR>The debugger automatically detects all DLLs that your application references when it loads the application.&nbsp; When
your program loads a DLL dynamically, the debugger detects this as well.&nbsp; If you have created your DLL with debugging
information, you can debug it just as if it were part of your application.&nbsp; Even if it does not have debugging information,
the debugger will process system information to make the DLL entry point names visible.&nbsp; There are a few limitations:
<OL>
<LI>You cannot debug your DLL initialization code.&nbsp; This is the first routine that the operating system runs when it
loads the DLL.&nbsp; This is not normally a problem, since most DLLs do not do much in the way of initialization.
<LI>When a DLL is loaded dynamically, its debugging information may not be available immediately.&nbsp; Try tracing a few
instructions and it will appear.
<LI>If you restart an application, you will lose any break points that you had set in dynamically loaded DLLs.&nbsp; You need
to trace back over the call to LoadModule or DOSLoadModule and re-set these break points.
</OL>
<H2 ID="Disabling_Use_of_386D486_Debug_Registers"> Disabling Use of 386/486 Debug Registers </H2>
<BR>It may be necessary to prevent the Open Watcom Debugger from using the 386/486 Debug Registers (a hardware feature used
to assist debugging).&nbsp; This situation arises with certain DOS control programs that do not properly manage Debug Registers.
&nbsp;If the Open Watcom Debugger fails upon startup on a 386/486 system, it is a good indication that use of the Debug Registers
must be disabled.&nbsp; With &quot;STD.TRP&quot;, the trap file parameter &quot;d&quot; may be specified to disable the use
of Debug Registers.&nbsp; The following example illustrates the specification of the &quot;d&quot; trap file parameter.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wd /trap=std;d calendar</TT>
<H2 ID="Debugging_Under_Linux"> Debugging Under Linux </H2>
<BR>When the debugger starts up, it will attempt to open the initialization file<TT> .wdrc</TT> provided that you have not
specified the<B> Invoke</B> command line option.&nbsp; It looks for this file in all the usual places (<B> CWD,</B> <B> WD_PATH,</B>
<TT> /opt/watcom/wd</TT>).&nbsp; This file normally contains your customization commands.&nbsp; If it is found, it is processed
as the default configuration file.&nbsp; You would normally place this file in your home directory.
<BR><BR>If the file does not exist, the debugger then looks for the<TT> wd.dbg</TT> file.
<BR><BR>If you do not want the debugger to use the<TT> .wdrc</TT> file then you can do one of two things - make sure that
it cannot be located (e.g., delete it) or use the<B> Invoke</B> command line option (you could specify the<TT> wd.dbg</TT>
file as the target).
<BR><BR>The supplied version of the<TT> wd.dbg</TT> file contains an &quot;invoke&quot; command referencing the file<TT> setup.dbg.</TT>
&nbsp;This file, in turn, contains a &quot;configfile&quot; command and &quot;invoke&quot; commands referencing other command
files.&nbsp; The &quot;configfile&quot; command marks<TT> setup.dbg</TT> as the default file name to use when the debugger
writes out the current configuration.
<BR><BR>The following section entitled <A HREF="#Search_Order_for_Open_Watcom_Debugger_Support_Files_under_Linux">Search Order for Open Watcom Debugger Support Files under Linux</A>
describes the search order for debugger files under Linux.
<H3 ID="Search_Order_for_Open_Watcom_Debugger_Support_Files_under_Linux"> Search Order for Open Watcom Debugger Support Files under Linux </H3>
<BR>There are several supporting files provided with the Open Watcom Debugger.&nbsp; These files fall into five categories.
&nbsp;
<OL>
<LI>Open Watcom Debugger command files (files with the &quot;.dbg&quot; suffix).
<LI>Open Watcom Debugger trap files (files with the &quot;.trp&quot; suffix).
<LI>Open Watcom Debugger parser files (files with the &quot;.prs&quot; suffix).
<LI>Open Watcom Debugger help files (files with the &quot;.hlp&quot; suffix).
<LI>Open Watcom Debugger symbolic debugging information files (files with the &quot;.sym&quot; suffix).
</OL>
<BR>The search order for Open Watcom Debugger support files is as follows:
<OL>
<LI>the current directory,
<LI>the paths listed in the<B> WD_PATH</B> environment variable,
<LI>the path listed in the<B> HOME</B> environment variable
<LI>the directory where Open Watcom Debugger was started from
<LI>&quot;../wd&quot; directory relative to the directory where Open Watcom Debugger was started from, and, finally,
<LI>the &quot;/opt/watcom/wd&quot; directory.
</OL>
<BR>You should note the following when using the remote debugging feature of the Open Watcom Debugger.&nbsp; When the<B> REMotefiles</B>
option is specified, the debugger also attempts to locate the Open Watcom Debugger's support files (command files, trap files,
etc.) on the task machine.
<H2 ID="Debugging_Under_QNX"> Debugging Under QNX </H2>
<BR>When the debugger starts up, it will attempt to open the initialization file<TT> .wdrc</TT> provided that you have not
specified the<B> Invoke</B> command line option.&nbsp; It looks for this file in all the usual places (<B> CWD,</B> <B> WD_PATH,</B>
<TT> /usr/watcom/&lt;ver&gt;/wd, /usr/watcom/wd</TT>).&nbsp; This file normally contains your customization commands.&nbsp;
If it is found, it is processed as the default configuration file.&nbsp; You would normally place this file in your home directory.
<BR><BR>If the file does not exist, the debugger then looks for the<TT> wd.dbg</TT> file.
<BR><BR>If you do not want the debugger to use the<TT> .wdrc</TT> file then you can do one of two things - make sure that
it cannot be located (e.g., delete it) or use the<B> Invoke</B> command line option (you could specify the<TT> wd.dbg</TT>
file as the target).
<BR><BR>The supplied version of the<TT> wd.dbg</TT> file contains an &quot;invoke&quot; command referencing the file<TT> setup.dbg.</TT>
&nbsp;This file, in turn, contains a &quot;configfile&quot; command and &quot;invoke&quot; commands referencing other command
files.&nbsp; The &quot;configfile&quot; command marks<TT> setup.dbg</TT> as the default file name to use when the debugger
writes out the current configuration.
<BR><BR>The following section entitled <A HREF="#Debugging_Under_QNX_Using_the_Postmortem_Dump_Facility">Debugging Under QNX Using the Postmortem Dump Facility</A>
describes the use of the debugger with the Postmortem dump facility.&nbsp; The following section entitled <A HREF="#Search_Order_for_Open_Watcom_Debugger_Support_Files_under_QNX">Search Order for Open Watcom Debugger Support Files under QNX</A>
describes the search order for debugger files under QNX.
<H3 ID="Debugging_Under_QNX_Using_the_Postmortem_Dump_Facility"> Debugging Under QNX Using the Postmortem Dump Facility </H3>
<BR>A limited form of debugging of an application that has terminated and produced a postmortem dump can be done under QNX.
&nbsp;In order to use this feature, you must start the QNX &quot;dumper&quot; program.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; dumper [-d path] [-p pid] &amp;</TT>
<DL>
<DT>dumper
<DD>is the program name for the QNX postmortem dump program.
<DT>-d path
<DD>The name of the directory in which postmortem dumps are written.&nbsp; If not specified, the default is the user's home directory.
<DT>-p pid
<DD>Save a dump file for this process if it terminates for any reason.&nbsp; Do not save a dump file for any other process.
<DT>&amp;
<DD>must be specified so that the shell is rejoined.
</DL>
<BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; $ dumper &amp;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; $ dumper -d /usr/fred/dump_area &amp;</TT>
<BR><BR>Whenever a program terminates abnormally, a dump of the current state of the program in memory is written to disk.
&nbsp;The dump file name is the same as the program name with a<B> .dmp</B> extension.&nbsp; For example, if the program name
is<B> a.out</B> then the dump will be written to the<B> /home/userid/a.out.dmp</B> file.
<BR><BR>You can use the<B> -d</B> option of the dumper program to force all dumps into a single directory rather than into
the invoking user's home directory.
<BR><BR>The<B> -p</B> option lets you monitor a particular process.&nbsp; You can run multiple copies of the dumper program,
each monitoring a different process.
<BR><BR>If the Open Watcom Debugger was being used to debug the program at the time that it abnormally terminated then the
dump is written to the user's home directory provided that the<B> -d</B> option was not used.
<BR><BR>To examine the contents of the postmortem dump, the Open Watcom Debugger may be used.&nbsp; The interface between
the Open Watcom Debugger and the postmortem dump is contained in a special &quot;trap&quot; file.&nbsp; The trap file is specified
to the Open Watcom Debugger using the<B> TRap</B> option.&nbsp; 
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; wd -TRap=pmd[;i] [:sym_file] file_spec</TT>
<DL>
<DT>wd
<DD>is the program name for the Open Watcom Debugger.
<DT>-TRap=pmd[
<DD>i] must be specified when debugging an application that has terminated and produced a postmortem dump.&nbsp; The optional
&quot;;i&quot; is specified when the modification date of the original program file does not match the information contained
in the dumper file.&nbsp; It indicates that the symbolic debugging information in the program file may be out-of-date.&nbsp;
It instructs the Open Watcom Debugger to ignore the date mismatch.&nbsp; Depending on the shell that you are using, it may
be necessary to place the option specification in quotation marks if you include the optional &quot;;i&quot;.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; $ wd &quot;-trap=pmd;i&quot; myapp</TT>
<DT>sym_file
<DD>is an optional symbolic information file specification.&nbsp; The specification must be preceded by a colon (&quot;:&quot;).
&nbsp;When specifying a symbol file name, a path such as &quot;//5/etc/&quot; may be included.&nbsp; For QNX, the default
file suffix of the symbol file is &quot;.sym&quot;.
<DT>file_spec
<DD>is the file name of the dumper file to be loaded into memory.&nbsp; When specifying a file name, a path such as &quot;//5/etc/&quot;
may be included.&nbsp; If a path is omitted, the Open Watcom Debugger will first attempt to locate the file in the current
directory and, if not successful, attempt to locate the file in the default dumper directory:<B>&nbsp; /usr/dumps</B>.
</DL>
<BR>Basically, the Open Watcom Debugger is fully functional when a postmortem dump is examined.&nbsp; However, there are some
operations which are not allowed.&nbsp; Among these are:
<OL>
<LI>Task execution cannot be restarted using<B><I> Go</I></B> from the<B><I> Run</I></B> menu.
<LI>A register can be modified for the purposes of expression evaluation.&nbsp; You can choose<B><I> Go</I></B> from the<B><I>
Run</I></B> menu to restore the register contents to their original postmortem state.
<LI>Memory cannot be modified.
<LI>Memory outside of regions owned by the program cannot always be examined.
<LI>I/O ports cannot be examined.
</OL>
<H3 ID="Search_Order_for_Open_Watcom_Debugger_Support_Files_under_QNX"> Search Order for Open Watcom Debugger Support Files under QNX </H3>
<BR>There are several supporting files provided with the Open Watcom Debugger.&nbsp; These files fall into five categories.
&nbsp;
<OL>
<LI>Open Watcom Debugger command files (files with the &quot;.dbg&quot; suffix).
<LI>Open Watcom Debugger trap files (files with the &quot;.trp&quot; suffix).
<LI>Open Watcom Debugger parser files (files with the &quot;.prs&quot; suffix).
<LI>Open Watcom Debugger help files (files with the &quot;.hlp&quot; suffix).
<LI>Open Watcom Debugger symbolic debugging information files (files with the &quot;.sym&quot; suffix).
</OL>
<BR>The search order for Open Watcom Debugger support files is as follows:
<OL>
<LI>the current directory,
<LI>the paths listed in the<B> WD_PATH</B> environment variable,
<LI>the path listed in the<B> HOME</B> environment variable, and, finally,
<LI>the &quot;/usr/watcom/wd&quot; directory.
</OL>
<BR>You should note the following when using the remote debugging feature of the Open Watcom Debugger.&nbsp; When the<B> REMotefiles</B>
option is specified, the debugger also attempts to locate the Open Watcom Debugger's support files (command files, trap files,
etc.) on the task machine.
<H1 ID="Open_Watcom_Debugger_Expression_Handling"> Open Watcom Debugger Expression Handling </H1>
<BR><BR>The Open Watcom Debugger is capable of handling a wide variety of expressions.&nbsp; An expression is a combination
of operators and operands selected from application variables and names, debugger variables, and constants.&nbsp; Expressions
can be used in a large number of debugger commands and dialogs.&nbsp; For example, the evaluated result of an expression may
be displayed by choosing<B><I> New</I></B> from the pop-up menu in the Watches window or by using the print command.
<BR><BR>The appropriate syntax of an expression, i.e., the valid sequence of operators and operands, depends on the grammar
of the language that is currently established.&nbsp; The Open Watcom Debugger supports the grammars of the C, C++, and FORTRAN
77 languages.&nbsp; A grammar is selected automatically by the debugger when tracing the execution of modules in an application.
&nbsp;For example, part of an application may be written in C, another part in C++, and another part in FORTRAN 77.&nbsp;
The modules must have been compiled by one of the Open Watcom C, C++ or FORTRAN 77 compilers.&nbsp; When tracing into a module
written in one of these languages, the debugger will automatically select the appropriate grammar.&nbsp; In addition to this
automatic selection, a particular grammar may be selected using the debugger<B><I> Set LAnguage</I></B> command.&nbsp; The
language currently selected can be determined using the<B><I> SHow Set LAnguage</I></B> command.
<H2 ID="General_Rules_of_Expression_Handling"> General Rules of Expression Handling </H2>
<BR>The debugger handles two types of expressions.&nbsp; The difference between the two types of expressions is quite subtle.
&nbsp;One is called an &quot;expression&quot; and things operate as you would normally expect.&nbsp; This type of expression
is used for all &quot;higher&quot; level operations such as adding items to the Watches window.&nbsp; The other type is called
an &quot;address expression&quot;.&nbsp; It is used whenever the debugger prompts for an address and in lower level commands
such<B><I> Examine</I></B> and<B><I> Modify</I></B> .&nbsp; If the notation for a particular command argument is &lt;address&gt;,
it is an address expression.&nbsp; If it ends in just &quot;expr&quot; then it is a normal expression.&nbsp; The difference
between the two forms lies in how they treat symbol names.&nbsp; In a normal expression the value of a symbol is its<B> rvalue,</B>
or contents.&nbsp; In an address expression, the value of a symbol is (sometimes) its<B> lvalue,</B> or address.
<BR><BR>Consider the following case.&nbsp; You have a symbol<TT> sam</TT> at offset 100 and the word at that location contains
the value 15.&nbsp; If you enter<TT> sam</TT> into the watches window you expect the value 15 to be printed and since the
Watches window takes a normal expression that is what you get.&nbsp; Now let us try it with the Breakpoint dialog.&nbsp; Enter<TT>
sam</TT> in the address field.&nbsp; The Breakpoint dialog uses the result of its expression as the address at which to set
a breakpoint.&nbsp; The Breakpoint dialog takes an address expression, and an implicit unary &quot;&amp;&quot; operator is
placed in front of symbols.&nbsp; The debugger has a set of heuristics that it applies to determine whether it should use
the rvalue or lvalue of a symbol.
<H2 ID="Language_Independent_Variables_and_Constants"> Language Independent Variables and Constants </H2>
<BR>The following sections describe conventions used in the debugger for identifying modules, variables, line numbers, registers,
etc.
<H3 ID="Symbol_Names"> Symbol Names </H3>
<BR>Regardless of the programming language that was used to code the modules of an application, the names of variables and
routines will be available to the debugger (provided that the appropriate symbolic debugging information has been included
with the application's execution module).&nbsp; The debugger does not restrict the way in which names are used in expressions.
&nbsp;A name could represent a variable but it could also represent the entry point into a routine.
<BR><BR>The syntax of a symbol name reference is quite complicated.&nbsp; 
<BR><BR><B><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </I></B>
<BR><B><I>&nbsp;&nbsp;&nbsp;&nbsp; [[[image]@][module]@][routine_name.]symbol_name</I></B>
<BR><BR>Generally, an application will consist of many modules which were compiled separately.&nbsp; The current image is
the one containing the module which is currently executing.&nbsp; The current module is the one containing the source lines
currently under examination in the Source or Assembly window.&nbsp; By default, the Source window's title line contains the
current module name.&nbsp; The current routine is the one containing the source line at which execution is currently paused.
<BR><BR>The following are examples of references to symbol names.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; symbol_name</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; main</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; WinMain</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; FMAIN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; printf</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; LIB$G_OPEN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; stdin</TT>
<BR><BR>If the symbol does not exist in the current scope then it must be qualified with its routine name.&nbsp; Generally,
these are variables that are local to a particular routine.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; routine_name.symbol_name</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; main.curr_time</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; main.tyme</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SUB1.X</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SUB2.X</TT>
<BR><BR>If the symbol is not externally defined and it does not exist in the current module then it may be qualified with
its module name.&nbsp; In the C and C++ programming languages, we can define a variable that is global to a module but known
only to that module (&quot;static&quot; storage class).
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static char *NarrowTitle = { &quot;Su Mo Tu We Th Fr Sa&quot; };</TT>
<BR><BR>In the above example, &quot;NarrowTitle&quot; is global to the module &quot;calendar&quot;.&nbsp; If the current module
is not &quot;calendar&quot; then the module name can be used to qualify the symbol as shown in the following example.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; calendar@NarrowTitle</TT>
<BR><BR>If the symbol is local to a routine that is not in the current module then it must be qualified with its module name
and routine name.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; module_name@routine_name.symbol_name</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; calendar@main.curr_time</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; calendar@main.tyme</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; subs@SUB1.X</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; subs@SUB2.X</TT>
<BR><BR>If the symbol is local to an image that is not in the current executable then it must be fully qualified with the
image name.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; prog_name@@routine_name</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; prog_name@module_name@routine_name</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; prog_name@module_name@routine_name.symbol_name</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; dll_name@calendar@main.curr_time</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; dll_name@calendar@main.tyme</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; program@subs@SUB1.X</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; program@subs@SUB2.X</TT>
<BR><BR>There is a special case for the primary executable image.&nbsp; This is the name of the program you specified when
you started the debugger.&nbsp; You can reference it by omitting the image name.&nbsp; The following examples all refer to
symbols in the primary executable image:
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; @@WinMain</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; @module@WinMain</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; @@routine.symbol</TT>
<BR><BR>In the FORTRAN 77 programming language, all variables (arguments, local variables, COMMON block variables) are available
to the subprogram in which they are defined or referenced.&nbsp; The same symbol name can be used in more than one subprogram.
&nbsp;If it is a local variable, it represents a different variable in each subprogram.&nbsp; If it is an argument, it may
represent a different variable in each subprogram.&nbsp; If it is a variable in a COMMON block, it represents the same variable
in each subprogram where the COMMON block is defined.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SUBROUTINE SUB1( X )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; REAL Y</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; COMMON /BLK/ Z</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SUBROUTINE SUB2( X )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; REAL Y</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; COMMON /BLK/ Z</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>In the above example, &quot;X&quot; is an argument and need not refer to the same variable in the calling subprogram.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CALL SUB1( A )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CALL SUB2( B )</TT>
<BR><BR>The variable &quot;Y&quot; is a different variable in each of &quot;SUB1&quot; and &quot;SUB2&quot;.&nbsp; The COMMON
block variable &quot;Z&quot; refers to the same variable in each of &quot;SUB1&quot; and &quot;SUB2&quot; (different names
for &quot;Z&quot; could have been used).&nbsp; To refer to &quot;X&quot;, &quot;Y&quot;, or &quot;Z&quot; in the subprogram
&quot;SUB2&quot;, you would specify &quot;SUB2.X&quot;, &quot;SUB2.Y&quot;, or &quot;SUB2.Z&quot;.&nbsp; If &quot;SUB2&quot;
was in the module &quot;MOD&quot; and it is not the current module, you would specify &quot;MOD@SUB2.X&quot;, &quot;MOD@SUB2.Y&quot;,
or &quot;MOD@SUB2.Z&quot;.
<DL>
<DT>Note:
<DD>Global and local symbol name debugging information is included in an executable image if you request it of the linker.&nbsp;
However, local symbol information must be present in your object files.&nbsp; The Open Watcom C, C++ and FORTRAN 77 compilers
can include local symbol debugging information in object files by specifying the appropriate compiler option.&nbsp; See <A HREF="#Preparing_a_Program_to_be_Debugged">Preparing a Program to be Debugged</A>.
</DL>
<H3 ID="Line_Numbers"> Line Numbers </H3>
<BR>Regardless of the programming language that was used to code the modules of an application, line number information identifying
the start of executable statements will be available to the debugger (provided that the appropriate symbolic debugging information
has been included with the application's execution module).&nbsp; The debugger does not restrict the way in which line number
references are used in expressions.&nbsp; A line number represents the code address of an executable statement in a routine.
&nbsp;Not all line numbers represent executable statements; thus some line numbers may not be valid in an expression.&nbsp;
For example, source lines consisting of comments do not represent executable statements.
<BR><BR>The general format for a line number reference is:
<BR><BR><B><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </I></B>
<BR><B><I>&nbsp;&nbsp;&nbsp;&nbsp; [ [image]@ ] [module_name] @ decimal_digits</I></B>
<BR><BR>The following are examples of references to executable statements.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; @36</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; @@45</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; @51</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; @125</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; hello@9</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; @hello@9</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; prog@hello@9</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; otherprg@goodbye@9</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; puzzle@50</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; calendar@20</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SUB1@30</TT>
<BR><BR>If the line number does not exist in the current module, it must be qualified with its module name.&nbsp; If it does
not exist in the current image, it must be qualified with the image name.&nbsp; Line numbers are not necessarily unique.&nbsp;
For example, an executable statement could occur at line number 20 in several modules.&nbsp; The module name can always be
used to uniquely identify the line 20 in which we are interested.&nbsp; In the above examples, we explicitly refer to line
20 in the module &quot;calendar&quot;.&nbsp; When the module name is omitted, the current module is assumed.
<DL>
<DT>Note:
<DD>Line number debugging information is included in an executable image if you request it of the linker.&nbsp; However, line
number information must be present in your object files.&nbsp; The Open Watcom C, C++ and FORTRAN 77 compilers can include
line number debugging information in object files by specifying the appropriate compiler option.&nbsp; See <A HREF="#Preparing_a_Program_to_be_Debugged">Preparing a Program to be Debugged</A>.
&nbsp;You can request line number debugging information when assembling assembly language source files using Open Watcom Assembler
The &quot;d1&quot; option must be specified on the command line.
</DL>
<H3 ID="Constants"> Constants </H3>
<BR>A<B> constant</B> can be arithmetic or character.&nbsp; Each constant has a data type associated with it.&nbsp; Arithmetic
constants consist of those constants whose data type is one of integer, real, or complex (FORTRAN only).&nbsp; C treats character
constants like arithmetic constants so they can be used in arithmetic expressions.&nbsp; FORTRAN treats character constants
as constants of type CHARACTER so they cannot be used in arithmetic expressions.
<H4 ID="Integer_Constants"> Integer Constants </H4>
<BR>An<B> integer constant</B> is formed by a non-empty string of digits preceded by an optional radix specifier.&nbsp; The
digits are taken from the set of digits valid for the current radix.&nbsp; If the current radix is 10 then the digits are
'0' through '9'.&nbsp; If the current radix is 16 then the digits are '0' through '9' and 'A' through 'F' or 'a' through 'f'.
&nbsp;See <A HREF="#The_Options_Dialog">The Options Dialog</A>.
<BR><BR>The following are examples of integer constants.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 123</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 57DE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 1423</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 345</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 34565788</TT>
<BR><BR>Radix specifiers may be defined by the user, but two are predefined by the debugger.<B>&nbsp; 0x</B> may be defined
to be a radix specifier for hexadecimal (base 16) numbers.<B>&nbsp; 0n</B> may be defined to be a radix specifier for decimal
(base 10) numbers
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0x1234&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hexadecimal</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0n1234&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; decimal</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 255&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; decimal</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0xff&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hexadecimal</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0x1ADB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hexadecimal</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0n200&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; decimal</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0x12fc0&nbsp;&nbsp;&nbsp;&nbsp; hexadecimal</TT>
<H4 ID="Real_Constants"> Real Constants </H4>
<BR>We first define a<B> simple real constant</B> as follows:&nbsp; an optional sign followed by an integer part followed
by a decimal point followed by a fractional part.&nbsp; The integer and fractional parts are non-empty strings of digits.
&nbsp;The fractional part can be omitted.
<BR><BR>A<B> real constant</B> has one of the following forms.
<DL>
<DT>(1)
<DD>A simple real constant.
<DT>(2)
<DD>A simple real constant followed by an<TT> E</TT> or<TT> e</TT> followed by an optionally signed integer constant.
</DL>
<BR>The optionally signed integer constant that follows the<TT> E</TT> is called the<B> exponent.</B>&nbsp; The value of a
real constant that contains an exponent is the value of the constant preceding the<TT> E</TT> multiplied by the power of ten
determined by the exponent.
<BR><BR>The following are examples of real constants.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 123.764</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0.4352344</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 1423.34E12</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +345.E-4</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -0.4565788E3</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 2.E6</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 1234.</TT>
<DL>
<DT>Note:
<DD>The accepted forms of floating-point constants are a subset of that supported by the FORTRAN 77 programming language.&nbsp;
The debugger does not support floating-point constants that begin with a decimal point (e.g., .4352344) or have no decimal
point (e.g., 2E6).&nbsp; However, both forms would be acceptable to a FORTRAN compiler.&nbsp; Also, the debugger does not
support double precision floating-point constants where &quot;D&quot; is used instead of &quot;E&quot; for the exponent part
(e.g., 2D6, 2.4352344D6).&nbsp; All floating-point constants are stored internally by the debugger in double precision format.
</DL>
<H4 ID="Complex_Constant_LFORTRAN_OnlyR"> Complex Constant (FORTRAN Only) </H4>
<BR>A<B> complex constant</B> consists of a left parenthesis, followed by a real or integer constant representing the real
part of the complex constant, followed by a comma, followed by a real or integer constant representing the imaginary part
of the complex constant, followed by a right parenthesis.
<BR><BR>The following are examples of complex constants.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ( 1423.34E12, 3 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ( +345, 4 )</TT>
<BR><BR>Complex constants will be accepted when the debugger's currently established language is FORTRAN.&nbsp; The language
currently selected can be determined using the<B><I> SHow Set LAnguage</I></B> command.
<H4 ID="Character_Constant_LC_OnlyR"> Character Constant (C Only) </H4>
<BR>In the C and C++ programming languages, a<B> character constant</B> consists of an apostrophe followed by a single character
followed by an apostrophe.&nbsp; The apostrophes are not part of the datum.&nbsp; An apostrophe in a character datum represents
one character, namely the apostrophe.&nbsp; A character constant must have length 1.
<BR><BR>The following are examples of character constants.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 'A'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 'e'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; '''</TT>
<BR><BR>The C/C++ form of a character constant will be accepted when the debugger's currently established language is C or
C++.&nbsp; The language currently selected can be determined using the<B><I> SHow Set LAnguage</I></B> command.
<H4 ID="Character_String_Constant_LFORTRAN_OnlyR"> Character String Constant (FORTRAN Only) </H4>
<BR>In the FORTRAN 77 programming language, a<B> character constant</B> consists of an apostrophe followed by any string of
characters followed by an apostrophe.&nbsp; The apostrophes are not part of the datum.&nbsp; If an apostrophe is to appear
as part of the datum it must be followed immediately by another apostrophe.&nbsp; Note that blanks are significant.&nbsp;
The length of the character constant is the number of characters appearing between the delimiting apostrophes.&nbsp; Consecutive
apostrophes in a character datum represent one character, namely the apostrophe.&nbsp; A character constant must not have
length 0.
<BR><BR>The following are examples of character constants.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 'ABCDEFG1234567'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 'There''s always tomorrow'</TT>
<BR><BR>The FORTRAN form of a character constant will be accepted when the debugger's currently established language is FORTRAN.
<H3 ID="Memory_References"> Memory References </H3>
<BR>In addition to referring to memory locations by symbolic name or line number, you can also refer to them using a combination
of constants, register names, and symbol names.&nbsp; In the Intel 80x86 architecture, a memory reference requires a segment
and offset specification.&nbsp; When symbol names are used, these are implicit.&nbsp; The general form of a memory reference
is:
<BR><BR><B><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </I></B>
<BR><B><I>&nbsp;&nbsp;&nbsp;&nbsp; [segment:]offset</I></B>
<BR><BR>When an offset is specified alone, the default segment value is taken from the CS, DS or SS register depending on
the circumstances.
<H3 ID="Predefined_Debugger_Variables"> Predefined Debugger Variables </H3>
<BR>The debugger defines a number of symbols which have special meaning.&nbsp; These symbols are used to refer to the computer's
registers and other special variables.
<DL>
<DT>General Purpose Registers
<DD><B> eax, ax, al, ah, ebx, bx, bl, bh, ecx, cx, cl, ch, edx, dx, dl, dh</B>
<DT>Index Registers
<DD><B> esi, si, edi, di</B>
<DT>Base Registers
<DD><B> esp, sp, ebp, bp</B>
<DT>Instruction Pointer
<DD><B> eip, ip</B>
<DT>Segmentation Registers
<DD><B> cs, ds, es, fs, gs, ss</B>
<DT>Flags Registers
<DD><B> fl, fl.o, fl.d, fl.i, fl.s, fl.z, fl.a, fl.p, fl.c, efl, efl.o, efl.d, efl.i, efl.s, efl.z, efl.a, efl.p, efl.c</B>
<DT>8087 Registers
<DD><B> st0, st1, st2, st3, st4, st5, st6, st7</B>
<DT>8087 Control Word
<DD><B> cw, cw.ic, cw.rc, cw.pc, cw.iem, cw.pm, cw.um, cw.om, cw.zm, cw.dm, cw.im</B>
<DT>8087 Status Word
<DD><B> sw, sw.b, sw.c3, sw.st, sw.c2, sw.c1, sw.c0, sw.es, sw.sf, sw.pe, sw.ue, sw.oe, sw.ze, sw.de, sw.ie</B>
<DT>Miscellaneous Variables
<DD><B> dbg$32, dbg$bottom, dbg$bp, dbg$code, dbg$cpu, dbg$ctid, dbg$data, dbg$etid, dbg$fpu, dbg$ip, dbg$left, dbg$monitor, dbg$ntid,
dbg$os, dbg$pid, dbg$psp, dbg$radix, dbg$remote, dbg$right, dbg$sp, dbg$top, dbg$nil, dbg$src, dbg$loaded</B>
</DL>
<BR>The debugger permits the manipulation of register contents and special debugger variables (e.g., dbg$32) using any of
the operators described in this chapter.&nbsp; By default, these predefined names are accessed just like any other variables
defined by the user or the application.&nbsp; Should the situation ever arise where the application defines a variable whose
name conflicts with that of one of these debugger variables, the module specifier<TT> _dbg</TT> may be used to resolve the
ambiguity.&nbsp; For example, if the application defines a variable called<TT> cs</TT> then<TT> _dbg@cs</TT> can be specified
to resolve the ambiguity.&nbsp; The &quot;_dbg@&quot; prefix indicates that we are referring to a debugger defined symbol
rather than an application defined symbol.&nbsp; See <A HREF="#Predefined_Symbols">Predefined Symbols</A>.
<H3 ID="Register_Aggregates"> Register Aggregates </H3>
<BR>There are times when a value may be stored in more than one register.&nbsp; For example, a 32-bit &quot;long&quot; integer
value may be stored in the register pair DX:AX.&nbsp; We require a mechanism for grouping registers to represent a single
quantity for use in expressions.
<BR><BR>We define the term &quot;register aggregate&quot; as any grouping of registers to form a single unit.&nbsp; An aggregate
is specified by placing register names in brackets in order from most significant to least significant.&nbsp; Any aggregate
may be specified as long as it forms an 8, 16, 32 or 64-bit quantity.&nbsp; The following are examples of some of the many
aggregates that can be formed.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 8-bit&nbsp;&nbsp;&nbsp; [al]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 16-bit&nbsp;&nbsp; [ah al]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 16-bit&nbsp;&nbsp; [bl ah]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 16-bit&nbsp;&nbsp; [ax]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 32-bit&nbsp;&nbsp; [dx ax]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 32-bit&nbsp;&nbsp; [dh dl ax]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 32-bit&nbsp;&nbsp; [dh dl ah al]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 32-bit&nbsp;&nbsp; [ds di]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 64-bit&nbsp;&nbsp; [ax bx cx dx]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 64-bit&nbsp;&nbsp; [edx eax]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (386/486/Pentium only)</TT>
<BR><BR>In some cases, the specified aggregate may be equivalent to a register.&nbsp; For example, the aggregates &quot;[ah
al]&quot; and &quot;[ax]&quot; are equivalent to &quot;ax&quot;.
<BR><BR>The default type for 8-bit, 16-bit, and 32-bit aggregates is integer.&nbsp; The default type for 64-bit aggregates
is double-precision floating-point.&nbsp; To force the debugger into treating a 32-bit aggregate as single-precision floating-point,
the type coercion operator &quot;[float]&quot; may be used.
<H2 ID="Operators_for_the_C_Grammar"> Operators for the C Grammar </H2>
<BR>The debugger supports most C operators and includes an additional set of operators for convenience.&nbsp; The<B> Open
Watcom C Language Reference</B> manual describes many of these operators.
<BR><BR>The syntax for debugger expressions is similar to that of the C programming language.&nbsp; Operators are presented
in order of precedence, from lowest to highest.&nbsp; Operators on the same line have the same priority.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; Lowest Priority</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Assignment Operators</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&nbsp; +=&nbsp; -=&nbsp; *=&nbsp; /=&nbsp; %=&nbsp; &amp;=&nbsp;
|=&nbsp; ^=&nbsp; &lt;&lt;=&nbsp; &gt;&gt;=</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Logical Operators</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ||</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Bit Operators</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Relational Operators</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ==&nbsp; !=</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&nbsp;&nbsp; &lt;=&nbsp;&nbsp; &lt;&nbsp;&nbsp; &gt;=</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Shift Operators</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt;&nbsp; &gt;&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Arithmetic Operators</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp; -</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; /&nbsp; %</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Unary Operators</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp; -&nbsp; ~&nbsp; !&nbsp; ++&nbsp; --&nbsp; &amp;&nbsp; *&nbsp;
%</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sizeof unary_expr</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sizeof(type_name)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (type_name) unary_expr</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [type_name] unary_expr</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ?</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Binary Address Operator</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; Highest Priority</TT>
<BR><BR>Parentheses can be used to order the evaluation of an expression.
<BR><BR>In addition to the operators listed above, a number of primary expression operators are supported.&nbsp; These operators
are used in identifying the object to be operated upon.
<DL>
<DT>[]
<DD>subscripting, substringing
<DT>()
<DD>function call
<DT>.
<DD>field selection
<DT>-&gt;
<DD>field selection using a pointer
</DL>
<BR>The following sections describe the operators presented above.
<H3 ID="Assignment_Operators_for_the_C_Grammar"> Assignment Operators for the C Grammar </H3>
<DL>
<DT>=
<DD>Assignment:&nbsp; The value on the right is assigned to the object on the left.
<DT>+=
<DD>Additive assignment:&nbsp; The value of the object on the left is augmented by the value on the right.
<DT>-=
<DD>Subtractive assignment:&nbsp; The value of the object on the left is reduced by the value on the right.
<DT>*=
<DD>Multiplicative assignment:&nbsp; The value of the object on the left is multiplied by the value on the right.
<DT>/=
<DD>Division assignment:&nbsp; The value of the object on the left is divided by the value on the right.
<DT>%=
<DD>Modulus assignment:&nbsp; The object on the left is updated with MOD(left,right).&nbsp; The result is the remainder when the
value of the object on the left is divided by the value on the right.
<DT>&amp;=
<DD>Bit-wise AND:&nbsp; The bits in the object on the left are ANDed with the bits of the value on the right.
<DT>|=
<DD>Bit-wise inclusive OR:&nbsp; The bits in the object on the left are ORed with the bits of the value on the right.
<DT>^=
<DD>Bit-wise exclusive OR:&nbsp; The bits in the object on the left are exclusively ORed with the bits of the value on the right.
<DT>&lt;&lt;=
<DD>Left shift:&nbsp; The bits in the object on the left are shifted to the left by the amount of the value on the right.
<DT>&gt;&gt;=
<DD>Right shift:&nbsp; The bits in the object on the left are shifted to the right by the amount of the value on the right.&nbsp;
If the object on the left is described as unsigned, the vacated high-order bits are zeroed.&nbsp; If the object on the left
is described as signed, the sign bit is propagated through the vacated high-order bits.&nbsp; The debugger treats registers
as unsigned items.
</DL>
<H3 ID="Logical_Operators_for_the_C_Grammar"> Logical Operators for the C Grammar </H3>
<DL>
<DT>&amp;&amp;
<DD>Logical conjunction:&nbsp; The logical AND of the value on the left and the value on the right is produced.&nbsp; If either
of the values on the left or right is equal to 0 then the result is 0; otherwise the result is 1.
<DT>||
<DD>Logical inclusive disjunction:&nbsp; The logical OR of the value on the left and the value on the right is produced.&nbsp;
If either of the values on the left or right is not equal to 0 then the result is 1; otherwise the result is 0.&nbsp; If the
value on the left is not equal to 0 then the expression on the right is not evaluated (this is known as short-circuit expression
evaluation).
</DL>
<H3 ID="Bit_Operators_for_the_C_Grammar"> Bit Operators for the C Grammar </H3>
<DL>
<DT>&amp;
<DD>Bit-wise AND:&nbsp; The bits of the value on the left and the value on the right are ANDed.
<DT>|
<DD>Bit-wise OR:&nbsp; The bits of the value on the left and the value on the right are ORed.
<DT>^
<DD>Bit-wise exclusive OR:&nbsp; The bits of the value on the left and the value on the right are exclusively ORed.
</DL>
<H3 ID="Relational_Operators_for_the_C_Grammar"> Relational Operators for the C Grammar </H3>
<DL>
<DT>==
<DD>Equal:&nbsp; If the value on the left is equal to the value on the right then the result is 1; otherwise the result is 0.
<DT>!=
<DD>Not equal:&nbsp; If the value on the left is not equal to the value on the right then the result is 1; otherwise the result
is 0.
<DT>&lt;
<DD>Less than:&nbsp; If the value on the left is less than the value on the right then the result is 1; otherwise the result is
0.
<DT>&lt;=
<DD>Less than or equal:&nbsp; If the value on the left is less than or equal to the value on the right then the result is 1; otherwise
the result is 0.
<DT>&gt;
<DD>Greater than:&nbsp; If the value on the left is greater than the value on the right then the result is 1; otherwise the result
is 0.
<DT>&gt;=
<DD>Greater than or equal:&nbsp; If the value on the left is greater than or equal to the value on the right then the result is
1; otherwise the result is 0.
</DL>
<H3 ID="ArithmeticDLogical_Shift_Operators_for_the_C_Grammar"> Arithmetic/Logical Shift Operators for the C Grammar </H3>
<DL>
<DT>&lt;&lt;
<DD>Left shift:&nbsp; The bits of the value on the left are shifted to the left by the amount described by the value on the right.
<DT>&gt;&gt;
<DD>Right shift:&nbsp; The bits of the value on the left are shifted to the right by the amount described by the value on the
right.&nbsp; If the object on the left is described as unsigned, the vacated high-order bits are zeroed.&nbsp; If the object
on the left is described as signed, the sign bit is propagated through the vacated high-order bits.&nbsp; The debugger treats
registers as unsigned items.
</DL>
<H3 ID="Binary_Arithmetic_Operators_for_the_C_Grammar"> Binary Arithmetic Operators for the C Grammar </H3>
<DL>
<DT>+
<DD>Addition:&nbsp; The value on the right is added to the value on the left.
<DT>_
<DD>Subtraction:&nbsp; The value on the right is subtracted from the value on the left.
<DT>*
<DD>Multiplication:&nbsp; The value on the left is multiplied by the value on the right.
<DT>/
<DD>Division:&nbsp; The value on the left is divided by the value on the right.
<DT>%
<DD>Modulus:&nbsp; The modulus of the value on the left with respect to the value on the right is produced.&nbsp; The result is
the remainder when the value on the left is divided by the value on the right.
</DL>
<H3 ID="Unary_Arithmetic_Operators_for_the_C_Grammar"> Unary Arithmetic Operators for the C Grammar </H3>
<DL>
<DT>+
<DD>Plus:&nbsp; The result is the value on the right.
<DT>_
<DD>Minus:&nbsp; The result is the negation of the value on the right.
<DT>~
<DD>Bit-wise complement:&nbsp; The result is the bit-wise complement of the value on the right.
<DT>!
<DD>Logical complement:&nbsp; If the value on the right is equal to 0 then the result is 1; otherwise it is 0.
<DT>++
<DD>Increment:&nbsp; Both prefix and postfix operators are supported.&nbsp; If the object is on the right, it is pre-incremented
by 1 (e.g., ++x).&nbsp; If the object is on the left, it is post-incremented by 1 (e.g., x++).
<DT>_ _
<DD>Decrement:&nbsp; Both prefix and postfix operators are supported.&nbsp; If the object is on the right, it is pre-decremented
by 1 (e.g., --x).&nbsp; If the object is on the left, it is post-decremented by 1 (e.g., x--).
<DT>&amp;
<DD>Address of:&nbsp; The result is the address (segment:offset) of the object on the right (e.g., &amp;main).
<DT>*
<DD>Points:&nbsp; The result is the value stored at the location addressed by the value on the right (e.g., *(ds:100), *string.loc).
&nbsp;In the absence of typing information, a near pointer is produced.&nbsp; If the operand does not have a segment specified,
the default data segment (DGROUP) is assumed.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (SS:00FE) = FFFF</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; var:&nbsp; (SS:0100) = 0152</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (SS:0102) = 1240</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (SS:0104) = EEEE</TT>
<DT>%
<DD>Value at address:&nbsp; The result is the value stored at the location addressed by the value on the right (e.g., %(ds:100),
%string.loc).&nbsp; In the absence of typing information, a far pointer is produced.&nbsp; If the operand does not have a
segment specified, the default data segment (DGROUP) is assumed.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (SS:00FE) = FFFF</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; var:&nbsp; (SS:0100) = 0152</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (SS:0102) = 1240</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (SS:0104) = EEEE</TT>
<BR><BR>Note that this operator is not found in the C or C++ programming languages.
</DL>
<H3 ID="Special_Unary_Operators_for_the_C_Grammar"> Special Unary Operators for the C Grammar </H3>
<DL>
<DT>sizeof unary_expression
<DD>
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; sizeof tyme</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; sizeof (*tyme)</TT>
<DT>sizeof(type_name)
<DD>
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; sizeof( struct tm )</TT>
<DT>(type_name) unary_expression
<DD>The type conversion operator<B> (type_name)</B> is used to convert an item from one type to another.&nbsp; The following describes
the syntax of &quot;type_name&quot;.
<BR><BR><B><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </I></B>
<BR><B><I>&nbsp;&nbsp;&nbsp;&nbsp; type_name ::= type_spec { [ &quot;near&quot; | &quot;far&quot; | &quot;huge&quot; ] &quot;*&quot;
}</I></B>
<BR><B><I>&nbsp;&nbsp;&nbsp;&nbsp; type_spec ::= typedef_name</I></B>
<BR><B><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;|&nbsp;&nbsp; &quot;struct&quot; structure_tag</I></B>
<BR><B><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;|&nbsp;&nbsp; &quot;union&quot;&nbsp; union_tag</I></B>
<BR><B><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;|&nbsp;&nbsp; &quot;enum&quot;&nbsp;&nbsp; enum_tag</I></B>
<BR><B><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;|&nbsp;&nbsp; scalar_type { scalar_type }</I></B>
<BR><B><I>&nbsp;&nbsp;&nbsp;&nbsp; scalar_type ::= &quot;char&quot; | &quot;int&quot; | &quot;float&quot; | &quot;double&quot;</I></B>
<BR><B><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;|&nbsp;&nbsp; &quot;short&quot; | &quot;long&quot; | &quot;signed&quot; | &quot;unsigned&quot;</I></B>
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; (float) 4</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; (int) 3.1415926</TT>
<DT>[type_name] unary_expression
<DD>You can force the debugger to treat a memory reference as a particular type of value by using a type coercion operator.&nbsp;
A type specification is placed inside brackets as shown above.&nbsp; The basic types are<B><I> char</I></B> (character, 8
bits),<B><I> short</I></B> (short integer, 16 bits),<B><I> long</I></B> (long integer, 32 bits),<B><I> float</I></B> (single-precision
floating-point, 32 bits), and<B><I> double</I></B> (double-precision floating-point, 64 bits).&nbsp; Unless qualified by the<B><I>
short</I></B> or<B><I> long</I></B> keyword, the<B><I> int</I></B> type will be 16 bits in 16-bit applications and 32 bits
in 32-bit applications (386, 486 and Pentium systems).&nbsp; The character, short integer and long integer types may be treated
as<B><I> signed</I></B> or<B><I> unsigned</I></B> items.&nbsp; The default for the character type is unsigned.&nbsp; The default
for the integer types is signed.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [char]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; (default unsigned)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [signed char]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [unsigned char]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [int]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; (default is signed)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [short]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; (default is signed)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [short int]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (default
is signed)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [signed short int]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [long]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; (default is signed)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [long int]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(default is signed)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [signed long]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [unsigned long int]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [float]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [double]</TT>
<BR><BR>Note that it is unnecessary to specify the<B><I> int</I></B> keyword when<B><I> short</I></B> or<B><I> long</I></B>
are specified.
<DT>?
<DD>Existence test:&nbsp; The &quot;?&quot; unary operator may be used to test for the existence of a symbol.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ?id</TT>
<BR><BR>The result of this expression is 1 if &quot;id&quot; is a symbol known to the debugger and 0 otherwise.&nbsp; If the
symbol does not exist in the current scope then it must be qualified with its module name.&nbsp; Automatic symbols exist only
in the current function.
</DL>
<H3 ID="Binary_Address_Operator_for_the_C_Grammar"> Binary Address Operator for the C Grammar </H3>
<DL>
<DT>:
<DD>Memory locations can be referenced by using the binary &quot;:&quot; operator and a combination of constants, register names,
and symbol names.&nbsp; In the Intel 80x86 architecture, a memory reference requires a segment and offset specification.&nbsp;
A memory reference using the &quot;:&quot; operator takes the following form:
<BR><BR><B><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </I></B>
<BR><B><I>&nbsp;&nbsp;&nbsp;&nbsp; segment:offset</I></B>
<BR><BR>The elements<B> segment</B> and<B> offset</B> can be expressions.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; (ES):(DI+100)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; (SS):(SP-20)</TT>
</DL>
<H3 ID="Primary_Expression_Operators_for_the_C_Grammar"> Primary Expression Operators for the C Grammar </H3>
<DL>
<DT>[]
<DD>Elements of an array can be identified using subscript expressions.&nbsp; Consider the following 3-dimensional array defined
in the &quot;C&quot; language.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char *ProcessorType[2][4][2] =</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { { { &quot;Intel 8086&quot;,&nbsp;&nbsp; &quot;Intel 8088&quot;
&nbsp;},</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { &quot;Intel 80186&quot;,&nbsp; &quot;Intel
80188&quot; },</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { &quot;Intel 80286&quot;,&nbsp; &quot;unknown&quot;
},</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { &quot;Intel 80386&quot;,&nbsp; &quot;unknown&quot;
} },</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { { &quot;NEC V30&quot;,&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&quot;NEC V20&quot; },</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { &quot;unknown&quot;,&nbsp;&nbsp;&nbsp;
&nbsp; &quot;unknown&quot; },</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { &quot;unknown&quot;,&nbsp;&nbsp;&nbsp;
&nbsp; &quot;unknown&quot; },</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { &quot;unknown&quot;,&nbsp;&nbsp;&nbsp;
&nbsp; &quot;unknown&quot; } } };</TT>
<BR><BR>This array can be viewed as two layers of rectangular matrices of 4 rows by 2 columns.&nbsp; The array elements are
all pointers to string values.
<BR><BR>By using a subscript expression, specific slices of an array can be displayed.&nbsp; To see only the values of the
first layer, the following expression can be issued.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; processortype[0]</TT>
<BR><BR>To see only the first row of the first layer, the following expression can be issued.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; processortype[0][0]</TT>
<BR><BR>To see the second row of the first layer, the following command can be issued.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; processortype[0][1]</TT>
<BR><BR>To see the value of a specific entry in a matrix, all the indices can be specified.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; processortype[0][0][0]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; processortype[0][0][1]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; processortype[0][1][0]</TT>
<DT>()
<DD>The function call operators appear to the right of a symbol name and identify a function call in an expression.&nbsp; The
parentheses can contain arguments.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ClearScreen()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; PosCursor( 10, 20 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Line( 15, 1, 30, '-', '+', '-' )</TT>
<DT>.
<DD>The &quot;.&quot; operator indicates field selection in a structure.&nbsp; In the following example,<TT> tyme2</TT> is a structure
and<TT> tm_year</TT> is a field in the structure.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; tyme2.tm_year</TT>
<DT>-&gt;
<DD>The &quot;-&gt;&quot; operator indicates field selection when using a pointer to a structure.&nbsp; In the following example,<TT>
tyme</TT> is the pointer and<TT> tm_year</TT> is a field in the structure to which it points.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; tyme-&gt;tm_year</TT>
</DL>
<H2 ID="Operators_for_the_CPP_Grammar"> Operators for the C++ Grammar </H2>
<BR>Debugger support for the C++ grammar includes all of the C operators described in the previous section entitled <A HREF="#Operators_for_the_C_Grammar">Operators for the C Grammar</A>.
&nbsp;In addition to this, the debugger supports a variety of C++ operators which are described in the<B> C++ Programming
Language</B> manual.
<BR><BR>Perhaps the best way to illustrate the additional capabilities of the debugger's support for the C++ grammar is by
way of an example.&nbsp; The following C++ program encompasses the features of C++ that we will use in our debugging example.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; // DBG_EXAM.C: C++ debugging example program</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct BASE {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int a;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BASE() : a(0) {}</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~BASE(){}</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BASE &amp; operator =( BASE const &amp;s )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a = s.a;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return *this;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void foo()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a = 1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct DERIVED : BASE {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int b;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DERIVED() : b(0) {}</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~DERIVED() {}</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DERIVED &amp; operator =( DERIVED const &amp;s )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a = s.a;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b = s.b;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return *this;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void foo()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a = 2;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b = 3;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void foo( int )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void use( BASE *p )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p-&gt;foo();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DERIVED x;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DERIVED y;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; use( &amp;x );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y = x;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>Compile and link this program so that the most comprehensive debugging information is included in the executable file.
<H3 ID="Ambiguity_Resolution_in_the_CPP_Grammar"> Ambiguity Resolution in the C++ Grammar </H3>
<BR>Continuing with the example of the previous section, we can step into the call to<TT> use</TT> and up to the<TT> p-&gt;foo()</TT>
function call.&nbsp; Try to set a breakpoint at foo.
<BR><BR>You will be presented with a window containing a list of &quot;foo&quot; functions to choose from since the reference
to<TT> foo</TT> at this point is ambiguous.&nbsp; Select the one in which you are interested.
<BR><BR>You may also have observed that, in this instance,<TT> p</TT> is really a pointer to the variable<TT> x</TT> which
is a<TT> DERIVED</TT> type.&nbsp; To display all the fields of<TT> x,</TT> you can type cast it as follows.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *(DERIVED *)p</TT>
<H3 ID="The__this__Operator_for_the_CPP_Grammar"> The &quot;this&quot; Operator for the C++ Grammar </H3>
<BR>Continuing with the example of the previous sections, we can step into the call to<TT> f-&gt;foo()</TT> and up to the<TT>
b=3</TT> statement.&nbsp; You can use the &quot;this&quot; operator as illustrated in the following example.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;a</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *this</TT>
<H3 ID="_operator__Functions_in_the_CPP_Grammar"> &quot;operator&quot; Functions in the C++ Grammar </H3>
<BR>Continuing with the example of the previous sections, we can set breakpoints at C++ operators using expressions similar
to the following:
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; operator =</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DERIVED &amp; operator =( DERIVED const &amp;s )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a = s.a;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b = s.b;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return *this;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H3 ID="Scope_Operator______for_the_CPP_Grammar"> Scope Operator &quot;::&quot; for the C++ Grammar </H3>
<BR>We can use the scope operator &quot;::&quot; to identify what it is that we wish to examine.&nbsp; Continuing with the
example of the previous sections, we can enter an address like:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; base::foo</TT>
<BR><BR>In some cases, this also helps to resolve any ambiguity.&nbsp; The example above permits us to set a breakpoint at
the source code for the function<TT> foo</TT> in the class<TT> BASE.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void foo()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a = 1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>Here are some more interesting examples:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; derived::foo</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; derived::operator =</TT>
<BR><BR>The first of these two examples contains an ambiguous reference so a prompt window is displayed to resolve the ambiguity.
<H3 ID="ConstructorDDestructor_Functions_in_the_CPP_Grammar"> Constructor/Destructor Functions in the C++ Grammar </H3>
<BR>We can also examine the constructor/destructor functions of an object or class.&nbsp; Continuing with the example of the
previous sections, we can enter expressions like:
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; base::base</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; base::~base</TT>
<BR><BR>The examples above permit us to reference the source code for the constructor and destructor functions in the class<TT>
BASE.</TT>
<H2 ID="Operators_for_the_FORTRAN_Grammar"> Operators for the FORTRAN Grammar </H2>
<BR>The debugger supports most FORTRAN 77 operators and includes an additional set of operators for convenience.&nbsp; The
additional operators are patterned after those available in the C programming language.
<BR><BR>The grammar that the debugger supports is close to that of the FORTRAN 77 language but there are a few instances where
space characters must be used to clear up any ambiguities.&nbsp; For example, the expression
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 1.eq.x</TT>
<BR><BR>will result in an error since the debugger will form a floating-point constant from the &quot;1.&quot; leaving the
string &quot;eq.x&quot;.&nbsp; If we introduce a space character after the &quot;1&quot; then we clear up the ambiguity.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 1 .eq.x</TT>
<BR><BR>Unlike FORTRAN, the parser in the debugger treats spaces as significant characters.&nbsp; Thus spaces must not be
introduced in the middle of symbol names, constants, multi-character operators like .EQ.&nbsp; or //, etc.
<BR><BR>Operators are presented in order of precedence, from lowest to highest.&nbsp; Operators on the same line have the
same priority.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; Lowest Priority</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Assignment Operators</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&nbsp; +=&nbsp; -=&nbsp; *=&nbsp; /=&nbsp; %=&nbsp; &amp;=&nbsp;
|=&nbsp; ^=&nbsp; &lt;&lt;=&nbsp; &gt;&gt;=</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Logical Operators</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .EQV.&nbsp; .NEQV.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .OR.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .AND.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .NOT.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Bit Operators</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Relational Operators</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .EQ.&nbsp; .NE.&nbsp; .LT.&nbsp; .LE.&nbsp; .GT.&nbsp; .GE.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Shift and Concatenation Operators</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt;&nbsp; &gt;&gt;&nbsp; //</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Arithmetic Operators</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp; -</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; /&nbsp; %</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ** (unsupported)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Unary Operators</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp; -</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~&nbsp; ++&nbsp; --&nbsp; &amp;&nbsp;&nbsp; *&nbsp;&nbsp; %</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [type_name] unary_expr</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ?</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Binary Address Operator</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; Highest Priority</TT>
<BR><BR>Parentheses can be used to order the evaluation of an expression.
<BR><BR>In addition to the operators listed above, a number of primary expression operators are supported.&nbsp; These operators
are used in identifying the object to be operated upon.
<DL>
<DT>()
<DD>subscripting, substringing, or function call
<DT>.
<DD>field selection
<DT>-&gt;
<DD>field selection using a pointer
</DL>
<BR>The following built-in functions may be used to convert the specified argument to a particular type.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; INT( )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; conversion to integer</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; REAL( )&nbsp;&nbsp;&nbsp;&nbsp; conversion to real</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DBLE( )&nbsp;&nbsp;&nbsp;&nbsp; conversion to double-precision</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CMPLX( )&nbsp;&nbsp;&nbsp; conversion to complex</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DCMPLX( )&nbsp;&nbsp; conversion to double-precision complex</TT>
<BR><BR>The following sections describe the operators presented above.
<H3 ID="Assignment_Operators_for_the_FORTRAN_Grammar"> Assignment Operators for the FORTRAN Grammar </H3>
<DL>
<DT>=
<DD>Assignment:&nbsp; The value on the right is assigned to the object on the left.
<DT>+=
<DD>Additive assignment:&nbsp; The object on the left is augmented by the value on the right.
<DT>-=
<DD>Subtractive assignment:&nbsp; The object on the left is reduced by the value on the right.
<DT>*=
<DD>Multiplicative assignment:&nbsp; The object on the left is multiplied by the value on the right.
<DT>/=
<DD>Division assignment:&nbsp; The object on the left is divided by the value on the right.
<DT>%=
<DD>Modulus assignment:&nbsp; The object on the left is updated with MOD(left,right).&nbsp; The result is the remainder when the
value of the object on the left is divided by the value on the right.
<DT>&amp;=
<DD>Bit-wise AND:&nbsp; The bits in the object on the left are ANDed with the bits of the value on the right.
<DT>|=
<DD>Bit-wise inclusive OR:&nbsp; The bits in the object on the left are ORed with the bits of the value on the right.
<DT>^=
<DD>Bit-wise exclusive OR:&nbsp; The bits in the object on the left are exclusively ORed with the bits of the value on the right.
<DT>&lt;&lt;=
<DD>Left shift:&nbsp; The bits in the object on the left are shifted to the left by the amount of the value on the right.
<DT>&gt;&gt;=
<DD>Right shift:&nbsp; The bits in the object on the left are shifted to the right by the amount of the value on the right.&nbsp;
If the object on the left is described as unsigned, the vacated high-order bits are zeroed.&nbsp; If the object on the left
is described as signed, the sign bit is propagated through the vacated high-order bits.&nbsp; The debugger treats registers
as unsigned items.
</DL>
<H3 ID="Logical_Operators_for_the_FORTRAN_Grammar"> Logical Operators for the FORTRAN Grammar </H3>
<DL>
<DT>.EQV.
<DD>Logical equivalence:&nbsp; The logical equivalence of the value on the left and the value on the right is produced.
<DT>.NEQV.
<DD>Logical non-equivalence:&nbsp; The logical non-equivalence of the value on the left and the value on the right is produced.
<DT>.OR.
<DD>Logical inclusive disjunction:&nbsp; The logical OR of the value on the left and the value on the right is produced.
<DT>.AND.
<DD>Logical conjunction:&nbsp; The logical AND of the value on the left and the value on the right is produced.
<DT>.NOT.
<DD>Logical negation:&nbsp; The logical complement of the value on the right is produced.
</DL>
<H3 ID="Bit_Operators_for_the_FORTRAN_Grammar"> Bit Operators for the FORTRAN Grammar </H3>
<DL>
<DT>|
<DD>Bit-wise OR:&nbsp; The bits of the value on the left and the value on the right are ORed.
<DT>^
<DD>Bit-wise exclusive OR:&nbsp; The bits of the value on the left and the value on the right are exclusively ORed.
<DT>&amp;
<DD>Bit-wise AND:&nbsp; The bits of the value on the left and the value on the right are ANDed.
</DL>
<H3 ID="Relational_Operators_for_the_FORTRAN_Grammar"> Relational Operators for the FORTRAN Grammar </H3>
<DL>
<DT>.EQ.
<DD>Equal:&nbsp; If the value on the left is equal to the value on the right then the result is 1; otherwise the result is 0.
<DT>.NE.
<DD>Not equal:&nbsp; If the value on the left is not equal to the value on the right then the result is 1; otherwise the result
is 0.
<DT>.LT.
<DD>Less than:&nbsp; If the value on the left is less than the value on the right then the result is 1; otherwise the result is
0.
<DT>.LE.
<DD>Less than or equal:&nbsp; If the value on the left is less than or equal to the value on the right then the result is 1; otherwise
the result is 0.
<DT>.GT.
<DD>Greater than:&nbsp; If the value on the left is greater than the value on the right then the result is 1; otherwise the result
is 0.
<DT>.GE.
<DD>Greater than or equal:&nbsp; If the value on the left is greater than or equal to the value on the right then the result is
1; otherwise the result is 0.
</DL>
<H3 ID="ArithmeticDLogical_Shift_Operators_for_the_FORTRAN_Grammar"> Arithmetic/Logical Shift Operators for the FORTRAN Grammar </H3>
<DL>
<DT>&lt;&lt;
<DD>Left shift:&nbsp; The bits of the value on the left are shifted to the left by the amount described by the value on the right.
<DT>&gt;&gt;
<DD>Right shift:&nbsp; The bits of the value on the left are shifted to the right by the amount described by the value on the
right.&nbsp; If the object on the left is described as unsigned, the vacated high-order bits are zeroed.&nbsp; If the object
on the left is described as signed, the sign bit is propagated through the vacated high-order bits.&nbsp; The debugger treats
registers as unsigned items.
</DL>
<H3 ID="Concatenation_Operator_for_the_FORTRAN_Grammar"> Concatenation Operator for the FORTRAN Grammar </H3>
<DL>
<DT>//
<DD>String concatenation:&nbsp; The concatenation of the character string value on the left and right is formed.
</DL>
<H3 ID="Binary_Arithmetic_Operators_for_the_FORTRAN_Grammar"> Binary Arithmetic Operators for the FORTRAN Grammar </H3>
<DL>
<DT>+
<DD>Addition:&nbsp; The value on the right is added to the value on the left.
<DT>_
<DD>Subtraction:&nbsp; The value on the right is subtracted from the value on the left.
<DT>*
<DD>Multiplication:&nbsp; The value on the left is multiplied by the value on the right.
<DT>/
<DD>Division:&nbsp; The value on the left is divided by the value on the right.
<DT>%
<DD>Modulus:&nbsp; The modulus of the value on the left with respect to the value on the right is produced.&nbsp; The result is
the remainder when the value on the left is divided by the value on the right.
<DT>**
<DD>Exponentiation:&nbsp; This operation is not supported by the debugger.
</DL>
<H3 ID="Unary_Arithmetic_Operators_for_the_FORTRAN_Grammar"> Unary Arithmetic Operators for the FORTRAN Grammar </H3>
<DL>
<DT>+
<DD>Plus:&nbsp; The result is the value on the right.
<DT>_
<DD>Minus:&nbsp; The result is the negation of the value on the right.
<DT>~
<DD>Bit-wise complement:&nbsp; The result is the bit-wise complement of the value on the right.
<DT>++
<DD>Increment:&nbsp; Both prefix and postfix operators are supported.&nbsp; If the object is on the right, it is pre-incremented
by 1 (e.g., ++x).&nbsp; If the object is on the left, it is post-incremented by 1 (e.g., x++).
<DT>_ _
<DD>Decrement:&nbsp; Both prefix and postfix operators are supported.&nbsp; If the object is on the right, it is pre-decremented
by 1 (e.g., --x).&nbsp; If the object is on the left, it is post-decremented by 1 (e.g., x--).
<DT>&amp;
<DD>Address of:&nbsp; The result is the address (segment:offset) of the object on the right (e.g., &amp;main).
<DT>*
<DD>Points:&nbsp; The result is the value stored at the location addressed by the value on the right (e.g., *(ds:100), *string.loc).
&nbsp;In the absence of typing information, the value on the right is treated as a pointer into the default data segment (DGROUP)
and a near pointer is produced.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (SS:00FE) = FFFF</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; var:&nbsp; (SS:0100) = 0152</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (SS:0102) = 1240</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (SS:0104) = EEEE</TT>
<DT>%
<DD>Value at address:&nbsp; The result is the value stored at the location addressed by the value on the right (e.g., %(ds:100),
%string.loc).&nbsp; In the absence of typing information, the value on the right is treated as a pointer into the default
data segment (DGROUP) and a far pointer is produced.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (SS:00FE) = FFFF</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; var:&nbsp; (SS:0100) = 0152</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (SS:0102) = 1240</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (SS:0104) = EEEE</TT>
<BR><BR>Note that this operator is not found in the FORTRAN 77 programming language.
</DL>
<H3 ID="Special_Unary_Operators_for_the_FORTRAN_Grammar"> Special Unary Operators for the FORTRAN Grammar </H3>
<DL>
<DT>?
<DD>Existence test:&nbsp; The &quot;?&quot; unary operator may be used to test for the existence of a symbol.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ?id</TT>
<BR><BR>The result of this expression is 1 if &quot;id&quot; is a symbol known to the debugger and 0 otherwise.&nbsp; If the
symbol does not exist in the current scope then it must be qualified with its module name.&nbsp; Automatic symbols exist only
in the current subprogram.
</DL>
<H3 ID="Binary_Address_Operator_for_the_FORTRAN_Grammar"> Binary Address Operator for the FORTRAN Grammar </H3>
<DL>
<DT>:
<DD>Memory locations can be referenced by using the binary &quot;:&quot; operator and a combination of constants, register names,
and symbol names.&nbsp; In the Intel 80x86 architecture, a memory reference requires a segment and offset specification.&nbsp;
A memory reference using the &quot;:&quot; operator takes the following form:
<BR><BR><B><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </I></B>
<BR><B><I>&nbsp;&nbsp;&nbsp;&nbsp; segment:offset</I></B>
<BR><BR>The elements<B> segment</B> and<B> offset</B> can be expressions.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; (ES):(DI+100)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; (SS):(SP-20)</TT>
</DL>
<H3 ID="Primary_Expression_Operators_for_the_FORTRAN_Grammar"> Primary Expression Operators for the FORTRAN Grammar </H3>
<DL>
<DT>()
<DD>Elements of an array can be identified using subscript expressions.
<DT>.
<DD>The &quot;.&quot; operator indicates field selection in a structure.&nbsp; This operator is useful in mixed language applications
where part of the application is written in the C or C++ programming language.&nbsp; In the following example,<TT> tyme2</TT>
is a structure and<TT> tm_year</TT> is a field in the structure.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; tyme2.tm_year</TT>
<DT>-&gt;
<DD>The &quot;-&gt;&quot; operator indicates field selection when using a pointer to a structure.&nbsp; This operator is useful
in mixed language applications where part of the application is written in the C or C++ programming language.&nbsp; In the
following example,<TT> tyme</TT> is the pointer and<TT> tm_year</TT> is a field in the structure to which it points.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; tyme-&gt;tm_year</TT>
</DL>
<H1 ID="Debugger_Commands"> Debugger Commands </H1>
<BR>This section describes the syntax of debugger commands as well as a description of each of the debugger commands.
<H2 ID="Syntax_Definitions"> Syntax Definitions </H2>
<BR>A debugger command may contain any of the following syntax elements:
<UL>
<LI>A word in angle brackets, like &lt;anything&gt; is a defined term.&nbsp; Its definition will appear after the syntax description
of the command.
<LI>[x] indicates that &quot;x&quot; is an optional item.&nbsp; It may or may not be included in the command.
<LI>[x|y|z] indicates that on of x, y or z should be included in the command.
<LI>[x [x [...]]] indicates that x may be repeated zero or more times in the command.
<LI>CApital indicates that ca,cap,capi,...&nbsp; are accepted short forms for the command &quot;capital&quot;.
<LI>(GUI only) indicates that this command is only available in a GUI debugger.
<LI>(character-based) indicates that this command is only available in a character mode debugger.
<LI>&lt;expr&gt; indicates an expression.&nbsp; These may include any of the variables, etc in the program being debugged,
and are evaluated in the current program context.&nbsp; See <A HREF="#Open_Watcom_Debugger_Expression_Handling">Open Watcom Debugger Expression Handling</A>.
<LI>&lt;integer&gt; is an integer constant
<LI>&lt;intexpr&gt; is an an expression which evaluates to an integral value.&nbsp; See <A HREF="#Open_Watcom_Debugger_Expression_Handling">Open Watcom Debugger Expression Handling</A>.
<LI>&lt;command&gt; is any debugger command or group of debugger commands.
<BR><BR>You can group debugger commands with braces and separate them with semi-colons.&nbsp; The resulting compound command
may be considered as an atomic command.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {&lt;command&gt;;&lt;command&gt;;&lt;command&gt;}</TT>
<LI>&lt;address&gt; is any expression which evaluates to an address.&nbsp; See <A HREF="#Open_Watcom_Debugger_Expression_Handling">Open Watcom Debugger Expression Handling</A>.
<LI>&lt;string&gt; is a string of text, optionally enclosed in braces.&nbsp; For example,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; this_is_a_string</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {so is this}</TT>
<LI>&lt;wndname&gt; is the name of a window.&nbsp; Valid window names (with acceptable short forms indicated in capitals)
are:
<UL>
<LI>ASsembly
<LI>ALl
<LI>BReak
<LI>Calls
<LI>Watch
<LI>FIle
<LI>FPu
<LI>FUnctions
<LI>FILEScope
<LI>LOCals
<LI>LOG
<LI>MEmory
<LI>MOdules
<LI>Register
<LI>SOurce
<LI>STack
<LI>Thread
<LI>IO
<LI>Globals
<LI>Variable
<LI>BInary
<LI>IMage
<LI>GLobalfunctions
<LI>Accelerators
<LI>TMPFile
<LI>REPlay
<LI>CUrrent
</UL>
<LI>&lt;file&gt; represents any valid operating system file name.&nbsp; For example,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; c:\autoexec.bat</TT>
<LI>&lt;path&gt; represents any valid operating system directory path.&nbsp; For example,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; c:\dir1\dir2</TT>
</UL>
<H2 ID="Command_Summary"> Command Summary </H2>
<BR>A summary of each command follows.
<H3 ID="Accelerate"> Accelerate </H3>
<BR>This command behaves as if a menu item from the main menu was selected:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Accelerate main &lt;menu&gt; {&lt;menu_string&gt;}</TT>
<BR><BR>This command behaves as if the named menu item in the floating pop-up menu for the current window was selected:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Accelerate {&lt;menu_string&gt;}</TT>
<DL>
<DT>&lt;menu&gt;
<DD>the string appearing on the main menu bar (File, Run, Break, Code, etc)
<DT>&lt;menu_string&gt;
<DD>is enough of the text appearing in a menu to uniquely identify it.
</DL>
<BR>For example:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; accelerate main run {until return}</TT>
<BR><BR>behaves as if &quot;Until return&quot; is selected from the run menu
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; accelerate {Home}</TT>
<BR><BR>behaves as if &quot;home&quot; were picked from the floating pop-up menu of the current window.
<H3 ID="Break"> Break </H3>
<BR>This command prints a list of all breakpoints into the log window:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Break</TT>
<BR><BR>This command sets a break point.&nbsp; See the section entitled <A HREF="#Breakpoints">Breakpoints</A> for details
about breakpoint operation.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Break [|/Set|/Byte|/Word|/DWord|/Modify]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;address&gt; [ {&lt;do_command&gt;}
[ { &lt;condition&gt; } [ &lt;countdown&gt; ]]]</TT>
<BR><BR>This command deactivates a breakpoint:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Break/Deactivate &lt;brkid&gt;</TT>
<BR><BR>This command enables a breakpoint:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Break/Activate &lt;brkid&gt;</TT>
<BR><BR>This command clears a breakpoint:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Break/Clear &lt;brkid&gt;</TT>
<BR><BR>This command toggles a breakpoint through the active/inactive/deleted states:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Break/Toggle &lt;brkid&gt;</TT>
<BR><BR>This command turns on the resume option in the breakpoint:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Break/Resume &lt;brkid&gt;</TT>
<BR><BR>This command turns off the resume option in the breakpoint:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Break/UnResume &lt;brkid&gt;</TT>
<BR><BR>This command turns on/off the breakpoint for appropriate image(DLL) load:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Break/Image [/Clear] &lt;image(DLL) name&gt;</TT>
<BR><BR>The Break options are:
<DL>
<DT>/Set (default)
<DD>the breakpoint triggers when &lt;address&gt; is executed
<DT>/Byte
<DD>the breakpoint triggers when the byte at &lt;address&gt; is modified
<DT>/Word
<DD>the breakpoint triggers when the word at &lt;address&gt; is modified
<DT>/DWord
<DD>the breakpoint triggers when the double word at &lt;address&gt; is modified
<DT>/Modify
<DD>the breakpoint triggers when integer at &lt;address&gt; is modified
<DT>&lt;condition&gt;
<DD>an expression that must be true (non-zero value) before the breakpoint stops program execution
<DT>&lt;countdown&gt;
<DD>an integer.&nbsp; The breakpoint will not stop program execution until &lt;countdown&gt; is decremented to zero.
<DL>
<DT>Note:
<DD>If you specify both &lt;condition&gt; and &lt;countdown&gt;, &lt;countdown&gt; decrements only when &lt;condition&gt; evaluates
to true.
</DL>
<DT>&lt;do_command&gt;
<DD>a command that is executed each time the breakpoint stops program execution
<DT>&lt;brkid&gt;
<DD>option can be three possible values:
<DL>
<DT>&lt;address&gt;
<DD>Perform the operation on breakpoint with the given address.
<DT>*
<DD>Perform the operation on all breakpoints.
<DT>#&lt;integer&gt;
<DD>Names a breakpoint by its index.&nbsp; This index can be discovered on the title line of the Breakpoint dialog.
</DL>
</DL>
<BR>Some examples of the break command and a description follow:
<BR><BR>This command sets a breakpoint at &quot;foo&quot; the 20th time that i equals 10.&nbsp; When this occurs 'do j7' is
executed:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Break /Set foo {do j7} {i10} 20</TT>
<BR><BR>This command clears the breakpoint at foo:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Break /Clear foo</TT>
<BR><BR>This command activates breakpoint #1:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Break /Activate #1</TT>
<BR><BR>This command deactivates all breakpoints:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Break /Deactivate *</TT>
<H3 ID="Call"> Call </H3>
<BR>Use the Call command to call a routine.&nbsp; The Call command options are:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Call [/Far|/Interrupt|/Near]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;address&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [([&lt;parm&gt;[,&lt;parm&gt;[...]]])]
[/|&lt;printlist&gt;]</TT>
<BR><BR>This command calls the routine at &lt;address&gt; with parameters.
<DL>
<DT>/Far
<DD>Use a far call instruction.
<DT>/Near
<DD>Use a near call instruction.
<DT>/Interrupt
<DD>Call the routine as if it were an interrupt handler.
<DT>&lt;parm&gt;
<DD>is [/&lt;location&gt;] &lt;expr&gt;
<DT>&lt;location&gt;
<DD>is [/|&lt;regset&gt;]
<DL>
<DT>/
<DD>means to put the parm on the stack.
<DT>/&lt;regset&gt;
<DD>means to put the parm into the named registers.
<DT>&lt;regset&gt; is a register aggregate.
<DD>See <A HREF="#Open_Watcom_Debugger_Expression_Handling">Open Watcom Debugger Expression Handling</A>.
</DL>
<DT>&lt;printlist&gt;
<DD>See the print command for details.
</DL>
<BR>Some examples of the Call command follow:&nbsp; This command calls the function foo:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; call foo</TT>
<BR><BR>This command calls the function bar passing the parameters 1, 2, and 3:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; call bar( 1,2,3 )</TT>
<BR><BR>This command calls foo putting 1 on the stack, 2 in AX and 3 in CX:BX printing out the value of AX and DX in decimal
and hexadecimal respectively on return:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; call /near foo( // 1, /ax 2, /[cx bx] 3 ) {%d %x} ax,dx</TT>
<BR><BR>The Call command only uses very basic symbolic information - it's designed that way so that it can work even when
no symbolic information is available.&nbsp; This has a number of implications.&nbsp; The first is that the debugger pays no
attention to any information on where parameters are stored.&nbsp; For example, in 32-bit applications, unless explictly instructed
otherwise, the first parm is placed in EAX, the second in EDX, and so on (as defined by the &quot;set call&quot; command).
&nbsp;That means that you have to do something like:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; call foo( // &amp;a, // 3 )</TT>
<BR><BR>to get things on to the stack.&nbsp; This leads to a second, very important consideration.
<BR><BR>The debugger has no idea of the memory model that the program is compiled in (recall that the 32-bit compiler does
support large memory models and far pointers, even if we don't supply versions of the libraries for it).&nbsp; That means
that the debugger has no idea on whether the address of a symbol should be far or near.&nbsp; It always assumes far, since
that never loses information.&nbsp; A far pointer would be truncated to a near pointer when moved into a 32-bit register like
EAX but not so when pushed onto the stack.&nbsp; In this case,<TT> // &amp;a</TT> and<TT> // 3</TT> cause 48-bit far pointers
to be pushed onto the stack (they are actually pushed as 64 bits for alignment reasons).&nbsp; Thus the pointer to<TT> b</TT>
is in the wrong place for the routine to access it (assuming it is expecting near pointers) and this will likely cause a task
exception.&nbsp; To avoid this problem and properly pass arguments to the routine, you need to do the following:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; call foo( // (void near *)&amp;a, // (void near *)3 )</TT>
<BR><BR>This forces the debugger to push near pointers onto the stack.
<BR><BR>Similar considerations apply for the 16-bit case.
<H3 ID="CAPture"> CAPture </H3>
<BR>Use the Capture command to execute a command and put the resulting program output into a window.&nbsp; The format of the
command follows:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CAPture &lt;command&gt;</TT>
<BR><BR>For example, this command calls a routine, foo, and puts its output into a debugger window.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; capture call foo</TT>
<H3 ID="COnfigfile"> COnfigfile </H3>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; COnfigfile</TT>
<BR><BR>Used by the debugger to save and restore the configuration.&nbsp; When &quot;configfile&quot; appears in a command
file, it identifies that file as the default configuration file.&nbsp; The debugger will overwrite the command file when autosaving
the current configuration.&nbsp; Also, the name of this file is displayed in the filename field when the &quot;Save Setup&quot;
dialog initially appears.
<BR><BR>If more than one file is encountered containing the &quot;configfile&quot; command, the last one seen is used to establish
the configuration file name.
<H3 ID="Display"> Display </H3>
<BR>The display command allows you to open any window.&nbsp; The general Display command is:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Display &lt;wndname&gt; [/Open|/Close|/New|/MInimize|/MAximize|/Restore] [&lt;ord&gt;,&lt;ord&gt;,&lt;ord&gt;,&lt;ord&gt;]</TT>
<BR><BR>This command causes the debugger screen to repaint:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Display</TT>
<BR><BR>This command displays the toolbar as either fixed (default) or floating:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Display TOolbar [/Open] [/FLoating/Fixed] [&lt;ord&gt;]</TT>
<BR><BR>This command closes the toolbar:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Display TOolbar [/Close]</TT>
<BR><BR>This command opens the status line:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Display Status [/Open]</TT>
<BR><BR>This command closes the status line:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Display Status /Close</TT>
<BR><BR>This command brings a window to the front:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Display &lt;wndname&gt;</TT>
<BR><BR>The options for the Display command follow:
<DL>
<DT>&lt;ord&gt;
<DD>The height to be used for toolbar buttons.
<DT>&lt;ord&gt;,&lt;ord&gt;,&lt;ord&gt;,&lt;ord&gt;
<DD>These are the x and y coordinates of the top left corner, and the width and the height of the window respectively.&nbsp; 0,0,10000,10000
is a window covering the entire screen.
<DT>/Open
<DD>Open a new window or resize an existing one.
<DT>/New
<DD>Open a new window regardless of an existing one.
<DT>/Close
<DD>Close the window.
<DT>/MInimize
<DD>Iconize the window.
<DT>/MAximize
<DD>Make the window full screen size.
<DT>/REstore
<DD>Restore a window from a minimize or maximize.
</DL>
<BR>Some examples of the display command follow:&nbsp; This command opens a register window in the top left quarter of the
screen:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; display register /open 0,0,5000,5000</TT>
<BR><BR>This command minimizes the source window if it is open:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; display source /minimize</TT>
<H3 ID="DO_Lor_DR"> DO (or /) </H3>
<BR>Use the DO command to evaluate an arbitrary C/C++ or FORTRAN expression.&nbsp; The format of the command is:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DO &lt;expr&gt;</TT>
<BR><BR>For example:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DO i = 10</TT>
<H3 ID="ERror"> ERror </H3>
<BR>Use the Error command to display a string as an error message.&nbsp; The format of the command is:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ERror &lt;string&gt;</TT>
<BR><BR>For example:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; error {An error has been detected}</TT>
<H3 ID="Examine"> Examine </H3>
<BR>Use the Examine command to examine memory at a specific address.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Examine [/&lt;type&gt;] [&lt;address&gt;] [,&lt;follow&gt; [,&lt;len&gt;]]</TT>
<BR><BR>where &quot;&lt;type&gt;&quot; is one of
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Byte</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Word</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Dword</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Qword</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Char</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Short</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Long</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; __int64</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Unsigned_Char</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Unsigned_Short</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Unsigned_Long</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Unsigned___int64</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0:16_Pointer</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 16:16_Pointer</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0:32_Pointer</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 16:32_Pointer</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Float</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Double</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Extended_Float</TT>
<BR><BR>To show an assembly window at a specific address:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Examine /Assembly [&lt;address&gt;]</TT>
<BR><BR>To show a source window at a specific address
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Examine /Source [&lt;address&gt;]</TT>
<BR><BR>To add an address to the I/O window as a byte, word, or dword:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Examine [/IOByte|/IOWord|/IODword] [&lt;address&gt;]</TT>
<BR><BR>The options for the Examine command follow:
<DL>
<DT>/&lt;type&gt;
<DD>where &quot;&lt;type&gt;&quot; is one of<TT> Byte, Word, Dword, Qword, Char, Short, Long, __int64, Unsigned_Char, Unsigned_Short,
Unsigned_Long, Unsigned___int64, 0:16_Pointer, 16:16_Pointer, 0:32_Pointer, 16:32_Pointer, Float, Double,</TT> or<TT> Extended_Float.</TT>
&nbsp;Set the initial display type of the memory window.
<DT>/IOByte /IOWord /IODword
<DD>Set the initial display type of the line in the I/O window.
<DT>&lt;address&gt;
<DD>the address to examine.
<DT>&lt;follow&gt;
<DD>an expression which will be used if the memory window's Repeat function is chosen.
<DT>&lt;len&gt;
<DD>an integer expression indicating the length of memory to examine.
</DL>
<BR>For example, this command opens a memory window positioned at the address of &quot;foo&quot;.&nbsp; The initial display
type will be 2 byte words.&nbsp; If the<B><I> Repeat</I></B> menu item is used, it will follow a near pointer 4 bytes past
the beginning of the window *(.+$).&nbsp; The window will display 16 bytes of data at a time:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; examine /word foo,*(.+4),16</TT>
<H3 ID="Flip"> Flip </H3>
<BR>Use the Flip command to configure screen flipping.&nbsp; See the section entitled <A HREF="#The_Options_Dialog">The Options Dialog</A>
for details
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Flip ON</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Flip OFf</TT>
<H3 ID="FOnt"> FOnt </H3>
<BR>Use the Font command to set the font for the specified window.&nbsp; The command is:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; FOnt &lt;wndname&gt; &lt;fontinfo&gt;</TT>
<DL>
<DT>&lt;wndname&gt;
<DD>the name of the affected window
<DT>&lt;fontinfo&gt;
<DD>operating system specific font data.
</DL>
<H3 ID="Go"> Go </H3>
<BR>Use the Go command to start or continue program execution.&nbsp; Execution then resumes at the specified address or at
the location defined by the current contents of the CS:IP or CS:EIP register pair.&nbsp; The format of the Go command is:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Go [/Until] [/Keep] [/Noflip] [[&lt;start&gt;,]&lt;stop&gt;]</TT>
<BR><BR>The options are:
<DL>
<DT>/Until
<DD>skips breakpoints until the specified stop address is reached.
<DT>/Keep
<DD>allows you to keep a previous temporary breakpoint.&nbsp; If you keep the previous breakpoint you cannot create a new one.
<DT>/Noflip
<DD>keeps the debugger from flipping to the application's screen.
<DT>&lt;start&gt;
<DD>the &lt;address&gt; at which to start execution (optional).
<DT>&lt;stop&gt;
<DD>the &lt;address&gt; at which to stop execution.
</DL>
<BR>Some examples of the Go command are:
<BR><BR>This command will resume execution until function &quot;foo&quot; is executed without flipping to the application
screen:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; go /noflip foo</TT>
<BR><BR>This command starts execution at &quot;foo&quot; and runs until &quot;bar&quot; is executed.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; go foo,bar</TT>
<H3 ID="Help"> Help </H3>
<BR>Bring up the help screen:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Help</TT>
<H3 ID="HOok"> HOok </H3>
<BR>Use the Hook command to execute a command when a defined event occurs.&nbsp; The format of the Hook command is:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; HOok &lt;event&gt; &lt;command&gt;</TT>
<BR><BR>&lt;event&gt; can be any of the following:
<DL>
<DT>PROGStart
<DD>a program is loaded
<DT>PROGEnd
<DD>a program terminates
<DT>DLLStart
<DD>a DLL is loaded
<DT>DLLEnd
<DD>a DLL is unloaded
<DT>EXECStart
<DD>program execution is beginning
<DT>EXECEnd
<DD>program execution is stopped
<DT>Sourceinfo
<DD>the current location being examined has debugging information
<DT>Assemblyinfo
<DD>the current location being examined has no debugging information
<DT>Modulechange
<DD>the current location being examined has changed modules
</DL>
<BR>This example causes the locals and source window to come to the front whenever a region with symbolic debugging information
is entered:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; hook sourceinfo {display locals; display source}</TT>
<H3 ID="IF"> IF </H3>
<BR>Use the If command to evaluate an expression and then, depending on the results, execute a list of commands.&nbsp; The
format of the If command is:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; IF &lt;expr&gt; { &lt;command&gt; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [ ELSEIF &lt;expr&gt; { &lt;command&gt; } [ ELSEIF &lt;expr&gt; { &lt;command&gt; } [...]]]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [ELSE { &lt;command&gt; }]</TT>
<BR><BR>If the expression results in a non-zero value, the list of debugger commands contained after the IF expression are
executed.&nbsp; Otherwise, the list of commands that appear after the ELSEIF expression are executed.
<H3 ID="INvoke_Lor_XR"> INvoke (or &lt;) </H3>
<BR>Use the Invoke command to invoke a file containing a number of debugger commands.&nbsp; The format of the Invoke command
is:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; INvoke &lt;file&gt; [&lt;string&gt; [&lt;string&gt; [...]]]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;file&gt; [&lt;string&gt; [&lt;string&gt; [...]]]</TT>
<DL>
<DT>&lt;file&gt;
<DD>is the name of the command file to invoke.
<DT>&lt;string&gt;
<DD>will be passed as a parameter.&nbsp; These parameters may be referenced in the command file as &lt;1&gt;, &lt;2&gt;, etc.
</DL>
<H3 ID="Log_Lor_YR"> Log (or &gt;) </H3>
<BR>Use the Log command to send the Dialog window output to a specified file.&nbsp; The following commands start logging to
a file:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Log&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;file&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Log /Start &lt;file&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;file&gt;</TT>
<BR><BR>The following commands start appending log information to a file.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Log &gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;file&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &gt;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;file&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Log /Append &lt;file&gt;</TT>
<BR><BR>The following commands stop logging:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Log</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &gt;</TT>
<H3 ID="MOdify"> MOdify </H3>
<BR>Use the Modify command to change memory at an address to the values specified by the list of expressions.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; MOdify [/Byte|/Pointer|/Word|/Dword|/IOByte|/IOWord|/IODword] &lt;address&gt;[,&lt;expr&gt;[...]]</TT>
<BR><BR>The options for the modify command are:
<DL>
<DT>/Byte /Pointer /Word /Dword
<DD>Control the size of memory to be modified.
<DT>/IOByte /IOWord /IODword
<DD>Control the size of the I/O port to be modified.
<DT>&lt;address&gt;
<DD>The address to modify.
<DT>&lt;expr&gt;
<DD>The values to be placed in memory.
</DL>
<BR>This command changes the 3 bytes at location &quot;foo&quot; to the values 1, 2 and 3:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; modify /byte foo 1,2,3</TT>
<BR><BR>This command changes the 4 bytes at location &quot;foo&quot; to the value 12345678 hex:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; modify /dword foo 0x12345678</TT>
<H3 ID="NEW"> NEW </H3>
<BR>Use the New command to initialize various items.&nbsp; The format of the New command is:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; NEW [&lt;args&gt;]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; NEW /Program [[:&lt;symfile&gt;] &lt;progfile&gt; [&lt;args&gt;]]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; NEW /Restart [&lt;args&gt;]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; NEW /STDIn &lt;file&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; NEW /STDOut &lt;file&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; NEW /SYmbol &lt;file&gt; [seg [,seg [...]]</TT>
<DL>
<DT>&lt;symfile&gt;
<DD>represents a file containing the symbolic information.
<DT>&lt;progfile&gt;
<DD>represents the executable file.
<DT>&lt;args&gt;
<DD>represent the arguments to be passed to the program.
<DT>/Restart
<DD>Reload the current application and place it into an initial state so that you may begin execution again.&nbsp; The application
may have already partially or completely executed.
<DT>/STDIn
<DD>associate the standard input file handle with a particular file or device.
<DT>/STDOut
<DD>associate the standard output file handle with a particular file or device.
<DT>/Symbol
<DD>load additional symbolic debugging information and specify the mapping between the linker addresses and the actual execution
addresses.
</DL>
<H3 ID="PAint"> PAint </H3>
<BR>Use the Paint command to define window or dialog colours.&nbsp; To define the colour for windows, use the following command:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; PAint [Status|&lt;wndname&gt;] &lt;wndattr&gt; &lt;color&gt; ON &lt;color&gt;</TT>
<BR><BR>To define the colour for dialogs in the character-based version of the debugger, use the following command:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; PAint DIalog &lt;dlgattr&gt; &lt;color&gt; ON &lt;color&gt;</TT>
<BR><BR>The paint options are as follows:
<DL>
<DT>&lt;wndattr&gt;
<DD>allows you to define the window attributes.&nbsp; You can choose from the following items:
<DL>
<DT>MEnu Plain
<DD>menu text (character-based)
<DT>MEnu STandout
<DD>menu accelerator key (character-based)
<DT>MEnu Disabled
<DD>grayed menu item (character-based)
<DT>MEnu Active
<DD>menu item under the cursor (character-based)
<DT>MEnu Active STandout
<DD>menu accelerator key under the cursor (character-based)
<DT>MEnu Frame
<DD>frame of the menu (character-based)
<DT>MEnu Disabled Active
<DD>grayed menu item under the cursor (character-based)
<DT>TItle Disabled
<DD>a non active window's title
<DT>Frame Active
<DD>the frame of the active window (character-based)
<DT>Frame Disabled
<DD>the frame an inactive window (character-based)
<DT>ICon
<DD>an icon
<DT>Plain
<DD>normal text within a window
<DT>Active
<DD>window text under the cursor
<DT>SElected
<DD>window text being selected
<DT>STandout
<DD>window text the debugger wishes to highlight
<DT>Active STandout
<DD>window text the debugger wishes to highlight under the cursor
<DT>BUtton
<DD>the gadgets on the left side of a window (character-based)
</DL>
<DT>&lt;dlgattr&gt;
<DD>option allows you to define the dialog attributes.&nbsp; The possible options are:
<DL>
<DT>Plain
<DD>normal text
<DT>Frame
<DD>the dialog frame
<DT>SHadow
<DD>the shadow of a button
<DT>BUtton Plain
<DD>normal button text
<DT>BUtton STandout
<DD>button accelerator key character
<DT>BUtton Active
<DD>a button which has focus
<DT>BUtton Active STandout
<DD>button accelerator key character of a button with focus
</DL>
<DT>&lt;color&gt;
<DD>You can choose from the following colours:
<UL>
<LI>BLAck
<LI>BLUe
<LI>GREEn
<LI>Cyan
<LI>Red
<LI>MAgenta
<LI>BROwn
<LI>White
<LI>GREY
<LI>GRAy
<LI>BRIght BLUe
<LI>BRIght GREEn
<LI>BRIght Cyan
<LI>BRIght Red
<LI>BRIght MAgenta
<LI>Yellow
<LI>BRIght BROwn
<LI>BRIght White
</UL>
</DL>
<BR>Some examples of the paint command follow:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; paint all plain black on white</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; paints plain text black on white in all windows.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; paint dialog button standout bright green on yellow</TT>
<H3 ID="Print_Lor__R"> Print (or ?) </H3>
<BR>Use the Print command to prompt for an expression and then print it to the log window.&nbsp; Use this command to examine
the values of variables and expressions.&nbsp; The Print command is:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Print [/Program] [&lt;printlist&gt;]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Print /Window [&lt;exprlist&gt;]</TT>
<DL>
<DT>/Window
<DD>opens up a watch window containing the listed expressions.
<DT>/Program
<DD>print the results to the application's screen.
<DT>&lt;printlist&gt;
<DD>is [&lt;format&gt;] [&lt;exprlist&gt;]
<DT>&lt;exprlist&gt;
<DD>is [&lt;expr&gt; [,&lt;expr&gt; [...]]]
<DT>&lt;format&gt;
<DD>is a printf like format string.&nbsp; It consists of plain text intermixed with control sequences, which will be substituted
with values from the expression list.&nbsp; The control sequences are:
<DL>
<DT>%i
<DD>The corresponding argument is printed out as a signed decimal integer value.
<DT>%d
<DD>The corresponding argument is printed out as a signed decimal integer value.
<DT>%u
<DD>The corresponding argument is printed out as an unsigned decimal integer value.
<DT>%x
<DD>The corresponding argument is printed out as an unsigned hexadecimal integer value.&nbsp; Letter digits are printed in lower
case (a-f).
<DT>%X
<DD>The corresponding argument is printed out as an unsigned hexadecimal integer value.&nbsp; Letter digits are printed in upper
case (A-F).
<DT>%o
<DD>The corresponding argument is printed out as an unsigned octal integer value.
<DT>%p
<DD>The corresponding argument is printed out as a pointer (segment:offset) value in hexadecimal notation.
<DT>%c
<DD>The corresponding argument is printed out as a single character value.
<DT>%s
<DD>The corresponding argument is printed out as a C/C++ string value.&nbsp; The argument must point to a string of characters
terminated by a byte whose value is zero.
<DT>%%
<DD>To print out a percentage symbol, the &quot;%&quot; must be doubled up (i.e., %%).
<DT>%f
<DD>The corresponding argument is printed out in floating-point representation.&nbsp; If the floating-point value has a very large
or small magnitude, you should use one of &quot;g&quot;, &quot;G&quot;, &quot;e&quot; or &quot;E&quot; formatting.
<DT>%g
<DD>The corresponding argument is printed out in floating-point representation.&nbsp; Numbers of very large or small magnitude
are printed out in scientific &quot;E&quot; notation (e.g., 1.54352e+16).&nbsp; The exponent letter is printed in lower case.
<DT>%G
<DD>The corresponding argument is printed out in floating-point representation.&nbsp; Numbers of very large or small magnitude
are printed out in scientific &quot;E&quot; notation (e.g., 1.54352E+16).&nbsp; The exponent letter is printed in upper case.
<DT>%e
<DD>The corresponding argument is printed out in scientific &quot;E&quot; notation (e.g., 1.23456e+02).&nbsp; The exponent letter
is printed in lower case.
<DT>%E
<DD>The corresponding argument is printed out in scientific &quot;E&quot; notation (e.g., 1.23456E+02).&nbsp; The exponent letter
is printed in upper case.
<DT>%r
<DD>The corresponding argument is printed out in the current default numeric radix.
<DT>%a
<DD>The corresponding argument is printed out as a symbol reference (symbol_name+offset) when possible; otherwise it is printed
out as a pointer (segment:offset) value in hexadecimal notation.
<DT>%l
<DD>The corresponding argument is printed out as a line number reference (module_name@line_number+offset) when possible; otherwise
it is printed out as a pointer (segment:offset) value in hexadecimal notation.
</DL>
</DL>
<BR>Some examples of the print command follow.&nbsp; This command prints the value of &quot;i&quot;:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ? i</TT>
<BR><BR>This command prints &quot;decimal=100 hex=0x64&quot;:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; print {decimal=%d hex=%x} 100,100</TT>
<BR><BR>This command opens a watch window and displays the value of argv[0]:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; print/window argv[0]</TT>
<H3 ID="Quit"> Quit </H3>
<BR>Use the Quit command to leave the debugger.
<H3 ID="RECord"> RECord </H3>
<BR>Use the Record command to add a command to the replay window.&nbsp; This command is for internal use only.&nbsp; The format
of the command is:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; REcord&lt;expr&gt; &lt;command&gt;</TT>
<H3 ID="Register"> Register </H3>
<BR>The format of the Register command is:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Register &lt;intexpr&gt;</TT>
<BR><BR>If intexpr is negative, this is equivalent to using the menu item Undo/Undo -&lt;intexpr&gt; times.&nbsp; If intexpr
is positive, this is equivalent to using the menu item Undo/Redo &lt;intexpr&gt; times.
<H3 ID="REMark_Lor_TR"> REMark (or *) </H3>
<BR>Use the Remark command to enter lines of comments.&nbsp; The format of the command is:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; REMark &lt;string&gt;</TT>
<H3 ID="Set"> Set </H3>
<BR>These commands are used internally by the debugger to save and restore the configuration.&nbsp; The syntax is:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Set AUtosave [ON|OFf]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Set ASsembly [Lower|Upper] [Outside|Inside] [Source|NOSource] [Hexadecimal|Decimal]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Set Variable [Entire|Partial] [CODe|NOCODe] [INherit|NOINherit] [COMpiler|NOCOMpiler] [PRIvate|NOPRIvate]
[PROtected|NOPROTected] [Members|NOMembers]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Set FUnctions [Typed|All]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Set GLobals [Typed|All]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Set REGister [Hexadecimal|Decimal] [Extended|Normal]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Set Fpu [Hexadecimal|Decimal]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Set BEll [ON|OFf]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Set BReakonwrite [ON|OFf]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Set Call [/Far|/Interrupt|/Near] [ ( [&lt;location&gt; [,&lt;location&gt; [...]]] ) ]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Set Dclick &lt;expr&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Set Implicit [ON|OFf]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Set INput &lt;wndname&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Set Radix &lt;expr&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Set RECursion [ON|OFf]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Set SEarch [CASEIgnore|CASEREspect] [Rx|NORx] &lt;string&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Set SOurce [/Add] [&lt;path&gt; [&lt;path&gt;] [...]]]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Set SYmbol [/Add|/Ignore|/Respect] [&lt;lookspec&gt; [&lt;lookspec&gt; [...]]]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Set Tab &lt;intexpr&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Set Level [Assembly|Mixed|Source]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Set LAnguage [CPP|C|FORTRAN]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Set SUpportroutine &lt;string&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Set MAcro &lt;wndname&gt; &lt;key&gt; &lt;command&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Set DOntexpandhex [ON|OFf]</TT>
<DL>
<DT>&lt;location&gt;
<DD>see call command.
<DT>&lt;lookspec&gt;
<DD>[/Ignore|/Respect] &lt;string&gt;
</DL>
<H3 ID="SHow"> SHow </H3>
<BR>The Show commands are used internally by the debugger to save and restore its configuration.&nbsp; The syntax is:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SHow Paint</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SHow Display</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SHow Font</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SHow Set</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SHow Set AUtosave</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SHow Set ASsembly</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SHow Set Variable</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SHow Set FUnctions</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SHow Set GLobals</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SHow Set REGister</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SHow Set Fpu</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SHow Set BEll</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SHow Set BReakonwrite</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SHow Set Call</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SHow Set Dclick</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SHow Set Implicit</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SHow Set INput</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SHow Set Radix</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SHow Set RECursion</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SHow Set SEarch</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SHow Set SOurce</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SHow Set SYmbol</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SHow Set Tab</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SHow Set Level</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SHow Set LAnguage</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SHow Set MAcro</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SHow Set SUpportroutine</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SHow Flip</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SHow Hook</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SHOW DOntexpandhex</TT>
<H3 ID="SKip"> SKip </H3>
<BR>Use the Skip command to set CS:EIP to a specific address.&nbsp; The format of the command is:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SKip &lt;address&gt;</TT>
<H3 ID="STackpos_XintexprY"> STackpos &lt;intexpr&gt; </H3>
<BR>The Stackpos command is the same as using Undo/Unwind.&nbsp; The &lt;intexpr&gt; allows you to define the number of times
to undo or unwind.
<H3 ID="SYstem_Lor__R"> SYstem (or !) </H3>
<BR>Use the System command to spawn an operating shell to execute a given string.&nbsp; The format of the system command is:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SYstem [/Remote|/Local] &lt;string&gt;</TT>
<DL>
<DT>/Remote
<DD>the shell is started on the program side of a remote debug link.
<DT>/Local
<DD>the shell is started on the debugger side of a remote debug link.
</DL>
<H3 ID="THread_Lor___R"> THread (or ~) </H3>
<BR>Use the Thread command to manipulate the threads of execution of a multi-threaded application under OS/2 or NetWare 386.
&nbsp;The format of the Thread command is:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; THread [/Show|/Freeze|/Thaw|/Change] [&lt;threadid&gt;]</TT>
<DL>
<DT>/Show
<DD>display the status of the current thread.
<DT>/Freeze
<DD>freeze a thread and make it unrunnable.
<DT>/Thaw
<DD>make a frozen thread runnable.
<DT>/Change
<DD>to select a specific thread.
<DT>&lt;threadid&gt;
<DD>is the identification number of the thread.
</DL>
<H3 ID="Trace"> Trace </H3>
<BR>Use the Trace command to step through the execution of your program.&nbsp; The Trace command is:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Trace [/Assembly|/Mixed|/Source] [/Into|/Next|/Over]</TT>
<DL>
<DT>/Assembly
<DD>trace through your assembly code on instruction at a time.
<DT>/Mixed
<DD>trace execution of the application one source statement at a time, or one instruction at a time when no source text is available.
<DT>/Source
<DD>trace execution of the application one source statement at a time.
<DT>/Into
<DD>continue execution to the next statement or assembly instruction.&nbsp; If the current statement or instruction invokes a
routine, then the next statement or instruction is the first one called in the routing.
<DT>/Next
<DD>continue execution to the next statement or assembly instruction that immediately follows the current statement or instruction
in memory.&nbsp; If the current statement or instruction is one that branches, be sure that the execution path eventually
executed the statement or instruction that follows.&nbsp; If the program does not executed this point, the program may execute
to completion.
<DT>/Over
<DD>continue execution to the next statement or assembly instruction.&nbsp; If the current statement or instruction invokes a
routine, then the next statement or instruction is the one that follows the invocation of the routine.
</DL>
<H3 ID="Undo"> Undo </H3>
<BR>The format of the Undo command is:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Undo &lt;intexpr&gt;</TT>
<BR><BR>If intexpr is positive, this is equivalent to using the menu item Undo/Undo &lt;intexpr&gt; times.&nbsp; If intexpr
is negative, this is equivalent to using the menu item Undo/Redo -&lt;intexpr&gt; times.
<H3 ID="View"> View </H3>
<BR>Use the View command to show a file in a window.&nbsp; The format of the command is:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; View [/Binary] [&lt;file&gt;|&lt;module&gt;]</TT>
<DL>
<DT>/Binary
<DD>show the file contents in binary.
<DT>&lt;file&gt;
<DD>the file to be shown.
<DT>&lt;module&gt;
<DD>the module to be shown.&nbsp; The default is the current module.
</DL>
<H3 ID="While"> While </H3>
<BR>Use the While command to permit the execution of a list of commands while the specified expression is true.&nbsp; The
While command is:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; While &lt;expr&gt; { &lt;command&gt; }</TT>
<H3 ID="WIndow"> WIndow </H3>
<BR>This command operates on the current window.&nbsp; It is useful when defining accelerators that perform window operations.
<DL>
<DT>WIndow CLose
<DD>close the window
<DT>WIndow CURSORStart
<DD>move the cursor to start of line
<DT>WIndow CURSOREnd
<DD>move the cursor to end of line
<DT>WIndow CURSORDown
<DD>move the cursor down one line
<DT>WIndow CURSORLeft
<DD>move the cursor left
<DT>WIndow CURSORRight
<DD>move the cursor right
<DT>WIndow CURSORUp
<DD>move up one line
<DT>WIndow Dump
<DD>dump the window to a file
<DT>WIndow Log
<DD>dump the window to a log window
<DT>WIndow FINDNext
<DD>find the next occurrence of the current search string
<DT>WIndow FINDPrev
<DD>find the previous occurrence of the current search string
<DT>WIndow Next
<DD>make another window the current window
<DT>WIndow PAGEDown
<DD>move the window down one page
<DT>WIndow PAGEUp
<DD>move the window up one page
<DT>WIndow POpup
<DD>show the window's floating pop-up menu
<DT>WIndow SEarch
<DD>search for a given string
<DT>WIndow SCROLLDown
<DD>scroll the window down one line
<DT>WIndow SCROLLUp
<DD>scroll the window up one line
<DT>WIndow SCROLLTop
<DD>scroll the window to the very top
<DT>WIndow SCROLLBottom
<DD>scroll the window to the very bottom
<DT>WIndow TABLeft
<DD>move to the previous tabstop
<DT>WIndow TABRight
<DD>move to the next tabstop
<DT>WIndow MAXimize
<DD>maximize the window
<DT>WIndow MINimize
<DD>minimize the window
<DT>WIndow REStore
<DD>restore the window
<DT>WIndow TIle
<DD>tile all windows
<DT>WIndow CAscade
<DD>cascade all windows
<DT>WIndow PRevious
<DD>move to the previous window
</DL>
<H1 ID="Predefined_Symbols"> Predefined Symbols </H1>
<BR>The Open Watcom Debugger defines a number of symbols which have special meaning.&nbsp; Each of the registers is designated
by a special name.&nbsp; Note that the registers listed here are applicable when the target is an x86 platorm.&nbsp; For other
platforms, the register set is different.
<DL>
<DT>eax
<DD>32-bit EAX register (32-bit mode only)
<DT>ax
<DD>16-bit AX register
<DT>al
<DD>8-bit AL register
<DT>ah
<DD>8-bit AH register
<DT>ebx
<DD>32-bit EBX register (32-bit mode only)
<DT>bx
<DD>16-bit BX register
<DT>bl
<DD>8-bit BL register
<DT>bh
<DD>8-bit BH register
<DT>ecx
<DD>32-bit ECX register (32-bit mode only)
<DT>cx
<DD>16-bit CX register
<DT>cl
<DD>8-bit CL register
<DT>ch
<DD>8-bit CH register
<DT>edx
<DD>32-bit EDX register (32-bit mode only)
<DT>dx
<DD>16-bit DX register
<DT>dl
<DD>8-bit DL register
<DT>dh
<DD>8-bit DH register
<DT>eip
<DD>Instruction pointer register (32-bit mode only)
<DT>ip
<DD>Instruction pointer register
<DT>esi
<DD>Source index register (32-bit mode only)
<DT>si
<DD>Source index register
<DT>edi
<DD>Destination index register (32-bit mode only)
<DT>di
<DD>Destination index register
<DT>esp
<DD>Stack pointer register (32-bit mode only)
<DT>sp
<DD>Stack pointer register
<DT>ebp
<DD>Base pointer register (32-bit mode only)
<DT>bp
<DD>Base pointer register
<DT>cs
<DD>Code segment register
<DT>ds
<DD>Data segment register
<DT>es
<DD>Extra segment register
<DT>fs
<DD>Segment register (32-bit mode only)
<DT>gs
<DD>Segment register (32-bit mode only)
<DT>ss
<DD>Stack segment register
<DT>fl
<DD>Flags register
<DT>efl
<DD>Flags register (32-bit mode only)
<DT>fl.flg_bit_name
<DD>Individual bits in Flags register
<BR><BR><B><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </I></B>
<BR><B><I>&nbsp;&nbsp;&nbsp;&nbsp; flg_bit_name ::= &quot;c&quot; | &quot;p&quot; | &quot;a&quot; | &quot;z&quot; | &quot;s&quot;
| &quot;i&quot; | &quot;d&quot; | &quot;o&quot;</I></B>
<DT>efl.flg_bit_name
<DD>Individual bits in Flags register
<BR><BR><B><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </I></B>
<BR><B><I>&nbsp;&nbsp;&nbsp;&nbsp; flg_bit_name ::= &quot;c&quot; | &quot;p&quot; | &quot;a&quot; | &quot;z&quot; | &quot;s&quot;
| &quot;i&quot; | &quot;d&quot; | &quot;o&quot;</I></B>
<BR><BR>The following table lists the full name for each of the flags register bits:
<DL>
<DT>fl.o, efl.o
<DD>overflow flag
<DT>fl.d, efl.d
<DD>direction flag
<DT>fl.i, efl.i
<DD>interrupt flag
<DT>fl.s, efl.s
<DD>sign flag
<DT>fl.z, efl.z
<DD>zero flag
<DT>fl.a, efl.a
<DD>auxiliary carry flag
<DT>fl.p, efl.p
<DD>parity flag
<DT>fl.c, efl.c
<DD>carry flag
</DL>
<DT>st0 - st7
<DD>Numeric Data Processor registers (math coprocessor registers) 
<DT>cw
<DD>8087 control word (math coprocessor control word)
<DT>cw.cw_bit_name
<DD>Individual bits in the control word
<BR><BR><B><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </I></B>
<BR><B><I>&nbsp;&nbsp;&nbsp;&nbsp; cw_bit_name ::= &quot;ic&quot; | &quot;rc&quot; | &quot;pc&quot; | &quot;iem&quot; | &quot;pm&quot;
|</I></B>
<BR><B><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;um&quot; | &quot;om&quot; | &quot;zm&quot; | &quot;dm&quot; | &quot;im&quot;</I></B>
<BR><BR>The following table lists the full name for each of the control word bits:
<DL>
<DT>cw.ic
<DD>infinity control
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp; 0 = projective
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 1 = affine
<DT>cw.rc
<DD>rounding control (2 bits)
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp; 00 = round to nearest or even
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 01 = round down (towards negative infinity)
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 10 = round up (towards positive infinity)
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 11 = chop (truncate toward zero)
<DT>cw.pc
<DD>precision control (2 bits)
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp; 00 = 24 bits
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 01 = reserved
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 10 = 53 bits
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 11 = 64 bits
<DT>cw.iem
<DD>interrupt enable mask (8087 only)
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp; 0 = interrupts enabled
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 1 = interrupts disabled (masked)
<DT>cw.pm
<DD>precision (inexact result) mask
<DT>cw.um
<DD>underflow mask
<DT>cw.om
<DD>overflow mask
<DT>cw.zm
<DD>zero-divide mask
<DT>cw.dm
<DD>denormalized operand mask
<DT>cw.im
<DD>invalid operand mask
</DL>
<DT>sw
<DD>8087 status word (math coprocessor status word)
<DT>sw.sw_bit_name
<DD>Individual bits in the status word
<BR><BR><B><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </I></B>
<BR><B><I>&nbsp;&nbsp;&nbsp;&nbsp; sw_bit_name ::=&nbsp; &quot;b&quot; | &quot;c3&quot; | &quot;st&quot; | &quot;c2&quot;
| &quot;c1&quot; |</I></B>
<BR><B><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;c0&quot; | &quot;es&quot; | &quot;sf&quot; | &quot;pe&quot; | &quot;ue&quot;
|</I></B>
<BR><B><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;oe&quot; | &quot;ze&quot; | &quot;de&quot; | &quot;ie&quot;</I></B>
<BR><BR>The following table lists the full name for each of the status word bits:
<DL>
<DT>sw.b
<DD>busy
<DT>sw.c3
<DD>condition code bit 3
<DT>sw.st
<DD>stack stop pointer (3 bits)
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp; 000 = register 0 is stack top
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 001 = register 1 is stack top
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 010 = register 2 is stack top
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 111 = register 7 is stack top
<DT>sw.c2
<DD>condition code bit 2
<DT>sw.c1
<DD>condition code bit 1
<DT>sw.c0
<DD>condition code bit 0
<DT>sw.es
<DD>error summary (287, 387 only)
<DT>sw.sf
<DD>stack fault (387 only)
<DT>sw.pe
<DD>precision (inexact result) exception
<DT>sw.ue
<DD>underflow exception
<DT>sw.oe
<DD>overflow exception
<DT>sw.ze
<DD>zero-divide exception
<DT>sw.de
<DD>denormalized operand exception
<DT>sw.ie
<DD>invalid operation exception
</DL>
<DT>mm0 - mm7
<DD>MMX registers
<DL>
<DT>mm0.b0 - mm0.b7
<DD>MMX register component bytes
<DT>mm0.w0 - mm0.w3
<DD>MMX register component words
<DT>mm0.d0 - mm0.d1
<DD>MMX register component doublewords
</DL>
<DT>xmm0 - xmm7
<DD>XMM registers (SSE registers)
<DL>
<DT>xmm0.b0 - xmm0.b15
<DD>XMM register component bytes
<DT>xmm0.w0 - xmm0.w7
<DD>XMM register component words
<DT>xmm0.d0 - xmm0.d3
<DD>XMM register component doublewords
<DT>xmm0.q0 - xmm0.q1
<DD>XMM register component quadwords
</DL>
</DL>
<BR>The debugger permits the manipulation of register contents using any of the operators described in the following chapter.
&nbsp;By default, these predefined names are accessed just like any other variables defined by the user or the application.
&nbsp;Should the situation ever arise where the application defines a variable whose name conflicts with that of one of these
debugger variables, the module specifier<TT> _dbg</TT> may be used to resolve the ambiguity.&nbsp; For example, if the application
defines a variable called<TT> cs</TT> then<TT> _dbg@cs</TT> can be specified to resolve the ambiguity.&nbsp; The &quot;_dbg@&quot;
prefix indicates that we are referring to a debugger defined symbol rather than an application defined symbol.
<BR><BR>The flags register, the 8087 control word, and the 8087 status word can be accessed as a whole or by its component
status bits.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /fl.c=0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /cw.um=0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ?sw.oe</TT>
<BR><BR>In the above example, the &quot;carry&quot; flag is cleared, the 8087 underflow mask of the control word is cleared,
and the 8087 overflow exception bit of the status word is printed.
<BR><BR>The low order bit of the expression result is used to set or clear the specified flag.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; fl.c=0x03a6</TT>
<BR><BR>In the above example, the &quot;carry&quot; flag is cleared since the low order bit of the result is 0.
<BR><BR>Similarly, the MMX and XMM registers can be accessed as a whole or by their component bytes, words, doublewords and
quadwords (in the case of the 128-bit XMM registers).
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /mm0.b1=1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ?mm0.d0</TT>
<BR><BR>In the above example, the second byte of the first MMX register is set to 1, then the first doubleword of the same
register is printed.
<BR><BR>The debugger also defines some other special names.
<DL>
<DT>dbg$32
<DD>This debugger symbol represents the mode in which the processor is running.
<DL>
<DT>0
<DD>16-bit mode
<DT>1
<DD>32-bit mode
</DL>
<DT>dbg$bp
<DD>This debugger symbol represents the register pair SS:BP (16-bit mode) or SS:EBP (32-bit mode).
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ? dbg$bp</TT>
<DT>dbg$code
<DD>This debugger symbol represents the current code location under examination.&nbsp; The dot address &quot;.&quot; is either
set to dbg$code or dbg$data, depending on whether you were last looking at code or data.&nbsp; 
<DT>dbg$cpu
<DD>This debugger symbol represents the type of central processing unit which is in your personal computer system.
<DL>
<DT>0
<DD>Intel 8088, 8086 or compatible processor
<DT>1
<DD>Intel 80188, 80186 or compatible processor
<DT>2
<DD>Intel 80286 or compatible processor
<DT>3
<DD>Intel 80386 or compatible processor
<DT>4
<DD>Intel 80486 or compatible processor
<DT>5
<DD>Intel Pentium processor
<DT>6
<DD>Intel Pentium Pro/II/III processor
<DT>15
<DD>Intel Pentium 4 processor
</DL>
<DT>dbg$ctid
<DD>This debugger symbol represents the identification number of the current execution thread.&nbsp; Under environments which
do not support threading, the current thread ID is always 1.&nbsp; The current execution thread can be selected using the
Thread window or the Thread command.&nbsp; 
<DT>dbg$data
<DD>This debugger symbol represents the current data location under examination.&nbsp; The dot address &quot;.&quot; is either
set to dbg$code or dbg$data, depending on whether you were last looking at code or data.&nbsp; 
<DT>dbg$etid
<DD>This debugger symbol represents the identification number of the thread that was executing when the debugger was entered.
&nbsp;Under environments which do not support threading, the executing thread ID is always 1.&nbsp; 
<DT>dbg$fpu
<DD>This debugger symbol represents the type of numeric data processor (math coprocessor) that is installed in your personal computer
system.
<DL>
<DT>-1
<DD>An 80x87 emulator is installed
<DT>0
<DD>No coprocessor is installed
<DT>1
<DD>An Intel 8087 is installed
<DT>2
<DD>An Intel 80287 is installed
<DT>3
<DD>An Intel 80387 is installed
<DT>4
<DD>An Intel 80486 processor, supporting coprocessor instructions, is installed
<DT>5
<DD>An Intel Pentium processor integrated FPU is installed
<DT>6
<DD>An Intel Pentium Pro/II/III processor integrated FPU is installed
<DT>15
<DD>An Intel Pentium 4 processor integrated FPU is installed
</DL>
<DT>dbg$ip
<DD>This debugger symbol represents the register pair CS:IP (16-bit mode) or CS:EIP (32-bit mode).
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ? dbg$ip</TT>
<DT>dbg$monitor
<DD>This debugger symbol represents the type of monitor adapter which is in use.
<DL>
<DT>0
<DD>IBM Monochrome Adapter
<DT>1
<DD>IBM Colour Graphics Adapter (CGA)
<DT>2
<DD>IBM Enhanced Graphics Adapter (EGA)
<DT>3
<DD>IBM Video Graphics Array (VGA)
</DL>
<DT>dbg$ntid
<DD>This debugger symbol represents the identification number of the next execution thread.&nbsp; To iterate through all of the
threads in a process, you can execute<TT> thread dbg$ntid</TT> repetitively until you are back to the original thread.&nbsp;
Under environments which do not support threading, the next thread ID is always 1.&nbsp; To show the execution stack for all
threads (in the Log window), you can execute the following commands:
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /orig_tid = dbg$ctid</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /curr_tid = dbg$ctid</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; while curr_tid != 0 {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print {----- Next Thread %x -----} curr_tid;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; show calls;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /curr_tid = dbg$ntid;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; thread curr_tid;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( curr_tid == orig_tid ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /curr_tid = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<DT>dbg$os
<DD>This debugger symbol represents the operating system that is currently running the application.
<DL>
<DT>0
<DD>Unknown Operating System
<DT>1
<DD>DOS
<DT>2
<DD>OS/2
<DT>3
<DD>386|DOS-Extender from Phar Lap Software, Inc.
<DT>5
<DD>NetWare 386 from Novell, Inc.
<DT>6
<DD>QNX from QNX Software Systems.
<DT>7
<DD>DOS/4GW from Tenberry Software, Inc., or CauseWay (both included in the Open Watcom C/C++(32) and Open Watcom FORTRAN 77/32
packages)
<DT>8
<DD>Windows 3.x from Microsoft Corporation
<DT>10
<DD>Windows NT/2000/XP or Windows 9x from Microsoft Corporation
<DT>12
<DD>QNX 6.x 'Neutrino'
<DT>13
<DD>GNU/Linux
<DT>14
<DD>FreeBSD
</DL>
<DT>dbg$pid
<DD>(OS/2, NetWare 386, Linux, QNX, Windows NT, Windows 95 only) This debugger symbol contains the process identification value
for the program being debugged.&nbsp; 
<DT>dbg$psp
<DD>(DOS only) This debugger symbol contains the segment value for the DOS &quot;program segment prefix&quot; of the program being
debugged.&nbsp; 
<DT>dbg$radix
<DD>This debugger symbol represents the current default numeric radix.&nbsp; 
<DT>dbg$remote
<DD>This debugger symbol is 1 if the &quot;REMotefiles&quot; option was specified and 0 otherwise.&nbsp; 
<DT>dbg$sp
<DD>This debugger symbol represents the register pair SS:SP (16-bit mode) or SS:ESP (32-bit mode).
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ? dbg$sp</TT>
<DT>dbg$loaded
<DD>This debugger symbol is 1 if a program is loaded.&nbsp; Otherwise, it is 0.&nbsp; 
<DT>dbg$nil
<DD>This debugger symbol is the null pointer value.&nbsp; 
<DT>dbg$src
<DD>This debugger symbol is 1 if you are currently debugging in an area that contains debugging information.
</DL>
<H1 ID="Wiring_For_Remote_Debugging"> Wiring For Remote Debugging </H1>
<BR>This appendix describes both serial and parallel port cable wiring for remote debugging.
<H2 ID="Serial_Port_Wiring_Considerations"> Serial Port Wiring Considerations </H2>
<BR>If you plan to use the serial port Debug Server &quot;SERSERV&quot;, a cable must connect the serial ports of the two
computer systems.&nbsp; The following diagram illustrates the wiring between the two serial ports.&nbsp; If your computer
systems have more than one serial port, any serial port may be used.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Task Machine&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Debugger Machine</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Serial&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Serial</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Connector&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; Connector</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Pin #&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; Pin #</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 (PG) &lt;----------&gt;1 (PG)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2 (TxD)&lt;----------&gt;3 (RxD)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3 (RxD)&lt;----------&gt;2 (TxD)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ------- 4 (RTS)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
4 (RTS) -------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ------&gt; 5 (CTS)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
5 (CTS) &lt;------</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ------&gt; 6 (DSR)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;6 (DSR) &lt;------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7 (SG) &lt;----------&gt;7 (SG)&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |------&gt; 8 (DCD)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8 (DCD)
&lt;------|</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ------ 20 (DTR)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 20 (DTR)
-------</TT>
<BR><BR><B><I>Figure 26.</I></B><B><I></I></B><B> Serial Port Wiring Scheme</B>
<BR><BR>Note that the wiring is symmetrical (i.e., either end of the cable can be plugged into either PC).&nbsp; This particular
arrangement of the wiring is sometimes called a &quot;null modem&quot; (since pins 2 and 3 are crossed and no modem is involved).
<H2 ID="Parallel_Port_Wiring_Considerations"> Parallel Port Wiring Considerations </H2>
<BR>If you plan to use the parallel port Debug Server &quot;PARSERV&quot; or &quot;PARSERVW&quot;, a cable must connect the
parallel ports of the two computer systems.&nbsp; Three cabling methods are supported - the LapLink cable, the Flying Dutchman
cable, and Watcom's own design.&nbsp; There are two advantages to using the LapLink or Flying Dutchman cable:
<OL>
<LI>They are commercially available (you may already own one).
<LI>They may work with more PC &quot;compatibles&quot; than Watcom's cable.&nbsp; Watcom's cabling requires 8 bi-directional
data lines in the parallel port and some PC &quot;compatibles&quot; do not support this.
</OL>
<BR>The disadvantage with the LapLink and Flying Dutchman cables is that they are slower than Watcom's cable since only 4
bits are transmitted in parallel versus 8 bits for Watcom's.&nbsp; Thus Watcom's cable is faster but it will have to be custom
made.
<BR><BR>The LapLink cable is available from:
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp; Travelling Software, Inc.
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 18702 North Creek Parkway
<BR>&nbsp;&nbsp;&nbsp;&nbsp; Bothell, Washington,
<BR>&nbsp;&nbsp;&nbsp;&nbsp; U.S.A. 98011
<BR>&nbsp;&nbsp;&nbsp;&nbsp; Telephone: (206) 483-8088
<BR><BR>The Flying Dutchman cable is available from:
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp; Cyco,
<BR>&nbsp;&nbsp;&nbsp;&nbsp; Adm. Banckertweg 2a,
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 2315 SR Leiden,
<BR>&nbsp;&nbsp;&nbsp;&nbsp; The Netherlands.
<BR><BR>The following diagram illustrates Watcom's cable wiring between the two parallel ports.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Task Machine&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Debugger Machine</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Parallel Connector&nbsp;&nbsp; Parallel Connector</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Pin Number&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Pin Number</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 &lt;--------------&gt; 2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2 &lt;--------------&gt; 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3 &lt;--------------&gt; 14</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 &lt;--------------&gt; 16</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5 &lt;--------------&gt; 15</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6 &lt;--------------&gt; 13</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7 &lt;--------------&gt; 12</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8 &lt;--------------&gt; 10</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 9 &lt;--------------&gt; 11</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10 &lt;--------------&gt; 8</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 11 &lt;--------------&gt; 9</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 12 &lt;--------------&gt; 7</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 13 &lt;--------------&gt; 6</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 14 &lt;--------------&gt; 3</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 15 &lt;--------------&gt; 5</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 &lt;--------------&gt; 4</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 17 &lt;--------------&gt; 17</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 18 &lt;--------------&gt; 18</TT>
<BR><BR><B><I>Figure 27.</I></B><B><I></I></B><B> Watcom Cable Wiring Scheme</B>
<BR><BR>The following diagram illustrates the LapLink cable wiring between the two parallel ports.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Task Machine&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Debugger Machine</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Parallel Connector&nbsp;&nbsp; Parallel Connector</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Pin Number&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Pin Number</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp; --------------&gt; 15</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp; --------------&gt; 13</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp; --------------&gt; 12</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5&nbsp; --------------&gt; 10</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6&nbsp; --------------&gt; 11</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10 &lt;--------------&nbsp;&nbsp; 5</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 11 &lt;--------------&nbsp;&nbsp; 6</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 12 &lt;--------------&nbsp;&nbsp; 4</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 13 &lt;--------------&nbsp;&nbsp; 3</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 15 &lt;--------------&nbsp;&nbsp; 2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 25 &lt;--------------&gt; 25</TT>
<BR><BR><B><I>Figure 28.</I></B><B><I></I></B><B> LapLink Cable Wiring Scheme</B>
<BR><BR>The following diagram illustrates the Flying Dutchman cable wiring between the two parallel ports.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Task Machine&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Debugger Machine</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Parallel Connector&nbsp;&nbsp; Parallel Connector</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Pin Number&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Pin Number</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp; --------------&gt; 11</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp; --------------&gt; 15</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp; --------------&gt; 13</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp; --------------&gt; 12</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5&nbsp; --------------&gt; 10</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10 &lt;--------------&nbsp;&nbsp; 5</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 11 &lt;--------------&nbsp;&nbsp; 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 12 &lt;--------------&nbsp;&nbsp; 4</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 13 &lt;--------------&nbsp;&nbsp; 3</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 15 &lt;--------------&nbsp;&nbsp; 2</TT>
<BR><BR><B><I>Figure 29.</I></B><B><I></I></B><B> Flying Dutchman Cable Wiring Scheme</B>
<BR><BR>For the IBM PC and PS/2, the connectors are standard &quot;male&quot; DB-25 connectors.&nbsp; Note that, in all cases,
the wiring is symmetrical (i.e., either end of the cable can be plugged into either PC).
<HR>
<BR><B><I>&nbsp; Note:</I></B>&nbsp; Although the wiring is different for all three cables, the Open Watcom parallel communications
software can determine which one is in use.
<HR>
<H1 ID="Remote_File_Operations_LDOS__NT__OSD2_OnlyR"> Remote File Operations (DOS, NT, OS/2 Only) </H1>
<BR>Use the<B> R</B>emote<B> F</B>ile e<B> X</B>change program (RFX) to manipulate files on a personal computer which is connected
to your personal computer using a debugger remote link.&nbsp; You should consult the chapter entitled <A HREF="#Remote_Debugging">Remote Debugging</A>
to familiarize yourself with the concepts of remote debugging.&nbsp; The types of file operations that are supported on both
local and remote machines include:
<OL>
<LI>creating, listing and removing directories
<LI>setting the current drive and directory
<LI>display, renaming, erasing, and copying files (including PC to PC file transfers).
</OL>
<BR>To run RFX, set up your machines as if you are about to do remote debugging.&nbsp; Start the remote debug server, then
start RFX using the the following syntax.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; RFX trap_file[;trap_parm] [rfx_cmd]</TT>
<BR><BR>The name of a trap file must be specified when running RFX.&nbsp; See <A HREF="#Remote_Debugging">Remote Debugging</A>.
<BR><BR>See the section entitled <A HREF="#Specifying_Files_on_Remote_and_Local_Machines">Specifying Files on Remote and Local Machines</A>
for an explanation of remote and local file names.
<BR><BR>You are now ready to copy files back and forth between machines.
<H2 ID="RFX_Commands"> RFX Commands </H2>
<BR>When RFX is run without specifying a command, the DOS, NT or OS/2 prompt will change as illustrated in the following example.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Mon&nbsp; 11-06-1989 15:17:05.84 E:\DOC\UG</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; E&gt;rfx par</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [RFX] Mon&nbsp; 11-06-1989 15:17:12.75 @LE:\DOC\UG</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [RFX] E&gt;</TT>
<BR><BR>Note that the current drive specifier &quot;E&quot; in &quot;E:\DOC\UG&quot; has changed to &quot;@LE&quot; indicating
that the current drive is the local &quot;E&quot; drive.
<BR><BR>Any command can be typed in response to the prompt.&nbsp; RFX recognizes a special set of commands and passes all
others on to DOS, NT or OS/2 for processing.&nbsp; The following sections describe RFX commands.
<H2 ID="Set_Current_Drive_M_drive_"> Set Current Drive - drive: </H2>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; drive:</TT>
<BR><BR>The current drive and locale can be set using this command.&nbsp; The &quot;@L&quot; or &quot;@R&quot; prefix may
be used to specify the locale (local or remote).
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; d:</TT>
<BR><BR>Make the &quot;D&quot; disk of the current locale (local or remote) the current drive.&nbsp; Since the locale is not
specified, it remains unchanged.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; @rc:</TT>
<BR><BR>Make the &quot;C&quot; disk of the remote machine the current drive.&nbsp; Both locale and disk are specified.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; @le:</TT>
<BR><BR>Make the &quot;E&quot; disk of the local machine the current drive.&nbsp; Both locale and disk are specified.
<H2 ID="Change_Directory_M_CHDIR__CD"> Change Directory - CHDIR, CD </H2>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; chdir dir_spec</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; cd dir_spec</TT>
<BR><BR>This command may be used to change the current directory of any disk on the local or remote machine.<B>&nbsp; CD</B>
is a short form for<B> CHDIR.</B>&nbsp; The &quot;@L&quot; or &quot;@R&quot; prefix may be used to specify the locale (local
or remote).
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; cd \tmp</TT>
<BR><BR>Make the &quot;TMP&quot; directory of the current drive the current directory.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; cd d:\etc</TT>
<BR><BR>Make the &quot;ETC&quot; directory of the &quot;D&quot; disk of the current locale (local or remote) the current directory
of that drive.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; cd @rc:\demo</TT>
<BR><BR>Make the &quot;DEMO&quot; directory of the &quot;C&quot; disk of the remote machine the current directory of that
drive.&nbsp; Both locale and disk are specified.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; cd @le:test</TT>
<BR><BR>Make the &quot;TEST&quot; subdirectory of the current directory of the &quot;E&quot; disk of the local machine the
current directory of that drive.&nbsp; Both locale and disk are specified.
<H2 ID="Copy_Files_M_COPY"> Copy Files - COPY </H2>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; copy [/s] src_spec [dst_spec] [/s]</TT>
<BR><BR>The<B> COPY</B> command operates in a manner very similar to the DOS &quot;COPY&quot; and &quot;XCOPY&quot; commands.
&nbsp;Files may be copied from the local machine to the local or remote machine.&nbsp; Similarly files may be copied from
the remote machine to the local or remote machine.&nbsp; If<B> /s</B> is specified then subdirectories are copied as well.
&nbsp;Directories will be created as required for the destination files.&nbsp; If<B> dst_spec</B> is not specified then the
default destination will be the current directory of the other locale (i.e., remote, if the file's locale is local or, local,
if the file's locale is remote).
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; copy *.for @rd:\tmp</TT>
<BR><BR>All files of type &quot;FOR&quot; in the current directory are copied to the &quot;TMP&quot; directory of the &quot;D&quot;
disk on the remote machine.&nbsp; If the current locale is the local machine then files are copied from the local machine
to the remote machine.&nbsp; If the current locale is the remote machine then files are copied from the remote machine to
the remote machine.
<HR>
<BR><B><I>&nbsp; Note:</I></B>&nbsp; If your default drive is set to one of the disks on the local machine then the locale
is local (e.g., @LC:, @LD:, @LE:, etc.).&nbsp; If your default drive is set to one of the disks on the remote machine then
the locale is remote (e.g., @RC:, @RD:, @RE:, etc.).&nbsp; If your DOS, NT or OS/2 prompt contains the current drive and directory
then it will be easy to identify which locale is current.
<HR>
<BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; copy @rd:\tmp\*.for</TT>
<BR><BR>All files of type &quot;FOR&quot; in the &quot;TMP&quot; directory of the &quot;D&quot; disk on the remote machine
are copied to the current directory of the local machine.&nbsp; Whenever a destination is not specified, the current directory
of the opposite locale is used.&nbsp; If the source locale is the remote machine then files are copied from the remote to
the local machine.&nbsp; If the source locale is the current machine then files are copied from the local to the remote machine.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; copy @rc:\watcom\*.* /s</TT>
<BR><BR>All files and subdirectories of the &quot;WATCOM&quot; directory of the &quot;C&quot; disk on the remote machine are
copied to the current directory of the local machine.&nbsp; Whenever a destination is not specified, the current directory
of the opposite locale is used.&nbsp; If the source locale is the remote machine then files are copied from the remote to
the local machine.&nbsp; If the source locale is the current machine then files are copied from the local to the remote machine.
&nbsp;Subdirectories are created as required.
<HR>
<BR><B><I>&nbsp; Note:</I></B>&nbsp; The &quot;COPY&quot; command is most effectively used when copying files from one machine
to the other.&nbsp; Copying of large amounts of files from one place on the remote machine to another place on the remote
machine could be done more effectively using the remote machine's DOS, NT or OS/2.&nbsp; This would eliminate the transfer
of data from the remote machine to the local machine and back to the remote machine.
<HR>
<H2 ID="List_Directory_M_DIR"> List Directory - DIR </H2>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; dir [/w] dir_spec [/w]</TT>
<BR><BR>This command may be used to list the directories of any disk on the local or remote machine.&nbsp; Any of the DOS,
NT or OS/2 &quot;wild card&quot; characters (&quot;?&quot; and &quot;*&quot;) may be used.&nbsp; If<B> /w</B> is specified
then file names are displayed across the screen (&quot;wide&quot;) and the file creation date and time are omitted.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; dir \tmp</TT>
<BR><BR>List the names of files in the &quot;TMP&quot; directory of the current drive.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; dir d:\etc</TT>
<BR><BR>List the names of files in the &quot;ETC&quot; directory of the &quot;D&quot; disk of the current locale (local or
remote).
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; dir @rc:\demo</TT>
<BR><BR>List the names of files in the &quot;DEMO&quot; directory of the &quot;C&quot; disk of the remote machine.&nbsp; Both
locale and disk are specified.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; dir @le:test</TT>
<BR><BR>List the names of files in the &quot;TEST&quot; subdirectory of the current directory of the &quot;E&quot; disk of
the local machine.&nbsp; If no &quot;TEST&quot; subdirectory exists then the names of all files named &quot;TEST&quot; will
be listed.&nbsp; Both locale and disk are specified.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; dir @le:test.*</TT>
<BR><BR>List the names of all files named &quot;TEST&quot; in the current directory of the &quot;E&quot; disk of the local
machine.&nbsp; Both locale and disk are specified.
<H2 ID="Erase_File_M_ERASE__DEL"> Erase File - ERASE, DEL </H2>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; erase [/s] file_spec [/s]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; del [/s] file_spec [/s]</TT>
<BR><BR>This command may be used to erase files from the directories of any disk on the local or remote machine.<B>&nbsp;
DEL</B> is a short form for<B> ERASE.</B>&nbsp; Any of the DOS, NT or OS/2 &quot;wild card&quot; characters (&quot;?&quot;
and &quot;*&quot;) may be used.&nbsp; If<B> /s</B> is specified then subdirectories are also processed.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; erase \tmp\*.*</TT>
<BR><BR>Erase all the files in the &quot;TMP&quot; directory of the current drive.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; erase d:\etc\*.lst</TT>
<BR><BR>Erase all files of type &quot;LST&quot; in the &quot;ETC&quot; directory of the &quot;D&quot; disk of the current
locale (local or remote).
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; erase @rc:\demo\*.obj</TT>
<BR><BR>Erase all files of type &quot;OBJ&quot; in the &quot;DEMO&quot; directory of the &quot;C&quot; disk of the remote
machine.&nbsp; Both locale and disk are specified.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; erase @le:trial.*</TT>
<BR><BR>Erase all files named &quot;TRIAL&quot; of any type in the current directory of the &quot;E&quot; disk of the local
machine.&nbsp; Both locale and disk are specified.
<H2 ID="Exit_from_RFX_M_EXIT"> Exit from RFX - EXIT </H2>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; exit</TT>
<BR><BR>This command may be used to exit from RFX and return to the invoking process.
<H2 ID="Make_Directory_M_MKDIR__MD"> Make Directory - MKDIR, MD </H2>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; mkdir dir_spec</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; md dir_spec</TT>
<BR><BR>This command may be used to create a directory on any disk on the local or remote machine.<B>&nbsp; MD</B> is a short
form for<B> MKDIR.</B>&nbsp; The &quot;@L&quot; or &quot;@R&quot; prefix may be used to specify the locale (local or remote).
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; md \tmp</TT>
<BR><BR>Create a &quot;TMP&quot; directory in the root of the current drive.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; md d:\etc</TT>
<BR><BR>Create an &quot;ETC&quot; directory in the root of the &quot;D&quot; disk of the current locale (local or remote).
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; md @rc:\demo</TT>
<BR><BR>Create a &quot;DEMO&quot; directory in the root of the &quot;C&quot; disk of the remote machine.&nbsp; Both locale
and disk are specified.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; md @le:test</TT>
<BR><BR>Create a &quot;TEST&quot; subdirectory in the current directory of the &quot;E&quot; disk of the local machine.&nbsp;
Both locale and disk are specified.
<H2 ID="Rename_M_RENAME__REN"> Rename - RENAME, REN </H2>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; rename file_spec new_name</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ren file_spec new_name</TT>
<BR><BR>This command may be used to rename a file in any directory on any disk on the local or remote machine.<B>&nbsp; REN</B>
is a short form for<B> RENAME.</B>&nbsp; The &quot;@L&quot; or &quot;@R&quot; prefix may be used to specify the locale (local
or remote).&nbsp; Unlike the DOS &quot;RENAME&quot; command, a file can be moved to a different directory if the directory
is specified in<B> new_name.</B>
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ren test.tmp test1.tmp</TT>
<BR><BR>Rename the file &quot;TEST.TMP&quot; in the current directory of the current drive to &quot;TEST1.TMP&quot;.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ren d:\etc\test.tmp test1.tmp</TT>
<BR><BR>Rename the file &quot;TEST.TMP&quot; in the &quot;ETC&quot; directory of the &quot;D&quot; disk of the current locale
(local or remote) to &quot;TEST1.TMP&quot;.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ren @rc:\demo\test.tmp test1.tmp</TT>
<BR><BR>Rename the file &quot;TEST.TMP&quot; in the &quot;DEMO&quot; directory of the &quot;C&quot; disk of the remote machine
to &quot;TEST1.TMP&quot;.&nbsp; Both locale and disk are specified.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ren @le:trial.dat trial1.dat</TT>
<BR><BR>Rename the file &quot;TRIAL.DAT&quot; in the current directory of the &quot;E&quot; disk of the local machine to &quot;TRIAL1.DAT&quot;.
&nbsp;Both locale and disk are specified.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ren @le:trial.dat ..\trial1.dat</TT>
<BR><BR>Rename the file &quot;TRIAL.DAT&quot; in the current directory of the &quot;E&quot; disk of the local machine to &quot;TRIAL1.DAT&quot;
and move it to the parent directory.&nbsp; Both locale and disk are specified.
<H2 ID="Remove_Directory_M_RMDIR__RD"> Remove Directory - RMDIR, RD </H2>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; rmdir [/s] dir_spec [/s]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; rd [/s] dir_spec [/s]</TT>
<BR><BR>This command may be used to remove one or more directories on any disk on the local or remote machine.<B>&nbsp; RD</B>
is a short form for<B> RMDIR.</B>&nbsp; The &quot;@L&quot; or &quot;@R&quot; prefix may be used to specify the locale (local
or remote).&nbsp; If<B> /s</B> is specified then subdirectories are also removed.&nbsp; Before a directory can be removed,
it must not contain any files.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; rd \tmp</TT>
<BR><BR>Remove the &quot;TMP&quot; directory from the root of the current drive.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; rd d:\etc</TT>
<BR><BR>Remove the &quot;ETC&quot; directory from the root of the &quot;D&quot; disk of the current locale (local or remote).
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; rd @rc:\demo</TT>
<BR><BR>Remove the &quot;DEMO&quot; directory from the root of the &quot;C&quot; disk of the remote machine.&nbsp; Both locale
and disk are specified.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; rd @le:test</TT>
<BR><BR>Remove the &quot;TEST&quot; subdirectory from the current directory of the &quot;E&quot; disk of the local machine.
&nbsp;Both locale and disk are specified.
<H2 ID="Display_File_Contents_M_TYPE"> Display File Contents - TYPE </H2>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; type dir_spec</TT>
<BR><BR>This command may be used to list the contents of a file on any disk on the local or remote machine.&nbsp; The &quot;@L&quot;
or &quot;@R&quot; prefix may be used to specify the locale (local or remote).&nbsp; Unlike the DOS &quot;TYPE&quot; command,
DOS, NT or OS/2 &quot;wild card&quot; characters (&quot;?&quot; or &quot;*&quot;) may be used.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; type \tmp\test.dat</TT>
<BR><BR>List the contents of the file &quot;TEST.DAT&quot; in the &quot;TMP&quot; directory of the current drive.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; type d:\etc\*.lst</TT>
<BR><BR>List the contents of all files of type &quot;LST&quot; in the &quot;ETC&quot; directory of the &quot;D&quot; disk
of the current locale (local or remote).
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; type @rc:\demo\test.c</TT>
<BR><BR>List the contents of the file &quot;TEST.C&quot; in the &quot;DEMO&quot; directory of the &quot;C&quot; disk of the
remote machine.&nbsp; Both locale and disk are specified.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; type @le:trial.*</TT>
<BR><BR>List the contents of all files named &quot;TRIAL&quot; of any type in the current directory of the &quot;E&quot; disk
of the local machine.&nbsp; Both locale and disk are specified.
<H2 ID="RFX_Sample_Session"> RFX Sample Session </H2>
<BR>Run serial port server on remote PC specifying a port 1 and a maximum baud rate of 38,400 baud.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Tue 11-07-1989 15:29:24.19 C:\</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C&gt;serserv 1.38</TT>
<BR><BR>Run RFX on local PC.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Tue 11-07-1989 15:30:53.18 E:\DOC\UG</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; E&gt;rfx ser</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Link at 38400 baud</TT>
<BR><BR>List directory of remote machine's &quot;F&quot; drive.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [RFX] Tue&nbsp; 11-07-1989 15:30:59.33 @LE:\DOC\UG</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [RFX] E&gt;dir @rf:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CLIB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;DIR&gt;&nbsp;&nbsp;
&nbsp; 02-01-89&nbsp; 06:43p</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;DIR&gt;&nbsp;&nbsp;
&nbsp; 02-01-89&nbsp; 06:51p</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PCLINT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;DIR&gt;&nbsp;&nbsp;&nbsp;&nbsp;
03-09-89&nbsp; 04:05p</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3 File(s)&nbsp; 16748544 bytes
free</TT>
<BR><BR>Switch to remote machine's &quot;F&quot; drive and list files.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [RFX] Tue&nbsp; 11-07-1989 15:31:11.80 @LE:\DOC\UG</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [RFX] E&gt;@rf:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [RFX] Tue&nbsp; 11-07-1989 15:31:22.51 @RF:\</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [RFX] F&gt;dir</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CLIB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;DIR&gt;&nbsp;&nbsp;
&nbsp; 02-01-89&nbsp; 06:43p</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;DIR&gt;&nbsp;&nbsp;
&nbsp; 02-01-89&nbsp; 06:51p</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PCLINT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;DIR&gt;&nbsp;&nbsp;&nbsp;&nbsp;
03-09-89&nbsp; 04:05p</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3 File(s)&nbsp; 16748544 bytes
free</TT>
<BR><BR>Change to subdirectory and list files.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [RFX] Tue&nbsp; 11-07-1989 15:31:27.73 @RF:\</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [RFX] F&gt;cd clib</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [RFX] Tue&nbsp; 11-07-1989 15:31:47.83 @RF:\CLIB</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [RFX] F&gt;dir</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;DIR&gt;
&nbsp;&nbsp;&nbsp; 02-01-89&nbsp; 06:43p</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ..&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;DIR&gt;&nbsp;
&nbsp;&nbsp; 02-01-89&nbsp; 06:43p</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MKCLIB&nbsp;&nbsp; BAT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 95&nbsp; 12-20-88
&nbsp;04:24p</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MKMODEL&nbsp; BAT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 128&nbsp; 02-01-89&nbsp; 04:32p</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MDEF&nbsp;&nbsp;&nbsp;&nbsp; INC&nbsp;&nbsp;&nbsp;&nbsp; 1831&nbsp; 12-08-88
&nbsp;12:23p</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STRUCT&nbsp;&nbsp; INC&nbsp;&nbsp;&nbsp;&nbsp; 2487&nbsp; 12-20-88&nbsp; 05:45p</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CLIB&nbsp;&nbsp;&nbsp;&nbsp; MIF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 559&nbsp; 02-01-89
&nbsp;04:42p</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;DIR&gt;
&nbsp;&nbsp;&nbsp; 02-01-89&nbsp; 06:44p</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SCSD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;DIR&gt;&nbsp;&nbsp;
&nbsp; 02-01-89&nbsp; 06:44p</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BCSD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;DIR&gt;&nbsp;&nbsp;
&nbsp; 02-01-89&nbsp; 06:44p</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SCBD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;DIR&gt;&nbsp;&nbsp;
&nbsp; 02-01-89&nbsp; 06:44p</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BCBD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;DIR&gt;&nbsp;&nbsp;
&nbsp; 02-01-89&nbsp; 06:44p</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BCHD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;DIR&gt;&nbsp;&nbsp;
&nbsp; 02-01-89&nbsp; 06:44p</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ANSI&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;DIR&gt;&nbsp;&nbsp;
&nbsp; 02-01-89&nbsp; 06:44p</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DOS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;DIR&gt;&nbsp;&nbsp;
&nbsp; 02-01-89&nbsp; 06:47p</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;DIR&gt;
&nbsp;&nbsp;&nbsp; 02-01-89&nbsp; 06:50p</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;DIR&gt;
&nbsp;&nbsp;&nbsp; 02-01-89&nbsp; 06:50p</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CGSUPP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;DIR&gt;&nbsp;&nbsp;&nbsp;&nbsp;
02-01-89&nbsp; 06:50p</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 18 File(s)&nbsp; 16748544 bytes free</TT>
<BR><BR>List directory of local machine.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [RFX] Tue&nbsp; 11-07-1989 15:31:51.57 @RF:\CLIB</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [RFX] F&gt;dir @l..\tools\*.c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALENDAR C&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4378&nbsp; 04-17-89&nbsp; 08:17p</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CLRSCRN&nbsp; C&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 233&nbsp; 04-17-89
&nbsp;08:17p</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ERR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
198&nbsp; 04-17-89&nbsp; 08:30p</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MAIN&nbsp;&nbsp;&nbsp;&nbsp; C&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 142
&nbsp;04-17-89&nbsp; 09:14p</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SAMPLE1&nbsp; C&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 83&nbsp; 04-14-89
&nbsp;03:56p</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SAMPLE2&nbsp; C&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 83&nbsp; 04-14-89
&nbsp;03:57p</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SAMPLE3&nbsp; C&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 86&nbsp; 04-14-89
&nbsp;03:58p</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SAMPLE4&nbsp; C&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 132&nbsp; 04-14-89
&nbsp;04:05p</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SAMPLE5&nbsp; C&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 131&nbsp; 04-14-89
&nbsp;04:05p</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SUB1&nbsp;&nbsp;&nbsp;&nbsp; C&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 108
&nbsp;11-03-89&nbsp; 05:11p</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SUB2&nbsp;&nbsp;&nbsp;&nbsp; C&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 108
&nbsp;11-03-89&nbsp; 05:11p</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TEST&nbsp;&nbsp;&nbsp;&nbsp; C&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 236
&nbsp;05-08-89&nbsp; 07:02p</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 12 File(s)&nbsp;&nbsp; 8292352 bytes
free</TT>
<BR><BR>Copy file from local machine to current directory of remote machine.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [RFX] Tue&nbsp; 11-07-1989 15:32:21.99 @RF:\CLIB</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [RFX] F&gt;copy @l..\tools\test.c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; E:..\TOOLS\TEST.C</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 Files copied&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; 0 Directories created</TT>
<BR><BR>Confirm presence of file.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [RFX] Tue&nbsp; 11-07-1989 15:32:41.22 @RF:\CLIB</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [RFX] F&gt;dir *.c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TEST&nbsp;&nbsp;&nbsp;&nbsp; C&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 236
&nbsp;05-08-89&nbsp; 07:02p</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 File(s)&nbsp; 16746496 bytes
free</TT>
<BR><BR>Leave RFX.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [RFX] Tue&nbsp; 11-07-1989 15:32:46.99 @RF:\CLIB</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [RFX] F&gt;exit</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Tue 1989-11-07 15:32:57.20 E:\DOC\UG</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; E&gt;</TT>
</BODY>
