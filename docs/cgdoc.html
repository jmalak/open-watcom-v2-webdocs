<HEAD>
<TITLE> Open Watcom 2.0 Code Generator </TITLE>
</HEAD>
<BODY>
<H1 ID="Introduction"> Introduction </H1>
<BR>The code generator (back end) interface is a set of procedure calls.&nbsp; These are divided into following category of
routines.
<UL>
<LI>Code Generation (CG)
<LI>Data Generation (DG)
<LI>Miscellaneous Back End (BE)
<LI>Front end supplied (FE)
<LI>Debugger information (DB)
</UL>
<H1 ID="General"> General </H1>
<H2 ID="cg_init_info_BEInitL_cg_switches_switches__cg_target_switches_targ_switches__uint_optsize__proc_revision_proc_R"> cg_init_info BEInit( cg_switches switches, cg_target_switches targ_switches, uint optsize, proc_revision proc ) </H2>
<BR>Initialize the code generator.&nbsp; This must be the first routine to be called.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>switches
<DD>Select code generation options.&nbsp; The options are bits, so may be combined with the bit-wise operator |.&nbsp; Options
apply to the entire compilation unit.&nbsp; The bit values are defined below.
<DT>targ_switches
<DD>Target specific switches.&nbsp; The bit values are defined below.
<DT>optsize
<DD>A number between 0 and 100.&nbsp; 0 means optimize for speed, 100 means optimize for size.&nbsp; Anything in between selects
a compromise between speed and size.
<DT>proc
<DD>The target hardware configuration, defined below.
</DL>
<DL>
<DT>Returns
<DD>Information about the code generator revision in a cg_init_info structure, defined below.
</DL>
<DL>
<DT><B><I>Switch</I></B>
<DD><B><I>Definition</I></B>
<DT>NO_OPTIMIZATION
<DD>Turn off optimizations.
<DT>DBG_NUMBERS
<DD>Generate line number debugging information.
<DT>FORTRAN_ALIASING
<DD>Assume pointers are only used for parameter passing.
<DT>DBG_DF
<DD>Generate debugging information in DWARF format.
<DT>DBG_CV
<DD>Generate debugging information in CodeView format.&nbsp; If neither DBG_DF nor DBG_CV is set, debugging information (if any)
is generated in the Watcom format.
<DT>RELAX_ALIAS
<DD>Assume that a static/extern variable and a pointer to that same variable are not used within the same routine.
<DT>DBG_LOCALS
<DD>Generate local symbol information for use by a debugger.
<DT>DBG_TYPES
<DD>Generate typing information for use by a debugger.
<DT>LOOP_UNROLLING
<DD>Turn on loop unrolling.
<DT>LOOP_OPTIMIZATION
<DD>Turn on loop optimizations.
<DT>INS_SCHEDULING
<DD>Turn on instruction scheduling.
<DT>MEMORY_LOW_FAILS
<DD>Allow the code generator to run out of memory without being able to generate object code (allows the 386 compiler to use EBP
as a cache register).
<DT>FP_UNSTABLE_OPTIMIZATION
<DD>Allow the code generator to perform optimizations that are mathematically correct, but are numerically unstable.&nbsp; E.g.
&nbsp;converting division by a constant to a multiplication by the reciprocal.
<DT>NULL_DEREF_OK
<DD>NULL points to valid memory and may be dereferenced.
<DT>FPU_ROUNDING_INLINE
<DD>Inline floating-point value rounding (actually truncation) routine when converting floating-point values to integers.
<DT>FPU_ROUNDING_OMIT
<DD>Omit floating-point value rounding entirely and use FPU default.&nbsp; Results will not be ISO C compliant.
<DT>ECHO_API_CALLS
<DD>Log each call to the code generator with its arguments and return value.&nbsp; Only available in debug builds.
<DT>OBJ_ELF
<DD>Emit ELF object files.
<DT>OBJ_COFF
<DD>Emit COFF object files.&nbsp; For Intel compilers, OMF object files will be emitted in the absence of either switch.
<DT>OBJ_ENDIAN_BIG
<DD>Emit big-endian object files (COFF or ELF).&nbsp; If OBJ_ENDIAN_BIG is not set, little-endian objects will be generated.
</DL>
<DL>
<DT><B><I>x86 Switch</I></B>
<DD><B><I>Definition</I></B>
<DT>I_MATH_INLINE
<DD>Do not check arguments for operators like O_SQRT.&nbsp; This allows the compiler to use some specialty x87 instructions.
<DT>EZ_OMF
<DD>Generate Phar Lap EZ-OMF object files.
<DT>BIG_DATA
<DD>Use segmented pointers (16:16 or 16:32).&nbsp; This defines TY_POINTER to be equivalent to TY_HUGE_POINTER.
<DT>BIG_CODE
<DD>Use inter segment (far) call and return instructions.
<DT>CHEAP_POINTER
<DD>Assume far objects are addressable by one segment value.&nbsp; This must be used in conjunction with BIG_DATA.&nbsp; It defines
TY_POINTER to be equivalent to TY_FAR_POINTER.
<DT>FLAT_MODEL
<DD>Assume all segment registers address the same base memory.
<DT>FLOATING_FS
<DD>Does FS float (or is it pegged to DGROUP).
<DT>FLOATING_GS
<DD>Does GS float (or is it pegged to DGROUP).
<DT>FLOATING_ES
<DD>Does ES float (or is it pegged to DGROUP).
<DT>FLOATING_SS
<DD>Does SS float (or is it pegged to DGROUP).
<DT>FLOATING_DS
<DD>Does DS float (or is it pegged to DGROUP).
<DT>USE_32
<DD>Generate code into a use32 segment (versus use16).
<DT>INDEXED_GLOBALS
<DD>Generate all global and static variable references as an offset past EBX.
<DT>WINDOWS
<DD>Generate windows prolog/epilog sequences for all routines.
<DT>CHEAP_WINDOWS
<DD>Generate windows prolog/epilog sequences assuming that call backs functions are defined as __export.
<DT>NO_CALL_RET_TRANSFORM
<DD>Do not change a CALL followed by a RET into a JMP.&nbsp; This is used for some older overlay managers that cannot handle a
JMP to an overlay.
<DT>CONST_IN_CODE
<DD>Generate all constant data into the code segment.&nbsp; This only applies to the internal code generator data, such as floating
point constants.&nbsp; The front end decides where its data goes using BESetSeg().
<DT>NEED_STACK_FRAME
<DD>Generate a traceable stack frame.&nbsp; The first instructions will be<B> INC BP</B> if the routine uses a far return instruction,
followed by<B> PUSH BP</B> and<B> MOV BP,SP</B>.&nbsp; (ESP and EBP for 386 targets).
<DT>LOAD_DS_DIRECTLY
<DD>Generate code to load DS directly.&nbsp; By default, a call to __GETDS routine is generated.
<DT>GEN_FWAIT_386
<DD>Generate FWAIT instructions on 386 and later CPUs.&nbsp; The 386 never needs FWAIT for data synchronization, but FWAIT may
still be needed for accurate exception reporting.
</DL>
<DL>
<DT><B><I>RISC Switch</I></B>
<DD><B><I>Definition</I></B>
<DT>ASM_OUTPUT
<DD>Print final pseudo-assembly on the console.&nbsp; Debug builds only.
<DT>OWL_LOGGING
<DD>Log calls to the Object Writer Library
<DT>STACK_INIT
<DD>Pre-initialize stack variables to a known bit pattern.
<DT>EXCEPT_FILTER_USED
<DD>Set when SEH (Structured Exception Handling) is used.
</DL>
<BR>The supported proc_revision CPU values are:
<UL>
<LI>CPU_86
<LI>CPU_186
<LI>CPU_286
<LI>CPU_386
<LI>CPU_486
<LI>CPU_586
</UL>
<BR>The supported proc_revision FPU values are:
<UL>
<LI>FPU_NONE
<LI>FPU_87
<LI>FPU_387
<LI>FPU_586
<LI>FPU_EMU
<LI>FPU_E87
<LI>FPU_E387
<LI>FPU_E586
</UL>
<BR>The supported proc_revision WEITEK values are:
<UL>
<LI>WTK_NONE
<LI>WTK_1167
<LI>WTK_3167
<LI>WTK_4167
</UL>
<BR>The following example sets the processor revision information to indicate a 386 with 387 and Weitek 3167.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; proc_revision proc;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SET_CPU( p, CPU_386 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SET_FPU( p, FPU_387 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SET_WTK( p, WTK_3167 );</TT>
<BR><BR>The return value structure is defined as follows:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef union&nbsp;&nbsp; cg_init_info {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned revision&nbsp;&nbsp; : 10; /* contains II_REVISION */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned target&nbsp;&nbsp;&nbsp;&nbsp; : 5;&nbsp; /* has II_TARG_???
*/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned is_large&nbsp;&nbsp; : 1;&nbsp; /* 1 if 16 bit host */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } version;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; success;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; } cg_init_info;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; enum {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; II_TARG_8086,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; II_TARG_80386,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; II_TARG_STUB,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; II_TARG_CHECK,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; II_TARG_370,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; II_TARG_AXP,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; II_TARG_PPC,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; II_TARG_MIPS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<H2 ID="void_BEStartLR"> void BEStart() </H2>
<BR>Start the code generator.&nbsp; Must be called immediately after all calls to BEDefSeg have been made.&nbsp; This restriction
is relaxed somewhat for the 80(x)86 code generator.&nbsp; See BEDefSeg for details.
<H2 ID="void_BEStopLR"> void BEStop() </H2>
<BR>Normal termination of code generator.&nbsp; This must be the second last routine called.
<H2 ID="void_BEAbortLR"> void BEAbort() </H2>
<BR>Abnormal termination of code generator.&nbsp; This must be the second last routine called.
<H2 ID="void_BEFiniLR"> void BEFini() </H2>
<BR>Finalize the code generator.&nbsp; This must be the last routine called.
<H2 ID="patch_handle_BEPatchLR"> patch_handle BEPatch() </H2>
<BR>Allocate a patch handle which can be used to create a patchable integer (an integer which will have a constant value provided
sometime while the codegen is handling the CGDone call).&nbsp; See CGPatchNode.
<H2 ID="void_BEPatchIntegerL_patch_handle_hdl__signed_32_value_R"> void BEPatchInteger( patch_handle hdl, signed_32 value ) </H2>
<BR>Patch the integer corresponding to the given handle to have the given value.&nbsp; This may be called repeatedly with
different values, providing CGPatchNode has been called and BEFiniPatch has not been called.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>hdl
<DD>A patch_handle returned from an earlier invocation of BEPatch which has had a node allocated for it via CGPatchNode.&nbsp;
If CGPatchNode has not been called with the handle given, the behaviour is undefined.
<DT>value
<DD>A signed 32-bit integer value.&nbsp; This will be the new value of the node which has been associated with the patch handle.
</DL>
<H2 ID="cg_name_BEFiniPatchL_patch_handle_hdl_R"> cg_name BEFiniPatch( patch_handle hdl ) </H2>
<BR>This must be called to free up resources used by the given handle.&nbsp; After this, the handle must not be used again.
<H1 ID="Segments"> Segments </H1>
<BR>The object file produced by the code generator is composed of various segments.&nbsp; These are defined by the front end.
&nbsp;A program may have as many data and code segments as required by the front end.&nbsp; Each segment may be regarded as
an individual file of objects, and may be created simultaneously.&nbsp; There is a current segment, selected by BESetSeg(),
into which all DG routines generate their data.&nbsp; The code for each routine is generated into the segment returned by
the FESegID() call when it is passed the cg_sym_handle for the routine.&nbsp; It is illegal to write data to the code segment
for a routine in between the CGProcDecl call and the CGReturn call.
<BR><BR>The following routines are used for initializing, finalizing, defining and selecting segments.
<H2 ID="void_BEDefSegL_segment_id_segid__seg_attr_attr__char_Tstr__uint_algn_R"> void BEDefSeg( segment_id segid, seg_attr attr, char *str, uint algn ) </H2>
<BR>Define a segment.&nbsp; This must be called after BEInit and before BEStart.&nbsp; For the 80(x)86 code generator, you
are allowed to define additional segments after BEStart if they are:
<OL>
<LI>Code Segments
<LI>PRIVATE data segments.
</OL>
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>segid
<DD>A non-negative integer used as an identifier for the segment.&nbsp; It is arbitrarily picked by the front end.
<DT>attr
<DD>Segment attribute bits, defined below.
<DT>str
<DD>The name given to the segment.
<DT>algn
<DD>The segment alignment requirements.&nbsp; The code generator will pick the next larger alignment allowed by the object module
format.&nbsp; For example, 9 would select paragraph alignment.
</DL>
<DL>
<DT><B><I>Attribute</I></B>
<DD><B><I>Definition</I></B>
<DT>EXEC
<DD>This is a code segment.
<DT>GLOBAL
<DD>The segment is accessible to other modules.&nbsp; (versus PRIVATE).
<DT>INIT
<DD>The segment is statically initialized.
<DT>ROM
<DD>The segment is read only.
<DT>BACK
<DD>The code generator may put its data here.&nbsp; One segment must be marked with this attribute.&nbsp; It may not be a COMMON,
PRIVATE or EXEC segment.&nbsp; If the front end requires code in the EXEC segment, the CONST_IN_CODE switch must be passed
to BEInit().
<DT>COMMON
<DD>All occurrences of this segment will be overlayed.&nbsp; This is used for FORTRAN common blocks.
<DT>PRIVATE
<DD>The segment is non combinable.&nbsp; This is used for far data items.
<DT>GIVEN_NAME
<DD>Normally, the back end feels free to prepend or append strings to the segment name passed in by the front end.&nbsp; This
allows a naive front end to specify a constant set of segment names, and have the code generator mangle them in such a manner
that they work properly in concert with the set of cg_switches that have been specified (e.g.&nbsp; prepending the module
name to the code segments when BIG_CODE is specified on the x86).&nbsp; When GIVEN_NAME is specified, the back end outputs
the segment name to the object file exactly as given.
<DT>THREAD_LOCAL
<DD>Segment contains thread local data.&nbsp; Such segments may need special handling in executable modules.
</DL>
<H2 ID="segment_id_BESetSegL_segment_id_segid_R"> segment_id BESetSeg( segment_id segid ) </H2>
<BR>Select the current segment for data generation routines.&nbsp; Code for a routine is always output into the segment returned
by FESegID when it is passed the routine symbol handle.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>segid
<DD>Selects the current segment.
</DL>
<DL>
<DT>Returns
<DD>The previous current segment.
</DL>
<BR><B>NOTE:</B>&nbsp; When emitting data into an EXEC or BACK segment, be aware that the code generator is at liberty to
emit code and/or back end data into that segment anytime you make a call to a code generation routine (CG*).&nbsp; Do NOT
expect data items to be contiguous in the segment if you have made an intervening CG* call.
<H2 ID="segment_id_BEGetSegL_void_R"> segment_id BEGetSeg( void ) </H2>
<BR>Return the current segment for generation routines.
<DL>
<DT>Returns
<DD>The current segment.
</DL>
<H2 ID="void_BEFlushSegL_segment_id_segid_R"> void BEFlushSeg( segment_id segid ) </H2>
<BR>BEFlushSeg informs the back end that no more code/data will be generated in the specified segment.&nbsp; For code segments,
it must be called after the CGReturn() for the final function which is placed in the segment.&nbsp; This causes the code generator
to flush all pending information associated with the segment and allows the front end to free all the back handles for symbols
which were referenced by the code going into the segment.&nbsp; (The FORTRAN compiler uses this since each function has its
own symbol table which is thrown out at the end of the function).
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>segid
<DD>The code segment id.
</DL>
<H1 ID="Labels"> Labels </H1>
<BR>The back end uses a<B> label_handle</B> for flow of control.&nbsp; Each<B> label_handle</B> is a unique code label.&nbsp;
These labels may only be used for flow of control.&nbsp; In order to define a label in a data segment, a<B> back_handle</B>
must be used.
<H2 ID="label_handle_BENewLabelLR"> label_handle BENewLabel() </H2>
<BR>Allocate a new control flow label.
<DL>
<DT>Returns
<DD>A new label_handle.
</DL>
<H2 ID="void_BEFiniLabelL_label_handle_lbl_R"> void BEFiniLabel( label_handle lbl ) </H2>
<BR>Indicate that a label_handle will not be used by the front end anymore.&nbsp; This allows the back end to free some memory
at some later stage.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>lbl
<DD>A label_handle
</DL>
<H1 ID="Back_Handles"> Back Handles </H1>
<BR>A<B> back_handle</B> is the front end's handle for a code generator symbol table entry.&nbsp; A<B> cg_sym_handle</B> is
the code generator's handle for a front end symbol table entry.&nbsp; The back end may call FEBack, passing in any cg_sym_handle
that has been passed to it.&nbsp; The front end must allocate a back_handle via BENewBack if one does not exist.&nbsp; Subsequent
calls to FEBack should return the same back_handle.&nbsp; This mechanism is used so that the back end does not have to do
symbol table searches.&nbsp; For example:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; back_handle FEBack( SYMPOINTER sym )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( sym-&gt;back == NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sym-&gt;back = BENewBack( sym );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( sym-&gt;back );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>It is the responsibility of the front end to free each back_handle, via BEFreeBack, when it frees the corresponding
cg_sym_handle entry.
<BR><BR>A back_handle for a symbol having automatic or register storage duration (auto back_handle) may not be freed until
CGReturn is called.&nbsp; A back_handle for a symbol having static storage duration, (static back_handle) may not be freed
until BEStop is called or until after a BEFlushSeg is done for a segment and the back_handle will never be referenced by any
other function.
<BR><BR>The code generator will not require a back handle for symbols which are not defined in the current compilation unit.
<BR><BR>The front end must define the location of all symbols with static storage duration by passing the appropriate back_handle
to DGLabel.&nbsp; It must also reserve the correct amount of space for that variable using DGBytes or DGUBytes.
<BR><BR>The front end may also allocate an back_handle with static storage duration that has no cg_sym_handle associated with
it (anonymous back_handle) by calling BENewBack(NULL).&nbsp; These are useful for literal strings.&nbsp; These must also be
freed after calling BEStop.
<H2 ID="back_handle_BENewBackL_cg_sym_handle_sym_R"> back_handle BENewBack( cg_sym_handle sym ) </H2>
<BR>Allocate a new back_handle.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>sym
<DD>The front end symbol handle to be associated with the back_handle.&nbsp; It may be NULL.
</DL>
<DL>
<DT>Returns
<DD>A new back_handle.
</DL>
<H2 ID="void_BEFiniBackL_back_handle_bck_R"> void BEFiniBack( back_handle bck ) </H2>
<BR>Indicate that<B> bck</B> will never be passed to the back end again, except to BEFreeBack.&nbsp; This allows the code
generator to free some memory at some later stage.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>bck
<DD>A back_handle.
</DL>
<H2 ID="void_BEFreeBackL_back_handle_bck_R"> void BEFreeBack( back_handle bck ) </H2>
<BR>Free the back_handle<B> bck</B>.&nbsp; See the preamble in this section for restrictions on freeing a back_handle.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>bck
<DD>A back_handle.
</DL>
<H1 ID="Type_definitions"> Type definitions </H1>
<BR>Base types are defined as constants.&nbsp; All other types (structures, arrays, unions, etc) are simply defined by their
length.&nbsp; The base types are:
<DL>
<DT><B><I>Type</I></B>
<DD><B><I>C type</I></B>
<DT>TY_UINT_1
<DD>unsigned char
<DT>TY_INT_1
<DD>signed char
<DT>TY_UINT_2
<DD>unsigned short
<DT>TY_INT_2
<DD>signed short
<DT>TY_UINT_4
<DD>unsigned long
<DT>TY_INT_4
<DD>signed long
<DT>TY_UINT_8
<DD>unsigned long long
<DT>TY_INT_8
<DD>signed long long
<DT>TY_LONG_POINTER
<DD>far *
<DT>TY_HUGE_POINTER
<DD>huge *
<DT>TY_NEAR_POINTER
<DD>near *
<DT>TY_LONG_CODE_PTR
<DD>(far *)()
<DT>TY_NEAR_CODE_PTR
<DD>(near *)()
<DT>TY_SINGLE
<DD>float
<DT>TY_DOUBLE
<DD>double
<DT>TY_LONG_DOUBLE
<DD>long double
<DT>TY_INTEGER
<DD>int
<DT>TY_UNSIGNED
<DD>unsigned int
<DT>TY_POINTER
<DD>*
<DT>TY_CODE_PTR
<DD>(*)()
<DT>TY_BOOLEAN
<DD>The result of a comparison or flow operator.&nbsp; May also be used as an integer.
<DT>TY_DEFAULT
<DD>Used to indicate default conversion
<DT>TY_NEAR_INTEGER
<DD>The result of subtracting 2 near pointers
<DT>TY_LONG_INTEGER
<DD>The result of subtracting 2 far pointers
<DT>TY_HUGE_INTEGER
<DD>The result of subtracting 2 huge pointers
</DL>
<BR>There are two special constants.
<DL>
<DT>TY_FIRST_FREE
<DD>The first user definable type
<DT>TY_LAST_FREE
<DD>The last user definable type.
</DL>
<H2 ID="void_BEDefTypeL_cg_type_what__uint_align__unsigned_32_len_R"> void BEDefType( cg_type what, uint align, unsigned_32 len ) </H2>
<BR>Define a new type to the code generator.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>what
<DD>An integral value greater than or equal to TY_FIRST_FREE and less then or equal to TY_LAST_FREE, used as the type identifier.
<DT>align
<DD>Currently ignored.
<DT>len
<DD>The length of the new type.
</DL>
<H2 ID="void_BEAliasTypeL_cg_type_what__cg_type_to_R"> void BEAliasType( cg_type what, cg_type to ) </H2>
<BR>Define a type to be an alias for an existing type.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>what
<DD>Will become an alias for an existing type.
<DT>to
<DD>An existing type.
</DL>
<H2 ID="unsigned_32_BETypeLengthL_cg_type_type_R"> unsigned_32 BETypeLength( cg_type type ) </H2>
<BR>Return the length of a previously defined type, or a base type.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>type
<DD>A previously defined type.
</DL>
<DL>
<DT>Returns
<DD>The length associated with the type.
</DL>
<H2 ID="uint_BETypeAlignL_cg_type_type_R"> uint BETypeAlign( cg_type type ) </H2>
<BR>Return the alignment requirements of a type.&nbsp; This is always 1 for x86 and 370 machines.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>type
<DD>A previously defined type.
</DL>
<DL>
<DT>Returns
<DD>The alignment requirements of<B> type</B> as declared in BEDefType, or for a base type, as defined by the machine architecture.
</DL>
<H1 ID="Procedure_Declarations"> Procedure Declarations </H1>
<H2 ID="void_CGProcDeclL_cg_sym_handle_name__cg_type_type_R"> void CGProcDecl( cg_sym_handle name, cg_type type ) </H2>
<BR>Declare a new procedure.&nbsp; This must be the first routine to be called when generating each procedure.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>name
<DD>The front end symbol table entry for the procedure.&nbsp; A back_handle will be requested.
<DT>type
<DD>The return type of the procedure.&nbsp; Use TY_INTEGER for void functions.
</DL>
<H2 ID="void_CGParmDeclL_cg_sym_handle_name__cg_type_type_R"> void CGParmDecl( cg_sym_handle name, cg_type type ) </H2>
<BR>Declare a new parameter to the current function.&nbsp; The calls to this function define the order of the parameters.
&nbsp;This function must be called immediately after calling CGProcDecl.&nbsp; Parameters are defined in left to right order,
as defined by the procedure prototype.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>name
<DD>The symbol table entry for the parameter.
<DT>type
<DD>The type of the parameter.
</DL>
<H2 ID="label_handle_CGLastParmLR"> label_handle CGLastParm() </H2>
<BR>End a parameter declaration section.&nbsp; This function must be called after the last parameter has been declared.&nbsp;
Prior to this function, the only calls the front-end is allowed to make are CGParmDecl and CGAutoDecl.
<H2 ID="void_CGAutoDeclL_cg_sym_handle_name__cg_type_type_R"> void CGAutoDecl( cg_sym_handle name, cg_type type ) </H2>
<BR>Declare an automatic variable.
<BR><BR>This routine may be called at any point in the generation of a function between the calls to CGProcDecl and CGReturn,
but must be called before<B> name</B> is passed to CGFEName.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>name
<DD>The symbol table entry for the variable.
<DT>type
<DD>The type of the variable.
</DL>
<H2 ID="temp_handle_CGTempL_cg_type_type_R"> temp_handle CGTemp( cg_type type ) </H2>
<BR>Yields a temporary with procedure scope.&nbsp; This can be used for things such as iteration counts for FORTRAN do loops,
or a variable in which to store the return value of a function.&nbsp; This routine should be used<B> only if necessary</B>.
&nbsp;It should be used when the front end requires a temporary which persists across a flow of control boundary.&nbsp; Other
temporary results are handled by the expression trees.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>type
<DD>The type of the new temporary.
</DL>
<DL>
<DT>Returns
<DD>A temp_handle which may be passed to CGTempName.&nbsp; This will be freed and invalidated by the back end when CGReturn is
called.
</DL>
<H1 ID="Expressions"> Expressions </H1>
<BR>Expression processing involves building an expression tree in the back end, using calls to CG routines.&nbsp; There are
routines to generate leaf nodes, binary and unary nodes, and others.&nbsp; These routines return a handle for a node in a
back end tree structure, called a<B> cg_name</B>.&nbsp; This handle must be exactly once in a subsequent call to a CG routine.
&nbsp;A tree may be built in any order, but a cg_name is invalidated by a call to any CG routine with return type void.&nbsp;
The exception to this rule is CGTrash.
<BR><BR>There is no equivalent of the C address of operator.&nbsp; All leaf nodes generated for symbols, via CGFEName, CGBackName
and CGTempName, yield the address of that symbol, and it is the responsibility of the front end to use an indirection operator
to get its value.&nbsp; The following operators are available:&nbsp; 
<DL>
<DT><B><I>0-ary Operator</I></B>
<DD><B><I>C equivalent</I></B>
<DT>O_NOP
<DD>N/A
</DL>
<DL>
<DT><B><I>Unary Operator</I></B>
<DD><B><I>C equivalent</I></B>
<DT>O_UMINUS
<DD>-x
<DT>O_COMPLEMENT
<DD>x
<DT>O_POINTS
<DD>(*x)
<DT>O_CONVERT
<DD>x=y
<DT>O_ROUND
<DD>Do not use!
<DT>O_LOG
<DD>log(x)
<DT>O_COS
<DD>cos(x)
<DT>O_SIN
<DD>sin(x)
<DT>O_TAN
<DD>tan(x)
<DT>O_SQRT
<DD>sqrt(x)
<DT>O_FABS
<DD>fabs(x)
<DT>O_ACOS
<DD>acos(x)
<DT>O_ASIN
<DD>asin(x)
<DT>O_ATAN
<DD>atan(x)
<DT>O_COSH
<DD>cosh(x)
<DT>O_SINH
<DD>sinh(x)
<DT>O_TANH
<DD>tanh(x)
<DT>O_EXP
<DD>exp(x)
<DT>O_LOG10
<DD>log10(x)
<DT>O_PARENTHESIS
<DD>This operator represents the &quot;strong&quot; parenthesises of FORTRAN and C.&nbsp; It prevents the back end from performing
certain mathematically correct, but floating point incorrect optimizations.&nbsp; E.g.&nbsp; in the expression &quot;(a*2.4)/2.0&quot;,
the back end is not allowed constant fold the expression into &quot;a*1.2&quot;.
</DL>
<DL>
<DT><B><I>Binary Operator</I></B>
<DD><B><I>C equivalent</I></B>
<DT>O_PLUS
<DD>+
<DT>O_MINUS
<DD>-
<DT>O_TIMES
<DD>*
<DT>O_DIV
<DD>/
<DT>O_MOD
<DD>%
<DT>O_AND
<DD>&amp;
<DT>O_OR
<DD>|
<DT>O_XOR
<DD>^
<DT>O_RSHIFT
<DD>&gt;&gt;
<DT>O_LSHIFT
<DD>&lt;&lt;
<DT>O_COMMA
<DD>,
<DT>O_TEST_TRUE
<DD>( x &amp; y ) != 0
<DT>O_TEST_FALSE
<DD>( x &amp; y ) == 0
<DT>O_EQ
<DD>==
<DT>O_NE
<DD>!=
<DT>O_GT
<DD>&gt;
<DT>O_LE
<DD>&lt;=
<DT>O_LT
<DD>&lt;
<DT>O_GE
<DD>&gt;=
<DT>O_POW
<DD>pow( x, y )
<DT>O_ATAN2
<DD>atan2( x, y )
<DT>O_FMOD
<DD>fmod( x, y )
<DT>O_CONVERT
<DD>See below.
</DL>
<BR>The binary O_CONVERT operator is only available on the x86 code generator.&nbsp; It is used for based pointer operations
(the result type of the CGBinary call must be a far pointer type).&nbsp; It effectively performs a MK_FP operation with the
left hand side providing the offset portion of the address, and the right hand side providing the segment value.&nbsp; If
the right hand side expression is the address of a symbol, or the type of the expression is a far pointer, then the segment
value for the symbol, or the segment value of the expression is used as the segment value after the O_CONVERT operation.
<DL>
<DT><B><I>Short circuit operators</I></B>
<DD><B><I>C equivalent</I></B>
<DT>O_FLOW_AND
<DD>&amp;&amp;
<DT>O_FLOW_OR
<DD>||
<DT>O_FLOW_NOT
<DD>!
</DL>
<DL>
<DT><B><I>Control flow operators</I></B>
<DD><B><I>C equivalent</I></B>
<DT>O_GOTO
<DD>goto label;
<DT>O_LABEL
<DD>label:;
<DT>O_IF_TRUE
<DD>if( x ) goto label;
<DT>O_IF_FALSE
<DD>if( !(x) ) goto label;
<DT>O_INVOKE_LABEL
<DD>GOSUB (Basic)
<DT>O_LABEL_RETURN
<DD>RETURN (Basic)
</DL>
<BR>The type passed into a CG routine is used by the back end as the type for the resulting node.&nbsp; If the node is an
operator node (CGBinary, CGUnary) the back end will convert the operands to the result type before performing the operation.
&nbsp;If the type TY_DEFAULT is passed, the code generator will use default conversion rules to determine the resulting type
of the node.&nbsp; These rules are the same as the ANSI C value preserving rules, with the exception that characters are not
promoted to integers before doing arithmetic operations.
<BR><BR>For example, if a node of type TY_UINT_2 and a node of type TY_INT_4 are to be added, the back end will automatically
convert the operands to TY_INT_4 before performing the addition.&nbsp; The resulting node will have type TY_INT_4.
<H1 ID="Leaf_Nodes"> Leaf Nodes </H1>
<H2 ID="cg_name_CGIntegerL_signed_32_val__cg_type_type_R"> cg_name CGInteger( signed_32 val, cg_type type ) </H2>
<BR>Create an integer constant leaf node.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>val
<DD>The integral value.
<DT>type
<DD>An integral type.
</DL>
<H2 ID="cg_name_CGInt64L_signed_64_val__cg_type_type_R"> cg_name CGInt64( signed_64 val, cg_type type ) </H2>
<BR>Create an 64-bit integer constant leaf node.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>val
<DD>The 64-bit integer value.
<DT>type
<DD>An integral type.
</DL>
<H2 ID="cg_name_CGFloatL_char_Tnum__cg_type_type_R"> cg_name CGFloat( char *num, cg_type type ) </H2>
<BR>Create a floating-point constant leaf node.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>num
<DD>A NULL terminated E format string.&nbsp; (-1.23456E-102)
<DT>type
<DD>A floating point type.
</DL>
<H2 ID="cg_name_CGFENameL_cg_sym_handle_sym__cg_type_type_R"> cg_name CGFEName( cg_sym_handle sym, cg_type type ) </H2>
<BR>Create a leaf node representing the address of the back_handle associated with<B> sym</B>.&nbsp; If sym represents an
automatic variable or a parameter, CGAutoDecl or CGParmDecl must be called before this routine is first used.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>sym
<DD>The front end symbol.
<DT>type
<DD>The type to be associated with the value of the symbol.
</DL>
<H2 ID="cg_name_CGBackNameL_back_handle_bck__cg_type_type_R"> cg_name CGBackName( back_handle bck, cg_type type ) </H2>
<BR>Create a leaf node which represents the address of the back_handle.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>bck
<DD>A back handle.
<DT>type
<DD>The type to be associated with the<B> value</B> of the symbol.
</DL>
<H2 ID="cg_name_CGTempNameL_temp_handle_temp__cg_type_type_R"> cg_name CGTempName( temp_handle temp, cg_type type ) </H2>
<BR>Create a leaf node which yields the address of the temp_handle.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>temp
<DD>A temp_handle.
<DT>type
<DD>The type to be associated with the<B> value</B> of the symbol.
</DL>
<H1 ID="Assignment_Operations"> Assignment Operations </H1>
<H2 ID="cg_name_CGAssignL_cg_name_dest__cg_name_src__cg_type_type_R"> cg_name CGAssign( cg_name dest, cg_name src, cg_type type ) </H2>
<BR>Create an assignment node.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>dest
<DD>The destination address.
<DT>src
<DD>The source value.
<DT>type
<DD>The type to which the destination address points.
</DL>
<DL>
<DT>Returns
<DD>The value of the right hand side.
</DL>
<H2 ID="cg_name_CGLVAssignL_cg_name_dest__cg_name_src__cg_type_type_R"> cg_name CGLVAssign( cg_name dest, cg_name src, cg_type type ) </H2>
<BR>Like CGAssign, but yields the address of the destination.
<H2 ID="cg_name_CGPreGetsL_cg_op_op__cg_name_dest__cg_name_src__cg_type_type_R"> cg_name CGPreGets( cg_op op, cg_name dest, cg_name src, cg_type type ) </H2>
<BR>Used for the C expressions a += b, a /= b.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>op
<DD>The arithmetic operator to be used.
<DT>dest
<DD>The address of the destination.
<DT>src
<DD>The value of the right hand side.
<DT>type
<DD>The type to which the destination address points.
</DL>
<DL>
<DT>Returns
<DD>The value of the left hand side.
</DL>
<H2 ID="cg_name_CGLVPreGetsL_cg_op_op__cg_name_dest__cg_name_src__cg_type_type_R"> cg_name CGLVPreGets( cg_op op, cg_name dest, cg_name src, cg_type type ) </H2>
<BR>Like CGPreGets, but yields the address of the destination.
<H2 ID="cg_name_CGPostGetsL_cg_op_op__cg_name_dest__cg_name_src__cg_type_type_R"> cg_name CGPostGets( cg_op op, cg_name dest, cg_name src, cg_type type ) </H2>
<BR>Used for the C expressions a++, a--.&nbsp; No automatic scaling is done for pointers.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>op
<DD>The operator.
<DT>dest
<DD>The address of the destination
<DT>src
<DD>The value of the increment.
<DT>type
<DD>The type of the destination.
</DL>
<DL>
<DT>Returns
<DD>The value of the left hand side before the operation occurs.
</DL>
<H1 ID="ArithmeticDlogical_operations"> Arithmetic/logical operations </H1>
<H2 ID="cg_name_CGBinaryL_cg_op_op__cg_name_left__cg_name_right__cg_type_type_R"> cg_name CGBinary( cg_op op, cg_name left, cg_name right, cg_type type ) </H2>
<BR>Binary operations.&nbsp; No automatic scaling is done for pointer operations.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>op
<DD>The operator.
<DT>left
<DD>The value of the left hand side.
<DT>right
<DD>The value of the right hand side.
<DT>type
<DD>The result type.
</DL>
<DL>
<DT>Returns
<DD>The value of the result.
</DL>
<H2 ID="cg_name_CGUnaryL_cg_op_op__cg_name_name__cg_type_type_R"> cg_name CGUnary( cg_op op, cg_name name, cg_type type ) </H2>
<BR>Unary operations.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>op
<DD>The operator.
<DT>name
<DD>The value of operand.
<DT>type
<DD>The result type.
</DL>
<DL>
<DT>Returns
<DD>The value of the result.
</DL>
<H2 ID="cg_name_CGIndexL_cg_name_name__cg_name_by__cg_type_type__cg_type_ptype_R"> cg_name CGIndex( cg_name name, cg_name by, cg_type type, cg_type ptype ) </H2>
<BR>Obsolete.&nbsp; Do not use.
<H1 ID="Procedure_calls"> Procedure calls </H1>
<H2 ID="call_handle_CGInitCallL_cg_name_name__cg_type_type__cg_sym_handle_aux_info_R"> call_handle CGInitCall( cg_name name, cg_type type, cg_sym_handle aux_info ) </H2>
<BR>Initiate a procedure call.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>name
<DD>The address of the routine to call.
<DT>type
<DD>The return type of the routine.
<DT>aux_info
<DD>A handle which the back end may passed to FEAuxInfo to determine the attributes of the call.
</DL>
<DL>
<DT>Returns
<DD>A<B> call_handle</B> to be passed to the following routines.
</DL>
<H2 ID="void_CGAddParmL_call_handle_call__cg_name_name__cg_type_type_R"> void CGAddParm( call_handle call, cg_name name, cg_type type ) </H2>
<BR>Add a parameter to a call_handle.&nbsp; The order of parameters is defined by the order in which they are passed to this
routine.&nbsp; Parameters should be added in right to left order, as defined by the procedure call.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>call
<DD>A call_handle.
<DT>name
<DD>The value of the parameter.
<DT>type
<DD>The type of the parameter.&nbsp; This type will be passed to FEParmType to determine the actual type to be used when passing
the parameter.&nbsp; For instance, characters are usually passes as integers in C.
</DL>
<H2 ID="cg_name_CGCallL_call_handle_call_R"> cg_name CGCall( call_handle call ) </H2>
<BR>Turn a call_handle into a cg_name by performing the call.&nbsp; This may be immediately followed by an optional addition
operation, to reference a field in a structure return value.&nbsp; An indirection operator must immediately follow, even if
the function has no return value.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>call
<DD>A call_handle.
</DL>
<DL>
<DT>Returns
<DD>The address of the function return value.
</DL>
<H1 ID="ComparisonDshortMcircuit_operations"> Comparison/short-circuit operations </H1>
<H2 ID="cg_name_CGCompareL_cg_op_op__cg_name_left__cg_name_right__cg_type_type_R"> cg_name CGCompare( cg_op op, cg_name left, cg_name right, cg_type type ) </H2>
<BR>Compare two values.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>op
<DD>The comparison operator.
<DT>left
<DD>The value of the left hand side.
<DT>right
<DD>The value of the right hand side.
<DT>type
<DD>The type to which to convert the operands to before performing comparison.
</DL>
<DL>
<DT>Returns
<DD>A TY_BOOLEAN cg_name, which may be passed to a control flow CG routine, or used in an expression as an integral value.
</DL>
<H1 ID="Control_flow_operations"> Control flow operations </H1>
<H2 ID="cg_name_CGFlowL_cg_op_op__cg_name_left__cg_name_right_R"> cg_name CGFlow( cg_op op, cg_name left, cg_name right ) </H2>
<BR>Perform short-circuit boolean operations.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>op
<DD>An operator.
<DT>left
<DD>A TY_BOOLEAN or integral cg_name.
<DT>right
<DD>A TY_BOOLEAN or integral cg_name, or NULL if op is O_FLOW_NOT.
</DL>
<DL>
<DT>Returns
<DD>A TY_BOOLEAN cg_name.
</DL>
<H2 ID="cg_name_CGChooseL_cg_name_sel__cg_name_n1__cg_name_n2__cg_type_type_R"> cg_name CGChoose( cg_name sel, cg_name n1, cg_name n2, cg_type type ) </H2>
<BR>Used for the C expression<B> sel</B> ?<B>&nbsp; n1</B> :<B>&nbsp; n2</B>.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>sel
<DD>A TY_BOOLEAN or integral cg_name used as the selector.
<DT>n1
<DD>The value to return if<B> sel</B> is non-zero.
<DT>n2
<DD>The value to return if<B> sel</B> is zero.
<DT>type
<DD>The type to which convert the result.
</DL>
<DL>
<DT>Returns
<DD>The value of<B> n1</B> or<B> n2</B> depending upon the truth of<B> sel</B>.
</DL>
<H2 ID="cg_name_CGWarpL_cg_name_before__label_handle_label__cg_name_after_R"> cg_name CGWarp( cg_name before, label_handle label, cg_name after ) </H2>
<BR>To be used for FORTRAN statement functions.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>before
<DD>An arbitrary expression tree to be evaluated before<B> label</B> is called.&nbsp; This is used to assign values to statement
function arguments, which are usually temporaries allocated with CGTemp.
<DT>label
<DD>A label_handle to invoke via O_CALL_LABEL.
<DT>after
<DD>An arbitrary expression tree to be evaluated after<B> label</B> is called.&nbsp; This is used to retrieve the statement function
return value.
</DL>
<DL>
<DT>Returns
<DD>The value of<B> after</B>.&nbsp; This can be passed to CGEval, to guarantee that nested statement functions are fully evaluated
before their parameter variables are reassigned, as in f(1,f(2,3,4),5).
</DL>
<H2 ID="void_CG3WayControlL_cg_name_expr__label_handle_lt__label_handle_eq__label_handle_gt_R"> void CG3WayControl( cg_name expr, label_handle lt, label_handle eq, label_handle gt ) </H2>
<BR>Used for the FORTRAN arithmetic if statement.&nbsp; Go to label<B> lt</B>,<B> eq</B> or<B> gt</B> depending on whether<B>
expr</B> is less than, equal to, or greater than zero.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>expr
<DD>The selector value.
<DT>lt
<DD>A label_handle.
<DT>eq
<DD>A label_handle.
<DT>gt
<DD>A label_handle.
</DL>
<H2 ID="void_CGControlL_cg_op_op__cg_name_expr__label_handle_lbl_R"> void CGControl( cg_op op, cg_name expr, label_handle lbl ) </H2>
<BR>Generate conditional and unconditional flow of control.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>op
<DD>a control flow operator.
<DT>expr
<DD>A TY_BOOLEAN expression if op is O_IF_TRUE or O_IF_FALSE.&nbsp; NULL otherwise.
<DT>lbl
<DD>The target label.
</DL>
<H2 ID="void_CGBigLabelL_back_handle_lbl_R"> void CGBigLabel( back_handle lbl ) </H2>
<BR>Generate a label which may be branched to from a nested procedure or used in NT structured exception handling.&nbsp; Don't
use this call unless you *really*, *really* need to.&nbsp; It kills a lot of optimizations.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>lbl
<DD>A back_handle.&nbsp; There must be a front end symbol associated with this back handle.
</DL>
<H2 ID="void_CGBigGotoL_back_handle_value__int_level_R"> void CGBigGoto( back_handle value, int level ) </H2>
<BR>Generate a branch to a label in an outer procedure.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>lbl
<DD>A back_handle.&nbsp; There must be a front end symbol associated with this back handle.
<DT>level
<DD>The lexical level of the target label.
</DL>
<H1 ID="Select_and_Switch_statements_"> Select and Switch statements. </H1>
<BR>The select routines are used as follows.&nbsp; CGSelOther should always be used even if there is no otherwise/default
case.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; end_label = BENewLabel();</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; sel_label = BENewLabel();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CGControl( O_GOTO, NULL, sel_label );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; sel_handle = CGSelInit();</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; case_label = BENewLabel();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CGControl( O_LABEL, NULL, case_label );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CGSelCase( sel_handle, case_label, case_value );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ... generate code associated with &quot;case_value&quot;&nbsp; here.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CGControl( O_GOTO, NULL, end_label ); // or else, fall through</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; other_label = BENewLabel();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CGControl( O_LABEL, NULL, other_label );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CGSelOther( sel_handle, other_label );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ... generate &quot;otherwise&quot; code here</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CGControl( O_GOTO, NULL, end_label ); // or else, fall through</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CGControl( O_LABEL, NULL, sel_label );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CGSelect( sel_handle );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CGControl( O_LABEL, NULL, end_label );</TT>
<H2 ID="sel_handle_CGSelInitLR"> sel_handle CGSelInit() </H2>
<BR>Create a sel_handle.
<DL>
<DT>Returns
<DD>A sel_handle to be passed to the following routines.
</DL>
<H2 ID="void_CGSelCaseL_sel_handle_sel__label_handle_lbl__signed_32_val_R"> void CGSelCase( sel_handle sel, label_handle lbl, signed_32 val ) </H2>
<BR>Add a single value case to a select or switch.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>sel
<DD>A sel_handle obtained from CGSelInit().
<DT>lbl
<DD>The label to be associated with the case value.
<DT>val
<DD>The case value.
</DL>
<H2 ID="void_CGSelRangeL_sel_handle_s__signed_32_lo__signed_32_hi__label_handle_lbl_R"> void CGSelRange( sel_handle s, signed_32 lo, signed_32 hi, label_handle lbl ) </H2>
<BR>Add a range of values to a select.&nbsp; All values are eventually converted into unsigned types to generate the switch
code, so lo and hi must have the same sign.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>s
<DD>A sel_handle obtained from CGSelInit().
<DT>lo
<DD>The lower bound of the case range.
<DT>hi
<DD>The upper bound of the case range.
<DT>lbl
<DD>The label to be associated with the case value.
</DL>
<H2 ID="void_CGSelOtherL_sel_handle_s__label_handle_lbl_R"> void CGSelOther( sel_handle s, label_handle lbl ) </H2>
<BR>Add the otherwise case to a select.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>s
<DD>A sel_handle.
<DT>lbl
<DD>The label to be associated with the otherwise case.
</DL>
<H2 ID="void_CGSelectL_sel_handle_s__cg_name_expr_R"> void CGSelect( sel_handle s, cg_name expr ) </H2>
<BR>Add the select expression to a select statement and generate code.&nbsp; This must be the last routine called for a given
select statement.&nbsp; It invalidates the sel_handle.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>s
<DD>A sel_handle.
<DT>expr
<DD>The value we are selecting.
</DL>
<H2 ID="void_CGSelectRestrictedL_sel_handle_s__cg_name_expr__cg_switch_type_allowed_R"> void CGSelectRestricted( sel_handle s, cg_name expr, cg_switch_type allowed ) </H2>
<BR>Identical to CGSelect, except that only switch generation techniques corresponding to the set of allowed methods will
be considered when determining how to produce code.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>s
<DD>A sel_handle.
<DT>expr
<DD>The value we are selecting.
<DT>allowed
<DD>The allowed methods of generating code.&nbsp; Must be a combination (non-empty) of the following bits:
<UL>
<LI>CG_SWITCH_SCAN
<LI>CG_SWITCH_BSEARCH
<LI>CG_SWITCH_TABLE
</UL>
</DL>
<H1 ID="Other"> Other </H1>
<H2 ID="void_CGReturnL_cg_name_name__cg_type_type_R"> void CGReturn( cg_name name, cg_type type ) </H2>
<BR>Return from a function.&nbsp; This is the last routine that may be called in any routine.&nbsp; Multiple return statements
must be implemented with assignments to a temporary variable (CGTemp) and a branch to a label generated just before this routine
call.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>name
<DD>The value of the return value, or NULL.
<DT>type
<DD>The type of the return value.&nbsp; Use TY_INTEGER for void functions.
</DL>
<H2 ID="cg_name_CGEvalL_cg_name_name_R"> cg_name CGEval( cg_name name ) </H2>
<BR>Evaluate this expression tree now and assign its value to a leaf node.&nbsp; Used to force the order of operations.&nbsp;
This should only be used if necessary.&nbsp; Normally, the expression trees adequately define the order of operations.&nbsp;
This usually used to force the order of parameter evaluation.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>name
<DD>The tree to be evaluated.
</DL>
<DL>
<DT>Returns
<DD>A leaf node containing the value of the tree.
</DL>
<H2 ID="void_CGDoneL_cg_name_name_R"> void CGDone( cg_name name ) </H2>
<BR>Generate the tree and throw away the resultant value.&nbsp; For example, CGAssign yields a value which may not be needed,
but must be passed to this routine to cause the tree to be generated.&nbsp; This routine invalidates all cg_name handles.
&nbsp;After this routine has returned, any pending inline function expansions will have been performed.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>name
<DD>The cg_name to be generated/discarded.
</DL>
<H2 ID="void_CGTrashL_cg_name_name_R"> void CGTrash( cg_name name ) </H2>
<BR>Like CGDone, but used for partial expression trees.&nbsp; This routine does not cause all existing cg_names to become
invalid.
<H2 ID="cg_type_CGTypeL_cg_name_name_R"> cg_type CGType( cg_name name ) </H2>
<BR>Returns the type of the given cg_name.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>name
<DD>A cg_name.
</DL>
<DL>
<DT>Returns
<DD>The type of the cg_name.
</DL>
<H2 ID="cg_name_TCGDuplicateL_cg_name_name_R"> cg_name *CGDuplicate( cg_name name ) </H2>
<BR>Create two copies of a cg_name.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>name
<DD>The cg_name to be duplicated.
</DL>
<DL>
<DT>Returns
<DD>A pointer to an array of two new cg_names, each representing the same value as the original.&nbsp; These should be copied
out of the array immediately since subsequent calls to CGDuplicate will overwrite the array.
</DL>
<H2 ID="cg_name_CGBitMaskL_cg_name_name__byte_start__byte_len__cg_type_type_R"> cg_name CGBitMask( cg_name name, byte start, byte len, cg_type type ) </H2>
<BR>Yields the address of a bit field.&nbsp; This address may not really be used except with an indirection operator or as
the destination of an assignment operation.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>name
<DD>The address of the integral variable containing the bit field.
<DT>start
<DD>The position of the least significant bit of the bit field.&nbsp; 0 indicates the least significant bit of the host data type.
<DT>len
<DD>The length of the bit field in bits.
<DT>type
<DD>The integral type of the value containing the bit field.
</DL>
<DL>
<DT>Returns
<DD>The address of the bit field.&nbsp; To reference field2 in the following C structure for a little endian target, use start=4,
len=5, and type=TY_INT_2.&nbsp; For a big endian target, start=7.
</DL>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef struct {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short field1 : 4;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short field2 : 5;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short field3 : 7;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="cg_name_CGVolatileL_cg_name_name_R"> cg_name CGVolatile( cg_name name ) </H2>
<BR>Indicate that the given address points to a volatile location.&nbsp; This back end does not remember this information
beyond this node in the expression tree.&nbsp; If an address points to a volatile location, the front end must call this routine
each time that address is used.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>name
<DD>The address of the volatile location.
</DL>
<DL>
<DT>Returns
<DD>A new cg_name representing the same value as name.
</DL>
<H2 ID="cg_name_CGCallbackL_cg_callback_func__void_Tptr_R"> cg_name CGCallback( cg_callback func, void *ptr ) </H2>
<BR>When a callback node is inserted into the tree, the code generator will call the given function with the pointer as a
parameter when it turns the node into an instruction.&nbsp; This can be used to retrieve order information about the placement
of nodes in the instruction stream.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>func
<DD>This is a pointer to a function which is compatible with the C type &quot;void (*)(void *)&quot;.&nbsp; This function will
be called with the second parameter to this function as it's only parameter sometime during the execution of the CGDone call.
<DT>ptr
<DD>This will be a parameter to the function given as the first parameter.
</DL>
<H2 ID="cg_name_CGPatchNodeL_patch_handle_hdl__cg_type_type_R"> cg_name CGPatchNode( patch_handle hdl, cg_type type ) </H2>
<BR>This prepares a leaf node to hold an integer constant which will be provided sometime during the execution of the CGDone
call by means of a BEPatchInteger() call.&nbsp; It is an error to insert a patch node into the tree and not call BEPatchInteger().
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>hdl
<DD>A handle for a patch allocated with BEPatch().
<DT>type
<DD>The actual type of the node.&nbsp; Must be an integer type.
</DL>
<H1 ID="Data_Generation"> Data Generation </H1>
<BR>The following routines generate a data item described at the current location in the current segment, and increment the
current location by the size of the generated object.
<H2 ID="void_DGLabelL_back_handle_bck_R"> void DGLabel( back_handle bck ) </H2>
<BR>Generate the label for a given back_handle.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>bck
<DD>A back_handle.
</DL>
<H2 ID="void_DGBackPtrL_back_handle_bck__segment_id_segid__signed_32_offset__cg_type_type_R"> void DGBackPtr( back_handle bck, segment_id segid, signed_32 offset, cg_type type ) </H2>
<BR>Generate a pointer to the label defined by the back_handle.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>bck
<DD>A back_handle.
<DT>segid
<DD>The segment_id of the segment in which the label for<B> bck</B> will be defined if it has not already been passed to DGLabel.
<DT>offset
<DD>A value to be added to the generated pointer value.
<DT>type
<DD>The pointer type to be used.
</DL>
<H2 ID="void_DGFEPtrL_cg_sym_handle_sym__cg_type_type__signed_32_offset_R"> void DGFEPtr( cg_sym_handle sym, cg_type type, signed_32 offset ) </H2>
<BR>Generate a pointer to the label associated with<B> sym</B>.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>sym
<DD>A cg_sym_handle.
<DT>type
<DD>The pointer type to be used.
<DT>offset
<DD>A value to be added to the generated pointer value.
</DL>
<H2 ID="void_DGIntegerL_unsigned_32_value__cg_type_type_R"> void DGInteger( unsigned_32 value, cg_type type ) </H2>
<BR>Generate an integer.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>value
<DD>An integral value.
<DT>type
<DD>The integral type to be used.
</DL>
<H2 ID="void_DGInteger64L_unsigned_64_value__cg_type_type_R"> void DGInteger64( unsigned_64 value, cg_type type ) </H2>
<BR>Generate an 64-bit integer.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>value
<DD>An 64-bit integer value.
<DT>type
<DD>The integral type to be used.
</DL>
<H2 ID="void_DGFloatL_char_Tvalue__cg_type_type_R"> void DGFloat( char *value, cg_type type ) </H2>
<BR>Generate a floating-point constant.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>value
<DD>An E format string (ie:&nbsp; 1.2345e-134)
<DT>type
<DD>The floating point type to be used.
</DL>
<H2 ID="void_DGCharL_char_value_R"> void DGChar( char value ) </H2>
<BR>Generate a character constant.&nbsp; Will be translated if cross compiling.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>value
<DD>A character value.
</DL>
<H2 ID="void_DGStringL_char_Tvalue__uint_len_R"> void DGString( char *value, uint len ) </H2>
<BR>Generate a character string.&nbsp; Will be translated if cross compiling.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>value
<DD>Pointer to the characters to put into the segment.&nbsp; It is not necessarily a null terminated string.
<DT>len
<DD>The length of the string.
</DL>
<H2 ID="void_DGBytesL_unsigned_32_len__byte_Tsrc_R"> void DGBytes( unsigned_32 len, byte *src ) </H2>
<BR>Generate raw binary data.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>src
<DD>Pointer to the data.
<DT>len
<DD>The length of the byte stream.
</DL>
<H2 ID="void_DGIBytesL_unsigned_32_len__byte_pat_R"> void DGIBytes( unsigned_32 len, byte pat ) </H2>
<BR>Generate the byte<B> pat</B>,<B> len</B> times.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>pat
<DD>The pattern byte.
<DT>len
<DD>The number of times to repeat the byte.
</DL>
<H2 ID="void_DGUBytesL_unsigned_32_len_R"> void DGUBytes( unsigned_32 len ) </H2>
<BR>Generate<B> len</B> undefined bytes.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>len
<DD>The size by which to increase the segment.
</DL>
<H2 ID="void_DGAlignL_uint_align_R"> void DGAlign( uint align ) </H2>
<BR>Align the segment to an<B> align</B> byte boundary.&nbsp; Any slack bytes will have an undefined value.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>align
<DD>The desired alignment boundary.
</DL>
<H2 ID="unsigned_32_DGSeekL_unsigned_32_where_R"> unsigned_32 DGSeek( unsigned_32 where ) </H2>
<BR>Seek to a location within a segment.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>where
<DD>The location within the segment.
</DL>
<DL>
<DT>Returns
<DD>The current location in the segment before the seek takes place.
</DL>
<H2 ID="unsigned_long_DGTellLR"> unsigned long DGTell() </H2>
<DL>
<DT>Returns
<DD>The current location within the segment.
</DL>
<H2 ID="unsigned_long_DGBackTellL_back_handle_bck_R"> unsigned long DGBackTell( back_handle bck ) </H2>
<DL>
<DT>Returns
<DD>The location of the label within its segment.&nbsp; The label must have been previously generated via DGLabel.
</DL>
<H1 ID="Front_End_Routines"> Front End Routines </H1>
<H2 ID="void_FEGenProcL_cg_sym_handle_sym_R"> void FEGenProc( cg_sym_handle sym ) </H2>
<BR>This routine will be called when the back end is generating a tree and encounters a function call having the<B> call_class</B>
MAKE_CALL_INLINE.&nbsp; The front end must save its current state and start generating code for<B> sym</B>.&nbsp; FEGenProc
calls may be nested if the code generator encounters an inline within the code for an inline function.&nbsp; The front end
should maintain a state stack.&nbsp; It is up to the front end to prevent infinite recursion.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>sym
<DD>The cg_sym_handle of the function to be generated.
</DL>
<H2 ID="back_handle_FEBackL_cg_sym_handle_sym_R"> back_handle FEBack( cg_sym_handle sym ) </H2>
<BR>Return, and possibly allocate using BENewBack, a back handle for sym.&nbsp; See the example under <A HREF="#Back_Handles">Back Handles</A>
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>sym
<DD>
</DL>
<DL>
<DT>Returns
<DD>A back_handle.
</DL>
<H2 ID="segment_id_FESegIDL_cg_sym_handle_sym_R"> segment_id FESegID( cg_sym_handle sym ) </H2>
<BR>Return the segment_id for symbol<B> sym</B>.&nbsp; A negative value may be returned to indicate that the symbol is defined
in an unknown PRIVATE segment which has been defined in another module.&nbsp; If two symbols have the same negative value
returned, the back end assumes that they are both defined in the same (unknown) segment.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>sym
<DD>A cg_sym_handle.
</DL>
<DL>
<DT>Returns
<DD>A segment_id.
</DL>
<H2 ID="char_TFEModuleNameLR"> char *FEModuleName() </H2>
<DL>
<DT>Returns
<DD>A null terminated string which is the name of the module being compiled.&nbsp; This is usually the file name with path and
extension information stripped.
</DL>
<H2 ID="char_FEStackCheckL_cg_sym_handle_sym_R"> char FEStackCheck( cg_sym_handle sym ) </H2>
<DL>
<DT>Returns
<DD>1 if stack checking required for this routine
</DL>
<H2 ID="unsigned_FELexLevelL_cg_sym_handle_sym_R"> unsigned FELexLevel( cg_sym_handle sym ) </H2>
<DL>
<DT>Returns
<DD>The lexical level of routine<B> sym</B>.&nbsp; This must be zero for all languages except Pascal.&nbsp; In Pascal, 1 indicates
the level of the main program.&nbsp; Each nested procedures adds an additional level.
</DL>
<H2 ID="char_TFENameL_cg_sym_handle_sym_R"> char *FEName( cg_sym_handle sym ) </H2>
<DL>
<DT>Returns
<DD>A NULL terminated character string which is the name of sym.&nbsp; A null string should be returned if the symbol has no name.
&nbsp;NULL should never be returned.
</DL>
<H2 ID="char_TFEExtNameL_cg_sym_handle_sym__int_request_R"> char *FEExtName( cg_sym_handle sym, int request ) </H2>
<DL>
<DT>Returns
<DD>A various kind in dependency on request parameter.
<DT><B><I>Request parameter</I></B>
<DD><B><I>Returns</I></B>
<DT>EXTN_BASENAME
<DD>NULL terminated character string which is the name of sym.&nbsp; A null string should be returned if the symbol has no name.
&nbsp;NULL should never be returned.
<DT>EXTN_PATTERN
<DD>NULL terminated character string which is the pattern for symbol name decoration.&nbsp; '*' is replaced by symbol name.&nbsp;
'^' is replaced by its upper case equivalent.&nbsp; '!' is replaced by its lower case equivalent.&nbsp; '#' is replaced by
'@nnn' where nnn is decimal number representing total size of all function parameters.&nbsp; If an '\' is present, the character
following is used literally.
<DT>EXTN_PRMSIZE
<DD>Returns int value which represent size of all parameters when symbol is function.
</DL>
<H2 ID="cg_type_FEParmTypeL_cg_sym_handle_func__cg_sym_handle_parm__cg_type_type_R"> cg_type FEParmType( cg_sym_handle func, cg_sym_handle parm, cg_type type ) </H2>
<DL>
<DT>Returns
<DD>The type to which to promote an argument with a given type before passing it to a procedure.&nbsp; Type will be a dealiased
type.
</DL>
<H2 ID="int_FETrueLR"> int FETrue() </H2>
<DL>
<DT>Returns
<DD>The value of TRUE.&nbsp; This is normally 1.
</DL>
<H2 ID="char_FEMoreMemL_size_t_size_R"> char FEMoreMem( size_t size ) </H2>
<BR>Release memory for the back end to use.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>size
<DD>is the amount of memory required
</DL>
<DL>
<DT>Returns
<DD>1 if at least<B> size</B> bytes were released.&nbsp; May always return 0 if memory is not a scarce resource in the host environment.
</DL>
<H2 ID="dbg_type_FEDbgTypeL_cg_sym_handle_sym_R"> dbg_type FEDbgType( cg_sym_handle sym ) </H2>
<DL>
<DT>Returns
<DD>The dbg_type handle for the symbol<B> sym</B>.
</DL>
<H2 ID="fe_attr_FEAttrL_cg_sym_handle_sym_R"> fe_attr FEAttr( cg_sym_handle sym ) </H2>
<BR>Return symbol attributes for<B> sym</B>.&nbsp; These are bits combinable with the bit-wise or operator |.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>sym
<DD>A cg_sym_handle.
</DL>
<DL>
<DT><B><I>Return value</I></B>
<DD><B><I> Definition</I></B>
<DT>FE_PROC
<DD>A procedure.
<DT>FE_STATIC
<DD>A static or external symbol.
<DT>FE_GLOBAL
<DD>Is a global (extern) symbol.
<DT>FE_IMPORT
<DD>Needs to be imported.
<DT>FE_CONSTANT
<DD>The symbol is read only.
<DT>FE_MEMORY
<DD>This automatic variable needs a memory location.
<DT>FE_VISIBLE
<DD>Accessible outside this procedure?
<DT>FE_NOALIAS
<DD>No pointers point to this symbol.
<DT>FE_UNIQUE
<DD>This symbol should have an address which is different from all other symbols with the FE_UNIQUE attribute.
<DT>FE_COMMON
<DD>There might be multiple definitions of this symbol in a program, and it should be generated in such a way that all versions
of the symbol are merged into one copy by the linker.
<DT>FE_ADDR_TAKEN
<DD>The symbol has had it's address taken somewhere in the program (not necessarally visible to the code generator).
<DT>FE_VOLATILE
<DD>The symbol is &quot;volatile&quot; (in the C language sense).
<DT>FE_INTERNAL
<DD>The symbol is not at file scope.
</DL>
<H2 ID="void_FEMessageL_msg_class_msg__void_Textra_R"> void FEMessage( msg_class msg, void *extra ) </H2>
<BR>Relays information to the front end.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>msg
<DD>Defined below.
<DT>extra
<DD>Extra information.&nbsp; The type and meaning depends on the value of<B> msg</B> and is indicated below.
</DL>
<DL>
<DT>MSG_INFO_FILE 
<DD>Informational message about file.&nbsp; extra (void) is ignored.
<DT>MSG_CODE_SIZE
<DD>Code size.&nbsp; Extra (int) is the size of the generated code.
<DT>MSG_DATA_SIZE
<DD>Data size.&nbsp; Extra (int) is the size of the generated data.
<DT>MSG_ERROR
<DD>A back end error message.&nbsp; Extra (char *) is the error message.
<DT>MSG_FATAL
<DD>A fatal code generator error.&nbsp; Extra (char *) is the reason for the fatal error.&nbsp; The front end should issue this
message and exit immediately to the system.
<DT>MSG_INFO_PROC
<DD>Informational message about current procedure.&nbsp; Extra (char *) is a message.
<DT>MSG_BAD_PARM_REGISTER
<DD>Invalid parameter register returned from FEAuxInfo.&nbsp; Extra (int) is position of the offending parameter.
<DT>MSG_BAD_RETURN_REGISTER
<DD>Invalid return register returned from FEAuxInfo.&nbsp; Extra (aux_handle) is the offending aux_handle.
<DT>MSG_REGALLOC_DIED
<DD>The register alloc ran out of memory.&nbsp; Extra (cg_sym_handle) is the procedure which was not fully optimized.
<DT>MSG_SCOREBOARD_DIED
<DD>The register scoreboard ran out of memory.&nbsp; Extra (cg_sym_handle) is the procedure which was not fully optimized.
<DT>MSG_PEEPHOLE_FLUSHED
<DD>Peep hole optimizer flushed due to lack of memory.&nbsp; (void)
<DT>MSG_BACK_END_ERROR
<DD>BAD NEWS!&nbsp; Internal compiler error.&nbsp; Extra (int) is an internal error number.
<DT>MSG_BAD_SAVE
<DD>Invalid register modification information return from FEAuxInfo.&nbsp; Extra (aux_handle) is the offending aux_handle.
<DT>MSG_WANT_MORE_DATA
<DD>The back end wants more data space.&nbsp; Extra (int) is amount of additional memory needed to run.&nbsp; (DOS real mode hosts
only).
<DT>MSG_BLIP
<DD>Blip.&nbsp; Let the world know we're still alive by printing a dot on the screen.&nbsp; This is called approximately every
4 seconds during code generation.&nbsp; (void)
<DT>MSG_BAD_LINKAGE
<DD>Cannot resolve linkage conventions.&nbsp; 370 only.&nbsp; (sym)
<DT>MSG_SCHEDULER_DIED
<DD>Instruction scheduler ran out of memory.&nbsp; Extra (cg_sym_handle) is the procedure which was not fully optimized.
<DT>MSG_NO_SEG_REGS
<DD>(Only occurs in the x86 version).&nbsp; The cg_switches did not allow any segment registers to float, but the user has requested
a far pointer indirection.&nbsp; Extra (cg_sym_handle) is the procedure which contained the far pointer usage.
<DT>MSG_SYMBOL_TOO_LONG
<DD>Given symbol is too long and is truncated to maximum permited length for current module output format.&nbsp; Extra (cg_sym_handle)
is the symbol which was truncated.
</DL>
<H2 ID="void_TFEAuxInfoL_void_Textra__aux_class_class_R"> void *FEAuxInfo( void *extra, aux_class class ) </H2>
<BR>relay information to back end
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>extra
<DD>Extra information.&nbsp; Its type and meaning is determined by the value of class.
<DT>class
<DD>Defined below.
</DL>
<DL>
<DT><B><I>Parameters</I></B>
<DD><B><I>Return Value</I></B>
<DT>( cg_sym_handle, AUX_LOOKUP )
<DD>aux_handle - given a cg_sym_handle, return an aux_handle.
<DT>( aux_handle, CALL_BYTES )
<DD>byte_seq * - A pointer to bytes to be generated instead of a call, or NULL if a call is to be generated.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef struct byte_seq {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; length;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; data[ 1 ];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; } byte_seq;</TT>
<DT>( aux_handle, CALL_CLASS )
<DD>call_class * - returns call_class of the given aux_handle.&nbsp; See definitions below.
<DT>( short, FREE_SEGMENT )
<DD>short - A free segment value which is free memory for the code generator to use.&nbsp; The first word at segment:0 is the
size of the free memory in bytes.&nbsp; (DOS real mode host only)
<DT>( NULL, OBJECT_FILE_NAME )
<DD>char * - The name of the object file to be generated.&nbsp; 
<DT>( aux_handle, PARM_REGS )
<DD>hw_reg_set[] - The set of register to be used as parameters.
<DT>( aux_handle, RETURN_REG )
<DD>hw_reg_set * - The return register.&nbsp; This is only called if the routine is declared to have the SPECIAL_RETURN call_class.
<DT>( NULL, REVISION_NUMBER )
<DD>int - Front end revision number.&nbsp; Must return II_REVISION.
<DT>( aux_handle, SAVE_REGS )
<DD>hw_reg_set * - Registers which are preserved by the routine.
<DT>( cg_sym_handle, SHADOW_SYMBOL )
<DD>cg_sym_handle - An alternate handle for a symbol.&nbsp; Required for FORTRAN.&nbsp; Usually implemented by turning on the
LSB of a pointer or MSB of an integer.
<DT>( NULL, SOURCE_NAME )
<DD>char * - The name of the source file to be put into the object file.
<DT>( cg_sym_handle, TEMP_LOC_NAME )
<DD>Return one of TEMP_LOC_NO, TEMP_LOC_YES, TEMP_LOC_QUIT.&nbsp; After the back end has assigned stack locations to those temporaries
which were not placed in registers, it begins to call FEAuxInfo with this request and passes in the cg_sym_handle for each
of those temporaries.&nbsp; If the front end responds with TEMP_LOC_QUIT the back end will stop making TEMP_LOC_NAME requests.
&nbsp;If the front end responds with TEMP_LOC_YES the back end will then perform a TEMP_LOC_TELL request (see next).&nbsp;
If the front end returns TEMP_LOC_NO the back end moves onto the next cg_sym_handle in its list.
<DT>( int, TEMP_LOC_TELL )
<DD>Returns nothing.&nbsp; The 'int' value passed in is the relative position on the stack for the temporary identified by the
cg_sym_handle passed in from the previous TEMP_LOC_NAME.&nbsp; The value for an individual temporary has no meaning, but the
difference between two of the values is the number of bytes between the addresses of the temporaries on the stack.
<DT>( void *, NEXT_DEPENDENCY )
<DD>Returns the handle of the next dependency file for which information is available.&nbsp; To start the list off, the back end
passes in NULL for the dependency file handle.
<DT>( void *, DEPENDENCY_TIMESTAMP )
<DD>Given the dependency file handle from the last NEXT_DEPENDENCY request, return pointer to an unsigned long containing a timestamp
value for the dependency file.
<DT>( void *, DEPENDENCY_NAME )
<DD>Given the dependency file handle from the last NEXT_DEPENDENCY request, return a pointer to a string containing the name for
the dependency file.
<DT>( NULL, SOURCE_LANGUAGE )
<DD>Returns a pointer to a string which identifies the source language of the pointer.&nbsp; E.g.&nbsp; &quot;C&quot; for C, &quot;FORTRAN&quot;
for FORTRAN, &quot;CPP&quot; for C++.
<DT>( cg_sym_handle, DEFAULT_IMPORT_RESOLVE )
<DD>Only called for imported symbols.&nbsp; Returns a cg_sym_handle for another imported symbol which the reference should be
resolved to if certain conditions are met (see IMPORT_TYPE request).&nbsp; If NULL or the original cg_sym_handle is returned,
there is no default import resolution symbol.
<DT>( int, UNROLL_COUNT )
<DD>Returns a user-specified unroll count, or 0 if the user did not specify an unroll count.&nbsp; The parameter is the nesting
level of the loop for which the request is being made.&nbsp; Loops which are not contained inside of other loops are nesting
level 1.&nbsp; If this function returns a non-zero value, the loop in question will be unrolled that many times (there will
be (count + 1) copies of the body).
</DL>
<DL>
<DT><B><I>x86 Parameters</I></B>
<DD><B><I>Return value</I></B>
<DT>( NULL, CODE_GROUP )
<DD>char * - The name of the code group.
<DT>( aux_handle, STRETURN_REG )
<DD>hw_reg_set * - The register which points to a structure return value.&nbsp; Only called if the routine has the SPECIAL_STRUCT_RETURN
attribute.
<DT>( void *, NEXT_IMPORT )
<DD>void * (See notes at end) - A handle for the next symbol to generate a reference to in the object file.
<DT>( void*, IMPORT_NAME )
<DD>char * - The EXTDEF name to generate given a handle
<DT>( void *, NEXT_IMPORT_S )
<DD>void * (See notes at end) - A handle for the next symbol to generate a reference to in the object file.
<DT>( void*, IMPORT_NAME_S )
<DD>Returns a cg_sym_handle.&nbsp; The EXTDEF name symbol reference to generate given a handle.
<DT>( void*, NEXT_LIBRARY )
<DD>void * (See notes at end) - Handle for the next library required
<DT>( void*, LIBRARY_NAME )
<DD>char * - The library name to generate given a handle
<DT>( NULL, DATA_GROUP )
<DD>char * - Used to name DGROUP exactly.&nbsp; NULL means use no group at all.
<DT>( segment_id, CLASS_NAME )
<DD>NULL - Used to name the class of a segment.
<DT>( NULL, USED_8087 )
<DD>NULL - Indicate that 8087 instructions were generated.
<DT>( NULL, STACK_SIZE_8087 )
<DD>int - How many 8087 registers are reserved for stack.
<DT>( NULL, CODE_LABEL_ALIGNMENT )
<DD>char * - An array x, such that x[i] is the label alignment requirements for labels nested within i loops.
<DT>( NULL, PROEPI_DATA_SIZE )
<DD>int - How much stack is reserved for the prolog hook routine.
<DT>( cg_sym_handle, IMPORT_TYPE )
<DD>Returns IMPORT_IS_WEAK, IMPORT_IS_LAZY, IMPORT_IS_CONDITIONAL.&nbsp; If the DEFAULT_IMPORT_RESOLVE request returned a default
resolution symbol the back end then performs an IMPORT_TYPE request to determine the type of the resolution.&nbsp; IMPORT_IS_WEAK
generates a weak import (the symbol is not searched for in libraries).&nbsp; IMPORT_IS_LAZY generates a lazy import (the symbol
is searched for in libraries).&nbsp; IMPORT_IS_CONDITIONAL is used for eliminating unused virtual functions.&nbsp; The default
symbol resolution is used if none of the conditional symbols are referenced/defined by the program.&nbsp; The back end is
informed of the list of conditional symbols by the following three aux requests.&nbsp; IMPORT_IS_CONDITIONAL_PURE is used
for eliminating unused pure virtual functions.
<DT>( cg_sym_handle, CONDITIONAL_IMPORT )
<DD>Returns void *.&nbsp; Once the back end determines that it has a conditional import, it performs this request to get a conditional
list handle which is the head of the list of conditional symbols.
<DT>( void *, CONDITIONAL_SYMBOL )
<DD>Returns a cg_sym_handle.&nbsp; Give an conditional list handle, return the front end symbol associated with it.
<DT>( void *, NEXT_CONDITIONAL )
<DD>Given an conditional list handle, return the next conditional list handle.&nbsp; Return NULL at the end of the list.
<DT>( aux_handle, VIRT_FUNC_REFERENCE )
<DD>Returns void *.&nbsp; When performing an indirect function call, the back end invokes FEAuxInfo passing the aux_handle supplied
with the CGInitCall.&nbsp; If the indirect call is referencing a C++ virtual function, the front end should return a magic
cookie which is the head of a list of virtual functions that might be invoked by this call.&nbsp; If it is not a virtual function
invocation, return NULL.
<DT>( void *, VIRT_FUNC_NEXT_REFERENCE )
<DD>Returns void *.&nbsp; Given the magic cookie returned by the VIRT_FUNC_REFERENCE or a previous VIRT_FUNC_NEXT_REFRENCE, return
the next magic cookie in the list of virtual functions that might be refrenced from this indirect call.&nbsp; Return NULL
if at the end of the list.
<DT>( void *, VIRT_FUNC_SYM )
<DD>Returns cg_sym_handle.&nbsp; Given a magic cookie from a VIRT_FUNC_REFERENCE or VIRT_FUNC_NEXT_REFERENCE, return the cg_sym_handle
for that entry in the list of virtual functions that might be invoked.
<DT>( segment_id, PEGGED_REGISTER )
<DD>Returns a pointer at a hw_reg_set or NULL.&nbsp; If the pointer is non-NULL and the hw_reg_set is not EMPTY, the hw_reg_set
will indicate a segment register that is pegged (pointing) to the given segment_id.&nbsp; The code generator will use this
segment register in any references to objects in the segment.&nbsp; If the pointer is NULL or the hw_reg_set is EMPTY, the
code generator uses the cg_switches to determine if a segment register is pointing at the segment or if it will have to load
one.
</DL>
<DL>
<DT><B><I>Call Class</I></B>
<DD><B><I>Meaning</I></B> 
<DT>REVERSE_PARMS
<DD>Reverse the parameter list.
<DT>SUICIDAL
<DD>Routine never returns.
<DT>PARMS_BY_ADDRESS
<DD>Pass parameters by reference.
<DT>MAKE_CALL_INLINE
<DD>Call should be inline.&nbsp; FEGenProc will be called for code sequence when required.
</DL>
<DL>
<DT><B><I>x86 Call Class</I></B>
<DD><B><I>Meaning</I></B>
<DT>FAR
<DD>Does routine require a far call/return.
<DT>LOAD_DS_ON_CALL
<DD>Load DS from DGROUP prior to call.
<DT>CALLER_POPS
<DD>Caller pops/removes parms from the stack.
<DT>ROUTINE_RETURN
<DD>Routine allocates structure return memory.
<DT>SPECIAL_RETURN
<DD>Routine has non-default return register.
<DT>NO_MEMORY_CHANGED
<DD>Routine modifies no visible statics.
<DT>NO_MEMORY_READ
<DD>Routine reads no visible statics.
<DT>MODIFY_EXACT
<DD>Routine modifies no parameter registers.
<DT>SPECIAL_STRUCT_RETURN
<DD>Routine has special struct return register.
<DT>NO_STRUCT_REG_RETURNS
<DD>Pass 2/4/8 byte structs on stack, as opposed to registers.
<DT>NO_FLOAT_REG_RETURNS
<DD>Return floats as structs.
<DT>INTERRUPT
<DD>Routine is an interrupt routine.
<DT>NO_8087_RETURNS
<DD>No return values in the 8087.
<DT>LOAD_DS_ON_ENTRY
<DD>Load ds with dgroup on entry.
<DT>DLL_EXPORT
<DD>Is routine an OS/2 export symbol?
<DT>FAT_WINDOWS_PROLOG
<DD>Generate the real mode windows prolog code.
<DT>GENERATE_STACK_FRAME
<DD>Always generate a traceable prolog.
<DT>EMIT_FUNCTION_NAME
<DD>Emit the function name in front of the function in the code segment.
<DT>GROW_STACK
<DD>Emit a call to grow the stack on entry
<DT>PROLOG_HOOKS
<DD>Generate a prolog hook call.
<DT>EPILOG_HOOKS
<DD>Generate an epilog hook call.
<DT>THUNK_PROLOG
<DD>Generate a thunking prolog for routines calling 16 bit code.
<DT>FAR16_CALL
<DD>Performs a 16:16 call in the 386 compiler.
<DT>TOUCH_STACK
<DD>Certain people (who shall remain nameless) have implemented an operating system (which shall remain nameless) that can't be
bothered figuring out whether a page reference is in the stack or not.&nbsp; This attribute forces the first reference to
the stack (after a routine prologue has grown it) to be through the SS register.
</DL>
<H1 ID="Debugging_Information"> Debugging Information </H1>
<BR>These routines generate information about types, symbols, etc.
<H2 ID="void_DBLineNumL_uint_no_R"> void DBLineNum( uint no ) </H2>
<BR>Set the current source line number.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>no
<DD>Is the current source line number.
</DL>
<H2 ID="void_DBModSymL_cg_sym_handle_sym__cg_type_indirect_R"> void DBModSym( cg_sym_handle sym, cg_type indirect ) </H2>
<BR>Define a symbol within the module (file scope).
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>sym
<DD>is a front end symbol handle.
<DT>indirect
<DD>is the type of indirection needed to obtain the value
</DL>
<H2 ID="void_DBObjectL_dbg_type_tipe__dbg_loc_loc_R"> void DBObject( dbg_type tipe, dbg_loc loc ) </H2>
<BR>Define a function as being a member function of a C++ class, and identify the type of the class and the location of the
object being manipulated.&nbsp; This function may only be done after the DBModSym for the function.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>tipe
<DD>is the debug type of the class that the function is a member of.
<DT>loc
<DD>is a location expression that evaluates to the address of the object being manipulated by the function (the contents of the
'this' pointer in C++).&nbsp; This parameter is NULL if the routine is a static member function.
</DL>
<H2 ID="void_DBLocalSymL_cg_sym_handle_sym__cg_type_indirect_R"> void DBLocalSym( cg_sym_handle sym, cg_type indirect ) </H2>
<BR>As DBModSym but for local (routine scope) symbols.
<H2 ID="void_DBGenSymL_cg_sym_handle_sym__dbg_loc_loc__int_scoped_R"> void DBGenSym( cg_sym_handle sym, dbg_loc loc, int scoped ) </H2>
<BR>Define a symbol either with module scope ('scoped' == 0) or within the current block ('scoped' != 0).&nbsp; This routine
superseeds both DBLocalSym and DBModuleSym.&nbsp; The 'loc' parameter is a location expression (explained later) which allows
an aribitrary sequence of operations to locate the storage for the symbol.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>sym
<DD>is a front end symbol handle.
<DT>loc
<DD>the location expression which is evaluated by the debugger to locate the lvalue of the symbol.
<DT>scoped
<DD>whether the symbol is file scoped or not.
</DL>
<H2 ID="void_DBBegBlockLR"> void DBBegBlock() </H2>
<BR>Open a new scope level.
<H2 ID="void_DBEndBlockLR"> void DBEndBlock() </H2>
<BR>Close the current scope level.
<H2 ID="dbg_type_DBScalarL_char_Tname__cg_type_tipe_R"> dbg_type DBScalar( char *name, cg_type tipe ) </H2>
<BR>Defines the string<B> name</B> to have type<B> tipe</B>.
<H2 ID="dbg_type_DBScopeL_char_Tname_R"> dbg_type DBScope( char *name ) </H2>
<BR>define a symbol which &quot;scopes&quot; subsequent symbols.&nbsp; In C, the keywords<B> enum</B>,<B> union</B>,<B> struct</B>
may perform this function as in<B> struct foo</B>.
<H2 ID="dbg_name_DBBegNameL_const_char_Tname__dbg_type_scope_R"> dbg_name DBBegName( const char *name, dbg_type scope ) </H2>
<BR>start a type name whose type is yet undetermined
<H2 ID="dbg_type_DBForwardL_dbg_name_name_R"> dbg_type DBForward( dbg_name name ) </H2>
<BR>declare a type to be a forward reference
<H2 ID="dbg_type_DBEndNameL_dbg_name_name__dbg_type_tipe_R"> dbg_type DBEndName( dbg_name name, dbg_type tipe ) </H2>
<BR>complete the definition of a type name.
<H2 ID="dbg_type_DBArrayL_dbg_type_index__dbg_type_base_R"> dbg_type DBArray( dbg_type index, dbg_type base ) </H2>
<BR>define a C array type
<H2 ID="dbg_type_DBIntArrayL_unsigned_32_hi__dbg_type_base_R"> dbg_type DBIntArray( unsigned_32 hi, dbg_type base ) </H2>
<BR>define a C array type
<H2 ID="dbg_type_DBSubRangeL_signed_32_lo__signed_32_hi__dbg_type_base_R"> dbg_type DBSubRange( signed_32 lo, signed_32 hi, dbg_type base ) </H2>
<BR>define an integer range type
<H2 ID="dbg_type_DBPtrL_cg_type_ptr_type__dbg_type_base_R"> dbg_type DBPtr( cg_type ptr_type, dbg_type base ) </H2>
<BR>declare a pointer type
<H2 ID="dbg_type_DBBasedPtrL_cg_type_ptr_type__dbg_type_base__dbg_loc_seg_loc_R"> dbg_type DBBasedPtr( cg_type ptr_type, dbg_type base, dbg_loc seg_loc ) </H2>
<BR>declare a based pointer type.&nbsp; The 'seg_loc' parameter is a location expression which evaluates to the base address
for the pointer after the indirection has been performed.&nbsp; Before the location expression is evalated, the current lvalue
of the pointer symbol associated with this type is pushed onto the expression stack (needed for based on self pointers).
<H2 ID="dbg_struct_DBBegStructLR"> dbg_struct DBBegStruct() </H2>
<BR>start a structure type definition
<H2 ID="void_DBAddFieldL_dbg_struct_st__unsigned_32_off__char_Tnm__dbg_type_base_R"> void DBAddField( dbg_struct st, unsigned_32 off, char *nm, dbg_type base ) </H2>
<BR>add a field to a structure
<H2 ID="void_DBAddBitFieldL_dbg_struct_st__unsigned_32_off__byte_strt__byte_len__char_Tnm__dbg_type_base_R"> void DBAddBitField( dbg_struct st, unsigned_32 off, byte strt, byte len, char *nm, dbg_type base ) </H2>
<BR>add a bit field to a structure
<H2 ID="void_DBAddLocFieldL_dbg_struct_st__dbg_loc_loc__uint_attr__byte_strt__byte_len__char_Tnm__dbg_type_base_R"> void DBAddLocField( dbg_struct st, dbg_loc loc, uint attr, byte strt, byte len, char *nm, dbg_type base ) </H2>
<BR>Add a field or bit field to a structure with a generalized location expression 'loc'.&nbsp; The location expression should
assume the the address of the base of the structure has already been pushed onto the debugger's evaluation stack.&nbsp; The
'attr' parameter contains a zero or more of the following attributes or'd together:
<DL>
<DT><B><I>Attribute</I></B>
<DD><B><I>Definition</I></B>
<DT>FIELD_ATTR_INTERNAL
<DD>the field is internally generated by the compiler and would not be normally visible to the user.
<DT>FIELD_ATTR_PUBLIC
<DD>the field has the C++ 'public' attribute.
<DT>FIELD_ATTR_PROTECTED
<DD>the field has the C++ 'protected' attribute.
<DT>FIELD_ATTR_PRIVATE
<DD>the field has the C++ 'private' attribute.
</DL>
<BR>If the field being described is _not_ a bit field, the 'len' parameter should be set to zero.
<H2 ID="void_DBAddInheritanceL_dbg_struct_st__dbg_type_inherit__dbg_loc_adjust_R"> void DBAddInheritance( dbg_struct st, dbg_type inherit, dbg_loc adjust ) </H2>
<BR>Add the fields of an inherited structure to the current structure being defined.
<DL>
<DT><B><I>Parameter</I></B>
<DD><B><I>Definition</I></B>
<DT>st
<DD>the dbg_struct handle for the structure currently being defined.
<DT>inherit
<DD>the dbg_type of a previously defined structure which is being inherited.
<DT>adjust
<DD>a location expression which evaluates to a value which is the amount to adjust the field offsets by in the inherited structure
to access them in the current structure.&nbsp; The base address of the symbol associated with the structure type is pushed
onto the location expression stack before the expression is evaluated.
</DL>
<H2 ID="dbg_type_DBEndStructL_dbg_struct_st_R"> dbg_type DBEndStruct( dbg_struct st ) </H2>
<BR>end a structure definition
<H2 ID="dbg_enum_DBBegEnumL_cg_type_tipe_R"> dbg_enum DBBegEnum( cg_type tipe ) </H2>
<BR>begin defining an enumerated type
<H2 ID="void_DBAddConstL_dbg_enum_en__const_char_Tnm__signed_32_val_R"> void DBAddConst( dbg_enum en, const char *nm, signed_32 val ) </H2>
<BR>add a symbolic constant to an enumerated type
<H2 ID="void_DBAddConst64L_dbg_enum_en__const_char_Tnm__signed_64_val_R"> void DBAddConst64( dbg_enum en, const char *nm, signed_64 val ) </H2>
<BR>add a symbolic 64-bit integer constant to an enumerated type
<H2 ID="dbg_type_DBEndEnumL_dbg_enum_en_R"> dbg_type DBEndEnum( dbg_enum en ) </H2>
<BR>finish declaring an enumerated type
<H2 ID="dbg_proc_DBBegProcL_cg_type_call_type__dbg_type_ret_R"> dbg_proc DBBegProc( cg_type call_type, dbg_type ret ) </H2>
<BR>begin the a current procedure
<H2 ID="void_DBAddParmL_dbg_proc_pr__dbg_type_tipe_R"> void DBAddParm( dbg_proc pr, dbg_type tipe ) </H2>
<BR>declare a parameter to the procedure
<H2 ID="dbg_type_DBEndProcL_proc_list_Tpr_R"> dbg_type DBEndProc( proc_list *pr ) </H2>
<BR>end the current procedure
<H2 ID="dbg_type_DBFtnTypeL_char_Tname__dbg_ftn_type_tipe_R"> dbg_type DBFtnType( char *name, dbg_ftn_type tipe ) </H2>
<BR>declare a fortran COMPLEX type
<H2 ID="dbg_type_DBCharBlockL_unsigned_32_len_R"> dbg_type DBCharBlock( unsigned_32 len ) </H2>
<BR>declare a type to be a block of length<B> len</B> characters
<H2 ID="dbg_type_DBIndCharBlockL_back_handle_len__cg_type_len_type__int_off_R"> dbg_type DBIndCharBlock( back_handle len, cg_type len_type, int off ) </H2>
<BR>declare a type to be a block of characters.&nbsp; The length is found at run-time at back_handle<B> len</B> + offset<B>
off</B>.&nbsp; The integral type of the back_handle location is<B> len_type</B>
<H2 ID="dbg_type_DBLocCharBlockL_dbg_loc_loc__cg_type_len_type_R"> dbg_type DBLocCharBlock( dbg_loc loc, cg_type len_type ) </H2>
<BR>declare a type to be a block of characters.&nbsp; The length is found at run-time at the address specified by the location
expression<B> loc</B>.&nbsp; The integral type of the location is<B> len_type</B>
<H2 ID="dbg_type_DBFtnArrayL_back_handle_dims__cg_type_lo_bound_tipe__cg_type_num_elts_tipe__int_off__dbg_type_base_R"> dbg_type DBFtnArray( back_handle dims, cg_type lo_bound_tipe, cg_type num_elts_tipe, int off, dbg_type base ) </H2>
<BR>define a FORTRAN array dimension slice.<B>&nbsp; dims</B> is a back handle + offset<B> off</B> which will point to a structure
at run-time.&nbsp; The structure contains the array low bound (type<B> lo_bound_tipe</B>) followed by the number of elements
(type<B> num_elts_tipe</B>).<B>&nbsp; base</B> is the element type of the array.
<H2 ID="dbg_type_DBDereferenceL_cg_type_ptr_type__dbg_type_base_R"> dbg_type DBDereference( cg_type ptr_type, dbg_type base ) </H2>
<BR>declare a type to need an implicit de-reference to retrieve the value (for FORTRAN parameters)
<BR><BR><B>NOTE:</B>&nbsp; This routine has been superceded by the use of location expressions.
<H2 ID="dbg_loc_DBLocInitL_void_R"> dbg_loc DBLocInit( void ) </H2>
<BR>create an initial empty location expression
<H2 ID="dbg_loc_DBLocSymL_dbg_loc_loc__cg_sym_handle_sym_R"> dbg_loc DBLocSym( dbg_loc loc, cg_sym_handle sym ) </H2>
<BR>push the address of 'sym' on to the expression stack
<H2 ID="dbg_loc_DBLocTempL_dbg_loc_loc__temp_handle_tmp_R"> dbg_loc DBLocTemp( dbg_loc loc, temp_handle tmp ) </H2>
<BR>push the address of 'tmp' on to the expression stack
<H2 ID="dbg_loc_DBLocConstL_dbg_loc_loc__unsigned_32_val_R"> dbg_loc DBLocConst( dbg_loc loc, unsigned_32 val ) </H2>
<BR>push the constant 'val' on to the expression stack
<H2 ID="dbg_loc_DBLocOpL_dbg_loc_loc__dbg_loc_op_op__unsigned_other_R"> dbg_loc DBLocOp( dbg_loc loc, dbg_loc_op op, unsigned other ) </H2>
<BR>perform the following list of operations on the expression stack
<DL>
<DT><B><I>Operation</I></B>
<DD><B><I>Definition</I></B>
<DT>DB_OP_POINTS
<DD>take the top of the expression stack and use it as the address in an indirection operation.&nbsp; The result type of the operation
is given by the 'other' parameter which must be a cg_type which resolves to either an unsigned_16, unsigned_32, a 16-bit far
pointer, or a 32-bit far pointer.
<DT>DB_OP_ZEX
<DD>zero extend the top of the stack.&nbsp; The 'other' parameter is a cg_type which is either 1 byte in size or 2 bytes in size.
&nbsp;That size determines how much of the original top of stack value to leave untouched.
<DT>DB_OP_XCHG
<DD>exchange the top of stack value with the stack entry indexed by 'other'.
<DT>DB_OP_MK_FP
<DD>take the top two entries on the stack.&nbsp; Make the second entry the segment value and the first entry the offset value
of an address.
<DT>DB_OP_ADD
<DD>add the top two stack entries together.
<DT>DB_OP_DUP
<DD>duplicate the top stack entry.
<DT>DB_OP_POP
<DD>pop off (throw away) the top stack entry.
</DL>
<H2 ID="void_DBLocFiniL_dbg_loc_loc_R"> void DBLocFini( dbg_loc loc ) </H2>
<BR>the given location expression will not be used anymore.
<H2 ID="unsigned_DBSrcFileL_char_Tfname_R"> unsigned DBSrcFile( char *fname ) </H2>
<BR>add the file name into the list of source files for positon info, return handle to this name
<BR><B>NOTE:</B>&nbsp; Handle 0 is reserved for base source file name and is added by BE automaticaly during initialization.
<H2 ID="void_DBSrcCueL_unsigned_fno__unsigned_line__unsigned_col_R"> void DBSrcCue( unsigned fno, unsigned line, unsigned col ) </H2>
<BR>add source position info for the appropriate source file
<H1 ID="Registers"> Registers </H1>
<BR>The hw_reg_set type is an abstract data type capable of representing any combination of machine registers.&nbsp; It must
be manipulated using the following macros.&nbsp; A parameter<B> c</B>,<B> c1</B>,<B> c2</B>, etc.&nbsp; indicate a register
constant such as HW_EAX must be used.&nbsp; Anything else must be a variable of type<B> hw_reg_set</B>.
<BR><BR>The following are used for static initialization.
<UL>
<LI>HW_D_1( c1 )
<LI>HW_NotD_1( c1 )
<LI>HW_D_2( c1, c2 )
<LI>HW_NotD_2( c1, c2 )
<LI>HW_D_3( c1, c2, c3 )
<LI>HW_NotD_3( c1, c2, c3 )
<LI>HW_D_4( c1, c2, c3, c4 )
<LI>HW_NotD_4( c1, c2, c3, c4 )
<LI>HW_D_5( c1, c2, c3, c4, c5 )
<LI>HW_NotD_5( c1, c2, c3, c4, c5 )
<LI>HW_D( c1 )
<LI>HW_NotD( c1 )
</UL>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; hw_reg_set regs[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* the EAX register */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HW_D( HW_EAX ),</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* all registers except EDX and EBX */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HW_NotD_2( HW_EDX, HW_EBX )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR>The following are to build registers dynamically.
<DL>
<DT><B><I>Macro</I></B>
<DD><B><I>Usage</I></B>
<DT>HW_CEqual( a, c )
<DD>Is<B> a</B> equal to<B> c</B>
<DT>HW_COvlap( a, c )
<DD>Does<B> a</B> overlap with<B> c</B>
<DT>HW_CSubset( a, c )
<DD>Is<B> a</B> subset of<B> c</B>
<DT>HW_CAsgn( dst, c )
<DD>Assign<B> c</B> to<B> dst</B>
<DT>HW_CTurnOn( dst, c )
<DD>Turn on registers<B> c</B> in<B> dst</B>.
<DT>HW_CTurnOff( dst, c )
<DD>Turn off registers<B> c</B> in<B> dst</B>.
<DT>HW_COnlyOn( a, c )
<DD>Turn off all registers except<B> c</B> in<B> dst</B>.
<DT>HW_Equal( a, b )
<DD>Is<B> a</B> equal to<B> b</B>
<DT>HW_Ovlap( a, b )
<DD>Does<B> a</B> overlap with<B> b</B>
<DT>HW_Subset( a, b )
<DD>Is<B> a</B> subset of<B> b</B>
<DT>HW_Asgn( dst, b )
<DD>Assign<B> b</B> to<B> dst</B>
<DT>HW_TurnOn( dst, b )
<DD>Turn on registers<B> b</B> in<B> dst</B>.
<DT>HW_TurnOff( dst, b )
<DD>Turn off registers<B> b</B> in<B> dst</B>.
<DT>HW_OnlyOn( dst, b )
<DD>Turn off all registers except<B> b</B> in<B> dst</B>.
</DL>
<BR>The following example selects the low order 16 bits of any register.&nbsp; that has a low part.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; hw_reg_set low16( hw_reg_set reg )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hw_reg_set&nbsp; low;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HW_CAsgn( low, HW_EMPTY );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HW_CTurnOn( low, HW_AX );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HW_CTurnOn( low, HW_BX );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HW_CTurnOn( low, HW_CX );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HW_CTurnOn( low, HW_DX );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( HW_Ovlap( reg, low ) ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HW_OnlyOn( reg, low );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The following register constants are defined for all targets.
<DL>
<DT>HW_EMPTY
<DD>The null register set.
<DT>HW_UNUSED
<DD>The set of unused register entries.
<DT>HW_FULL
<DD>All possible registers.
</DL>
<BR>The following example yields the set of all valid machine registers.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; hw_reg_set reg;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; HW_CAsgn( reg, HW_FULL );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; HW_CTurnOff( reg, HW_UNUSED );</TT>
<H1 ID="Miscellaneous"> Miscellaneous </H1>
<BR>I apologize for my lack of consistency in this document.&nbsp; I use the terms function, routine, procedure interchangeably,
as well as index, subscript - select, switch - parameter, argument - etc.&nbsp; I come from a multiple language background
and will always be hopelessly confused.
<BR><BR>The NEXT_IMPORT/NEXT_IMPORT_S/NEXT_LIBRARY are used as follows.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; handle = NULL;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; for( ;; ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handle = FEAuxInfo( handle, NEXT_IMPORT );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( handle == NULL ) break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do_something( FEAuxInfo( handle, IMPORT_NAME ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The FREE_SEGMENT request is used as follows.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; segment = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; for( ;; ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; segment = FEAuxInfo( segment, FREE_SEGMENT );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( segment == NULL ) break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; segment_size = *(short *)MK_FP( segment, 0 ) * 16;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this_is_my_memory_now( MK_FP( segment, 0 ), segment_size );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The main line in Pascal is defined to be lexical level 1.&nbsp; Add 1 for each nested subroutine level.&nbsp; C style
routines are defined to be lexical level 0.
<BR><BR>The following types are defined by the code generator header files:&nbsp; 
<DL>
<DT><B><I>Utility type</I></B>
<DD><B><I>Definition</I></B>
<DT>bool
<DD>(unsigned char) 0 = false, non-0 = true.
<DT>byte
<DD>(unsigned char)
<DT>int_8
<DD>(signed char)
<DT>int_16
<DD>(signed short)
<DT>int_32
<DD>(signed long)
<DT>signed_8
<DD>(signed char)
<DT>signed_16
<DD>(signed short)
<DT>signed_32
<DD>(signed long)
<DT>uint
<DD>(unsigned)
<DT>uint_8
<DD>(unsigned char)
<DT>uint_16
<DD>(unsigned short)
<DT>uint_32
<DD>(unsigned long)
<DT>unsigned_8
<DD>(unsigned char)
<DT>unsigned_16
<DD>(unsigned short)
<DT>unsigned_32
<DD>(unsigned long)
<DT>real
<DD>(float)
<DT>reallong
<DD>(double)
<DT>pointer
<DD>(void*)
</DL>
<DL>
<DT><B><I>Type</I></B>
<DD><B><I>Definition</I></B>
<DT>aux_class
<DD>(enum) Passed as 2nd parameter to FEAuxInfo.
<DT>aux_handle
<DD>(void*) A handle used as 1st parameter to FEAuxInfo.
<DT>back_handle
<DD>(void*) A handle for a back end symbol table entry.
<DT>byte_seq
<DD>(struct) Passed to back end in response to CALL_BYTES FEAuxInfo request.
<DT>call_class
<DD>(unsigned long) A set of combinable bits indicating the call attributes for a routine.
<DT>call_handle
<DD>(void*) A handle to be used in CGInitCall, CGAddParm and CGCall.
<DT>cg_init_info
<DD>(union) The return value of BEInit.
<DT>cg_name
<DD>(void*) A handle for a back end expression tree node.
<DT>cg_op
<DD>(enum) An operator to be used in building expressions.
<DT>cg_switches
<DD>(unsigned_32) A set of combinable bits indicating the code generator options.
<DT>cg_sym_handle
<DD>(uint) A handle for a front end symbol table entry.
<DT>cg_type
<DD>(unsigned short) A code generator type.
<DT>fe_attr
<DD>(enum) A set of combinable bits indicating symbol attributes.
<DT>hw_reg_set
<DD>(struct hw_reg_set) A structure representing a hardware register.
<DT>label_handle
<DD>(void*) A handle for a code generator code label.
<DT>linkage_regs
<DD>(struct) For 370 linkage conventions.
<DT>more_cg_types
<DD>(enum)
<DT>msg_class
<DD>(enum) The 1st parameter to FEMessage.
<DT>proc_revision
<DD>(enum) The 3rd parameter to BEInit.
<DT>seg_attr
<DD>(enum) A set of combinable bits indicate the attributes of a segment.
<DT>segment_id
<DD>(int) A segment identifier.
<DT>sel_handle
<DD>(void*) A handle to be used in the CGSel calls.
<DT>temp_handle
<DD>(void*) A handle for a code generator temporary.
</DL>
<DL>
<DT><B><I>Misc Type</I></B>
<DD><B><I>Definition</I></B>
<DT>HWT
<DD>hw_reg_part
<DT>hw_reg_part
<DD>(unsigned)
<DT>dbg_enum
<DD>(void*)
<DT>dbg_ftn_type
<DD>(enum)
<DT>dbg_name
<DD>(void*)
<DT>dbg_proc
<DD>(void*)
<DT>dbg_struct
<DD>(void*)
<DT>dbg_type
<DD>(unsigned short)
<DT>predefined_cg_types
<DD>(enum)
</DL>
<H1 ID="PreMdefined_macros"> Pre-defined macros </H1>
<BR>The following macros are defined by the code generator include files.
<UL>
<LI>HW_D
<LI>HW_D_1
<LI>HW_D_2
<LI>HW_D_3
<LI>HW_D_4
<LI>HW_D_5
<LI>BIG_CODE
<LI>BIG_DATA
<LI>CALLER_POPS
<LI>CHEAP_POINTER
<LI>CHEAP_WINDOWS
<LI>CONST_IN_CODE
<LI>CPU_MASK
<LI>C_FRONT_END
<LI>DBG_FWD_TYPE
<LI>DBG_LOCALS
<LI>DBG_NIL_TYPE
<LI>DBG_NUMBERS
<LI>DBG_TYPES
<LI>DLL_EXPORT
<LI>DO_FLOATING_FIXUPS
<LI>DO_SYM_FIXUPS
<LI>EMIT_FUNCTION_NAME
<LI>EPILOG_HOOKS
<LI>EZ_OMF
<LI>E_8087
<LI>FALSE
<LI>FAR
<LI>FAT_WINDOWS_PROLOG
<LI>FIX_SYM_OFFSET
<LI>FIX_SYM_RELOFF
<LI>FIX_SYM_SEGMENT
<LI>FLAT_MODEL
<LI>FLOATING_DS
<LI>FLOATING_ES
<LI>FLOATING_FIXUP_BYTE
<LI>FLOATING_FS
<LI>FLOATING_GS
<LI>FLOATING_SS
<LI>FORTRAN_ALIASING
<LI>FORTRAN_FRONT_END
<LI>FPU_MASK
<LI>FRONT_END_MASK
<LI>FUNCS_IN_OWN_SEGMENTS
<LI>GENERATE_STACK_FRAME
<LI>GET_CPU
<LI>GET_FPU
<LI>GET_WTK
<LI>GROW_STACK
<LI>HWREG_INCLUDED
<LI>HW_0
<LI>HW_1
<LI>HW_2
<LI>HW_3
<LI>HW_64
<LI>HW_Asgn
<LI>HW_CAsgn
<LI>HW_CEqual
<LI>HW_COMMA
<LI>HW_COnlyOn
<LI>HW_COvlap
<LI>HW_CSubset
<LI>HW_CTurnOff
<LI>HW_CTurnOn
<LI>HW_DEFINE_COMPOUND
<LI>HW_DEFINE_GLOBAL_CONST
<LI>HW_DEFINE_SIMPLE
<LI>HW_Equal
<LI>HW_ITER
<LI>HW_NotD
<LI>HW_NotD_1
<LI>HW_NotD_2
<LI>HW_NotD_3
<LI>HW_NotD_4
<LI>HW_NotD_5
<LI>HW_OnlyOn
<LI>HW_Op1
<LI>HW_Op2
<LI>HW_Op3
<LI>HW_Op4
<LI>HW_Op5
<LI>HW_Ovlap
<LI>HW_Subset
<LI>HW_TurnOff
<LI>HW_TurnOn
<LI>II_REVISION
<LI>INDEXED_GLOBALS
<LI>INS_SCHEDULING
<LI>INTERNAL_DBG_OUTPUT
<LI>INTERRUPT
<LI>I_MATH_INLINE
<LI>LAST_AUX_ATTRIBUTE
<LI>LAST_CGSWITCH
<LI>LAST_TARG_AUX_ATTRIBUTE
<LI>LAST_TARG_CGSWITCH
<LI>LOAD_DS_ON_CALL
<LI>LOAD_DS_ON_ENTRY
<LI>LOOP_OPTIMIZATION
<LI>MAKE_CALL_INLINE
<LI>MAX_POSSIBLE_REG
<LI>MIN_OP
<LI>MODIFY_EXACT
<LI>NEED_STACK_FRAME
<LI>NO_8087_RETURNS
<LI>NO_CALL_RET_TRANSFORM
<LI>NO_FLOAT_REG_RETURNS
<LI>NO_MEMORY_CHANGED
<LI>NO_MEMORY_READ
<LI>NO_OPTIMIZATION
<LI>NO_STRUCT_REG_RETURNS
<LI>NULL
<LI>NULLCHAR
<LI>O_FIRST_COND
<LI>O_FIRST_FLOW
<LI>O_LAST_COND
<LI>O_LAST_FLOW
<LI>PARMS_BY_ADDRESS
<LI>PROLOG_HOOKS
<LI>RELAX_ALIAS
<LI>REVERSE_PARMS
<LI>ROUTINE_RETURN
<LI>SEG_EXTRN_FAR
<LI>SET_CPU
<LI>SET_FPU
<LI>SET_WTK
<LI>SPECIAL_RETURN
<LI>SPECIAL_STRUCT_RETURN
<LI>STANDARD_INCLUDED
<LI>SUICIDAL
<LI>SYM_FIXUP_BYTE
<LI>THUNK_PROLOG
<LI>TRUE
<LI>TY_HUGE_CODE_PTR
<LI>USE_32
<LI>WINDOWS
<LI>WTK_MASK
<LI>_AL
<LI>_AX
<LI>_BL
<LI>_BP
<LI>_BX
<LI>_CG_H_INCLUDED
<LI>_CL
<LI>_CMS
<LI>_CX
<LI>_DI
<LI>_DL
<LI>_DX
<LI>_HOST_INTEGER
<LI>_OS
<LI>_SI
<LI>_TARG_AUX_SHIFT
<LI>_TARG_CGSWITCH_SHIFT
<LI>far
<LI>huge
<LI>interrupt
<LI>near
<LI>offsetof
</UL>
<H1 ID="Register_constants"> Register constants </H1>
<BR>The following register constants are defined for x86 targets.
<UL>
<LI>HW_AH
<LI>HW_AL
<LI>HW_BH
<LI>HW_BL
<LI>HW_CH
<LI>HW_CL
<LI>HW_DH
<LI>HW_DL
<LI>HW_SI
<LI>HW_DI
<LI>HW_BP
<LI>HW_SP
<LI>HW_DS
<LI>HW_ES
<LI>HW_CS
<LI>HW_SS
<LI>HW_ST0
<LI>HW_ST1
<LI>HW_ST2
<LI>HW_ST3
<LI>HW_ST4
<LI>HW_ST5
<LI>HW_ST6
<LI>HW_ST7
<LI>HW_FS
<LI>HW_GS
<LI>HW_AX
<LI>HW_BX
<LI>HW_CX
<LI>HW_DX
<LI>HW_EAX
<LI>HW_EBX
<LI>HW_ECX
<LI>HW_EDX
<LI>HW_ESI
<LI>HW_EDI
<LI>HW_ESP
<LI>HW_EBP
</UL>
<BR>The following registers are defined for the Alpha AXP target.
<UL>
<LI>HW_R0-HW_R31
<LI>HW_D0-HW_D31
<LI>HW_W0-HW_W31
<LI>HW_B0-HW_B31
<LI>HW_F0-HW_F31
</UL>
<BR>The following registers are defined for the PowerPC target.
<UL>
<LI>HW_R0-HW_R31
<LI>HW_Q3-HW_Q29
<LI>HW_D0-HW_D31
<LI>HW_W0-HW_W31
<LI>HW_B0-HW_B31
<LI>HW_F0-HW_F31
</UL>
<BR>The following registers are defined for the MIPS32 target.
<UL>
<LI>HW_R0-HW_R31
<LI>HW_Q2-HW_Q24
<LI>HW_D0-HW_D31
<LI>HW_W0-HW_W31
<LI>HW_B0-HW_B31
<LI>HW_F0-HW_F31
<LI>HW_FD0-HW_FD30
</UL>
<H1 ID="Debugging_Open_Watcom_Code_Generator"> Debugging Open Watcom Code Generator </H1>
<BR>If you want to use vc.dbg command, make sure you have a tmp directory in root of used filesystem (see bld/cg/dumpio.c
for details).
<BR><BR>Note:&nbsp; make a s:\tmp to facilitate debugging in s:\brad :) Yeah, it's a cheap and sleazy hack...
<BR><BR>If you need to dump something and don't know the routine to call, try<B> &quot;e/s Dump&quot;</B> and see what pops
up...
<H2 ID="Instructions"> Instructions </H2>
<BR>You can get a dump of instructions for current function via<B><I> DumpRange</I></B> anytime between<B><I> FixEdges</I></B>
and start of<B><I> GenObject</I></B>.
<BR><BR>You can dump an individual instruction via<B><I> DumpIns</I></B>
<BR><BR>If you need live info for a basic block, find address and call<B><I> DumpABlk( block )</I></B>.
<H2 ID="Symbols"> Symbols </H2>
<BR>If you need to see a list of symbols, use<B><I> DumpSymTab</I></B>.&nbsp; To look at one symbol, use<B><I> DumpSym</I></B>.
<H2 ID="Tree_Problems"> Tree Problems </H2>
<BR>Find the line number of a piece of source near the problem.&nbsp; Do a<B> &quot;bif { edx == LINENUMBER }</B><B><I> DBSrcCue</I></B><B>&quot;</B>
to stop near that Go to<B><I> CGDone</I></B> in order to see what resulting tree is (<B><I>DumpTree</I></B>) If there is a
problem with tree, but not with API calls, do to<B><I> DBSrcCue</I></B> as above and then break on next appropriate CG API
call.
<H2 ID="Optimization_Problems_LLoopopts_at_allR"> Optimization Problems (Loopopts at all) </H2>
<BR>Find the ordinal of the problem function in the file (ie 4th function) Do a<B> &quot;bcnt 4</B><B><I> FixEdges</I></B><B>&quot;</B>
in order to stop on 4th call (for example) to<B><I> FixEdges</I></B> Dump instructions (using<B><I> DumpRange</I></B>) and
see if problem is in trees If not, go to<B><I> RegAlloc</I></B> and see if problem shows up yet If so, binary search between<B><I>
FixEdges</I></B> and<B><I> RegAlloc</I></B> to find optimization at fault.
<H2 ID="Instruction_Select_Problems"> Instruction Select Problems </H2>
<BR>Go to<B><I> RegAlloc</I></B> for appropriate function (called once per function when not -od) Find address of instruction
which gets translated or handled improperly.&nbsp; (Look in results of<B><I> DumpRange</I></B> for this address).&nbsp; Do
a<B> &quot;bif { eax == address }</B><B><I> ExpandIns</I></B><B>&quot;</B> to look at what we do to this instruction (trace
through).
<H2 ID="Register_Allocation_Problem"> Register Allocation Problem </H2>
<H2 ID="Instruction_Encoding_Problem"> Instruction Encoding Problem </H2>
<BR>Go to<B><I> RegAlloc</I></B> invocation for routine in question.&nbsp; Go to<B><I> GenObject</I></B> and call<B><I> DumpRange</I></B>.
&nbsp;Find address of instruction that gets encoded incorrectly, and do a<B> &quot;bif { eax == address }</B><B><I> GenObjCode</I></B><B>&quot;</B>
Trace into<B><I> GenObjCode</I></B> at appropriate time.
</BODY>
