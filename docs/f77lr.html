<HEAD>
<TITLE> Open Watcom 2.0 FORTRAN 77 Language Reference </TITLE>
</HEAD>
<BODY>
<H1 ID="Index_of_Topics"> Index of Topics </H1>
<DL>
<DT>- $ -
<DD><A HREF="#__or_B_Editing_LExtensionR">$ or \ Editing (Extension)</A>
<DT>- A -
<DD><A HREF="#Absolute_Value">Absolute Value</A>
<BR><A HREF="#Actual_Arguments">Actual Arguments</A>
<BR><A HREF="#Actual_Arguments_for_a_Subroutine">Actual Arguments for a Subroutine</A>
<BR><A HREF="#Actual_Arguments_for_an_External_Function">Actual Arguments for an External Function</A>
<BR><A HREF="#Actual_Array_Declarator">Actual Array Declarator</A>
<BR><A HREF="#Adjustable_Array_Declarator">Adjustable Array Declarator</A>
<BR><A HREF="#ADMIT_Statement">ADMIT Statement</A>
<BR><A HREF="#Allocatable_Array_Declarator">Allocatable Array Declarator</A>
<BR><A HREF="#ALLOCATE_Statement">ALLOCATE Statement</A>
<BR><A HREF="#Allocated_Array">Allocated Array</A>
<BR><A HREF="#Apostrophe_Editing">Apostrophe Editing</A>
<BR><A HREF="#Arccosine">Arccosine</A>
<BR><A HREF="#Arcsine">Arcsine</A>
<BR><A HREF="#Arctangent">Arctangent</A>
<BR><A HREF="#Arithmetic_Assignment">Arithmetic Assignment</A>
<BR><A HREF="#Arithmetic_Constant_Expression">Arithmetic Constant Expression</A>
<BR><A HREF="#Arithmetic_Expressions">Arithmetic Expressions</A>
<BR><A HREF="#Arithmetic_IF_Statement">Arithmetic IF Statement</A>
<BR><A HREF="#Arithmetic_Operators">Arithmetic Operators</A>
<BR><A HREF="#Arithmetic_Relational_Expressions">Arithmetic Relational Expressions</A>
<BR><A HREF="#Array_Elements">Array Elements</A>
<BR><A HREF="#Arrays">Arrays</A>
<BR><A HREF="#Arrays_as_Dummy_Arguments">Arrays as Dummy Arguments</A>
<BR><A HREF="#Arrays_of_Records">Arrays of Records</A>
<BR><A HREF="#Assigned_GO_TO_Statement">Assigned GO TO Statement</A>
<BR><A HREF="#Assignment_Statements">Assignment Statements</A>
<BR><A HREF="#Association_of_Actual_and_Dummy_Arguments">Association of Actual and Dummy Arguments</A>
<BR><A HREF="#AssumedMsize_Array_Declarator">Assumed-size Array Declarator</A>
<BR><A HREF="#Asterisks_as_Dummy_Arguments">Asterisks as Dummy Arguments</A>
<BR><A HREF="#AT_END">AT END</A>
<BR><A HREF="#AT_END_Statement">AT END Statement</A>
<DT>- B -
<DD><A HREF="#BACKSPACE_Statement">BACKSPACE Statement</A>
<BR><A HREF="#Binary_Pattern_Processing_Functions__Arithmetic_Shift">Binary Pattern Processing Functions:&nbsp; Arithmetic Shift</A>
<BR><A HREF="#Binary_Pattern_Processing_Functions__Arithmetic_Shifts">Binary Pattern Processing Functions:&nbsp; Arithmetic Shifts</A>
<BR><A HREF="#Binary_Pattern_Processing_Functions__Bit_Testing">Binary Pattern Processing Functions:&nbsp; Bit Testing</A>
<BR><A HREF="#Binary_Pattern_Processing_Functions__Boolean_AND">Binary Pattern Processing Functions:&nbsp; Boolean AND</A>
<BR><A HREF="#Binary_Pattern_Processing_Functions__Boolean_Complement">Binary Pattern Processing Functions:&nbsp; Boolean Complement</A>
<BR><A HREF="#Binary_Pattern_Processing_Functions__Boolean_Exclusive_OR">Binary Pattern Processing Functions:&nbsp; Boolean Exclusive OR</A>
<BR><A HREF="#Binary_Pattern_Processing_Functions__Boolean_Inclusive_OR">Binary Pattern Processing Functions:&nbsp; Boolean Inclusive OR</A>
<BR><A HREF="#Binary_Pattern_Processing_Functions__Change_Bit">Binary Pattern Processing Functions:&nbsp; Change Bit</A>
<BR><A HREF="#Binary_Pattern_Processing_Functions__Circular_Shift">Binary Pattern Processing Functions:&nbsp; Circular Shift</A>
<BR><A HREF="#Binary_Pattern_Processing_Functions__Clear_Bit">Binary Pattern Processing Functions:&nbsp; Clear Bit</A>
<BR><A HREF="#Binary_Pattern_Processing_Functions__Logical_Shift">Binary Pattern Processing Functions:&nbsp; Logical Shift</A>
<BR><A HREF="#Binary_Pattern_Processing_Functions__Set_Bit">Binary Pattern Processing Functions:&nbsp; Set Bit</A>
<BR><A HREF="#BLOCK_DATA_Statement">BLOCK DATA Statement</A>
<BR><A HREF="#Block_IF_Statement">Block IF Statement</A>
<BR><A HREF="#Block_WHILE_Statement">Block WHILE Statement</A>
<BR><A HREF="#BN_and_BZ_Editing">BN and BZ Editing</A>
<DT>- C -
<DD><A HREF="#CALL_Statement">CALL Statement</A>
<BR><A HREF="#CASE_Statement">CASE Statement</A>
<BR><A HREF="#Character_Assignment">Character Assignment</A>
<BR><A HREF="#Character_Constant">Character Constant</A>
<BR><A HREF="#Character_Constant_Expressions">Character Constant Expressions</A>
<BR><A HREF="#Character_Expressions">Character Expressions</A>
<BR><A HREF="#Character_Operators">Character Operators</A>
<BR><A HREF="#Character_Relational_Expressions">Character Relational Expressions</A>
<BR><A HREF="#Character_Set">Character Set</A>
<BR><A HREF="#CHARACTER_Statement">CHARACTER Statement</A>
<BR><A HREF="#Character_Substrings">Character Substrings</A>
<BR><A HREF="#Choosing_Largest_Value">Choosing Largest Value</A>
<BR><A HREF="#Choosing_Smallest_Value">Choosing Smallest Value</A>
<BR><A HREF="#Classifying_Array_Declarators_by_Array_Name">Classifying Array Declarators by Array Name</A>
<BR><A HREF="#Classifying_Array_Declarators_by_Dimension_Declarator">Classifying Array Declarators by Dimension Declarator</A>
<BR><A HREF="#Classifying_Statements">Classifying Statements</A>
<BR><A HREF="#CLOSE_Statement">CLOSE Statement</A>
<BR><A HREF="#Colon_Editing">Colon Editing</A>
<BR><A HREF="#Comment_Line">Comment Line</A>
<BR><A HREF="#Common_Logarithm">Common Logarithm</A>
<BR><A HREF="#COMMON_Statement">COMMON Statement</A>
<BR><A HREF="#Complement_of_Error_Function">Complement of Error Function</A>
<BR><A HREF="#Complex_Constant">Complex Constant</A>
<BR><A HREF="#Complex_Editing">Complex Editing</A>
<BR><A HREF="#COMPLEX_Statement">COMPLEX Statement</A>
<BR><A HREF="#Computed_GO_TO_Statement">Computed GO TO Statement</A>
<BR><A HREF="#Conjugate_of_a_Complex_Number">Conjugate of a Complex Number</A>
<BR><A HREF="#Constant_Array_Declarator">Constant Array Declarator</A>
<BR><A HREF="#Constant_Expressions">Constant Expressions</A>
<BR><A HREF="#Constants">Constants</A>
<BR><A HREF="#Continuation_Line">Continuation Line</A>
<BR><A HREF="#CONTINUE_Statement">CONTINUE Statement</A>
<BR><A HREF="#Cosine">Cosine</A>
<BR><A HREF="#Cotangent">Cotangent</A>
<BR><A HREF="#CYCLE">CYCLE</A>
<BR><A HREF="#CYCLE_Statement">CYCLE Statement</A>
<DT>- D -
<DD><A HREF="#DATA_Statement">DATA Statement</A>
<BR><A HREF="#Data_Type_of_a_Name">Data Type of a Name</A>
<BR><A HREF="#Data_Type_of_Arithmetic_Expressions">Data Type of Arithmetic Expressions</A>
<BR><A HREF="#Data_Types">Data Types</A>
<BR><A HREF="#DEALLOCATE_Statement">DEALLOCATE Statement</A>
<BR><A HREF="#Debug_Line_LExtensionR">Debug Line (Extension)</A>
<BR><A HREF="#Definition_Status_of_Specifiers_M_Inquire_by_File">Definition Status of Specifiers - Inquire by File</A>
<BR><A HREF="#Definition_Status_of_Specifiers_M_Inquire_by_Unit">Definition Status of Specifiers - Inquire by Unit</A>
<BR><A HREF="#Description_of_DO_Statement">Description of DO Statement</A>
<BR><A HREF="#Description_of_IMPLICIT_Statement">Description of IMPLICIT Statement</A>
<BR><A HREF="#Description_of_PRINT_Statement">Description of PRINT Statement</A>
<BR><A HREF="#Description_of_READ_Statement">Description of READ Statement</A>
<BR><A HREF="#DIMENSION_Statement">DIMENSION Statement</A>
<BR><A HREF="#DO_M_END_DO">DO - END DO</A>
<BR><A HREF="#DO_Statement">DO Statement</A>
<BR><A HREF="#DO_WHILE_M_END_DO">DO WHILE - END DO</A>
<BR><A HREF="#DO_WHILE_Statement">DO WHILE Statement</A>
<BR><A HREF="#DOUBLE_COMPLEX_Statement">DOUBLE COMPLEX Statement</A>
<BR><A HREF="#DOUBLE_COMPLEX_Statement__Data_Initialization">DOUBLE COMPLEX Statement:&nbsp; Data Initialization</A>
<BR><A HREF="#Double_Precision_Complex_Constant_LExtensionR">Double Precision Complex Constant (Extension)</A>
<BR><A HREF="#Double_Precision_Constant">Double Precision Constant</A>
<BR><A HREF="#Double_Precision_Product">Double Precision Product</A>
<BR><A HREF="#DOUBLE_PRECISION_Statement">DOUBLE PRECISION Statement</A>
<BR><A HREF="#Dummy_Arguments">Dummy Arguments</A>
<BR><A HREF="#Dummy_Array_Declarator">Dummy Array Declarator</A>
<DT>- E -
<DD><A HREF="#E_and_D_Editing">E and D Editing</A>
<BR><A HREF="#A_Edit_Descriptor">A Edit Descriptor</A>
<BR><A HREF="#Editing">Editing</A>
<BR><A HREF="#ELSE_IF">ELSE IF</A>
<BR><A HREF="#ELSE_IF_Statement">ELSE IF Statement</A>
<BR><A HREF="#ELSE_Statement">ELSE Statement</A>
<BR><A HREF="#END_AT_END_Statement">END AT END Statement</A>
<BR><A HREF="#END_BLOCK_Statement">END BLOCK Statement</A>
<BR><A HREF="#END_DO_Statement">END DO Statement</A>
<BR><A HREF="#END_GUESS_Statement">END GUESS Statement</A>
<BR><A HREF="#END_IF_Statement">END IF Statement</A>
<BR><A HREF="#END_LOOP_Statement">END LOOP Statement</A>
<BR><A HREF="#END_MAP_Statement">END MAP Statement</A>
<BR><A HREF="#END_SELECT_Statement">END SELECT Statement</A>
<BR><A HREF="#END_Statement">END Statement</A>
<BR><A HREF="#END_STRUCTURE_Statement">END STRUCTURE Statement</A>
<BR><A HREF="#END_UNION_Statement">END UNION Statement</A>
<BR><A HREF="#END_WHILE_Statement">END WHILE Statement</A>
<BR><A HREF="#EndMofMFile_Specifier">End-of-File Specifier</A>
<BR><A HREF="#Endfile_Record">Endfile Record</A>
<BR><A HREF="#ENDFILE_Statement">ENDFILE Statement</A>
<BR><A HREF="#ENTRY_Statement">ENTRY Statement</A>
<BR><A HREF="#The_ENTRY_Statement">The ENTRY Statement</A>
<BR><A HREF="#ENTRY_Statement_Restrictions">ENTRY Statement Restrictions</A>
<BR><A HREF="#ENTRY_Statements_in_External_Functions">ENTRY Statements in External Functions</A>
<BR><A HREF="#EQUIVALENCE_Statement">EQUIVALENCE Statement</A>
<BR><A HREF="#Error_Function">Error Function</A>
<BR><A HREF="#Error_Specifier">Error Specifier</A>
<BR><A HREF="#Evaluating_Expressions">Evaluating Expressions</A>
<BR><A HREF="#Examples">Examples</A>
<BR><A HREF="#EXECUTE_and_REMOTE_BLOCK">EXECUTE and REMOTE BLOCK</A>
<BR><A HREF="#EXECUTE_Statement">EXECUTE Statement</A>
<BR><A HREF="#EXIT">EXIT</A>
<BR><A HREF="#EXIT_Statement">EXIT Statement</A>
<BR><A HREF="#Exponential">Exponential</A>
<BR><A HREF="#Expressions">Expressions</A>
<BR><A HREF="#Extended_Assignment_Statement">Extended Assignment Statement</A>
<BR><A HREF="#Extended_Block_IF_Statement">Extended Block IF Statement</A>
<BR><A HREF="#Extended_Character_Set">Extended Character Set</A>
<BR><A HREF="#Extended_CHARACTER_Statement__Data_Initialization">Extended CHARACTER Statement:&nbsp; Data Initialization</A>
<BR><A HREF="#Extended_COMPLEX_Statement__Data_Initialization">Extended COMPLEX Statement:&nbsp; Data Initialization</A>
<BR><A HREF="#Extended_COMPLEX_Statement__Length_Specification">Extended COMPLEX Statement:&nbsp; Length Specification</A>
<BR><A HREF="#Extended_DO_Statement">Extended DO Statement</A>
<BR><A HREF="#Extended_DOUBLE_PRECISION_Statement__Data_Initialization">Extended DOUBLE PRECISION Statement:&nbsp; Data Initialization</A>
<BR><A HREF="#Extended_FUNCTION_Statement">Extended FUNCTION Statement</A>
<BR><A HREF="#Extended_IMPLICIT_Statement">Extended IMPLICIT Statement</A>
<BR><A HREF="#Extended_INTEGER_Statement__Data_Initialization">Extended INTEGER Statement:&nbsp; Data Initialization</A>
<BR><A HREF="#Extended_INTEGER_Statement__Length_Specification">Extended INTEGER Statement:&nbsp; Length Specification</A>
<BR><A HREF="#Extended_LOGICAL_Statement__Data_Initialization">Extended LOGICAL Statement:&nbsp; Data Initialization</A>
<BR><A HREF="#Extended_LOGICAL_Statement__Length_Specification">Extended LOGICAL Statement:&nbsp; Length Specification</A>
<BR><A HREF="#Extended_PRINT_Statement">Extended PRINT Statement</A>
<BR><A HREF="#Extended_READ_Statement">Extended READ Statement</A>
<BR><A HREF="#Extended_REAL_Statement__Data_Initialization">Extended REAL Statement:&nbsp; Data Initialization</A>
<BR><A HREF="#Extended_REAL_Statement__Length_Specification">Extended REAL Statement:&nbsp; Length Specification</A>
<BR><A HREF="#Extensions">Extensions</A>
<BR><A HREF="#External_Files">External Files</A>
<BR><A HREF="#External_Function_Subprogram_Restrictions">External Function Subprogram Restrictions</A>
<BR><A HREF="#External_Functions">External Functions</A>
<BR><A HREF="#EXTERNAL_Statement">EXTERNAL Statement</A>
<DT>- F -
<DD><A HREF="#F_Editing">F Editing</A>
<BR><A HREF="#Files">Files</A>
<BR><A HREF="#FloatingMpoint_Editing__F__E__D_and_G_Edit_Descriptors">Floating-point Editing:&nbsp; F, E, D and G Edit Descriptors</A>
<BR><A HREF="#Form_of_a_Relational_Expression">Form of a Relational Expression</A>
<BR><A HREF="#Format">Format</A>
<BR><A HREF="#FORMAT_as_a_Character_Expression">FORMAT as a Character Expression</A>
<BR><A HREF="#Format_Specification">Format Specification</A>
<BR><A HREF="#Format_Specifier">Format Specifier</A>
<BR><A HREF="#FORMAT_Statement">FORMAT Statement</A>
<BR><A HREF="#The_FORMAT_Statement">The FORMAT Statement</A>
<BR><A HREF="#FormatMDirected_InputDOutput">Format-Directed Input/Output</A>
<BR><A HREF="#Formatted_Record">Formatted Record</A>
<BR><A HREF="#FORTRAN_Source_Program_Format">FORTRAN Source Program Format</A>
<BR><A HREF="#FORTRAN_Statement_Summary">FORTRAN Statement Summary</A>
<BR><A HREF="#FORTRAN_Statements">FORTRAN Statements</A>
<BR><A HREF="#FUNCTION_Statement">FUNCTION Statement</A>
<BR><A HREF="#Functions_and_Subroutines">Functions and Subroutines</A>
<DT>- G -
<DD><A HREF="#G_Editing">G Editing</A>
<BR><A HREF="#Gamma_Function">Gamma Function</A>
<BR><A HREF="#GUESS_Statement">GUESS Statement</A>
<BR><A HREF="#GUESSMADMITMEND_GUESS">GUESS-ADMIT-END GUESS</A>
<DT>- H -
<DD><A HREF="#H_Editing">H Editing</A>
<BR><A HREF="#Hexadecimal_Constants_LExtensionR">Hexadecimal Constants (Extension)</A>
<BR><A HREF="#Hollerith_Constants_LExtensionR">Hollerith Constants (Extension)</A>
<BR><A HREF="#Hyperbolic_Cosine">Hyperbolic Cosine</A>
<BR><A HREF="#Hyperbolic_Sine">Hyperbolic Sine</A>
<BR><A HREF="#Hyperbolic_Tangent">Hyperbolic Tangent</A>
<DT>- I -
<DD><A HREF="#IF_M_ELSE_M_END_IF">IF - ELSE - END IF</A>
<BR><A HREF="#Imaginary_Part_of_Complex_Number">Imaginary Part of Complex Number</A>
<BR><A HREF="#IMPLICIT_NONE_Statement">IMPLICIT NONE Statement</A>
<BR><A HREF="#IMPLICIT_Statement">IMPLICIT Statement</A>
<BR><A HREF="#INCLUDE_Statement">INCLUDE Statement</A>
<BR><A HREF="#Index_of_a_Substring">Index of a Substring</A>
<BR><A HREF="#Initial_Line">Initial Line</A>
<BR><A HREF="#InputDOutput">Input/Output</A>
<BR><A HREF="#InputDOutput_Status_Specifier">Input/Output Status Specifier</A>
<BR><A HREF="#INQUIRE_by_FILE">INQUIRE by FILE</A>
<BR><A HREF="#INQUIRE_by_UNIT">INQUIRE by UNIT</A>
<BR><A HREF="#INQUIRE_Statement">INQUIRE Statement</A>
<BR><A HREF="#Inquiry_Specifiers">Inquiry Specifiers</A>
<BR><A HREF="#Integer_Constants">Integer Constants</A>
<BR><A HREF="#Integer_Editing__Iw_and_Iw_m_Edit_Descriptors">Integer Editing:&nbsp; Iw and Iw.m Edit Descriptors</A>
<BR><A HREF="#INTEGER_Statement">INTEGER Statement</A>
<BR><A HREF="#Internal_Files">Internal Files</A>
<BR><A HREF="#Intrinsic_Functions">Intrinsic Functions</A>
<BR><A HREF="#INTRINSIC_Statement">INTRINSIC Statement</A>
<DT>- L -
<DD><A HREF="#L_Edit_Descriptor">L Edit Descriptor</A>
<BR><A HREF="#Length">Length</A>
<BR><A HREF="#Length_of_Character_Actual_and_Dummy_Arguments">Length of Character Actual and Dummy Arguments</A>
<BR><A HREF="#Length_Without_Trailing_Blanks">Length Without Trailing Blanks</A>
<BR><A HREF="#Lexically_Greater_Than">Lexically Greater Than</A>
<BR><A HREF="#Lexically_Greater_Than_or_Equal">Lexically Greater Than or Equal</A>
<BR><A HREF="#Lexically_Less_Than">Lexically Less Than</A>
<BR><A HREF="#Lexically_Less_Than_or_Equal">Lexically Less Than or Equal</A>
<BR><A HREF="#ListMDirected_Formatting">List-Directed Formatting</A>
<BR><A HREF="#ListMDirected_Input">List-Directed Input</A>
<BR><A HREF="#ListMDirected_Output">List-Directed Output</A>
<BR><A HREF="#Logical_Assignment">Logical Assignment</A>
<BR><A HREF="#Logical_Constant">Logical Constant</A>
<BR><A HREF="#Logical_Constant_Expressions">Logical Constant Expressions</A>
<BR><A HREF="#Logical_Expressions">Logical Expressions</A>
<BR><A HREF="#Logical_IF_Statement">Logical IF Statement</A>
<BR><A HREF="#Logical_Operators">Logical Operators</A>
<BR><A HREF="#LOGICAL_Statement">LOGICAL Statement</A>
<BR><A HREF="#LOOP_M_END_LOOP">LOOP - END LOOP</A>
<BR><A HREF="#LOOP_Statement">LOOP Statement</A>
<DT>- M -
<DD><A HREF="#MAP_Statement">MAP Statement</A>
<BR><A HREF="#Memory_Location">Memory Location</A>
<DT>- N -
<DD><A HREF="#NAMELIST_Statement">NAMELIST Statement</A>
<BR><A HREF="#NamelistMDirected_Formatting_LExtensionR">Namelist-Directed Formatting (Extension)</A>
<BR><A HREF="#NamelistMDirected_Input_LExtensionR">Namelist-Directed Input (Extension)</A>
<BR><A HREF="#NamelistMDirected_Output">Namelist-Directed Output</A>
<BR><A HREF="#Names__Data_Types_and_Constants">Names, Data Types and Constants</A>
<BR><A HREF="#Natural_Log_of_Gamma_Function">Natural Log of Gamma Function</A>
<BR><A HREF="#Natural_Logarithm">Natural Logarithm</A>
<BR><A HREF="#Nearest_Integer">Nearest Integer</A>
<BR><A HREF="#Nearest_Whole_Number">Nearest Whole Number</A>
<BR><A HREF="#Nonrepeatable_Edit_Descriptors">Nonrepeatable Edit Descriptors</A>
<BR><A HREF="#Notes_on_Structured_Programming_Statements">Notes on Structured Programming Statements</A>
<BR><A HREF="#Numeric_Editing__I__F__E__D_and_G_Edit_Descriptors">Numeric Editing:&nbsp; I, F, E, D and G Edit Descriptors</A>
<DT>- O -
<DD><A HREF="#Octal_Constants_LExtensionR">Octal Constants (Extension)</A>
<BR><A HREF="#OPEN_Statement">OPEN Statement</A>
<BR><A HREF="#Open_Watcom_FORTRAN_77_Extensions_to_Standard_FORTRAN_77">Open Watcom FORTRAN 77 Extensions to Standard FORTRAN 77</A>
<BR><A HREF="#Order_of_FORTRAN_Statements_and_Lines">Order of FORTRAN Statements and Lines</A>
<BR><A HREF="#OTHERWISE_Statement">OTHERWISE Statement</A>
<DT>- P -
<DD><A HREF="#P_Editing">P Editing</A>
<BR><A HREF="#PARAMETER_Statement">PARAMETER Statement</A>
<BR><A HREF="#PAUSE_Statement">PAUSE Statement</A>
<BR><A HREF="#Positional_Editing__T__TL__TR_and_X_Editing">Positional Editing:&nbsp; T, TL, TR and X Editing</A>
<BR><A HREF="#Positive_Difference">Positive Difference</A>
<BR><A HREF="#PRINT_Statement">PRINT Statement</A>
<BR><A HREF="#Printing_of_Formatted_Records">Printing of Formatted Records</A>
<BR><A HREF="#Procedures_as_Dummy_Arguments">Procedures as Dummy Arguments</A>
<BR><A HREF="#PROGRAM_Statement">PROGRAM Statement</A>
<BR><A HREF="#Program_Structure_Control_Statements">Program Structure Control Statements</A>
<BR><A HREF="#Properties_of_Arrays">Properties of Arrays</A>
<DT>- Q -
<DD><A HREF="#QUIT">QUIT</A>
<BR><A HREF="#QUIT_Statement">QUIT Statement</A>
<DT>- R -
<DD><A HREF="#READ_Statement">READ Statement</A>
<BR><A HREF="#Reading_and_Writing">Reading and Writing</A>
<BR><A HREF="#Real_Constants">Real Constants</A>
<BR><A HREF="#REAL_Statement">REAL Statement</A>
<BR><A HREF="#Record_Specifier">Record Specifier</A>
<BR><A HREF="#RECORD_Statement">RECORD Statement</A>
<BR><A HREF="#Records">Records</A>
<BR><A HREF="#Referencing_a_Statement_Function">Referencing a Statement Function</A>
<BR><A HREF="#Referencing_a_Subroutine__The_CALL_Statement">Referencing a Subroutine:&nbsp; The CALL Statement</A>
<BR><A HREF="#Referencing_an_External_Function">Referencing an External Function</A>
<BR><A HREF="#Relational_Expressions">Relational Expressions</A>
<BR><A HREF="#Relational_Operators">Relational Operators</A>
<BR><A HREF="#Remainder">Remainder</A>
<BR><A HREF="#REMOTE_BLOCK_Statement">REMOTE BLOCK Statement</A>
<BR><A HREF="#Repeatable_Edit_Descriptors">Repeatable Edit Descriptors</A>
<BR><A HREF="#RETURN_Statement">RETURN Statement</A>
<BR><A HREF="#The_RETURN_Statement">The RETURN Statement</A>
<BR><A HREF="#RETURN_Statement_in_Function_Subprograms">RETURN Statement in Function Subprograms</A>
<BR><A HREF="#RETURN_Statement_in_Subroutine_Subprograms">RETURN Statement in Subroutine Subprograms</A>
<BR><A HREF="#RETURN_Statement_in_the_Main_Program_LExtensionR">RETURN Statement in the Main Program (Extension)</A>
<BR><A HREF="#REWIND_Statement">REWIND Statement</A>
<BR><A HREF="#Rules_for_Forming_Character_Expressions">Rules for Forming Character Expressions</A>
<BR><A HREF="#Rules_for_Forming_Logical_Expressions">Rules for Forming Logical Expressions</A>
<BR><A HREF="#Rules_for_Forming_Standard_Arithmetic_Expressions">Rules for Forming Standard Arithmetic Expressions</A>
<DT>- S -
<DD><A HREF="#S__SP_and_SS_Editing">S, SP and SS Editing</A>
<BR><A HREF="#SAVE_Statement">SAVE Statement</A>
<BR><A HREF="#SELECT_M_END_SELECT">SELECT - END SELECT</A>
<BR><A HREF="#SELECT_Statement">SELECT Statement</A>
<BR><A HREF="#Significance_of_Lower_Case_Characters_LExtensionR">Significance of Lower Case Characters (Extension)</A>
<BR><A HREF="#Significance_of_the_Blank_Character">Significance of the Blank Character</A>
<BR><A HREF="#Simple_DOUBLE_COMPLEX_Statement">Simple DOUBLE COMPLEX Statement</A>
<BR><A HREF="#Sine">Sine</A>
<BR><A HREF="#Size_of_Variable_or_Structure">Size of Variable or Structure</A>
<BR><A HREF="#Slash_Editing">Slash Editing</A>
<BR><A HREF="#Source_Program_Format">Source Program Format</A>
<BR><A HREF="#Specific_Names_and_Generic_Names_of_Intrinsic_Functions">Specific Names and Generic Names of Intrinsic Functions</A>
<BR><A HREF="#Specifiers">Specifiers</A>
<BR><A HREF="#Square_Root">Square Root</A>
<BR><A HREF="#Standard_Block_IF_Statement">Standard Block IF Statement</A>
<BR><A HREF="#Standard_CHARACTER_Statement">Standard CHARACTER Statement</A>
<BR><A HREF="#Standard_COMPLEX_Statement">Standard COMPLEX Statement</A>
<BR><A HREF="#Standard_DO_Statement">Standard DO Statement</A>
<BR><A HREF="#Standard_DOUBLE_PRECISION_Statement">Standard DOUBLE PRECISION Statement</A>
<BR><A HREF="#Standard_FUNCTION_Statement">Standard FUNCTION Statement</A>
<BR><A HREF="#Standard_IMPLICIT_Statement">Standard IMPLICIT Statement</A>
<BR><A HREF="#Standard_INTEGER_Statement">Standard INTEGER Statement</A>
<BR><A HREF="#Standard_LOGICAL_Statement">Standard LOGICAL Statement</A>
<BR><A HREF="#Standard_PRINT_Statement">Standard PRINT Statement</A>
<BR><A HREF="#Standard_READ_Statement">Standard READ Statement</A>
<BR><A HREF="#Standard_REAL_Statement">Standard REAL Statement</A>
<BR><A HREF="#Statement_Function_Restrictions">Statement Function Restrictions</A>
<BR><A HREF="#Statement_Functions">Statement Functions</A>
<BR><A HREF="#Statement_Label_Assignment">Statement Label Assignment</A>
<BR><A HREF="#Statement_Label_Assignment_LASSIGNR_Statement">Statement Label Assignment (ASSIGN) Statement</A>
<BR><A HREF="#STOP_Statement">STOP Statement</A>
<BR><A HREF="#String_Constant_LExtensionR">String Constant (Extension)</A>
<BR><A HREF="#STRUCTURE_Statement">STRUCTURE Statement</A>
<BR><A HREF="#Structures_and_Records">Structures and Records</A>
<BR><A HREF="#Structures__Unions_and_Records">Structures, Unions and Records</A>
<BR><A HREF="#Subprogram_Arguments">Subprogram Arguments</A>
<BR><A HREF="#SUBROUTINE_Statement">SUBROUTINE Statement</A>
<BR><A HREF="#Subroutine_Subprogram_Restrictions">Subroutine Subprogram Restrictions</A>
<BR><A HREF="#Subroutines">Subroutines</A>
<BR><A HREF="#Substring_Names">Substring Names</A>
<BR><A HREF="#Symbolic_Constants">Symbolic Constants</A>
<BR><A HREF="#Symbolic_Names">Symbolic Names</A>
<DT>- T -
<DD><A HREF="#Tangent">Tangent</A>
<BR><A HREF="#Transfer_of_Sign">Transfer of Sign</A>
<BR><A HREF="#Truncation">Truncation</A>
<BR><A HREF="#Type_Conversion__Character_conversion_to_integer">Type Conversion:&nbsp; Character conversion to integer</A>
<BR><A HREF="#Type_Conversion__Conversion_to_character">Type Conversion:&nbsp; Conversion to character</A>
<BR><A HREF="#Type_Conversion__Conversion_to_complex">Type Conversion:&nbsp; Conversion to complex</A>
<BR><A HREF="#Type_Conversion__Conversion_to_double_complex">Type Conversion:&nbsp; Conversion to double complex</A>
<BR><A HREF="#Type_Conversion__Conversion_to_double_precision">Type Conversion:&nbsp; Conversion to double precision</A>
<BR><A HREF="#Type_Conversion__Conversion_to_integer">Type Conversion:&nbsp; Conversion to integer</A>
<BR><A HREF="#Type_Conversion__Conversion_to_real">Type Conversion:&nbsp; Conversion to real</A>
<DT>- U -
<DD><A HREF="#Unconditional_GO_TO_Statement">Unconditional GO TO Statement</A>
<BR><A HREF="#Unformatted_Record">Unformatted Record</A>
<BR><A HREF="#UNION_Statement">UNION Statement</A>
<BR><A HREF="#Unions">Unions</A>
<BR><A HREF="#The_Unit_Specifier">The Unit Specifier</A>
<BR><A HREF="#Units">Units</A>
<BR><A HREF="#UNTIL">UNTIL</A>
<BR><A HREF="#UNTIL_Statement">UNTIL Statement</A>
<BR><A HREF="#Use_of_Array_Names">Use of Array Names</A>
<DT>- V -
<DD><A HREF="#Variables_as_Dummy_Arguments">Variables as Dummy Arguments</A>
<BR><A HREF="#Volatile_Reference">Volatile Reference</A>
<BR><A HREF="#VOLATILE_Statement">VOLATILE Statement</A>
<DT>- W -
<DD><A HREF="#WHILE_M_END_WHILE">WHILE - END WHILE</A>
<BR><A HREF="#WHILE_M_ExecutableMstatement">WHILE - Executable-statement</A>
<BR><A HREF="#WHILE_Statement">WHILE Statement</A>
<BR><A HREF="#WRITE_Statement">WRITE Statement</A>
<DT>- Z -
<DD><A HREF="#Z_Editing_LExtensionR">Z Editing (Extension)</A>
</DL>
<H1 ID="FORTRAN_Source_Program_Format"> FORTRAN Source Program Format </H1>
<BR>The following sections describe input rules for FORTRAN source programs.
<H2 ID="Character_Set"> Character Set </H2>
<BR>The FORTRAN<B> character set</B> consists of twenty-six letters, ten digits, and thirteen special characters.
<BR><BR>The letters are:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; A B C D E F G H I J K L M N O P Q R S T U V W X Y Z</TT>
<BR><BR>The digits are:<TT>&nbsp; 0 1 2 3 4 5 6 7 8 9</TT>
<BR><BR>The special characters are:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +-----------+-----------------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; | Character | Name of Character&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +-----------+-----------------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Blank&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; | =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Equals&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; | +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Plus&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; | -&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Minus&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; | *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Asterisk&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; | /&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Slash&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; | (&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Left Parenthesis&nbsp;&nbsp;&nbsp;
&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; | )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Right Parenthesis&nbsp;&nbsp;&nbsp;
&nbsp;|</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; | ,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Comma&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; | .&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Decimal Point&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; | $&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Currency Symbol&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; | '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Apostrophe&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; | :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Colon&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +-----------+-----------------------+</TT>
<BR><BR>The FORTRAN character set is a subset of the character set of the computing system which you are using.&nbsp; We shall
refer to the larger character set as the<B> processor character set.</B>
<H2 ID="Extended_Character_Set"> Extended Character Set </H2>
<BR>Open Watcom FORTRAN 77 also includes the following special characters.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +-----------+-----------------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; | Character | Name of Character&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +-----------+-----------------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; | !&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Exclamation Mark&nbsp;&nbsp;&nbsp;
&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; | %&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Percentage Symbol&nbsp;&nbsp;&nbsp;
&nbsp;|</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; | \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Back slash&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +-----------+-----------------------+</TT>
<H2 ID="Source_Program_Format"> Source Program Format </H2>
<BR>Open Watcom FORTRAN 77 supports one source program format.&nbsp; A FORTRAN program is composed of<B> lines.</B>&nbsp;
There are three types of lines; the<B> comment</B> line, the<B> initial</B> line, and the<B> continuation</B> line.
<H3 ID="Comment_Line"> Comment Line </H3>
<BR><B> Comment</B> lines are denoted by placing a &quot;C&quot; or &quot;*&quot; in column one of the line.&nbsp; Open Watcom
FORTRAN 77 also allows the use of a lowercase &quot;c&quot; as a comment indicator.&nbsp; <B> Blank</B> lines are treated
as comment lines.&nbsp; Comment lines may be placed anywhere in the program source (i.e., they may appear before a FORTRAN
statement, they may be intermingled with continuation lines, or they may appear after a statement).&nbsp; There is no restriction
on the number of comment lines.&nbsp; Comment lines may contain any characters from the processor character set.
<BR><BR>Open Watcom FORTRAN 77 allows end-of-line comments.&nbsp; If a &quot;!&quot; character appears in column 1 or anywhere
in the statement portion of a source line, the remainder of that line is treated as a comment unless the &quot;!&quot; appears
inside quotation marks or in column 6.
<H3 ID="Debug_Line_LExtensionR"> Debug Line (Extension) </H3>
<BR><B> Debug</B> lines are denoted by placing a &quot;D&quot; or &quot;d&quot; in column one of the line.&nbsp; Debug lines
contain FORTRAN statements.&nbsp; There is no restriction on the number of debug lines.&nbsp; Normally, the FORTRAN statements
on debug lines are ignored by the compiler.&nbsp; See the User's Guide for information on activating debug statements.
<H3 ID="Initial_Line"> Initial Line </H3>
<BR>An<B> initial</B> line is the first line of a FORTRAN statement.&nbsp; Column 6 of this line must be blank or contain
the digit &quot;0&quot;.&nbsp; A comment line can never be an initial line.&nbsp; Columns 1 through 5 of an initial line may
contain a<B> statement label.</B>&nbsp; Statement labels are composed entirely of digits.&nbsp; The statement label may be
thought of as an integral number and, as such, leading 0 digits are not significant.&nbsp; For example, the label composed
of the digits &quot;00123&quot; is the same as the label &quot;123&quot;.&nbsp; The same label may not identify more than
one statement in a<B> program unit.</B>&nbsp; A program unit is a series of comment lines and FORTRAN statements ending in
an<TT> END</TT> statement.&nbsp; The body of the FORTRAN<B> statement</B> is entered starting in column 7 and stopping at
column 72.&nbsp; Column 73 and on is called the<B> sequence field</B> and is ignored by the compiler.
<H3 ID="Continuation_Line"> Continuation Line </H3>
<BR>A statement may be<B> continued</B> on a new line.&nbsp; A continuation character is placed in column 6.&nbsp; The continuation
character may not be a blank character or a &quot;0&quot; character.&nbsp; FORTRAN 77 requires that the continuation character
be selected from the FORTRAN character set but Open Watcom FORTRAN 77 allows any character from the processor's character
set.&nbsp; The statement number field must be blank.&nbsp; The previous statement is continued on the new line, starting in
column 7 and continuing to column 72.&nbsp; Under the control of a compiler option, Open Watcom FORTRAN 77 permits the source
statement to extend to column 132.
<BR><BR>FORTRAN 77 allows up to 19 continuation lines to continue a statement.&nbsp; Open Watcom FORTRAN 77 extends this by
allowing more than 19 continuation lines.&nbsp; A minimum of 61 continuation lines are permitted when the source statement
ends at column 72.&nbsp; A minimum of 31 continuation lines are permitted when the source statement ends at column 132.&nbsp;
The maximum number of continuation lines depends on the sum of the lengths of all the continuation lines.
<H3 ID="Significance_of_the_Blank_Character"> Significance of the Blank Character </H3>
<BR>Except in the following cases, blank characters have no meaning within a program unit.
<DL>
<DT>(1)
<DD>Character and Hollerith constants.
<DT>(2)
<DD>Apostrophe and H edit descriptors in format specifications.
</DL>
<BR>For example, the symbolic name<TT> A B</TT> is the same as the symbolic name<TT> AB.</TT>
<H3 ID="Significance_of_Lower_Case_Characters_LExtensionR"> Significance of Lower Case Characters (Extension) </H3>
<BR>Except in the following cases, lower case characters are treated as if they were the upper case equivalent.&nbsp; This
is a Open Watcom FORTRAN 77 extension to the usual rules of FORTRAN.
<DL>
<DT>(1)
<DD>Character and Hollerith constants.
<DT>(2)
<DD>Apostrophe and H edit descriptors in format specifications.
</DL>
<BR>Hence,<TT> TOTAL, total,</TT> and<TT> Total</TT> represent the same symbolic name and<TT> 3F10.2</TT> and<TT> 3f10.2</TT>
represent the same format edit descriptor.
<H3 ID="Examples"> Examples </H3>
<BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C This and the following five lines are comment lines.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; c The following statement &quot;INDEX = INDEX + 2&quot; has a</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; c statement number and is continued by placing a &quot;$&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; c in column 6.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Column Numbers</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *234567890</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 10&nbsp;&nbsp;&nbsp; INDEX = INDEX</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $ + 2</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * The above blank lines are treated like comment lines.</TT>
<BR><BR>The following example demonstrates the use of comment lines, blanks lines, and continuation lines.&nbsp; We use the
symbol &quot;$&quot; to denote continuation lines although any character other than a blank or &quot;0&quot; could have been
used.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * From the quadratic equation</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; ax&nbsp; + bx + c = 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * we derive the following two equations:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ____________</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp; / 2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -b - \/ b&nbsp; - 4ac</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; x = ---------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2a</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * and express these equations in FORTRAN as:</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X1 = ( -B + SQRT( B**2 - 4 * A * C ) )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $&nbsp;&nbsp; /&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;( 2 * A )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X2 = ( -B - SQRT( B**2 - 4 * A * C ) )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $&nbsp;&nbsp; /&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;( 2 * A )</TT>
<H2 ID="Order_of_FORTRAN_Statements_and_Lines"> Order of FORTRAN Statements and Lines </H2>
<BR>The first statement of a program unit may be a<TT> PROGRAM</TT>,<TT> FUNCTION</TT>,<TT> SUBROUTINE</TT>, or<TT> BLOCK
DATA</TT> statement.&nbsp; The<TT> PROGRAM</TT> statement identifies the start of a main program and there may only be one
of these in an executable FORTRAN program.&nbsp; Execution of a FORTRAN program begins with the first<B> executable</B> statement
in the main program.&nbsp; The other statements identify the start of a subprogram.&nbsp; If the first statement of a program
unit is not one of the above then the program unit is considered to be a main program.
<BR><BR>Although you may not be familiar with all of the terms used here, it is important that you understand that FORTRAN
77 has specific rules regarding the ordering of FORTRAN statements.&nbsp; You may wish to refer to this section at later times.
&nbsp;In general, the following rules apply to the order of statements and comment lines within a program unit:
<OL>
<LI>Comment lines and<TT> INCLUDE</TT> statements may appear anywhere.
<LI><TT> FORMAT</TT> statements may appear anywhere in a subprogram.
<LI>All specification statements must precede all<TT> DATA</TT> statements,<B> statement function</B> statements, and executable
statements.
<LI>All statement function statements must precede all executable statements.
<LI><TT> DATA</TT> statements may appear anywhere after the specification statements.
<LI><TT> ENTRY</TT> statements may appear anywhere except between a block<TT> IF</TT> statement and its corresponding<TT>
END IF</TT> statement, or between a<TT> DO</TT> statement and its corresponding terminal statement.&nbsp; Open Watcom FORTRAN
77 extends these rules to apply to all program structure blocks resulting from the use of statements introduced to the language
by Open Watcom FORTRAN 77 (e.g.,<TT> WHILE</TT>,<TT> LOOP</TT>,<TT> SELECT</TT>).
<LI><TT> IMPLICIT</TT> statements must precede all other specification statements, except<TT> PARAMETER</TT> statements.&nbsp;
A specification statement that defines the type of a symbolic constant must appear before the<TT> PARAMETER</TT> statement
that defines the name and value of a symbolic constant.&nbsp; A<TT> PARAMETER</TT> statement that defines the name and value
of a symbolic constant must precede all other statements containing a reference to that symbolic constant.
</OL>
<BR>The following chart illustrates the required order of FORTRAN statements.&nbsp; Vertical lines delineate varieties of
statements that may be interspersed, while horizontal lines mark varieties of statements that may not be interspersed.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +-----------+-------------------------------------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | PROGRAM, FUNCTION, SUBROUTINE,
or&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | BLOCK DATA Statement&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-----------+---------------+---------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | IMPLICIT
&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; PARAMETER&nbsp;&nbsp;&nbsp; | Statements&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +---------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; | Comment&nbsp;&nbsp; | ENTRY&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; Statements&nbsp;&nbsp; | Other
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; | Lines&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Specification |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | and&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Statements&nbsp;&nbsp;&nbsp;
|</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; |---------------+---------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | FORMAT&nbsp;&nbsp;&nbsp;
|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Statement&nbsp;&nbsp;&nbsp;&nbsp;
|</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; | INCLUDE&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Function&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; | Statement | Statements|&nbsp; DATA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Statements
&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +---------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; Statements&nbsp;&nbsp; | Executable&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Statements
&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-----------+---------------+---------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | END Statement&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +-----------+-------------------------------------------+</TT>
<BR><BR><B>Required Order of Comment Lines and Statements</B>
<BR><BR>For example,<TT> DATA</TT> statements may be interspersed with<B> statement function</B> statements and executable
statements but<B> statement function</B> statements must precede executable statements.
<H1 ID="FORTRAN_Statements"> FORTRAN Statements </H1>
<BR>The following sections describe each FORTRAN 77 statement.
<H2 ID="Classifying_Statements"> Classifying Statements </H2>
<BR>The following table is a summary of Open Watcom FORTRAN 77 statement classification.
<DL>
<DT>Column 1
<DD>indicates that the statement is a specification statement.
<DT>Column 2
<DD>indicates that the statement is not allowed as the terminal statement of a DO-loop.
<DT>Column 3
<DD>indicates that the statement is not executable.
<DT>Column 4
<DD>indicates that the statement is not allowed as the object of a logical<TT> IF</TT>
<BR><BR>or<TT> WHILE</TT> statement.
<DT>Column 5
<DD>indicates that the statement cannot have control of execution transferred to it by using a statement label.
<DT>Column 6
<DD>indicates that the statement is allowed in a block data subprogram.
</DL>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +---------------------+------+------+------+------+------+------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |Statement&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; 1&nbsp;
&nbsp;|&nbsp; 2&nbsp;&nbsp; |&nbsp; 3&nbsp;&nbsp; |&nbsp; 4&nbsp;&nbsp; |&nbsp; 5&nbsp;&nbsp; |&nbsp; 6&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +---------------------+------+------+------+------+------+------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |ADMIT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp;
*&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |ALLOCATE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;
&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;
&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |ASSIGN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |AT END&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;
&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |BACKSPACE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;
&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;
&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |BLOCK DATA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;
&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |CALL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;
&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |CASE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp;
*&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |CHARACTER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; *&nbsp;
&nbsp;|&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |CLOSE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;
&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |COMMON&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;
&nbsp;|</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +---------------------+------+------+------+------+------+------+</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +---------------------+------+------+------+------+------+------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |Statement&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; 1&nbsp;
&nbsp;|&nbsp; 2&nbsp;&nbsp; |&nbsp; 3&nbsp;&nbsp; |&nbsp; 4&nbsp;&nbsp; |&nbsp; 5&nbsp;&nbsp; |&nbsp; 6</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +---------------------+------+------+------+------+------+------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |COMPLEX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
&nbsp;*&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;
&nbsp;|</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |CONTINUE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;
&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;
&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |CYCLE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;
&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |DATA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp;
|&nbsp; *&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |DEALLOCATE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;
&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;
&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |DIMENSION&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; *&nbsp;
&nbsp;|&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |DO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |
&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |DOUBLE COMPLEX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;
&nbsp;|&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |DOUBLE PRECISION&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp;
*&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |DO WHILE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;
&nbsp;&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |ELSE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp;
*&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |ELSE IF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp;
|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |END&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |
&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |END AT END&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;
&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;
&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |END BLOCK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;
&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp;&nbsp;
&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |END DO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp;
*&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |ENDFILE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |END GUESS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;
&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |END IF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp;&nbsp;
&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |END LOOP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;
&nbsp;&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp;
&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |END MAP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
&nbsp;*&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;
&nbsp;|</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |END SELECT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp;
|&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |END STRUCTURE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *
&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |END UNION&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;
&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;
&nbsp;|</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |END WHILE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;
&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp;&nbsp;
&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |ENTRY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp;
*&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |EQUIVALENCE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp;
|&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |EXECUTE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |EXIT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;
&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |EXTERNAL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;
*&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;
&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |FORMAT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |
&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |FUNCTION&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;
&nbsp;&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;
&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |assigned GO TO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;
*&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;
&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |computed GO TO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;
&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;
&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |unconditional GO TO&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp;
&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |GUESS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp;
&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |arithmetic IF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|&nbsp; *&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;
&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |logical IF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;
&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |block IF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;
&nbsp;&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +---------------------+------+------+------+------+------+------+</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +---------------------+------+------+------+------+------+------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |Statement&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; 1&nbsp;
&nbsp;|&nbsp; 2&nbsp;&nbsp; |&nbsp; 3&nbsp;&nbsp; |&nbsp; 4&nbsp;&nbsp; |&nbsp; 5&nbsp;&nbsp; |&nbsp; 6</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +---------------------+------+------+------+------+------+------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |IMPLICIT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;
*&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp;
|</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |INCLUDE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *
&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |INQUIRE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |INTEGER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
&nbsp;*&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;
&nbsp;|</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |INTRINSIC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; *&nbsp;
&nbsp;|&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |LOGICAL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
&nbsp;*&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;
&nbsp;|</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |LOOP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp;
&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |MAP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp;
|&nbsp; *&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |NAMELIST&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;
*&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;
&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |OPEN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;
&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |OTHERWISE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;
&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp;&nbsp;
&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |PARAMETER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; *&nbsp;
&nbsp;|&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |PAUSE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;
&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |PRINT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;
&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |PROGRAM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp;&nbsp;
&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |QUIT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;
&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |READ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;
&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |REAL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp;
*&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |RECORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;
&nbsp;|</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |REMOTE BLOCK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |RETURN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;
&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |REWIND&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |SAVE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp;
*&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |SELECT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp;&nbsp;
&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |STOP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |STRUCTURE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; *&nbsp;
&nbsp;|&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |SUBROUTINE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;
&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |UNION&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;|&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp;
*&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |UNTIL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp;
*&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |VOLATILE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;
*&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp;
|</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |WHILE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; *&nbsp;&nbsp; |&nbsp;
&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |WRITE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;
&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +---------------------+------+------+------+------+------+------+</TT>
<H2 ID="FORTRAN_Statement_Summary"> FORTRAN Statement Summary </H2>
<BR>The following sections describe each FORTRAN 77 statement.&nbsp; The statement descriptions are organized alphabetically
for quick reference.&nbsp; The syntax models for each statement are presented in shaded or unshaded boxes.&nbsp; The unshaded
box denotes a standard FORTRAN 77 statement.&nbsp; The shaded box denotes a Open Watcom FORTRAN 77 extension to the language.
&nbsp;Users should note that extensions which are supported by this compiler may not be supported by other compilers.&nbsp;
We leave the choice to use a particular extension to the discretion of the programmer.
<BR><BR>In the following sections the use of square brackets ([ ]) denotes items which may be optionally specified.&nbsp;
The use of the ellipsis (...) denotes items which may be repeated as often as desired.
<H2 ID="ADMIT_Statement"> ADMIT Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ADMIT</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR>The<TT> ADMIT</TT> statement is used in conjunction with the structured<TT> GUESS</TT> statement.&nbsp; The<TT> ADMIT</TT>
statement marks the beginning of an alternative block of statements that are executed if a<TT> QUIT</TT> statement is executed
in a previous<TT> GUESS</TT> or<TT> ADMIT</TT> block.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; Assume incorrect sex code</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GUESS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( SEX .EQ. 'F' )QUIT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( SEX .EQ. 'M' )QUIT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'Invalid sex code encountered'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALL INVSEX( SEX )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; Wrong assumption - sex code is fine</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ADMIT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END GUESS</TT>
<BR><BR>For more information, see the chapter entitled <A HREF="#Program_Structure_Control_Statements">Program Structure Control Statements</A>.
<H2 ID="ALLOCATE_Statement"> ALLOCATE Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp; ALLOCATE (array([l:]u[,[l:]u,...])[,...][,LOCATION=loc])</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp; ALLOCATE (array([l:]u[,[l:]u,...])[,...][,STAT=ierr])</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp; ALLOCATE (char*len)</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>array
<DD>is the name of an allocatable array.
<DT>l
<DD>is an integer expression that sets the lower bound of the array dimension.
<DT>u
<DD>is an integer expression that sets the upper bound of the array dimension.
<DT>char
<DD>is the name of an allocatable character variable.
<DT>len
<DD>is an integer expression that sets the length of the character variable.
<DT>LOCATION = loc
<DD>
<BR><BR><TT>loc</TT> is an integer expression that specifies the location of the allocated memory.
<DT>STAT = ierr
<DD>
<BR><BR><TT>ierr</TT> is an allocation status specifier.&nbsp; The integer variable or integer array element<TT> ierr</TT>
is defined with 0 if the allocation succeeded, 1 if the allocation failed, and 2 if the array is already allocated.&nbsp;
The<TT> STAT=</TT> specifier may not be used with the<TT> LOCATION=</TT> specifier.
</DL>
<BR>Allocatable arrays and character variables may be dynamically allocated and deallocated at execution time.&nbsp; An array
must have been declared allocatable by specifying its dimensions using colons only.&nbsp; No array bounds are specified.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DIMENSION A(:), B(:,:)</TT>
<BR><BR>In the above example,<TT> A</TT> is declared to be a one-dimensional allocatable array and<TT> B</TT> is declared
to be a two-dimensional allocatable array.
<BR><BR>A character variable must have been declared allocatable by specifying its size as (*).
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER C*(*)</TT>
<BR><BR>For an allocatable array, the<TT> ALLOCATE</TT> statement establishes the lower and upper bounds of each array dimension
and calculates the amount of memory required for the array.
<BR><BR>For an allocatable character variable, the<TT> ALLOCATE</TT> statement establishes the number of characters in the
character variable and thus the size of the character variable.
<BR><BR>If there is no<TT> LOCATION=</TT> specifier, it then attempts to dynamically allocate memory for the array or character
variable.&nbsp; The success of the allocation can be checked by using the<TT> STAT=</TT> specifier.
<BR><BR>If there is a<TT> LOCATION=</TT> specifier, the expression in the specification is evaluated and that value is used
as the address of the array or character variable.&nbsp; This permits the programmer to specify a substitute memory allocator
or to map the array or character variable onto a fixed memory location.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DIMENSION A(:), B(:,:)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ALLOCATE( A(N) )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ALLOCATE( B(0:4,5) )</TT>
<BR><BR>More than one allocatable array or character variable may appear in an<TT> ALLOCATE</TT> statement, separated by commas.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DIMENSION A(:), B(:,:)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ALLOCATE( A(N), B(0:4,5) )</TT>
<BR><BR>If the allocation fails and the<TT> STAT=</TT> specifier was not used, an execution-time error occurs.&nbsp; If the<TT>
STAT=</TT> specifier is used, the specified variable returns a zero value if the allocation succeeded, and a non-zero value
if the allocation failed.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DIMENSION A(:), B(:,:)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ALLOCATE( A(N), B(0:4,5), STAT=IALLOC )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( IALLOC .NE. 0 ) PRINT *, 'Allocation failure'</TT>
<BR><BR>An attempt to allocate a previously allocated array or character variable results in an execution-time error.&nbsp;
If the<TT> LOCATION=</TT> specifier was not used, the array or character variable must be deallocated first before it can
be allocated a second time (see the<TT> DEALLOCATE</TT> statement).
<BR><BR>An absolute memory location may be specified using the<TT> LOCATION=</TT> specifier.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*1 SCREEN(:,:)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; N = 80*25</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$IFDEF __386__</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ALLOCATE( SCREEN(0:1,0:N-1), LOCATION='B8000'x )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$ELSE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ALLOCATE( SCREEN(0:1,0:N-1), LOCATION='B8000000'x )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$ENDIF</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO I = 0, N-1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SCREEN(0,I) = '*'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDDO</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>The above example maps the array<TT> SCREEN</TT> onto the IBM PC colour monitor screen memory and then fills the screen
with asterisks (16-bit real-mode only).&nbsp; The character is stored in<TT> SCREEN(0,I)</TT> and the character attribute
(unchanged in this example) is stored in<TT> SCREEN(1,I).</TT>&nbsp; The column major ordering of arrays must be taken into
consideration when mapping an array onto a fixed area of memory.
<BR><BR>The following example is similar but uses an allocatable character variable.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*(*) SCREEN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER SCRSIZE, I</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PARAMETER ( SCRSIZE = 80*25*2 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$IFDEF __386__</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ALLOCATE( SCREEN*SCRSIZE, LOCATION='B8000'X )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$ELSE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ALLOCATE( SCREEN*SCRSIZE, LOCATION='B8000000'X )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *$ENDIF</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO I = 1, SCRSIZE, 2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SCREEN(I:I) = '*'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDDO</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>A user-defined memory allocator may be specified using the<TT> LOCATION=</TT> specifier.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*1 BUFFER(:)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; N = 128</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ALLOCATE( BUFFER(0:N-1), LOCATION=MYALLOC(N) )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>Perhaps a better way to check for a successful allocation, in this case, would be the following.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*1 BUFFER(:)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; N = 128</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOC = MYALLOC( N )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( LOC .EQ. 0 ) STOP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ALLOCATE( BUFFER(0:N-1), LOCATION=LOC )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>For more information on arrays, see the chapter entitled <A HREF="#Arrays">Arrays</A>.
<H2 ID="Statement_Label_Assignment_LASSIGNR_Statement"> Statement Label Assignment (ASSIGN) Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ASSIGN s TO i</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>s
<DD>is a statement label
<DT>i
<DD>is an integer variable name
</DL>
<BR>The statement label<TT> s</TT> is assigned to the integer variable<TT> i.</TT>&nbsp; The statement label must appear in
the same program unit as the<TT> ASSIGN</TT> statement.&nbsp; The statement label must be that of an executable statement
or a<TT> FORMAT</TT> statement.
<BR><BR>After a statement label has been assigned to an integer variable, that variable may only be used in an assigned<TT>
GO TO</TT> statement or as a format identifier in an input/output statement.&nbsp; The integer variable must not be used in
any other way (e.g., in an arithmetic expression).&nbsp; It may, however, be redefined with another statement label using
the<TT> ASSIGN</TT> statement or it may be assigned an integer value (e.g., in an arithmetic assignment statement).
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER RET</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X = 0.0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ASSIGN 100 TO RET</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GO TO 3000</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 100&nbsp;&nbsp; X = X + 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ASSIGN 110 TO RET</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GO TO 3000</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 110&nbsp;&nbsp; X = X + 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; Print both X and its square root</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 3000&nbsp; Y = SQRT( X )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, X, Y</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GO TO RET</TT>
<BR><BR>In the above example, we illustrate the use of the<TT> ASSIGN</TT> statement and the assigned<TT> GO TO</TT> statement
to implement a &quot;local subroutine&quot; in a program unit.&nbsp; A sequence of often-used code can be &quot;called&quot;
using the unconditional<TT> GO TO</TT> statement and &quot;return&quot; is accomplished using the assigned<TT> GO TO</TT>
statement.&nbsp; Care must be exercised to properly assign the return label value.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( FIRST )THEN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ASSIGN 100 TO LFRMT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ELSE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ASSIGN 200 TO LFRMT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END IF</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WRITE( UNIT=5, FMT=LFRMT) X, Y, Z</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 100&nbsp;&nbsp; FORMAT(1X,3F10.5)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 200&nbsp;&nbsp; FORMAT(1X,3E15.7)</TT>
<BR><BR>It should be noted that the<TT> ASSIGN</TT> statement does not assign the numeric value of the statement label to
the variable.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ASSIGN 100 TO LABEL2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, LABEL2</TT>
<BR><BR>Try the above example; the value printed will not be 100.
<BR><BR>Consider the following example.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Illegal use of a GOTO statement.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LABEL2 = 123</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LABEL3 = LABEL2 + 10</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GO TO LABEL3</TT>
<BR><BR><TT>LABEL3</TT> is assigned the integer value 133.&nbsp; The assigned<TT> GO TO</TT> statement, which follows it,
is illegal and a run-time error will occur when it is executed.
<BR><BR>Statement label values are quite different from integer values and the two should never be mixed.&nbsp; In the following
example, the assignment statement is illegal since it involves an integer variable that was specified in an<TT> ASSIGN</TT>
statement.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Illegal use of an ASSIGNed variable in an expression.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ASSIGN 100 TO LABEL2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LABEL3 = LABEL2 + 10</TT>
<BR><BR>Note that if the assignment statement was preceded by
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; LABEL2 = 100</TT>
<BR><BR>the assignment statement would have been legal.
<H2 ID="AT_END_Statement"> AT END Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AT END DO&nbsp;&nbsp;&nbsp; [: block-label]</TT></TT>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT></TT> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or</TT></TT>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT></TT> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AT END, stmt</TT></TT>&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>stmt
<DD>is an executable statement other than an<TT> AT END</TT> statement.
</DL>
<BR>The<TT> AT END</TT> control statement is an extension of the<TT> END=</TT> option of the<TT> READ</TT> statement for sequential
files.&nbsp; It allows a statement or a block of code following the<TT> READ</TT> statement to be executed when an end-of-file
condition is encountered during the read.&nbsp; The<TT> AT END</TT> statement or block is by-passed if no end-of-file occurs.
&nbsp;It is not valid to use this control statement with direct-access or internal files.&nbsp; It is not valid to use this
statement when<TT> END=</TT> is also specified in the<TT> READ</TT> statement.&nbsp; The<TT> AT END</TT> statement or block
must immediately follow the<TT> READ</TT> statement to which it applies.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ( UNIT=1, FMT='(I5,F10.4)' ) I, X</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AT END DO</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'END-OF-FILE ENCOUNTERED
ON UNIT 1'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EOFSW = .TRUE.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END AT END</TT>
<BR><BR>The second form of the<TT> AT END</TT> statement is illustrated below.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ( UNIT=1, FMT='(F10.4)' ) X</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AT END, EOFSW = .TRUE.</TT>
<BR><BR>For more information, see the chapter entitled <A HREF="#Program_Structure_Control_Statements">Program Structure Control Statements</A>.
<H2 ID="BACKSPACE_Statement"> BACKSPACE Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BACKSPACE u</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BACKSPACE (alist)</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;<TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>u
<DD>is an external unit identifier.
<DT>alist
<DD>is a list of backspace specifiers separated by commas:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [UNIT =] u</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; IOSTAT = ios</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ERR = s</TT>
</DL>
<BR>Execution of a<TT> BACKSPACE</TT> statement causes the file connected to the specified unit to be positioned at the beginning
of the preceding record.&nbsp; If the preceding record is an endfile record then the file is positioned at the beginning of
the endfile record.
<DL>
<DT>Backspace Specifiers
<DD>
<DT>[UNIT =] u
<DD>
<BR><BR><TT>u</TT> is an<B> external unit identifier.</B>&nbsp; An external unit identifier is a non-negative integer expression.
&nbsp;If the optional<TT> UNIT=</TT> specifier is omitted then the specifier must be the first item in the list of specifiers.
<DT>IOSTAT = ios
<DD>
<BR><BR>is an<B> input/output status specifier.</B>&nbsp; The integer variable or integer array element<TT> ios</TT> is defined
with zero if no error condition occurs or a positive integer value if an error condition occurs.
<DT>ERR = s
<DD>
<BR><BR>is an<B> error specifier</B> and<TT> s</TT> is a statement label.&nbsp; When an error occurs, execution is transferred
to the statement labelled by<TT> s.</TT>
</DL>
<BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOOP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ( UNIT=8, END=100, FMT=200
) RECORD</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDLOOP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 100&nbsp;&nbsp; BACKSPACE( UNIT=8 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WRITE( UNIT=8, FMT=200 ) NEWREC</TT>
<BR><BR>In the previous example, we illustrate how one might append a record to the end of an existing file.
<BR><BR><B>Notes:</B>
<OL>
<LI>The unit must be connected for sequential access.
<LI>If the file is positioned before the first record then the<TT> BACKSPACE</TT> statement has no effect.
<LI>It is illegal to backspace a file that does not exist.
</OL>
<BR>The FORTRAN 77 standard specifies that it is illegal to backspace over records that were written using list-directed formatting;
Open Watcom FORTRAN 77 allows it.
<BR><BR>If the file has been opened with access<TT> 'APPEND',</TT> which is a form of sequential access in which the file
is positioned at the endfile record, then the<TT> BACKSPACE</TT> statement cannot be used.
<BR><BR>For more information on input/output, see the chapter entitled <A HREF="#InputDOutput">Input/Output</A>.
<H2 ID="BLOCK_DATA_Statement"> BLOCK DATA Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BLOCK DATA [sub]</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>sub
<DD>is an optional symbolic name of the block data subprogram and must not be the name of an external procedure, main program,
common block, other block data subprogram, or any local name in the block data subprogram.
</DL>
<BR>The<TT> BLOCK DATA</TT> statement is used to define the start of a block data subprogram.&nbsp; A block data subprogram
is used to provide initial values for variables and array elements in<B> named common blocks.</B>&nbsp; 
<BR><BR>The only statements which are allowed to appear in a block data subprogram are:
<OL>
<LI><TT> IMPLICIT</TT>
<LI><TT> PARAMETER</TT>
<LI><TT> DIMENSION</TT>
<LI><TT> COMMON</TT>
<LI><TT> SAVE</TT>
<LI><TT> EQUIVALENCE</TT>
<LI><TT> DATA</TT>
<LI><TT> STRUCTURE, END STRUCTURE</TT>
<LI><TT> UNION, END UNION</TT>
<LI><TT> MAP, END MAP</TT>
<LI><TT> RECORD</TT>
<LI><TT> END</TT>
<LI>type statements
</OL>
<BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BLOCK DATA INITCB</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DIMENSION A(10), B(10)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; COMMON /CB/ A, B</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DATA A/10*1.0/, B/10*2.0/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>In the above example, the arrays<TT> A</TT> and<TT> B</TT> in the named common block<TT> CB</TT> are initialized.
<BR><BR><B>Notes:</B>
<OL>
<LI>More than one named common block may appear in a block data subprogram.
<LI>All entities of the named common block(s) must be specified.
<LI>Not all entities need be given initial values.
<LI>Only entities that appear in (or are associated, through the<TT> EQUIVALENCE</TT> statement, with entries in) a named
common block may be given initial values.
<LI>Only one unnamed block data subprogram may occur in an executable program.
<LI>A named block data subprogram may occur only once in an executable program.
</OL>
<H2 ID="CALL_Statement"> CALL Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALL sub [( [a [, a] ... ] )]</TT></TT>&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>sub
<DD>is a symbolic name of a subroutine and must not be the name of a main program, function, common block, or block data subprogram.
&nbsp;As an extension to FORTRAN 77, Open Watcom FORTRAN 77 permits the calling of functions.
<DT>a
<DD>is an actual argument.
</DL>
<BR>The<TT> CALL</TT> statement is used to invoke the execution of a subroutine subprogram or function.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X = 1.0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Y = 1.1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Z = 1.2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALL QUAD( X, Y, Z )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SUBROUTINE QUAD( ARGA, ARGB, ARGC )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REAL ARGA, ARGB, ARGC</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 2.0*ARGA**2 + 4.0*ARGB + ARGC</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>In the above example, the variables<TT> X, Y</TT> and<TT> Z</TT> are passed to the subroutine<TT> QUAD.</TT>&nbsp;
This subroutine computes an expression and prints the result.
<BR><BR><B>Notes:</B>
<OL>
<LI>The parameters in the<TT> CALL</TT> statement are called<B> actual arguments.</B>&nbsp; 
<LI>The parameters in the<TT> SUBROUTINE</TT> statement are called<B> dummy arguments.</B>&nbsp; 
<LI>The actual arguments in a subroutine or function reference must agree in order, number and type with the corresponding
dummy arguments.
<LI>An actual argument may be an expression, array name, intrinsic function name, external procedure name (i.e., a subroutine
or function name), a dummy procedure name (i.e., one that was an argument to the calling subroutine or function), or an<B>
alternate return specifier</B> (subroutines only).&nbsp; An alternate return specifier takes the form<TT> *s,</TT> where<TT>
s</TT> is the statement label of an executable statement that appears in the same program unit as the<TT> CALL</TT> statement.
&nbsp;An expression may not be a character expression involving the concatenation of an operand whose length specification
is<TT> (*)</TT> unless the operand is the symbolic name of a constant.
<LI>Actual arguments are associated with dummy arguments by passing the address of the actual arguments.
<BR><BR>It is important to note that versions of FORTRAN compilers that implement the previous FORTRAN language standard may
have associated arguments by passing the value of the actual argument and assigning it to the dummy argument and then updating
the actual argument upon return from the subprogram (this is called &quot;value-result&quot; argument handling).&nbsp; The
FORTRAN 77 language standard prohibits this technique for handling argument association.
<BR><BR>The following example illustrates the importance of this rule.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I=1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALL ASSOC( I, I )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SUBROUTINE ASSOC( M, N )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; M = M + 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, M, N</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>In the above example,<TT> M</TT> and<TT> N</TT> refer to the same variable; they are both associated to<TT> I</TT>
in the calling subprogram.&nbsp; The value 2 will be printed twice.
</OL>
<BR>For more information, see the chapter entitled <A HREF="#Functions_and_Subroutines">Functions and Subroutines</A>.
<H2 ID="CASE_Statement"> CASE Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CASE cl</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>cl
<DD>is a list, enclosed in parentheses, of one or more<B> cases</B> separated by commas, or the<TT> DEFAULT</TT> keyword.&nbsp;
A<B> case</B> is either
<DL>
<DT>(a)
<DD>a single integer, logical or character constant expression or
<DT>(b)
<DD>an integer, logical or character constant expression followed by a colon followed by another expression or the same type.
&nbsp;This form of a case defines a range of values consisting of all integers or characters greater than or equal to the
value of the expression preceding the colon and less than or equal to the value of the expression following the colon.
</DL>
</DL>
<BR>The<TT> CASE</TT> statement is used in conjunction with the<TT> SELECT</TT> statement.&nbsp; The<TT> CASE</TT> statement
marks the start of a new<TT> CASE</TT> block which is a series of zero or more statements ending in another<TT> CASE</TT>
statement, a<TT> CASE DEFAULT</TT> statement, or an<TT> END SELECT</TT> statement.
<BR><BR>A particular case value or range of values must not be contained in more than one<TT> CASE</TT> block.
<BR><BR>The<TT> CASE DEFAULT</TT> statement is used to indicate a block of statements that are to be executed when no other
case is selected.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SELECT CASE ( CH )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CASE ( 'a' : 'z' )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'Lower case letter'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CASE ( 'A' : 'Z' )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'Upper case letter'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CASE ( '0' : '9' )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'Digit'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CASE DEFAULT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'Special character'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END SELECT</TT>
<BR><BR>In order to retain compatibility with earlier versions of WATCOM FORTRAN 77 compilers, the<TT> OTHERWISE</TT> statement
may be used in place of the<TT> CASE DEFAULT</TT> statement.
<BR><BR>For more information, see the chapter entitled <A HREF="#Program_Structure_Control_Statements">Program Structure Control Statements</A>.
<H2 ID="CHARACTER_Statement"> CHARACTER Statement </H2>
<BR>The<TT> CHARACTER</TT> statement is a type declaration statement and can be used to declare a name to be of type character.
&nbsp;The implicit type of the name, whether defined by the &quot;first letter rule&quot; (see the chapter entitled <A HREF="#Names__Data_Types_and_Constants">Names, Data Types and Constants</A>)
or by an<TT> IMPLICIT</TT> statement, is either confirmed or overridden.&nbsp; However, once a name has been declared to be
of type character, it cannot appear in another type declaration statement.
<BR><BR>There are various forms of the<TT> CHARACTER</TT> statement.&nbsp; The following sections describe them.
<H3 ID="Standard_CHARACTER_Statement"> Standard CHARACTER Statement </H3>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER[*len [,]] name [,name] ...</TT></TT>&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>name
<DD>is one of the following forms:
<BR><BR><TT>v[*len]</TT>
<BR><BR><TT>a(d)[*len]</TT>
<BR><BR><TT>a[*len](d)</TT>
<DT>v
<DD>is a variable name, symbolic name of a constant, function name or dummy procedure name.
<DT>a
<DD>is an array name.
<DT>(d)
<DD>is that part of the array declarator defining the dimensions of the array.
<DT>len
<DD>is called the<B> length specification</B> and is the length (number of characters) of a character variable, character array
element, symbolic character constant or character function.&nbsp; It has one of the following forms:
<DL>
<DT>(1)
<DD>An unsigned positive integer constant.
<DT>(2)
<DD>A positive integer constant expression enclosed in parentheses.
<DT>(3)
<DD>An asterisk in parentheses<TT> (*).</TT>
</DL>
</DL>
<BR>The length specification immediately following the word<TT> CHARACTER</TT> is the length specification for each entity
in the statement not having its own length specification.&nbsp; If omitted, the default is 1.&nbsp; An entity with its own
length specification overrides the default length specification or the length specification immediately following the word<TT>
CHARACTER.</TT>&nbsp; Note that for an array the length specification applies to<B> each</B> element of the array.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DIMENSION C(-5:5)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER A, B*10(10), C*20</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*7 X, Y, Z*4</TT>
<BR><BR>The<TT> (*)</TT> length specification is only allowed for external functions, dummy arguments or symbolic character
constants.&nbsp; If a dummy argument has a length specification of<TT> (*),</TT> it assumes the length of the corresponding
actual argument.&nbsp; If the actual argument is an array name, the length assumed by the dummy argument is the length of
an array element of the actual array.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SUBROUTINE OUTCHR( STR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER STR*(*)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, STR</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>In this example,<TT> STR</TT> is a character variable whose length is the length of the actual argument.&nbsp; Thus<TT>
OUTCHR</TT> can be called with a character entity of any length.
<BR><BR>If an external function has a length specification of<TT> (*)</TT> declared in a function subprogram, the function
name must appear as the name of a function in a<TT> FUNCTION</TT> or<TT> ENTRY</TT> statement in the same subprogram.&nbsp;
When the function is called, the function assumes the length specified in the program unit that called it.&nbsp; In the following
example, when<TT> F</TT> is called its length is assumed to be 10.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*(10) F</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, F()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*(*) FUNCTION F</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; F = 'HELLO'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>The following example is illegal since<TT> F</TT> does not appear in a<TT> FUNCTION</TT> or<TT> ENTRY</TT> statement.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Illegal definition of function F.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*(*) F</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, F()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>The length specified for a character function in the program unit that referenced it must agree with the length specified
in the subprogram that defines the character function.&nbsp; Note that there is always agreement if the function is defined
to have a length specification of<TT> (*).</TT>
<BR><BR>If a symbolic name is of type character and has a length specification of<TT> (*),</TT> it assumes the length of the
corresponding character constant expression in the<TT> PARAMETER</TT> statement.
<BR><BR>The length specification of a character statement function or statement function dummy argument must not be<TT> (*).</TT>
<H3 ID="Extended_CHARACTER_Statement__Data_Initialization"> Extended CHARACTER Statement:&nbsp; Data Initialization </H3>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER[*len[,]] name [/cl/] [,name[/cl/]] ...</TT></TT>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>name
<DD>is as described in the previous section.
<DT>len
<DD>is as described in the previous section.
<DT>cl
<DD>is a list of the form:
<BR><BR><TT>k [,k] ...</TT>
<DT>k
<DD>is one of the forms:
<BR><BR><TT>c</TT>
<BR><BR><TT>r*c</TT> (equivalent to<TT> r</TT> successive appearances of<TT> c)</TT>
<DT>c
<DD>is a constant or the symbolic name of a constant
<DT>r
<DD>is an unsigned positive integer constant or the symbolic name of a constant.
</DL>
<BR>This form of the<TT> CHARACTER</TT> statement is an extension to the FORTRAN 77 language.&nbsp; The rules for data initialization
are the same as for the<TT> DATA</TT> statement.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*5 A/'AAAAA'/, B*3(10)/10*'111'/</TT>
<BR><BR>In the previous example,<TT> A</TT> is initialized with the character constant<TT> 'AAAAA'</TT> and each element of
the array<TT> B</TT> is initialized with the character constant<TT> '111'.</TT>
<H2 ID="CLOSE_Statement"> CLOSE Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CLOSE (cllist)</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>cllist
<DD>is a list of close specifiers separated by commas:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [UNIT =] u</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; IOSTAT = ios</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ERR = s</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; STATUS = sta</TT>
</DL>
<BR>A<TT> CLOSE</TT> statement is used to terminate the connection of a file to the specified unit.
<DL>
<DT>Close Specifiers
<DD>
<DT>[UNIT =] u
<DD>
<BR><BR><TT>u</TT> is an<B> external unit identifier.</B>&nbsp; An external unit identifier is a non-negative integer expression.
&nbsp;If the optional<TT> UNIT=</TT> specifier is omitted then the specifier must be the first item in the list of specifiers.
<DT>IOSTAT = ios
<DD>
<BR><BR>is an input/output status specifier.&nbsp; The integer variable or integer array element<TT> ios</TT> is defined with
zero if no error condition occurs or a positive integer value if an error condition occurs.
<DT>ERR = s
<DD>
<BR><BR>is an error specifier and<TT> s</TT> is a statement label.&nbsp; When an error occurs, execution is transferred to
the statement labelled by<TT> s.</TT>
<DT>STATUS = sta
<DD>
<BR><BR>is a status specifier and<TT> sta</TT> is a character expression whose value when trailing blanks are removed evaluates
to one of<TT> 'KEEP'</TT> or<TT> 'DELETE'.</TT>
<DL>
<DT>KEEP
<DD><TT> 'KEEP'</TT> may not be specified for a file whose status is<TT> 'SCRATCH'</TT> (see description of the<TT> OPEN</TT>
statement).&nbsp; If the file exists, it will exist after execution of the<TT> CLOSE</TT> statement.&nbsp; If the file does
not exist, it will not exist after execution of the<TT> CLOSE</TT> statement.&nbsp; If not specified,<TT> 'KEEP'</TT> is assumed,
unless the file status is<TT> 'SCRATCH'</TT> in which case<TT> 'DELETE'</TT> is assumed.
<DT>DELETE
<DD>If<TT> 'DELETE'</TT> is specified, the file will not exist after execution of the<TT> CLOSE</TT> statement.
</DL>
</DL>
<BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOOP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ( UNIT=8, END=100, FMT=200
) RECORD</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDLOOP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 100&nbsp;&nbsp; CLOSE( UNIT=8 )</TT>
<BR><BR>In the previous example, we illustrate how one might process the records in a file and then terminate the connection
of the file to unit 8 using the<TT> CLOSE</TT> statement.
<BR><BR><B>Notes:</B>
<OL>
<LI>Execution of a<TT> CLOSE</TT> statement specifying a unit that is not connected to a file or a unit that is connected
to a file that does not exist has no effect.
<LI>It is possible to connect the unit to another file after a<TT> CLOSE</TT> statement has been executed.
<LI>It is possible to connect the unit to the same file after a<TT> CLOSE</TT> statement has been executed, provided that
the file still exists.
<LI>It is possible to connect the file to another unit after a<TT> CLOSE</TT> statement has been executed, provided that the
file still exists.
<LI>At the termination of execution of the program, for whatever the reason of termination, any units that are connected are
closed.&nbsp; Each unit is closed with status<TT> 'KEEP'</TT> unless the file status was<TT> 'SCRATCH',</TT> in which case
the unit is closed with status<TT> 'DELETE'.</TT>&nbsp; The effect is the same as if a<TT> CLOSE</TT> statement is executed
without a<TT> STATUS=</TT> specifier.
</OL>
<BR>For more information on input/output, see the chapter entitled <A HREF="#InputDOutput">Input/Output</A>.
<H2 ID="COMMON_Statement"> COMMON Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; COMMON [/[cb]/] nlist [[,]/[cb]/ nlist] ...</TT></TT>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>cb
<DD>is a common block name.
<DT>nlist
<DD>is a list of names each separated by a comma.
</DL>
<BR>If<TT> cb</TT> is omitted, the<B> blank common block</B> is assumed.&nbsp; If specified,<TT> cb</TT> is called a<B> named
common block.</B>&nbsp; The names appearing in<TT> nlist</TT> can be variable names, array names, and array declarators.&nbsp;
Dummy arguments are not allowed in<TT> nlist.</TT>
<BR><BR>The<TT> COMMON</TT> statement allows sharing of blocks of storage between subprograms.&nbsp; Each name appearing in
the<TT> nlist</TT> following a common block name<TT> cb</TT> is declared to belong to that common block.&nbsp; A variable
or an array name can belong to only one common block.&nbsp; A common block name can occur more than once in the same<TT> COMMON</TT>
statement as well as in more than one<TT> COMMON</TT> statement.&nbsp; Lists following successive appearances of the same
common block name in<TT> COMMON</TT> statements are considered a continuation of the list of names belonging to the common
block.&nbsp; A variable or an array can appear in a<TT> COMMON</TT> statement only once.
<BR><BR>Common blocks are defined as follows.&nbsp; A common block is one consecutive block of storage.&nbsp; It consists
of all the storage sequences of all the entities specified in all the lists declared to belong to that common block.&nbsp;
The order in which each entity appears in a common block is defined by the order in which they appear in the lists.&nbsp;
Storage sequences associated to a common block through the<TT> EQUIVALENCE</TT> statement are considered to belong to that
common block.&nbsp; In this way a common block may only be extended beyond the last storage unit.&nbsp; The size of a common
block is the sum of all the storage sequences of all the names belonging to that common block plus any storage sequence which
extends the common block through equivalence association.
<BR><BR>An<TT> EQUIVALENCE</TT> statement must not cause storage sequences of two different common blocks to become associated
nor should they extend the common block by adding storage units preceding the first storage unit of the common block.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DIMENSION A(5)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; COMMON /COMBLK/ A,B(10),C</TT>
<BR><BR>In this example, the common block<TT> COMBLK</TT> contains the array<TT> A</TT> followed by the array<TT> B</TT> and
finally the variable<TT> C.</TT>
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REAL A,B,C,D</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DIMENSION D(5)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EQUIVALENCE (B,D)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; COMMON A,B,C</TT>
<BR><BR>In this example,<TT> A, B, C,</TT> and<TT> D</TT> belong to the blank common block;<TT> A, B,</TT> and<TT> C</TT>
have been explicitly defined to be in the blank common block whereas<TT> D</TT> has been equivalenced to a variable in common,
namely<TT> B.</TT>&nbsp; Also note that the<TT> EQUIVALENCE</TT> statement has caused the extension of the common block beyond
its last storage unit.&nbsp; In this example, array<TT> D</TT> has extended the common block by 3 storage units.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Illegal definition of a common block.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DIMENSION A(5)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EQUIVALENCE (A(2),B)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; COMMON /XYZ/ B</TT>
<BR><BR>This example demonstrates an illegal use of the<TT> COMMON</TT> statement.<TT>&nbsp; B</TT> is in the named common
block<TT> XYZ</TT> since it appeared in a<TT> COMMON</TT> statement.<TT>&nbsp; A</TT> is in the common block<TT> XYZ</TT>
since it was equivalenced to<TT> B.</TT>&nbsp; However,<TT> A</TT> illegally extends the common block by adding 1 storage
unit before the first storage unit of the common block.
<BR><BR>The following outlines the differences between a blank common block and a named common block.
<DL>
<DT>(1)
<DD>All named common blocks with the same name in an executable program must be the same size.&nbsp; Blank common blocks do not
have to be the same size.
<DT>(2)
<DD>Entities in named common blocks can be initialized by using<TT> DATA</TT> statements in block data subprograms; entities in
blank common blocks cannot.
<DT>(3)
<DD>Entities in named common blocks can become undefined after the execution of a<TT> RETURN</TT> or<TT> END</TT> statement; entities
in blank common blocks cannot.&nbsp; This situation can arise when all subprograms which refer to the named common block become
inactive.&nbsp; A typical case occurs when program overlays are used.&nbsp; If the named common block is placed in an overlay,
then the entities in the named common block will become undefined when the overlay is replaced by another.&nbsp; Of course,
if the named common block is referenced in the main program then this could never happen.&nbsp; The main program and any named
common blocks referenced in the main program remain memory-resident until the application terminates.
<BR><BR>The<TT> SAVE</TT> statement should be used if entities in named common blocks must not become undefined.
</DL>
<BR>The FORTRAN 77 standard specifies that a common block cannot contain both numeric and character data; Open Watcom FORTRAN
77 allows common blocks to contain both numeric and character data.
<BR><BR>The FORTRAN 77 standard specifies that a named common block must be initialized in a block data subprogram.&nbsp;
Open Watcom FORTRAN 77 permits the initialization of named common blocks in other subprograms.
<H2 ID="COMPLEX_Statement"> COMPLEX Statement </H2>
<BR>The<TT> COMPLEX</TT> statement is a type declaration statement and can be used to declare a name to be of type complex.
&nbsp;The implicit type of the name, whether defined by the &quot;first letter rule&quot; (see the chapter entitled <A HREF="#Names__Data_Types_and_Constants">Names, Data Types and Constants</A>)
or by an<TT> IMPLICIT</TT> statement, is either confirmed or overridden.&nbsp; However, once a name has been declared to be
of type complex, it cannot appear in another type declaration statement.
<BR><BR>There are various forms of the<TT> COMPLEX</TT> statement.&nbsp; The following sections describe them.
<H3 ID="Standard_COMPLEX_Statement"> Standard COMPLEX Statement </H3>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; COMPLEX name [,name] ...</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>name
<DD>is a variable name, array name, array declarator, symbolic name of a constant, function name or dummy procedure name.
</DL>
<BR>This form is the standard form of the<TT> COMPLEX</TT> statement.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DIMENSION C(-5:5)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; COMPLEX A, B(10), C</TT>
<BR><BR>In the previous example,<TT> A</TT> is defined to be a variable of type complex and<TT> B</TT> and<TT> C</TT> are
defined to be arrays of type complex.
<H3 ID="Extended_COMPLEX_Statement__Length_Specification"> Extended COMPLEX Statement:&nbsp; Length Specification </H3>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; COMPLEX[*len[,]] name [,name] ...</TT></TT>&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>name
<DD>is one of the following forms:
<BR><BR><TT>v[*len]</TT>
<BR><BR><TT>a[*len](d)</TT>
<BR><BR><TT>a(d)[*len]</TT>
<DT>v
<DD>is a variable name, array name, symbolic name of a constant, function name or dummy procedure name.
<DT>a
<DD>is an array name.
<DT>(d)
<DD>is that part of the array declarator defining the dimensions of the array.
<DT>len
<DD>is called the<B> length specification</B> and is an unsigned positive integer constant or an integer constant expression enclosed
in parentheses whose value is 8 or 16.
</DL>
<BR>This form of the<TT> COMPLEX</TT> statement is a Open Watcom FORTRAN 77 extension to the FORTRAN 77 language.&nbsp; The
length specification specifies the number of bytes of storage that will be allocated for the name appearing in the<TT> COMPLEX</TT>
statement.&nbsp; The default length specification is 8.&nbsp; A length specification of 16 specifies that the data type of
the name appearing in the<TT> COMPLEX</TT> statement is to be double precision complex.
<BR><BR>The length specification immediately following the word<TT> COMPLEX</TT> is the length specification for each entity
in the statement not having its own length specification.&nbsp; If a length specification is not specified the default length
specification is used.&nbsp; An entity with its own specification overrides the default length specification or the length
specification immediately following the word<TT> COMPLEX.</TT>&nbsp; Note that for an array the length specification applies
to<B> each</B> element of the array.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DIMENSION C(-5:5)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; COMPLEX A, B*16(10), C*16</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; COMPLEX*16 X</TT>
<BR><BR>In the previous example,<TT> X</TT> is declared to be a variable of type double precision complex,<TT> A</TT> is declared
to be a variable of type complex and<TT> B</TT> and<TT> C</TT> are declared to be arrays of type double precision complex.
<H3 ID="Extended_COMPLEX_Statement__Data_Initialization"> Extended COMPLEX Statement:&nbsp; Data Initialization </H3>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; COMPLEX[*len[,]] name [/cl/] [,name[/cl/]] ...</TT></TT>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>name
<DD>is as described in the previous section.
<DT>len
<DD>is as described in the previous section.
<DT>cl
<DD>is a list of the form:
<BR><BR><TT>k [,k] ...</TT>
<DT>k
<DD>is one of the forms:
<BR><BR><TT>c</TT>
<BR><BR><TT>r*c</TT> (equivalent to<TT> r</TT> successive appearances of<TT> c)</TT>
<DT>c
<DD>is a constant or the symbolic name of a constant
<DT>r
<DD>is an unsigned positive integer constant or the symbolic name of a constant.
</DL>
<BR>This form of the<TT> COMPLEX</TT> statement is an extension to the FORTRAN 77 language.&nbsp; The rules for data initialization
are the same as for the<TT> DATA</TT> statement.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; COMPLEX A/(.4,-.3)/, B(10)/10*(0,1)/</TT>
<BR><BR>In the previous example,<TT> A</TT> is initialized with the complex constant<TT> (.4,-.3)</TT> and each element of
the array<TT> B</TT> is initialized with the complex constant<TT> (0,1).</TT>
<H2 ID="CONTINUE_Statement"> CONTINUE Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONTINUE</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR>Execution of a<TT> CONTINUE</TT> statement has no effect.&nbsp; This statement is often used in conjunction with<TT> DO</TT>
statements.&nbsp; It is usually identified with a label.&nbsp; It often provides a convenient reference for statements which
have the ability to transfer control of execution.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO 10 X = -5.1, 12.8, 0.125</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 10&nbsp;&nbsp;&nbsp; CONTINUE</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( A .LT. B ) GO TO 20</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( A .GT. C ) GO TO 20</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 20&nbsp;&nbsp;&nbsp; CONTINUE</TT>
<H2 ID="CYCLE_Statement"> CYCLE Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CYCLE&nbsp;&nbsp; [: block-label]</TT></TT>&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR>The<TT> CYCLE</TT> statement may be used to cause a transfer of control from within a loop to the terminal statement of
a corresponding<TT> DO</TT>,<TT> DO WHILE</TT>,<TT> WHILE</TT> or<TT> LOOP</TT> statement.&nbsp; If<TT> block-label</TT> is
present then control is transferred to the terminal statement of the block identified by that block label.&nbsp; The<TT> CYCLE</TT>
statement is an extension to the FORTRAN 77 language.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOOP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WRITE( UNIT=*, FMT='(A)' ) 'Enter
a number'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ( UNIT=*, FMT='(F10.4)',
IOSTAT=IOS ) X</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( IOS .NE. 0 ) CYCLE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( X .LT. 0 ) EXIT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, X, SQRT( X )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END LOOP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>For more information, see the chapter entitled <A HREF="#Program_Structure_Control_Statements">Program Structure Control Statements</A>.
<H2 ID="DATA_Statement"> DATA Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DATA nlist/clist/ [[,]nlist/clist/] ...</TT></TT>&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>nlist
<DD>is a list of variable names, array element names, substring names and implied-DO lists.
<DT>clist
<DD>is a list of the form:
<BR><BR><TT>a [,a] ...</TT>
<DT>a
<DD>is one of the forms:
<BR><BR><TT>c</TT>
<BR><BR><TT>r*c</TT> (equivalent to<TT> r</TT> successive appearances of<TT> c)</TT>
<DT>c
<DD>is a constant or the symbolic name of a constant
<DT>r
<DD>is an unsigned positive integer constant or the symbolic name of a constant.
</DL>
<BR>The items of<TT> nlist</TT> are initialized with the values specified in<TT> clist</TT> in the following manner.&nbsp;
The first item in<TT> nlist</TT> is assigned the value of the first item in<TT> clist,</TT> the second item in<TT> nlist</TT>
is assigned the value of the second item in<TT> clist,</TT> etc.&nbsp; In this way all items of<TT> nlist</TT> are initialized.
<BR><BR>The number of items in<TT> nlist</TT> must equal the number of items in<TT> clist</TT> so that a one-to-one correspondence
exists between the two lists.&nbsp; If an array without a subscript list appears in<TT> nlist</TT> there must be an element
in<TT> clist</TT> for each element of the array.
<BR><BR>If the type of an entity in<TT> nlist</TT> is character or logical then the type of its corresponding item in<TT>
clist</TT> must also be character or logical respectively.&nbsp; As an extension to FORTRAN 77, Open Watcom FORTRAN 77 permits
an item of type character to be initialized with integer data.
<BR><BR>An item of type character is initialized using the rules of assignment.&nbsp; If the length of the item in<TT> nlist</TT>
is greater than the length of the corresponding character constant in<TT> clist,</TT> the rightmost remaining characters in
the item are initialized with blanks.&nbsp; If the length of the item in<TT> nlist</TT> is less than the length of the character
constant in<TT> clist,</TT> the character constant is truncated to the length of the item in<TT> nlist.</TT>&nbsp; Note that
initializing a character entity causes all of the characters in the entity to become defined and that each character constant
defines exactly one character variable, array element or substring.
<BR><BR>If the type of an entity in<TT> nlist</TT> is integer, real, double precision or complex then the corresponding item
in<TT> clist</TT> can be one of integer, real, double precision or complex.&nbsp; If necessary the constant in<TT> clist</TT>
is converted to the type of the item in<TT> nlist</TT> according to the rules of arithmetic conversion (see the chapter entitled
<A HREF="#Assignment_Statements">Assignment Statements</A>).
<BR><BR>A variable, array element or substring can only be initialized once.&nbsp; If two entities are associated (for example
equivalenced), only one of the items can be initialized.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*30 MSG</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOGICAL TRUE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REAL X, Y(10)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DATA X/1.0/, TRUE/.TRUE./, MSG/'ENTER DATA'/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DATA Y/10*5/</TT>
<BR><BR>An<B> implied-DO list</B> in a<TT> DATA</TT> statement has the following form:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ( dlist, i = m1, m2[, m3] )</TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>dlist
<DD>is a list of array element names and implied-DO lists.
<DT>i
<DD>is the name of an integer variable called the implied-DO-variable.
<DT>m1,m2,m3
<DD>are each integer constant expressions.&nbsp; The expressions may contain implied-DO-variables of other implied-DO lists that
have this implied-DO list in their ranges.
</DL>
<BR>The range of the implied-DO list is the list<TT> dlist.</TT>&nbsp; An iteration count and the value of the implied-DO-variable
are computed from<TT> m1,m2</TT> and<TT> m3</TT> in the same way as for a DO-loop except that the iteration count must be
positive.&nbsp; An implied-DO-variable does not affect the definition of a variable by the same name in the same program unit.
&nbsp;An implied-DO list is processed as follows.&nbsp; Each item in the implied-DO list is processed once for each iteration
with the appropriate substitution of values for any occurrence of the implied-DO-variable.&nbsp; The following example initializes
the upper right triangle of the array A.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DIMENSION A(5,5)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DATA ((A(I,J),J=1,I),I=1,5)/15*0/</TT>
<BR><BR>Dummy arguments, functions, and entities in blank common are not allowed in<TT> nlist.</TT>&nbsp; Entities in a named
common block can be initialized only within a<B> block data subprogram.</B>&nbsp; 
<BR><BR>The following extensions to data initialization are supported by Open Watcom FORTRAN 77.
<OL>
<LI>Character constants can initialize a variable of any type.&nbsp; If the item in<TT> nlist</TT> is of numeric type and
is being initialized with character data, the size of the item in<TT> nlist</TT> is the maximum number of characters that
can be stored in the space allocated for that item.&nbsp; The rules for initializing such items, are the same as for items
of type character.&nbsp; See the chapter entitled <A HREF="#Names__Data_Types_and_Constants">Names, Data Types and Constants</A>
for the number of bytes required for a particular data type.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER I,J</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DATA I/'AA'/,J/'123456'/</TT>
<BR><BR>In the previous example,<TT> I</TT> and<TT> J</TT> each occupy 4 character storage units.<TT>&nbsp; I</TT> will be
initialized with the characters<TT> AA</TT> followed by 2 blank characters.<TT>&nbsp; J</TT> will be initialized with the
characters<TT> 1234.</TT>&nbsp; Note the the character constant initializing<TT> J</TT> is truncated on the right to the number
of character storage units occupied by<TT> J.</TT>
<LI>As an extension to FORTRAN 77, Open Watcom FORTRAN 77 permits an item of type character to be initialized with integer
data.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER C, D</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DATA C/65/, D/66/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<LI>Open Watcom FORTRAN 77 allows data initialization using hollerith constants.&nbsp; Initializing items using hollerith
constants behaves in the same way as initializing items using character constants.&nbsp; Note that hollerith data can initialize
entities of any type.&nbsp; See the chapter entitled <A HREF="#Names__Data_Types_and_Constants">Names, Data Types and Constants</A>
for a description of hollerith constants.
<LI>Open Watcom FORTRAN 77 allows data initialization using hexadecimal or octal constants.&nbsp; Hexadecimal or octal constants
can be used to initialize memory with any binary pattern.
<BR><BR>Items are initialized with hexadecimal constants in the following way.&nbsp; Two hexadecimal digits are required to
initialize one byte of storage.&nbsp; If the number of characters in the hexadecimal constant is less than 2 times the number
of bytes of storage allocated for the entity being initialized, the entity is padded on the left with zeroes.&nbsp; If the
number of characters in the hexadecimal constant is greater than 2 times the number of bytes of storage allocated for the
entity being initialized, the constant is truncated on the left to the size (in bytes) of the entity being initialized.
<BR><BR>Items are initialized with octal constants in the following way.&nbsp; Each octal digit initializes three bits of
storage.&nbsp; If the number of digits in the octal constant times 3 is less than the number of bits of storage allocated
for the entity being initialized, the entity is padded on the left with zero bits.&nbsp; If the number of digits in the octal
constant times 3 is greater than the number of bits of storage allocated for the entity being initialized, bits are truncated
on the left to the size (in bits) of the entity being initialized.
<BR><BR>Note that hexadecimal or octal data can initialize entities of any type.&nbsp; See the chapter entitled <A HREF="#Names__Data_Types_and_Constants">Names, Data Types and Constants</A>
for a description of hexadecimal and octal constants.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DOUBLE PRECISION DPREC</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; COMPLEX CMPLX</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Initialize an integer variable with the value 5</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DATA I/Z05/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Initialize a real variable with the value 5.0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DATA X/Z41500000/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Initialize a double precision variable</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp; with the value 5D0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DATA DPREC/Z4150000000000000/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Initialize a complex variable</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp; with the value (5.0,5.0)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DATA CMPLX/Z4150000041500000/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>Caution should be used when initializing items with hexadecimal constants, in particular those whose type is real
or double precision, since the data they represent depends on the computer being used.&nbsp; In the previous example, the
hexadecimal constant used to initialize the variable<TT> X,</TT> represents the number 5.0 on a computer with an IBM 370 architecture.
&nbsp;The number 5.0 will have a different floating-point representation on other computers.
</OL>
<H2 ID="DEALLOCATE_Statement"> DEALLOCATE Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DEALLOCATE (arraylist [, STAT = ierr])</TT></TT>&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>arraylist
<DD>is a list of allocatable array names separated by commas.
<DT>ierr
<DD>is an integer variable that returns the status of the attempted deallocation.
</DL>
<BR>Allocatable arrays may be dynamically allocated and deallocated at execution time.&nbsp; An array must have been declared
allocatable by specifying its dimensions using colons only.&nbsp; No array bounds are specified.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DIMENSION A(:), B(:,:)</TT>
<BR><BR>In the above example,<TT> A</TT> is declared to be a one-dimensional allocatable array and<TT> B</TT> is declared
to be a two-dimensional allocatable array.
<BR><BR>The<TT> DEALLOCATE</TT> statement frees up any memory allocated for the specified array(s).&nbsp; It then disassociates
the specified array(s) from the memory to which it was associated.&nbsp; The deallocation does not necessarily succeed.&nbsp;
For example, an attempt to deallocate an array that was not previously allocated will cause an error.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DIMENSION A(:), B(:,:)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ALLOCATE( A(N), B(0:4,5) )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DEALLOCATE( A )</TT>
<BR><BR>More than one allocatable array may appear in an<TT> DEALLOCATE</TT> statement, separated by commas.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DIMENSION A(:), B(:,:)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ALLOCATE( A(N), B(0:4,5) )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DEALLOCATE( A, B )</TT>
<BR><BR>If the deallocation fails and the<TT> STAT=</TT> specifier was not used, an execution-time error occurs.&nbsp; If
the<TT> STAT=</TT> specifier is used, the specified variable returns a zero value if the deallocation succeeded, and a non-zero
value if the deallocation failed.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DIMENSION A(:), B(:,:)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ALLOCATE( A(N), B(0:4,5), STAT=IALLOC )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( IALLOC .NE. 0 ) PRINT *, 'Allocation failure'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DEALLOCATE( A, B, STAT=IFREE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( IFREE .NE. 0 ) PRINT *, 'Deallocation failure'</TT>
<BR><BR>An attempt to deallocate an unallocated array results in an execution-time error.&nbsp; The array must be allocated
first (see the<TT> ALLOCATE</TT> statement).
<BR><BR>An array that was allocated using the<TT> LOCATION=</TT> specifier need not be deallocated.
<BR><BR>For more information on arrays, see the chapter entitled <A HREF="#Arrays">Arrays</A>.
<H2 ID="DIMENSION_Statement"> DIMENSION Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DIMENSION a(d) [,a(d)] ...</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>a
<DD>is the name of the array.
<DT>d
<DD>defines the dimension of the array and the range of its subscripts.&nbsp; See the chapter entitled <A HREF="#Arrays">Arrays</A>
for more information on dimensioning arrays.
</DL>
<BR>Each name<TT> a</TT> appearing in a<TT> DIMENSION</TT> statement defines<TT> a</TT> to be an array in the program unit
containing the<TT> DIMENSION</TT> statement.&nbsp; A name can only be dimensioned once in a program unit.&nbsp; Note that
a name can also be dimensioned in a<TT> COMMON</TT> statement and type declaration statements.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DIMENSION A(10), B(-5:5), C(I,J), D(4,*)</TT>
<BR><BR>In this example<TT> A</TT> is a 1-dimensional array containing 10 elements, each element referenced as<TT> A(1), A(2),
..., A(9), A(10).&nbsp; B</TT> is a 1-dimensional array containing 11 elements, each element referenced as<TT> B(-5), B(-4),
..., B(4), B(5).&nbsp; C</TT> is a 2-dimensional array containing<TT> I</TT> rows and<TT> J</TT> columns.<TT>&nbsp; C, I,</TT>
and<TT> J</TT> must be<B> dummy arguments</B> or belong to a common block.<TT>&nbsp; D</TT> is a 2-dimensional array containing
4 rows.&nbsp; The<TT> *</TT> in the last dimension indicates that<TT> D</TT> is an<B> assumed size array.</B>&nbsp; <TT> D</TT>
must be a<B> dummy argument.</B>&nbsp; The number of columns is determined from the number of elements of the<B> actual argument.</B>
&nbsp;For example, if the actual argument contains 8 elements then<TT> D</TT> would contain 2 columns (i.e., 8 elements /
4 rows).
<BR><BR>For more information on dimensioning arrays refer to the chapter entitled <A HREF="#Arrays">Arrays</A>.&nbsp; See
also the description of the<TT> ALLOCATE</TT> and<TT> DEALLOCATE</TT> statements for information on dynamically allocatable
arrays.
<H2 ID="DO_Statement"> DO Statement </H2>
<BR>Two forms of the<TT> DO</TT> statement are presented.&nbsp; The second form is a Open Watcom FORTRAN 77 extension to the
FORTRAN 77 language.
<H3 ID="Standard_DO_Statement"> Standard DO Statement </H3>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO s [,] i = e1, e2 [, e3]</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>s
<DD>is the statement label of an executable statement, called the<B> terminal statement,</B> which follows the<TT> DO</TT> statement
in the same program unit.
<DT>i
<DD>is an integer, real, or double precision variable, called the DO-variable.
<DT>e1, e2, e3
<DD>are each an integer, real, or double precision expression.
</DL>
<H3 ID="Extended_DO_Statement"> Extended DO Statement </H3>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO [s[,]] i = e1, e2 [, e3]&nbsp;&nbsp;&nbsp; [: block-label]</TT></TT>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>s
<DD>is an optional statement label of an executable statement, called the<B> terminal statement,</B> which follows the<TT> DO</TT>
statement in the same program unit.
<DT>i
<DD>is an integer, real, or double precision variable, called the DO-variable.
<DT>e1, e2, e3
<DD>are each an integer, real, or double precision expression.
<DT>block-label
<DD>is an optional block label.
</DL>
<BR>This form of the<TT> DO</TT> statement is an extension to the FORTRAN 77 language.&nbsp; If no statement label is present
then the terminal statement of the DO-loop must be an<TT> END DO</TT> statement.&nbsp; In all other respects, the rules are
the same as those given for the standard<TT> DO</TT> statement.
<H3 ID="Description_of_DO_Statement"> Description of DO Statement </H3>
<BR>The range of a DO-loop consists of all of the executable statements that appear following the<TT> DO</TT> statement that
specifies the DO-loop, up to and including the terminal statement of the DO-loop.&nbsp; Only certain statements can be the
terminal statement of a DO-loop.&nbsp; See the section entitled <A HREF="#Classifying_Statements">Classifying Statements</A>
at the beginning of this chapter for a list of these statements.
<BR><BR>Transfer of control into the range of a DO-loop from outside the range is not permitted.
<BR><BR>A DO-loop may be executed 0 or more times.&nbsp; The following sequence occurs when a<TT> DO</TT> statement is encountered.
<DL>
<DT>(i)
<DD>An<B> initial</B> value,<TT> m1,</TT> is calculated by evaluating expression<TT> e1.</TT>&nbsp; A<B> terminal</B> value,<TT>
m2,</TT> is calculated by evaluating expression<TT> e2.</TT>&nbsp; An<B> incrementation</B> value,<TT> m3,</TT> is calculated
by evaluating expression<TT> e3</TT> if it is present; otherwise<TT> m3</TT> has the value one.&nbsp; If<TT> e3</TT> is specified,<TT>
m3</TT> must not be zero.&nbsp; The type of<TT> m1, m2, and m3</TT> is determined from the DO-variable and any conversions
of type are done as required.
<DT>(ii)
<DD>The DO-variable is defined with the initial value<TT> m1.</TT>
<DT>(iii)
<DD>The iteration count (i.e., the maximum number of times that the DO-loop will be executed) is calculated as follows:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MAX( INT((m2 - m1 + m3)/m3), 0 )</TT>
<BR><BR>The iteration count will be zero whenever:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m1 &gt; m2 and m3 &gt; 0, or</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m1 &lt; m2 and m3 &lt; 0.</TT>
<BR><BR>The number of times that the DO-loop is executed may be reduced if control is transferred outside the range of the
DO-loop, or if a<TT> RETURN</TT> or<TT> STOP</TT> statement is executed.
</DL>
<BR>The steps involved in each iteration of the DO-loop are as follows:
<DL>
<DT>(i)
<DD>Check the iteration count.&nbsp; If it is not zero then start execution of the first executable statement of the DO-loop.
&nbsp;If the count is zero then iteration of the DO-loop is complete.
<DT>(ii)
<DD>Execute statements until the terminal statement is encountered.&nbsp; During this time, the DO-variable may not be redefined.
<DT>(iii)
<DD>Execute the terminal statement.&nbsp; Unless execution of the terminal statement causes a transfer of control, proceed with
the next step which is &quot;incrementation&quot; processing.
<DT>(iv)
<DD>The DO-variable is incremented by the value<TT> m3.</TT>&nbsp; The iteration count is decremented by one.&nbsp; Go back to
step (i).
</DL>
<BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO 10 I = -5, 5</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, I, I*I</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 10&nbsp;&nbsp;&nbsp; CONTINUE</TT>
<BR><BR>In this example, the initial value is -5, the terminal value is 5, and the incrementation value is 1 (the default).
&nbsp;The DO-variable is<TT> I.</TT>&nbsp; The DO-loop is executed
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MAX( INT((5 - (-5) + 1)/1), 0 )</TT>
<BR><BR>or 11 times.&nbsp; The successive values of<TT> I,</TT> inside the range of the DO-loop, are -5, -4, -3, ..., 0, 1,
..., 4, 5.&nbsp; When the DO-loop is terminated, the value of<TT> I</TT> will be 6.&nbsp; It should be noted that when a DO-loop
variable is of type real, the iteration count may be one less than expected.&nbsp; Because of rounding errors, the value of<TT>
m2 - m1 + m3</TT> may be slightly less than the exact value and when the INT function is applied, the resulting iteration
count is one less than expected.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO 10 X = -5, 6, 2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, X, X*X</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 10&nbsp;&nbsp;&nbsp; CONTINUE</TT>
<BR><BR>In this example, the terminal value has been changed to 6 and the incrementation value has been changed to 2.&nbsp;
The DO-variable is<TT> X,</TT> a real variable.&nbsp; Thus the values of<TT> e1, e2</TT> and<TT> e3</TT> are converted to
type real.&nbsp; The DO-loop is executed
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MAX( INT((6 - (-5) + 2)/2), 0 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MAX( INT(&nbsp;&nbsp;&nbsp; 13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /&nbsp;
2), 0 )</TT>
<BR><BR>or 6 times.&nbsp; The successive values of<TT> X,</TT> inside the range of the DO-loop, are -5.0, -3.0, -1.0, 1.0,
3.0, 5.0.&nbsp; When the DO-loop is terminated, the value of<TT> X</TT> will be 7.0.
<BR><BR>DO-loops may be nested, that is, another DO-loop may be contained within the range of the outer DO-loop.&nbsp; More
than one DO-loop may have the same terminal statement.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO 10 I = -5, 5</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO 10 J = -2, 3</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARRAY( I, J ) = 0.0</TT>
<BR><BR>This is equivalent to the following example.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO 10 I = -5, 5</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO 20 J = -2, 3</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARRAY(
I, J ) = 0.0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONTINUE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 10&nbsp;&nbsp;&nbsp; CONTINUE</TT>
<BR><BR>If a<TT> DO</TT> statement appears within the range of a DO-loop, its range must be entirely contained within the
range of the outer DO-loop.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Illegal use of nested DO-loops.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO 20 I = -5, 5</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO 10 J = -2, 3</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARRAY(
I, J ) = 0.0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONTINUE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 10&nbsp;&nbsp;&nbsp; CONTINUE</TT>
<BR><BR>The above example is illegal since the terminal statement of the first DO-loop precedes that of the second DO-loop.
<BR><BR>Similarly, the range of a DO-loop that appears within the range of an IF-block, ELSE IF-block, or ELSE-block must
be entirely contained within that IF-block, ELSE IF-block, or ELSE-block, respectively.&nbsp; This rule applies to all Open
Watcom FORTRAN 77 structured block extensions.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Illegal nesting of a DO-loop and an IF-block.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( A .LT. B )THEN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO 10 I = 1, 5</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT
*, 'Iteration number', I</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END IF</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECTOR(
I ) = I</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONTINUE</TT>
<BR><BR>The above example is illegal since the range of the IF-block must terminate after the range of the DO-loop.&nbsp;
Note how statement indentation helps to illustrate the problem with this example.
<BR><BR>It is also illegal to attempt to transfer control into the range of a DO-loop.&nbsp; The following example illustrates
this error.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Illegal transfer into the range of a DO-loop.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GO TO 20</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO 10, I = 100, 0, -1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'Counting down from
100 to 0', I</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, I, SQRT( FLOAT(I) )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 10&nbsp;&nbsp;&nbsp; CONTINUE</TT>
<BR><BR>The following example shows a more subtle form of this error.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Illegal transfer into the range of a DO-loop.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO 10 I = 1, 10</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Skip row 5 of 10x10 matrix</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( I .EQ. 5 )GO TO 10</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO 10 J = 1, 10</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A( I,
J ) = 0.0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 10&nbsp;&nbsp;&nbsp; CONTINUE</TT>
<BR><BR>Since the<TT> CONTINUE</TT> statement is included in the range of the inner DO-loop, an error message is issued.
<BR><BR>The following example illustrates the Open Watcom FORTRAN 77 structured<TT> DO</TT> statement.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO I = -5, 5</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO J = -2, 3</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARRAY(
I, J ) = 0.0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END DO</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END DO</TT>
<BR><BR>In keeping with more modern programming practices, this feature allows the programmer to write DO-loops without resorting
to the use of statement labels.&nbsp; A well-chosen indentation style further enhances the readability of the program.
<BR><BR>For more information, see the chapter entitled <A HREF="#Program_Structure_Control_Statements">Program Structure Control Statements</A>.
<H2 ID="DOUBLE_COMPLEX_Statement"> DOUBLE COMPLEX Statement </H2>
<BR>The<TT> DOUBLE COMPLEX</TT> statement is a type declaration statement and can be used to declare a name to be of type
double complex.&nbsp; The implicit type of the name, whether defined by the &quot;first letter rule&quot; (see the chapter
entitled <A HREF="#Names__Data_Types_and_Constants">Names, Data Types and Constants</A>) or by an<TT> IMPLICIT</TT> statement,
is either confirmed or overridden.&nbsp; However, once a name has been declared to be of type double complex, it cannot appear
in another type declaration statement.
<BR><BR>There are various forms of the<TT> DOUBLE COMPLEX</TT> statement.&nbsp; The following sections describe them.
<H3 ID="Simple_DOUBLE_COMPLEX_Statement"> Simple DOUBLE COMPLEX Statement </H3>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DOUBLE COMPLEX name [,name] ...</TT></TT>&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>name
<DD>is a variable name, array name, array declarator, symbolic name of a constant, function name or dummy procedure name.
</DL>
<BR>The<TT> DOUBLE COMPLEX</TT> statement is an extension to the FORTRAN 77 language.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DIMENSION C(-5:5)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DOUBLE COMPLEX A, B(10), C</TT>
<BR><BR>In the previous example,<TT> A</TT> is defined to be a variable of type double complex and<TT> B</TT> and<TT> C</TT>
are defined to be arrays of type double complex.
<H3 ID="DOUBLE_COMPLEX_Statement__Data_Initialization"> DOUBLE COMPLEX Statement:&nbsp; Data Initialization </H3>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DOUBLE COMPLEX name [/cl/] [,name[/cl/]] ...</TT></TT>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>name
<DD>is as described in the previous section.
<DT>cl
<DD>is a list of the form:
<BR><BR><TT>k [,k] ...</TT>
<DT>k
<DD>is one of the forms:
<BR><BR><TT>c</TT>
<BR><BR><TT>r*c</TT> (equivalent to<TT> r</TT> successive appearances of<TT> c)</TT>
<DT>c
<DD>is a constant or the symbolic name of a constant
<DT>r
<DD>is an unsigned positive integer constant or the symbolic name of a constant.
</DL>
<BR>This form of the<TT> DOUBLE COMPLEX</TT> statement is also an extension to the FORTRAN 77 language.&nbsp; The rules for
data initialization are the same as for the<TT> DATA</TT> statement.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DOUBLE COMPLEX A/(4D4,5.1D4)/, B(10)/10*(5D1,3.1D1)/</TT>
<BR><BR>In the previous example,<TT> A</TT> is initialized with the double precision complex constant<TT> (4D4,5.1D4)</TT>
and each element of the array<TT> B</TT> is initialized with the double precision complex constant<TT> (5D1,3.1D1).</TT>
<H2 ID="DOUBLE_PRECISION_Statement"> DOUBLE PRECISION Statement </H2>
<BR>The<TT> DOUBLE PRECISION</TT> statement is a type declaration statement and can be used to declare a name to be of type
double precision.&nbsp; The implicit type of the name, whether defined by the &quot;first letter rule&quot; (see the chapter
entitled <A HREF="#Names__Data_Types_and_Constants">Names, Data Types and Constants</A>) or by an<TT> IMPLICIT</TT> statement,
is either confirmed or overridden.&nbsp; However, once a name has been declared to be of type double precision, it cannot
appear in another type declaration statement.
<BR><BR>There are various forms of the<TT> DOUBLE PRECISION</TT> statement.&nbsp; The following sections describe them.
<H3 ID="Standard_DOUBLE_PRECISION_Statement"> Standard DOUBLE PRECISION Statement </H3>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DOUBLE PRECISION name [,name] ...</TT></TT>&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>name
<DD>is a variable name, array name, array declarator, symbolic name of a constant, function name or dummy procedure name.
</DL>
<BR>This form is the standard form of the<TT> DOUBLE PRECISION</TT> statement.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DIMENSION C(-5:5)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DOUBLE PRECISION A, B(10), C</TT>
<BR><BR>In the previous example,<TT> A</TT> is defined to be a variable of type double precision and<TT> B</TT> and<TT> C</TT>
are defined to be arrays of type double precision.
<H3 ID="Extended_DOUBLE_PRECISION_Statement__Data_Initialization"> Extended DOUBLE PRECISION Statement:&nbsp; Data Initialization </H3>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DOUBLE PRECISION name [/cl/] [,name[/cl/]] ...</TT></TT>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>name
<DD>is as described in the previous section.
<DT>cl
<DD>is a list of the form:
<BR><BR><TT>k [,k] ...</TT>
<DT>k
<DD>is one of the forms:
<BR><BR><TT>c</TT>
<BR><BR><TT>r*c</TT> (equivalent to<TT> r</TT> successive appearances of<TT> c)</TT>
<DT>c
<DD>is a constant or the symbolic name of a constant
<DT>r
<DD>is an unsigned positive integer constant or the symbolic name of a constant.
</DL>
<BR>This form of the<TT> DOUBLE PRECISION</TT> statement is an extension to the FORTRAN 77 language.&nbsp; The rules for data
initialization are the same as for the<TT> DATA</TT> statement.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DOUBLE PRECISION A/4D4/, B(10)/10*5D1/</TT>
<BR><BR>In the previous example,<TT> A</TT> is initialized with the double precision constant<TT> 4D4</TT> and each element
of the array<TT> B</TT> is initialized with the double precision constant<TT> 5D1.</TT>
<H2 ID="DO_WHILE_Statement"> DO WHILE Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO [s[,]] WHILE (e)&nbsp;&nbsp;&nbsp; [: block-label]</TT></TT>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>s
<DD>is an optional statement label of an executable statement, called the<B> terminal statement,</B> which follows the<TT> DO</TT>
statement in the same program unit.
<DT>e
<DD>is a logical expression or integer arithmetic expression, in which case the result of the integer expression is compared for
inequality to the integer value 0.
<DT>block-label
<DD>is an optional block label.
</DL>
<BR>The<TT> DO WHILE</TT> statement is an extension to the FORTRAN 77 language.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X = 0.0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO 10 WHILE( X .LT. 100.0 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, X, SQRT( X )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X = X + 1.0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 10&nbsp;&nbsp;&nbsp; CONTINUE</TT>
<BR><BR>If no statement label is present, the terminal statement of the DO-loop must be an<TT> END DO</TT> statement.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X = 0.0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO WHILE( X .LT. 100.0 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, X, SQRT( X )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X = X + 1.0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDDO</TT>
<BR><BR>The following example illustrates the use of an integer arithmetic expression.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I = 10</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO WHILE( I )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, I</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I = I - 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDDO</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>The<TT> DO WHILE</TT> statement, is similar to the<TT> DO</TT> statement.&nbsp; All nesting rules that apply to the<TT>
DO</TT> statement also apply to the<TT> DO WHILE</TT> statement.&nbsp; The difference is the way in which the looping is accomplished;
the DO-loop is executed while the logical expression of the<TT> DO WHILE</TT> statement has a true value or until control
is transferred out of the DO-loop.
<BR><BR>For more information, see the chapter entitled <A HREF="#Program_Structure_Control_Statements">Program Structure Control Statements</A>.
<H2 ID="ELSE_Statement"> ELSE Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ELSE</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR>The<TT> ELSE</TT> statement is used in conjunction with the<TT> IF</TT> or<TT> ELSE IF</TT> statement.&nbsp; The range
of the<TT> ELSE</TT> block is terminated by a matching<TT> END IF</TT> statement.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( A .LT. B )THEN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'A is less than B'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ELSE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'A is greater than or
equal to B'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END IF</TT>
<BR><BR>Transfer of control into the range of an<TT> ELSE</TT> block is illegal.&nbsp; It is interesting to note that the<TT>
ELSE</TT> statement may be identified by a statement label but it must not be referenced by any statement!
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Illegal branch to a labelled ELSE statement.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( A .LT. B )THEN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'A is less than B'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 100&nbsp;&nbsp; ELSE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'A is greater than or
equal to B'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GO TO 100</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END IF</TT>
<BR><BR>The above is an example of an illegal way to construct an infinitely repeating loop.&nbsp; The following is the correct
way to do this.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( A .LT. B )THEN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'A is less than B'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ELSE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 100&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'A is greater than or equal to B'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GO TO 100</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END IF</TT>
<BR><BR>For more information, see the chapter entitled <A HREF="#Program_Structure_Control_Statements">Program Structure Control Statements</A>.
<H2 ID="ELSE_IF_Statement"> ELSE IF Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ELSE IF (e) THEN</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>e
<DD>is a logical expression or integer arithmetic expression, in which case the result of the integer expression is compared for
inequality to the integer value 0.
</DL>
<BR>The<TT> ELSE IF</TT> statement is used in conjunction with the<TT> IF</TT> statement.&nbsp; The range of the<TT> ELSE
IF</TT> block is terminated by another<TT> ELSE IF</TT> statement, an<TT> ELSE</TT> statement, or an<TT> END IF</TT> statement.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( A .LT. B )THEN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'A is less than B'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ELSE IF( A .EQ. B )THEN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'A is equal to B'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ELSE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'A is greater than B'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END IF</TT>
<BR><BR>Transfer of control into the range of an<TT> ELSE IF</TT> block is illegal.&nbsp; It is interesting to note that the<TT>
ELSE IF</TT> statement may be identified by a statement label but it must not be referenced by any statement!
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Illegal transfer into the range of</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * an ELSE IF statement.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( A .EQ. 0.0 )GO TO 110</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( A .LT. B )THEN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'A is less than B'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ELSE IF( A .EQ. B )THEN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'A is equal to B or'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 110&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'A is equal to 0'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ELSE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'A is greater than B'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END IF</TT>
<BR><BR>The above is an example of an illegal attempt to branch into the range of an<TT> ELSE IF</TT> block.
<BR><BR>For more information, see the chapter entitled <A HREF="#Program_Structure_Control_Statements">Program Structure Control Statements</A>.
<H2 ID="END_Statement"> END Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR>The<TT> END</TT> statement indicates the end of a sequence of statements and comment lines of a program unit.&nbsp; Execution
of an<TT> END</TT> statement in a function or subroutine subprogram has the same effect as a<TT> RETURN</TT> statement.&nbsp;
Control is returned to the invoking program unit.&nbsp; Execution of an<TT> END</TT> statement in a main program causes termination
of execution of the program.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SUBROUTINE EULER( X, Y, Z )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>Upon executing the<TT> END</TT> statement, execution control is returned to the calling program unit.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PROGRAM PAYROL</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>Upon executing the<TT> END</TT> statement, execution of the program is terminated.
<BR><BR>Some rather special rules apply to the<TT> END</TT> statement.&nbsp; The statement is written in columns 7 to 72 of
an initial line.&nbsp; In other words, it must not be continued.&nbsp; Also, no other statement in the program unit may have
an initial line that appears to be an<TT> END</TT> statement.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * An illegal ENDIF statement.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( A .LT. B )THEN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;IF</TT>
<BR><BR>The above<TT> END IF</TT> statement is illegal since the initial line appears to be an<TT> END</TT> statement.
<H2 ID="END_AT_END_Statement"> END AT END Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END AT END</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR>The<TT> END AT END</TT> statement is used in conjunction with the structured<TT> AT END</TT> statement.&nbsp; The<TT>
END AT END</TT> statement marks the end of a sequence of statements which are part of an AT END-block.&nbsp; The<TT> AT END</TT>
statement marks the beginning of the AT END-block.&nbsp; The AT END-block is executed when the preceding<TT> READ</TT> statement
terminates because of an end-of-file condition.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ( UNIT=1, FMT='(3I5)' ) I, J, K</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AT END DO</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'END-OF-FILE ENCOUNTERED
ON UNIT 1'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EOFSW = .TRUE.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END AT END</TT>
<BR><BR>For more information, see the chapter entitled <A HREF="#Program_Structure_Control_Statements">Program Structure Control Statements</A>.
<H2 ID="END_BLOCK_Statement"> END BLOCK Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END BLOCK</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR>The<TT> END BLOCK</TT> statement is used to terminate a REMOTE-block.&nbsp; The<TT> END BLOCK</TT> statement is implicitly
a transfer statement, since it returns program control from a REMOTE-block.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REMOTE BLOCK A</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I=I+1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'I=',I</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END BLOCK</TT>
<BR><BR>For more information, see the description of the<TT> EXECUTE</TT> and<TT> REMOTE BLOCK</TT> statements or the chapter
entitled <A HREF="#Program_Structure_Control_Statements">Program Structure Control Statements</A>.
<H2 ID="END_DO_Statement"> END DO Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END DO</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR>The<TT> END DO</TT> statement is used to terminate the range of a &quot;structured&quot;<TT> DO</TT> statement.&nbsp;
A structured<TT> DO</TT> statement is one in which a statement label is not present.&nbsp; For more information, see the description
of the structured<TT> DO</TT> statement or the chapter entitled <A HREF="#Program_Structure_Control_Statements">Program Structure Control Statements</A>.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO X = -5.1, 12.8, 0.125</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END DO</TT>
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X = -5.1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO WHILE( X .LE. 12.8 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X = X + 0.125</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END DO</TT>
<H2 ID="ENDFILE_Statement"> ENDFILE Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDFILE u</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDFILE (alist)</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>u
<DD>is an external unit identifier.
<DT>alist
<DD>is a list of endfile specifiers separated by commas:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [UNIT =] u</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; IOSTAT = ios</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ERR = s</TT>
</DL>
<BR>Execution of an<TT> ENDFILE</TT> statement causes an endfile record to be written to the file connected to the specified
unit.&nbsp; The file is then positioned after the endfile record.&nbsp; If the file may be connected for<B> direct access,</B>
only those records before the endfile record are considered to have been written.&nbsp; Thus, only those records before the
endfile record may be read during subsequent direct access connections to the file.
<DL>
<DT>Endfile Specifiers
<DD>
<DT>[UNIT =] u
<DD>
<BR><BR><TT>u</TT> is an<B> external unit identifier.</B>&nbsp; An external unit identifier is a non-negative integer expression.
&nbsp;If the optional<TT> UNIT=</TT> specifier is omitted then the specifier must be the first item in the list of specifiers.
<DT>IOSTAT = ios
<DD>
<BR><BR>is an<B> input/output status specifier.</B>&nbsp; The integer variable or integer array element<TT> ios</TT> is defined
with zero if no error condition exists or a positive integer value if an error condition exists.
<DT>ERR = s
<DD>
<BR><BR>is an<B> error specifier</B> and<TT> s</TT> is a statement label.&nbsp; When an error occurs, execution is transferred
to the statement labelled by<TT> s.</TT>
</DL>
<BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOOP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ( UNIT=7, END=100, FMT=200
)RECORD</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WRITE( UNIT=8, FMT=200 )RECORD</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDLOOP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 100&nbsp;&nbsp; ENDFILE( UNIT=8 )</TT>
<BR><BR>In the previous example, we illustrate how one might read all the records from one file (unit 7), write them to another
file (unit 8) and then write an endfile record to the end of the file on unit 8.
<BR><BR><B>Notes:</B>
<OL>
<LI>The unit must be connected for sequential access.
<LI>After execution of an<TT> ENDFILE</TT> statement, a<TT> BACKSPACE</TT> or<TT> REWIND</TT> statement must be used to reposition
the file before any other input/output statement which refers to this file can be executed.
<LI>If the file did not exist before execution of the<TT> ENDFILE</TT> statement then it will be created after execution of
this statement.
</OL>
<BR>For more information on input/output, see the chapter entitled <A HREF="#InputDOutput">Input/Output</A>.
<H2 ID="END_GUESS_Statement"> END GUESS Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END GUESS</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR>The<TT> END GUESS</TT> statement is used in conjunction with the structured<TT> GUESS</TT> statement.&nbsp; The<TT> END
GUESS</TT> statement marks the end of a series of GUESS-ADMIT blocks.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER CH</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ *, CH</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GUESS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( CH .LT. 'a' )QUIT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( CH .GT. 'z' )QUIT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'Lower case letter'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ADMIT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( CH .LT. 'A' )QUIT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( CH .GT. 'Z' )QUIT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'Upper case letter'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ADMIT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( CH .LT. '0' )QUIT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( CH .GT. '9' )QUIT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'Digit'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ADMIT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'Special character'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END GUESS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>For more information, see the chapter entitled <A HREF="#Program_Structure_Control_Statements">Program Structure Control Statements</A>.
<H2 ID="END_IF_Statement"> END IF Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END IF</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR>The<TT> END IF</TT> statement is used in conjunction with the block<TT> IF</TT> statement.&nbsp; The<TT> END IF</TT> statement
marks the end of a sequence of statements which are to be conditionally executed.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( X .LT. 100.0 )THEN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'X IS LESS THAN 100'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END IF</TT>
<BR><BR>The<TT> END IF</TT> statement can also be used in conjunction with the<TT> ELSE</TT> and<TT> ELSE IF</TT> statements.
&nbsp;For more information, see the chapter entitled <A HREF="#Program_Structure_Control_Statements">Program Structure Control Statements</A>.
<H2 ID="END_LOOP_Statement"> END LOOP Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END LOOP</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR>The<TT> END LOOP</TT> statement is used in conjunction with the structured<TT> LOOP</TT> statement.&nbsp; The<TT> END
LOOP</TT> statement marks the end of a sequence of statements which are to be repeated.&nbsp; The<TT> LOOP</TT> statement
marks the beginning of the loop.&nbsp; The LOOP-block is executed until control is transferred out of the LOOP-block.
<BR><BR>The<TT> QUIT</TT> statement may be used to transfer control out of a LOOP-block.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOOP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ *, X</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( X .GT. 99.0 ) QUIT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, X</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END LOOP</TT>
<BR><BR>For more information, see the chapter entitled <A HREF="#Program_Structure_Control_Statements">Program Structure Control Statements</A>.
<H2 ID="END_MAP_Statement"> END MAP Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END MAP</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR>The<TT> END MAP</TT> statement is used in conjunction with the<TT> MAP</TT> declarative statement.&nbsp; The<TT> END MAP</TT>
statement marks the end of a<TT> MAP</TT> structure.&nbsp; The following example maps out a 4-byte integer on an Intel 80x86-based
processor.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STRUCTURE /MAPINT/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UNION</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MAP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; INTEGER*4 LONG</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END MAP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MAP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; INTEGER*2 LO_WORD</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; INTEGER*2 HI_WORD</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END MAP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MAP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; INTEGER*1 BYTE_0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; INTEGER*1 BYTE_1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; INTEGER*1 BYTE_2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; INTEGER*1 BYTE_3</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END MAP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END UNION</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END STRUCTURE</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RECORD /MAPINT/ I</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I%LONG = '01020304'x</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT '(2Z4)', I%LO_WORD, I%HI_WORD</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>For more information, see the chapter entitled <A HREF="#Structures__Unions_and_Records">Structures, Unions and Records</A>.
<H2 ID="END_SELECT_Statement"> END SELECT Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END SELECT</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR>The<TT> END SELECT</TT> statement is used in conjunction with the<TT> SELECT</TT> statement.&nbsp; The<TT> END SELECT</TT>
statement marks the end of a series of<TT> CASE</TT> blocks.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SELECT CASE ( CH )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CASE ( 'a' : 'z' )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'Lower case letter'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CASE ( 'A' : 'Z' )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'Upper case letter'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CASE ( '0' : '9' )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'Digit'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CASE DEFAULT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'Special character'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END SELECT</TT>
<BR><BR>For more information, see the chapter entitled <A HREF="#Program_Structure_Control_Statements">Program Structure Control Statements</A>.
<H2 ID="END_STRUCTURE_Statement"> END STRUCTURE Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END STRUCTURE</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR>The<TT> END STRUCTURE</TT> statement is used in conjunction with the<TT> STRUCTURE</TT> declarative statement.&nbsp; The<TT>
END STRUCTURE</TT> statement marks the end of a structure definition.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STRUCTURE /ADDRESS/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*20 STREET</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*20 CITY</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*20 STATE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*20 COUNTRY</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*10 ZIP_CODE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END STRUCTURE</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STRUCTURE /PEOPLE/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*20 NAME</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RECORD /ADDRESS/ ADDR</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER*2 AGE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END STRUCTURE</TT>
<BR><BR>For more information, see the chapter entitled <A HREF="#Structures__Unions_and_Records">Structures, Unions and Records</A>.
<H2 ID="END_UNION_Statement"> END UNION Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END UNION</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR>The<TT> END UNION</TT> statement is used in conjunction with the<TT> UNION</TT> declarative statement.&nbsp; The<TT> END
UNION</TT> statement marks the end of a series of<TT> MAP</TT> structures.&nbsp; The following example maps out a 4-byte integer
on an Intel 80x86-based processor.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STRUCTURE /MAPINT/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UNION</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MAP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; INTEGER*4 LONG</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END MAP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MAP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; INTEGER*2 LO_WORD</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; INTEGER*2 HI_WORD</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END MAP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MAP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; INTEGER*1 BYTE_0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; INTEGER*1 BYTE_1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; INTEGER*1 BYTE_2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; INTEGER*1 BYTE_3</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END MAP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END UNION</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END STRUCTURE</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RECORD /MAPINT/ I</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I%LONG = '01020304'x</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT '(2Z4)', I%LO_WORD, I%HI_WORD</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>For more information, see the chapter entitled <A HREF="#Structures__Unions_and_Records">Structures, Unions and Records</A>.
<H2 ID="END_WHILE_Statement"> END WHILE Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END WHILE</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR>The<TT> END WHILE</TT> statement is used in conjunction with the structured<TT> WHILE</TT> statement.&nbsp; The<TT> END
WHILE</TT> statement marks the end of a sequence of statements which are to be repeated.&nbsp; The<TT> WHILE</TT> statement
marks the beginning of the WHILE-block.&nbsp; The WHILE-block is executed while the logical expression (or integer arithmetic
expression) of the<TT> WHILE</TT> statement has a true (or non-zero) value or until control is transferred out of the WHILE-block.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X = 1.0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WHILE( X .LT. 100 )DO</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, X, SQRT( X )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X = X + 1.0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END WHILE</TT>
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I = 10</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WHILE( I )DO</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, I</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I = I - 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDWHILE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>For more information, see the chapter entitled <A HREF="#Program_Structure_Control_Statements">Program Structure Control Statements</A>.
<H2 ID="ENTRY_Statement"> ENTRY Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENTRY name [( [d [, d] ...] )]</TT></TT>&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>name
<DD>is a symbolic name of an entry in a function or subroutine subprogram.&nbsp; If the<TT> ENTRY</TT> statement appears in a
subroutine subprogram then<TT> name</TT> is a<B> subroutine name.</B>&nbsp; If the<TT> ENTRY</TT> statement appears in a function
subprogram then<TT> name</TT> is an<B> external function name.</B>&nbsp; 
<DT>d
<DD>is a variable name, array name, dummy procedure name, or an asterisk.<TT>&nbsp; d</TT> is called a<B> dummy argument.</B>
&nbsp;An asterisk is allowed only in a subroutine subprogram.
</DL>
<BR>The<TT> ENTRY</TT> statement is used to define an alternate entry into a subprogram.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, TMAX2( 121.0, -290.0 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, TMAX3( -1.0, 12.0, 5.0 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FUNCTION TMAX3( ARGA, ARGB, ARGC )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T3 = ARGC</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GO TO 10</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENTRY TMAX2( ARGA, ARGB )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T3 = ARGA</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TMAX2 = ARGA</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( ARGB .GT. TMAX2 ) TMAX2 =
ARGB</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( T3 .GT. TMAX2 ) TMAX2 = T3</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>In the above example, an entry was defined to permit us to find the maximum of two real variables.&nbsp; Either the
entry name<TT> TMAX2</TT> or the function name<TT> TMAX3</TT> could have been used as the variable for returning the maximum
value since they agree in type.&nbsp; It is not necessary to precede an<TT> ENTRY</TT> statement with a transfer statement
as the<TT> ENTRY</TT> statement is not an executable statement; the next statement executed will be the first executable statement
following the<TT> ENTRY</TT> statement.
<BR><BR><B>Notes:</B>
<OL>
<LI>No dummy arguments need be specified in the<TT> ENTRY</TT> statement.&nbsp; If this is the case, the parentheses () are
optional.
</OL>
<BR>For more information, see the chapter entitled <A HREF="#Functions_and_Subroutines">Functions and Subroutines</A>.
<H2 ID="EQUIVALENCE_Statement"> EQUIVALENCE Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EQUIVALENCE (nlist) [,(nlist)] ...</TT></TT>&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>nlist
<DD>is a list of at least two names, each name separated by a comma.
</DL>
<BR>The names appearing in<TT> nlist</TT> can be variable names, array names, array element names, character names, character
substring names, and character array element substring names.&nbsp; Dummy arguments are not allowed in<TT> nlist.</TT>
<BR><BR>The<TT> EQUIVALENCE</TT> statement specifies that the storage occupied by the entities appearing in<TT> nlist</TT>
all start at the same place.&nbsp; It in no way changes the characteristics of an object.&nbsp; For example, if a variable
is equivalenced to an array, the variable does not inherit the properties of the array.&nbsp; Similarly, if a variable of
type integer is equivalenced to a variable of type real, there is no implied type conversion.
<BR><BR>If an array element name appears in an<TT> EQUIVALENCE</TT> statement, the number of subscript expressions must be
the same as the number of dimensions specified when the array was declared and each subscript expression must be in the range
specified.&nbsp; As an extension to FORTRAN 77, Open Watcom FORTRAN 77 allows a single subscript expression for a multi-dimensional
array.&nbsp; An array name used by itself is equivalent to specifying the first element of the array.
<BR><BR>If a character substring appears in an<TT> EQUIVALENCE</TT> statement, the substring defined by the substring expression
must be properly contained in the character entity being substrung.&nbsp; A character name used by itself is equivalent to
specifying the first character of the character variable.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REAL A,B</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DIMENSION A(10),B(20)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EQUIVALENCE (A,B(16))</TT>
<BR><BR>In the above example, the first 5 elements of<TT> A</TT> occupy the same storage as the last 5 elements of<TT> B.</TT>
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DIMENSION A(10)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EQUIVALENCE (C,A(2)),(D,A(4))</TT>
<BR><BR>In the above example,<TT> C</TT> is assigned the same storage unit as<TT> A(2)</TT> and<TT> D</TT> is assigned the
same storage unit as<TT> A(4).</TT>
<BR><BR>The following example illustrates a Open Watcom FORTRAN 77 extension.
<BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REAL A(2,10),B(20),C(2,2,5)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EQUIVALENCE (A(5),B(1)),(B(1),C(1))</TT>
<BR><BR>In the above example, a single subscript is specified for arrays<TT> A</TT> and<TT> C.</TT>&nbsp; The following table
shows the mapping of a 2-dimensional array onto a 1-dimensional array.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A(1,1)&nbsp; ==&nbsp; A(1)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A(2,1)&nbsp; ==&nbsp; A(2)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A(1,2)&nbsp; ==&nbsp; A(3)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A(2,2)&nbsp; ==&nbsp; A(4)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A(1,3)&nbsp; ==&nbsp; A(5)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A(2,3)&nbsp; ==&nbsp; A(6)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><BR>In the above table, &quot;==&quot; is read as &quot;is equivalent to&quot;.&nbsp; In FORTRAN, arrays are stored in
&quot;column major&quot; format (i.e., arrays are stored column by column rather than row by row).
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*5 A, D</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EQUIVALENCE (A(3:5), D(1:3))</TT>
<BR><BR>In this example, the last 3 characters of<TT> A</TT> occupy the same character storage units as the first 3 characters
of<TT> D.</TT>
<BR><BR>There are certain restrictions on<TT> EQUIVALENCE</TT> statements.&nbsp; It is not possible to equivalence a storage
unit to 2 different storage units.&nbsp; This is illustrated by the following example.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Illegally equivalencing a storage unit to</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * 2 different storage units.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DIMENSION A(2)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EQUIVALENCE (A(1),B),(A(2),B)</TT>
<BR><BR><TT>B</TT> has been given 2 different storage units.
<BR><BR>It is also not possible to specify that consecutive storage units be non-consecutive.&nbsp; For example,
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Illegally equivalencing consecutive storage units to</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * non-consecutive storage units.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DIMENSION A(2),B(2)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EQUIVALENCE (A(1),B(2)),(A(2),B(1))</TT>
<BR><BR><TT>A(1)</TT> and<TT> A(2)</TT> are consecutive but<TT> B(1)</TT> and<TT> B(2)</TT> are not.
<BR><BR>The FORTRAN 77 standard specifies that character and numeric data cannot be equivalenced; Open Watcom FORTRAN 77 allows
character and numeric data to be equivalenced.
<H2 ID="EXECUTE_Statement"> EXECUTE Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EXECUTE name</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>name
<DD>is the name of a<TT> REMOTE BLOCK</TT> located in the same program unit.
</DL>
<BR>The<TT> EXECUTE</TT> statement allows a named block of code to be executed.&nbsp; The named block of code may be defined
anywhere in the same program unit and is delimited by the<TT> REMOTE BLOCK</TT> and<TT> END BLOCK</TT> statements.&nbsp; Executing
a REMOTE-block is similar in concept to calling a subroutine, with the advantage that shared variables do not need to be placed
in a<TT> COMMON</TT> block or passed in an argument list.&nbsp; When execution of the REMOTE-block is complete (i.e., when
the<TT> END BLOCK</TT> statement is executed), control returns to the statement following the<TT> EXECUTE</TT> statement which
invoked it.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EXECUTE INCR</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'FIRST'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EXECUTE INCR</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'SECOND'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REMOTE BLOCK INCR</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I=I+1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'I=',I</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END BLOCK</TT>
<BR><BR>For more information, see the chapter entitled <A HREF="#Program_Structure_Control_Statements">Program Structure Control Statements</A>.
<H2 ID="EXIT_Statement"> EXIT Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EXIT&nbsp;&nbsp;&nbsp; [: block-label]</TT></TT>&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR>The<TT> EXIT</TT> statement is used to transfer control:
<OL>
<LI>from within a loop (DO, DO WHILE, WHILE or LOOP) to the statement following the loop,
<LI>from within a GUESS or ADMIT block to the statement following the<TT> ENDGUESS</TT> statement, or
<LI>from within a remote block to the statement following the<TT> EXECUTE</TT> statement that invoked the remote block.
</OL>
<BR>The<TT> EXIT</TT> statement may be used to cause a transfer of control to the first executable statement that follows
the terminal statement of the block which contains it.&nbsp; Examples of such terminal statements are<TT> END DO</TT>,<TT>
END LOOP</TT>,<TT> END WHILE</TT>,<TT> UNTIL</TT>, etc.&nbsp; If<TT> block-label</TT> is present then control is transferred
out of the block identified by that block label.&nbsp; The<TT> EXIT</TT> statement is an extension to the FORTRAN 77 language.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOOP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WRITE( UNIT=*, FMT='(A)' ) 'Enter
a number'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ( UNIT=*, FMT='(F10.4)',
IOSTAT=IOS ) X</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( IOS .NE. 0 ) EXIT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( X .LT. 0 ) EXIT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, X, SQRT( X )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END LOOP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>For more information, see the chapter entitled <A HREF="#Program_Structure_Control_Statements">Program Structure Control Statements</A>.
<H2 ID="EXTERNAL_Statement"> EXTERNAL Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EXTERNAL p [,p] ...</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>p
<DD>is the name of an external procedure, dummy procedure or block data subprogram.
</DL>
<BR>The<TT> EXTERNAL</TT> statement identifies a symbolic name to be a dummy procedure or an external procedure and allows
these names to be passed as an actual argument.&nbsp; In the following example,<TT> SAM, ERRRTN</TT> and<TT> POLY</TT> are
declared to be external procedures.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EXTERNAL SAM, ERRRTN, POLY</TT>
<BR><BR>In the following example,<TT> F</TT> is declared to be an external procedure and is passed as such to subroutine<TT>
SAM.</TT>&nbsp; If the<TT> EXTERNAL</TT> statement were eliminated then the variable<TT> F</TT> would be passed on to subroutine<TT>
SAM</TT> since there is no way of knowing that<TT> F</TT> is an external function.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EXTERNAL F</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALL SAM( F )</TT>
<BR><BR>The appearance of an intrinsic function in an<TT> EXTERNAL</TT> statement declares that name to be an external procedure
and the intrinsic function by that name is no longer available in that program unit.&nbsp; This allows the programmer to define
a function by the same name as an intrinsic function.&nbsp; In the following example, the programmer's<TT> SIN</TT> function
will be called instead of the intrinsic<TT> SIN</TT> function.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EXTERNAL SIN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALL SIN( .1 )</TT>
<BR><BR>A statement function name must not appear in an<TT> EXTERNAL</TT> statement.&nbsp; A name must only appear in an<TT>
EXTERNAL</TT> statement once.
<H2 ID="FORMAT_Statement"> FORMAT Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; label&nbsp;&nbsp;&nbsp; FORMAT fs</TT></TT>&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;<TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>fs
<DD>is a format specification and is described in the chapter entitled <A HREF="#Format">Format</A>.
<DT>label
<DD>is the statement label used by an I/O statement to identify the<TT> FORMAT</TT> statement to be used.&nbsp; The<TT> FORMAT</TT>
statement must be labelled.
</DL>
<BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REAL X</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X = 234.43</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT 100, X</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 100&nbsp;&nbsp; FORMAT(F10.2)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>In the previous example, the<TT> PRINT</TT> statement uses the format specification in the<TT> FORMAT</TT> statement
whose statement label is 100 to display the value of<TT> X.</TT>
<BR><BR>For more information on the<TT> FORMAT</TT> statement, see the chapter entitled <A HREF="#Format">Format</A>.
<H2 ID="FUNCTION_Statement"> FUNCTION Statement </H2>
<BR>A<TT> FUNCTION</TT> statement is used to define the start of a function subprogram.&nbsp; There are two forms of the<TT>
FUNCTION</TT> function statement.&nbsp; The second form is a Open Watcom FORTRAN 77 extension.
<H3 ID="Standard_FUNCTION_Statement"> Standard FUNCTION Statement </H3>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [type] FUNCTION fun ( [d [, d] ...] )</TT></TT>&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>type
<DD>is one of<TT> LOGICAL, INTEGER, REAL, DOUBLE PRECISION, COMPLEX</TT> or<TT> CHARACTER [*len].</TT>
<DT>fun
<DD>is a symbolic name of a function subprogram.
<DT>d
<DD>is a variable name, array name, or a dummy procedure name.<TT>&nbsp; d</TT> is called a<B> dummy argument.</B>&nbsp; 
<DT>len
<DD>is called the length specification and is the length (number of characters) of the result of the character function.&nbsp;
It has one of the following forms:
<DL>
<DT>(1)
<DD>An unsigned positive integer constant.
<DT>(2)
<DD>A positive integer constant expression enclosed in parentheses.
<DT>(3)
<DD>An asterisk in parentheses,<TT> (*).</TT>
</DL>
</DL>
<BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, TMAX3( -1.0, 12.0, 5.0 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FUNCTION TMAX3( ARGA, ARGB, ARGC )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TMAX3 = ARGA</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( ARGB .GT. TMAX3 ) TMAX3 =
ARGB</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( ARGC .GT. TMAX3 ) TMAX3 =
ARGC</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>In the above example, the function<TT> TMAX3</TT> is defined to find the maximum of three real variables.
<BR><BR><B>Notes:</B>
<OL>
<LI>No dummy arguments need be specified in the<TT> FUNCTION</TT> statement.&nbsp; However, the parentheses () are mandatory.
</OL>
<BR>For more information, see the chapter entitled <A HREF="#Functions_and_Subroutines">Functions and Subroutines</A>.
<H3 ID="Extended_FUNCTION_Statement"> Extended FUNCTION Statement </H3>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [type[*len]] FUNCTION fun[*len] ( [d [, d] ...] )</TT></TT>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>type
<DD>is one of<TT> LOGICAL, INTEGER, REAL, DOUBLE PRECISION, COMPLEX, CHARACTER</TT> or<TT> RECORD /typename/</TT>
<DT>fun
<DD>is a symbolic name of a function subprogram.
<DT>d
<DD>is a variable name, array name, or a dummy procedure name.<TT>&nbsp; d</TT> is called a<B> dummy argument.</B>&nbsp; 
<DT>len
<DD>is called the length specification and has one of the following forms:
<DL>
<DT>(1)
<DD>An unsigned positive integer constant.
<DT>(2)
<DD>A positive integer constant expression enclosed in parentheses.
<DT>(3)
<DD>An asterisk in parentheses,<TT> (*).</TT>
</DL>
<BR>For valid values of<TT> len,</TT> refer to the appropriate type declaration statement.
</DL>
<BR>This form of the<TT> FUNCTION</TT> statement is an extension to the FORTRAN 77 language.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER*2 MOD2, I, J</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I = 12</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; J = 5</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, MOD2( I, J )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER*2 FUNCTION MOD2( I, J )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER*2 I, J</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER II, JJ</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; II = I</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; JJ = J</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MOD2 = MOD(II, JJ)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR><B>Notes:</B>
<OL>
<LI>No dummy arguments need be specified in the<TT> FUNCTION</TT> statement.&nbsp; However, the parentheses () are mandatory.
<LI>The length specification can appear only once in the<TT> FUNCTION</TT> statement.
</OL>
<BR>For more information, see the chapter entitled <A HREF="#Functions_and_Subroutines">Functions and Subroutines</A>.
<H2 ID="Unconditional_GO_TO_Statement"> Unconditional GO TO Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GO TO s</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>s
<DD>is the statement label of an executable statement that appears in the same program unit as the<TT> GO TO</TT> statement.
</DL>
<BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GO TO 10</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 10&nbsp;&nbsp;&nbsp; S = S + 1</TT>
<BR><BR>When the<TT> GO TO</TT> statement is executed, control is transferred to the statement identified by that label.&nbsp;
In the above example, the<TT> GO TO</TT> statement causes execution to proceed to the statement labelled 10.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * An illegal GO TO statement</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GO TO 100</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 100&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FORMAT( 1X, 3F10.2 )</TT>
<BR><BR>The above example contains an illegal<TT> GO TO</TT> statement since the statement identified by the label 100 is
not executable.
<H2 ID="Computed_GO_TO_Statement"> Computed GO TO Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GO TO (s [,s]...) [,] i</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>i
<DD>is an integer expression.
<DT>s
<DD>is the statement label of an executable statement that appears in the same program unit as the computed<TT> GO TO</TT> statement.
</DL>
<BR>The integer expression<TT> i</TT> is evaluated and the<TT> i</TT>th label is selected for transfer of control.&nbsp; If<TT>
i</TT> is less than 1 or greater than the number of statement labels in the list then execution control continues with the
next executable statement that follows the computed<TT> GO TO</TT> statement.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GO TO (110, 120, 130, 140) INDEX</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 100&nbsp;&nbsp; CALL AUDIT</TT>
<BR><BR>In the above example, control is transferred to the statement identified by the label 110 if<TT> INDEX</TT> has the
value 1, the label 120 if<TT> INDEX</TT> has the value 2, etc.&nbsp; If<TT> INDEX</TT> has a value that is negative, zero
or larger than 4, control continues with the statement labelled 100.&nbsp; In this example, the integer expression consists
simply of an integer variable.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GO TO (100, 200, 100, 200, 100, 200), I/10</TT>
<BR><BR>The above example illustrates that statement labels may be repeated in the list and that a &quot;,&quot; may follow
the closing right parenthesis.
<H2 ID="Assigned_GO_TO_Statement"> Assigned GO TO Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GO TO i [[,] (s [,s]...)]</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>i
<DD>is an integer variable name.
<DT>s
<DD>is the statement label of an executable statement that appears in the same program unit as the assigned<TT> GO TO</TT> statement.
</DL>
<BR>The variable<TT> i</TT> must be defined with the value of a statement label of an executable statement that appears in
the same program unit (see the<TT> ASSIGN</TT> statement).&nbsp; The execution of the assigned<TT> GO TO</TT> statement causes
a transfer of control to the statement that is identified by that label.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER RET</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X = 0.0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ASSIGN 100 TO RET</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GO TO 3000</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 100&nbsp;&nbsp; X = X + 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ASSIGN 110 TO RET</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GO TO 3000</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 110&nbsp;&nbsp; X = X + 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Print both X and its square root</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 3000&nbsp; Y = SQRT( X )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, X, Y</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GO TO RET</TT>
<BR><BR>In the above example, we illustrate the use of the<TT> ASSIGN</TT> statement and the assigned<TT> GO TO</TT> statement
to implement a &quot;local subroutine&quot; in a program unit.&nbsp; A sequence of often-used code can be &quot;called&quot;
using the unconditional<TT> GO TO</TT> statement and &quot;return&quot; is accomplished using the assigned<TT> GO TO</TT>
statement.&nbsp; Care must be exercised to properly assign the return label value.
<BR><BR>If a list of statement labels is present then the statement label assigned to<TT> i</TT> must be in the list.&nbsp;
If it is not in the list, an error will occur when the assigned<TT> GO TO</TT> statement is executed.&nbsp; Unlike the computed<TT>
GO TO</TT> statement, execution does not continue with the next statement.&nbsp; This is demonstrated by the following example.
&nbsp;Note that the &quot;,&quot; preceding the statement label list is optional.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Illegal use of the assigned GO TO:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp; Statement label 100 does not appear in the statement</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp; label list of the assigned GO TO statement.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ASSIGN 100 TO ICASE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GO TO ICASE, (110, 120, 130)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; beginning of selections</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 100&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 100</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GO TO 200</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 110&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 110</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GO TO 200</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 120&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 120</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GO TO 200</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 130&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 130</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end of selections</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 200&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<H2 ID="GUESS_Statement"> GUESS Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GUESS&nbsp;&nbsp;&nbsp; [: block-label]</TT></TT>&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR>The<TT> GUESS</TT> statement is an extension to the FORTRAN 77 language.&nbsp; The<TT> GUESS</TT> statement marks the
beginning of a block of statements for which a certain assumption or hypothesis has been made.&nbsp; This hypothesis may be
tested using logical<TT> IF</TT> statements in conjunction with<TT> QUIT</TT> statements.&nbsp; The<TT> ADMIT</TT> statement
may be used to mark the beginning of an alternate hypothesis.&nbsp; The<TT> END GUESS</TT> statement is used to mark the end
of a series of GUESS-ADMIT blocks.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER CH</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ *, CH</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GUESS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( CH .LT. 'a' )QUIT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( CH .GT. 'z' )QUIT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'Lower case letter'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ADMIT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( CH .LT. 'A' )QUIT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( CH .GT. 'Z' )QUIT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'Upper case letter'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ADMIT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( CH .LT. '0' )QUIT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( CH .GT. '9' )QUIT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'Digit'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ADMIT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'Special character'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END GUESS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>An optional block label may be specified with the<TT> GUESS</TT> statement.
<BR><BR>For more information, see the chapter entitled <A HREF="#Program_Structure_Control_Statements">Program Structure Control Statements</A>.
<H2 ID="Arithmetic_IF_Statement"> Arithmetic IF Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF (e) s1, s2, s3</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>e
<DD>is an integer, real, or double precision expression.
<DT>s1, s2, s3
<DD>are statement labels of executable statements that appear in the same program unit as the arithmetic<TT> IF</TT> statement.
</DL>
<BR>The expression<TT> e</TT> is evaluated and if the value is less than zero then transfer is made to the statement identified
by label<TT> s1.</TT>&nbsp; If the value is equal to zero then transfer is made to the statement identified by label<TT> s2.</TT>
&nbsp;If the value is greater than zero then transfer is made to the statement identified by label<TT> s3.</TT>
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( SIN( X ) ) 10, 20, 30</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 10&nbsp;&nbsp;&nbsp; PRINT *, 'SIN(X) IS &lt; 0'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GO TO 40</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 20&nbsp;&nbsp;&nbsp; PRINT *, 'SIN(X) = 0'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GO TO 40</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 30&nbsp;&nbsp;&nbsp; PRINT *, 'SIN(X) &gt; 0'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 40&nbsp;&nbsp;&nbsp; CONTINUE</TT>
<BR><BR>The above example evaluates the sine of the real variable<TT> X</TT> and prints whether the result is less than 0,
equal to 0, or greater than 0.
<BR><BR>The same label may appear more than once in the arithmetic<TT> IF</TT> statement.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( SIN( X ) ) 10, 10, 30</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 10&nbsp;&nbsp;&nbsp; PRINT *, 'SIN(X) IS &lt;= 0'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GO TO 40</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 30&nbsp;&nbsp;&nbsp; PRINT *, 'SIN(X) &gt; 0'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 40&nbsp;&nbsp;&nbsp; CONTINUE</TT>
<BR><BR>The above example evaluates the sine of the real variable<TT> X</TT> and prints whether the result is less than or
equal to zero, or that it is greater than 0.
<H2 ID="Logical_IF_Statement"> Logical IF Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF (e) st</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>e
<DD>is a logical expression or integer arithmetic expression, in which case the result of the integer expression is compared for
inequality to the integer value 0.
<DT>st
<DD>is an executable statement.&nbsp; Only certain executable statements are allowed.&nbsp; See the section entitled <A HREF="#Classifying_Statements">Classifying Statements</A>
at the beginning of this chapter for a list of allowable statements.
</DL>
<BR>The expression<TT> e</TT> is evaluated and must result in a true or a false value.&nbsp; If the result is true then the
statement<TT> st</TT> is executed, otherwise it is not executed.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( A .LT. B )PRINT *, 'A &lt; B'</TT>
<BR><BR>In the above example, the logical expression<TT> A .LT.&nbsp; B</TT> is evaluated and, if it is true, the message<TT>
A &lt; B</TT> is printed.&nbsp; A logical expression is one in which the result is either true or false.&nbsp; An expression
such as<TT> 1 + 2</TT> is clearly not an example of a logical expression.
<BR><BR>Logical variables have logical values of true or false and may also be used in the logical expression.&nbsp; Consider
the following two examples.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOGICAL RESULT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RESULT = A .LT. B</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( RESULT )PRINT *, 'A &lt; B'</TT>
<BR><BR>The above example is equivalent to the preceding one but introduces the use of a logical variable.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOGICAL RESULT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RESULT = A .LT. B</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( .NOT. RESULT )PRINT *, 'A &gt;= B'</TT>
<BR><BR>In the above example, the logical expression is negated through the use of the<TT> .NOT.</TT>&nbsp; operator in order
to test for the inverse condition, namely<TT> .GE..</TT>
<BR><BR>Much more complex logical expressions can be constructed and then tested for their truth value.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( A.LT.B .OR. C.GE.D )PRINT *, 'A&lt;B or C&gt;=D'</TT>
<BR><BR>An example of an integer expression in an<TT> IF</TT> statement follows:
<BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I = 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Integer arithmetic expression</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( I )THEN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT
*, 'Yes'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDIF</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Equivalent logical expression</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( I .NE. 0 )THEN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT
*, 'Yes'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDIF</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<H2 ID="Block_IF_Statement"> Block IF Statement </H2>
<BR>There are two forms of the block<TT> IF</TT> statement.&nbsp; The second is a Open Watcom FORTRAN 77 extension.
<H3 ID="Standard_Block_IF_Statement"> Standard Block IF Statement </H3>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF (e) THEN</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>e
<DD>is a logical expression.
</DL>
<BR>The block<TT> IF</TT> statement is used in conjunction with the<TT> ELSE IF</TT>,<TT> ELSE</TT>, and<TT> END IF</TT> statements.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( A .LT. B )THEN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'A &lt; B'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END IF</TT>
<BR><BR>For more information, see the chapter entitled <A HREF="#Program_Structure_Control_Statements">Program Structure Control Statements</A>.
<H3 ID="Extended_Block_IF_Statement"> Extended Block IF Statement </H3>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF (e) THEN&nbsp;&nbsp;&nbsp; [: block-label]</TT></TT>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>e
<DD>is a logical expression or integer arithmetic expression, in which case the result of the integer expression is compared for
inequality to the integer value 0.
<DT>block-label
<DD>is an optional block label.
</DL>
<BR>This form of the block<TT> IF</TT> statement is an extension to the FORTRAN 77 language.&nbsp; It is identical to the
standard form of the block<TT> IF</TT> statement with the exception that an integer arithmetic expression and an optional
block label are permitted.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( I .EQ. 10 )THEN : IFBLK</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( J .EQ. 20 )THEN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( K.
EQ. 0 )QUIT : IFBLK</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END IF</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END IF</TT>
<BR><BR>In the previous example, the<TT> QUIT</TT> statement will transfer control to the statement following the second<TT>
END IF</TT> statement.
<H2 ID="IMPLICIT_Statement"> IMPLICIT Statement </H2>
<BR>Open Watcom FORTRAN 77 supports three forms of the<TT> IMPLICIT</TT> statement.&nbsp; The second and third forms are extensions
to the FORTRAN 77 language.
<H3 ID="Standard_IMPLICIT_Statement"> Standard IMPLICIT Statement </H3>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IMPLICIT type (a [,a] ...) [,type (a [,a] ...)]...</TT></TT>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>type
<DD>is one of<TT> LOGICAL, INTEGER, REAL, DOUBLE PRECISION, COMPLEX</TT> or<TT> CHARACTER[*len].</TT>
<DT>a
<DD>is either a single letter or a range of letters denoted by separating the first letter in the range from the last letter in
the range by a minus sign.
<DT>len
<DD>is the length of the character entities and is a positive unsigned integer constant or a positive integer constant expression
enclosed in parentheses.&nbsp; If<TT> len</TT> is not specified, the length is 1.
</DL>
<H3 ID="Extended_IMPLICIT_Statement"> Extended IMPLICIT Statement </H3>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IMPLICIT type[*len] (a [,a] ...)</TT></TT>&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [,type[*len]
(a [,a] ...)] ...</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>type
<DD>is one of<TT> LOGICAL, INTEGER, REAL, DOUBLE PRECISION, COMPLEX</TT> or<TT> CHARACTER.</TT>
<DT>len
<DD>is a positive unsigned integer constant or a positive integer constant expression enclosed in parentheses.&nbsp; If<TT> type</TT>
is<TT> CHARACTER</TT> then<TT> (*)</TT> is also allowed.&nbsp; The possible values of<TT> len</TT> are as follows:
<OL>
<LI>If<TT> type</TT> is<TT> LOGICAL</TT> then<TT> len</TT> can be 1 or 4.&nbsp; The default is 4.
<LI>If<TT> type</TT> is<TT> INTEGER</TT> then<TT> len</TT> can be 1, 2 or 4.&nbsp; The default is 4.
<LI>If<TT> type</TT> is<TT> REAL</TT> then<TT> len</TT> can be 4 or 8.&nbsp; The default is 4.
<LI>If<TT> type</TT> is<TT> DOUBLE PRECISION</TT> then<TT> len</TT> cannot be specified.
<LI>If<TT> type</TT> is<TT> COMPLEX</TT> then<TT> len</TT> can be 8 or 16.&nbsp; The default is 8.
<LI>If<TT> type</TT> is<TT> CHARACTER</TT> then<TT> len</TT> can be<TT> (*)</TT> or any positive integer.
</OL>
</DL>
<H3 ID="IMPLICIT_NONE_Statement"> IMPLICIT NONE Statement </H3>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IMPLICIT NONE</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<H3 ID="Description_of_IMPLICIT_Statement"> Description of IMPLICIT Statement </H3>
<BR>The<TT> IMPLICIT</TT> statement defines the default type and length for all variables, arrays, symbolic constants, external
functions and statement functions that begin with any letter that has appeared in an<TT> IMPLICIT</TT> statement as a single
letter or as a member of a range of letters.
<BR><BR>The following example specifies that any name beginning with the letters<TT> A, D, E, F</TT> or<TT> G</TT> will have
default a default type of integer and any name beginning with the letters<TT> X, Y</TT> or<TT> Z</TT> will have a default
type of character and length 3.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IMPLICIT INTEGER (A,D-G), CHARACTER*3 (X-Z)</TT>
<BR><BR>The next example illustrates the extended form of the<TT> IMPLICIT</TT> statement.
<BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IMPLICIT INTEGER*2 (A,B), LOGICAL*1 (C-F)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IMPLICIT COMPLEX*16 (X,Y,Z), REAL*8 (P)</TT>
<BR><BR>Specifying NONE in the<TT> IMPLICIT</TT> statement will cause Open Watcom FORTRAN 77 to issue an error when a symbol
is used and has not appeared in a type specification statement.
<BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Referencing X will cause an error</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IMPLICIT NONE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X = 13143.383</TT>
<BR><BR>In the above example, the<TT> IMPLICIT</TT> statement specifies that the type of all symbols must be explicitly declared
in a type specification statement.&nbsp; The assignment statement will cause an error since the type of<TT> X</TT> has not
been explicitly declared.
<BR><BR><B>Notes:</B>
<OL>
<LI>The implicit type set by an<TT> IMPLICIT</TT> statement may be overridden or confirmed for any variable, array, symbolic
constant, external function or statement function name by its appearance in a type statement.&nbsp; The default length specification
may also be overridden or confirmed in a type statement.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IMPLICIT CHARACTER*10 (S-U)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IMPLICIT INTEGER*2 (P)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER STRING</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER POINTS</TT>
<BR><BR>In the above example, the variable<TT> STRING</TT> is of type character but its length is 1 since it has appeared
in a<TT> CHARACTER</TT> statement which has a default length of 1.&nbsp; Also, the variable<TT> POINTS</TT> is of type integer
but its length is 4 since it has appeared in an<TT> INTEGER</TT> statement which has a default length of 4.
<LI>A letter cannot appear more than once as a single letter or be included in a range of letters in all<TT> IMPLICIT</TT>
statements in a program unit.
<LI>An<TT> IMPLICIT</TT> statement applies only to the program unit that contains it.
<LI>The<TT> IMPLICIT</TT> statement does not change the type of intrinsic functions.
<LI>A program unit can contain more than one<TT> IMPLICIT</TT> statement.
<LI>Within the specification statements of a program unit,<TT> IMPLICIT</TT> statements must precede all other specification
statements except<TT> PARAMETER</TT> statements.
<LI>The<TT> IMPLICIT NONE</TT> statement is allowed only once in a program unit.&nbsp; Furthermore, no other<TT> IMPLICIT</TT>
statement can be specified in the program unit containing an<TT> IMPLICIT NONE</TT> statement.
</OL>
<H2 ID="INCLUDE_Statement"> INCLUDE Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INCLUDE 'inc_spec'</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>inc_spec
<DD>is an include specification.&nbsp; You should refer to the compiler's User's Guide for a detailed description of an include
specification and include file processing.
</DL>
<BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INCLUDE 'GBLDEFS'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<H2 ID="INQUIRE_Statement"> INQUIRE Statement </H2>
<BR>The<TT> INQUIRE</TT> statement is used to ask about certain properties of a named file or its connection to a particular
unit.&nbsp; There are two forms of the<TT> INQUIRE</TT> statement; inquire by file name and inquire by unit.
<H3 ID="INQUIRE_by_FILE"> INQUIRE by FILE </H3>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INQUIRE (iflist)</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>iflist
<DD>includes the<TT> FILE=</TT> specifier and may include at most one of each of the inquiry specifiers listed below.&nbsp; Specifiers
are separated by commas.&nbsp; The<TT> FILE=</TT> specifier has the form
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; FILE = fin</TT>
<BR><BR>where<TT> fin</TT> is a character expression whose value when trailing blanks are removed is the name of a file being
inquired about.&nbsp; The file need not exist or be connected to a unit.
</DL>
<BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOGICAL EX, OD</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER NUM</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INQUIRE( FILE='ROLL',EXIST=EX,OPENED=OD,NUMBER=NUM )</TT>
<BR><BR>In the above example, information is requested on the file<TT> PAYROLL.</TT>&nbsp; In particular, we want to know
if it exists, whether it is connected to a unit, and what the unit number is (if it is indeed connected).
<H3 ID="INQUIRE_by_UNIT"> INQUIRE by UNIT </H3>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INQUIRE (iulist)</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>iulist
<DD>includes the<TT> UNIT=</TT> specifier and may include at most one of each of the inquiry specifiers listed below.&nbsp; Specifiers
are separated by commas.&nbsp; The<TT> UNIT=</TT> specified has the form
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [UNIT =] u</TT>
<BR><BR>where<TT> u</TT> is an<B> external unit identifier.</B>&nbsp; An external unit identifier is a non-negative integer
expression.&nbsp; If the optional<TT> UNIT=</TT> specifier is omitted then the specifier must be the first item in the list
of specifiers.
</DL>
<BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOGICAL EX, OD</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*30 FN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INQUIRE( UNIT=7, EXIST=EX, OPENED=OD, NAME=FN )</TT>
<BR><BR>In the above example, information is requested on unit 7.&nbsp; In particular, we want to know if the unit exists,
whether it is connected to a file, and, if so, what the file name is.
<H3 ID="Inquiry_Specifiers"> Inquiry Specifiers </H3>
<BR>The following inquiry specifiers are supported.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IOSTAT = ios</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ERR = s</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EXIST = ex</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPENED = od</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NUMBER = num</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NAMED = nmd</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NAME = fn</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ACCESS = acc</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SEQUENTIAL = seq</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DIRECT = dir</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FORM = fm</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FORMATTED = fmt</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UNFORMATTED = unf</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RECL = rcl</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NEXTREC = nr</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BLANK = blnk</TT>
<BR><BR>As an extension to the FORTRAN 77 language, the following inquiry specifiers are also supported.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ACTION = act</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CARRIAGECONTROL = cc</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RECORDTYPE = rct</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BLOCKSIZE = bl</TT>
<DL>
<DT>IOSTAT = ios
<DD>is an<B> input/output status specifier.</B>&nbsp; The integer variable or integer array element<TT> ios</TT> is defined with
zero if no error condition exists or a positive integer value if an error condition exists.
<DT>ERR = s
<DD>is an<B> error specifier</B> and<TT> s</TT> is a statement label.&nbsp; When an error occurs, execution is transferred to
the statement labelled by<TT> s.</TT>
<DT>EXIST = ex
<DD><TT> ex</TT> is a logical variable or logical array element.
<BR><BR>Inquire by file:&nbsp; The value .TRUE.&nbsp; is assigned if a file exists with the specified name; otherwise the
value .FALSE.&nbsp; is assigned.
<BR><BR>Inquire by unit:&nbsp; The value .TRUE.&nbsp; is assigned if the specified unit exists; otherwise the value .FALSE.
&nbsp;is assigned.
<DT>OPENED = od
<DD><TT> od</TT> is a logical variable or logical array element.
<BR><BR>Inquire by file:&nbsp; The value .TRUE.&nbsp; is assigned if the specified file is connected to a unit; otherwise
the value .FALSE.&nbsp; is assigned.
<BR><BR>Inquire by unit:&nbsp; The value .TRUE.&nbsp; is assigned if the specified unit is connected to a file; otherwise
the value .FALSE.&nbsp; is assigned.
<DT>NUMBER = num
<DD><TT> num</TT> is an integer variable or integer array element that is assigned the value of the unit number to which the file
is connected.&nbsp; If no unit is connected to the file then<TT> num</TT> becomes undefined.
<DT>NAMED = nmd
<DD><TT> nmd</TT> is a logical variable or logical array element name that is assigned the value .TRUE.&nbsp; if the file has
a name; otherwise the value .FALSE.&nbsp; is assigned.
<DT>NAME = fn
<DD><TT> fn</TT> is a character variable or character array element.&nbsp; Open Watcom FORTRAN 77 also permits<TT> fn</TT> to
be a character substring.
<BR><BR>It is assigned the name of the file, if the file has a name; otherwise it becomes undefined.&nbsp; The file name that
is returned need not be the same as that given in a<TT> FILE=</TT> specifier but it must be suitable for use in the<TT> FILE=</TT>
specification of an<TT> OPEN</TT> statement (e.g., the file name returned may have additional system qualifications attached
to it).
<DT>ACCESS = acc
<DD><TT> acc</TT> is a character variable or character array element.&nbsp; Open Watcom FORTRAN 77 also permits<TT> acc</TT> to
be a character substring.
<BR><BR>It is assigned the value<TT> 'SEQUENTIAL'</TT> if the file is connected for sequential access.&nbsp; It is assigned
the value<TT> 'DIRECT'</TT> if the file is connected for direct access.&nbsp; It is assigned an undefined value if there is
no connection.
<DT>SEQUENTIAL = seq
<DD><TT> seq</TT> is a character variable or character array element.&nbsp; Open Watcom FORTRAN 77 also permits<TT> seq</TT> to
be a character substring.
<BR><BR>It is assigned the value<TT> 'YES'</TT> if<TT> SEQUENTIAL</TT> is included in the set of allowed access methods for
the file, the value<TT> 'NO'</TT> if<TT> SEQUENTIAL</TT> is not included in the set of allowed access methods for the file,
or<TT> 'UNKNOWN'</TT> if Open Watcom FORTRAN 77 is unable to determine whether or not<TT> SEQUENTIAL</TT> is included in the
set of allowed access methods for the file.
<DT>DIRECT = dir
<DD><TT> dir</TT> is a character variable or character array element.&nbsp; Open Watcom FORTRAN 77 also permits<TT> dir</TT> to
be a character substring.
<BR><BR>It is assigned the value<TT> 'YES'</TT> if<TT> DIRECT</TT> is included in the set of allowed access methods for the
file, the value<TT> 'NO'</TT> if<TT> DIRECT</TT> is not included in the set of allowed access methods for the file, or<TT>
'UNKNOWN'</TT> if Open Watcom FORTRAN 77 is unable to determine whether or not<TT> DIRECT</TT> is included in the set of allowed
access methods for the file.
<DT>FORM = fm
<DD><TT> fm</TT> is a character variable or character array element.&nbsp; Open Watcom FORTRAN 77 also permits<TT> fm</TT> to
be a character substring.
<BR><BR>It is assigned the value<TT> 'FORMATTED'</TT> if the file is connected for formatted input/output, the value<TT> 'UNFORMATTED'</TT>
if the file is connected for unformatted input/output, or an undefined value if there is no connection.
<DT>FORMATTED = fmt
<DD><TT> fmt</TT> is a character variable or character array element.&nbsp; Open Watcom FORTRAN 77 also permits<TT> fmt</TT> to
be a character substring.
<BR><BR>It is assigned the value<TT> 'YES'</TT> if<TT> FORMATTED</TT> is included in the set of allowed forms for the file,
the value<TT> 'NO'</TT> if<TT> FORMATTED</TT> is not included in the set of allowed forms for the file, or<TT> 'UNKNOWN'</TT>
if Open Watcom FORTRAN 77 is unable to determine whether or not<TT> FORMATTED</TT> is included in the set of allowed forms
for the file.
<DT>UNFORMATTED = unf
<DD><TT> unf</TT> is a character variable or character array element.&nbsp; Open Watcom FORTRAN 77 also permits<TT> unf</TT> to
be a character substring.
<BR><BR>It is assigned the value<TT> 'YES'</TT> if<TT> UNFORMATTED</TT> is included in the set of allowed forms for the file,
the value<TT> 'NO'</TT> if<TT> UNFORMATTED</TT> is not included in the set of allowed forms for the file, or<TT> 'UNKNOWN'</TT>
if Open Watcom FORTRAN 77 is unable to determine whether or not<TT> UNFORMATTED</TT> is included in the set of allowed forms
for the file.
<DT>RECL = rcl
<DD><TT> rcl</TT> is an integer variable or integer array element that is assigned the value of the record length of the file
connected for direct access.&nbsp; If the file is connected for formatted input/output, the length is the number of characters.
&nbsp;If the file is connected for unformatted input/output, the length is measured in processor-dependent units (bytes).
&nbsp;See the compiler User's Guide for a discussion of record length or size.&nbsp; If there is no connection or if the file
is not connected for direct access then the value is undefined.&nbsp; The<TT> RECL=</TT> specifier is also allowed if the
file is connected for sequential access.
<DT>NEXTREC = nr
<DD><TT> nr</TT> is an integer variable or integer array element that is assigned the value<TT> n+1,</TT> where<TT> n</TT> is
the record number of the last record read or written on the file connected for direct access.&nbsp; If the file is connected
but no records have been read or written then the value is 1.&nbsp; If the file is not connected for direct access or if the
position of the file can not be determined because of an input/output error then<TT> nr</TT> becomes undefined.
<DT>BLANK = blnk
<DD><TT> blnk</TT> is a character variable or character array element.&nbsp; Open Watcom FORTRAN 77 also permits<TT> blnk</TT>
to be a character substring.
<BR><BR>It is assigned the value<TT> 'NULL'</TT> if null blank control is in effect for the file connected for formatted input/output,
and is assigned the value<TT> 'ZERO'</TT> if zero blank control is in effect for the file connected for formatted input/output.
&nbsp;If there is no connection, or if the file is not connected for formatted input/output,<TT> blnk</TT> becomes undefined.
<DT>ACTION = act
<DD><TT> act</TT> is a character variable or character array element.&nbsp; Open Watcom FORTRAN 77 also permits<TT> act</TT> to
be a character substring.
<BR><BR>It is assigned the value<TT> 'READ'</TT> if data can only be read from the file,<TT> 'WRITE'</TT> if data can only
be written from the file, and<TT> 'READWRITE'</TT> if data can be both read and written.
<DT>CARRIAGECONTROL = cc
<DD><TT> cc</TT> is a character variable or character array element.&nbsp; Open Watcom FORTRAN 77 also permits<TT> cc</TT> to
be a character substring.
<BR><BR>It is assigned the value<TT> 'YES'</TT> if the first character of each record is interpreted as a carriage control
character and<TT> 'NO'</TT> if no interpretation is placed on the first character of each record.
<DT>RECORDTYPE = rct
<DD><TT> rct</TT> is a character variable or character array element.&nbsp; Open Watcom FORTRAN 77 also permits<TT> rct</TT> to
be a character substring.
<BR><BR>It is assigned a value that represents the record type (or record structure) that is used for the file.&nbsp; The
value assigned depends on the system on which you are running the program.&nbsp; See the compiler User's Guide for a discussion
of record types.
<DT>BLOCKSIZE = bl
<DD><TT> bl</TT> is an integer variable or integer array element.
<BR><BR>It is assigned a value that represents the internal buffer size that is used for input/output operations on the file.
&nbsp;The value assigned depends on the system on which you are running the program.&nbsp; See the compiler User's Guide for
a discussion of default internal buffer size.
</DL>
<H3 ID="Definition_Status_of_Specifiers_M_Inquire_by_File"> Definition Status of Specifiers - Inquire by File </H3>
<BR>The following table summarizes which specifier variables or array elements become defined with values under what conditions
when using the<TT> FILE=</TT> specifier.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IOSTAT = ios&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(1)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EXIST = ex&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; (2)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPENED = od&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;(2)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NUMBER = num&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(4)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NAMED = nmd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;(3)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NAME = fn&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; (3)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ACCESS = acc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(5)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SEQUENTIAL = seq&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (3)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DIRECT = dir&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(3)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FORM = fm&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; (5)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FORMATTED = fmt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (3)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UNFORMATTED = unf&nbsp;&nbsp;&nbsp;&nbsp; (3)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RECL = rcl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; (5)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NEXTREC = nr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(5)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BLANK = blnk&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(5)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ACTION = act&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(5)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CARRIAGECONTROL = cc&nbsp; (5)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RECORDTYPE = rct&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (5)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BLOCKSIZE = bl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (5)</TT>
<OL>
<LI>The<TT> IOSTAT=</TT> specifier variable is always defined with the most recent error status.&nbsp; If an error occurs
during execution of the<TT> INQUIRE</TT> statement then the error status is defined with a positive integer; otherwise the
status is that of the most recent input/output statement which referenced that file.
<LI>The specifier always becomes defined unless an error condition occurs.
<LI>This specifier becomes defined with a value only if the file name specified in the<TT> FILE=</TT> specifier is an acceptable
file name and the named file exists.&nbsp; Also, no error condition can occur during the execution of the<TT> INQUIRE</TT>
statement.
<LI>This specifier becomes defined with a value if and only if<TT> od</TT> becomes defined with the value .TRUE..&nbsp; Also,
no error condition can occur during the execution of the<TT> INQUIRE</TT> statement.
<LI>This specifier<B> may</B> become defined with a value only if<TT> od</TT> becomes defined with the value .TRUE..&nbsp;
However, there may be other conditions under which this specifier does not become defined with a value.&nbsp; In other words,
(5) is a necessary, but not sufficient condition.&nbsp; For example,<TT> blnk</TT> is undefined if the file is not connected
for formatted input/output.
</OL>
<H3 ID="Definition_Status_of_Specifiers_M_Inquire_by_Unit"> Definition Status of Specifiers - Inquire by Unit </H3>
<BR>The following table summarizes which specifier variables or array elements become defined with values under what conditions
when using the<TT> UNIT=</TT> specifier.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IOSTAT = ios&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(1)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EXIST = ex&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; (2)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPENED = od&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;(2)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NUMBER = num&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(3)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NAMED = nmd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;(3)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NAME = fn&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; (3)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ACCESS = acc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(3)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SEQUENTIAL = seq&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (3)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DIRECT = dir&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(3)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FORM = fm&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; (3)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FORMATTED = fmt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (3)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UNFORMATTED = unf&nbsp;&nbsp;&nbsp;&nbsp; (3)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RECL = rcl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; (3)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NEXTREC = nr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(3)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BLANK = blnk&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(3)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ACTION = act&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(3)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CARRIAGECONTROL = cc&nbsp; (3)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RECORDTYPE = rct&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (3)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BLOCKSIZE = bl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (3)</TT>
<OL>
<LI>The<TT> IOSTAT=</TT> specifier variable is always defined with the most recent error status.&nbsp; If an error occurs
during execution of the<TT> INQUIRE</TT> statement then the error status is defined with a positive integer; otherwise the
status is that of the most recent input/output statement which referenced that unit.
<LI>This specifier always becomes defined unless an error condition occurs.
<LI>This specifier becomes defined with a value only if the specified unit exists and if a file is connected to the unit.
&nbsp;Also, no error condition can occur during the execution of the<TT> INQUIRE</TT> statement.
</OL>
<BR>For more information on input/output, see the chapter entitled <A HREF="#InputDOutput">Input/Output</A>.
<H2 ID="INTEGER_Statement"> INTEGER Statement </H2>
<BR>The<TT> INTEGER</TT> statement is a type declaration statement and can be used to declare a name to be of type integer.
&nbsp;The implicit type of the name, whether defined by the &quot;first letter rule&quot; (see the chapter entitled <A HREF="#Names__Data_Types_and_Constants">Names, Data Types and Constants</A>)
or by an<TT> IMPLICIT</TT> statement, is either confirmed or overridden.&nbsp; However, once a name has been declared to be
of type integer, it cannot appear in another type declaration statement.
<BR><BR>There are various forms of the<TT> INTEGER</TT> statement.&nbsp; The following sections describe them.
<H3 ID="Standard_INTEGER_Statement"> Standard INTEGER Statement </H3>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER name [,name] ...</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>name
<DD>is a variable name, array name, array declarator, symbolic name of a constant, function name or dummy procedure name.
</DL>
<BR>This form is the standard form of the<TT> INTEGER</TT> statement.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DIMENSION C(-5:5)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER A, B(10), C</TT>
<BR><BR>In the previous example,<TT> A</TT> is defined to be a variable of type integer and<TT> B</TT> and<TT> C</TT> are
defined to be arrays of type integer.
<H3 ID="Extended_INTEGER_Statement__Length_Specification"> Extended INTEGER Statement:&nbsp; Length Specification </H3>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER[*len[,]] name [,name] ...</TT></TT>&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>name
<DD>is one of the following forms:
<BR><BR><TT>v[*len]</TT>
<BR><BR><TT>a[*len](d)</TT>
<BR><BR><TT>a(d)[*len]</TT>
<DT>v
<DD>is a variable name, array name, symbolic name of a constant, function name or dummy procedure name.
<DT>a
<DD>is an array name.
<DT>(d)
<DD>is that part of the array declarator defining the dimensions of the array.
<DT>len
<DD>is called the<B> length specification</B> and is an unsigned positive integer constant or an integer constant expression enclosed
in parentheses whose value is 1, 2 or 4.
</DL>
<BR>This form of the<TT> INTEGER</TT> statement is a Open Watcom FORTRAN 77 extension to the FORTRAN 77 language.&nbsp; The
length specification specifies the number of bytes of storage that will be allocated for the name appearing in the<TT> INTEGER</TT>
statement.&nbsp; The default length specification is 4.&nbsp; A length specification of 1 or 2 does not change the data type;
it merely restricts the magnitude of the integer that can be represented.&nbsp; See the chapter entitled <A HREF="#Names__Data_Types_and_Constants">Names, Data Types and Constants</A>
for more information.
<BR><BR>The length specification immediately following the word<TT> INTEGER</TT> is the length specification for each entity
in the statement not having its own length specification.&nbsp; If a length specification is not specified the default length
specification is used.&nbsp; An entity with its own specification overrides the default length specification or the length
specification immediately following the word<TT> INTEGER.</TT>&nbsp; Note that for an array the length specification applies
to<B> each</B> element of the array.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DIMENSION C(-5:5)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER A, B*2(10), C*2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER*1 X</TT>
<BR><BR>In the previous example,<TT> X</TT> is declared to be a variable of type integer and occupying 1 byte of storage,<TT>
A</TT> is declared to be a variable of type integer and occupying 4 bytes of storage and<TT> B</TT> and<TT> C</TT> are declared
to be arrays of type integer with<B> each</B> element of the array occupying 2 bytes.
<H3 ID="Extended_INTEGER_Statement__Data_Initialization"> Extended INTEGER Statement:&nbsp; Data Initialization </H3>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER[*len[,]] name [/cl/] [,name[/cl/]] ...</TT></TT>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>name
<DD>is as described in the previous section.
<DT>len
<DD>is as described in the previous section.
<DT>cl
<DD>is a list of the form:
<BR><BR><TT>k [,k] ...</TT>
<DT>k
<DD>is one of the forms:
<BR><BR><TT>c</TT>
<BR><BR><TT>r*c</TT> (equivalent to<TT> r</TT> successive appearances of<TT> c)</TT>
<DT>c
<DD>is a constant or the symbolic name of a constant
<DT>r
<DD>is an unsigned positive integer constant or the symbolic name of a constant.
</DL>
<BR>This form of the<TT> INTEGER</TT> statement is an extension to the FORTRAN 77 language.&nbsp; The rules for data initialization
are the same as for the<TT> DATA</TT> statement.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER A/100/, B(10)/10*0/</TT>
<BR><BR>In the previous example,<TT> A</TT> is initialized with the integer constant<TT> 100</TT> and each element of the
array<TT> B</TT> is initialized with the integer constant<TT> 0.</TT>
<H2 ID="INTRINSIC_Statement"> INTRINSIC Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTRINSIC f [,f] ...</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>f
<DD>is the name of an intrinsic function name.
</DL>
<BR>An<TT> INTRINSIC</TT> statement is used to identify a symbolic name as the name of an intrinsic function.&nbsp; It also
allows a specific intrinsic function to be passed as an actual argument.&nbsp; The names of intrinsic functions for type conversion
(INT, IFIX, HFIX, IDINT, FLOAT, DFLOAT, SNGL, REAL, DREAL, DBLE, CMPLX, DCMPLX, ICHAR, CHAR), lexical relationship (LGE, LGT,
LLE, LLT), for choosing the largest or smallest value (MAX, MAX0, AMAX1, DMAX1, AMAX0, MAX1, MIN, MIN0, AMIN1, DMIN1, AMIN0,
MIN1), as well as ALLOCATED, ISIZEOF and LOC, must not be used as actual arguments.
<BR><BR>A generic intrinsic function does not lose its generic property if it appears in an<TT> INTRINSIC</TT> statement.
<BR><BR>A name must only appear in an<TT> INTRINSIC</TT> statement once.&nbsp; A symbolic name must not appear in both an<TT>
INTRINSIC</TT> and an<TT> EXTERNAL</TT> statement in a program unit.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTRINSIC SIN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALL SAM( SIN )</TT>
<BR><BR>In the previous example, the intrinsic function<TT> SIN</TT> was passed to the subroutine<TT> SAM.</TT>&nbsp; If the<TT>
INTRINSIC</TT> statement were eliminated then the variable<TT> SIN</TT> would be passed to the subroutine<TT> SAM.</TT>
<H2 ID="LOGICAL_Statement"> LOGICAL Statement </H2>
<BR>The<TT> LOGICAL</TT> statement is a type declaration statement and can be used to declare a name to be of type logical.
&nbsp;The implicit type of the name, whether defined by the &quot;first letter rule&quot; (see the chapter entitled <A HREF="#Names__Data_Types_and_Constants">Names, Data Types and Constants</A>)
or by an<TT> IMPLICIT</TT> statement, is either confirmed or overridden.&nbsp; However, once a name has been declared to be
of type logical, it cannot appear in another type declaration statement.
<BR><BR>There are various forms of the<TT> LOGICAL</TT> statement.&nbsp; The following sections describe them.
<H3 ID="Standard_LOGICAL_Statement"> Standard LOGICAL Statement </H3>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOGICAL name [,name] ...</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>name
<DD>is a variable name, array name, array declarator, symbolic name of a constant, function name or dummy procedure name.
</DL>
<BR>This form is the standard form of the<TT> LOGICAL</TT> statement.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DIMENSION C(-5:5)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOGICAL A, B(10), C</TT>
<BR><BR>In the previous example,<TT> A</TT> is defined to be a variable of type logical and<TT> B</TT> and<TT> C</TT> are
defined to be arrays of type logical.
<H3 ID="Extended_LOGICAL_Statement__Length_Specification"> Extended LOGICAL Statement:&nbsp; Length Specification </H3>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOGICAL[*len[,]] name [,name] ...</TT></TT>&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>name
<DD>is one of the following forms:
<BR><BR><TT>v[*len]</TT>
<BR><BR><TT>a[*len](d)</TT>
<BR><BR><TT>a(d)[*len]</TT>
<DT>v
<DD>is a variable name, array name, symbolic name of a constant, function name or dummy procedure name.
<DT>a
<DD>is an array name.
<DT>(d)
<DD>is that part of the array declarator defining the dimensions of the array.
<DT>len
<DD>is called the<B> length specification</B> and is an unsigned positive integer constant or an integer constant expression enclosed
in parentheses whose value is 1 or 4.
</DL>
<BR>This form of the<TT> LOGICAL</TT> statement is a Open Watcom FORTRAN 77 extension to the FORTRAN 77 language.&nbsp; The
length specification specifies the number of bytes of storage that will be allocated for the name appearing in the<TT> LOGICAL</TT>
statement.&nbsp; The default length specification is 4.&nbsp; A length specification of 1 only changes the storage requirement
from 4 bytes to 1 byte; the values of true and false can be represented regardless of the length specification.
<BR><BR>The length specification immediately following the word<TT> LOGICAL</TT> is the length specification for each entity
in the statement not having its own length specification.&nbsp; If a length specification is not specified the default length
specification is used.&nbsp; An entity with its own specification overrides the default length specification or the length
specification immediately following the word<TT> LOGICAL.</TT>&nbsp; Note that for an array the length specification applies
to<B> each</B> element of the array.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DIMENSION C(-5:5)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOGICAL A, B*1(10), C*1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOGICAL*4 X</TT>
<BR><BR>In the previous example,<TT> X</TT> is declared to be a variable of type logical and occupying 4 bytes of storage,<TT>
A</TT> is declared to be a variable of type logical and occupying 4 bytes of storage and<TT> B</TT> and<TT> C</TT> are declared
to be arrays of type logical with<B> each</B> element of the array occupying 1 byte.
<H3 ID="Extended_LOGICAL_Statement__Data_Initialization"> Extended LOGICAL Statement:&nbsp; Data Initialization </H3>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOGICAL[*len[,]] name [/cl/] [,name[/cl/]] ...</TT></TT>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>name
<DD>is as described in the previous section.
<DT>len
<DD>is as described in the previous section.
<DT>cl
<DD>is a list of the form:
<BR><BR><TT>k [,k] ...</TT>
<DT>k
<DD>is one of the forms:
<BR><BR><TT>c</TT>
<BR><BR><TT>r*c</TT> (equivalent to<TT> r</TT> successive appearances of<TT> c)</TT>
<DT>c
<DD>is a constant or the symbolic name of a constant
<DT>r
<DD>is an unsigned positive integer constant or the symbolic name of a constant.
</DL>
<BR>This form of the<TT> LOGICAL</TT> statement is an extension to the FORTRAN 77 language.&nbsp; The rules for data initialization
are the same as for the<TT> DATA</TT> statement.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOGICAL A/.TRUE./, B(10)/10*.FALSE./</TT>
<BR><BR>In the previous example,<TT> A</TT> is initialized with the logical constant<TT> .TRUE.</TT>&nbsp; and each element
of the array<TT> B</TT> is initialized with the logical constant<TT> .FALSE..</TT>
<H2 ID="LOOP_Statement"> LOOP Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOOP&nbsp;&nbsp;&nbsp; [:block-label]</TT></TT>&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR>The<TT> LOOP</TT> statement is used in conjunction with the structured<TT> END LOOP</TT> or<TT> UNTIL</TT> statement.
&nbsp;The<TT> LOOP</TT> statement marks the beginning of a sequence of statements which are to be repeated.&nbsp; The<TT>
END LOOP</TT> or<TT> UNTIL</TT> statement marks the end of the loop.&nbsp; The LOOP-block is executed until control is transferred
out of the LOOP-block or the logical expression (or integer arithmetic expression) of the<TT> UNTIL</TT> statement has a true
(or non-zero) value.
<BR><BR>The<TT> QUIT</TT> statement may be used to transfer control out of a LOOP-block.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOOP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ *, X</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( X .GT. 99.0 ) QUIT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, X</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END LOOP</TT>
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X = 1.0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOOP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, X, SQRT( X )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X = X + 1.0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UNTIL( X .GT. 10.0 )</TT>
<BR><BR>An optional block label may be specified with the<TT> LOOP</TT> statement.
<BR><BR>For more information, see the chapter entitled <A HREF="#Program_Structure_Control_Statements">Program Structure Control Statements</A>.
<H2 ID="MAP_Statement"> MAP Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MAP</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR>The<TT> MAP</TT> statement is used in conjunction with the<TT> END MAP</TT> declarative statement.&nbsp; The<TT> MAP</TT>
statement marks the start of a memory mapping structure.&nbsp; A<TT> MAP</TT> structure must appear within a<TT> UNION</TT>
block.&nbsp; Any number of variables of any type may appear within a memory map.&nbsp; At least two<TT> MAP</TT> structures
must appear within a<TT> UNION</TT> block.&nbsp; A<TT> UNION</TT> block permits the mapping of the same storage in several
different ways.
<BR><BR>The following example maps out a 4-byte integer on an Intel 80x86-based processor.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STRUCTURE /MAPINT/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UNION</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MAP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; INTEGER*4 LONG</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END MAP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MAP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; INTEGER*2 LO_WORD</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; INTEGER*2 HI_WORD</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END MAP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MAP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; INTEGER*1 BYTE_0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; INTEGER*1 BYTE_1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; INTEGER*1 BYTE_2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; INTEGER*1 BYTE_3</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END MAP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END UNION</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END STRUCTURE</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RECORD /MAPINT/ I</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I%LONG = '01020304'x</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT '(2Z4)', I%LO_WORD, I%HI_WORD</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>For more information, see the chapter entitled <A HREF="#Structures__Unions_and_Records">Structures, Unions and Records</A>.
<H2 ID="NAMELIST_Statement"> NAMELIST Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NAMELIST /name/ vlist [[,]/name/ vlist] ...</TT></TT>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>name
<DD>is the name, enclosed in slashes, of a group of variables.&nbsp; It may not be the same as a variable or array name.
<DT>vlist
<DD>is a list of variable names and array names separated by commas.
</DL>
<BR>The<TT> NAMELIST</TT> statement is used to declare a group name for a set of variables so that they may be read or written
with a single namelist-directed<TT> READ</TT>,<TT> WRITE</TT>, or<TT> PRINT</TT> statement.
<BR><BR>The list of variable or array names belonging to a<TT> NAMELIST</TT> name ends with a new<TT> NAMELIST</TT> name enclosed
in slashes or with the end of the<TT> NAMELIST</TT> statement.&nbsp; The same variable name may appear in more than one namelist.
<BR><BR>A dummy variable, dummy array name, or allocatable array may not appear in a<TT> NAMELIST</TT> list.&nbsp; Also, a
variable whose type is a user-defined structure may not appear in a<TT> NAMELIST</TT> list.
<BR><BR>The<TT> NAMELIST</TT> statement must precede any statement function definitions and all executable statements.&nbsp;
A<TT> NAMELIST</TT> name must be declared in a<TT> NAMELIST</TT> statement and may be declared only once.&nbsp; The name may
appear only in input/output statements.&nbsp; The<TT> READ</TT>,<TT> WRITE</TT>, and<TT> PRINT</TT> statements may be used
to transmit data between a file and the variables specified in a namelist.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*20 NAME</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*20 STREET</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*15 CITY</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*20 STATE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*20 COUNTRY</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*10 ZIP_CODE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER AGE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER MARKS(10)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NAMELIST /PERSON/ NAME, STREET, CITY, STATE,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; COUNTRY, ZIP_CODE, AGE, MARKS</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPEN( UNIT=1, FILE='PEOPLE' )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOOP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ( UNIT=1, FMT=PERSON, END=99
)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WRITE( UNIT=6, FMT=PERSON )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDLOOP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 99&nbsp;&nbsp;&nbsp; CLOSE( UNIT=1 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>The following example shows another form of a namelist-directed<TT> READ</TT> statement.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*20 NAME</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*20 STREET</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*15 CITY</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*20 STATE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*20 COUNTRY</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*10 ZIP_CODE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER AGE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER MARKS(10)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NAMELIST /PERSON/ NAME, STREET, CITY, STATE,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; COUNTRY, ZIP_CODE, AGE, MARKS</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ PERSON</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT PERSON</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>The input data must be in a special format.&nbsp; The first character in each record must be blank.&nbsp; The second
character in the first record of a group of data records must be an ampersand (&amp;) or dollar sign ($) immediately followed
by the<TT> NAMELIST</TT> name.&nbsp; The<TT> NAMELIST</TT> name must be followed by a blank and must not contain any imbedded
blanks.&nbsp; This name is followed by data items separated by commas.&nbsp; The end of a data group is signaled by the character
&quot;&amp;&quot; or &quot;$&quot;, optionally followed by the string &quot;END&quot;.&nbsp; If the &quot;&amp;&quot; character
was used to start the group, then it must be used to end the group.&nbsp; If the &quot;$&quot; character was used to start
the group, then it must be used to end the group.
<BR><BR>The form of the data items in an input record is:
<DL>
<DT>Name = Constant
<DD>The name may be a variable name or an array element name.&nbsp; The constant may be integer, real, complex, logical or character.
&nbsp;Logical constants may be in the form &quot;T&quot; or &quot;.TRUE&quot; and &quot;F&quot; or &quot;.FALSE&quot;.&nbsp;
Character constants must be contained within apostrophes.&nbsp; Subscripts must be of integer type.
<DT>ArrayName = Set of Constants
<DD>The set of constants consists of constants of the type integer, real, complex, logical or character.&nbsp; The constants are
separated by commas.&nbsp; The number of constants must be less than or equal to the number of elements in the array.&nbsp;
Successive occurrences of the same constant may be represented in the form<TT> r*constant,</TT> where<TT> r</TT> is a non-zero
integer constant specifying the number of times the constant is to occur.
</DL>
<BR>The variable and array names specified in the input file must appear in the<TT> NAMELIST</TT> list, but the order is not
important.&nbsp; A name that has been made equivalent to a name in the input data cannot be substituted for that name in the<TT>
NAMELIST</TT> list.&nbsp; The list can contain names of items in<TT> COMMON</TT> but must not contain dummy argument names.
<BR><BR>Each data record must begin with a blank followed by a complete variable or array name or constant.&nbsp; Embedded
blanks are not permitted in name or constants.&nbsp; Trailing blanks after integers and exponents are treated as zeros.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;PERSON</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NAME = 'John Doe'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STREET = '22 Main St.' CITY = 'Smallville'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STATE = 'Texas'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; COUNTRY
= 'U.S.A.'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ZIP_CODE = '78910-1203'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MARKS = 73, 82, 3*78, 89, 2*93, 91, 88</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AGE = 23</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;END</TT>
<BR><BR>The form of the data items in an output record is suitable for input using a namelist-directed<TT> READ</TT> statement.
<OL>
<LI>Output records are written using the ampersand character (&amp;), not the dollar sign ($), although the dollar sign is
accepted as an alternative during input.&nbsp; That is, the output data is preceded by &quot;&amp;name&quot; and is followed
by &quot;&amp;END&quot;.
<LI>All variable and array names specified in the<TT> NAMELIST</TT> list and their values are written out, each according
to its type.
<LI>Character data is enclosed in apostrophes.
<LI>The fields for the data are made large enough to contain all the significant digits.
<LI>The values of a complete array are written out in columns.
</OL>
<BR>For more information, see the chapters entitled <A HREF="#Format">Format</A> and <A HREF="#InputDOutput">Input/Output</A>.
<H2 ID="OPEN_Statement"> OPEN Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPEN (oplist)</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>oplist
<DD>must include the<TT> UNIT=</TT> specifier and may include at most one of each of the open specifiers listed below.&nbsp; Specifiers
are separated by commas.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [UNIT =] u</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IOSTAT = ios</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ERR = s</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FILE = fin</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STATUS = sta</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ACCESS = acc</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FORM = fm</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RECL = rcl</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BLANK = blnk</TT>
<BR><BR>As an extension to the FORTRAN 77 language, the following inquiry specifiers are also supported.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ACTION = act</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CARRIAGECONTROL = cc</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RECORDTYPE = rct</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BLOCKSIZE = bl</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SHARE = shr</TT>
</DL>
<BR>The<TT> OPEN</TT> statement may be used to connect an existing file to a unit, create a file that is preconnected, create
a file and connect it to a unit, or change certain specifications of a connection between a file and a unit.
<DL>
<DT>Open Specifiers
<DD>
<DT>[UNIT =] u
<DD>
<BR><BR><TT>u</TT> is an<B> external unit identifier.</B>&nbsp; An external unit identifier is a non-negative integer expression.
&nbsp;If the optional<TT> UNIT=</TT> specifier is omitted then the specifier must be the first item in the list of specifiers.
<DT>IOSTAT = ios
<DD>
<BR><BR>is an<B> input/output status specifier.</B>&nbsp; The integer variable or integer array element<TT> ios</TT> is defined
with zero if no error condition exists or a positive integer value if an error condition exists.
<DT>ERR = s
<DD>
<BR><BR>is an<B> error specifier</B> and<TT> s</TT> is a statement label.&nbsp; When an error occurs, execution is transferred
to the statement labelled by<TT> s.</TT>
<DT>FILE = fin
<DD>
<BR><BR><TT>fin</TT> is a character expression whose value when trailing blanks are removed is the name of a file to be connected
to the specified unit.&nbsp; If this specifier is omitted and the unit is not connected to a file, it becomes connected to
a file determined by Open Watcom FORTRAN 77.&nbsp; The name established by Open Watcom FORTRAN 77 is described in the section
entitled <A HREF="#Units">Units</A> of the chapter entitled <A HREF="#InputDOutput">Input/Output</A>.
<DT>STATUS = sta
<DD>
<BR><BR><TT>sta</TT> is a character expression whose value when trailing blanks are removed is<TT> 'OLD', 'NEW', 'SCRATCH',</TT>
or<TT> 'UNKNOWN'.</TT>
<DL>
<DT>OLD
<DD>When<TT> OLD</TT> is specified, a<TT> FILE=</TT> specifier must be given.&nbsp; The file must exist.
<DT>NEW
<DD>When<TT> NEW</TT> is specified, a<TT> FILE=</TT> specifier must be given.&nbsp; The file must not exist.&nbsp; Successful
execution of the<TT> OPEN</TT> statement creates the file and changes the status to<TT> OLD.</TT>
<DT>SCRATCH
<DD><TT> SCRATCH</TT> may only be specified for an unnamed file (i.e.<TT>&nbsp; FILE=</TT> is not allowed).&nbsp; When the file
is closed, it is deleted.
<DT>UNKNOWN
<DD>If<TT> UNKNOWN</TT> is specified, the status is ignored.&nbsp; If the<TT> STATUS=</TT> specifier is omitted then<TT> UNKNOWN</TT>
is assumed.
</DL>
<DT>ACCESS = acc
<DD>
<BR><BR><TT>acc</TT> is a character expression whose value when trailing blanks are removed is<TT> 'SEQUENTIAL'</TT> or<TT>
'DIRECT'.</TT>&nbsp; It specifies the access method for the file.&nbsp; If the<TT> ACCESS=</TT> specifier is omitted then<TT>
'SEQUENTIAL'</TT> is assumed.&nbsp; If the file exists then the access method must be in the set of allowed access methods
for the file.&nbsp; If the file does not exist then the file is created with a set of allowed access methods that includes
the specified access method.
<BR>Open Watcom FORTRAN 77 also supports access<TT> 'APPEND'</TT> which is a form of sequential access in which the file is
positioned at the endfile record.&nbsp; The file must exist or the append access method must be in the set of allowed access
methods for the file.&nbsp; In all other respects, the file is treated as if<TT> 'SEQUENTIAL'</TT> had been specified.
<DT>FORM = fm
<DD>
<BR><BR><TT>fm</TT> is a character expression whose value when trailing blanks are removed is<TT> 'FORMATTED'</TT> or<TT>
'UNFORMATTED'.</TT>&nbsp; It specifies that the file is being connected for formatted or unformatted input/output.&nbsp; If
the<TT> FORM=</TT> specifier is omitted and the file is being connected for direct access then<TT> 'UNFORMATTED'</TT> is assumed.
&nbsp;If the<TT> FORM=</TT> specifier is omitted and the file is being connected for sequential access then<TT> 'FORMATTED'</TT>
is assumed.&nbsp; If the file exists then the specified form must be included in the set of allowed forms for the file.&nbsp;
If the file does not exist then the file is created with a set of allowed forms that includes the specified form.
<DT>RECL = rcl
<DD>
<BR><BR><TT>rcl</TT> is an integer expression whose value must be positive.&nbsp; It specifies the length of each record in
a file being connected for direct access.&nbsp; If the file is being connected for direct access, this specifier must be given;
otherwise it must be omitted.&nbsp; Open Watcom FORTRAN 77 allows the<TT> RECL=</TT> specifier for files opened for sequential
access.
<DT>BLANK = blnk
<DD>
<BR><BR><TT>blnk</TT> is a character expression whose value when trailing blanks are removed is<TT> 'NULL'</TT> or<TT> 'ZERO'.</TT>
&nbsp;If<TT> 'NULL'</TT> is specified then all blank characters in numeric formatted input fields are ignored except that
an entirely blank field has a value of zero.&nbsp; If<TT> 'ZERO'</TT> is specified then all blank characters other than leading
blanks are treated as zeroes.&nbsp; If this specifier is omitted then<TT> 'NULL'</TT> is assumed.&nbsp; This specifier may
only be present for a file being connected for formatted input/output.
<DT>ACTION = act
<DD>
<BR><BR><TT>act</TT> is a character expression whose value when trailing blanks are removed is<TT> 'READ', 'WRITE'</TT> or<TT>
'READWRITE'.</TT>&nbsp; If<TT> 'READ'</TT> is specified, data can only be read from the file.&nbsp; If<TT> 'WRITE'</TT> is
specified, data can only be written to the file.&nbsp; If<TT> 'READWRITE'</TT> is specified, data can both be read and written.
&nbsp;The default is<TT> 'READWRITE'.</TT>
<DT>CARRIAGECONTROL = cc
<DD>
<BR><BR><TT>cc</TT> is a character expression whose value when trailing blanks are removed is<TT> 'YES',</TT> or<TT> 'NO'.</TT>
&nbsp;If<TT> 'YES'</TT> is specified, Open Watcom FORTRAN 77 will automatically add an extra character at the beginning of
each record.&nbsp; This character will be interpreted as a carriage control character.&nbsp; If<TT> 'NO'</TT> is specified,
records will be written to the file without adding a carriage control character at the beginning of the record.&nbsp; The
default is<TT> 'NO'.</TT>
<DT>RECORDTYPE = rct
<DD>
<BR><BR><TT>rct</TT> is a character expression whose value when trailing blanks are removed specifies the type of record (or
record structure) to be used for the file.&nbsp; The allowed values for<TT> rct</TT> depend on the system on which you are
running the program.&nbsp; See the compiler User's Guide for a discussion of the<TT> RECORDTYPE=</TT> specifier.
<DT>BLOCKSIZE = bl
<DD>
<BR><BR><TT>bl</TT> is an integer expression whose value specifies the internal buffer size to be used for file input/output.
&nbsp;The allowed values for<TT> bl</TT> depend on the system on which you are running the program.&nbsp; Generally, the larger
the buffer, the faster the input/output.&nbsp; See the compiler User's Guide for a discussion of the<TT> BLOCKSIZE=</TT> specifier.
<DT>SHARE = shr
<DD>
<BR><BR><TT>shr</TT> is a character expression whose value when trailing blanks are removed specifies the way in which other
processes can simultaneously access the file.&nbsp; The allowed values for<TT> shr</TT> depend on the system on which you
are running the program.&nbsp; See the compiler User's Guide for a discussion of the<TT> SHARE=</TT> specifier.
</DL>
<BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPEN( UNIT=1, FILE='TEST', STATUS='UNKNOWN',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ACCESS='SEQUENTIAL',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FORM='FORMATTED', BLANK='ZERO'
)</TT>
<BR><BR>In the above example, the file<TT> 'TEST',</TT> containing FORMATTED records, is connected to unit 1.&nbsp; The status
of the file is<TT> 'UNKNOWN'</TT> since we do not know if it already exists.&nbsp; We will access the file sequentially, using
formatted input/output statements.&nbsp; Blanks in numeric input data are to be treated as zeroes.
<BR><BR><B>Notes:</B>
<OL>
<LI>If the unit is already connected to a file that exists, the execution of an<TT> OPEN</TT> statement for that unit is permitted.
<DL>
<DT>(a)
<DD>If the same file is opened then only the<TT> BLANK=</TT> specifier may be different.&nbsp; The same file is opened if no<TT>
FILE=</TT> specifier was given or if the<TT> FILE=</TT> specifier refers to the same file.
<DT>(b)
<DD>If a different file is opened then the currently connected file is automatically closed.
</DL>
<LI>If the file to be connected to the unit does not exist, but is already preconnected to the unit, any properties specified
in the<TT> OPEN</TT> statement are merged with and supersede those of the preconnection.&nbsp; For example, the<TT> RECL=</TT>
specification will override the record length attribute defined by a preconnection of the file.
<LI>The same file may not be connected to two or more different units.
</OL>
<BR>For more information on input/output, see the chapter entitled <A HREF="#InputDOutput">Input/Output</A>.
<H2 ID="OTHERWISE_Statement"> OTHERWISE Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OTHERWISE</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR>The<TT> OTHERWISE</TT> statement is used in conjunction with the<TT> SELECT</TT> statement.&nbsp; The<TT> OTHERWISE</TT>
statement marks the start of a new<TT> CASE</TT> block which is a series of zero or more statements ending in an<TT> END SELECT</TT>
statement.
<BR><BR>When this statement is used and the value of a<B> case expression</B> is not found in any<B> case list</B> then control
of execution is transferred to the first executable statement following the<TT> OTHERWISE</TT> statement.
<BR><BR>The<TT> CASE DEFAULT</TT> statement may be used in place of the<TT> OTHERWISE</TT> statement.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SELECT CASE ( CH )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CASE ( 'a' : 'z' )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'Lower case letter'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CASE ( 'A' : 'Z' )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'Upper case letter'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CASE ( '0' : '9' )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'Digit'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OTHERWISE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'Special character'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END SELECT</TT>
<BR><BR>In the above example, if the character<TT> CH</TT> is not a letter or digit then the<TT> OTHERWISE</TT> block is executed.
<DL>
<DT>Note:
<DD>The<TT> OTHERWISE</TT> or<TT> CASE DEFAULT</TT> block must follow all other<TT> CASE</TT> blocks.
</DL>
<BR>For more information, see the chapter entitled <A HREF="#Program_Structure_Control_Statements">Program Structure Control Statements</A>.
<H2 ID="PARAMETER_Statement"> PARAMETER Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PARAMETER (p=e [,p=e] ...)</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>p
<DD>is a symbolic name.
<DT>e
<DD>is a constant expression.&nbsp; Refer to the chapter entitled <A HREF="#Expressions">Expressions</A> for more information.
</DL>
<BR><TT>p</TT> is known as a symbolic constant whose value is determined by the value of the expression<TT> e</TT> according
to the rules of assignment as described in the chapter entitled <A HREF="#Assignment_Statements">Assignment Statements</A>.
&nbsp;Any symbolic constant appearing in expression<TT> e</TT> must have been previously defined in the same or a previous<TT>
PARAMETER</TT> statement in the same program unit.&nbsp; A symbolic constant may not be defined more than once in a program
unit.
<BR><BR>If the symbolic name<TT> p</TT> is of type integer, real, double precision or complex then the corresponding expression<TT>
e</TT> must be an arithmetic constant expression (see the chapter entitled <A HREF="#Expressions">Expressions</A>).&nbsp;
If the symbolic name<TT> p</TT> is of type character or logical then the expression<TT> e</TT> must be a character constant
expression or a logical constant expression respectively (see the chapter entitled <A HREF="#Expressions">Expressions</A>).
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PARAMETER (PI=3.14159,BUFFER=80,PIBY2=PI/2)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PARAMETER (ERRMSG='AN ERROR HAS OCCURRED')</TT>
<BR><BR>If a symbolic constant is not of default implied type, its type must be specified in an<TT> IMPLICIT</TT> statement
or a type statement before its occurrence in a<TT> PARAMETER</TT> statement.&nbsp; Similarly, if the length of a character
symbolic constant is not the default length of 1, its length must be specified in an<TT> IMPLICIT</TT> statement or a type
statement before its occurrence in a<TT> PARAMETER</TT> statement.
<H2 ID="PAUSE_Statement"> PAUSE Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PAUSE [n]</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>n
<DD>is a character constant or an unsigned integer constant of no more than five digits.
<BR><BR>Open Watcom FORTRAN 77 allows<TT> n</TT> to be any unsigned integer constant.
</DL>
<BR>Execution of a<TT> PAUSE</TT> statement causes a cessation of execution of the program.&nbsp; Execution of the program
may be resumed by the program operator by pressing the terminal line entering key (e.g., ENTER or RETURN).&nbsp; The<TT> PAUSE</TT>
statement may appear in any program unit.
<BR><BR>If the Open Watcom FORTRAN 77 debugger was requested then execution of the<TT> PAUSE</TT> statement will cause entry
into the debugger.&nbsp; Program execution may be resumed by issuing the debugger &quot;go&quot; command.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PAUSE 4341</TT>
<BR><BR>The four digit number<TT> 4341</TT> is displayed on the terminal.&nbsp; The program temporarily ceases execution.
&nbsp;Execution is resumed by pressing the terminal line entering key.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PAUSE 'Ready the paper and then resume execution'</TT>
<BR><BR>The character string
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Ready the paper and then resume execution</TT>
<BR><BR>is displayed on the terminal.&nbsp; Execution of the program may be resumed.
<H2 ID="PRINT_Statement"> PRINT Statement </H2>
<BR>Two forms of the<TT> PRINT</TT> statement are supported by Open Watcom FORTRAN 77.
<H3 ID="Standard_PRINT_Statement"> Standard PRINT Statement </H3>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT f [,olist]</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>f
<DD>is a format identifier.
<DT>olist
<DD>is an optional output list.
</DL>
<H3 ID="Extended_PRINT_Statement"> Extended PRINT Statement </H3>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT, olist</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>olist
<DD>is an output list.
</DL>
<H3 ID="Description_of_PRINT_Statement"> Description of PRINT Statement </H3>
<BR>The<TT> PRINT</TT> statement is used to transfer data from the executing FORTRAN program to an external device or file.
<BR><BR><B>Format Identifier -</B> A format identifier is one of the following:
<OL>
<LI>A statement label of a<TT> FORMAT</TT> statement that appears in the same program unit as the format identifier.
<LI>An integer variable name that has been assigned the statement label of a<TT> FORMAT</TT> statement that appears in the
same program unit as the format identifier (see the<TT> ASSIGN</TT> statement).
<LI>An integer array name.
<LI>A character array name.
<LI>Any character expression except one involving the concatenation of an operand whose length specification is<TT> (*)</TT>
unless the operand is a symbolic constant (see the<TT> PARAMETER</TT> statement).
<LI>An asterisk<TT> (*),</TT> indicating<B> list-directed</B> formatting.
<BR><BR>Open Watcom FORTRAN 77 supports a variation of<B> list-directed</B> formatting in which the asterisk<TT> (*)</TT>
may be omitted.&nbsp; It is equivalent to
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; PRINT * [,olist]</TT>
<LI>A<TT> NAMELIST</TT> name, indicating<B> namelist-directed</B> formatting.
</OL>
<BR><B>Output list -</B> An output list may contain one or more of the following:
<OL>
<LI>A variable name.
<LI>An array element name.
<LI>A character substring name.
<LI>An array name except an assumed-size dummy array.
<LI>Any other expression except a character expression involving concatenation of an operand whose length specification is
an asterisk in parentheses unless the operand is the symbol name of a constant (since the length can be determined at compile
time).
<LI>An implied-DO list of the form:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ( dlist, i = e1, e2 [,e3] )</TT>
<BR><BR>where<TT> dlist</TT> is composed of one or more of items (1) through (6).
</OL>
<BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*5 S</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; COMPLEX C</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S = 'Hello'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I = 123</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X = 12.5</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C = (12.5,4.58)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, S, I, X, C</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>The above example illustrates<B> list-directed</B> formatting using the<TT> PRINT</TT> statement.&nbsp; The asterisk
specifies that the variables in the output list are to be displayed in some format that is appropriate to the type of the
variable (hence the term &quot;list-directed&quot;).&nbsp; The CHARACTER variable<TT> S</TT> is printed using a suitable<TT>
A</TT> format descriptor.&nbsp; The INTEGER variable<TT> I</TT> is printed using a suitable<TT> I</TT> format descriptor.
&nbsp;The REAL variable<TT> X</TT> is printed using a suitable<TT> G</TT> format descriptor.&nbsp; The COMPLEX variable<TT>
C</TT> is printed using a suitable<TT> G</TT> format descriptor and is displayed with enclosing parentheses and a comma.&nbsp;
Output from the above program would resemble the following.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Hello&nbsp;&nbsp;&nbsp; 123&nbsp;&nbsp;&nbsp; 12.5000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (12.5000000,4.5799999)</TT>
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*5 S</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; COMPLEX C</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S = 'Hello'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I = 123</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X = 12.5</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C = (12.5,4.58)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT, S, I, X, C</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>The above example illustrates a Open Watcom FORTRAN 77 extension of<B> list-directed</B> formatting using the<TT>
PRINT</TT> statement.&nbsp; The asterisk is omitted but the results are exactly the same as in the previous example.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT 100, X, Y, Z</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 100&nbsp;&nbsp; FORMAT( 3F10.5 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT '( 3F10.5 )', X, Y, Z</TT>
<BR><BR>The above gives two examples of the<TT> PRINT</TT> statement.&nbsp; In both cases, the format conversion is identical
but it was specified in different ways.&nbsp; When executed, the effect of both<TT> PRINT</TT> statements is the same.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT '(1X,100A1)', ('*',I=1,J)</TT>
<BR><BR>The above example illustrates a technique for producing histograms using the implied DO-loop.&nbsp; Each time this
statement is executed, a number of asterisks are printed, depending on the value of<TT> J.</TT>
<BR><BR><B>Notes:</B>
<OL>
<LI>The<TT> PRINT</TT> statement is implicitly a formatted output statement.
<LI>The unit number that is<B> implicitly</B> used in the<TT> PRINT</TT> statement is unit number 6.
<LI>If no output list is specified then the effect of the<TT> PRINT</TT> statement is to produce one or more records whose
characters are all blanks.
<LI>FORTRAN 77 leaves the format of output in list-directed formatting to the discretion of Open Watcom FORTRAN 77.&nbsp;
Hence other FORTRAN compilers may produce different results.&nbsp; If the format of output must be consistent from one compiler
to the next then list-directed formatting should<B> not</B> be used.
<LI>An implication of point (6) above is that nesting of implied-DO lists is permitted.&nbsp; For example, the output list
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ( (A(I,J), B(I,J), J = 1, 5), I = 1, 10 )</TT>
<BR><BR>may be broken down into the following components:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A(I,J), B(I,J)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (....dlist1...., J = 1, 5)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ( .....dlist2..............., I = 1, 10 )</TT>
</OL>
<BR>For more information on input/output, see the chapter entitled <A HREF="#InputDOutput">Input/Output</A>.&nbsp; For more
information on formatted input/output, see the chapter entitled <A HREF="#Format">Format</A>.
<H2 ID="PROGRAM_Statement"> PROGRAM Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PROGRAM pgm</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>pgm
<DD>is the symbolic name of the main program.
</DL>
<BR>A<TT> PROGRAM</TT> statement is optional in an executable program.&nbsp; If it does appear, it must be the first statement
in the main program.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PROGRAM CALC</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALL COMPUTE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>The main program can contain any Open Watcom FORTRAN 77 statement except a<TT> FUNCTION</TT>,<TT> SUBROUTINE</TT>,<TT>
BLOCK DATA</TT>,<TT> RETURN</TT> or<TT> ENTRY</TT> statement.&nbsp; Note that a<TT> SAVE</TT> statement is allowed but has
no effect in the main program.
<H2 ID="QUIT_Statement"> QUIT Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; QUIT&nbsp;&nbsp;&nbsp; [: block-label]</TT></TT>&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR>The<TT> QUIT</TT> statement may be used to cause a transfer of control to the first executable statement that follows
the terminal statement of the block which contains it.&nbsp; Examples of such terminal statements are<TT> ADMIT</TT>,<TT>
CASE</TT>,<TT> END DO</TT>,<TT> END LOOP</TT>,<TT> END WHILE</TT>,<TT> UNTIL</TT>, etc.&nbsp; If<TT> block-label</TT> is present
then control is transferred out of the block identified by that block label.&nbsp; The<TT> QUIT</TT> statement is an extension
to the FORTRAN 77 language.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOOP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WRITE( UNIT=*, FMT='(A)' ) 'Enter
a number'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ( UNIT=*, FMT='(F10.4)',
IOSTAT=IOS ) X</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( IOS .NE. 0 ) QUIT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( X .LT. 0 ) QUIT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, X, SQRT( X )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END LOOP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>For more information, see the chapter entitled <A HREF="#Program_Structure_Control_Statements">Program Structure Control Statements</A>.
<H2 ID="READ_Statement"> READ Statement </H2>
<BR>Three forms of the<TT> READ</TT> statement are supported by Open Watcom FORTRAN 77.
<H3 ID="Standard_READ_Statement"> Standard READ Statement </H3>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ (cilist) [ilist]</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ f [,ilist]</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>cilist
<DD>is a control information list of specifiers separated by commas:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [UNIT =] u</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [FMT =] f</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; REC = rn</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; IOSTAT = ios</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ERR = s</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; END = s</TT>
<DT>f
<DD>is a format identifier.
<DT>ilist
<DD>is an optional input list.
</DL>
<H3 ID="Extended_READ_Statement"> Extended READ Statement </H3>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ, ilist</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>ilist
<DD>is an input list.
</DL>
<H3 ID="Description_of_READ_Statement"> Description of READ Statement </H3>
<BR>The<TT> READ</TT> statement is used to transfer data from a device or file into the executing FORTRAN program.&nbsp; As
shown above, Open Watcom FORTRAN 77 supports three forms of the<TT> READ</TT> statement.
<DL>
<DT>Control Information List and Format Identifier
<DD>
<DT>[UNIT =] u
<DD>
<BR><BR><TT>u</TT> is an<B> external unit identifier</B> or an<B> internal file identifier.</B>
<OL>
<LI>An external unit identifier is a non-negative integer expression or an asterisk<TT> (*)</TT> in which case unit 5 is assumed.
<LI>An internal file identifier is the name of a character variable, character array, character array element, or character
substring.
</OL>
<BR>If the optional<TT> UNIT=</TT> specifier is omitted then the unit specifier must be the first item in the list of specifiers.
<DT>[FMT =] f
<DD>
<BR><BR><TT>f</TT> is a<B> format identifier.</B>&nbsp; A format identifier is one of the following:
<OL>
<LI>A statement label of a<TT> FORMAT</TT> statement that appears in the same program unit as the format identifier.
<LI>An integer variable name that has been assigned the statement label of a<TT> FORMAT</TT> statement that appears in the
same program unit as the format identifier (see the<TT> ASSIGN</TT> statement).
<LI>An integer array name.
<LI>A character array name.
<LI>Any character expression except one involving the concatenation of an operand whose length specification is<TT> (*)</TT>
unless the operand is a symbolic constant (see the<TT> PARAMETER</TT> statement).
<LI>An asterisk<TT> (*),</TT> indicating<B> list-directed</B> formatting.
<BR><BR>Open Watcom FORTRAN 77 supports a third form of the<TT> READ</TT> statement in which the asterisk<TT> (*)</TT> may
be omitted.&nbsp; This is a form of<B> list-directed</B> formatting in which unit 5 is assumed.&nbsp; It is equivalent to
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; READ * [,ilist]</TT>
<LI>A<TT> NAMELIST</TT> name, indicating<B> namelist-directed</B> formatting.
</OL>
<BR>If the optional<TT> FMT=</TT> specifier is omitted then the format specifier must be the second item in the list of specifiers
and<TT> UNIT=</TT> must not be specified for the first item in the list.
<DT>REC = rn
<DD>
<BR><BR><TT>rn</TT> is an integer expression whose value must be positive.&nbsp; It is the number of the record to be read
when a file is connected for direct access.
<DT>IOSTAT = ios
<DD>
<BR><BR>is an input/output status specifier.&nbsp; The integer variable or integer array element<TT> ios</TT> is defined with
zero if no error occurs, a positive integer value if an error occurs, or a negative integer value if an end-of-file occurs.
<DT>ERR = s
<DD>
<BR><BR>is an error specifier and<TT> s</TT> is a statement label.&nbsp; When an error occurs, execution is transferred to
the statement labelled by<TT> s.</TT>
<DT>END = s
<DD>
<BR><BR>is an end-of-file specifier and<TT> s</TT> is a statement label.&nbsp; When an end-of-file occurs, execution is transferred
to the statement labelled by<TT> s.</TT>
</DL>
<BR><B>Input list -</B> An input list may contain one or more of the following:
<OL>
<LI>A variable name.
<LI>An array element name.
<LI>A character substring name.
<LI>An array name except an assumed-size dummy array.
<LI>An implied-DO list of the form:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ( dlist, i = e1, e2 [,e3] )</TT>
<BR><BR>where<TT> dlist</TT> is composed of one or more of items (1) through (5).
</OL>
<BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ( 5, 100 )X, Y, Z</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ( UNIT=5, FMT=100 )X, Y, Z</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 100&nbsp;&nbsp; FORMAT( 3F10.5 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ( UNIT=5, FMT='( 3F10.5 )' )X, Y, Z</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ( 5, '( 3F10.5 )' )X, Y, Z</TT>
<BR><BR>The above gives four examples of formatted<TT> READ</TT> statements, using the first of three supported forms of the<TT>
READ</TT> statement.&nbsp; In all cases, the format conversion is identical but it was specified in different ways.&nbsp;
When executed, the effect of all<TT> READ</TT> statements is the same.&nbsp; The unit number that is<B> explicitly</B> used
in this form of the<TT> READ</TT> statement is unit number 5.&nbsp; There are, in fact, many other ways in which the<TT> READ</TT>
statement could have been written, all of which would have the same effect when executed.&nbsp; We have not shown the use
of all the specifiers.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ 100, X, Y, Z</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 100&nbsp;&nbsp; FORMAT( 3F10.5 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ '( 3F10.5 )', X, Y, Z</TT>
<BR><BR>The above gives two examples of formatted<TT> READ</TT> statements, using the second of three supported forms of the<TT>
READ</TT> statement.&nbsp; In both cases, the format conversion is identical but it was specified in different ways.&nbsp;
When executed, the effect of both<TT> READ</TT> statements is the same.&nbsp; The unit number that is<B> implicitly</B> used
in this form of the<TT> READ</TT> statement is unit number 5.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ( 5, * )X, Y, Z</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ( *, * )X, Y, Z</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ( UNIT=5, FMT=* )X, Y, Z</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ( UNIT=*, FMT=* )X, Y, Z</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ *, X, Y, Z</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ&nbsp; , X, Y, Z</TT>
<BR><BR>The above six examples of list-directed formatted input are all equivalent.&nbsp; Open Watcom FORTRAN 77 assumes unit
5 when the unit number identifier is an asterisk (as in the second and fourth examples).&nbsp; In the fifth example, the asterisk
is a format identifier indicating list-directed formatting.&nbsp; The fifth and sixth examples are examples of the second
and third forms, respectively, of the<TT> READ</TT> statement in which Open Watcom FORTRAN 77 assumes unit 5.&nbsp; When the
format identifier is an asterisk or when the third form of the<TT> READ</TT> statement is used, we call this list-directed<B>
list-directed</B> formatting.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ( 8 )X, Y, Z</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ( UNIT=8 )X, Y, Z</TT>
<BR><BR>The above gives two examples of unformatted <TT> READ</TT> statements.&nbsp; The unit number used in the example is
8.&nbsp; When executed, the effect of both of these statements is the same.&nbsp; The values of the variables<TT> X, Y</TT>
and<TT> Z</TT> are read from the file connected to unit 8.&nbsp; The values are stored in the file in their binary form (a
form quite incomprehensible to most human beings).&nbsp; An advantage to using this particular form of the<TT> READ</TT> statement
is that no conversion is required between the internal binary representation of the values and their textual (human-readable)
form (which means it takes less computer time to process the data).
<BR><BR><B>Notes:</B>
<OL>
<LI>The<TT> REC=</TT> specifier may not be used when list-directed output is specified.
<LI>If no input list is specified then the effect of the<TT> READ</TT> statement is to skip one or more records in the file.
<LI>An implication of point (5) above is that nesting of implied-DO lists is permitted.&nbsp; For example, the input list
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ( (A(I,J), B(I,J), J = 1, 5), I = 1, 10 )</TT>
<BR><BR>may be broken down into the following components:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A(I,J), B(I,J)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (....dlist1...., J = 1, 5)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ( .....dlist2..............., I = 1, 10 )</TT>
</OL>
<BR>For more information on input/output, see the chapter entitled <A HREF="#InputDOutput">Input/Output</A>.&nbsp; For more
information on formatted input/output, see the chapter <A HREF="#Format">Format</A>.
<H2 ID="REAL_Statement"> REAL Statement </H2>
<BR>The<TT> REAL</TT> statement is a type declaration statement and can be used to declare a name to be of type real.&nbsp;
The implicit type of the name, whether defined by the &quot;first letter rule&quot; (see the chapter entitled <A HREF="#Names__Data_Types_and_Constants">Names, Data Types and Constants</A>)
or by an<TT> IMPLICIT</TT> statement, is either confirmed or overridden.&nbsp; However, once a name has been declared to be
of type real, it cannot appear in another type declaration statement.
<BR><BR>There are various forms of the<TT> REAL</TT> statement.&nbsp; The following sections describe them.
<H3 ID="Standard_REAL_Statement"> Standard REAL Statement </H3>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REAL name [,name] ...</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>name
<DD>is a variable name, array name, array declarator, symbolic name of a constant, function name or dummy procedure name.
</DL>
<BR>This form is the standard form of the<TT> REAL</TT> statement.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DIMENSION C(-5:5)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REAL A, B(10), C</TT>
<BR><BR>In the previous example,<TT> A</TT> is defined to be a variable of type real and<TT> B</TT> and<TT> C</TT> are defined
to be arrays of type real.
<H3 ID="Extended_REAL_Statement__Length_Specification"> Extended REAL Statement:&nbsp; Length Specification </H3>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REAL[*len[,]] name [,name] ...</TT></TT>&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>name
<DD>is one of the following forms:
<BR><BR><TT>v[*len]</TT>
<BR><BR><TT>a[*len](d)</TT>
<BR><BR><TT>a(d)[*len]</TT>
<DT>v
<DD>is a variable name, array name, symbolic name of a constant, function name or dummy procedure name.
<DT>a
<DD>is an array name.
<DT>(d)
<DD>is that part of the array declarator defining the dimensions of the array.
<DT>len
<DD>is called the<B> length specification</B> and is an unsigned positive integer constant or an integer constant expression enclosed
in parentheses whose value is 4 or 8.
</DL>
<BR>This form of the<TT> REAL</TT> statement is a Open Watcom FORTRAN 77 extension to the FORTRAN 77 language.&nbsp; The length
specification specifies the number of bytes of storage that will be allocated for the name appearing in the<TT> REAL</TT>
statement.&nbsp; The default length specification is 4.&nbsp; A length specification of 8 specifies that the data type of
the name appearing in the<TT> REAL</TT> statement is to be double precision.
<BR><BR>The length specification immediately following the word<TT> REAL</TT> is the length specification for each entity
in the statement not having its own length specification.&nbsp; If a length specification is not specified the default length
specification is used.&nbsp; An entity with its own specification overrides the default length specification or the length
specification immediately following the word<TT> REAL.</TT>&nbsp; Note that for an array the length specification applies
to<B> each</B> element of the array.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DIMENSION C(-5:5)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REAL A, B*8(10), C*8</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REAL*8 X</TT>
<BR><BR>In the previous example,<TT> X</TT> is declared to be a variable of type double precision,<TT> A</TT> is declared
to be a variable of type real and<TT> B</TT> and<TT> C</TT> are declared to be arrays of type double precision.
<H3 ID="Extended_REAL_Statement__Data_Initialization"> Extended REAL Statement:&nbsp; Data Initialization </H3>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REAL[*len[,]] name [/cl/] [,name[/cl/]] ...</TT></TT>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>name
<DD>is as described in the previous section.
<DT>len
<DD>is as described in the previous section.
<DT>cl
<DD>is a list of the form:
<BR><BR><TT>k [,k] ...</TT>
<DT>k
<DD>is one of the forms:
<BR><BR><TT>c</TT>
<BR><BR><TT>r*c</TT> (equivalent to<TT> r</TT> successive appearances of<TT> c)</TT>
<DT>c
<DD>is a constant or the symbolic name of a constant
<DT>r
<DD>is an unsigned positive integer constant or the symbolic name of a constant.
</DL>
<BR>This form of the<TT> REAL</TT> statement is an extension to the FORTRAN 77 language.&nbsp; The rules for data initialization
are the same as for the<TT> DATA</TT> statement.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REAL A/1.2/, B(10)/10*5.0/</TT>
<BR><BR>In the previous example,<TT> A</TT> is initialized with the real constant<TT> 1.2</TT> and each element of the array<TT>
B</TT> is initialized with the real constant<TT> 5.0.</TT>
<H2 ID="RECORD_Statement"> RECORD Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RECORD /typename/ name [,name] ...</TT></TT>&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>typename
<DD>is the name of a user-defined structure type.
<DT>name
<DD>is a variable name, array name, array declarator, function name or dummy procedure name.
</DL>
<BR>The<TT> RECORD</TT> statement is used to assign a structure type to a variable.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STRUCTURE /ADDRESS/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*20 STREET</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*15 CITY</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*20 STATE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*20 COUNTRY</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*10 ZIP_CODE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END STRUCTURE</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STRUCTURE /PEOPLE/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*20 NAME</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RECORD /ADDRESS/ ADDR</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER*2 AGE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END STRUCTURE</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RECORD /PEOPLE/ CUSTOMER</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CUSTOMER%NAME = 'John Doe'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CUSTOMER%ADDR%STREET = '22 Main St.'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CUSTOMER%ADDR%CITY = 'Smallville'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CUSTOMER%ADDR%STATE = 'Texas'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CUSTOMER%ADDR%COUNTRY = 'U.S.A.'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CUSTOMER%ADDR%ZIP_CODE = '78910-1203'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CUSTOMER%AGE = 23</TT>
<BR><BR>For more information, see the chapter entitled <A HREF="#Structures__Unions_and_Records">Structures, Unions and Records</A>.
<H2 ID="REMOTE_BLOCK_Statement"> REMOTE BLOCK Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REMOTE BLOCK name</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>name
<DD>is a valid FORTRAN symbolic name.
</DL>
<BR>The<TT> REMOTE BLOCK</TT> statement is used to define a block of statements which may be executed by an<TT> EXECUTE</TT>
statement.&nbsp; A REMOTE-block must be defined in the program unit in which it is used and is terminated by an<TT> END BLOCK</TT>
statement.&nbsp; A REMOTE-block is similar in concept to a subroutine, with the advantage that shared variables do not need
to be placed in a common block or passed in an argument list.&nbsp; When execution of the REMOTE-block is complete, control
returns to the statement following the<TT> EXECUTE</TT> statement which invoked it.
<BR><BR>This feature is helpful in avoiding duplication of code for a common sequence of statements required in a number of
places throughout a program.&nbsp; It can also be an aid to writing a well structured program.&nbsp; This feature can be mimicked
using the<TT> ASSIGN</TT> and assigned<TT> GO TO</TT> statements.&nbsp; However, statement numbers must be introduced which
could lead to errors.
<BR><BR>Each REMOTE-block must have a different name and it must not be a subprogram or variable name.&nbsp; Note that a REMOTE-block
is local to the program unit in which it is defined and may not be referenced (executed) from another program unit.
<BR><BR>Note that the nested definition of REMOTE-blocks is not permitted.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EXECUTE INCR</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'FIRST'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EXECUTE INCR</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'SECOND'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REMOTE BLOCK INCR</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I=I+1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'I=',I</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END BLOCK</TT>
<BR><BR>Both<TT> EXECUTE</TT> statements will cause REMOTE-block<TT> INCR</TT> to be executed.&nbsp; That is, variable<TT>
I</TT> will be incremented and its value will be printed.&nbsp; When the block has been executed by the first<TT> EXECUTE</TT>
statement, control returns to the<TT> PRINT</TT> statement following it and the word<TT> FIRST</TT> is printed.&nbsp; Similarly,
when the block is executed by the second<TT> EXECUTE</TT> statement, control returns to the<TT> PRINT</TT> statement following
it and the word<TT> SECOND</TT> is printed.
<BR><BR>For more information, see the chapter entitled <A HREF="#Program_Structure_Control_Statements">Program Structure Control Statements</A>.
<H2 ID="RETURN_Statement"> RETURN Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RETURN [e]</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>e
<DD>is an integer expression.
</DL>
<BR>A<TT> RETURN</TT> statement is used to terminate execution of a subprogram and return control to the program unit that
referenced it.&nbsp; As an extension to FORTRAN 77, Open Watcom FORTRAN 77 permits the use of the<TT> RETURN</TT> statement
in the main program.&nbsp; When a<TT> RETURN</TT> statement is executed in the main program, program execution terminates
in the same manner as the<TT> STOP</TT> or<TT> END</TT> statement.
<BR><BR>The expression<TT> e</TT> is not permitted when returning from an external function subprogram (or main program);
it can only be specified when returning from a subroutine subprogram.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FUNCTION ABS( A )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ABS = A</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( A .GE. 0 )RETURN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ABS = -A</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RETURN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>For more information, see the chapter entitled <A HREF="#Functions_and_Subroutines">Functions and Subroutines</A>.
<H2 ID="REWIND_Statement"> REWIND Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REWIND u</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REWIND (alist)</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>u
<DD>is an external unit identifier.
<DT>alist
<DD>is a list of rewind specifiers separated by commas:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [UNIT =] u</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; IOSTAT = ios</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ERR = s</TT>
</DL>
<BR>Execution of a<TT> REWIND</TT> statement causes the file connected to the specified unit to be positioned at the beginning
(or before the first record) of the file.
<DL>
<DT>Rewind Specifiers
<DD>
<DT>[UNIT =] u
<DD>
<BR><BR><TT>u</TT> is an<B> external unit identifier.</B>&nbsp; An external unit identifier is a non-negative integer expression.
&nbsp;If the optional<TT> UNIT=</TT> specifier is omitted then the specifier must be the first item in the list of specifiers.
<DT>IOSTAT = ios
<DD>
<BR><BR>is an<B> input/output status specifier.</B>&nbsp; The integer variable or integer array element<TT> ios</TT> is defined
with zero if no error condition exists or a positive integer value if an error condition exists.
<DT>ERR = s
<DD>
<BR><BR>is an<B> error specifier</B> and<TT> s</TT> is a statement label.&nbsp; When an error occurs, execution is transferred
to the statement labelled by<TT> s.</TT>
</DL>
<BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOOP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ( UNIT=7, END=100, FMT=200
)RECORD</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, RECORD</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDLOOP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 100&nbsp;&nbsp; REWIND( UNIT=7 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOOP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ( UNIT=7, END=101, FMT=200
)RECORD</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WRITE( UNIT=8, FMT=200 )RECORD</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDLOOP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 101&nbsp;&nbsp; CONTINUE</TT>
<BR><BR>In the previous example, we illustrate how one might process the records in a file twice.&nbsp; After reaching the
endfile record, a<TT> REWIND</TT> statement is executed and the file is read a second time.
<BR><BR><B>Notes:</B>
<OL>
<LI>The unit must be connected for sequential access.
<LI>If the file is positioned at the beginning of the file then the<TT> REWIND</TT> statement has no effect.
<LI>It is permissible to rewind a file that does not exist but it has no effect.
</OL>
<BR>For more information on input/output, see the chapter entitled <A HREF="#InputDOutput">Input/Output</A>.
<H2 ID="SAVE_Statement"> SAVE Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SAVE [a [,a] ...]</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>a
<DD>is a named common block preceded and followed by a slash (/), a variable name or an array name.
</DL>
<BR>The<TT> SAVE</TT> statement is used to retain the value of an entity after the execution of a<TT> RETURN</TT> or<TT> END</TT>
statement in a subprogram.&nbsp; Upon re-entry to the subprogram, the entity will have the same value it had when exit was
made from the subprogram.&nbsp; However, an entity belonging to a common block that has appeared in a<TT> SAVE</TT> statement
may become redefined in another program unit.
<BR><BR><B>Notes:</B>
<OL>
<LI>A name cannot appear in a<TT> SAVE</TT> statement more than once in the same program unit.
<LI>Dummy arguments, procedure names and names belonging to a common block are not permitted in a<TT> SAVE</TT> statement.
<LI>A<TT> SAVE</TT> statement with no list is identical to a<TT> SAVE</TT> statement containing all allowable names in a program
unit.
<LI>A common block name appearing in a<TT> SAVE</TT> statement has the same effect of specifying all names belonging to that
common block in the<TT> SAVE</TT> statement.
<LI>If a named common block is specified in a<TT> SAVE</TT> statement in a subprogram, it must be specified in a<TT> SAVE</TT>
statement in every subprogram in which that common block appears.&nbsp; Furthermore, upon executing a<TT> RETURN</TT> or<TT>
END</TT> statement, the current values of the entities in that common block are made available to the next program unit executed
in which that common block appears.
<LI>If a named common block is specified in a<TT> SAVE</TT> statement in the main program unit, the current values of the
entities in that common block are made available to every subprogram that specifies that common block.&nbsp; In this case,
a<TT> SAVE</TT> statement has no effect in the subprogram.
</OL>
<BR>In the following example, the subroutine<TT> BLKINIT</TT> initializes the entities of the common block<TT> BLK</TT> and
uses a<TT> SAVE</TT> statement to ensure that their values are made available to subroutine<TT> BLKPRT.</TT>
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PROGRAM MAIN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALL BLKINIT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALL BLKPRT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SUBROUTINE BLKINIT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; COMMON /BLK/ A,B,C</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SAVE /BLK/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A = 1.0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B = 2.0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C = 3.0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SUBROUTINE BLKPRT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; COMMON /BLK/ A,B,C</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SAVE /BLK/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, A, B, C</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<H2 ID="SELECT_Statement"> SELECT Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SELECT [CASE] (e) [FROM]&nbsp; [: block-label]</TT></TT>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR>The<TT> SELECT</TT> statement is used in conjunction with the<TT> CASE</TT> and<TT> END SELECT</TT> statements.&nbsp;
The form of a<TT> SELECT</TT> block is as follows:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SELECT [CASE] (e) [FROM]&nbsp; [: block-label]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CASE ( case-list )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; statement (s)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CASE ( case-list )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; statement (s)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CASE ( case-list )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; statement(s)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CASE DEFAULT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; statement(s)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END SELECT</TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>e
<DD>is an integer expression.&nbsp; 
<DT>case-list
<DD>is a list of one or more<B> cases</B> separated by commas.&nbsp; A<B> case</B> is either
<DL>
<DT>(a)
<DD>a single integer, logical or character constant expression or
<DT>(b)
<DD>an integer, logical or character constant expression followed by a colon followed by another expression or the same type.
&nbsp;This form of a case defines a range of values consisting of all integers or characters greater than or equal to the
value of the expression preceding the colon and less than or equal to the value of the expression following the colon.
</DL>
</DL>
<BR>The<TT> CASE</TT> and<TT> FROM</TT> keywords are optional in the<TT> SELECT</TT> statement.&nbsp; An optional block label
may be specified with the<TT> SELECT</TT> statement.
<BR><BR>The case expression<B> e</B> is evaluated and if the result is equal to one of the values covered by<TT> case-list</TT>
then the control of execution is transferred to the associated<TT> CASE</TT> block.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SELECT CASE ( CH )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CASE ( 'a' : 'z' )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'Lower case letter'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CASE ( 'A' : 'Z' )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'Upper case letter'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CASE ( '0' : '9' )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'Digit'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CASE DEFAULT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'Special character'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END SELECT</TT>
<BR><BR>In the above example, if the character<TT> CH</TT> is not a letter or digit then the<TT> CASE DEFAULT</TT> block is
executed.
<BR><BR>The<TT> CASE DEFAULT</TT> statement is optional.&nbsp; If it is present and the case expression is out of range (i.e.,
no<TT> CASE</TT> blocks are executed) then the<TT> CASE DEFAULT</TT> block is executed.&nbsp; If it is not present and the
case expression is out of range then execution continues with the first executable statement following the<TT> END SELECT</TT>
statement.&nbsp; The<TT> CASE DEFAULT</TT> block must follow all other<TT> CASE</TT> blocks.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SELECT CASE ( I )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CASE ( 1 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Y = Y + X</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X = X * 3.2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CASE ( 2 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Z = Y**2 + X</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CASE ( 3 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Y = Y * 13. + X</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X = X - 0.213</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CASE ( 4 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Z = X**2 + Y**2 - 3.0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Y = Y + 1.5</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X = X * 32.0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CASE DEFAULT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'CASE is not in range'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END SELECT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, X, Y, Z</TT>
<BR><BR>In order to retain compatibility with earlier versions of WATCOM FORTRAN 77 compilers, the<TT> OTHERWISE</TT> statement
may be used in place of the<TT> CASE DEFAULT</TT> statement.
<BR><BR>For more information, see the chapter entitled <A HREF="#Program_Structure_Control_Statements">Program Structure Control Statements</A>.
<H2 ID="STOP_Statement"> STOP Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STOP [n]</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>n
<DD>is a character constant or an unsigned integer constant of no more than five digits.
<BR><BR>Open Watcom FORTRAN 77 allows<TT> n</TT> to be any unsigned integer constant.
</DL>
<BR>Execution of a<TT> STOP</TT> statement causes termination of execution of the program.&nbsp; A<TT> STOP</TT> statement
may appear in any program unit (although good programming practice suggests that the main program is the proper place for
this statement).
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STOP 943</TT>
<BR><BR>The three digit number<TT> 943</TT> is displayed on the console prior to program termination.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STOP 'Finished at last'</TT>
<BR><BR>The character string
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Finished at last</TT>
<BR><BR>is displayed on the console prior to program termination.
<H2 ID="STRUCTURE_Statement"> STRUCTURE Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STRUCTURE /typename/</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>typename
<DD>is the name for a new, compound variable, data type.
</DL>
<BR>The<TT> STRUCTURE</TT> statement is used in conjunction with the<TT> END STRUCTURE</TT> declarative statement.&nbsp; The<TT>
STRUCTURE</TT> statement marks the start of a structure definition.
<BR><BR>The<TT> STRUCTURE</TT> statement defines a new variable type, called a<B> structure.</B>&nbsp; It does not declare
a specific program variable.&nbsp; The<TT> RECORD</TT> statement is used to declare variables and arrays to be of this particular
structure type.
<BR><BR>Structures may be composed of simple FORTRAN types or more complex structure types.&nbsp; This is shown in the following
example.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STRUCTURE /ADDRESS/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*20 STREET</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*20 CITY</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*20 STATE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*20 COUNTRY</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*10 ZIP_CODE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END STRUCTURE</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STRUCTURE /PEOPLE/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*20 NAME</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RECORD /ADDRESS/ ADDR</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER*2 AGE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END STRUCTURE</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RECORD /PEOPLE/ CUSTOMER</TT>
<BR><BR>Element names are local to the structure in which they appear.&nbsp; The same element name can appear in more than
one structure.&nbsp; Nested structures may have elements with the same name.&nbsp; A particular element is specified by listing
the sequence of elements required to reach the desired element, separated by percent symbols (%) or periods (.).
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CUSTOMER%NAME = 'John Doe'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CUSTOMER%ADDR%STREET = '22 Main St.'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CUSTOMER%ADDR%CITY = 'Smallville'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CUSTOMER%ADDR%STATE = 'Texas'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CUSTOMER%ADDR%COUNTRY = 'U.S.A.'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CUSTOMER%ADDR%ZIP_CODE = '78910-1203'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CUSTOMER%AGE = 23</TT>
<BR><BR>For more information, see the chapter entitled <A HREF="#Structures__Unions_and_Records">Structures, Unions and Records</A>.
<H2 ID="SUBROUTINE_Statement"> SUBROUTINE Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SUBROUTINE sub [( [d [, d] ...] )]</TT></TT>&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>sub
<DD>is a symbolic name of a subroutine subprogram.
<DT>d
<DD>is a variable name, array name, dummy procedure name or an asterisk (*).<TT>&nbsp; d</TT> is called a<B> dummy argument.</B>
&nbsp;
</DL>
<BR>A<TT> SUBROUTINE</TT> statement is used to define the start of a subroutine subprogram.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALL TMAX3( -1.0, 12.0, 5.0 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SUBROUTINE TMAX3( ARGA, ARGB, ARGC )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; THEMAX = ARGA</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( ARGB .GT. THEMAX ) THEMAX
= ARGB</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( ARGC .GT. THEMAX ) THEMAX
= ARGC</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, THEMAX</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>In the above example, the subroutine<TT> TMAX3</TT> is defined to find and print out the maximum value of three real
variables.
<BR><BR><B>Notes:</B>
<OL>
<LI>No dummy arguments need be specified in the<TT> SUBROUTINE</TT> statement.&nbsp; If such is the case, the parentheses
() are optional.
</OL>
<BR>For more information, see the chapter entitled <A HREF="#Functions_and_Subroutines">Functions and Subroutines</A>.
<H2 ID="UNION_Statement"> UNION Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UNION</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR>The<TT> UNION</TT> statement is used in conjunction with the<TT> END UNION</TT> declarative statement.&nbsp; The<TT> UNION</TT>
statement marks the start of a series of<TT> MAP</TT> structures.&nbsp; A<TT> UNION</TT> block must contain at least two<TT>
MAP</TT> structures.&nbsp; A<TT> UNION</TT> block permits the mapping of the same storage in several different ways.
<BR><BR>The following example maps out a 4-byte integer on an Intel 80x86-based processor.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STRUCTURE /MAPINT/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UNION</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MAP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; INTEGER*4 LONG</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END MAP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MAP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; INTEGER*2 LO_WORD</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; INTEGER*2 HI_WORD</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END MAP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MAP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; INTEGER*1 BYTE_0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; INTEGER*1 BYTE_1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; INTEGER*1 BYTE_2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; INTEGER*1 BYTE_3</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END MAP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END UNION</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END STRUCTURE</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RECORD /MAPINT/ I</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I%LONG = '01020304'x</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT '(2Z4)', I%LO_WORD, I%HI_WORD</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>For more information, see the chapter entitled <A HREF="#Structures__Unions_and_Records">Structures, Unions and Records</A>.
<H2 ID="UNTIL_Statement"> UNTIL Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UNTIL (e)</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>e
<DD>is a logical expression or integer arithmetic expression, in which case the result of the integer expression is compared for
inequality to the integer value 0.
</DL>
<BR>The<TT> UNTIL</TT> statement is used in conjunction with the structured<TT> LOOP</TT> or block<TT> WHILE</TT> statement.
&nbsp;The<TT> LOOP</TT> or block<TT> WHILE</TT> statement marks the beginning of a sequence of statements which are to be
repeated.&nbsp; The<TT> UNTIL</TT> statement marks the end of the loop.&nbsp; The LOOP-block or WHILE-block is executed until
control is transferred out of the block or the logical expression of the<TT> UNTIL</TT> statement has a true value.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X = 1.0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOOP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, X, SQRT( X )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X = X + 1.0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UNTIL( X .GT. 10.0 )</TT>
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I = 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WHILE( I .LT. 100 )DO</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; J = 4 * I * I</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; K = 3 * I</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, '4x**2 + 3x + 6 = ',
J + K + 6</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I = I + 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UNTIL( ( J + K + 6 ) .GT. 100 )</TT>
<BR><BR>For more information, see the chapter entitled <A HREF="#Program_Structure_Control_Statements">Program Structure Control Statements</A>.
<H2 ID="VOLATILE_Statement"> VOLATILE Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VOLATILE [a [,a] ...]</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>a
<DD>is a variable name or an array name.
</DL>
<BR>The<TT> VOLATILE</TT> statement is used to indicate that a variable or an element of an array may be updated concurrently
by other code.&nbsp; A volatile variable or array element will not be cached (in a register) by the code generator.&nbsp;
Each time a volatile variable or array element is referenced, it is loaded from memory.&nbsp; Each time a volatile variable
or array element is updated, it is stored back into memory.
<BR><BR><B>Notes:</B>
<OL>
<LI>A name cannot appear in a<TT> VOLATILE</TT> statement more than once in the same program unit.
<LI>Dummy arguments, procedure names, and common block names are not permitted in a<TT> VOLATILE</TT> statement.
</OL>
<BR>In the following example, the subroutine<TT> A_THREAD</TT> waits on the<TT> HoldThreads</TT> semaphore.&nbsp; It uses
the<TT> VOLATILE</TT> statement to ensure that the variable is re-loaded from memory each time through the loop.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SUBROUTINE A_THREAD()</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STRUCTURE /RTL_CRITICAL_SECTION/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER*4 DebugInfo</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER*4 LockCount</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER*4 RecursionCount</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER*4 OwningThread</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER*4 LockSemaphore</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER*4 Reserved</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END STRUCTURE</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER NumThreads</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOGICAL HoldThreads</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VOLATILE HoldThreads</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RECORD /RTL_CRITICAL_SECTION/ CriticalSection</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; COMMON NumThreads, HoldThreads, CriticalSection</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER threadid</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WHILE( HoldThreads )DO</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALL Sleep( 1 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END WHILE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT '(''Hi from thread '', i4)', threadid()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALL EnterCriticalSection( CriticalSection )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NumThreads = NumThreads - 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALL LeaveCriticalSection( CriticalSection )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALL endthread()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<H2 ID="Block_WHILE_Statement"> Block WHILE Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WHILE (e) DO&nbsp;&nbsp;&nbsp; [: block-label]</TT></TT>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>e
<DD>is a logical expression or integer arithmetic expression, in which case the result of the integer expression is compared for
inequality to the integer value 0.
</DL>
<BR>The block<TT> WHILE</TT> statement is used in conjunction with the structured<TT> END WHILE</TT> or<TT> UNTIL</TT> statement.
&nbsp;The block<TT> WHILE</TT> statement marks the beginning of a sequence of statements which are to be repeated.&nbsp; The<TT>
END WHILE</TT> or<TT> UNTIL</TT> statement marks the end of the WHILE-block.&nbsp; The WHILE-block is executed while the logical
expression of the<TT> WHILE</TT> statement has a true value or until control is transferred out of the WHILE-block.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X = 1.0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WHILE( X .LT. 100 )DO</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, X, SQRT( X )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X = X + 1.0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END WHILE</TT>
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I = 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WHILE( I .LT. 100 )DO</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; J = 4 * I * I</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; K = 3 * I</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, '4x**2 + 3x + 6 = ',
J + K + 6</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I = I + 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UNTIL( ( J + K + 6 ) .GT. 100 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>An optional block label may be specified with the<TT> WHILE</TT> statement.
<BR><BR>For more information, see the chapter entitled <A HREF="#Program_Structure_Control_Statements">Program Structure Control Statements</A>.
<H2 ID="WHILE_Statement"> WHILE Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WHILE (e) stmt</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>e
<DD>is a logical expression.
<DT>stmt
<DD>is an executable statement.&nbsp; Only certain executable statements are allowed.&nbsp; See the section entitled <A HREF="#Classifying_Statements">Classifying Statements</A>
at the beginning of this chapter for a list of allowed statements.
</DL>
<BR>This form of the<TT> WHILE</TT> statement allows an executable statement to be repeatedly executed until the logical expression<B>
e</B> is false.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I = 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WHILE( I .LE. 100 ) CALL PRTSQR( I )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SUBROUTINE PRTSQR( J )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, J, J**2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; J = J + 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>In the above example, the subroutine<TT> PRTSQR</TT> is called again and again until the value of<TT> I</TT> has been
incremented beyond 100.&nbsp; Note that the subroutine increments its argument thereby guaranteeing that the program will
eventually stop execution.
<BR><BR>For more information, see the chapter entitled <A HREF="#Program_Structure_Control_Statements">Program Structure Control Statements</A>
Control Statements&quot;.
<H2 ID="WRITE_Statement"> WRITE Statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WRITE (cilist) [olist]</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>cilist
<DD>is a control information list of specifiers separated by commas:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [UNIT =] u</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [FMT =] f</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; REC = rn</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; IOSTAT = ios</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ERR = s</TT>
<DT>olist
<DD>is an output list.
</DL>
<BR>The<TT> WRITE</TT> statement is used to transfer data from the executing FORTRAN program to an external device or file.
<DL>
<DT>Control Information List
<DD>
<DT>[UNIT =] u
<DD>
<BR><BR><TT>u</TT> is an<B> external unit identifier</B> or an<B> internal file identifier.</B>
<OL>
<LI>An external unit identifier is a non-negative integer expression or an asterisk<TT> (*)</TT> in which case unit 6 is assumed.
<LI>An internal file identifier is the name of a character variable, character array, character array element, or character
substring.
</OL>
<BR>If the optional<TT> UNIT=</TT> specifier is omitted then the unit specifier must be the first item in the list of specifiers.
<DT>[FMT =] f
<DD>
<BR><BR><TT>f</TT> is a<B> format identifier.</B>&nbsp; A format identifier is one of the following:
<OL>
<LI>A statement label of a<TT> FORMAT</TT> statement that appears in the same program unit as the format identifier.
<LI>An integer variable name that has been assigned the statement label of a<TT> FORMAT</TT> statement that appears in the
same program unit as the format identifier (see the<TT> ASSIGN</TT> statement).
<LI>An integer array name.
<LI>A character array name.
<LI>Any character expression except one involving the concatenation of an operand whose length specification is<TT> (*)</TT>
unless the operand is a symbolic constant (see the<TT> PARAMETER</TT> statement).
<LI>An asterisk<TT> (*),</TT> indicating<B> list-directed</B> formatting.
<LI>A<TT> NAMELIST</TT> name, indicating<B> namelist-directed</B> formatting.
</OL>
<BR>If the optional<TT> FMT=</TT> specifier is omitted then the format specifier must be the second item in the list of specifiers
and<TT> UNIT=</TT> must not be specified for the first item in the list.
<DT>REC = rn
<DD>
<BR><BR><TT>rn</TT> is an integer expression whose value must be positive.&nbsp; It is the number of the record to be written
when a file is connected for direct access.
<DT>IOSTAT = ios
<DD>
<BR><BR>is an input/output status specifier.&nbsp; The integer variable or integer array element<TT> ios</TT> is defined with
zero if no error condition occurs or a positive integer value if an error condition occurs.
<DT>ERR = s
<DD>
<BR><BR>is an error specifier and<TT> s</TT> is a statement label.&nbsp; When an error occurs, execution is transferred to
the statement labelled by<TT> s.</TT>
</DL>
<BR><B>Output list -</B> An output list may contain one or more of the following:
<OL>
<LI>A variable name.
<LI>An array element name.
<LI>A character substring name.
<LI>An array name except an assumed-size dummy array.
<LI>Any other expression except a character expression involving concatenation of an operand whose length specification is
an asterisk in parentheses unless the operand is the symbolic name of a constant (since the length can be determined at compile
time).
<LI>An implied-DO list of the form:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ( dlist, i = e1, e2 [,e3] )</TT>
<BR><BR>where<TT> dlist</TT> is composed of one or more of items (1) through (6).
</OL>
<BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WRITE( 6, 100 )X, Y, Z</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WRITE( UNIT=6, FMT=100 )X, Y, Z</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 100&nbsp;&nbsp; FORMAT( 3F10.5 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WRITE( UNIT=6, FMT='( 3F10.5 )' )X, Y, Z</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WRITE( 6, '( 3F10.5 )' )X, Y, Z</TT>
<BR><BR>The above gives four examples of formatted<TT> WRITE</TT> statements.&nbsp; In all cases, the format conversion is
identical but it was specified in different ways.&nbsp; When executed, the effect of all<TT> WRITE</TT> statements is the
same.&nbsp; The unit number, used here, is 6.&nbsp; There are, in fact, many other ways in which the<TT> WRITE</TT> statement
could have been written, all of which would have the same effect when executed.&nbsp; We have not shown use of all the specifiers.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WRITE( 6, * )X, Y, Z</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WRITE( *, * )X, Y, Z</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WRITE( UNIT=6, FMT=* )X, Y, Z</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WRITE( UNIT=*, FMT=* )X, Y, Z</TT>
<BR><BR>The above four examples of list-directed formatted output are all equivalent.&nbsp; Open Watcom FORTRAN 77 assumes
unit 6 when the unit number identifier is an asterisk (as in the second and fourth examples).&nbsp; In the examples, the format
identifier is an asterisk indicating list-directed formatting.&nbsp; 
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WRITE( 8 )X, Y, Z</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WRITE( UNIT=8 )X, Y, Z</TT>
<BR><BR>The above gives two examples of unformatted<TT> WRITE</TT> statements.&nbsp; The unit number used in the example is
8.&nbsp; When executed, the effect of both of these statements is the same.&nbsp; The values of the variables<TT> X, Y</TT>
and<TT> Z</TT> are written to the file connected to unit 8 in their binary form (a form quite incomprehensible to most human
beings).&nbsp; An advantage to using this particular form of the<TT> WRITE</TT> statement is that no conversion is required
between the internal binary representation of the values and their textual (human-readable) form (which means it takes less
computer time to process the data).
<BR><BR><B>Notes:</B>
<OL>
<LI>If no output list is specified then the effect of the<TT> WRITE</TT> statement is to produce a record whose characters
are all blanks.
<LI>The<TT> REC=</TT> specifier may not be used when list-directed output is specified.
<LI>An implication of point (6) above is that nesting of implied-DO lists is permitted.&nbsp; For example, the output list
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ( (A(I,J), B(I,J), J = 1, 5), I = 1, 10 )</TT>
<BR><BR>may be broken down into the following components:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A(I,J), B(I,J)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (....dlist1...., J = 1, 5)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ( .....dlist2..............., I = 1, 10 )</TT>
</OL>
<BR>For more information on input/output, see the chapter entitled <A HREF="#InputDOutput">Input/Output</A>.&nbsp; For more
information on formatted input/output, see the chapter entitled <A HREF="#Format">Format</A>.
<H1 ID="Names__Data_Types_and_Constants"> Names, Data Types and Constants </H1>
<BR>The following sections describe naming rules, data types supported by Open Watcom FORTRAN 77, and formats for constants.
<H2 ID="Symbolic_Names"> Symbolic Names </H2>
<BR><B> Symbolic names</B> are names that represent variables, arrays, functions, etc.&nbsp; Names are formed using any of
the upper-case letters A-Z and the digits 0-9, the first of which must be a letter.&nbsp; Symbolic names are limited to 6
characters in length.&nbsp; The following are examples of symbolic names.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AMOUNT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AGE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CUST73</TT>
<BR><BR>Open Watcom FORTRAN 77 extends the allowable characters that can make up a symbolic name to include the lower-case
letters a-z, the dollar sign ($) and the underscore (_).&nbsp; Note that the dollar sign and the underscore are treated as
letters and are therefore allowed as the first letter of a symbolic name.&nbsp; Furthermore, Open Watcom FORTRAN 77 allows
symbolic names of up to 32 characters.&nbsp; The following are examples of permissible symbolic names.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Evaluate</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $Cheque</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ComputeAverage</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _device</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IO$ERROR</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; student_total</TT>
<BR><BR>Open Watcom FORTRAN 77 makes no distinction between upper and lower case letters.&nbsp; The following symbolic names
are identical.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Account</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ACCount</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ACCOUNT</TT>
<BR><BR>Spaces are allowed in symbolic names and are ignored.&nbsp; The following symbolic names are identical.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C R E DIT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CRE D I T</TT>
<BR><BR>FORTRAN 77 allows certain keywords such as WRITE to be used as symbolic names.&nbsp; In Open Watcom FORTRAN 77, all<B>
keywords</B> satisfy the requirements of a symbolic name.&nbsp; A keyword is a sequence of letters that is interpreted in
a special way by Open Watcom FORTRAN 77.&nbsp; Whether a string of characters is interpreted as a keyword or as a symbolic
name depends on the context in which it is used.&nbsp; In the following example, the first statement is an assignment statement
assigning the value 2 to the symbolic name<TT> DO10I.</TT>&nbsp; The second statement is the beginning of a DO-loop.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO10I=1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO10I=1,10</TT>
<H2 ID="Data_Types"> Data Types </H2>
<BR>There are 6 basic data types in FORTRAN 77; logical, integer, real, double precision, complex and character.&nbsp; Open
Watcom FORTRAN 77 provides an additional data type, namely double precision complex (<TT> DOUBLE COMPLEX</TT> or<TT> COMPLEX*16</TT>).
&nbsp;Open Watcom FORTRAN 77 also supports the creation of more complex user-defined data types using the<TT> STRUCTURE</TT>
statement.
<BR><BR>Each data type can be classified as numeric, logical or character.&nbsp; Each datum occupies a sequence of storage
units.&nbsp; Numeric data and logical data occupy numeric storage units whereas character data occupy character storage units.
&nbsp;In Open Watcom FORTRAN 77, a numeric storage unit occupies 4 bytes and a character storage unit occupies 1 byte.
<BR><BR>The following table summarizes all data types supported by Open Watcom FORTRAN 77.&nbsp; 
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +--------------------+-----------+-------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; | Data Type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Size&nbsp;&nbsp;&nbsp;
&nbsp; | Standard&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; |(in bytes) | FORTRAN&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +--------------------+-----------+-------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; | LOGICAL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 4&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; | LOGICAL*1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 1&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; | extension&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; | LOGICAL*4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 4&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; | extension&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; | INTEGER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 4&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; | INTEGER*1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 1&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; | extension&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; | INTEGER*2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 2&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; | extension&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; | INTEGER*4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 4&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; | extension&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; | REAL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
| 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; | REAL*4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 4&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | extension&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; | REAL*8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 8&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | extension&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; | DOUBLE PRECISION&nbsp;&nbsp; | 8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | yes
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; | COMPLEX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 8&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; | COMPLEX*8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 8&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; | extension&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; | DOUBLE COMPLEX&nbsp;&nbsp;&nbsp;&nbsp; | 16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
extension&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; | COMPLEX*16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 16&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; | extension&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; | CHARACTER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 1&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; | yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; | CHARACTER*n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; | yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +--------------------+-----------+-------------+</TT>
<BR><BR>Detailed information on the size and range of values supported by each of these data types is provided in the User's
Guide.
<H2 ID="Data_Type_of_a_Name"> Data Type of a Name </H2>
<BR>A name must only have one data type.&nbsp; Its type is specified by the appearance of that name in a type statement.&nbsp;
If a name does not appear in any type statement then an implied type is assigned to it by the &quot;first letter rule&quot;.
&nbsp;A name not appearing in any type statement and beginning with any of the letters I, J, K, L, M or N is assigned the
type integer.&nbsp; A name not appearing in any type statement and beginning with any other letter is assigned the type real.
&nbsp;The implied type of a letter can be changed by an<TT> IMPLICIT</TT> statement.
<BR><BR>The type associated with a name defines the type of the data it is to contain.&nbsp; For example, if A is of type
integer, then the storage unit which A occupies is assumed to contain integer data.&nbsp; Note that the data type of an array
element is the same as the data type associated with the array name.
<BR><BR>The data type of a function name specifies the type of the result returned by the function when it is referenced.
&nbsp;A name that identifies a specific intrinsic function has type as specified in the chapter entitled <A HREF="#Functions_and_Subroutines">Functions and Subroutines</A>.
&nbsp;A<B> generic function</B> name has no type associated with it; its type is determined by the type of its argument(s).
&nbsp;The appearance of a generic function in a type statement is not sufficient to remove the generic properties of that
name.&nbsp; For example, if SIN was declared to be of type real, it could still be called with an argument of type complex.
&nbsp;The type of an external function reference is determined in the same way as for variables and arrays.&nbsp; The actual
type of the external function is determined implicitly by its name or explicitly by its appearance in a<TT> FUNCTION</TT>
or type statement.&nbsp; Note that an<TT> IMPLICIT</TT> statement can affect the type of the external function being defined.
<H2 ID="Constants"> Constants </H2>
<BR>A<B> constant</B> can be one of arithmetic, logical or character.&nbsp; Each constant has a data type and value associated
with it and, once established in a program, cannot be changed.&nbsp; Arithmetic constants consist of those constants whose
data type is one of integer, real, double precision, complex or double precision complex.&nbsp; Logical constants consist
of those constants whose data type is logical and character constants consist of those constants whose data type is character.
&nbsp;The string of characters representing a constant determines its value and data type.&nbsp; The blank character is insignificant
for all but character constants.
<H3 ID="Integer_Constants"> Integer Constants </H3>
<BR>An<B> integer constant</B> is formed by a non-empty string of digits preceded by an optional sign.
<BR><BR>The following are examples of integer constants.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1423</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +345</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -34565788</TT>
<H3 ID="Real_Constants"> Real Constants </H3>
<BR>We first define a<B> simple real constant</B> as follows:&nbsp; an optional sign followed by an integer part followed
by a decimal point followed by a fractional part.&nbsp; The integer and fractional parts are non-empty strings of digits.
&nbsp;Either can be omitted but not both.
<BR><BR>A<B> real constant</B> has one of the following forms.
<OL>
<LI>A simple real constant.
<LI>A simple real constant followed by an<TT> E</TT> followed by an optionally signed integer constant.
<LI>An integer constant followed by an<TT> E</TT> followed by an optionally signed integer constant.
</OL>
<BR>The optionally signed integer constant that follows the<TT> E</TT> is called the<B> exponent.</B>&nbsp; The value of a
real constant that contains an exponent is the value of the constant preceding the<TT> E</TT> multiplied by the power of ten
determined by the exponent.
<BR><BR>The following are examples of real constants.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 123.764</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .4352344</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1423.34E12</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +345.E-4</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -.4565788E3</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2E6</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1234.</TT>
<H3 ID="Double_Precision_Constant"> Double Precision Constant </H3>
<BR>A<B> double precision constant</B> has one of the following forms.
<OL>
<LI>A simple real constant followed by a<TT> D</TT> followed by an optionally signed integer constant.
<LI>An integer constant followed by a<TT> D</TT> followed by an optionally signed integer constant.
</OL>
<BR>The optionally signed integer constant that follows the<TT> D</TT> is called the<B> exponent.</B>&nbsp; The value of a
double precision constant that contains an exponent is the value of the constant preceding the<TT> D</TT> multiplied by the
power of ten determined by the double precision exponent.&nbsp; Note that the resulting approximation is of greater precision
than the equivalent real constant.&nbsp; The approximations may be of equal precision if the approximations are exact representations.
&nbsp;For example,<TT> 0D0</TT> and<TT> 0E0</TT> are double and single precision constants respectively, both representing
zero with the same precision.
<BR><BR>The following are examples of double precision constants.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1423.34D12</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +345.D-4</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -.4565788D5</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2D6</TT>
<H3 ID="Complex_Constant"> Complex Constant </H3>
<BR>A<B> complex constant</B> consists of a left parenthesis, followed by a real or integer constant representing the real
part of the complex constant, followed by a comma, followed by a real or integer constant representing the imaginary part
of the complex constant, followed by a right parenthesis.
<BR><BR>The following are examples of complex constants.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( 1423.34E12, 3 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( +345, 4 )</TT>
<H3 ID="Double_Precision_Complex_Constant_LExtensionR"> Double Precision Complex Constant (Extension) </H3>
<BR>A<B> double precision complex constant</B> has the same form as a complex constant except that at least one of the real
and imaginary parts<B> must</B> be a double precision constant.
<BR><BR>The following are examples of double precision complex constants.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( 1423.34D12, 3 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( +345, 4D2 )</TT>
<H3 ID="Logical_Constant"> Logical Constant </H3>
<BR>A<B> logical constant</B> can have one of the following forms.
<OL>
<LI><TT> .TRUE.</TT>&nbsp; representing the value true.
<LI><TT> .FALSE.</TT>&nbsp; representing the value false.
</OL>
<H3 ID="Character_Constant"> Character Constant </H3>
<BR>A<B> character constant</B> consists of an apostrophe followed by any string of characters followed by an apostrophe.
&nbsp;The apostrophes are not part of the datum.&nbsp; If an apostrophe is to appear as part of the datum it must be followed
immediately by another apostrophe.&nbsp; Note that blanks are significant.&nbsp; The length of the character constant is the
number of characters appearing between the delimiting apostrophes.&nbsp; Consecutive apostrophes in a character datum represent
one character, namely the apostrophe.&nbsp; A character constant must not have length 0.
<BR><BR>The following are examples of character constants.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'ABCDEFG1234567'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'There''s always tomorrow'</TT>
<H3 ID="String_Constant_LExtensionR"> String Constant (Extension) </H3>
<BR>A<B> string constant</B> consists of an apostrophe followed by any string of characters followed by an apostrophe and
then the letter<TT> C</TT> or<TT> c.</TT>&nbsp; The apostrophes are not part of the datum.&nbsp; The datum is stored in memory
with a terminating NUL character (CHAR(0)).&nbsp; If an apostrophe is to appear as part of the datum it must be followed immediately
by another apostrophe.&nbsp; Note that blanks are significant.&nbsp; The length of the string constant is the number of characters
appearing between the delimiting apostrophes plus one for the terminating NUL character (CHAR(0)).&nbsp; Consecutive apostrophes
in a string datum represent one character, namely the apostrophe.&nbsp; A string constant must not have length 0.&nbsp; A
string constant may be used anywhere a character constant may be used.
<BR><BR>The following are examples of string constants.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'Hello there'C</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'There''s always tomorrow'c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'The result for %s=%d'c</TT>
<H3 ID="Hollerith_Constants_LExtensionR"> Hollerith Constants (Extension) </H3>
<BR>A<B> hollerith constant</B> consists of a positive unsigned integer constant<TT> n</TT> followed by the letter<TT> H or
h</TT> followed by a string of exactly<TT> n</TT> characters.&nbsp; The actual data is the<TT> n</TT> characters following
the letter<TT> H</TT> or<TT> h.</TT>&nbsp; A hollerith constant is another way of representing character data.
<BR><BR>Actually, hollerith constants are treated as character constants and can be used wherever a character constant can
be used.&nbsp; Hollerith constants are different from character constants in that a quote is represented by two quotes in
character constants and by a single quote in hollerith constants.
<BR><BR>The following are examples of hollerith constants.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5HABCDEFG</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10h xxxxx '44</TT>
<H3 ID="Hexadecimal_Constants_LExtensionR"> Hexadecimal Constants (Extension) </H3>
<BR>Two forms of<B> hexadecimal constant</B> are supported.&nbsp; The first form can only be used in type declaration or<TT>
DATA</TT> statements.&nbsp; The second form may be used anywhere an integer constant may be used.
<BR><BR>The first form of hexadecimal constant consists of the letter<TT> Z</TT> or<TT> z</TT> followed by a string of hexadecimal
digits.&nbsp; A hexadecimal digit can be any digit or one of the letters<TT> A, B, C, D, E</TT> or<TT> F</TT> (the lower case
of these letters is also acceptable).&nbsp; The actual data is the hexadecimal digits following the letter<TT> Z</TT> or<TT>
z.</TT>&nbsp; Hexadecimal constants of this form can only be used in type declaration statements and<TT> DATA</TT> statements
for initializing memory with binary patterns.
<BR><BR>The following are examples of the first form of hexadecimal constant.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; z1234</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Zac</TT>
<BR><BR>The first example is equivalent to the binary pattern<TT> 0001 0010 0011 0100.</TT>&nbsp; The second example is equivalent
to the binary pattern<TT> 1010 1100.</TT>
<BR><BR>The second form of hexadecimal constant consists of an apostrophe followed by any string of hexadecimal digits followed
by an apostrophe and then the letter<TT> X</TT> or<TT> x.</TT>&nbsp; A hexadecimal digit can be any digit or one of the letters<TT>
A, B, C, D, E</TT> or<TT> F</TT> (the lower case of these letters is also acceptable).&nbsp; The actual data is the hexadecimal
digits placed inside apostrophes.
<BR><BR>The following are examples of the second form of hexadecimal constant.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '1234'x</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'ac'X</TT>
<BR><BR>The first example is equivalent to the binary pattern<TT> 0001 0010 0011 0100.</TT>&nbsp; The second example is equivalent
to the binary pattern<TT> 1010 1100.</TT>
<H3 ID="Octal_Constants_LExtensionR"> Octal Constants (Extension) </H3>
<BR>An<B> octal constant</B> consists of an apostrophe followed by any string of octal digits followed by an apostrophe and
then the letter<TT> O</TT> or<TT> o.</TT>&nbsp; An octal digit can be any of the digits 0 through 7.&nbsp; The actual data
is the octal digits placed inside apostrophes.&nbsp; An octal constant may be used anywhere an integer constant may be used.
<BR><BR>The following are examples of octal constants.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '1234'o</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '37'O</TT>
<BR><BR>The first example is equivalent to the binary pattern<TT> 001 010 011 100.</TT>&nbsp; The second example is equivalent
to the binary pattern<TT> 011 111.</TT>
<H2 ID="Symbolic_Constants"> Symbolic Constants </H2>
<BR>It is possible to give a constant a symbolic name.&nbsp; This is done through<TT> PARAMETER</TT> statements.&nbsp; For
more details, see the section on the<TT> PARAMETER</TT> statement in the chapter entitled <A HREF="#FORTRAN_Statements">FORTRAN Statements</A>.
<H1 ID="Arrays"> Arrays </H1>
<BR>An array is a non-empty collection of data.&nbsp; Arrays allow a convenient way of manipulating large quantities of data.
&nbsp;An array can be referenced as an entity.&nbsp; In this way it is possible to conveniently pass large quantities of data
between subprograms.&nbsp; Alternatively, it is possible to reference each element of an array individually so that data can
be selectively processed.&nbsp; Consider the task of managing the marks of 100 students.&nbsp; Without arrays one would have
to have a unique name for each mark.&nbsp; They might be M1, M2, etc.&nbsp; up to M100.&nbsp; This is clearly cumbersome.
&nbsp;Instead, we can use an array called MARKS containing 100 elements.&nbsp; Now there is one name for all the marks.&nbsp;
Each mark can be referenced by using that name followed by a subscript.&nbsp; Furthermore, suppose the size of the class doubled.
&nbsp;Do we add the names M101, M102, etc.&nbsp; up to M200?&nbsp; Not if we use arrays.&nbsp; If the size of the class doubled,
all that need be done is to define the array to contain 200 elements.&nbsp; It is not hard to see that programs that use arrays
tend to be general in nature.&nbsp; Arrays also facilitate the repetitive computations that must be performed on large amounts
of data in that they lend themselves to loop processing.
<H2 ID="Properties_of_Arrays"> Properties of Arrays </H2>
<BR>Arrays are defined by an array declarator.&nbsp; The form of an<B> array declarator</B> is:
<BR><BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a( d [,d] ... )</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>a
<DD>is the symbolic name of the array
<DT>d
<DD>is a dimension declarator.
</DL>
<BR>The number of dimensions of the array is determined by the number of dimension declarators appearing in the array declarator.
&nbsp;Allowable dimensions for arrays range from 1 to 7.&nbsp; A 1-dimensional array can be viewed as a vector, a 2-dimensional
array as a matrix and a 3-dimensional array as a number of parallel matrices.&nbsp; Arrays with dimension higher than 3 are
generally difficult to intuitively describe and hence examples will deal with arrays whose dimension is 1, 2 or 3.
<BR><BR>Each dimension has a range of values.&nbsp; When referencing elements in that dimension, the dimension expression
must fall in that range.&nbsp; The range of a dimension is defined in the dimension declarator.&nbsp; A<B> dimension declarator</B>
has the following form:
<BR><BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [lo:] hi</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>lo
<DD>is the lower dimension bound.
<DT>hi
<DD>is the upper dimension bound.
</DL>
<BR>The lower and upper dimension bounds must be integer expressions and the upper dimension bound must be greater than or
equal to the lower dimension bound.&nbsp; The upper dimension bound of the last dimension may be an asterisk<TT> (*).</TT>
&nbsp;The meaning of this will be discussed later.&nbsp; If the lower dimension bound is not specified then a default of 1
is assumed.&nbsp; The size of a dimension is defined as<TT> hi</TT> - lo + 1.&nbsp; Note that if the lower dimension bound
is not specified the size of the dimension is just<TT> hi.</TT>&nbsp; The size of the array (or the number of elements in
the array) is defined as the product of all the sizes of the dimensions of the array.&nbsp; The maximum number of elements
in any dimension is limited to 65535.&nbsp; The maximum size of an array is limited by the amount of available memory.
<BR><BR>Arrays are defined by the appearance of an array declarator in a<TT> DIMENSION</TT> statement, a type statement or
a<TT> COMMON</TT> statement.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DIMENSION A(10), B(-5:5,-10:10)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER C(10,20)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; COMMON /DATA/ X,Y(30,30),Z</TT>
<BR><BR>In the previous example, B is a 2-dimensional array with 11 rows and 21 columns and has 231 elements (i.e.&nbsp; 11
* 21).
<BR><BR>Each array has a data type associated with it.&nbsp; This data type is inherited by all elements of the array.
<H2 ID="Array_Elements"> Array Elements </H2>
<BR>Each array is comprised of a sequence of array elements.&nbsp; An array element is referenced by following the array name
with a<B> subscript.</B>&nbsp; Different elements of the array are referenced by simply changing the subscript.&nbsp; An<B>
array element</B> has the following form:
<BR><BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a(s[,s]...)</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>a
<DD>is the array name.
<DT>(s[,s]...)
<DD>is a subscript.
<DT>s
<DD>is a subscript expression.
</DL>
<BR>Each<B> subscript expression</B> must be an integer expression and must be in the range defined by the upper and lower
dimension bounds of the corresponding dimension.&nbsp; The number of subscript expressions must be equal to the dimension
of the array.
<BR><BR>If an array has<B> n</B> elements then there is a 1-to-1 correspondence between the elements of the array and the
integers from 1 to<B> n.</B>&nbsp; Each subscript has a<B> subscript value</B> associated with it which determines which element
of the array is being referenced.&nbsp; If the subscript value is<B> i</B> then the<B> i</B>th element of the array is the
one referenced.&nbsp; The subscript value depends on the subscript expressions and on the dimensions of the array.&nbsp; The
following table describes how to compute the subscript value.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +---+--------------------+------------+----------------------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; | n | Dimension&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Subscript&nbsp; |
Subscript&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; | Declarator&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Value&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +---+--------------------+------------+----------------------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; | 1 | (J1:K1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | (S1)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; | 1+(S1-J1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +---+--------------------+------------+----------------------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; | 2 | (J1:K1,J2:K2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | (S1,S2)&nbsp;&nbsp;&nbsp; | 1+(S1-J1)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; +(S2-J2)*D1&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +---+--------------------+------------+----------------------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; | 3 | (J1:K1,J2:K2,J3:K3)| (S1,S2,S3) | 1+(S1-J1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; +(S2-J2)*D1&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; +(S3-J3)*D2*D1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +---+--------------------+------------+----------------------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; | . | .&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; | .&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | .&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; | . | .&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; | .&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | .&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; | . | .&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; | .&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | .&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +---+--------------------+------------+----------------------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; | n | (J1:K1,...,Jn:Kn)&nbsp; | (S1,...,Sn)| 1+(S1-J1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; +(S2-J2)*D1&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; +(S3-J3)*D2*D1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; +&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; +(Sn-Jn)*Dn-1*Dn-2*...*D1
|</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +---+--------------------+------------+----------------------------+</TT>
<BR><BR><B>Notes:</B>
<OL>
<LI>n is the number of dimensions, 1 &lt;= n &lt;= 7.
<LI>Ji is the value of the lower bound of the<B> i'th</B> dimension.
<LI>Ki is the value of the upper bound of the<B> i'th</B> dimension.
<LI>If only the upper bound is specified, then Ji = 1
<LI>Si is the integer value of the<B> i'th</B> subscript expression.
<LI>Di = Ki-Ji+1 is the size of the<B> i'th</B> dimension.&nbsp; If the value of the lower bound is 1, then Di = Ki.
<LI>A subscript of the form (J1,...,Jn) has subscript value 1 and identifies the first element of the array.&nbsp; A subscript
of the form (K1,...,Kn) has subscript value equal to the size of the array and identifies the last element of the array.
</OL>
<H2 ID="Classifying_Array_Declarators_by_Dimension_Declarator"> Classifying Array Declarators by Dimension Declarator </H2>
<BR>Array declarators can be classified according to the characteristics of the dimension declarator.&nbsp; The following
sections discuss the three classifications.
<H3 ID="Constant_Array_Declarator"> Constant Array Declarator </H3>
<BR>A<B> constant array declarator</B> is one in which each of the dimension bound expressions is an integer constant expression.
&nbsp;It is called a constant array declarator because the dimension bound expressions can never change.&nbsp; In the following
example both<TT> A(10)</TT> and<TT> B(</TT>-5:5) are constant array declarators.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SUBROUTINE SQUARE( A )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DIMENSION A(10), B(-5:5)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<H3 ID="Adjustable_Array_Declarator"> Adjustable Array Declarator </H3>
<BR>An<B> adjustable array declarator</B> is one that contains at least one variable in all of its dimension bound expressions.
&nbsp;It is called an adjustable array declarator because the dimension bound expressions can change depending on the current
value of the variables in the dimension bound expressions.&nbsp; The array name must be a dummy argument.&nbsp; In the following
example,<TT> A(M,2*N)</TT> is an adjustable array declarator.&nbsp; If<TT> SQUARE</TT> is called with<TT> M</TT> having value
5 and<TT> N</TT> having value 10, then the array<TT> A</TT> will be a 2-dimensional array having 5 rows and 20 columns.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SUBROUTINE SQUARE( A, M, N )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DIMENSION A(M,2*N)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<H3 ID="AssumedMsize_Array_Declarator"> Assumed-size Array Declarator </H3>
<BR>An<B> assumed-size array declarator</B> is a constant array declarator or an adjustable array declarator whose upper dimension
bound of the last dimension is an asterisk (e.g., A(M,N,*)) or the integer value 1 (e.g., A(M,N,1)).&nbsp; The array name
must be a dummy argument.&nbsp; The value of the upper bound of the last dimension is determined by the number of elements
of the actual array argument and is computed as follows.&nbsp; First we compute the size of the dummy array.&nbsp; Note that
this size is really an upper bound.
<OL>
<LI>If the corresponding actual array argument is a non-character array name, the size of the dummy array is the size of the
actual array.
<LI>If the corresponding actual array argument is a non-character array element name with a subscript value of<B> r</B> in
an array of size<B> x,</B> the size of the dummy array is<B> x</B> + 1 -<B> r.</B>
<LI>If the corresponding actual argument is a character array name, character array element or a substrung character array
element which begins at character<B> t</B> of an array with<B> c</B> characters then the size of the dummy array is INT((<B>
c</B> + 1 -<B> t</B> ) /<B> e)</B> where<B> e</B> is the size of an element of the dummy array.
</OL>
<BR>If the assumed-size array has dimension<B> n</B> then the product of the first<B> n</B> - 1 dimensions must be less than
or equal to the size of the array as determined by one of the preceding rules.&nbsp; The value of the assumed dimension is
the largest integer such that the product of all of the dimensions is less than or equal to the size of the dummy array.&nbsp;
In the following example,<TT> A(4,*)</TT> is an assumed-size array declarator.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DIMENSION B(10)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALL SQUARE( B )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SUBROUTINE SQUARE( A )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DIMENSION A(4,*)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>By rule 1, the upper bound of the size of<TT> A</TT> is 10.&nbsp; We now look for the largest integer<B> n</B> such
that 4 *<B> n</B> is less than or equal to 10.&nbsp; Clearly,<B> n</B> is 2.<TT>&nbsp; A</TT> is therefore a 2-dimensional
array with 4 rows and 2 columns.
<H3 ID="Allocatable_Array_Declarator"> Allocatable Array Declarator </H3>
<BR>An<B> allocatable array declarator</B> is one that contains no dimension bound expressions.&nbsp; It is called an allocatable
array declarator because the dimension bounds are specified at run-time in an<TT> ALLOCATE</TT> statement.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DIMENSION A(:), B(:,:)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ALLOCATE( A(N) )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ALLOCATE( B(0:4,5) )</TT>
<BR><BR>In the previous example,<TT> A(:)</TT> is a one-dimensional allocatable array declarator and<TT> B(:,:)</TT> is a
two-dimensional allocatable array declarator.&nbsp; The first<TT> ALLOCATE</TT> statement is used to allocate the array<TT>
A</TT> with bounds<TT> 1:N.</TT>&nbsp; The second<TT> ALLOCATE</TT> statement is used to allocate the array<TT> B</TT> with
bounds<TT> 0:4</TT> in the first dimension and<TT> 1:5</TT> in the second dimension.
<H2 ID="Classifying_Array_Declarators_by_Array_Name"> Classifying Array Declarators by Array Name </H2>
<BR>Array declarators can also be classified according to the characteristic of the array name.&nbsp; The following sections
discuss the two classifications.
<H3 ID="Actual_Array_Declarator"> Actual Array Declarator </H3>
<BR>An<B> actual array declarator</B> is one in which the array name is not a dummy argument.&nbsp; All actual array declarators
must also be constant array declarators.&nbsp; An actual array declarator is permitted in a<TT> DIMENSION</TT> statement,
a type statement or a<TT> COMMON</TT> statement.
<H3 ID="Dummy_Array_Declarator"> Dummy Array Declarator </H3>
<BR>A<B> dummy array declarator</B> is one in which the array name is a dummy argument and hence can only appear in a function
or subroutine subprogram.&nbsp; It can be a constant, adjustable or assumed-size array declarator.&nbsp; A dummy array declarator
can appear in a<TT> DIMENSION</TT> statement or a type statement but not in a<TT> COMMON</TT> statement.&nbsp; It should be
noted that the array declarator for a dummy array declarator need not be the same as the array declarator of the corresponding
actual array declarator.&nbsp; Also note that every array declarator in a main program must be a constant array declarator.
<H2 ID="Use_of_Array_Names"> Use of Array Names </H2>
<BR>The appearance of an array name must always be as part of an array element name except in the following cases:
<OL>
<LI>in a list of dummy arguments.&nbsp; For example, a subroutine that has as one of its arguments an array.
<LI>in a<TT> COMMON</TT> statement to define that array as belonging to a common block.
<LI>in a type statement either as part of an array declarator or by itself to establish the type of the array.
<LI>in an array declarator in a<TT> DIMENSION</TT>, type or<TT> COMMON</TT> statement.
<LI>in an<TT> EQUIVALENCE</TT> statement.
<LI>in a<TT> DATA</TT> statement.
<LI>in the list of actual arguments when calling an external procedure.
<LI>In the list of an input/output statement.
<LI>as a unit identifier for an internal file in an input/output statement.
<LI>as a format identifier in an input/output statement.
<LI>in a<TT> SAVE</TT> statement.
</OL>
<H1 ID="Character_Substrings"> Character Substrings </H1>
<BR>A<B> substring</B> is a contiguous portion of a character entity.&nbsp; The substring operation selects a substring from
a character entity.&nbsp; The resulting substring can then be treated as a character entity in itself.&nbsp; Substringing
also allows the replacement of substrings from character entities with other character entities.
<H2 ID="Substring_Names"> Substring Names </H2>
<BR>Substrings are formed by specifying a substring name.&nbsp; The forms of a<B> substring name</B> are:
<BR><BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v( [ e1] : [ e2] )</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a(s [,s] ...)( [ e1] : [ e2] )</TT></TT>&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>v
<DD>is a character variable name.
<DT>a(s[,s]...)
<DD>is a character array element name.
<DT>e1
<DD>is an integer expression identifying the leftmost character of the substring.
<DT>e2
<DD>is an integer expression identifying the rightmost character of the substring.
</DL>
<BR><TT>e1</TT> and<TT> e2</TT> are called<B> substring expressions.</B>&nbsp; They must be such that
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 1 &lt;= e1 &lt;= e2 &lt;= len</TT>
<BR><BR>where<TT> len</TT> is the length of the character entity.&nbsp; If<TT> e1</TT> is omitted, a value of 1 is assumed.
&nbsp;If<TT> e2</TT> is omitted, a value of<TT> len</TT> is assumed.&nbsp; Both<TT> e1</TT> and<TT> e2</TT> may be omitted.
&nbsp;The length of the substring is<TT> e2</TT> -<TT> e1</TT> + 1.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER A*8, B(4)*8, C*14</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * A gets the string 'EVERYDAY'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A = 'EVERYDAY'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Replace 'DAY' with 'ONE' in A</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A(6:8) = 'ONE'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * B(1) gets the string 'OTHELLO'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B(1) = 'OTHELLO'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * B(2) gets same value as B(1)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B(2)(:) = 'OTHELLO'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * B(3) gets last 6 characters of B(1)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B(3) = B(1)(3:8)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * B(4) gets first 4 characters of B(1)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; concatenated with the letter 'R'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B(4) = B(1)(1:4) // 'R'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * C gets last 6 characters of B(1)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; concatenated with the variable A</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C = B(1)(3:) // A</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Print out the results</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, A</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT '(A8)', B</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, C</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<H2 ID="Extensions"> Extensions </H2>
<BR>Open Watcom FORTRAN 77 allows an external character function reference or a character statement function reference as
part of the substring name (see the chapter entitled <A HREF="#Functions_and_Subroutines">Functions and Subroutines</A>.&nbsp;
for more information).
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*10 F,G</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*10 X</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * DEFINE CHARACTER STATEMENT FUNCTION</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; G(X) = X</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, F('0123456789')(1:5)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, G('0123456789')(6:10)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * DEFINE CHARACTER EXTERNAL FUNCTION</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*(*) FUNCTION F( X )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*10 X</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; F = X</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<H1 ID="Structures__Unions_and_Records"> Structures, Unions and Records </H1>
<BR>The following sections describe support for composite data types.
<H2 ID="Structures_and_Records"> Structures and Records </H2>
<BR>As an extension to the basic FORTRAN 77 types such as INTEGER, REAL, LOGICAL, etc., Open Watcom FORTRAN 77 supports the
creation of hierarchical, composite data types called<B> structures.</B>&nbsp; A structure is a template describing the form
of a<B> record.</B>&nbsp; It is composed of members or fields of various types, including other structures.&nbsp; A structure
does not reserve any storage.
<BR><BR>For example, you could describe the structure of the COMPLEX data type using the following construction.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STRUCTURE /CMPLX/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REAL REAL_PART</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REAL IMAG_PART</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END STRUCTURE</TT>
<BR><BR>Since the COMPLEX data type is an intrinsic type of FORTRAN, there is no need to do so.&nbsp; The<TT> STRUCTURE</TT>
and<TT> END STRUCTURE</TT> statements mark the start and end of a structure definition.
<BR><BR>There are, however, many practical examples of collections of data that may be described using a structure.&nbsp;
Consider, for example, the contents of a data record on disk.&nbsp; It may contain fields such as last name, first name, and
middle initial which describe the name of a customer.&nbsp; Each of these fields are fixed in length.&nbsp; A sample structure
declaration might be:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STRUCTURE /NAME/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*20 LAST_NAME</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*20 FIRST_NAME</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*1&nbsp; MIDDLE_INITIAL</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END STRUCTURE</TT>
<BR><BR>As we stated above, a structure does not allocate storage.&nbsp; Instead, we have created a new type called<TT> NAME</TT>
which may be used to describe objects.&nbsp; Objects of the new type are defined using the<TT> RECORD</TT> statement.&nbsp;
For example, the following statements describe two objects,<TT> STUDENT_1</TT> and<TT> STUDENT_2</TT>, to be of type<TT> NAME.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RECORD /NAME/ STUDENT_1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RECORD /NAME/ STUDENT_2</TT>
<BR><BR>There are other attributes of a person besides one's name that could be recorded in the record.&nbsp; For example,
we can also store a person's date of birth and sex.&nbsp; First, let us define a<TT> DATE</TT> structure.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STRUCTURE /DATE/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER*1 DAY</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER*1 MONTH</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER*2 YEAR</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END STRUCTURE</TT>
<BR><BR>Now we can describe a person in terms of name, date of birth, and sex.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STRUCTURE /PERSON/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RECORD /NAME/ NAME</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RECORD /DATE/ BIRTH_DATE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*1 SEX</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END STRUCTURE</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RECORD /PERSON/ STUDENT</TT>
<BR><BR>Having declared<TT> STUDENT</TT> to be of type<TT> PERSON</TT>, how do we reference the component parts of<TT> STUDENT</TT>?
&nbsp;The following example illustrates this.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STUDENT.NAME.LAST_NAME = 'Pugsley'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STUDENT.NAME.FIRST_NAME = 'Elmar'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STUDENT.NAME.MIDDLE_INITIAL = 'M'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STUDENT.BIRTH_DATE.DAY = 21</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STUDENT.BIRTH_DATE.MONTH = 11</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STUDENT.BIRTH_DATE.YEAR = 1959</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STUDENT.SEX = 'M'</TT>
<BR><BR>The object's name is specified first, followed by a &quot;.&quot; (or &quot;%&quot;) and the structure member name.
&nbsp;If the structure member is itself a record then another &quot;.&quot; (or &quot;%&quot;) and member name is specified.
&nbsp;This continues until the desired structure member is identified.&nbsp; The &quot;.&quot; or &quot;%&quot; is called
a<B> field selection operator.</B>
<BR><BR>The previous example contained both a structure called<TT> NAME (RECORD /NAME/)</TT> and a structure member called<TT>
NAME (RECORD /NAME/ NAME).</TT>&nbsp; The structure name is enclosed within slashes (&quot;/&quot;).&nbsp; A structure name
must be unique among structure names.&nbsp; However, the same name can also be used to name either variables or structure
members (fields).&nbsp; Thus it is possible to have a variable named<TT> X,</TT> a structure named<TT> X,</TT> and one or
more fields named<TT> X.</TT>
<BR><BR>Structure, field, and variable names are all local to the program unit in which they are defined.
<H2 ID="Arrays_of_Records"> Arrays of Records </H2>
<BR>It is often the case that the individual attributes of objects are stored in separate arrays.&nbsp; If, for example, your
application deals with 1000 objects with attributes &quot;size&quot;, &quot;weight&quot;, and &quot;colour&quot;, the traditional
approach is to declare three different arrays.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PARAMETER (MAX_ELS=1000)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REAL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SIZE(MAX_ELS)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER&nbsp;&nbsp;&nbsp;&nbsp; WEIGHT(MAX_ELS)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*2 COLOUR(MAX_ELS)</TT>
<BR><BR>To read or write the attributes relating to an object, you would use a statement such as:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ(UNIT=3) SIZE(I), WEIGHT(I), COLOUR(I)</TT>
<BR><BR>Using a simple structure, we can express the problem as follows:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PARAMETER (MAX_ELS=1000)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STRUCTURE /OBJECT/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REAL&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; SIZE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER&nbsp;&nbsp;&nbsp;&nbsp;
WEIGHT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*2 COLOUR</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END STRUCTURE</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RECORD /OBJECT/ ITEM(MAX_ELS)</TT>
<BR><BR>To read or write the attributes relating to an object, you would use a statement such as:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ(UNIT=3) ITEM(I)</TT>
<H2 ID="Unions"> Unions </H2>
<BR>Sometimes it is useful to be able to describe parts of structures in different ways in much the same way that the<TT>
EQUIVALENCE</TT> statement is used to describe a specific storage area in different ways.&nbsp; The<TT> UNION</TT> -<TT> END
UNION</TT> statements are used to mark a section of a structure that will have alternate storage organizations (MAPs).&nbsp;
The<TT> MAP</TT> -<TT> END MAP</TT> statements are used to define the start and end of an alternate storage map.&nbsp; Thus
several<TT> MAP</TT> -<TT> END MAP</TT> pairs will appear between a<TT> UNION</TT> -<TT> END UNION</TT> section.
<BR><BR>Consider the following example.&nbsp; The subroutine displays the contents of a field using different names and formats
depending on a<TT> TYPE</TT> field.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SUBROUTINE PRINT_ITEM( ITEM )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STRUCTURE /DATA_MAP/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER
TYPE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UNION</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; MAP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOGICAL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LGL</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; END MAP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; MAP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; END MAP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; MAP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REAL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FLT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; END MAP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; MAP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DOUBLE PRECISION&nbsp; DBL</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; END MAP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END UNION</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END STRUCTURE</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RECORD /DATA_MAP/ ITEM</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( ITEM%TYPE .EQ. 1 ) THEN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT
'(L2)', ITEM%LGL</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ELSEIF( ITEM%TYPE .EQ. 2 ) THEN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT
'(I8)', ITEM%INT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ELSEIF( ITEM%TYPE .EQ. 3 ) THEN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT
'(E12.5)', ITEM%FLT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ELSEIF( ITEM%TYPE .EQ. 4 ) THEN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT
'(D12.5)', ITEM%DBL</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDIF</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>The organization of the record in memory is as follows:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; offset&nbsp; +0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +4&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +8</TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT>&nbsp;&nbsp;&nbsp; integer&nbsp;&nbsp;&nbsp;
&nbsp;logical&nbsp;&nbsp;&nbsp;&nbsp; (slack)</TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer&nbsp;&nbsp;&nbsp;&nbsp; (slack)</TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (slack)</TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double precision</TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR><BR>The first 4 bytes of storage are occupied by<TT> TYPE.</TT>&nbsp; The next 4 to 8 bytes of storage are occupied by
either<TT> LGL, INT, FLT,</TT> or<TT> DBL</TT> depending on the interpretation of the contents of the variable<TT> TYPE.</TT>
&nbsp;The size of the record<TT> ITEM</TT> is a total of 12 bytes.&nbsp; Based on the conventions of the above program example,
only 8 bytes of the record<TT> ITEM</TT> are used when<TT> TYPE</TT> is 1, 2, or 3.&nbsp; When<TT> TYPE</TT> is 4 then 12
bytes of the record are used.
<BR><BR>The following example maps out a 4-byte integer on an Intel 80x86-based processor.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STRUCTURE /MAPINT/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UNION</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MAP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; INTEGER*4 LONG</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END MAP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MAP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; INTEGER*2 LO_WORD</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; INTEGER*2 HI_WORD</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END MAP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MAP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; INTEGER*1 BYTE_0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; INTEGER*1 BYTE_1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; INTEGER*1 BYTE_2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; INTEGER*1 BYTE_3</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END MAP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END UNION</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END STRUCTURE</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RECORD /MAPINT/ I</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I%LONG = '01020304'x</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT '(Z8)', I%LONG</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT '(Z4,1X,Z4)', I%LO_WORD, I%HI_WORD</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT '(Z2,3(1X,Z2))', I%BYTE_0, I%BYTE_1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I%BYTE_2, I%BYTE_3</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>The above example produces the following output:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 01020304</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0304 0102</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 04 03 02 01</TT>
<H1 ID="Expressions"> Expressions </H1>
<BR>The following topics are discussed in this chapter.
<UL>
<LI>Arithmetic Expressions
<LI>Character Expressions
<LI>Relational Expressions
<LI>Logical Expressions
<LI>Evaluating Expressions
<LI>Constant Expressions
</UL>
<H2 ID="Arithmetic_Expressions"> Arithmetic Expressions </H2>
<BR>Arithmetic expressions are used to describe computations involving operands with numeric data type, arithmetic operators
and left and right parentheses.&nbsp; The result of the computation is of numeric data type.
<H3 ID="Arithmetic_Operators"> Arithmetic Operators </H3>
<BR>The following table lists the arithmetic operators and the operation they perform.
<BR><BR> <TT>&nbsp;&nbsp;&nbsp; Operator&nbsp;&nbsp;&nbsp; Arithmetic Operation</TT></TT>&nbsp;&nbsp; <TT><TT></TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp; **</TT>&nbsp;&nbsp;&nbsp;&nbsp; <TT>&nbsp;&nbsp;&nbsp;&nbsp; Exponentiation</TT></TT>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp; /</TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT>&nbsp;&nbsp;&nbsp;&nbsp; Division</TT></TT>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp; *</TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT>&nbsp;&nbsp;&nbsp;&nbsp; Multiplication</TT></TT>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp; -</TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT>&nbsp;&nbsp;&nbsp;&nbsp; Subtraction or Negation</TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp; +</TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT>&nbsp;&nbsp;&nbsp;&nbsp; Addition or Identity</TT></TT>
&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR>Some operators can be either binary or unary.&nbsp; A<B> binary operator</B> is one that requires two operands.&nbsp;
A<B> unary operator</B> is one that requires one operand.&nbsp; Each of the operators **, /, and * are binary operators.&nbsp;
The operators + and - can either be binary or unary operators.&nbsp; The following table describes how each operator is used
with their operands.
<BR><BR> <TT>&nbsp;&nbsp;&nbsp; Operator&nbsp;&nbsp;&nbsp; Arithmetic Operation</TT></TT>&nbsp;&nbsp; <TT><TT></TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp; x ** y</TT> <TT>&nbsp;&nbsp;&nbsp;&nbsp; x is raised to the power y</TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp; x / y</TT>&nbsp; <TT>&nbsp;&nbsp;&nbsp;&nbsp; x is divided by y</TT></TT>&nbsp;&nbsp;
&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp; x * y</TT>&nbsp; <TT>&nbsp;&nbsp;&nbsp;&nbsp; x is multiplied by y</TT></TT>&nbsp;&nbsp;
<TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp; x - y</TT>&nbsp; <TT>&nbsp;&nbsp;&nbsp;&nbsp; y is subtracted from x</TT></TT> <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp; x + y</TT>&nbsp; <TT>&nbsp;&nbsp;&nbsp;&nbsp; y is added to x</TT></TT>&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - x</TT>&nbsp; <TT>&nbsp;&nbsp;&nbsp;&nbsp; x is negated</TT></TT>&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + x</TT>&nbsp; <TT>&nbsp;&nbsp;&nbsp;&nbsp; identity</TT></TT>&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR>Arithmetic expressions can contain more than one operator.&nbsp; It is thus necessary to define rules of evaluation for
such expressions.&nbsp; A<B> precedence relation</B> is defined between operators.&nbsp; This relation defines the order in
which operands are combined and hence describes the evaluation sequence of an arithmetic expression.&nbsp; Operands of higher
precedence operators are combined using that operator to form an operand for an operator of lower precedence.&nbsp; The following
rules define the precedence relation among arithmetic operators.
<OL>
<LI>Exponentiation<TT> (**)</TT> has highest precedence.
<LI>Multiplication<TT> (*)</TT> and division (/) have equal precedence but have lower precedence than exponentiation.
<LI>Addition (+) and subtraction (-) have equal precedence but have lower precedence than multiplication and division.
</OL>
<BR>For example, to evaluate the expression
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A-B**4</TT>
<BR><BR><TT>B</TT> is raised to the exponent 4 first and the result is then subtracted from<TT> A.</TT>
<BR><BR>Parentheses can be used to alter the evaluation sequence of an arithmetic expression.&nbsp; When a left parenthesis
is encountered, the entire expression enclosed in parentheses is evaluated.&nbsp; Consider the following expression.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3*(4+5)</TT>
<BR><BR>We first evaluate the expression in the parentheses, the result being 9.&nbsp; We now multiply the result by 3 giving
a final result of 27.&nbsp; Now suppose we remove the parentheses.&nbsp; According to the precedence rules,<TT> *</TT> has
precedence over + so we perform the multiplication before the addition.&nbsp; The result in this case is 17.
<H3 ID="Rules_for_Forming_Standard_Arithmetic_Expressions"> Rules for Forming Standard Arithmetic Expressions </H3>
<BR>The building blocks for arithmetic expressions are called<B> arithmetic primaries.</B>&nbsp; They are one of the following:
<OL>
<LI>unsigned arithmetic constant
<LI>arithmetic symbolic constant
<LI>arithmetic variable reference
<LI>arithmetic array element reference
<LI>arithmetic function reference
<LI>( arithmetic expression )
</OL>
<BR>A grammar for forming arithmetic expressions can be described which reflects the precedence relation among arithmetic
operators.
<BR><BR>Exponentiation has highest precedence.&nbsp; We define a<B> factor</B> as:
<OL>
<LI>primary
<LI>primary ** factor
</OL>
<BR>A factor is simply a sequence of primaries, each separated by the exponentiation operator.&nbsp; Rule (2) specifies that
the primaries involving exponentiation operators are combined from right to left when evaluating a factor.
<BR><BR>Next in the precedence hierarchy are the multiplication and division operators.&nbsp; We define a<B> term</B> as:
<OL>
<LI>factor
<LI>term / factor
<LI>term * factor
</OL>
<BR>A term is simply a sequence of factors, each separated by a multiplication operator or a division operator.&nbsp; Rules
(2) and (3) imply that in such a sequence, factors are combined from left to right when evaluating a term.&nbsp; Factors can
be interpreted as the result obtained from evaluating them.&nbsp; This implies that all factors are evaluated before any of
the multiplication or division operands are combined.&nbsp; This interpretation is consistent with the precedence relation
between the exponentiation operator and the division and multiplication operators.
<BR><BR>An<B> arithmetic expression</B> can now be defined as follows.
<OL>
<LI>term
<LI>+ term
<LI>- term
<LI>arithmetic expression + term
<LI>arithmetic expression - term
</OL>
<BR>An arithmetic expression is simply a sequence of terms, each separated by an addition operator or a subtraction operator.
&nbsp;Rules (4) and (5) imply that terms are evaluated from left to right.&nbsp; Rules (2) and (3) imply that only the first
term of an arithmetic expression can be preceded by a unary + or - operator.&nbsp; Terms can be interpreted in the same way
as factors were interpreted in the definition of terms.
<BR><BR>Note that consecutive operators are not permitted.&nbsp; For example, the expression
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A+-B</TT>
<BR><BR>is illegal.&nbsp; However, expressions of the form
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A+(-B)</TT>
<BR><BR>are allowed.
<H3 ID="Arithmetic_Constant_Expression"> Arithmetic Constant Expression </H3>
<BR>An<B> arithmetic constant expression</B> is an arithmetic expression in which all primaries are one of the following.
<OL>
<LI>arithmetic constant
<LI>symbolic arithmetic constant
<LI>( arithmetic constant expression )
</OL>
<BR>There is a further restriction with the exponentiation operator; the exponent must be of type INTEGER.
<BR><BR>As an extension to the FORTRAN 77 language, Open Watcom FORTRAN 77 supports the use of the intrinsic function<TT>
ISIZEOF</TT> in an arithmetic constant expression.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PARAMETER (INTSIZ = ISIZEOF(INTEGER))</TT>
<BR><BR>An<B> integer constant expression</B> is an arithmetic constant expression in which all constants and symbolic constants
are of type INTEGER.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 123</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -753+2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -(12*13)</TT>
<BR><BR>A<B> real constant expression</B> is an arithmetic constant expression in which at least one constant or symbolic
constant is of type REAL and all other constants or symbolic constants are of type REAL or INTEGER.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 123.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -753+2.0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -(13E0*12)</TT>
<BR><BR>A<B> double precision constant expression</B> is an arithmetic constant expression in which at least one constant
or symbolic constant is of type DOUBLE PRECISION and all other constants or symbolic constants are of type DOUBLE PRECISION,
REAL or INTEGER.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 123.4D0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -753D0*2+.5</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -(12D0*12.2)</TT>
<BR><BR>A<B> complex constant expression</B> is an arithmetic constant expression in which at least one constant or symbolic
constant is of type COMPLEX and all other constants or symbolic constants are of type COMPLEX, REAL or INTEGER.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (123,0)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (-753,12.3)*2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -(12,-12.4)-(1.0,.2)</TT>
<BR><BR>A<B> double precision complex constant expression</B> is an arithmetic constant expression in which at least one constant
or symbolic constant is of type COMPLEX*16 and all other constants or symbolic constants are of type COMPLEX*16, DOUBLE PRECISION,
REAL or INTEGER.&nbsp; If there are no constants or symbolic constants of type COMPLEX*16 in a constant expression, the type
of the constant expression will be COMPLEX*16 if it contains at least one constant or symbolic constant of type COMPLEX and
at least one constant or symbolic constant of type DOUBLE PRECISION.&nbsp; Open Watcom FORTRAN 77 supports this type of constant
expression as an extension of the FORTRAN 77 language.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (123,0D0)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (-753,12.3D0)*2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -(12D0,-12.4)-(1.0,.2)</TT>
<H3 ID="Data_Type_of_Arithmetic_Expressions"> Data Type of Arithmetic Expressions </H3>
<BR>Evaluating an arithmetic expression produces a result which has a type.&nbsp; The type of the result is determined by
the type of its operands.&nbsp; The following table describes the rules for determining the type of arithmetic expressions.
&nbsp;The letters I, R, D, C and Z stand for INTEGER, REAL, DOUBLE PRECISION, COMPLEX and COMPLEX*16 respectively.&nbsp; An
entry in the table represents the data type of the result when the operands are of the type indicated by the row and column
in which the entry belongs.&nbsp; The column represents the type of the operand to the right of the operator, and the row
represents the type of the operand to the left of the operator.&nbsp; The table is valid for all of the arithmetic operators.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +-------+-------+-------+-------+-------+-------+-------+-------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; op&nbsp;&nbsp; |&nbsp; I*1&nbsp; |&nbsp; I*2&nbsp; |&nbsp; I*4&nbsp; |&nbsp;&nbsp;
R&nbsp;&nbsp; |&nbsp;&nbsp; D&nbsp;&nbsp; |&nbsp;&nbsp; C&nbsp;&nbsp; |&nbsp;&nbsp; Z&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +-------+-------+-------+-------+-------+-------+-------+-------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; I*1&nbsp; |&nbsp; I*1&nbsp; |&nbsp; I*2&nbsp; |&nbsp; I*4&nbsp; |&nbsp;&nbsp; R&nbsp;
&nbsp;|&nbsp;&nbsp; D&nbsp;&nbsp; |&nbsp;&nbsp; C&nbsp;&nbsp; |&nbsp;&nbsp; Z&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; I*2&nbsp; |&nbsp; I*2&nbsp; |&nbsp; I*2&nbsp; |&nbsp; I*4&nbsp; |&nbsp;&nbsp; R&nbsp;
&nbsp;|&nbsp;&nbsp; D&nbsp;&nbsp; |&nbsp;&nbsp; C&nbsp;&nbsp; |&nbsp;&nbsp; Z&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; I*4&nbsp; |&nbsp; I*4&nbsp; |&nbsp; I*4&nbsp; |&nbsp; I*4&nbsp; |&nbsp;&nbsp; R&nbsp;
&nbsp;|&nbsp;&nbsp; D&nbsp;&nbsp; |&nbsp;&nbsp; C&nbsp;&nbsp; |&nbsp;&nbsp; Z&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; R&nbsp;&nbsp; |&nbsp;&nbsp; R&nbsp;&nbsp; |&nbsp;&nbsp; R&nbsp;&nbsp; |&nbsp;
&nbsp;R&nbsp;&nbsp; |&nbsp;&nbsp; R&nbsp;&nbsp; |&nbsp;&nbsp; D&nbsp;&nbsp; |&nbsp;&nbsp; C&nbsp;&nbsp; |&nbsp;&nbsp; Z&nbsp;
&nbsp;|</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; D&nbsp;&nbsp; |&nbsp;&nbsp; D&nbsp;&nbsp; |&nbsp;&nbsp; D&nbsp;&nbsp; |&nbsp;
&nbsp;D&nbsp;&nbsp; |&nbsp;&nbsp; D&nbsp;&nbsp; |&nbsp;&nbsp; D&nbsp;&nbsp; |&nbsp;&nbsp; Z&nbsp;&nbsp; |&nbsp;&nbsp; Z&nbsp;
&nbsp;|</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; C&nbsp;&nbsp; |&nbsp;&nbsp; C&nbsp;&nbsp; |&nbsp;&nbsp; C&nbsp;&nbsp; |&nbsp;
&nbsp;C&nbsp;&nbsp; |&nbsp;&nbsp; C&nbsp;&nbsp; |&nbsp;&nbsp; Z&nbsp;&nbsp; |&nbsp;&nbsp; C&nbsp;&nbsp; |&nbsp;&nbsp; Z&nbsp;
&nbsp;|</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; Z&nbsp;&nbsp; |&nbsp;&nbsp; Z&nbsp;&nbsp; |&nbsp;&nbsp; Z&nbsp;&nbsp; |&nbsp;
&nbsp;Z&nbsp;&nbsp; |&nbsp;&nbsp; Z&nbsp;&nbsp; |&nbsp;&nbsp; Z&nbsp;&nbsp; |&nbsp;&nbsp; Z&nbsp;&nbsp; |&nbsp;&nbsp; Z&nbsp;
&nbsp;|</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +-------+-------+-------+-------+-------+-------+-------+-------+</TT>
<BR><BR><B>Notes:</B>
<OL>
<LI>I*1 represents the<TT> INTEGER*1</TT> data type, I*2 represents the<TT> INTEGER*2</TT> data type, and I*4 represents the<TT>
INTEGER</TT> or<TT> INTEGER*4</TT> data type.
<LI>The data type of the result obtained by dividing an integer datum by an integer datum is also of type INTEGER even though
the mathematical result may not be an integer.&nbsp; This result is called the<B> integer quotient</B> and is defined as the
integer part of the mathematical quotient.
<LI>Open Watcom FORTRAN 77 supports the double precision complex data type (COMPLEX*16) as an extension of the FORTRAN 77
language.&nbsp; Combining an operand of type DOUBLE PRECISION with an operand of type COMPLEX yields a result of type COMPLEX*16.
</OL>
<H2 ID="Character_Expressions"> Character Expressions </H2>
<BR>Character expressions are used to describe computations involving operands of type CHARACTER, the concatenation operator
(//) and left and right parentheses.&nbsp; The result of the computation is of type CHARACTER.
<H3 ID="Character_Operators"> Character Operators </H3>
<BR>There is only one character operator, namely the concatenation operator (//).&nbsp; It requires two operands of type CHARACTER.
&nbsp;If<TT> x</TT> is the left operand and<TT> y</TT> is the right operand, then the result is<TT> y</TT> concatenated to<TT>
x.</TT>&nbsp; The length of the result is the sum of the lengths of the two operands.&nbsp; For example, the result of
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'AAAAA'//'BBB'</TT>
<BR><BR>is the string<TT> AAAAABBB.</TT>
<H3 ID="Rules_for_Forming_Character_Expressions"> Rules for Forming Character Expressions </H3>
<BR>The building blocks for character expressions are called<B> character primaries.</B>&nbsp; They are one of the following.
<OL>
<LI>character constant
<LI>character symbolic constant
<LI>character variable reference
<LI>character array element reference
<LI>character substring reference
<LI>character function reference
<LI>( character expression )
</OL>
<BR><B> Character expressions</B> are defined as follows:
<OL>
<LI>character primary
<LI>character expression // character primary
</OL>
<BR>A character expression is simply a sequence of character primaries, each separated by the concatenation operator (//).
&nbsp;Rule 2 implies that character primaries are combined from left to right.&nbsp; Except in a character assignment statement,
the operands in a character expression must not contain operands whose length specification is (*) unless the operand is a
symbolic constant.
<BR><BR>Note that, unlike arithmetic expressions, parentheses have no effect on the result of evaluating a character expression.
&nbsp;For example, the result of the expressions
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'A'//'B'//'C'</TT>
<BR><BR>and
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'A'//('B'//'C')</TT>
<BR><BR>is identically the string<TT> ABC.</TT>
<H3 ID="Character_Constant_Expressions"> Character Constant Expressions </H3>
<BR>A<B> character constant expression</B> is a character expression in which all primaries are one of the following.
<OL>
<LI>character constant
<LI>symbolic character constant
<LI>( character constant expression )
</OL>
<BR>As an extension to the FORTRAN 77 language, Open Watcom FORTRAN 77 supports the use of the intrinsic function<TT> CHAR</TT>
in a character constant expression.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*6 HELLO, WORLD</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PARAMETER (HELLO = 'Hello'//CHAR(0))</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PARAMETER (WORLD = 'world'//CHAR(7))</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, HELLO, WORLD</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<H2 ID="Relational_Expressions"> Relational Expressions </H2>
<BR>A relational expression is used to compare two arithmetic expressions or two character expressions.&nbsp; It is not possible
to compare a character expression to an arithmetic expression.&nbsp; Evaluation of a relational expression produces a result
of type logical.
<H3 ID="Relational_Operators"> Relational Operators </H3>
<BR>The following table lists the<B> relational operators</B> and the operation they perform.
<BR><BR> <TT>&nbsp;&nbsp;&nbsp; Operator&nbsp;&nbsp;&nbsp; Relational Operation</TT></TT>&nbsp;&nbsp; <TT><TT></TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp; .LT.</TT>&nbsp; <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Less than</TT></TT>&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp; .LE.</TT>&nbsp; <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Less than or equal</TT></TT>
&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp; .EQ.</TT>&nbsp; <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Equal</TT></TT>&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp; .NE.</TT>&nbsp; <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Not equal</TT></TT>&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp; .GT.</TT>&nbsp; <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Greater than</TT></TT>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp; .GE.</TT>&nbsp; <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Greater than or equal</TT></TT>
<TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<H3 ID="Form_of_a_Relational_Expression"> Form of a Relational Expression </H3>
<BR>The form of a<B> relational expression</B> is as follows.
<BR><BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e1 relop e2</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>relop
<DD>is a relational operator.
<DT>e1, e2
<DD>are both arithmetic expressions or both character expressions.
</DL>
<H4 ID="Arithmetic_Relational_Expressions"> Arithmetic Relational Expressions </H4>
<BR>An<B> arithmetic relational expression</B> is a relational expression in which<TT> e1</TT> and<TT> e2</TT> are both arithmetic
expressions.&nbsp; An arithmetic relational expression has a value of true if the operands satisfy the relation specified
by the relational operator and false otherwise.
<BR><BR>A complex operand is only permitted when using either the .EQ.&nbsp; or .NE.&nbsp; relational operators.&nbsp; Open
Watcom FORTRAN 77 allows operands of type COMPLEX*16.
<H4 ID="Character_Relational_Expressions"> Character Relational Expressions </H4>
<BR><B> Character relational expressions</B> are relational expressions whose operands are of type CHARACTER.&nbsp; The value
of a relation between character strings is established by using the<B> collating sequence</B> of the processor character set.
&nbsp;The collating sequence is an ordering of the characters in the processor character set.&nbsp; Note, for example, that
the EBCDIC character set has a different collating sequence than that of the ASCII character set.&nbsp; For example,<TT> e1</TT>
is greater than<TT> e2</TT> if the value of<TT> e1</TT> follows the value of<TT> e2</TT> in the processor collating sequence.
&nbsp;The value of a character relational expression depends on the collating sequence.&nbsp; In the case of the .NE.&nbsp;
and .EQ.&nbsp; operators, the collating sequence has no effect.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( 'A' .LT. 'a' )THEN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'The processor character
set'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'appears to be ASCII'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ELSE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'The processor character
set'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'appears to be EBCDIC'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END IF</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>The above example is a crude test for determining the character set used on your processor.
<BR><BR>It is possible to have operands of unequal length.&nbsp; In this case, the character string of smaller length is treated
as if blanks were padded to the right of it to the length of the larger string.&nbsp; The relational operator is then applied.
<H2 ID="Logical_Expressions"> Logical Expressions </H2>
<BR>Logical expressions are used to describe computations involving operands whose type is LOGICAL or INTEGER, logical operators
and left and right parentheses.&nbsp; The result of the computation is of type LOGICAL unless both operands are of type INTEGER
in which case the result of the computation is of type INTEGER.
<H3 ID="Logical_Operators"> Logical Operators </H3>
<BR>The following table lists the<B> logical operators</B> and the operation they perform.
<BR><BR> <TT>&nbsp;&nbsp;&nbsp; Operator&nbsp;&nbsp;&nbsp; Logical Operation</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp; .NOT.</TT> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Logical negation</TT></TT>&nbsp;&nbsp;
&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp; .AND.</TT> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Logical conjunction</TT></TT>&nbsp;
&nbsp;<TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp; .OR.</TT>&nbsp; <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Logical inclusive disjunction</TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp; .EQV.</TT> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Logical equivalence</TT></TT>&nbsp;
&nbsp;<TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp; .NEQV.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Logical non-equivalence</TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp; .XOR.</TT> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exclusive or</TT></TT>&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR>The logical operator .NOT.&nbsp; is a unary operator; all other logical operators are binary.&nbsp; The following tables
describe the result of each operator when it is used with logical operands.
<BR><BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x</TT>&nbsp;&nbsp;&nbsp; <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .NOT. x</TT></TT>
&nbsp;&nbsp; <TT><TT></TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp; true</TT>&nbsp;&nbsp; <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; false</TT></TT>&nbsp;&nbsp;
&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp; false</TT>&nbsp; <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; true</TT></TT>&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x</TT> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y</TT> <TT>&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;x .AND. y</TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp; true&nbsp;&nbsp;&nbsp; true&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; true</TT></TT> <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp; true&nbsp;&nbsp;&nbsp; false&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; false</TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp; false&nbsp;&nbsp; true&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; false</TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp; false&nbsp;&nbsp; false&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; false</TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x</TT> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y</TT> <TT>&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;x .OR.</TT> <TT>y</TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp; true&nbsp;&nbsp;&nbsp; true&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; true</TT></TT> <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp; true&nbsp;&nbsp;&nbsp; false&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; true</TT></TT> <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp; false&nbsp;&nbsp; true&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; true</TT></TT> <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp; false&nbsp;&nbsp; false&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; false</TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x</TT> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y</TT> <TT>&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;x .EQV. y</TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp; true&nbsp;&nbsp;&nbsp; true&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; true</TT></TT> <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp; true&nbsp;&nbsp;&nbsp; false&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; false</TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp; false&nbsp;&nbsp; true&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; false</TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp; false&nbsp;&nbsp; false&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; true</TT></TT> <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp; x</TT>&nbsp;&nbsp; <TT>&nbsp;&nbsp;&nbsp; y</TT>&nbsp;&nbsp; <TT>&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;x .NEQV. y</TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp; ................ x .XOR. y</TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp; true&nbsp;&nbsp;&nbsp; true&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; false</TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp; true&nbsp;&nbsp;&nbsp; false&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; true</TT></TT> <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp; false&nbsp;&nbsp; true&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; true</TT></TT> <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp; false&nbsp;&nbsp; false&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; false</TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR>Note that the operators .NEQV.&nbsp; and .XOR.&nbsp; perform the same logical operation.
<BR><BR>The following tables describe the result of the logical operators when they are used with integer operands.&nbsp;
These operators apply to bits in the operand(s), hence we show only the result of operations on individual bits.&nbsp; The
way to read the entries in the following tables is:
<OL>
<LI>If the bit in &quot;x&quot; is 0 then the corresponding bit in &quot;.NOT.x&quot; is 1, and so on.
<LI>If the bit in &quot;x&quot; is 1 and the corresponding bit in &quot;y&quot; is 1 then the corresponding bit in &quot;x.AND.y&quot;
is 1, and so on.
</OL>
<BR> <TT>&nbsp;&nbsp;&nbsp; x</TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT>&nbsp;&nbsp;&nbsp;&nbsp; .NOT. x</TT></TT>&nbsp;&nbsp;
&nbsp;&nbsp; <TT><TT></TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp; 0</TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1</TT></TT>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp; 1</TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0</TT></TT>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp; x</TT>&nbsp; <TT>&nbsp;&nbsp;&nbsp;&nbsp; y</TT> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x
.AND. y</TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp; 1</TT>&nbsp; <TT>&nbsp;&nbsp;&nbsp;&nbsp; 1</TT> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; 1</TT></TT>&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp; 1</TT>&nbsp; <TT>&nbsp;&nbsp;&nbsp;&nbsp; 0</TT> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; 0</TT></TT>&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp; 0</TT>&nbsp; <TT>&nbsp;&nbsp;&nbsp;&nbsp; 1</TT> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; 0</TT></TT>&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp; 0</TT>&nbsp; <TT>&nbsp;&nbsp;&nbsp;&nbsp; 0</TT> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; 0</TT></TT>&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp; x</TT>&nbsp; <TT>&nbsp;&nbsp;&nbsp;&nbsp; y</TT> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x
.OR. y</TT></TT> <TT><TT></TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp; 1</TT>&nbsp; <TT>&nbsp;&nbsp;&nbsp;&nbsp; 1</TT> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; 1</TT></TT>&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp; 1</TT>&nbsp; <TT>&nbsp;&nbsp;&nbsp;&nbsp; 0</TT> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; 1</TT></TT>&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp; 0</TT>&nbsp; <TT>&nbsp;&nbsp;&nbsp;&nbsp; 1</TT> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; 1</TT></TT>&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp; 0</TT>&nbsp; <TT>&nbsp;&nbsp;&nbsp;&nbsp; 0</TT> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; 0</TT></TT>&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp; x</TT>&nbsp; <TT>&nbsp;&nbsp;&nbsp;&nbsp; y</TT> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x
.EQV. y</TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp; 1</TT>&nbsp; <TT>&nbsp;&nbsp;&nbsp;&nbsp; 1</TT> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; 1</TT></TT>&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp; 1</TT>&nbsp; <TT>&nbsp;&nbsp;&nbsp;&nbsp; 0</TT> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; 0</TT></TT>&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp; 0</TT>&nbsp; <TT>&nbsp;&nbsp;&nbsp;&nbsp; 1</TT> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; 0</TT></TT>&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp; 0</TT>&nbsp; <TT>&nbsp;&nbsp;&nbsp;&nbsp; 0</TT> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; 1</TT></TT>&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp; x</TT>&nbsp; <TT>&nbsp;&nbsp;&nbsp;&nbsp; y</TT> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x
.NEQV.</TT> <TT>y</TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp; .............. x .XOR. y</TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp; 1</TT>&nbsp; <TT>&nbsp;&nbsp;&nbsp;&nbsp; 1</TT> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; 0</TT></TT>&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp; 1</TT>&nbsp; <TT>&nbsp;&nbsp;&nbsp;&nbsp; 0</TT> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; 1</TT></TT>&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp; 0</TT>&nbsp; <TT>&nbsp;&nbsp;&nbsp;&nbsp; 1</TT> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; 1</TT></TT>&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp; 0</TT>&nbsp; <TT>&nbsp;&nbsp;&nbsp;&nbsp; 0</TT> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; 0</TT></TT>&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR>Note that the operators .NEQV.&nbsp; and .XOR.&nbsp; perform the same mathematical operation on bits.
<BR><BR>As is the case with arithmetic operators, we must define rules in order to evaluate logical expressions.&nbsp; Again
we define rules of precedence for logical operators which dictate the evaluation sequence of logical expressions.&nbsp; The
following lists the logical operators in order of precedence.
<OL>
<LI>.NOT.&nbsp; (highest precedence)
<LI>.AND.
<LI>.OR.
<LI>.EQV., .NEQV.&nbsp; and .XOR.&nbsp; (lowest precedence)
</OL>
<BR>For example, in the expression
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A .OR. B .AND. C</TT>
<BR><BR>the .AND.&nbsp; operator has higher precedence than the .OR.&nbsp; operator so<TT> B</TT> and<TT> C</TT> are combined
first using the .AND.&nbsp; operator.&nbsp; The result is then combined with<TT> A</TT> using the .OR.&nbsp; operator.
<BR><BR>Parentheses can be used to alter the sequence of evaluation of logical expressions.&nbsp; If in the previous example
we had written
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (A .OR. B) .AND. C</TT>
<BR><BR>then<TT> A</TT> and<TT> B</TT> would have been combined first.
<H3 ID="Rules_for_Forming_Logical_Expressions"> Rules for Forming Logical Expressions </H3>
<BR>Logical primaries are the building blocks for logical expressions.&nbsp; They are one of the following.
<OL>
<LI>logical or integer constant
<LI>symbolic logical or integer constant
<LI>logical or integer variable reference
<LI>logical or integer array element reference
<LI>logical or integer function reference
<LI>relational expression
<LI>( logical or integer expression )
</OL>
<BR>As was done with arithmetic expressions, a grammar can be defined which dictates the precedence relation among logical
operators.
<BR><BR>The .NOT.&nbsp; logical operator has highest precedence.&nbsp; We define a<B> logical factor</B> as:
<OL>
<LI>logical primary
<LI>.NOT.&nbsp; logical primary
</OL>
<BR>Next in the precedence hierarchy is the .AND.&nbsp; operator.&nbsp; We define a<B> logical term</B> as:
<OL>
<LI>logical factor
<LI>logical term .AND.&nbsp; logical factor
</OL>
<BR>A logical term is simply a sequence of logical factors, each separated by the .AND.&nbsp; operator.&nbsp; Rule (2) specifies
that the logical factors are combined from left to right.
<BR><BR>Next is the .OR.&nbsp; operator.&nbsp; We define a<B> logical disjunct</B> as:
<OL>
<LI>logical term
<LI>logical disjunct .OR.&nbsp; logical term
</OL>
<BR>A logical disjunct is simply a sequence of logical terms each separated by the .OR.&nbsp; operator.&nbsp; Rule (2) specifies
that the logical terms are combined from left to right.
<BR><BR>A<B> logical expression</B> can now be defined as follows.
<OL>
<LI>logical disjunct
<LI>logical expression .EQV.&nbsp; logical disjunct
<LI>logical expression .NEQV.&nbsp; logical disjunct or logical expression .XOR.&nbsp; logical disjunct
</OL>
<BR>A logical expression is therefore a sequence of logical disjuncts, each separated by the .EQV.&nbsp; operator or the .NEQV.
&nbsp;or .XOR.&nbsp; operator.&nbsp; Rules (2) and (3) indicate that logical disjuncts are combined from left to right.
<BR><BR>Consider the following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A .OR. .NOT. B .AND. C</TT>
<BR><BR>Since the .NOT.&nbsp; operator has highest precedence we first logically negate<TT> B.</TT>&nbsp; The result is then
combined with<TT> C</TT> using the .AND.&nbsp; operator.&nbsp; That result is then combined with<TT> A</TT> using the .OR.
&nbsp;operator to form the final result.
<H3 ID="Logical_Constant_Expressions"> Logical Constant Expressions </H3>
<BR>A<B> logical constant expression</B> is a logical expression in which each primary is one of the following:
<OL>
<LI>logical constant
<LI>symbolic logical constant
<LI>a relational expression in which each primary is a constant expression
<LI>( logical constant expression )
</OL>
<BR>The following are examples of a logical constant expression (assume that<TT> A, B, C</TT> and<TT> D</TT> are arithmetic
constants appearing in<TT> PARAMETER</TT> statements).
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .TRUE. .AND. .NOT. .FALSE.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'A' .LT. 'a'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A * B .GT. C * D</TT>
<H2 ID="Evaluating_Expressions"> Evaluating Expressions </H2>
<BR>Four different types of operators have been discussed; arithmetic, character, relational and logical.&nbsp; It is possible
to form an expression which contains all of these operators.&nbsp; Consider the following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A+B .LE. C .AND. X // Y .EQ. Z .AND. L</TT>
<BR><BR>where<TT> A, B</TT> and<TT> C</TT> are of numeric type,<TT> X, Y</TT> and<TT> Z</TT> are of type CHARACTER and<TT>
L</TT> is of type LOGICAL.&nbsp; In this expression, + is an arithmetic operator, // is a character operator, .EQ.&nbsp; is
a relational operator and .AND.&nbsp; is a logical operator.&nbsp; Since we can mix these four types of operators, it is necessary
to define a precedence among these four classes of operators.&nbsp; The following defines this precedence of operators.&nbsp;

<OL>
<LI>arithmetic operators (highest precedence)
<LI>character operators
<LI>relational operators
<LI>logical operators (lowest precedence)
</OL>
<BR>With this precedence any expression can now be evaluated without ambiguity.
<H2 ID="Constant_Expressions"> Constant Expressions </H2>
<BR>A<B> constant expression</B> is an arithmetic constant expression, a character constant expression or a logical constant
expression.
<H1 ID="Assignment_Statements"> Assignment Statements </H1>
<BR>Assignment statements are used to define entities.&nbsp; There are four different types of assignment.
<OL>
<LI>Arithmetic
<LI>Logical
<LI>Statement label (ASSIGN)
<LI>Character
</OL>
<H2 ID="Arithmetic_Assignment"> Arithmetic Assignment </H2>
<BR>The form of an<B> arithmetic assignment statement</B> is
<BR><BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v = e</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>v
<DD>is a variable name or array element name of type INTEGER, REAL, DOUBLE PRECISION, COMPLEX or double precision complex (COMPLEX*16).
<DT>e
<DD>is an arithmetic expression.
</DL>
<BR>The following are examples of arithmetic assignment statements.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Y = X**2 + 4.0*X + 3.0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Z(10) = 4.3*(X+Y)</TT>
<BR><BR>Executing an arithmetic assignment statement causes the evaluation of the arithmetic expression<TT> e,</TT> converting
the type of the expression<TT> e</TT> to the type of<TT> v,</TT> and defining<TT> v</TT> with the result.
<BR><BR>If<TT> v</TT> is of type INTEGER*1 or INTEGER*2, then the value of the expression<TT> e</TT> is first converted to
type INTEGER.&nbsp; The resulting integer is then assigned to<TT> v</TT> in the following way.
<OL>
<LI>If<TT> v</TT> is of type INTEGER*2 and the value of<TT> e</TT> is such that -32768 &lt;=<TT> e</TT> &lt;= 32767,<TT> v</TT>
will be assigned the value of<TT> e.</TT>&nbsp; Otherwise,<TT> v</TT> will be undefined.
<LI>If<TT> v</TT> is of type INTEGER*1 and the value of<TT> e</TT> is such that -128 &lt;=<TT> e</TT> &lt;= 127,<TT> v</TT>
will be assigned the value of<TT> e.</TT>&nbsp; Otherwise,<TT> v</TT> will be undefined.
</OL>
<H2 ID="Logical_Assignment"> Logical Assignment </H2>
<BR>The form of a<B> logical assignment statement</B> is
<BR><BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v = e</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>v
<DD>is a variable name or array element name of type LOGICAL.
<DT>e
<DD>is a logical expression.
</DL>
<BR>The following are examples of logical assignment statements.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOG1 = .TRUE.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOG2 = (X.GT.Y) .AND. (X.LT.Z)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOG3(2) = LOG2 .EQV. LOG1</TT>
<BR><BR>Executing a logical assignment statement causes the evaluation of the logical expression<TT> e,</TT> and defining<TT>
v</TT> with the result.&nbsp; Note that the type of<TT> v</TT> and<TT> e</TT> must be LOGICAL.
<H2 ID="Statement_Label_Assignment"> Statement Label Assignment </H2>
<BR>The form of a<B> statement label assignment</B> is
<BR><BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ASSIGN s to i</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>s
<DD>is a statement label.
<DT>i
<DD>is the name of an integer variable.
</DL>
<BR>The following is an example of a statement label assignment statement.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ASSIGN 10 TO I</TT>
<BR><BR>The result of executing an<TT> ASSIGN</TT> statement causes the integer variable<TT> i</TT> to be defined with the
value of the statement label<TT> s.&nbsp; s</TT> must be the statement label of an executable statement or a format statement
in the same program unit in which the<TT> ASSIGN</TT> statement appears.&nbsp; It is possible to change the value of<TT> i</TT>
by executing another<TT> ASSIGN</TT> statement.
<BR><BR>During execution when<TT> i</TT> is used in an assigned<TT> GO TO</TT> statement, an<TT> ASSIGN</TT> statement which
defines<TT> i</TT> must have been executed prior to the execution of the assigned<TT> GO TO</TT> statement.
<BR><BR>While the variable<TT> i</TT> is defined with a statement label, it should not be used in any other way other than
in an assigned<TT> GO TO</TT> statement.&nbsp; Consider the following example.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 10&nbsp;&nbsp;&nbsp; ASSIGN 10 TO I</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Illegal use of an ASSIGNed variable</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, I</TT>
<BR><BR>The output produced by the<TT> PRINT</TT> statement is<B> not</B> the integer 10.&nbsp; Its value is undefined and
should be treated that way.
<H2 ID="Character_Assignment"> Character Assignment </H2>
<BR>The form of a<B> character assignment statement</B> is
<BR><BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v = e</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>v
<DD>is a character variable name, character array element, or character substring.
<DT>e
<DD>is a character expression.
</DL>
<BR>The following are examples of character assignment statements.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*20 C,D(5)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C='ABCDEF'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C(3:5)='XYZ'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D(5)(14:15)='12'</TT>
<BR><BR>Executing a character assignment statement causes the evaluation of the character expression<TT> e</TT> and the definition
of<TT> v</TT> with the result.
<BR><BR>None of the character positions defined in<TT> v</TT> may be referenced in<TT> e.</TT>&nbsp; The following example
is illegal since the 4th and 5th character positions of<TT> A</TT> appear on the left and right hand side of the equal sign.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Illegal character assignment.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*10 A,B*5</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A(2:6) = A(4:5) // B</TT>
<BR><BR>The length of<TT> v</TT> and<TT> e</TT> may be different.&nbsp; If the length of<TT> v</TT> is less than the length
of<TT> e</TT> then the assignment has the effect of truncating<TT> e</TT> from the right to the length of<TT> v.</TT>&nbsp;
If the length of<TT> v</TT> is greater than the length of<TT> e,</TT> the value assigned to<TT> v</TT> is the value of<TT>
e</TT> padded on the right with blanks to the length of<TT> v.</TT>
<H2 ID="Extended_Assignment_Statement"> Extended Assignment Statement </H2>
<BR>Open Watcom FORTRAN 77 supports an extension to the FORTRAN 77 assignment statement, namely the<B> extended assignment
statement</B> shown here:
<BR><BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v&nbsp; =&nbsp; v&nbsp; =&nbsp; v&nbsp; = ... =&nbsp;
v&nbsp; = e</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>v'i
<DD>must be one of the following:
<OL>
<LI>Variable names or array element names of type INTEGER, REAL, DOUBLE PRECISION, COMPLEX or double precision complex (COMPLEX*16).
<LI>Variable names or array element names of type LOGICAL.
<LI>Character variable names, character array elements, or character substrings.
</OL>
<DT>e
<DD>must be one of the following and must follow the rules of the arithmetic, logical or character assignment statements:
<OL>
<LI>An arithmetic expression.
<LI>A logical expression.
<LI>A character expression.
</OL>
</DL>
<BR>The extended assignment statement is equivalent to the following individual statements.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v&nbsp;&nbsp;&nbsp; =&nbsp;&nbsp; e</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v&nbsp;&nbsp;&nbsp; =&nbsp;&nbsp; v</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n-1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v&nbsp;&nbsp;&nbsp; =&nbsp;&nbsp; v</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v&nbsp;&nbsp;&nbsp; =&nbsp;&nbsp; v</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2</TT>
<BR><BR>When using an extended assignment statement involving variables of mixed type, it is important to understand the exact
way in which the assignments are performed.&nbsp; Assignment of each variable is made using the value of the variable to its
immediate right, starting with the rightmost variable which is assigned the value of the expression.&nbsp; To help make this
clear, consider the following program.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER C1*10, C2*5, C3*7</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOGICAL L1, L2, L3</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER*2 K, L</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I = S = J = T = 1.25</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, I, S, J, T</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I = K = J = L = 70000</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, I, K, J, L</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C1 = C2 = C3 = 'ABCDEFGHIJKL'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, C1, C2, C3</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; L1 = L2 = L3 = .TRUE.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, L1, L2, L3</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>The output from this program would be:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 1.0000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
1 1.2500000</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4464&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4464&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4464&nbsp;
&nbsp;&nbsp;&nbsp; 4464</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ABCDE&nbsp;&nbsp;&nbsp;&nbsp; ABCDEABCDEFG</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T</TT>
<BR><BR>Note that variables<TT> K</TT> and<TT> L</TT> are of type INTEGER*2 and cannot contain any value greater than 32767.
&nbsp;Truncation resulted and this value (4464) was propagated to the left.
<H1 ID="Program_Structure_Control_Statements"> Program Structure Control Statements </H1>
<BR>The use of structured programming statements has been found to encourage better programming and design practices among
beginners, and aids the more experienced programmer in writing error-free programs.
<BR><BR>The format of these statements and their blocks is illustrated below.&nbsp; Following this, the use and meaning of
each statement is described and illustrated with examples.&nbsp; In each of these illustrations, the blocks are denoted by<TT>
statement(s)</TT> and are delimited by control statements.
<BR><BR>In the descriptions,<TT> logical-expression</TT> can also be an integer expression, in which case the result of the
integer expression is compared for inequality to the integer value 0.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( LEN - 1 )THEN</TT>
<BR><BR>In the preceding example, the expression<TT> LEN - 1</TT> is interpreted as<TT> LEN - 1 .NE.&nbsp; 0.</TT>
<H2 ID="IF_M_ELSE_M_END_IF"> IF - ELSE - END IF </H2>
<BR>The<TT> ELSE</TT> portion of this construct is optional, thus there are two possible formats.
<BR><BR> <TT>&nbsp;&nbsp;&nbsp; (a) IF( logical-expression )THEN&nbsp;&nbsp;&nbsp; [: block-label]</TT></TT>&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; statement(s)</TT></TT>&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END IF</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT></TT> <TT><TT><TT>&nbsp;&nbsp;&nbsp; (b) IF( logical-expression )THEN&nbsp;&nbsp;&nbsp; [: block-label]</TT></TT>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; statement(s)</TT></TT>&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ELSE</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; statement(s)</TT></TT>&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END IF</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR>This construct is an enhancement of the FORTRAN logical<TT> IF</TT> statement.&nbsp; If the value of the parenthesized
logical expression is true in (a), the block of statements following the<TT> IF</TT> statement is executed, after which control
passes to the statement following the<TT> END IF</TT> statement; otherwise, control will pass directly to the statement following
the<TT> END IF</TT> statement.&nbsp; When the<TT> ELSE</TT> statement is used and the logical expression is true, the block
of statements between the<TT> IF</TT> and the<TT> ELSE</TT> statements is executed and then control passes to the statement
following the<TT> END IF</TT> statement; otherwise the block of statements following<TT> ELSE</TT> statement is executed and
then control passes to the statement following the<TT> END IF</TT> statement.
<BR><BR>An optional block label may be specified with the<TT> IF</TT> statement (see the<TT> CYCLE</TT>,<TT> EXIT</TT> or<TT>
QUIT</TT> statement for more information).
<BR><BR>Examples follow which illustrate the use of the two formats.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( I .EQ. 0 )THEN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'I IS ZERO'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I = 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END IF</TT>
<BR><BR>If variable<TT> I</TT> is zero when the<TT> IF</TT> statement is executed, the string<TT> I IS ZERO</TT> will be printed,
variable<TT> I</TT> will be assigned the value 1, and the statement following the<TT> END IF</TT> will be executed.&nbsp;
If variable<TT> I</TT> is not zero when the<TT> IF</TT> statement is executed, control will pass to the statement following
the<TT> END IF</TT> statement.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( A .GT. B )THEN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'A GREATER THAN B'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A = A - B</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ELSE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'A NOT GREATER THAN
B'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END IF</TT>
<BR><BR>If the value of variable<TT> A</TT> is greater than the value of variable<TT> B</TT> when this<TT> IF</TT> statement
is executed, the string<TT> A GREATER THAN B</TT> will be printed and variable<TT> A</TT> will be assigned the value of the
expression<TT> A - B.</TT>&nbsp; Control will then pass to the statement following the<TT> END IF</TT> statement.
<BR><BR>If the value of variable<TT> A</TT> is not greater than the value of variable<TT> B</TT> when the<TT> IF</TT> statement
is executed, the string<TT> A NOT GREATER THAN B</TT> will be printed and control will pass to the statement following the<TT>
END IF</TT> statement.
<H2 ID="ELSE_IF"> ELSE IF </H2>
<BR>A further enhancement of the IF-THEN-ELSE construct is the<TT> ELSE IF</TT> statement which may be used in the following
two formats:
<BR><BR> <TT>&nbsp;&nbsp;&nbsp; (a) IF( logical-expression-1 )THEN&nbsp;&nbsp;&nbsp; [: block-label]</TT></TT>&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; statement(s)</TT></TT>&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ELSE IF( logical-expression-2 )THEN</TT></TT>&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; statement(s)</TT></TT>&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END IF</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT></TT> <TT><TT><TT>&nbsp;&nbsp;&nbsp; (b) IF( logical-expression-1 )THEN&nbsp;&nbsp;&nbsp; [: block-label]</TT></TT>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; statement(s)</TT></TT>&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ELSE IF( logical-expression-2 )THEN</TT></TT>&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; statement(s)</TT></TT>&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ELSE</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; statement(s)</TT></TT>&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END IF</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR>The presence of the &quot;...&quot; in the above formats indicates that the<TT> ELSE IF</TT> statement may be repeated
as often as desired.&nbsp; If the value of<TT> logical-expression-1</TT> is true in case (a), the block of statements following
the<TT> IF</TT> statement up to the first<TT> ELSE IF</TT> statement is executed, after which control passes to the statement
following the<TT> END IF</TT> statement; otherwise, control will pass to the first<TT> ELSE IF</TT> statement.&nbsp; If the
value of<TT> logical-expression-2</TT> is true, the block of statements following the first<TT> ELSE IF</TT> statement up
to the next<TT> ELSE IF</TT> statement or<TT> END IF</TT> statement is executed, after which control passes to the statement
following the<TT> END IF</TT> statement; otherwise, control will pass to the next<TT> ELSE IF</TT> statement, if there is
one, or directly to the statement following the<TT> END IF</TT> statement.&nbsp; When the<TT> ELSE</TT> statement is used,
as in case (b), and the values of all the logical expressions in the<TT> IF</TT> and<TT> ELSE IF</TT> statements are false,
the block of statements following the<TT> ELSE</TT> statement is executed and then control passes to the statement following
the<TT> END IF</TT> statement.&nbsp; An optional block label may be specified with the<TT> IF</TT> statement (see the<TT>
CYCLE</TT>,<TT> EXIT</TT> or<TT> QUIT</TT> statement for more information).
<BR><BR>Examples follow which illustrate the use of the two formats.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( I .EQ. 0 )THEN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'I IS ZERO'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ELSE IF( I .GT. 0 )THEN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'I IS GREATER THAN ZERO'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END IF</TT>
<BR><BR>If variable<TT> I</TT> is zero when the<TT> IF</TT> statement is executed, the string<TT> I IS ZERO</TT> will be printed
and the statement following the<TT> END IF</TT> statement will be executed.&nbsp; If variable<TT> I</TT> is not zero when
the<TT> IF</TT> statement is executed, control will pass to the<TT> ELSE IF</TT> statement.&nbsp; If variable<TT> I</TT> is
greater than zero, the string<TT> I IS GREATER THAN ZERO</TT> will be printed and the statement following the<TT> END IF</TT>
statement will be executed.&nbsp; If variable<TT> I</TT> is less than zero then nothing would be printed and control passes
from the<TT> ELSE IF</TT> statement to the statement following the<TT> END IF</TT> statement.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( A .GT. B )THEN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'A GREATER THAN B'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A = A - B</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ELSE IF( A .LT. B )THEN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'A LESS THAN B'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A = B - A</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ELSE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'A EQUAL TO B'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A = 0.0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END IF</TT>
<BR><BR>If the value of variable<TT> A</TT> is greater than the value of variable<TT> B</TT> when the<TT> IF</TT> statement
is executed, the string<TT> A GREATER THAN B</TT> will be printed and variable<TT> A</TT> will be assigned the value of the
expression<TT> A - B.</TT>&nbsp; Control will then pass to the statement following the<TT> END IF</TT> statement.
<BR><BR>If the value of variable<TT> A</TT> is not greater than the value of variable<TT> B</TT> when the<TT> IF</TT> statement
is executed, control passes to the<TT> ELSE IF</TT> statement.&nbsp; If the value of variable<TT> A</TT> is less than the
value of variable<TT> B,</TT> the string<TT> A LESS THAN B</TT> will be printed and variable<TT> A</TT> will be assigned the
value of the expression<TT> B - A.</TT>&nbsp; Control will then pass to the statement following the<TT> END IF</TT> statement.
<BR><BR>If the value of variable<TT> A</TT> is not less than the value of variable<TT> B</TT> when the<TT> ELSE IF</TT> statement
is executed, the string<TT> A EQUAL TO B</TT> will be printed and variable<TT> A</TT> will be assigned the value zero.&nbsp;
Control will pass to the statement following the<TT> END IF</TT> statement.
<H2 ID="DO_M_END_DO"> DO - END DO </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO init-expr,end-value[,inc-value] [: block-label]</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; statement(s)</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END DO</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR>This extension to FORTRAN 77 allows the creation of DO-loops without the introduction of statement numbers.&nbsp; An optional
block label may be specified (see the<TT> CYCLE</TT>,<TT> EXIT</TT> or<TT> QUIT</TT> statement for more information).&nbsp;
The<TT> END DO</TT> statement is used to indicate the end of the range of its corresponding<TT> DO</TT> statement.&nbsp; A
statement number may not be specified in the corresponding<TT> DO</TT> statement.&nbsp; Nested DO-loops of this form require
separate<TT> END DO</TT> statements to terminate the range of the corresponding<TT> DO</TT> statement.&nbsp; Since a statement
number may appear on the<TT> END DO</TT> statement, the number may be used to terminate outer DO-loops.&nbsp; This is not
a recommended practice (a<TT> CONTINUE</TT> statement or a structured<TT> DO</TT> statement should be used).&nbsp; A transfer
of control from within the DO-loop to a statement number on the<TT> END DO</TT> statement is treated in the same manner as
if the word<TT> CONTINUE</TT> had been used instead of<TT> END DO</TT>.
<BR><BR>Some examples follow.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO I = 1, 3</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO J = 1, 5</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT
*, MATRIX( I, J )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END DO</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END DO</TT>
<BR><BR>The above is equivalent to the following example which uses statement numbers.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO 10 I = 1, 3</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO 20 J = 1, 5</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT
*, MATRIX( I, J )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONTINUE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 10&nbsp;&nbsp;&nbsp; CONTINUE</TT>
<BR><BR>The next example demonstrates the use of a<TT> GO TO</TT> statement to control execution of all or part of a DO-loop.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO I = 1, 3</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO J = 1, 5</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT
*, 'INNER LOOP - J=', J</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( J
.LE. 3 )GO TO 20</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT
*, 'J &gt; 3'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END DO</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'OUTER LOOP - J=', J</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END DO</TT>
<BR><BR>A result of this example is that the character string<TT> J &gt; 3</TT> is printed 6 times (i.e., twice for each iteration
of the outer loop).&nbsp; Of course there is a much better way of coding this algorithm using the IF-END IF construct.&nbsp;
The example is included to illustrate the behaviour of transfers of control to an<TT> END DO</TT> statement.&nbsp; The following
example is an equivalent algorithm to the one above but the intent is much clearer.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO I = 1, 3</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO J = 1, 5</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT
*, 'INNER LOOP - J=', J</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( J
.GT. 3 )THEN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; PRINT *, 'J &gt; 3'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END IF</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END DO</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'OUTER LOOP - J=', J</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END DO</TT>
<H2 ID="DO_WHILE_M_END_DO"> DO WHILE - END DO </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO WHILE (e) [: block-label]</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; statement(s)</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END DO</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR>This extension to FORTRAN 77 allows the creation of DO-loops without iterative techniques.&nbsp; Instead, the DO-loop
is executed while the parenthesized expression is true.&nbsp; The logical expression is evaluated before entry to the DO-loop.
&nbsp;If the value is false, control is transferred to the statement following the<TT> END DO</TT> statement.&nbsp; If the
logical expression if true, the statements of the DO-loop are executed.&nbsp; When the<TT> END DO</TT> statement is reached,
the expression is re-evaluated and program control proceeds as previously described.&nbsp; An optional block label may be
specified (see the<TT> CYCLE</TT>,<TT> EXIT</TT> or<TT> QUIT</TT> statement for more information).
<BR><BR>An optional statement number can be specified after the<TT> DO</TT> keyword.&nbsp; When the<TT> END DO</TT> statement
is used to indicate the end of the range of its corresponding<TT> DO WHILE</TT> statement, a statement number may not be specified.
<BR><BR>Some examples follow.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I = 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO WHILE( I .LE. 3 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; J = 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO WHILE( J .LE. 5 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT
*, MATRIX( I, J )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END DO</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END DO</TT>
<BR><BR>The above is equivalent to the following example which uses statement numbers.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I = 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO 10 WHILE( I .LE. 3 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; J = 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO 20 WHILE( J .LE. 5 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT
*, MATRIX( I, J )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONTINUE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 10&nbsp;&nbsp;&nbsp; CONTINUE</TT>
<BR><BR>The next example demonstrates the use of a<TT> GO TO</TT> statement to control execution of all or part of a DO-loop.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I = 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO WHILE( I .LE. 3 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; J = 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO WHILE( J .LE. 5 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT
*, 'INNER LOOP - J=', J</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( J
.LE. 3 )GO TO 20</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT
*, 'J &gt; 3'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END DO</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'OUTER LOOP - J=', J</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END DO</TT>
<BR><BR>A result of this example is that the character string<TT> J &gt; 3</TT> is printed 6 times (i.e., twice for each iteration
of the outer loop).&nbsp; Of course there is a much better way of coding this algorithm using the IF-END IF construct.&nbsp;
The example is included to illustrate the behaviour of transfers of control to an<TT> END DO</TT> statement.&nbsp; The following
example is an equivalent algorithm to the one above but the intent is much clearer.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I = 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO WHILE( I .LE. 3 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; J = 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO WHILE( J .LE. 5 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT
*, 'INNER LOOP - J=', J</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( J
.GT. 3 )THEN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; PRINT *, 'J &gt; 3'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END IF</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END DO</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'OUTER LOOP - J=', J</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END DO</TT>
<H2 ID="LOOP_M_END_LOOP"> LOOP - END LOOP </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOOP&nbsp;&nbsp;&nbsp; [: block-label]</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; statement(s)</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END LOOP</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR>This extension to FORTRAN 77 causes the statements between the<TT> LOOP</TT> and<TT> END LOOP</TT> statements to be repeated
until control is transferred out of the loop, usually by an<TT> EXIT</TT> or<TT> QUIT</TT> statement.&nbsp; An optional block
label may be specified (see the<TT> CYCLE</TT>,<TT> EXIT</TT> or<TT> QUIT</TT> statement for more information).&nbsp; An example
follows:
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOOP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ *, X</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( X .EQ. 99.0 )EXIT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, X</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END LOOP</TT>
<BR><BR>The above statements cause values to be read and printed, one to a line, until the value 99.0 is read.&nbsp; When
variable<TT> X</TT> has this value, the logical expression in the<TT> IF</TT> statement evaluates as true and the<TT> EXIT</TT>
statement causes a transfer of control to the statement following the<TT> END LOOP</TT> statement.&nbsp; The<TT> EXIT</TT>
statement is discussed in more detail in a later section.
<H2 ID="WHILE_M_END_WHILE"> WHILE - END WHILE </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WHILE( logical-expression )DO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [: block-label]</TT></TT>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; statement(s)</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END WHILE</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR>This extension to FORTRAN 77 causes its block of code to be executed repeatedly while the parenthesized logical expression
is true.&nbsp; The logical expression is evaluated before entry to the block.&nbsp; If the value is false, control passes
to the statement following the<TT> END WHILE</TT> statement.&nbsp; If the logical expression is true, the statements of the
block are executed.&nbsp; When the<TT> END WHILE</TT> statement is reached, the<TT> WHILE</TT> logical expression is re-evaluated
and the above program control decisions are repeated.&nbsp; An optional block label may be specified (see the<TT> CYCLE</TT>,<TT>
EXIT</TT> or<TT> QUIT</TT> statement for more information).&nbsp; An example follows:
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WHILE( J .GT. 0 )DO</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A(J) = B(I + J)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; J = J - 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END WHILE</TT>
<BR><BR>If variable<TT> J</TT> is zero or negative when the<TT> WHILE</TT> statement is executed, the<TT> WHILE</TT> block
of code will be by-passed and the statement following the<TT> END WHILE</TT> statement will be executed.
<BR><BR>If variable<TT> J</TT> is greater than zero when the<TT> WHILE</TT> statement is executed, the<TT> WHILE</TT> block
will be executed repeatedly until<TT> J</TT> becomes equal to zero.&nbsp; The effect of this loop will be to assign values
to elements of array<TT> A</TT> from array<TT> B,</TT> starting with the element of<TT> A</TT> corresponding to the initial
value of variable<TT> J</TT> and working backwards down the array to element 1.
<H2 ID="WHILE_M_ExecutableMstatement"> WHILE - Executable-statement </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WHILE( logical-expression )stmt</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>stmt
<DD>is an executable statement.&nbsp; Only certain executable statements are are allowed.&nbsp; See the section entitled <A HREF="#Classifying_Statements">Classifying Statements</A>
in the chapter entitled <A HREF="#FORTRAN_Statements">FORTRAN Statements</A> for a list of allowable statements.
</DL>
<BR>This control statement is another form of the WHILE construct.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WHILE( I .GT. 0 )EXECUTE A</TT>
<BR><BR>When this statement is executed, if the logical expression is not true, control passes to the next statement.&nbsp;
If the expression is true, REMOTE-block<TT> A</TT> (assumed to be defined elsewhere in the program unit) is executed, and
the logical expression is re-evaluated.&nbsp; This is repeated until the logical expression, when evaluated, is false; control
then passes to the next statement.
<H2 ID="UNTIL"> UNTIL </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOOP&nbsp;&nbsp;&nbsp; [: block-label]</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; statement(s)</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UNTIL( logical-expression )</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR>or
<BR><BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WHILE( logical-expression )DO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [: block-label]</TT></TT>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; statement(s)</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UNTIL( logical-expression )</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR>The<TT> UNTIL</TT> statement, an extension to FORTRAN 77, may be combined with either a<TT> LOOP</TT> or<TT> WHILE</TT>
statement by replacing the<TT> END LOOP</TT> or<TT> END WHILE</TT> statement.&nbsp; It provides a way of specifying a condition
to be tested at the end of each iteration of a loop, which will determine whether or not the loop is repeated.&nbsp; After
all of the statements in the block have been executed, the logical expression in the<TT> UNTIL</TT> statement is evaluated.
&nbsp;If the result of the condition is false, the loop is repeated; otherwise, control passes to the statement following
the<TT> UNTIL</TT> statement.
<BR><BR>In the following example, the statements between the<TT> LOOP</TT> and the<TT> UNTIL</TT> statements are executed
until the value of variable<TT> X</TT> is greater than 10.0.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X = 1.0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOOP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, X, SQRT( X )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X = X + 1.0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UNTIL( X .GT. 10.0 )</TT>
<H2 ID="SELECT_M_END_SELECT"> SELECT - END SELECT </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SELECT [CASE] (e) [FROM]&nbsp; [: block-label]</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CASE ( case-list )</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; statement (s)</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CASE ( case-list )</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; statement (s)</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CASE DEFAULT</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; statement(s)</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END SELECT</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>case-list
<DD>is a list of one or more<B> cases</B> separated by commas.&nbsp; A<B> case</B> is either
<DL>
<DT>(a)
<DD>a single integer, logical or character constant expression or
<DT>(b)
<DD>an integer, logical or character constant expression followed by a colon followed by another expression or the same type.
&nbsp;This form of a case defines a range of values consisting of all integers or characters greater than or equal to the
value of the expression preceding the colon and less than or equal to the value of the expression following the colon.
</DL>
</DL>
<BR>The<TT> SELECT</TT> construct, an extension to FORTRAN 77, is similar in concept to the FORTRAN computed<TT> GO TO</TT>
statement.&nbsp; It allows one of a number of blocks of code (case blocks) to be selected for execution by means of an integer
expression in the<TT> SELECT</TT> statement.
<BR><BR>The<TT> SELECT</TT> statement keywords,<TT> CASE</TT> and<TT> FROM</TT>, are optional.&nbsp; The<TT> SELECT</TT> statement
may contain a block label (see the<TT> CYCLE</TT>,<TT> EXIT</TT> or<TT> QUIT</TT> statements for more information).
<BR><BR>Each block must be started with a<TT> CASE</TT> statement; however, the last block may begin with a<TT> CASE DEFAULT</TT>
statement.&nbsp; The<TT> CASE DEFAULT</TT> block is optional.&nbsp; In order to retain compatibility with earlier versions
of WATCOM FORTRAN 77 compilers, the<TT> OTHERWISE</TT> statement may be used in place of the<TT> CASE DEFAULT</TT> statement.
&nbsp;The last block is ended by the<TT> END SELECT</TT> statement.&nbsp; The number of case blocks is optional, from one
to many; however, it is recommended that the SELECT construct not be used for fewer than 3 case blocks.&nbsp; The conditional
execution of one or two blocks of code is handled more efficiently by the IF-THEN-ELSE construct.
<BR><BR>A particular case value or range of values must not be contained in more than one CASE-block.&nbsp; For example, the
following is illegal:
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Illegal SELECT block - case value in more</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * than one CASE block.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SELECT CASE ( I - 3 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CASE (1,3,7:10)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; statement(s)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CASE (5,6,8)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; statement(s)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CASE (-3:-2+4)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; statement(s)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END SELECT</TT>
<BR><BR>The second CASE-block includes 8 which is already handled by the first CASE-block.&nbsp; As well, the third CASE-block
handles cases -3, -2, -1, 0, 1, 2 but the first CASE-block also handles case 1.&nbsp; Thus the second and third CASE-ranges
are in error.
<BR><BR>When the<TT> SELECT</TT> statement case expression is evaluated as<B> i,</B> the case block whose range contains<B>
i</B> is executed and control passes to the statement following the<TT> END SELECT</TT> statement.&nbsp; If no range contains<B>
i,</B> control is transferred to the statement following the<TT> CASE DEFAULT</TT> statement, if one is specified.&nbsp; If
the<TT> CASE DEFAULT</TT> block is omitted and the case expression is out of range when the<TT> SELECT</TT> statement is executed
(that is, none of the CASE-blocks handles the particular expression value), control is passed to the statement following the<TT>
END SELECT</TT> statement and none of the CASE-blocks is executed.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SELECT CASE ( I )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CASE (1)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Y = Y + X</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X = X * 3.2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CASE (2)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Z = Y**2 + X</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, X, Y, Z</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CASE (3)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Y = Y * 13. + X</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X = X - 0.213</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CASE (4)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Z = X**2 + Y**2 - 3.0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Y = Y + 1.5</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X = X * 32.0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'CASE 4', X, Y, Z</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END SELECT</TT>
<BR><BR>This example will execute in the manner described below for each of the possible values of variable<TT> I.</TT>
<DL>
<DT>(i)
<DD><TT> I</TT> is zero or negative:
<BR><BR>- control will pass to the statement after the<TT> END SELECT</TT> statement
<DT>(ii)
<DD><TT> I = 1:</TT>
<BR><BR>- the value of<TT> X</TT> will be added to<TT> Y</TT>
<BR>-<TT> X</TT> will be multiplied by 3.2
<BR>- control will pass to the statement after the<TT> END SELECT</TT> statement
<DT>(iii)
<DD><TT> I = 2:</TT>
<BR><BR>-<TT> Z</TT> will be assigned the value of the expression<TT> Y**2 + X</TT>
<BR>- the values of<TT> X, Y</TT> and<TT> Z</TT> will be printed
<BR>- control will pass to the statement after the<TT> END SELECT</TT> statement
<DT>(iv)
<DD><TT> I = 3:</TT>
<BR><BR>-<TT> Y</TT> will be assigned the value of the expression<TT> Y * 13.&nbsp; + X</TT>
<BR>- 0.213 will be subtracted from<TT> X</TT>
<BR>- control will pass to the statement after the<TT> END SELECT</TT> statement
<DT>(v)
<DD><TT> I = 4:</TT>
<BR><BR>-<TT> Z, Y</TT> and<TT> X</TT> will be assigned new values
<BR>- the string<TT> CASE 4,</TT> followed by the values of<TT> X, Y</TT> and<TT> Z</TT> will be printed
<BR>- control will pass to the statement after the<TT> END SELECT</TT> statement
<DT>(vi)
<DD><TT> I = 5, 6, ...:</TT>
<BR><BR>- control will pass to the statement after the<TT> END SELECT</TT> statement
</DL>
<BR><TT>CASE DEFAULT</TT> allows a block of code to be specified for execution when the<TT> SELECT</TT> expression is out
of range.&nbsp; It must follow all CASE-blocks and thus is ended by the<TT> END SELECT</TT> statement.&nbsp; The<TT> CASE
DEFAULT</TT> statement terminates the previous and last CASE-block.&nbsp; Note that only one<TT> CASE DEFAULT</TT> block may
be specified in a SELECT construct.
<BR><BR>If a<TT> CASE DEFAULT</TT> block were included in the above example, it would be executed in cases (i) and (vi) of
the description.&nbsp; After a<TT> CASE DEFAULT</TT> block is executed, control then passes to the statement after the<TT>
END SELECT</TT> statement.
<BR><BR>Empty or null case blocks are permitted (that is, two<TT> CASE</TT> statements with no statements between).&nbsp;
The net result of executing a null CASE-block is to effectively bypass the SELECT construct.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SELECT CASE ( I * 4 - J )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CASE (-10 : -5)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *,'First case:'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *,'-10 &lt;= I*4-J &lt;=
-5'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CASE (-4 : 2)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *,'Second case:'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *,'-4 &lt;= I*4-J &lt;=
2'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CASE (3, 5, 7)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *,'Third case:'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *,'I*4-J is one of 3, 5
or 7'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CASE (4, 6, 8:10)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *,'Fourth case:'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *,'I*4-J is one of 4, 6,
8, 9 or 10'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CASE DEFAULT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *,'All other cases:'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *,'I*4-J &lt; -10 or I*4-J
&gt; 10'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END SELECT</TT>
<BR><BR>This example will execute in the manner described below for each of the possible values of expression<TT> I*4-J.</TT>
<DL>
<DT>(i)
<DD>expression &lt; -10
<BR><BR>- control will pass to the statement after the<TT> CASE DEFAULT</TT> statement
<BR>- the string<TT> All other cases:</TT>&nbsp; will be printed
<BR>- the string<TT> I*4-J &lt; -10 or I*4-J &gt; 10</TT> will be printed
<DT>(ii)
<DD>-10 &lt;= expression &lt;= -5:
<BR><BR>- control will pass to the statement after the first<TT> CASE</TT> statement
<BR>- the string<TT> First case:</TT>&nbsp; will be printed
<BR>- the string<TT> -10 &lt;= I*J-4 &lt;= -5</TT> will be printed
<BR>- control will pass to the statement after the<TT> END SELECT</TT> statement
<DT>(iii)
<DD>-4 &lt;= expression &lt;= 2:
<BR><BR>- control will pass to the statement after the second<TT> CASE</TT> statement
<BR>- the string<TT> Second case:</TT>&nbsp; will be printed
<BR>- the string<TT> -4 &lt;= I*J-4 &lt;= 2</TT> will be printed
<BR>- control will pass to the statement after the<TT> END SELECT</TT> statement
<DT>(iv)
<DD>expression = 3, 5 or 7:
<BR><BR>- control will pass to the statement after the third<TT> CASE</TT> statement
<BR>- the string<TT> Third case:</TT>&nbsp; will be printed
<BR>- the string<TT> I*J-4 is one of 3, 5 or 7</TT> will be printed
<BR>- control will pass to the statement after the<TT> END SELECT</TT> statement
<DT>(v)
<DD>expression = 4, 6, 8, 9 or 10:
<BR><BR>- control will pass to the statement after the fourth<TT> CASE</TT> statement
<BR>- the string<TT> Fourth case:</TT>&nbsp; will be printed
<BR>- the string<TT> I*J-4 is one of 4, 6, 8, 9 or 10</TT> will be printed.
<BR>- control will pass to the statement after the<TT> END SELECT</TT> statement
<DT>(vi)
<DD>expression &gt; 10:
<BR><BR>- control will pass to the statement after the<TT> CASE DEFAULT</TT> statement
<BR>- the string<TT> All other cases:</TT>&nbsp; will be printed
<BR>- the string<TT> I*4-J &lt; -10 or I*4-J &gt; 10</TT> will be printed
</DL>
<H2 ID="EXECUTE_and_REMOTE_BLOCK"> EXECUTE and REMOTE BLOCK </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EXECUTE&nbsp;&nbsp; name</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REMOTE BLOCK name</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;<TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; statement(s)</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END BLOCK</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>name
<DD>is a valid FORTRAN symbolic name.
</DL>
<BR>The<TT> EXECUTE</TT> statement, an extension to FORTRAN 77, allows a named block of code to be executed.&nbsp; The named
block of code may be defined anywhere in the same program unit and is delimited by the<TT> REMOTE BLOCK</TT> and<TT> END BLOCK</TT>
statements.&nbsp; Executing a REMOTE-block is similar in concept to calling a subroutine, with the advantage that shared variables
do not need to be placed in a common block or passed in an argument list.&nbsp; In addition there is less overhead involved
in executing a REMOTE-block than in calling a subroutine (in both amount of object code and execution time).&nbsp; When execution
of the REMOTE-block is complete, control returns to the statement following the<TT> EXECUTE</TT> statement which invoked it.
<BR><BR>This feature is helpful in avoiding duplication of code for a function (such as I/O) required in a number of places
throughout a program.&nbsp; It can also be an aid to writing a well-structured program.
<BR><BR>Each REMOTE-block within the same program unit must have a different name and it must not be a subprogram or variable
name.&nbsp; Note that a REMOTE-block is local to the program unit in which it is defined and may not be referenced (executed)
from another program unit.
<BR><BR>REMOTE-blocks may be defined anywhere in the program unit except as follows.
<OL>
<LI>They must follow all specification statements.
<LI>They must not be defined within a control structure.
</OL>
<BR>If a<TT> REMOTE BLOCK</TT> statement is encountered during execution, control is transferred to the statement following
the corresponding<TT> END BLOCK</TT> statement.
<BR><BR>Note that the nested definition of REMOTE-blocks is not permitted.
<BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EXECUTE A</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'FIRST'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EXECUTE A</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'SECOND'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REMOTE BLOCK A</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I = I + 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'I=', I</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END BLOCK</TT>
<BR><BR>Both<TT> EXECUTE</TT> statements will cause REMOTE-block<TT> A</TT> to be executed.&nbsp; That is, variable<TT> I</TT>
will be incremented and its value will be printed.&nbsp; When the block has been executed by the first<TT> EXECUTE</TT> statement,
control returns to the<TT> PRINT</TT> statement following it and the word<TT> FIRST</TT> is printed.&nbsp; Similarly, when
the block is executed by the second<TT> EXECUTE</TT> statement, control returns to the<TT> PRINT</TT> statement following
it and the word<TT> SECOND</TT> is printed.
<BR><BR>REMOTE-blocks may be executed from other REMOTE-blocks.&nbsp; For example, REMOTE-block<TT> A</TT> might contain the
statement<TT> EXECUTE B,</TT> where<TT> B</TT> is a REMOTE-block defined elsewhere in the program unit.&nbsp; The execution
of REMOTE-blocks from other REMOTE-blocks may take place to any level; however, the recursive execution of REMOTE-blocks is
not permitted, either directly or through a chain of<TT> EXECUTE</TT> statements.&nbsp; Attempts to execute REMOTE-blocks
recursively are detected as errors at execution time.
<H2 ID="GUESSMADMITMEND_GUESS"> GUESS-ADMIT-END GUESS </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GUESS&nbsp;&nbsp;&nbsp; [: block-label]</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; statement(s)</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ADMIT</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; statement(s)</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ADMIT</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; statement(s)</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ADMIT</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; statement(s)</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END GUESS</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR>The GUESS-ADMIT-END GUESS structure is a rejection mechanism which is useful when sets of statements are to be conditionally
chosen for execution, but not all of the conditions required to make a selection are available beforehand.&nbsp; It is an
extension to FORTRAN 77.&nbsp; The sets of statements to be chosen may be thought of as alternatives, the first alternative
being statements immediately after the<TT> GUESS</TT> statement.&nbsp; Execution begins with the statements in the first alternative.
&nbsp;If a condition is detected which indicates that the first alternative was the wrong choice, a<TT> QUIT</TT> statement
may be executed to cause control to be passed to the statements after the<TT> ADMIT</TT> statement (i.e., the second alternative).
&nbsp;A<TT> QUIT</TT> statement within the second alternative passes control to the third alternative, etc.&nbsp; A<TT> QUIT</TT>
statement within the last alternative passes control to the statement after the<TT> END GUESS</TT> statement.&nbsp; If an
alternative completes execution without encountering a<TT> QUIT</TT> statement (i.e., all statements are executed up to the
next<TT> ADMIT</TT> statement) then control is passed to the statement after the<TT> END GUESS</TT> statement.&nbsp; An optional
block label may be specified following the keyword<TT> GUESS</TT> (see the<TT> QUIT</TT> statement for more information).
<BR><BR>In the following example, two sets of codes and numbers are read in and some simple sequence checking is performed.
&nbsp;If a sequence error is detected an error message is printed and processing terminates; otherwise the numbers are processed
and another pair of numbers is read.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOOP : PRLOOP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GUESS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LINE
= LINE + 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ
*, ICODE, X</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AT END,
QUIT :PRLOOP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( ICODE
.NE. 1 )QUIT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LINE
= LINE + 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ
*, ICODE, Y</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AT END,
QUIT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( ICODE
.NE. 2 )QUIT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT
*, X, Y</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALL
PROCES(X, Y)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ADMIT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT
*, 'INVALID SEQUENCE: LINE =', LINE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; QUIT
:PRLOOP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END GUESS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END LOOP</TT>
<BR><BR>The above example attempts to read a code and number.&nbsp; If an end of file occurs then the loop is terminated by
the<TT> QUIT</TT> statement.
<BR><BR>If the code is not 1 then we did not get what we expected and an error situation has arisen.&nbsp; Control is passed
to the statement following the<TT> ADMIT</TT> statement.&nbsp; An error message is printed and the loop is terminated by the<TT>
QUIT</TT> statement.
<BR><BR>If the code is 1 then a second code and number are read.&nbsp; If an end of file occurs then we are missing a set
of data and an error situation has arisen.&nbsp; Control is passed to the statement following the<TT> ADMIT</TT> statement.
&nbsp;An error message is printed and the loop is terminated by the<TT> QUIT</TT> statement.&nbsp; Similarly if the expected
code is not 2 an error situation has arisen.&nbsp; Control is passed to the statement following the<TT> ADMIT</TT> statement.
&nbsp;An error message is printed and the loop is terminated by the<TT> QUIT</TT> statement.
<BR><BR>If the second code is 2, the values of variables<TT> X</TT> and<TT> Y</TT> are printed.&nbsp; A subroutine is then
called to process the data.&nbsp; Control resumes at the statement following the<TT> END GUESS</TT> statement.&nbsp; Since
this statement is an<TT> END LOOP</TT>, control is transferred to the beginning of the loop.
<BR><BR>The above example illustrates the point that all the information required to make a choice (in this case between a
valid set of data and an invalid set) is not available from the beginning.&nbsp; In this case we make an assumption that the
data values are correct (our hypothesis) and then test the assumption at various points in the algorithm.&nbsp; If any of
the tests fail we reject the hypothesis (and, perhaps, select a new hypothesis).
<BR><BR>It should be noted that no alternative selection need be coded (i.e., we need not use any ADMIT-blocks).&nbsp; This
is illustrated in the following example.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GUESS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X=SQRT( X )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( X .LT. EPS )QUIT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X=Y+SQRT(Y)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( X .LT. EPS )QUIT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALL INTGRT( X, Y )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END GUESS</TT>
<BR><BR>It might be noted that the IF-ELSE-END IF construct is simply a specific instance of the more general GUESS-ADMIT-END
GUESS construct wherein the data values are known beforehand (as could be illustrated using the previous example).
<H2 ID="QUIT"> QUIT </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; QUIT&nbsp;&nbsp;&nbsp; [ : block-label]</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR>The<TT> QUIT</TT> statement may be used to transfer control to the first executable statement following the terminal statement
of the block in which it is contained.
<BR><BR>When transferring out of a loop, control is passed to the statement following the<TT> END DO</TT>,<TT> END WHILE</TT>,<TT>
END LOOP</TT> or<TT> UNTIL</TT> statement.
<BR><BR>When transferring out of a GUESS block, control is passed to the statement after the next<TT> ADMIT</TT> or<TT> END
GUESS</TT> statement.
<BR><BR>When transferring out of an IF-block or SELECT-block, control is passed to the statement after the corresponding<TT>
END IF</TT> or<TT> END SELECT</TT> statement.
<BR><BR>When transferring out of a REMOTE-block, control passes to the statement following the<TT> EXECUTE</TT> statement
that invoked the REMOTE-block.
<BR><BR>If no block label is specified in the<TT> QUIT</TT> statement, control is transferred from the immediately enclosing
structure.&nbsp; If several structures or DO-loops are nested, it is possible to exit from any one of them by specifying the
block label of the corresponding block structure.
<BR><BR>The<TT> QUIT</TT> statement is most commonly used as the statement in a logical<TT> IF</TT> or<TT> AT END</TT> statement
but may also be used to cause an unconditional transfer of control.&nbsp; (The<TT> AT END</TT> statement is described in a
subsequent section).
<BR><BR>Examples of the<TT> QUIT</TT> statement with and without a block label follow.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER CH</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ *, CH</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GUESS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( CH .LT. 'a' )QUIT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( CH .GT. 'z' )QUIT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'Lower case letter'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ADMIT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( CH .LT. 'A' )QUIT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( CH .GT. 'Z' )QUIT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'Upper case letter'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ADMIT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( CH .LT. '0' )QUIT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( CH .GT. '9' )QUIT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'Digit'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ADMIT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'Special character'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END GUESS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>The above statements read and print values until an end of file occurs.&nbsp; At that point control is passed to the<TT>
QUIT</TT> statement, as specified by the<TT> AT END</TT> statement.&nbsp; The<TT> QUIT</TT> statement causes control to continue
with the statement after the<TT> END LOOP</TT> statement.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER RECORD(80)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOOP : RDREC</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ(5,100) RECORD</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AT END, STOP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO I = 1, 80</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( RECORD(I)
.LT. '0'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; .OR. RECORD(I) .GT. '9' )QUIT : RDREC</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END DO</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WRITE(6,101) RECORD</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END LOOP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'INVALID RECORD'</TT>
<BR><BR>The above example reads in records and verifies that they contain only numeric data.&nbsp; The<TT> QUIT</TT> statement
is within two levels of nesting:&nbsp; the DO-loop and the LOOP-END LOOP structure.&nbsp; If a non-numeric character is found,
the<TT> QUIT :&nbsp; RDREC</TT> statement will cause control to be passed to the<TT> PRINT</TT> statement after the<TT> END
LOOP</TT> statement.
<H2 ID="EXIT"> EXIT </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EXIT&nbsp;&nbsp;&nbsp; [ : block-label]</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR>The<TT> EXIT</TT> statement is used to transfer control:
<OL>
<LI>from within a loop (DO, DO WHILE, WHILE or LOOP) to the statement following the loop,
<LI>from within a GUESS or ADMIT block to the statement following the<TT> ENDGUESS</TT> statement, or
<LI>from within a remote block to the statement following the<TT> EXECUTE</TT> statement that invoked the remote block.
</OL>
<BR>When transferring out of a loop, control is passed to the statement following the<TT> END DO</TT>,<TT> END WHILE</TT>,<TT>
END LOOP</TT> or<TT> UNTIL</TT> statement.
<BR><BR>When transferring out of a GUESS block, control is passed to the statement after the corresponding<TT> END GUESS</TT>
statement.
<BR><BR>When transferring out of a REMOTE-block, control passes to the statement following the<TT> EXECUTE</TT> statement
that invoked the REMOTE-block.
<BR><BR>If no block label is specified in the<TT> EXIT</TT> statement, control is transferred from the immediately enclosing
structure.&nbsp; If several structures or DO-loops are nested, it is possible to exit from any one of them by specifying the
block label of the corresponding block structure.
<BR><BR>The<TT> EXIT</TT> statement is most commonly used as the statement in a logical<TT> IF</TT> or<TT> AT END</TT> statement
but may also be used to cause an unconditional transfer of control.&nbsp; (The<TT> AT END</TT> statement is described in a
subsequent section).
<BR><BR>Examples of the<TT> EXIT</TT> statement with and without a block label follow.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOOP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ *, X</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AT END, EXIT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, X</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END LOOP</TT>
<BR><BR>The above statements read and print values until an end of file occurs.&nbsp; At that point control is passed to the<TT>
EXIT</TT> statement, as specified by the<TT> AT END</TT> statement.&nbsp; The<TT> EXIT</TT> statement causes control to continue
with the statement after the<TT> END LOOP</TT> statement.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER RECORD(80)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOOP : RDREC</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ(5,100) RECORD</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AT END, STOP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO I = 1, 80</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( RECORD(I)
.LT. '0'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; .OR. RECORD(I) .GT. '9' )EXIT : RDREC</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END DO</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WRITE(6,101) RECORD</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END LOOP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'INVALID RECORD'</TT>
<BR><BR>The above example reads in records and verifies that they contain only numeric data.&nbsp; The<TT> EXIT</TT> statement
is within two levels of nesting:&nbsp; the DO-loop and the LOOP-END LOOP structure.&nbsp; If a non-numeric character is found,
the<TT> EXIT :&nbsp; RDREC</TT> statement will cause control to be passed to the<TT> PRINT</TT> statement after the<TT> END
LOOP</TT> statement.
<H2 ID="CYCLE"> CYCLE </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CYCLE&nbsp;&nbsp; [ : block-label]</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR>The<TT> CYCLE</TT> statement is used to cause a transfer of control from within a loop to the terminal statement of a
corresponding<TT> DO</TT>,<TT> DO WHILE</TT>,<TT> WHILE</TT> or<TT> LOOP</TT> statement.&nbsp; If<TT> block-label</TT> is
present then control is transferred to the terminal statement of the block identified by that block label.
<BR><BR>If no block label is specified in the<TT> CYCLE</TT> statement, control is transferred to the terminal statement of
the immediately enclosing loop structure.&nbsp; If several loop structures are nested, it is possible to cycle to the terminal
statement of any one of them by specifying the block label of the corresponding block structure.
<BR><BR>The<TT> CYCLE</TT> statement is most commonly used as the statement in a logical<TT> IF</TT> statement but may also
be used to cause an unconditional transfer of control.
<BR><BR>Examples of the<TT> CYCLE</TT> statement with and without a block label follow.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOOP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WRITE( UNIT=*, FMT='(A)' ) 'Enter
a number'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ( UNIT=*, FMT='(F10.4)',
IOSTAT=IOS ) X</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( IOS .NE. 0 ) CYCLE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( X .LT. 0 ) EXIT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, X, SQRT( X )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END LOOP</TT>
<BR><BR>The above statements read and print values until a negative integer value is entered.&nbsp; If an input error occurs,
the input operation (READ) is retried using the<TT> CYCLE</TT> statement.&nbsp; The<TT> CYCLE</TT> statement causes control
to resume at the<TT> END LOOP</TT> statement which then immediately transfers control to the statement following the<TT> LOOP</TT>
statement.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER RECORD(80)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOOP : RDREC</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ(5,100) RECORD</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AT END, STOP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO I = 1, 80</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( RECORD(I)
.LT. '0'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; .OR. RECORD(I) .GT. '9' )THEN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; PRINT *, 'INVALID RECORD'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; CYCLE : RDREC</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDIF</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END DO</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WRITE(6,101) RECORD</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END LOOP</TT>
<BR><BR>The above example reads in records and verifies that they contain only numeric data.&nbsp; If the record does not,
the input operation is tried again.&nbsp; The<TT> CYCLE</TT> statement is within three levels of nesting:&nbsp; the IF, the
DO-loop, and the LOOP-END LOOP structure.&nbsp; If a non-numeric character is found, the<TT> CYCLE :&nbsp; RDREC</TT> statement
will cause control to be passed to the<TT> READ</TT> statement that follows the<TT> LOOP</TT> statement.
<H2 ID="AT_END"> AT END </H2>
<BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (READ statement)</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AT END DO [: block-label ]</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; statement(s)</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END AT END</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR>or
<BR><BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (READ statement)</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;<TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AT END, statement</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;<TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR>The<TT> AT END</TT> control statement, an extension to FORTRAN 77, is an extension of the<TT> END=</TT> option of the
FORTRAN<TT> READ</TT> statement for sequential files.&nbsp; It allows a statement or a block of code following the<TT> READ</TT>
statement to be executed when an end of file condition is encountered during the<TT> READ</TT> and to be by-passed immediately
following a<TT> READ</TT> statement.&nbsp; It is not valid to use this control statement with direct-access or memory-to-memory
reads.&nbsp; Clearly, it is not valid to use this statement when<TT> END=</TT> is specified in the<TT> READ</TT> statement.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ(7, *) I, X</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AT END DO</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'END-OF-FILE ENCOUNTERED'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EOFSW = .TRUE.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END AT END</TT>
<BR><BR>If the<TT> READ</TT> statement is executed without encountering end of file, control passes to the statement following
the<TT> END AT END</TT> statement.&nbsp; If an end of file condition occurs during the read, the string,<TT> END-OF-FILE ENCOUNTERED</TT>
is printed, logical variable<TT> EOFSW</TT> is assigned the value<TT> .TRUE.</TT>&nbsp; and control passes to the statement
following the<TT> END AT END</TT> statement.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ(7, *) X</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AT END, EOFSW = .TRUE.</TT>
<BR><BR>If an end of file is not encountered by the<TT> READ</TT> statement, control passes to the statement following the<TT>
AT END</TT> statement.&nbsp; If an end-of-file condition occurs, variable<TT> EOFSW</TT> is set to<TT> .TRUE.</TT>&nbsp; and
control then passes to the statement following the<TT> AT END</TT> statement.&nbsp; Note that the use of the second form of
the<TT> AT END</TT> statement requires the use of a comma (,) between the<TT> AT END</TT> word and the executable statement.
&nbsp;This is necessary to distinguish the case where the executable statement is an assignment statement.&nbsp; The executable
statement may be any statement that is also allowed as the operand of a logical<TT> IF</TT> statement.
<H2 ID="Notes_on_Structured_Programming_Statements"> Notes on Structured Programming Statements </H2>
<BR>In addition to the definitions and examples of these constructs, the following points should be noted:
<DL>
<DT>(i)
<DD>Any of the new control statements with their blocks may be used within the block of any other statement.&nbsp; For example,
a WHILE-block may contain another WHILE or an IF-THEN-ELSE block.&nbsp; Blocks may be nested in this manner to any level within
storage limitations.&nbsp; An important exception to this rule is the REMOTE-block A REMOTE-block may contain other types
of blocks (nested to any level); however, another REMOTE-block may not be defined within it.&nbsp; Furthermore, REMOTE-blocks
may not be defined within another control structure.&nbsp; The following example is illegal.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Illegal definition of a REMOTE-block.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( I .EQ. 3 )then</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REMOTE BLOCK A</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END BLOCK</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END IF</TT>
<DT>(ii)
<DD>When nesting blocks, the inner blocks must always be completed with the appropriate block-terminating<TT> END</TT> statement
before the outer blocks are terminated.&nbsp; Similarly, when nesting blocks with DO-loops, a DO-loop started within a block
must be completed before the block is completed.&nbsp; A block started within a DO-loop must be terminated before the DO-loop
is completed.&nbsp; Indenting the statements of each new block, as shown in the examples, is helpful in avoiding invalid nesting
and helps to make the structure of the program visually obvious.
<DT>(iii)
<DD>The normal flow of control of the new programming constructs described earlier may be altered with standard FORTRAN control
statements.&nbsp; For example, the program may exit from a block using a<TT> GO TO</TT>,<TT> STOP</TT>,<TT> RETURN</TT> or
arithmetic<TT> IF</TT> statement.&nbsp; However, a block may not be entered in the middle through use of any control statement
such as<TT> GO TO</TT> or the arithmetic<TT> IF</TT>.
<BR><BR>Consider the following example.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GO TO 20</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 10&nbsp;&nbsp;&nbsp; IF( X .GT. Y )THEN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALL REDUCE( X, Y )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X = X - 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ELSE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALL SCALE( X )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END IF</TT>
<BR><BR>This is an example of an illegal attempt to transfer execution into the middle of an IF-block.&nbsp; The statement<TT>
X = X - 1</TT> is contained within the IF-block and may only be transferred to from within the block.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( X .GT. Y )THEN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALL REDUCE( X, Y )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X = X - 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( X .GT. 0 )GO TO 20</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ELSE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALL SCALE( X )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END IF</TT>
<BR><BR>This last example demonstrates a legal transfer of control within an IF-block.&nbsp; However, we have seen better
ways to express the loop with this IF-block.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( X .GT. Y )THEN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOOP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALL
REDUCE( X, Y )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X = X
- 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UNTIL( X .LE. 0 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ELSE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALL SCALE( X )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END IF</TT>
<DT>(iv)
<DD>Many control structure statements cannot be branched to using a<TT> GO TO</TT> statement.&nbsp; For a list of these statements,
see the section entitled <A HREF="#Classifying_Statements">Classifying Statements</A> in the chapter entitled <A HREF="#FORTRAN_Statements">FORTRAN Statements</A>.
<DT>(v)
<DD>Many control structure statements cannot be the object statement of a logical<TT> IF</TT> statement, or be the last statement
of a DO-loop.&nbsp; For a list of these statements, see the section entitled <A HREF="#Classifying_Statements">Classifying Statements</A>
in the chapter entitled <A HREF="#FORTRAN_Statements">FORTRAN Statements</A>.
</DL>
<H1 ID="InputDOutput"> Input/Output </H1>
<BR>FORTRAN 77 provides a means of communicating information or<B> data</B> between a FORTRAN program and the computing environment.
&nbsp;The computing environment may include a number of devices which are capable of the recording, retrieval, display, and
input of data.&nbsp; Disk and magnetic tape devices are capable of storing large amounts of data.&nbsp; Other devices such
as printers and display terminals can be used to present a visual (i.e., human-readable) representation of the data.&nbsp;
Yet other devices such as terminal keyboards and card-readers make possible the entry of new data into the computing environment.
<BR><BR>For the purposes of our discussion, data is any information which can be processed by an executing FORTRAN program.
&nbsp;Some examples of data are names, addresses, telephone numbers, credit card balances, flight trajectories, bus schedules,
athletic records, etc.&nbsp; In computing, such information is usually well-organized in order to make it useful for processing.
<BR><BR>To use an example, consider the entries in a telephone book.&nbsp; There are essentially three pieces of data listed
for each entry; a name, an address, and a number.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Smith J 32 Arthur St--------------------------555-3208</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Smith JW 512 King St--------------------------555-9229</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Smith Jack 255-113 Queen St N-----------------555-0572</TT>
<BR><BR>Each entry is a<B> record.</B>&nbsp; The organization of the book is clear.&nbsp; The name is always listed first,
the address second, and the number last.&nbsp; The records are<B> sorted,</B> for our convenience, by name (within each city
or geographical location).&nbsp; The length of each record is the same.&nbsp; This<B> fixed length</B> does sometimes lead
to problems since entries which have a long name or address won't fit in a record.&nbsp; The phone company solved this by
continuing the information in subsequent records.&nbsp; We might have solved this problem by increasing the length of a record
with the disadvantage of wasting a lot of printing space.&nbsp; Alternatively, we could have used a<B> variable length</B>
record.&nbsp; This solves the problem of wasted space but creates a severe problem when trying to display the records in nice
orderly columns.&nbsp; The telephone book itself is a collection of records or a<B> file.</B>&nbsp; 
<BR><BR>We have introduced much of the terminology of data processing:&nbsp; &quot;data&quot;, &quot;records&quot;, &quot;fixed
and variable record sizes&quot;, &quot;files&quot;, &quot;sorted&quot;, etc.
<H2 ID="Reading_and_Writing"> Reading and Writing </H2>
<BR>FORTRAN provides a mechanism called &quot;reading&quot; for transferring data into the environment of an executing program.
&nbsp;The<TT> READ</TT> statement is used to do this.&nbsp; Similarly &quot;writing&quot; is the mechanism for transferring
data out of an executing program.&nbsp; The<TT> WRITE</TT> and<TT> PRINT</TT> statements are used to do this.&nbsp; Other
statements provide additional functions such as positioning to a certain record in a file, establishing which files are to
be processed by the program, or making inquiries about files.
<H2 ID="Records"> Records </H2>
<BR>FORTRAN distinguishes between three kinds of records, namely:
<OL>
<LI>Formatted
<LI>Unformatted
<LI>Endfile
</OL>
<BR>We shall describe each of these in the following sections.
<H3 ID="Formatted_Record"> Formatted Record </H3>
<BR>A formatted record consists of characters.&nbsp; The length of a formatted record is determined by the number of characters
in it.&nbsp; A formatted record may contain no characters at all and thus has zero length.&nbsp; Formatted records are read
or written using<B> formatted input/output</B> statements.&nbsp; An excellent example of a file consisting of formatted records
is our telephone book example.
<H3 ID="Unformatted_Record"> Unformatted Record </H3>
<BR>An unformatted record consists of values such as integers, real numbers, complex numbers, etc.&nbsp; It may also consist
of characters.&nbsp; Essentially, these values have the same representation in a record as they have in the computer's memory.
&nbsp;The length of an unformatted record depends on the amount of storage required to represent these values in the computer's
memory.&nbsp; For example, on this computer an integer value is stored using 4 bytes of memory (a byte is a grouping of 8
binary digits).&nbsp; Thus, integer values in unformatted records also require 4 bytes of storage.&nbsp; For example, 3 integer
values stored in an unformatted record would require 12 bytes of storage.&nbsp; Unformatted records are read or written using<B>
unformatted input/output</B> statements.
<BR><BR>To illustrate the difference between a formatted and unformatted record consider the following example.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER NUMBER</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NUMBER=12345</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT 100, NUMBER</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 100&nbsp;&nbsp; FORMAT(1X,I5)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WRITE( UNIT=7 ) NUMBER</TT>
<BR><BR>If you print the variable<TT> NUMBER</TT> on a printer, it requires 5 character positions.&nbsp; If you write it to
a file using an unformatted<TT> WRITE</TT> statement, it only requires 4 bytes or character positions in the record.&nbsp;
Note that a character is conveniently represented in one byte of storage, hence we sometimes use the term &quot;byte&quot;
or &quot;character&quot; interchangeably when talking about the size of variables.
<H3 ID="Endfile_Record"> Endfile Record </H3>
<BR>An endfile record is a special record that follows all other records in a file.&nbsp; Simply stated, an endfile record
occurs at the end of a file.&nbsp; Actually, an endfile record is a conceptual thing.&nbsp; It has no length.&nbsp; When the
end of a file is reached (i.e., an attempt to read a record results in the endfile record being read), an &quot;end-of-file&quot;
condition exists.&nbsp; There are no more records following the endfile record.&nbsp; There is only one endfile record so
it is strictly illegal to attempt to read another record after the endfile record has been read (i.e., when the end-of-file
condition exists).
<H2 ID="Files"> Files </H2>
<BR>Earlier we described the notion of a file as a collection of records.&nbsp; In FORTRAN, there are two kinds of files:
<OL>
<LI>External
<LI>Internal
</OL>
<H3 ID="External_Files"> External Files </H3>
<BR>External files are files that exist or can be created upon external media such as disks, printers, terminal displays,
etc.&nbsp; A file may exist before the execution of a FORTRAN program.&nbsp; It may be brought into existence or &quot;created&quot;
during execution.&nbsp; It may also be deleted and therefore not exist after the execution of a FORTRAN program.
<BR><BR>All input/output statements may refer to files that exist.&nbsp; In addition, the<TT> INQUIRE</TT>,<TT> OPEN</TT>,<TT>
CLOSE</TT>,<TT> WRITE</TT>,<TT> PRINT</TT>, and<TT> ENDFILE</TT> statements may refer to files that do not exist (and in so
doing, may very well cause the file to be created).
<DL>
<DT>Properties of External Files
<DD>
<DT>Name
<DD>In FORTRAN, a file may or may not have a name.&nbsp; If it does have a name then, not surprisingly, it is called a<B> named</B>
file.&nbsp; All files in Open Watcom FORTRAN 77 have names and so it may seem odd to introduce this notion.&nbsp; However,
we do since the<TT> INQUIRE</TT> statement lets you find out if a file is named and, if so, what its name is.&nbsp; File naming
conventions may differ from one computing system to the next.&nbsp; As well, different FORTRAN 77 compilers may have different
file naming conventions.
<DT>Access
<DD>&quot;Access&quot; simply refers to the way in which we can position to and read or write the data in a particular record
in a file.&nbsp; There are two ways in which records can be accessed in a file;<B> sequentially</B> or<B> directly.</B>
<BR><BR>Using the<B> sequential access</B> method, records may be read or written in order starting with the first record
and proceeding to the last record.&nbsp; For example, it would be quite impossible to read or write the tenth record in a
file and then read or write the third record.&nbsp; Similarly the eleventh record must be read or written before we can access
the twelfth record.&nbsp; If we adopt the convention that each record in a file has a record number then the first record
is record number 1, the second is 2, and so on.&nbsp; This numbering convention is important when we look at the other access
method which is &quot;direct&quot;.
<BR><BR>Using the<B> direct access</B> method, records may be read or written in any order.&nbsp; It is possible to read or
write the tenth record of a file and then the third and then the twelfth and so on.&nbsp; A caveat:&nbsp; a record cannot
be read if it has never been written since the file was created.&nbsp; In direct access, the idea of a record number is very
important and so by convention, we number them starting at 1 as the first record and proceeding on up.&nbsp; With direct access,
if you create a new file and write record number 10 then the file has ten records regardless of the fact that only one has
been written.&nbsp; You could, at some later time, write records 1 through 9 (in whatever order you please) and add additional
records by writing records with record numbers greater than 10.
<BR><BR>Some files have the property of being able to sustain both of these access methods.&nbsp; Some files may only have
one of these properties.&nbsp; For example, most line printers cannot be accessed directly.&nbsp; You have no choice but to
write records sequentially.&nbsp; Sometimes a file that was created using the sequential access method may not be accessed
using the direct method or vice versa.&nbsp; FORTRAN calls this property of a file the &quot;set of allowed access methods&quot;.
<DT>Record Form
<DD>Some files have the property of being able to handle both formatted and unformatted record formats.&nbsp; Some files may only
have one of these properties.&nbsp; For example, if you tried to write unformatted records to a line printer, the result might
be gibberish.&nbsp; On the other hand a graphics printer may readily accept unformatted records for reproducing graphical
images on paper.&nbsp; FORTRAN calls this property of a file the &quot;set of allowed forms&quot;.
<DT>Record Length
<DD>Another property of a file is record length.&nbsp; Some files may have restrictions on the length of a record.&nbsp; Some
files do not allow records of zero length.&nbsp; Other files, such as printers, may restrict the length of a record to some
maximum.&nbsp; FORTRAN calls this property the &quot;set of allowed record lengths&quot;.
</DL>
<H3 ID="Internal_Files"> Internal Files </H3>
<BR>Internal files are special files that reside only in memory.&nbsp; They do not exist before or after the execution of
a FORTRAN program, only during the execution of a program.&nbsp; An internal file allows you to treat memory in the computer
as if it were one or more records in a file.&nbsp; The file must be a character variable, character array element, character
array, or character substring.&nbsp; A record in this file may be a character variable, character array element or character
substring.
<BR><BR>Another way of looking at this is that an internal file that is either a character variable, character array element
or character substring can contain only one record but an internal file that is a character array can contain several records
(as many as there are elements in the array).
<DL>
<DT>Properties of Internal Files
<DD>
<DT>Records
<DD>Unless the name of a character array is used, only one record is contained in an internal file.&nbsp; The length of this record
is the same as the length of the variable, array element, or substring.&nbsp; If the file is a character array then each element
in the array is a record.&nbsp; The order of the records in the file is the same as the order of the elements in the array.
&nbsp;The length of a record in this case is the same as the length of the character array elements.
<BR><BR>If the number of characters written to a record in an internal file is less than the length of the record then the
record is padded with blanks.
<DT>Definition
<DD>A record may be read only if the variable, array element, or substring is defined (i.e., it has been assigned some value).
&nbsp;Definition may not only result from an output statement such as<TT> WRITE</TT>.&nbsp; It may also be defined through
other means; for example, a character assignment statement.
<DT>Position
<DD>For all input/output statements, the file is positioned at the beginning of the first record.&nbsp; Multiple records may be
read or written using the &quot;slash&quot; format edit descriptor (see the chapter entitled <A HREF="#Format">Format</A>).
<DT>Restrictions
<DD>Only sequential access formatted input and output statements (<TT> READ</TT> and<TT> WRITE</TT>) may be used to transfer data
to and from records in an internal file.
<BR><BR>Although FORTRAN 77 states that list-directed formatted input/output to an internal file is not permitted, Open Watcom
FORTRAN 77 allows you to use list-directed formatted input/output statements.&nbsp; This is an extension to the language standard.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WRITE(INTFIL,*) X, Y, Z</TT>
<BR><BR>No other input/output statements (<TT> OPEN</TT>,<TT> ENDFILE</TT>,<TT> REWIND</TT>, etc.) may be used.
</DL>
<BR>Internal files may be used to convert data from one format to another.&nbsp; The following example illustrates one use
of internal files.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*11 INPUT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'TYPE IN ''I'' FOLLOWED BY AN INTEGER'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'OR TYPE IN ''R'' FOLLOWED BY A REAL'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ 100, INPUT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 100&nbsp;&nbsp; FORMAT( A11 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( INPUT(1:1) .EQ. 'I' )THEN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ( UNIT=INPUT(2:11), FMT='(I10)'
) IVAR</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'AN INTEGER WAS ENTERED
', IVAR</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ELSE IF( INPUT(1:1) .EQ. 'R' )THEN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ( UNIT=INPUT(2:11), FMT='(F10.3)'
) RVAR</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'A REAL NUMBER WAS ENTERED
', RVAR</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END IF</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>After checking for an<TT> &quot;I&quot;</TT> or<TT> &quot;R&quot;</TT> as the first character of the character variable<TT>
INPUT,</TT> the appropriate internal<TT> READ</TT> statement is executed.
<H2 ID="Units"> Units </H2>
<BR>Many FORTRAN 77 input/output statements refer to external files using a mechanism called the<B> unit.</B>&nbsp; There
are many units available to the FORTRAN 77 programmer.&nbsp; Open Watcom FORTRAN 77 numbers these units from 0 to 999; thus
the unit number is a non-negative integer less than 1000.
<BR><BR>A unit may be associated with a particular file.&nbsp; This association is called<B> connection.</B>&nbsp; Any unit
may or may not be connected to a file.&nbsp; There are a number of ways in which this connection may be established.
<BR><BR>A unit may be<B> preconnected</B> to a file before execution of a program begins.&nbsp; The User's Guide describes
the mechanism for preconnecting a unit to a file.
<BR><BR>Alternatively, a unit may become connected to a file by the execution of an<TT> OPEN</TT> statement.
<BR><BR>All input/output statements except<TT> OPEN</TT>,<TT> CLOSE</TT>, and<TT> INQUIRE</TT> must refer to a unit that is
connected to a file.&nbsp; Open Watcom FORTRAN 77 automatically establishes a connection of the unit to a file if no connection
previously existed.&nbsp; Consider the following example in which unit number 1 is not previously connected to a file.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WRITE(1,*) 'Output on unit 1'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>Open Watcom FORTRAN 77 constructs a file name using the specified unit number.&nbsp; The format of the file name is
described in the User's Guide since it varies from one computer system to the next.
<BR><BR>Connection of a unit to a file does not imply that the file must exist.&nbsp; For example, it could be a new file.
&nbsp;When we speak of a unit being connected to a file, we can also say that a file is connected to a unit.&nbsp; Under the
rules of FORTRAN, it is illegal to connect the same file to more than one unit<B> at the same time.</B>&nbsp; However, a file
may be connected to different units at different times.&nbsp; We shall explain how this is possible.
<BR><BR>A file may be<B> disconnected</B> from a unit by the use of the<TT> CLOSE</TT> statement.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CLOSE(UNIT=1)</TT>
<BR><BR>Under certain circumstances, the file may be disconnected from a unit by the use of the<TT> OPEN</TT> statement.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPEN(UNIT=1,FILE='FILE1')</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPEN(UNIT=1,FILE='FILE2')</TT>
<BR><BR>In the above example, the second<TT> OPEN</TT> statement disconnects unit 1 from one file and connects it to a second
file.&nbsp; You may think of the second<TT> OPEN</TT> statement as automatically closing the first file and then establishing
a connection to the second file.
<BR><BR>If a unit has been disconnected from a file through the execution of a<TT> CLOSE</TT> statement, the unit may subsequently
be connected to the same file or to a different file.&nbsp; It also follows that a file which has been disconnected from one
unit number may be connected to the same unit number or a different unit number.&nbsp; The following example may help to illustrate
this last point.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPEN(UNIT=1,FILE='FILE1')</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CLOSE(UNIT=1)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OPEN(UNIT=2,FILE='FILE1')</TT>
<BR><BR>Once a file has been disconnected, the only means for referring to the file is by its name in an<TT> OPEN</TT> statement
or an<TT> INQUIRE</TT> statement.
<H2 ID="Specifiers"> Specifiers </H2>
<BR>All input/output statements contain one or more specifiers.&nbsp; They appear in a list separated by commas.&nbsp; Some
of the more common specifiers are those listed below.&nbsp; Not all of them need be used in every input/output statement.
&nbsp;You should consult the description of the input/output statement under consideration to discover which specifiers are
allowed and what they mean.
<DL>
<DT>[UNIT =] u
<DD>the unit specifier 
<DT>[FMT =] f
<DD>the format specifier 
<DT>REC = rn
<DD>the record specifier 
<DT>IOSTAT = ios
<DD>the input/output status specifier 
<DT>ERR = s
<DD>the error specifier 
<DT>END = s
<DD>the end-of-file specifier
</DL>
<BR>We shall look at these specifiers in more detail.
<H3 ID="The_Unit_Specifier"> The Unit Specifier </H3>
<BR>The form of a unit specifier in an input/output statement is:
<DL>
<DT>[UNIT =] u
<DD><TT> u</TT> is an<B> external unit identifier</B> or an<B> internal file identifier.</B>
<OL>
<LI>An external unit identifier is a non-negative integer expression or an asterisk<TT> (*)</TT> in which case unit 5 is assumed
for an input statement and unit 6 is assumed for an output statement.&nbsp; The unit identifier must not be an asterisk for
the<TT> BACKSPACE</TT>,<TT> ENDFILE</TT> and<TT> REWIND</TT> statements.
<LI>An internal file identifier is the name of a character variable, character array, character array element, or character
substring.
</OL>
</DL>
<BR>If the optional<TT> UNIT=</TT> specifier is omitted then the unit specifier must be the first item in the list of specifiers.
<H3 ID="Format_Specifier"> Format Specifier </H3>
<BR>The form of a format specifier in an input/output statement is:
<DL>
<DT>[FMT =] f
<DD><TT> f</TT> is a<B> format identifier.</B>&nbsp; A format identifier is one of the following:
<OL>
<LI>A statement label of a<TT> FORMAT</TT> statement that appears in the same program unit as the format identifier.
<LI>An integer variable name that has been assigned the statement label of a<TT> FORMAT</TT> statement that appears in the
same program unit as the format identifier (see the<TT> ASSIGN</TT> statement).
<LI>An integer array name.
<LI>A character array name.
<LI>Any character expression except one involving the concatenation of an operand whose length specification is<TT> (*)</TT>
unless the operand is a symbolic constant (see the<TT> PARAMETER</TT> statement).
<LI>An asterisk<TT> (*),</TT> indicating<B> list-directed</B> formatting.
<LI>A<TT> NAMELIST</TT> name, indicating<B> namelist-directed</B> formatting.
</OL>
</DL>
<BR>If the optional<TT> FMT=</TT> specifier is omitted then the format specifier must be the second item in the list of specifiers
and<TT> UNIT=</TT> must not be specified for the first item in the list.
<H3 ID="Record_Specifier"> Record Specifier </H3>
<BR>The form of a record specifier in an input/output statement is:
<DL>
<DT>REC = rn
<DD><TT> rn</TT> is an integer expression whose value must be positive.&nbsp; It is the number of the record to be read when a
file is connected for<B> direct access.</B>&nbsp; 
</DL>
<H3 ID="InputDOutput_Status_Specifier"> Input/Output Status Specifier </H3>
<BR>The form of an input/output status specifier in an input/output statement is:
<DL>
<DT>IOSTAT = ios
<DD><TT> ios</TT> is an integer variable or integer array element.&nbsp; It is defined with zero if no error occurs, a positive
integer value if an error occurs, or a negative integer value if an end-of-file occurs.
</DL>
<BR>If an input/output error or end-of-file condition occurs during the execution of an input/output statement and the input/output
status specifier is present then execution of the program is not terminated.&nbsp; Input/output errors may result from a violation
of the rules of FORTRAN or from a file system error.&nbsp; For example, a negative unit number will result in an error since
this is a violation of the rules of FORTRAN.&nbsp; An example of a file system error might be an attempt to create a file
on a non-existent file storage device.
<BR><BR>Consult the User's Guide for a list of Open Watcom FORTRAN 77 diagnostic messages.&nbsp; An input/output status of<TT>
nn</TT> corresponds to the message<TT> IO-nn.</TT>&nbsp; For example, if the status returned is 3 then the error is:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; IO-03&nbsp; ENDFILE statement requires sequential access mode</TT>
<H3 ID="Error_Specifier"> Error Specifier </H3>
<BR>The form of an error specifier in an input/output statement is:
<DL>
<DT>ERR = s
<DD><TT> s</TT> is a statement label.&nbsp; When an error occurs, execution is transferred to the statement labelled by<TT> s.</TT>
</DL>
<BR>If an input/output error occurs during the execution of an input/output statement and the<TT> ERR=</TT> specifier is present
then execution of the program is not terminated.
<H3 ID="EndMofMFile_Specifier"> End-of-File Specifier </H3>
<BR>The form of an end-of-file specifier in an input/output statement is:
<DL>
<DT>END = s
<DD><TT> s</TT> is a statement label.&nbsp; When an end-of-file condition occurs, execution is transferred to the statement labelled
by<TT> s.</TT>
</DL>
<BR>If an end-of-file condition occurs during the execution of an input/output statement and the<TT> END=</TT> specifier is
present then execution of the program is not terminated.
<H2 ID="Printing_of_Formatted_Records"> Printing of Formatted Records </H2>
<BR>Printing occurs when<B> formatted</B> records are transferred to a device which interprets the first character of the
record as a special spacing command.&nbsp; The remaining characters in the record are &quot;printed&quot;.&nbsp; Printing
can be accomplished by use of either the<TT> PRINT</TT> statement or the<TT> WRITE</TT> statement.&nbsp; What actually determines
whether or not you are &quot;printing&quot; is the device (or file) to which records are transferred.
<BR><BR>The first character of the record controls the vertical spacing.&nbsp; This feature is quite often called ASA (American
Standards Association) carriage control.
<BR><BR> <TT>&nbsp;&nbsp;&nbsp; Character&nbsp;&nbsp;&nbsp; Vertical Spacing Before Printing</TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; <TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp; Blank</TT>&nbsp;&nbsp; <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; One Line</TT></TT>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp; 0</TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Two Lines</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp; -</TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Three Lines</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp; 1</TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
To First Line of Next Page</TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp; +</TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
No Advance</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; <TT></TT>
<BR>The &quot;-&quot; control character is an extension to the FORTRAN 77 language that is supported by many &quot;printing&quot;
devices.
<H1 ID="Format"> Format </H1>
<BR>A<B> format</B> specification used in conjunction with formatted I/O provides a means of specifying the way internal data
is converted to a character string and vice versa.&nbsp; A format specification can be given in two ways.
<OL>
<LI>In a<TT> FORMAT</TT> statement.
<LI>As values of character expressions or character arrays.
</OL>
<H2 ID="The_FORMAT_Statement"> The FORMAT Statement </H2>
<BR>The form of a<TT> FORMAT</TT> statement is
<BR><BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; label&nbsp;&nbsp;&nbsp; FORMAT fs</TT></TT>&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>label
<DD>is the statement label used by an I/O statement to identify the<TT> FORMAT</TT> statement.
<DT>fs
<DD>is a format specification which will be described later.
</DL>
<BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REAL X</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X = 234.43</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT 100, X</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 100&nbsp;&nbsp; FORMAT(F10.2)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>In the previous example, the<TT> PRINT</TT> statement uses the format specification in the<TT> FORMAT</TT> statement
whose statement label is 100 to display the value of<TT> X.</TT>
<H2 ID="FORMAT_as_a_Character_Expression"> FORMAT as a Character Expression </H2>
<BR>Instead of specifying the statement label of a<TT> FORMAT</TT> statement, a character expression can be used.&nbsp; The
previous example could be modified as follows and achieve the identical result.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REAL X</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X = 234.43</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT '(F10.2)', X</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>When using a character expression to represent a format specification, the format specification can be preceded by
blank characters and followed by any character data without affecting the format specification.&nbsp; The following example
produces the identical result to the previous example.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REAL X</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X = 234.43</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT '&nbsp;&nbsp;&nbsp; (F10.2) THIS IS FOR X', X</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>If a character array is used to describe the format specification, the format specification is considered to be the
concatenation of all the character array elements in the order given by array element ordering described in the chapter entitled
<A HREF="#Arrays">Arrays</A>.&nbsp; Note that if a character array element is used, the format specification is considered
to be only that array element.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REAL X</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*5 FMTSPEC(3)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X = 234.43</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FMTSPEC(1)='('</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FMTSPEC(2)='F10.2'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FMTSPEC(3)=')'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT FMTSPEC, X</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<H2 ID="Format_Specification"> Format Specification </H2>
<BR>A<B> format specification</B> has the following form.
<BR><BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( [flist] )</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>flist
<DD>is a list whose items are separated by commas.&nbsp; The forms of the items in<TT> flist</TT> are:
<BR><BR><TT>[r] ed</TT>
<BR><BR><TT>ned</TT>
<BR><BR><TT>[r] fs</TT>
<DT>ed
<DD>is a repeatable edit descriptor.
<DT>ned
<DD>is a nonrepeatable edit descriptor.
<DT>fs
<DD>is a format specification with a nonempty list<TT> flist.</TT>
<DT>r
<DD>is a positive unsigned integer constant called a<B> repeat specification.</B>&nbsp; 
</DL>
<BR>The comma separating the items of<TT> flist</TT> can be omitted in the following cases.
<OL>
<LI>Between a<TT> P</TT> edit descriptor and an<TT> F, E, D</TT> or<TT> G</TT> edit descriptor which immediately follows.
<LI>Before or after a slash edit descriptor.
<LI>Before or after a colon edit descriptor.
</OL>
<BR>Open Watcom FORTRAN 77 allows the omission of a comma between the items of<TT> flist.</TT>&nbsp; Care should be taken
when omitting commas between edit descriptors.&nbsp; For example, the format specification<TT> (I5 2I3)</TT> may appear to
be an<TT> I5</TT> edit descriptor followed by two<TT> I3</TT> edit descriptors when in actuality it is interpreted as an<TT>
I52</TT> edit descriptor followed by an<TT> I3</TT> edit descriptor.
<H2 ID="Repeatable_Edit_Descriptors"> Repeatable Edit Descriptors </H2>
<BR>The forms of<B> repeatable edit descriptors</B> are:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Iw</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Iw.m</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fw.d</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ew.d</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ew.dEe</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Dw.d</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Gw.d</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Gw.dEe</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Lw</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Aw</TT>
<BR><BR>As an extension to the FORTRAN 77 language, the following repeatable edit descriptors are also supported.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ew.dDe</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Zw</TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>
<DD><TT> I, F, E, D, G, L, A</TT> and<TT> Z</TT> indicate the method of editing.
<BR><BR><TT>w</TT> and<TT> e</TT> are positive unsigned integer constants.
<BR><BR><TT>d</TT> and<TT> m</TT> are unsigned integer constants.
</DL>
<H2 ID="Nonrepeatable_Edit_Descriptors"> Nonrepeatable Edit Descriptors </H2>
<BR>The forms of<B> nonrepeatable edit descriptors</B> are:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'hh...h' (apostrophe)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nHhh...h</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Tc</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TLc</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TRc</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nX</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BZ</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X</TT>
<BR><BR>As an extension to the FORTRAN 77 language, the following nonrepeatable edit descriptors are also supported.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>
<DD>Apostrophe,<TT> H, T, TL, TR, X, /, :, S, SP, SS, P, BN, BZ, \</TT> and<TT> $</TT> indicate the method of editing.
<BR><BR><TT>h</TT> is a character.
<BR><BR><TT>n</TT> and<TT> c</TT> are positive unsigned integer constants.
<BR><BR><TT>k</TT> is an optionally signed integer constant.
</DL>
<BR>Open Watcom FORTRAN 77 allows edit descriptors to be specified using lower case letters.
<H2 ID="Editing"> Editing </H2>
<BR>Edit descriptors are used to describe the way the editing between internal representation of data and the characters of
a record in a file is to take place.&nbsp; When the edit descriptors<TT> I, F, E, D, G, L, A, H, Z</TT> or apostrophe are
processed, they process a sequence of characters called a<B> field.</B>&nbsp; On input, the field is the character data read
from a record; on output it is the character data written to a record.&nbsp; The number of characters in a field is called
the<B> field width.</B>&nbsp; 
<H3 ID="Apostrophe_Editing"> Apostrophe Editing </H3>
<BR>The<B> apostrophe edit descriptor</B> has the same form as a character constant and can only be used on output.&nbsp;
It causes the characters in the format specification enclosed in quotes to be written.&nbsp; The field width is the number
of characters enclosed in quotes.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT '(''HI THERE'')'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>In the previous example, the string
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; HI THERE</TT>
<BR><BR>would be the output produced by the<TT> PRINT</TT> statement.
<H3 ID="H_Editing"> H Editing </H3>
<BR>The<TT> nH</TT> edit descriptor causes the<TT> n</TT> characters following the<TT> H,</TT> including blanks, to be written.
&nbsp;Like the apostrophe edit descriptor, it can only appear in a format specification used for output.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT '(8HHI THERE)'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>In the previous example, the string
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; HI THERE</TT>
<BR><BR>would be the output produced by the<TT> PRINT</TT> statement.
<H3 ID="Positional_Editing__T__TL__TR_and_X_Editing"> Positional Editing:&nbsp; T, TL, TR and X Editing </H3>
<BR>The<TT> T, TL, TR</TT> and<TT> X</TT> edit descriptors specify at which position the next character will be read from
or written to the record.&nbsp; In the case of input, this allows data to be read more than once with different edit descriptors.
&nbsp;On output, it is possible to overwrite data previously written.
<BR><BR>On output it is possible to use positional editing to create a record in which gaps appear.&nbsp; That is, there may
be parts of the record where no data has been written.&nbsp; The parts of a record in which no data has been written are filled
with blanks.&nbsp; The effect is as if the record was previously initialized to blanks.&nbsp; Note that positioning does not
cause any data to be transmitted.
<BR><BR>The<TT> Tc</TT> edit descriptor specifies that the next character to be transmitted is to be from the<TT> c</TT>th
character position in the record.&nbsp; The<TT> TLc</TT> edit descriptor specifies that the next character to be transmitted
is to be from the<TT> c</TT>th position backward from the current position.&nbsp; The<TT> TRc</TT> edit descriptor is identical
to the<TT> TLc</TT> edit descriptor except that positioning is forward from the current position.&nbsp; The<TT> nX</TT> edit
descriptor behaves identically to the<TT> TRc</TT> edit descriptor; the transmission of the next character is<TT> n</TT> character
positions forward from the current position.&nbsp; If<TT> n</TT> is omitted then the transmission of the next character is
1 character position forward from the current position.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT '(''THE NUMBER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;IS AN INTEGER'',TL19,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ''12345'')'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>The output produced is
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; THE NUMBER 12345 IS AN INTEGER</TT>
<H3 ID="Slash_Editing"> Slash Editing </H3>
<BR>The<B> slash edit descriptor</B> indicates the end of data transfer on the current record.&nbsp; On input from a record
connected for sequential access, the remaining characters in the record are skipped and the file is positioned to the start
of the next record.&nbsp; Note that entire records may be skipped.&nbsp; On output, a new record is created and becomes the
last and current record of the file.&nbsp; Note that a record with no characters can be written.&nbsp; If the file is an internal
file or a direct access file, the record is filled with blanks.
<BR><BR>For a file connected for direct access, the current record number is increased by one and the file is positioned at
the beginning of that record.
<H3 ID="Colon_Editing"> Colon Editing </H3>
<BR>The<B> colon edit descriptor</B> terminates processing of the format specification if there are no more items in the I/O
list.&nbsp; If there are items remaining in the I/O list, the colon edit descriptor has no effect.
<H3 ID="S__SP_and_SS_Editing"> S, SP and SS Editing </H3>
<BR>The<TT> S, SP</TT> and<TT> SS</TT> edit descriptors control optional plus characters in numeric output fields.&nbsp; They
only effect the<TT> I, F, E, D</TT> and<TT> G</TT> edit descriptors during output and have no effect on input.&nbsp; The FORTRAN
77 standard specifies that before processing a format specification, the appearance of a plus sign in numeric output fields
is optional and is determined by the processor.&nbsp; Open Watcom FORTRAN 77 does not produce plus signs in numeric output
fields.&nbsp; When an<TT> SP</TT> edit descriptor is encountered, a plus sign is produced in any subsequent position that
optionally contains a plus sign.&nbsp; When as<TT> SS</TT> edit descriptor is encountered, a plus sign is not produced in
any subsequent position that optionally contains a plus sign.&nbsp; If an<TT> S</TT> edit descriptor is encountered, the option
is returned to the processor.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT '(1H&lt;,I5,SP,I5,SS,I5,1H&gt;)',1,2,3</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>The output produced by the<TT> PRINT</TT> statement in the previous example is:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &lt;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp; +2&nbsp;&nbsp;&nbsp; 3&gt;</TT>
<H3 ID="P_Editing"> P Editing </H3>
<BR>The form of a<TT> P</TT> edit descriptor is <TT> kP</TT> where<TT> k</TT> is an optionally signed integer constant called
the<B> scale factor.</B>&nbsp; The value of the scale factor is zero at the beginning of each I/O statement.&nbsp; The scale
factor applies to all subsequent<TT> F, E, D</TT> and<TT> G</TT> edit descriptors until another scale factor is encountered.
&nbsp;The scale factor affects editing in the following way.
<OL>
<LI>On input with<TT> F, E, D</TT> and<TT> G</TT> editing, provided that no exponent exists in the field, the effect is that
the represented number equals the internally represented number multiplied by<TT> 10**k.</TT>
<LI>On input with<TT> F, E, D</TT> and<TT> G</TT> editing, the scale factor has no effect if there is an exponent in the field.
<LI>On<TT> F</TT> output editing, the effect is that the represented number equals the internally represented number multiplied
by<TT> 10**k.</TT>
<LI>On output with<TT> E</TT> and<TT> D</TT> editing, the simple real constant (see the chapter entitled <A HREF="#Names__Data_Types_and_Constants">Names, Data Types and Constants</A>)
part of the data is multiplied by<TT> 10**k</TT> and the exponent is reduced by<TT> k.</TT>
<LI>On output with<TT> G</TT> editing, the scale factor has no effect unless the magnitude of the datum is outside the range
that allows<TT> F</TT> editing (see the section entitled <A HREF="#G_Editing">G Editing</A>).&nbsp; If<TT> E</TT> editing
is required, the scale factor has the same effect as with<TT> E</TT> output editing.
</OL>
<H3 ID="BN_and_BZ_Editing"> BN and BZ Editing </H3>
<BR>The<TT> BN</TT> and<TT> BZ</TT> edit descriptors are used to describe the interpretation of embedded blanks in numeric
input fields.&nbsp; They only effect<TT> I, F, E, D</TT> and<TT> G</TT> editing and have no effect during output.&nbsp; When
a<TT> BN</TT> edit descriptor is encountered in a format specification, embedded blanks in subsequent numeric input fields
are ignored.&nbsp; However, a field of all blanks has the value of zero.&nbsp; If a<TT> BZ</TT> edit descriptor is encountered,
then all embedded blanks in subsequent numeric input fields are treated as zeroes.&nbsp; At the beginning of each I/O statement,
all blanks are treated as zeroes or ignored depending on the value of the<TT> BLANK=</TT> specifier (see the<TT> OPEN</TT>
statement) currently in effect for the unit.
<H3 ID="__or_B_Editing_LExtensionR"> $ or \ Editing (Extension) </H3>
<BR>The $ and \ edit descriptors behave identically.&nbsp; The $ and \ edit descriptors are intended for output to an interactive
device such as a terminal.&nbsp; They are a Open Watcom FORTRAN 77 extensions.&nbsp; The output record is displayed at the
terminal leaving the cursor at the end of the record; the carriage return at the end of the line is suppressed.&nbsp; Its
use is intended for prompting for input so that the response can be entered immediately following the prompt.
<BR><BR>Depending on the type of terminal, the prompt may be returned as part of the input.&nbsp; An application must be aware
of the way a particular terminal behaves.&nbsp; The following example demonstrates this.&nbsp; Note that the format specification
in the<TT> FORMAT</TT> statement labelled<TT> 20</TT> ignores the first eleven characters of the response since the prompt
also appears in the response.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER AGE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WRITE(6,FMT=10)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 10&nbsp;&nbsp;&nbsp; FORMAT( 'Enter age: ',$ )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ(5,20) AGE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 20&nbsp;&nbsp;&nbsp; FORMAT( 11X, I2 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *,'Your age is ',AGE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>If the terminal you are using does not return the prompt as part of the response (that is, a read from the terminal
only includes characters typed at the terminal), the format specification in the<TT> FORMAT</TT> statement labelled<TT> 20</TT>
must be changed, as in the following example, to achieve the same result.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER AGE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WRITE(6,FMT=10)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 10&nbsp;&nbsp;&nbsp; FORMAT( 'Enter age: ',\/ )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ(5,20) AGE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 20&nbsp;&nbsp;&nbsp; FORMAT( I2 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *,'Your age is ',AGE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<H3 ID="Numeric_Editing__I__F__E__D_and_G_Edit_Descriptors"> Numeric Editing:&nbsp; I, F, E, D and G Edit Descriptors </H3>
<BR>Numeric edit descriptors are used to specify I/O of integer, real, double precision, complex and double precision complex
data.&nbsp; The following rules apply to all numeric edit descriptors.
<OL>
<LI>On input, leading blanks are not significant.&nbsp; The interpretation of blanks other than leading blanks is determined
by any<TT> BN</TT> or<TT> BZ</TT> edit descriptors in effect and the<TT> BLANK=</TT> specifier (see the<TT> OPEN</TT> statement).
&nbsp;A field of all blanks is always zero.&nbsp; Plus signs are optional.
<LI>On input, with<TT> F, E, D</TT> and<TT> G</TT> editing, the decimal location specified in the edit descriptor is overridden
by a decimal point appearing in the input field.
<LI>On output, the plus sign is optional and is determined by the<TT> S, SP</TT> and<TT> SS</TT> edit descriptors.&nbsp; A
negative quantity is represented by a negative sign.&nbsp; A minus sign is never produced when outputting a value of zero.
<LI>On output, the representation is always right justified in the field with leading blanks inserted at the beginning of
the field if the number of characters in the representation is less than the field width.
<LI>On output, if the number of characters in the external representation is greater than the field width or an exponent exceeds
its specified length using<TT> Ew.dEe, Gw.dEe, Ew.dDe</TT> or<TT> Gw.dDe</TT> edit descriptors, the entire field is filled
with asterisks.
</OL>
<H4 ID="Integer_Editing__Iw_and_Iw_m_Edit_Descriptors"> Integer Editing:&nbsp; Iw and Iw.m Edit Descriptors </H4>
<BR>The<TT> Iw</TT> and<TT> Iw.m</TT> edit descriptors indicate that the field width of the field to be edited is<TT> w.</TT>
&nbsp;The item in the I/O list must be of type integer; on input the I/O list item will be defined by integer data, on output
the I/O list item must be defined with an integer datum.
<BR><BR>On input, the<TT> Iw.m</TT> edit descriptor is treated identically to the<TT> Iw</TT> edit descriptor.&nbsp; The output
field for the<TT> Iw</TT> edit descriptor consists of zero or more leading blanks followed by a minus sign if the value of
the I/O list item is negative or an optional plus sign otherwise, followed by the magnitude of the integer datum with no leading
zeroes.&nbsp; Note that the integer constant contains at least one digit.&nbsp; On output, the<TT> Iw.m</TT> edit descriptor
specifies that at least<TT> m</TT> digits are to be displayed with leading zeroes if necessary.&nbsp; The value of<TT> m</TT>
must be less than or equal to the value of<TT> w.</TT>&nbsp; If<TT> m</TT> is zero and the value of the datum is zero, then
the output field is filled with blanks.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT '(1H&lt;,I4.4,I5,1H&gt;)',23,2345</TT>
<BR><BR>The output produced by the<TT> PRINT</TT> statement in the previous example is the string:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &lt;0023 2345&gt;</TT>
<H4 ID="FloatingMpoint_Editing__F__E__D_and_G_Edit_Descriptors"> Floating-point Editing:&nbsp; F, E, D and G Edit Descriptors </H4>
<BR>The<TT> F, E, D</TT> and<TT> G</TT> edit descriptors describe the editing of real, double precision, complex and double
precision complex data.&nbsp; The I/O list item corresponding to one of these edit descriptors must be of type real, double
precision, complex or double precision complex.&nbsp; On input, the I/O list item will become defined with a datum whose type
is the same as that of the I/O list item.&nbsp; On output, the I/O list item must be defined with a datum whose type is that
of the I/O list item.
<H4 ID="F_Editing"> F Editing </H4>
<BR>An<TT> F</TT> edit descriptor has the form <TT> Fw.d</TT> where<TT> w</TT> is the field width and<TT> d</TT> is the number
of digits in the fractional part.&nbsp; The input field consists of an optional sign, followed by a string of digits optionally
containing a decimal point.&nbsp; If the decimal point is omitted, the rightmost<TT> d</TT> digits with leading zeroes assumed
if necessary, are interpreted as the fractional part of the value represented.&nbsp; An exponent of one of the following forms
may follow.
<OL>
<LI>A signed integer constant.
<LI>An<TT> E</TT> or<TT> D</TT> followed by an optionally signed integer constant.
</OL>
<BR>Consider the following example, where the decimal point is omitted.&nbsp; The formula used in the evaluation is:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -d&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (exponent subfield)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; (integer subfield) x 10&nbsp;&nbsp;&nbsp; x 10</TT>
<BR><BR>If the specification is F10.8 and the input quantity is 31415E+5 then the following conversion takes place.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; -8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 00031415 x 10&nbsp;&nbsp;&nbsp; x 10</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; 5</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; =&nbsp;&nbsp; .00031415 x 10</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; =&nbsp;&nbsp; 31.415</TT>
<BR><BR>In other words, the decimal point is assumed to lie to the left of the 8 digits (padded with zeroes on the left) forming
the fractional part of the input value.
<BR><BR>The output field produced by an<TT> F</TT> edit descriptor consists of blanks if necessary followed by a minus sign
if the item in the I/O list is negative or an optional plus sign otherwise, followed by a string of digits containing a decimal
point which represents the magnitude of the I/O list item.&nbsp; The string representing the magnitude of the I/O list item
is modified according to the scale factor and is rounded to<TT> d</TT> fractional digits.&nbsp; An optional leading zero is
produced only if the magnitude of the I/O list item is less than one.&nbsp; Note that a leading zero is required if there
would otherwise be no digits in the output field.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT '(1H&lt;,F8.4,1H&gt;)', 234.43</TT>
<BR><BR>The output produced by the<TT> PRINT</TT> statement in the previous example is the string:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &lt;234.4300&gt;</TT>
<H4 ID="E_and_D_Editing"> E and D Editing </H4>
<BR>The<TT> Ew.d, Dw.d</TT> and<TT> Ew.dEe</TT> edit descriptors indicate that the field width is<TT> w,</TT> the fractional
part contains<TT> d</TT> digits unless a scale factor greater than one is in effect, and the exponent consists of<TT> e</TT>
digits.&nbsp; The<TT> e</TT> has no effect on input.
<BR><BR>The form of the input field and processing of it is the same as that for<TT> F</TT> editing.&nbsp; The form of the
output field is:
<BR><BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [+] [0] . x&nbsp; x&nbsp; ... x&nbsp; exp</TT></TT>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT><TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [-]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;
2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>p
<DD>indicates a plus or minus sign.
<DT>x's
<DD>are the<TT> d</TT> most significant digits of the value after rounding.
<DT>exp
<DD>is a decimal exponent.
</DL>
<BR>The form of the exponent is as follows.
<OL>
<LI>When using the<TT> Ew.d</TT> edit descriptor, the form of the exponent is
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; E+nn</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if |exp| &lt;= 99</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; E-nn</TT>
<BR><BR>and
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +nnn</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if 99 &lt; |exp| &lt;= 999</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -nnn</TT>
<LI>When using the<TT> Ew.dEe</TT> edit descriptor, the form of the exponent is
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; E+n ... n&nbsp;&nbsp; where |exp| &lt;= (10**e)-1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - 1&nbsp;&nbsp;&nbsp;&nbsp; e</TT>
<LI>When using the<TT> Dw.d</TT> edit descriptor, the form of the exponent is
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; D+nn</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if |exp| &lt;= 99</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; D-nn</TT>
<BR><BR>and
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +nnn</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if 99 &lt; |exp| &lt;= 999</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -nnn</TT>
</OL>
<BR>Note that a sign in the exponent is always present.&nbsp; If the exponent is 0, a plus sign is used.&nbsp; The forms<TT>
Ew.d</TT> and<TT> Dw.d</TT> are not to be used if<TT> |exp| &gt; 999.</TT>
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT '(1H&lt;,E10.4,1H&gt;,1H&lt;,E9.4,1H&gt;,1H&lt;,E12.4E3,1H&gt;)',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .5, .5, .5</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>The output from the<TT> PRINT</TT> statement in the previous example is the string:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &lt;0.5000E+00&gt;&lt;.5000E+00&gt;&lt; 0.5000E+000&gt;</TT>
<BR><BR>The scale factor<TT> k</TT> in a<TT> P</TT> edit descriptor controls decimal normalization as follows:
<OL>
<LI>If<TT> -d &lt; k &lt;= 0,</TT> then the output field contains<TT> |k|</TT> leading zeroes and<TT> d-|k|</TT> significant
digits after the decimal point.
<LI>If<TT> 0 &lt; k &lt; d+2,</TT> the output field contains exactly<TT> k</TT> significant digits to the left of the decimal
point and<TT> d-k+1</TT> significant digits to the right of the decimal point.
<LI>Other values of<TT> k</TT> are not permitted.
</OL>
<BR>The<TT> Ew.dDe</TT> edit descriptor behaves in the same way as the<TT> Ew.dEe</TT> edit descriptor on input; on output
the only difference is that the letter<TT> D</TT> is used to mark the exponent instead of the letter<TT> E.</TT>
<H4 ID="G_Editing"> G Editing </H4>
<BR>The<TT> Gw.d</TT> and<TT> Gw.dEe</TT> edit descriptors indicate that the field width is<TT> w,</TT> the fractional part
contains<TT> d</TT> digits unless a scale factor greater than one is in effect, and the exponent consists of<TT> e</TT> digits.
<BR><BR><TT>G</TT> input editing is the same as<TT> F</TT> input editing.
<BR><BR>The representation on<TT> G</TT> output editing depends on the magnitude of the datum being edited.&nbsp; Let<TT>
M</TT> be the magnitude of the datum being edited.&nbsp; Then<TT> G</TT> output editing behaves as follows.
<OL>
<LI>If<TT> M &lt; 0.1</TT> or<TT> M &gt;= 10**d, Gw.d</TT> output editing is equivalent to<TT> kPEw.d</TT> output editing
and<TT> Gw.dEe</TT> output editing is equivalent to<TT> kPEw.dEe</TT> output editing where<TT> k</TT> is the scaling factor
currently in effect.
<LI>If<TT> 0.1 &lt;= M &lt; 10**d,</TT> the scale factor has no effect and the value of<TT> M</TT> determines the editing
as shown in the following table.
</OL>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +-----------------------+-----------------------------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; | Magnitude of Datum&nbsp;&nbsp;&nbsp; | Equivalent Edit Descriptor&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +-----------------------+-----------------------------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; | 0.1&lt;=M&lt;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;| F&lt;w-n&gt;.d followed by n blanks&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; | 1&lt;=M&lt;10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;| F&lt;w-n&gt;.&lt;d-1&gt; followed by n blanks |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; .&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; .&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; .&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; | 10**(d-2)&lt;=M&lt;10**(d-1)| F&lt;w-n&gt;.1 followed by n blanks&nbsp;&nbsp;&nbsp;&nbsp;
|</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; | 10**(d-1)&lt;=M&lt;10**d&nbsp;&nbsp;&nbsp; | F&lt;w-n&gt;.0 followed by n blanks&nbsp;
&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +-----------------------+-----------------------------------+</TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>&lt;w-n&gt;
<DD>stands for the integer represented by evaluating<TT> w-n.</TT>
<DT>&lt;d-1&gt;
<DD>stands for the integer represented by evaluating<TT> d-1.</TT>
<DT>n
<DD>is 4 for<TT> Gw.d</TT> editing and<TT> e+2</TT> for<TT> Gw.dEe</TT> editing.
</DL>
<BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT '(1H&lt;,G12.6,1H&gt;,1H&lt;,G12.4E4,1H&gt;)',
.5, .5</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>The output from the<TT> PRINT</TT> statement in the previous example is the string:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &lt;0.500000&nbsp;&nbsp;&nbsp; &gt;&lt;0.5000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt;</TT>
<H4 ID="Complex_Editing"> Complex Editing </H4>
<BR>Since a complex datum consists of a pair of real or double precision data, the editing of a complex datum is specified
by two successive pairs of<TT> F, E, D</TT> or<TT> G</TT> edit descriptors.&nbsp; The two descriptors may be different and
may be separated by any number of non-repeatable edit descriptors.&nbsp; Double precision complex editing is identical to
complex editing.
<H3 ID="L_Edit_Descriptor"> L Edit Descriptor </H3>
<BR>The<TT> Lw</TT> edit descriptor is used for I/O list items of type logical.&nbsp; The field width is<TT> w.</TT>
<BR><BR>On input the I/O list item will become defined with a datum of type logical.&nbsp; The input field consists of optional
blanks, followed by an optional decimal point followed by a<TT> T</TT> or<TT> F</TT> for true or false respectively.&nbsp;
The<TT> T</TT> and<TT> F</TT> may be followed by additional characters in the field.&nbsp; Open Watcom FORTRAN 77 allows<TT>
t</TT> and<TT> f</TT> in addition to<TT> T</TT> and<TT> F</TT> on input.
<BR><BR>On output, the I/O list item must be defined with a datum of type logical.&nbsp; The output field consists of<TT>
w-1</TT> blanks followed by a<TT> T</TT> for true or<TT> F</TT> for false.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT '(1H&lt;,L3,L5,1H&gt;)',.TRUE.,.FALSE.</TT>
<BR><BR>The output produced by the<TT> PRINT</TT> statement in the previous example is the string:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &lt;&nbsp; T&nbsp;&nbsp;&nbsp; F&gt;</TT>
<H3 ID="A_Edit_Descriptor"> A Edit Descriptor </H3>
<BR>The<TT> A[w]</TT> edit descriptor is used for I/O list items of type character.&nbsp; On input, the I/O list item becomes
defined with character data.&nbsp; On output, the I/O list item must be defined with character data.&nbsp; If<TT> w</TT> is
specified in the edit descriptor, the field width is<TT> w</TT> otherwise the field width is the number of characters in the
I/O list item.
<BR><BR>Open Watcom FORTRAN 77 also permits I/O list items of non-character data types.&nbsp; On input, the I/O list item
becomes defined with the binary representation of the character data.&nbsp; On output, the I/O list item is assumed to be
defined with character data.
<BR><BR>If<TT> len</TT> is the length of the I/O list item and<TT> w</TT> is specified in<TT> A</TT> input editing so that<TT>
w</TT> is greater than<TT> len,</TT> the rightmost<TT> len</TT> characters of the input field will be taken.&nbsp; If<TT>
w</TT> is less than<TT> len,</TT> then the<TT> w</TT> characters in the input field will be taken and padded with<TT> len-w</TT>
blanks.
<BR><BR>If<TT> w</TT> is specified in<TT> A</TT> output editing so that<TT> w</TT> is greater than<TT> len,</TT> then the
output field will consist of<TT> w-len</TT> blanks followed by the<TT> len</TT> characters of the I/O list item.&nbsp; If<TT>
w</TT> is less than or equal to<TT> len,</TT> the output field will consist of the first<TT> w</TT> characters of the I/O
list item.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT '(1H&lt;,A5,A8,1H&gt;)','ABCDEFG','123'</TT>
<BR><BR>The output produced by the<TT> PRINT</TT> statement in the previous example is the string:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &lt;ABCDE&nbsp;&nbsp;&nbsp;&nbsp; 123&gt;</TT>
<H3 ID="Z_Editing_LExtensionR"> Z Editing (Extension) </H3>
<BR>The<TT> Zw</TT> edit descriptor is used to display the hexadecimal representation of data or read hexadecimal data.&nbsp;
It is a Open Watcom FORTRAN 77 extension.&nbsp; The<TT> Zw</TT> edit descriptor can be used for I/O list items of any type.
&nbsp;The field width is<TT> w.</TT>
<BR><BR>On output,<TT> w</TT> must be greater than or equal to twice the size (in bytes) of the I/O list item since each byte
is represented by two hexadecimal digits.&nbsp; For example, real data requires four bytes.&nbsp; Hence,<TT> w</TT> must be
at least eight.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT '(1H&lt;,Z8,1H&gt;)', 256</TT>
<BR><BR>The output produced by the<TT> PRINT</TT> statement in the previous example is the string:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &lt;00000100&gt;</TT>
<BR><BR>If<TT> w</TT> is greater then the number of hexadecimal digits required to represent the data, the leftmost print
positions of the output field are filled with blanks.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT '(1H&lt;,Z10,1H&gt;)','ABCD'</TT>
<BR><BR>The output produced by the<TT> PRINT</TT> statement in the previous example is the string
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &lt;&nbsp; C1C2C3C4&gt;</TT>
<BR><BR>if the EBCDIC character set is being used or
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &lt;&nbsp; 41424344&gt;</TT>
<BR><BR>if the ASCII character set is being used.
<BR><BR>On input, if<TT> w</TT> is greater than twice the size (in bytes) of the I/O list item, the leftmost characters are
truncated from the input field.&nbsp; For example, if the input field contains the string
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 91A2C3D4</TT>
<BR><BR>and is read into a character variable whose length is two, the character would contain the hexadecimal data<TT> C3D4.</TT>
&nbsp;If<TT> w</TT> is less than twice the size (in bytes) of the I/O item, the I/O item is padded to the left with hexadecimal
zeroes.&nbsp; For example, if the input field contains the string
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 81C1</TT>
<BR><BR>and is read into a character variable whose length is four, the character would contain the hexadecimal data<TT> 000081C1.</TT>
<H2 ID="FormatMDirected_InputDOutput"> Format-Directed Input/Output </H2>
<BR><B> Format-directed input/output</B> (I/O) is formatted input or output controlled by a format specification.&nbsp; The
action taken during formatted input or output depends on the next edit descriptor in the format specification and the next
item in the input/output list if one exists.
<BR><BR>A format specification is processed from left to right.&nbsp; An edit descriptor or a format specification with a
repeat specification of<TT> r</TT> is processed as a list of<TT> r</TT> edit descriptors or format specifications.&nbsp; A
repeat specification of one is equivalent to no repeat specification.
<BR><BR>For each repeatable edit descriptor in the format specification, there corresponds one item in the I/O list except
an I/O list item of type complex where two repeatable floating-point edit descriptors are required.&nbsp; Non-repeatable edit
descriptors do not correspond to any I/O list item; they communicate information directly with the record.&nbsp; Whenever
a repeatable edit descriptor is encountered in a format specification, there must be a corresponding item in the I/O list.
&nbsp;The edited information is transmitted appropriately between the item and the record.
<BR><BR>Format processing is terminated when any of the following conditions occur.
<OL>
<LI>When an edit descriptor has no corresponding item in the I/O list.
<LI>When a colon edit descriptor is encountered and there are no more items in the I/O list.
<LI>When the right parenthesis is encountered and there are no more items in the I/O list.
</OL>
<BR>If the right parenthesis of the complete format specification is encountered and the I/O list has not been exhausted,
the file is positioned at the next record and format processing resumes at the start of the format specification terminated
by the last preceding right parenthesis.&nbsp; If there is no such right parenthesis, format processing resumes at the start
of the complete format specification.&nbsp; The part of the format specification that is reused must contain at least one
repeatable edit descriptor.&nbsp; If format processing resumes at a left parenthesis preceded by a repeat specification, the
repeat specification is also reused.&nbsp; The scale factor, sign control edit descriptors and blank control edit descriptors
are not affected when part of a format specification is reused.
<H2 ID="ListMDirected_Formatting"> List-Directed Formatting </H2>
<BR><B> List-directed formatting</B> is input/output without a format specification.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ( un, * ) X, Y, Z</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ( UNIT=un, FMT=* ) X, Y, Z</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ *, X, Y, Z</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WRITE( un, * ) X, Y, Z</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WRITE( UNIT=un, FMT=* ) X, Y, Z</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, X, Y, Z</TT>
<BR><BR>In the previous example, an asterisk instead of a format specification indicates list-directed formatting.
<BR><BR>Omitting the asterisk and format specification also indicates list-directed formatting.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ, X, Y, Z</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT, X, Y, Z</TT>
<BR><BR>Records used during list-directed formatting are called list-directed records.&nbsp; A list-directed record is a sequence
of values and value separators.&nbsp; Any sequence of blanks is treated as a single blank except when it appears in a character
constant.&nbsp; The end of a record has the same effect as a blank character.
<BR><BR>A<B> value</B> is one of the following:
<OL>
<LI>A constant.
<LI>A null value.
<LI><TT> r*c</TT>
<LI><TT> r*</TT>
</OL>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>r
<DD>is an unsigned, nonzero integer constant.
<DT>c
<DD>is a constant.
</DL>
<BR>The<TT> r*c</TT> form is equivalent to<TT> r</TT> successive occurrences of<TT> c.</TT>&nbsp; The<TT> r*</TT> form is
equivalent to<TT> r</TT> successive occurrences of the null value.&nbsp; In these two forms, blanks are permitted only where
they are allowed in the constant<TT> c.</TT>
<BR><BR>A<B> value separator</B> is one of the following:
<OL>
<LI>A comma preceded and followed by any number of blanks.
<LI>A slash preceded and followed by any number of blanks.&nbsp; A slash as a value separator terminates the execution of
the input statement.&nbsp; The definition status of the remaining input items in the input list remains the same as it was
prior to the input statement.
<LI>Any number of blanks between two values.
</OL>
<BR>A null value is specified by having no character between successive value separators, no characters preceding the first
value separator in a record or the<TT> r*</TT> form.&nbsp; It has no effect on the current value of the input item.&nbsp;
Note that the end of record following a value separator does not specify a null value.
<H3 ID="ListMDirected_Input"> List-Directed Input </H3>
<BR>The input forms acceptable to format specifications for a given type are also acceptable for list-directed formatting
with certain exceptions.
<OL>
<LI>Blanks are never used as zeroes and blanks embedded in constants are not allowed except in character constants.
<LI>An input item of type real or double precision must have an input field suitable for F editing except that no fractional
digits are assumed unless a decimal point is present in the field.&nbsp; Such a field will be called a<B> numeric input field.</B>
<LI>An input item of type complex or double precision complex must consist of a left parenthesis followed by two numeric input
fields separated by a comma and followed by a right parenthesis.&nbsp; The numeric input fields may be preceded or followed
by blanks.&nbsp; The end of record can only appear between the first numeric field and the comma or between the comma and
the second numeric field.&nbsp; Note that a null value must not be used as the real or imaginary part but may represent the
entire complex constant.
<LI>An input item of type logical must not include either a slash or a comma among the optional characters allowed in L editing.
<LI>An input item of type character consists of a non-empty string of characters enclosed in apostrophes.&nbsp; Apostrophes
in character constants are represented by two consecutive apostrophes without a blank or end of record separating them.&nbsp;
Character constants may span records.&nbsp; If this is the case, the end of record does cause a blanks to be inserted into
the character constant.&nbsp; Note that a comma or slash in a character constant is not a value separator.&nbsp; A character
input field is assigned to a character input item as though it were a character assignment.
</OL>
<H3 ID="ListMDirected_Output"> List-Directed Output </H3>
<BR>The form of the output field produced by list-directed output is similar to the form required by list-directed input.
&nbsp;The output of a character constant does not include the enclosing quotes and an apostrophe in a character constant is
output as a single apostrophe.&nbsp; The values are separated by one or more blanks.&nbsp; When printed, each record will
start with a blank if the file is a carriage-control oriented file.&nbsp; For example, the source listing file produced by
Open Watcom FORTRAN 77 is such a file.
<H2 ID="NamelistMDirected_Formatting_LExtensionR"> Namelist-Directed Formatting (Extension) </H2>
<BR>The<TT> READ</TT>,<TT> WRITE</TT>, and<TT> PRINT</TT> statements may be used to transmit data between a file and the variables
specified in a<TT> NAMELIST</TT> statement.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*20 NAME</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*20 STREET</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*15 CITY</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*20 STATE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*20 COUNTRY</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*10 ZIP_CODE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER AGE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER MARKS(10)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NAMELIST /nl/ NAME, STREET, CITY, STATE,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; COUNTRY, ZIP_CODE, AGE, MARKS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ( un, nl )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ( UNIT=un, FMT=nl )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ nl</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WRITE( un, nl )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WRITE( UNIT=un, FMT=nl )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT nl</TT>
<H3 ID="NamelistMDirected_Input_LExtensionR"> Namelist-Directed Input (Extension) </H3>
<BR>The input data must be in a special format.&nbsp; The first character in each record must be blank.&nbsp; The second character
in the first record of a group of data records must be an ampersand (&amp;) or dollar sign ($) immediately followed by the<TT>
NAMELIST</TT> name.&nbsp; The<TT> NAMELIST</TT> name must be followed by a blank and must not contain any imbedded blanks.
&nbsp;This name is followed by data items, optionally separated by commas.&nbsp; The end of a data group is signaled by the
character &quot;&amp;&quot; or &quot;$&quot;, optionally followed by the string &quot;END&quot;.&nbsp; If the &quot;&amp;&quot;
character was used to start the group, then it must be used to end the group.&nbsp; If the &quot;$&quot; character was used
to start the group, then it must be used to end the group.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 12345678901234567890...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;NL</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; item1, item2, item3,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; item4, item5, ...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><BR>The form of the data items in an input record is:
<DL>
<DT>Name = Constant
<DD>The name may be a variable name, an array element name, or a character substring name.&nbsp; The constant may be integer,
real, complex, logical or character.&nbsp; Logical constants may be in the form &quot;T&quot; or &quot;.TRUE&quot; and &quot;F&quot;
or &quot;.FALSE&quot;.&nbsp; Character constants must be contained within apostrophes.&nbsp; Subscripts and substring indices
must be of integer type.
<DT>ArrayName = Set of Constants
<DD>The set of constants consists of constants of the type integer, real, complex, logical or character.&nbsp; The constants are
separated by commas.&nbsp; The number of constants must be less than or equal to the number of elements in the array.&nbsp;
Successive occurrences of the same constant may be represented in the form<TT> r*constant,</TT> where<TT> r</TT> is a non-zero
integer constant specifying the number of times the constant is to occur.&nbsp; Consecutive commas within a list indicate
that the values of the array elements remain unchanged.
</DL>
<BR>The variable and array names specified in the input file must appear in the<TT> NAMELIST</TT> list, but the order is not
important.&nbsp; A name that has been made equivalent to a name in the input data cannot be substituted for that name in the<TT>
NAMELIST</TT> list.&nbsp; The list can contain names of items in<TT> COMMON</TT> but must not contain dummy argument names.
<BR><BR>Each data record must begin with a blank followed by a complete variable or array name or constant.&nbsp; Embedded
blanks are not permitted in names or constants.&nbsp; Trailing blanks after integers and exponents are treated as zeros.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;PERSON</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NAME = 'John Doe'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STREET = '22 Main St.' CITY = 'Smallville'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STATE = 'Texas'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; COUNTRY
= 'U.S.A.'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ZIP_CODE = '78910-1203'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MARKS = 73, 82, 3*78, 89, 2*93, 91, 88</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AGE = 23</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;END</TT>
<BR><BR>The input forms acceptable to format specifications for a given type are also acceptable for namelist-directed formatting
with certain exceptions.
<OL>
<LI>Blanks are never used as zeroes and blanks embedded in constants are not allowed except in character constants.
<LI>An input item of type real or double precision must have an input field suitable for F editing except that no fractional
digits are assumed unless a decimal point is present in the field.&nbsp; Such a field will be called a<B> numeric input field.</B>
<LI>An input item of type complex or double precision complex must consist of a left parenthesis followed by two numeric input
fields separated by a comma and followed by a right parenthesis.&nbsp; The numeric input fields may be preceded or followed
by blanks.&nbsp; The end of record can only appear between the first numeric field and the comma or between the comma and
the second numeric field.&nbsp; Note that a null value must not be used as the real or imaginary part but may represent the
entire complex constant.
<LI>An input item of type logical must not include either a slash or a comma among the optional characters allowed in L editing.
<LI>An input item of type character consists of a non-empty string of characters enclosed in apostrophes.&nbsp; Apostrophes
in character constants are represented by two consecutive apostrophes without a blank or end of record separating them.&nbsp;
Character constants may span records.&nbsp; If this is the case, the end of record does cause a blank to be inserted into
the character constant.&nbsp; Note that a comma or slash in a character constant is not a value separator.&nbsp; A character
input field is assigned to a character input item as though it were a character assignment.
</OL>
<H3 ID="NamelistMDirected_Output"> Namelist-Directed Output </H3>
<BR>The form of the data items in an output record is suitable for input using a namelist-directed<TT> READ</TT> statement.
<OL>
<LI>Output records are written using the ampersand character (&amp;), not the dollar sign ($), although the dollar sign is
accepted as an alternative during input.&nbsp; That is, the output data is preceded by &quot;&amp;name&quot; and is followed
by &quot;&amp;END&quot;.
<LI>All variable and array names specified in the<TT> NAMELIST</TT> list and their values are written out, each according
to its type.
<LI>Character data is enclosed in apostrophes.
<LI>The fields for the data are made large enough to contain all the significant digits.
<LI>The values of a complete array are written out in columns.
</OL>
<H1 ID="Functions_and_Subroutines"> Functions and Subroutines </H1>
<BR>Functions and subroutines are procedures that fall into one of the following categories.
<OL>
<LI>Statement functions
<LI>Intrinsic functions
<LI>External functions
<LI>Subroutines
</OL>
<BR>First let us introduce some terminology.
<BR><BR>A<B> program unit</B> is a collection of Open Watcom FORTRAN 77 statements and comments that can be either a main
program or a subprogram.
<BR><BR>A<B> main program</B> identifies the program unit where execution is to begin.&nbsp; A main program is a program unit
which has as its first statement a<TT> PROGRAM</TT> statement or one which does not have a<TT> PROGRAM</TT>,<TT> FUNCTION</TT>,<TT>
SUBROUTINE</TT> or<TT> BLOCK DATA</TT> statement as its first statement.&nbsp; Complete execution of the main program implies
the complete execution of the program.&nbsp; Each executable program can contain only one main program.
<BR><BR>A<B> subprogram</B> is a program unit that either has a<TT> FUNCTION</TT>,<TT> SUBROUTINE</TT> or<TT> BLOCK DATA</TT>
statement as its first statement.&nbsp; This chapter will only deal with subprograms that have a<TT> FUNCTION</TT> or<TT>
SUBROUTINE</TT> statement as its first statement.
<H2 ID="Statement_Functions"> Statement Functions </H2>
<BR>A statement function is a procedure defined by a single statement.&nbsp; Its definition must follow all specification
statements and precede the first executable statement.&nbsp; The statement defining a statement function is not an executable
statement.
<BR><BR>A<B> statement function</B> has the following form.
<BR><BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sf ( [d [,d] ...] ) = e</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>sf
<DD>is the name of the statement function.
<DT>d
<DD>is a statement function dummy argument.
<DT>e
<DD>is an expression.
</DL>
<BR>The expression<TT> e</TT> and the statement function name<TT> sf</TT> must conform according to the rules of assignment
as described in the chapter entitled <A HREF="#Assignment_Statements">Assignment Statements</A>.
<BR><BR>The statement function dummy arguments are variable names and are used to indicate the order, number and type of the
arguments of the statement function.&nbsp; A dummy argument name of a statement function must only appear once in the dummy
argument list of the statement function.&nbsp; Its scope is the statement defining the statement function.&nbsp; That is,
it becomes defined when the statement function is referenced and undefined when execution of the statement function is completed.
&nbsp;A name that is a statement function dummy argument can also be the name of a variable, a common block, the dummy argument
of another statement function or appear in the dummy argument list of a<TT> FUNCTION</TT>,<TT> SUBROUTINE</TT> or<TT> ENTRY</TT>
statement.&nbsp; It cannot be used in any other context.
<BR><BR>The expression<TT> e</TT> can contain any of the following as operands.
<OL>
<LI>A constant.
<LI>A symbolic constant.
<LI>A variable reference.&nbsp; This can be a reference to a statement function dummy argument or to a variable that appears
within the same program unit which defines the statement function.&nbsp; If the statement function dummy argument has the
same name as a variable in the same program unit, the statement function dummy argument is used.&nbsp; The variable reference
can also be a dummy argument that appears in the dummy argument list of a<TT> FUNCTION</TT> or<TT> SUBROUTINE</TT> statement.
&nbsp;If it is a dummy argument that has appeared in the dummy argument list of an<TT> ENTRY</TT> statement, then the<TT>
ENTRY</TT> statement must have previously appeared.
<LI>An array element reference.
<LI>An intrinsic function reference.
<LI>A reference to a statement function whose defining statement has previously appeared.
<LI>An external function reference.
<LI>A dummy procedure reference.
<LI>An expression enclosed in parentheses which adheres to the rules specified for the expression<TT> e.</TT>
</OL>
<H3 ID="Referencing_a_Statement_Function"> Referencing a Statement Function </H3>
<BR>A statement function is referenced by its use in an expression.&nbsp; The process of executing a statement function involves
the following steps.
<OL>
<LI>The expressions that form the actual arguments to the statement function are evaluated.
<LI>The dummy arguments of the statement function are associated with the actual arguments.
<LI>The expression<TT> e</TT> is evaluated.
<LI>The value of the result is converted to the type of the statement function according to the rules of assignment and is
available to the expression that contained the reference to the statement function.
</OL>
<BR>The actual arguments must agree in order, number and type with the corresponding dummy arguments.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SUBROUTINE CALC( U, V )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REAL POLY, X, Y, U, V, Z, CONST</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Define a Statement Function.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; POLY(X,Y) = X**2 + Y**2 + 2.0*X*Y + CONST</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Invoke the Statement Function.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONST = 23.5</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Z = POLY( U, V )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, Z</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>In the previous example, note that after the execution of the statement function, the values of<TT> X</TT> and<TT>
Y</TT> are not equal to the value of<TT> U</TT> and<TT> V</TT> respectively; they are undefined.
<H3 ID="Statement_Function_Restrictions"> Statement Function Restrictions </H3>
<OL>
<LI>A statement function is local to the program unit in which it is defined.&nbsp; Thus, a statement function name is not
allowed to appear in an<TT> EXTERNAL</TT> statement and cannot be passed to another procedure as an actual argument.&nbsp;
The following example illegally attempts to pass the statement function<TT> F</TT> to the subroutine<TT> SAM.</TT>
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Illegally passing a statement function</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * to a subroutine.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PROGRAM MAIN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; F(X) = X</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALL SAM( F )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<LI>If a statement function<TT> F</TT> contains a reference to another statement function<TT> G,</TT> then the statement defining<TT>
G</TT> must have previously appeared.&nbsp; In the following example, the expression defining the statement function<TT> F</TT>
illegally references a statement function<TT> G</TT> whose defining statement follows the statement defining<TT> F.</TT>
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Illegal order of statement functions.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; F(X) = X + G(X)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; G(X) = X + 2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<LI>The statement function name must not be the same name of any other entity in the program unit except possibly the name
of a common block.
<LI>If a dummy argument of a statement function is of type CHARACTER, then its length specification must be an integer constant
expression.&nbsp; The following is illegal.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SUBROUTINE SAM( X )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*(*) X</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Illegal - CHARACTER*(*) dummy argument not</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; allowed in statement function.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; F(X) = X</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, F('ABC')</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<LI>An actual argument to a statement function can be any expression, except character expressions involving the concatenation
of an operand whose length specification is<TT> (*)</TT> unless the operand is a symbolic constant.
</OL>
<H2 ID="Intrinsic_Functions"> Intrinsic Functions </H2>
<BR>An<B> intrinsic function</B> is a function that is provided by Open Watcom FORTRAN 77.
<H3 ID="Specific_Names_and_Generic_Names_of_Intrinsic_Functions"> Specific Names and Generic Names of Intrinsic Functions </H3>
<BR>All intrinsic functions can be referenced by using the<B> generic name</B> or the<B> specific name</B> of the intrinsic
function.&nbsp; The specific name uniquely identifies the function to be performed.&nbsp; The type of the result is predefined
thus its name need not appear in a type statement.&nbsp; For example, CLOG is a specific name of the generic LOG function
and computes the natural logarithm of a complex number.&nbsp; The type of the result is also COMPLEX.
<BR><BR>When the generic name is used, a specific name is selected based on the data type of the actual argument.&nbsp; For
example, the generic name of the natural logarithm intrinsic function is LOG.&nbsp; To compute the natural logarithm of REAL,
DOUBLE PRECISION, COMPLEX or DOUBLE PRECISION COMPLEX data, the generic name LOG can be used.&nbsp; Generic names simplify
the use of intrinsic functions because the same name can be used with more than one type of argument.
<BR><BR><B>Notes:</B>
<OL>
<LI>It is also possible to pass intrinsic functions to subprograms.&nbsp; When doing so, only the specific name of the intrinsic
function can be used as an actual argument.&nbsp; The specific name must have appeared in an<TT> INTRINSIC</TT> statement.
<LI>If an intrinsic function has more than one argument, each argument must be of the same type.
<LI>The generic and specific name of an intrinsic function is the same for some intrinsic functions.&nbsp; For example, the
specific name of the intrinsic function which computes the sine of an argument whose type is REAL is called SIN which is also
the generic name of the sine function.
</OL>
<BR>The following sections present all generic and specific names of intrinsic functions and describe how they are used.&nbsp;
The following is a guide to interpreting the information presented.
<BR><BR>Data types are represented by letter codes.
<OL>
<LI>CHARACTER is represented by CH.
<LI>LOGICAL is represented by L.
<LI>INTEGER is represented by I.
<LI>INTEGER*1 is represented by I1.
<LI>INTEGER*2 is represented by I2.
<LI>REAL (REAL*4) is represented by R.
<LI>DOUBLE PRECISION (REAL*8) is represented by D.
<LI>Single precision COMPLEX (COMPLEX*8) is represented by C.
<LI>Double precision COMPLEX (COMPLEX*16) is represented by Z.
</OL>
<BR>The &quot;Definition&quot; description gives the mathematical definition of the function performed by the intrinsic function.
&nbsp;There are two fields for each intrinsic function.&nbsp; The &quot;Name&quot; field lists the specific and generic names
of the intrinsic functions.&nbsp; When the name of an intrinsic function is a generic name, it is indicated by the letter
&quot;g&quot; in parentheses; all other names are specific names.&nbsp; The &quot;Usage&quot; field describes how the intrinsic
functions are used.&nbsp; &quot;R&lt;-ATAN2(R,R)&quot; is a typical entry in this field.&nbsp; The name of the intrinsic function
always follows the &quot;&lt;-&quot;.&nbsp; In this example the name of the intrinsic function is ATAN2.&nbsp; The data type
of the arguments to the intrinsic function are enclosed in parentheses, are separated by commas, and always follow the name
of the intrinsic function.&nbsp; In this case, ATAN2 requires two arguments both of type REAL.&nbsp; The type of the result
of the intrinsic function is indicated by the type preceding the &quot;&lt;-&quot;.&nbsp; In this case, the result of ATAN2
is of type REAL.
<BR><BR>Open Watcom FORTRAN 77 extensions to the FORTRAN 77 language are flagged by an exclamation mark (!).
<H3 ID="Type_Conversion__Conversion_to_integer"> Type Conversion:&nbsp; Conversion to integer </H3>
<DL>
<DT>Definition:
<DD><TT> int(a)</TT>
<DT>Name / Usage:
<DD>
<DT>INT (g)
<DD>I&lt;-INT(I), I&lt;-INT(R), I&lt;-INT(D), I&lt;-INT(C), I&lt;-INT(Z) !
<DT>INT
<DD>I&lt;-INT(R)
<DT>HFIX
<DD>I2&lt;-HFIX(R) !
<DT>IFIX
<DD>I&lt;-IFIX(R)
<DT>IDINT
<DD>I&lt;-IDINT(D)
<DT>Notes:
<DD>The value of int(X) is X if X is of type INTEGER.&nbsp; If X is of type REAL or DOUBLE PRECISION, then int(X) is 0 if |X|&lt;1
and the integer whose magnitude is the largest integer that does not exceed the magnitude of X and has the same sign of X
if |X| &gt; 1.&nbsp; If X is of type COMPLEX or COMPLEX*16, int(X) is int(real part of X).
<BR><BR>!&nbsp; is an extension to FORTRAN 77.
</DL>
<H3 ID="Type_Conversion__Conversion_to_real"> Type Conversion:&nbsp; Conversion to real </H3>
<DL>
<DT>Name / Usage:
<DD>
<DT>REAL (g)
<DD>R&lt;-REAL(I), R&lt;-REAL(R), R&lt;-REAL(D), R&lt;-REAL(C), R&lt;-REAL(Z) !
<DT>REAL
<DD>R&lt;-REAL(I)
<DT>FLOAT
<DD>R&lt;-FLOAT(I)
<DT>SNGL
<DD>R&lt;-SNGL(D)
<DT>Notes:
<DD>For X of type COMPLEX, REAL(X) is the real part of X.&nbsp; For X of type COMPLEX*16, REAL(X) is the single precision representation
of the real part of X.
<BR><BR>!&nbsp; is an extension to FORTRAN 77.
</DL>
<H3 ID="Type_Conversion__Conversion_to_double_precision"> Type Conversion:&nbsp; Conversion to double precision </H3>
<DL>
<DT>Name / Usage:
<DD>
<DT>DBLE (g)
<DD>D&lt;-DBLE(I), D&lt;-DBLE(R), D&lt;-DBLE(D), D&lt;-DBLE(C), D&lt;-DBLE(Z) !
<DT>DREAL
<DD>D&lt;-DREAL(Z) !
<DT>DFLOAT
<DD>D&lt;-DFLOAT(I) !
<DT>Notes:
<DD>For X of type COMPLEX, DBLE(X) is the double precision representation of the real part of X.&nbsp; For X of type COMPLEX*16,
DBLE(X) is the real part of X.
<BR><BR>!&nbsp; is an extension to FORTRAN 77.
</DL>
<H3 ID="Type_Conversion__Conversion_to_complex"> Type Conversion:&nbsp; Conversion to complex </H3>
<DL>
<DT>Name / Usage:
<DD>
<DT>CMPLX (g)
<DD>C&lt;-CMPLX(I), C&lt;-CMPLX(I,I), C&lt;-CMPLX(R), C&lt;-CMPLX(R,R), C&lt;-CMPLX(D), C&lt;-CMPLX(D,D), C&lt;-CMPLX(C), C&lt;-CMPLX(Z)
!
<DT>Notes:
<DD>If X is of type COMPLEX, then CMPLX(X) is X.&nbsp; If X is of type COMPLEX*16, then CMPLX(X) is a complex number whose real
part is REAL(real part of X) and imaginary part is REAL(imaginary part of X).
<BR><BR>If X is not of type COMPLEX, then CMPLX(X) is the complex number whose real part is REAL(X) and imaginary part is
REAL(0).&nbsp; CMPLX(X,Y) is the complex number whose real part is REAL(X) and whose imaginary part is REAL(Y) for X,Y not
of type COMPLEX.
<BR><BR>!&nbsp; is an extension to FORTRAN 77.
</DL>
<H3 ID="Type_Conversion__Conversion_to_double_complex"> Type Conversion:&nbsp; Conversion to double complex </H3>
<DL>
<DT>Name / Usage:
<DD>
<DT>DCMPLX (g) !
<DD>Z&lt;-DCMPLX(I), Z&lt;-DCMPLX(I,I), Z&lt;-DCMPLX(R), Z&lt;-DCMPLX(R,R), Z&lt;-DCMPLX(D), Z&lt;-DCMPLX(D,D), Z&lt;-DCMPLX(C),
Z&lt;-DCMPLX(Z)
<DT>Notes:
<DD>If X is of type COMPLEX*16, then DCMPLX(X) is X.&nbsp; If X is of type COMPLEX, then DCMPLX(X) is a COMPLEX*16 number whose
real part is DBLE(real part of X) and imaginary part is DBLE(imaginary part of X).
<BR><BR>If X is not of type COMPLEX*16, then DCMPLX(X) is the COMPLEX*16 number whose real part is DBLE(X) and imaginary part
is DBLE(0).&nbsp; DCMPLX(X,Y) is the COMPLEX*16 number whose real part is DBLE(X) and whose imaginary part is DBLE(Y) for
X,Y not of type COMPLEX.
<BR><BR>!&nbsp; is an extension to FORTRAN 77.
</DL>
<H3 ID="Type_Conversion__Character_conversion_to_integer"> Type Conversion:&nbsp; Character conversion to integer </H3>
<DL>
<DT>Name / Usage:
<DD>
<DT>ICHAR
<DD>I&lt;-ICHAR(CH)
<DT>Notes:
<DD>ICHAR returns an integer which describes the position of the character in the processor collating sequence.&nbsp; The first
character in the collating sequence is in position 0 and the last character of the collating sequence is in position n-1 where
n is the number of characters in the collating sequence.&nbsp; The value of ICHAR(X) for X a character of length one is such
that 0 &lt;= ICHAR(X) &lt;= n-1.&nbsp; For any characters X and Y, the following holds true.
<OL>
<LI>X .LT.&nbsp; Y if and only if ICHAR(X) .LT.&nbsp; ICHAR(Y)
<LI>X .EQ.&nbsp; Y if and only if ICHAR(X) .EQ.&nbsp; ICHAR(Y)
</OL>
<BR>CHAR is the inverse of ICHAR.
</DL>
<H3 ID="Type_Conversion__Conversion_to_character"> Type Conversion:&nbsp; Conversion to character </H3>
<DL>
<DT>Name / Usage:
<DD>
<DT>CHAR
<DD>CH&lt;-CHAR(I)
<DT>Notes:
<DD>CHAR returns the character in the i'th position of the processor collating sequence.&nbsp; The first character in the collating
sequence is in position 0 and the last character of the collating sequence is in position n-1 where n is the number of characters
in the collating sequence.&nbsp; The value of CHAR(I) is of type CHARACTER of length one.&nbsp; The argument I must be in
the range 0 &lt;= I &lt;= n-1.
<BR><BR>ICHAR is the inverse of CHAR.
</DL>
<H3 ID="Truncation"> Truncation </H3>
<DL>
<DT>Definition:
<DD><TT> int(a)</TT>
<DT>Name / Usage:
<DD>
<DT>AINT (g)
<DD>R&lt;-AINT(R), D&lt;-AINT(D)
<DT>AINT
<DD>R&lt;-AINT(R)
<DT>DINT
<DD>D&lt;-DINT(D)
<DT>Notes:
<DD>The value of int(X) is X if X is of type INTEGER.&nbsp; If X is of type REAL or DOUBLE PRECISION, then int(X) is 0 if |X|&lt;1
and the integer whose magnitude is the largest integer that does not exceed the magnitude of X and has the same sign of X
if |X| &gt; 1.&nbsp; If X is of type COMPLEX or COMPLEX*16, int(X) is int(real part of X).
</DL>
<H3 ID="Nearest_Whole_Number"> Nearest Whole Number </H3>
<DL>
<DT>Definition:
<DD><TT> int(a+.5)</TT> if a&gt;=0;<TT> int(a-.5)</TT> if a&lt;0
<DT>Name / Usage:
<DD>
<DT>ANINT (g)
<DD>R&lt;-ANINT(R), D&lt;-ANINT(D)
<DT>ANINT
<DD>R&lt;-ANINT(R)
<DT>DNINT
<DD>D&lt;-DNINT(D)
</DL>
<H3 ID="Nearest_Integer"> Nearest Integer </H3>
<DL>
<DT>Definition:
<DD><TT> int(a+.5)</TT> if a&gt;=0;<TT> int(a-.5)</TT> if a&lt;0
<DT>Name / Usage:
<DD>
<DT>NINT (g)
<DD>I&lt;-NINT(R), I&lt;-NINT(D)
<DT>NINT
<DD>I&lt;-NINT(R)
<DT>IDNINT
<DD>I&lt;-IDNINT(D)
</DL>
<H3 ID="Absolute_Value"> Absolute Value </H3>
<DL>
<DT>Definition:
<DD><TT> (ar**2+ai**2)**1/2</TT> if a is complex;<TT> |a|</TT> otherwise
<DT>Name / Usage:
<DD>
<DT>ABS (g)
<DD>I&lt;-ABS(I), I1&lt;-ABS(I1) !, I2&lt;-ABS(I2) !, R&lt;-ABS(R), D&lt;-ABS(D), R&lt;-ABS(C), D&lt;-ABS(Z) !
<DT>IABS
<DD>I&lt;-IABS(I)
<DT>I1ABS
<DD>I1&lt;-I1ABS(I1) !
<DT>I2ABS
<DD>I2&lt;-I2ABS(I2) !
<DT>ABS
<DD>R&lt;-ABS(R)
<DT>DABS
<DD>D&lt;-DABS(D)
<DT>CABS
<DD>R&lt;-CABS(C)
<DT>CDABS !
<DD>D&lt;-CDABS(Z)
<DT>Notes:
<DD>A complex number is an ordered pair of real numbers,<TT> (ar,ai)</TT> where<TT> ar</TT> is the real part and<TT> ai</TT> is
the imaginary part of the complex number.
<BR><BR>!&nbsp; is an extension to FORTRAN 77.
</DL>
<H3 ID="Remainder"> Remainder </H3>
<DL>
<DT>Definition:
<DD><TT> mod(a1,a2) = a1-int(a1/a2)*a2</TT>
<DT>Name / Usage:
<DD>
<DT>MOD (g)
<DD>I&lt;-MOD(I,I), I1&lt;-MOD(I1,I1) !, I2&lt;-MOD(I2,I2) !, R&lt;-MOD(R,R), D&lt;-MOD(D,D),
<DT>MOD
<DD>I&lt;-MOD(I,I)
<DT>I1MOD
<DD>I1&lt;-I1MOD(I1,I1) !
<DT>I2MOD
<DD>I2&lt;-I2MOD(I2,I2) !
<DT>AMOD
<DD>R&lt;-AMOD(R,R)
<DT>DMOD
<DD>D&lt;-DMOD(D,D)
<DT>Notes:
<DD>The value of int(X) is X if X is of type INTEGER.&nbsp; If X is of type REAL or DOUBLE PRECISION, then int(X) is 0 if |X|&lt;1
and the integer whose magnitude is the largest integer that does not exceed the magnitude of X and has the same sign of X
if |X| &gt; 1.&nbsp; If X is of type COMPLEX or COMPLEX*16, int(X) is int(real part of X).
<BR><BR>The value of MOD, I1MOD, I2MOD, AMOD or DMOD is undefined if the value of a2 is 0.
</DL>
<H3 ID="Transfer_of_Sign"> Transfer of Sign </H3>
<DL>
<DT>Definition:
<DD><TT> sign(a1,a2) = |a1|</TT> if a2&gt;=0;<TT> -|a1|</TT> if a2&lt;0
<DT>Name / Usage:
<DD>
<DT>SIGN (g)
<DD>I&lt;-SIGN(I,I), I1&lt;-SIGN(I1,I1) !, I2&lt;-SIGN(I2,I2) !, R&lt;-SIGN(R,R), D&lt;-SIGN(D,D)
<DT>ISIGN
<DD>I&lt;-ISIGN(I,I)
<DT>I1SIGN
<DD>I1&lt;-I1SIGN(I1,I1) !
<DT>I2SIGN
<DD>I2&lt;-I2SIGN(I2,I2) !
<DT>SIGN
<DD>R&lt;-SIGN(R,R)
<DT>DSIGN
<DD>D&lt;-DSIGN(D,D)
<DT>Notes:
<DD>If the value of a1 is 0, the result is 0 which has no sign.
</DL>
<H3 ID="Positive_Difference"> Positive Difference </H3>
<DL>
<DT>Definition:
<DD><TT> a1-a2</TT> if a1&gt;a2;<TT> 0</TT> if a1&lt;=a2
<DT>Name / Usage:
<DD>
<DT>DIM (g)
<DD>I&lt;-DIM(I,I), I1&lt;-DIM(I1,I1) !, I2&lt;-DIM(I2,I2) !, R&lt;-DIM(R,R), D&lt;-DIM(D,D)
<DT>IDIM
<DD>I&lt;-IDIM(I,I)
<DT>I1IDIM
<DD>I1&lt;-I1DIM(I1,I1) !
<DT>I2IDIM
<DD>I2&lt;-I2DIM(I2,I2) !
<DT>DIM
<DD>R&lt;-DIM(R,R)
<DT>DDIM
<DD>D&lt;-DDIM(D,D)
</DL>
<H3 ID="Double_Precision_Product"> Double Precision Product </H3>
<DL>
<DT>Definition:
<DD><TT> a1*a2</TT>
<DT>Name / Usage:
<DD>
<DT>DPROD
<DD>D&lt;-DPROD(R,R)
</DL>
<H3 ID="Choosing_Largest_Value"> Choosing Largest Value </H3>
<DL>
<DT>Definition:
<DD><TT> max(a1,a2,...)</TT>
<DT>Name / Usage:
<DD>
<DT>MAX (g)
<DD>I&lt;-MAX(I,...), I1&lt;-MAX(I1,...) !, I2&lt;-MAX(I2,...) !, R&lt;-MAX(R,...), D&lt;-MAX(D,...)
<DT>MAX0
<DD>I&lt;-MAX0(I,...)
<DT>I1MAX0
<DD>I1&lt;-I1MAX0(I1,...) !
<DT>I2MAX0
<DD>I2&lt;-I2MAX0(I2,...) !
<DT>AMAX1
<DD>R&lt;-AMAX1(R,...)
<DT>DMAX1
<DD>D&lt;-DMAX1(D,...)
<DT>AMAX0
<DD>R&lt;-AMAX0(I,...)
<DT>MAX1
<DD>I&lt;-MAX1(R,...)
</DL>
<H3 ID="Choosing_Smallest_Value"> Choosing Smallest Value </H3>
<DL>
<DT>Definition:
<DD><TT> min(a1,a2,...)</TT>
<DT>Name / Usage:
<DD>
<DT>MIN (g)
<DD>I&lt;-MIN(I,...), I1&lt;-MIN(I1,...) !, I2&lt;-MIN(I2,...) !, R&lt;-MIN(R,...), D&lt;-MIN(D,...)
<DT>MIN0
<DD>I&lt;-MIN0(I,...)
<DT>I1MIN0
<DD>I1&lt;-I1MIN0(I1,...) !
<DT>I2MIN0
<DD>I2&lt;-I2MIN0(I2,...) !
<DT>AMIN1
<DD>R&lt;-AMIN1(R,...)
<DT>DMIN1
<DD>D&lt;-DMIN1(D,...)
<DT>AMIN0
<DD>R&lt;-AMIN0(I,...)
<DT>MIN1
<DD>I&lt;-MIN1(R,...)
</DL>
<H3 ID="Length"> Length </H3>
<DL>
<DT>Definition:
<DD>Length of character entity
<DT>Name / Usage:
<DD>
<DT>LEN
<DD>I&lt;-LEN(CH)
<DT>Notes:
<DD>The argument to the LEN function need not be defined.
</DL>
<H3 ID="Length_Without_Trailing_Blanks"> Length Without Trailing Blanks </H3>
<DL>
<DT>Definition:
<DD>Length of character entity excluding trailing blanks
<DT>Name / Usage:
<DD>
<DT>LENTRIM
<DD>I&lt;-LENTRIM(CH)
</DL>
<H3 ID="Index_of_a_Substring"> Index of a Substring </H3>
<DL>
<DT>Definition:
<DD><TT> index(a1,a2)</TT> is location of substring<TT> a2</TT> in string<TT> a1</TT>
<DT>Name / Usage:
<DD>
<DT>INDEX
<DD>I&lt;-INDEX(CH,CH)
<DT>Notes:
<DD>INDEX(x,y) returns the starting position of a substring in x which is identical to y.&nbsp; The position of the first such
substring is returned.&nbsp; If y is not contained in x, zero is returned.
</DL>
<H3 ID="Imaginary_Part_of_Complex_Number"> Imaginary Part of Complex Number </H3>
<DL>
<DT>Definition:
<DD><TT> ai</TT>
<DT>Name / Usage:
<DD>
<DT>IMAG (g) !
<DD>R&lt;-IMAG(C), D&lt;-IMAG(Z)
<DT>AIMAG
<DD>R&lt;-AIMAG(C)
<DT>DIMAG
<DD>D&lt;-DIMAG(Z) !
<DT>Notes:
<DD>A complex number is an ordered pair of real numbers,<TT> (ar,ai)</TT> where<TT> ar</TT> is the real part and<TT> ai</TT> is
the imaginary part of the complex number.
<BR><BR>!&nbsp; is an extension to FORTRAN 77.
</DL>
<H3 ID="Conjugate_of_a_Complex_Number"> Conjugate of a Complex Number </H3>
<DL>
<DT>Definition:
<DD><TT> (ar,-ai)</TT>
<DT>Name / Usage:
<DD>
<DT>CONJG (g) !
<DD>C&lt;-CONJG(C), Z&lt;-CONJG(Z)
<DT>CONJG
<DD>C&lt;-CONJG(C)
<DT>DCONJG
<DD>Z&lt;-DCONJG(Z) !
<DT>Notes:
<DD>A complex number is an ordered pair of real numbers,<TT> (ar,ai)</TT> where<TT> ar</TT> is the real part and<TT> ai</TT> is
the imaginary part of the complex number.
<BR><BR>!&nbsp; is an extension to FORTRAN 77.
</DL>
<H3 ID="Square_Root"> Square Root </H3>
<DL>
<DT>Definition:
<DD><TT> a**1/2</TT>
<DT>Name / Usage:
<DD>
<DT>SQRT (g)
<DD>R&lt;-SQRT(R), D&lt;-SQRT(D), C&lt;-SQRT(C), Z&lt;-SQRT(Z) !
<DT>SQRT
<DD>R&lt;-SQRT(R)
<DT>DSQRT
<DD>D&lt;-DSQRT(D)
<DT>CSQRT
<DD>C&lt;-CSQRT(C)
<DT>CDSQRT
<DD>Z&lt;-CDSQRT(Z) !
<DT>Notes:
<DD>The argument to SQRT must be &gt;= 0.&nbsp; The result of CSQRT and CDSQRT is the principal value with the real part &gt;=
0.&nbsp; When the real part of the result is 0, the imaginary part is &gt;= 0.
<BR><BR>!&nbsp; is an extension to FORTRAN 77.
</DL>
<H3 ID="Exponential"> Exponential </H3>
<DL>
<DT>Definition:
<DD><TT> e**a</TT>
<DT>Name / Usage:
<DD>
<DT>EXP (g)
<DD>R&lt;-EXP(R), D&lt;-EXP(D), C&lt;-EXP(C), Z&lt;-EXP(Z) !
<DT>EXP
<DD>R&lt;-EXP(R)
<DT>DEXP
<DD>D&lt;-DEXP(D)
<DT>CEXP
<DD>C&lt;-CEXP(C)
<DT>CDEXP
<DD>Z&lt;-CDEXP(Z) !
<DT>Notes:
<DD>The result of a complex function is the principal value.
<BR><BR>!&nbsp; is an extension to FORTRAN 77.
</DL>
<H3 ID="Natural_Logarithm"> Natural Logarithm </H3>
<DL>
<DT>Definition:
<DD>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; log (a)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e</TT>
<DT>Name / Usage:
<DD>
<DT>LOG (g)
<DD>R&lt;-LOG(R), D&lt;-LOG(D), C&lt;-LOG(C), Z&lt;-LOG(Z) !
<DT>ALOG
<DD>R&lt;-ALOG(R)
<DT>DLOG
<DD>D&lt;-DLOG(D)
<DT>CLOG
<DD>C&lt;-CLOG(C)
<DT>CDLOG
<DD>Z&lt;-CDLOG(Z) !
<DT>Notes:
<DD>The value of<TT> a</TT> must be &gt; 0.&nbsp; The argument of CLOG and CDLOG must not be (0,0).&nbsp; The result of CLOG and
CDLOG is such that -pi &lt; imaginary part of the result &lt;= pi.&nbsp; The imaginary part of the result is pi only when
the real part of the argument is &lt; 0 and the imaginary part of the argument = 0.
<BR><BR>The result of a complex function is the principal value.
<BR><BR>!&nbsp; is an extension to FORTRAN 77.
</DL>
<H3 ID="Common_Logarithm"> Common Logarithm </H3>
<DL>
<DT>Definition:
<DD>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; log&nbsp; (a)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10</TT>
<DT>Name / Usage:
<DD>
<DT>LOG10 (g)
<DD>R&lt;-LOG10(R), D&lt;-LOG10(D)
<DT>ALOG10
<DD>R&lt;-ALOG10(R)
<DT>DLOG10
<DD>D&lt;-DLOG10(D)
</DL>
<H3 ID="Sine"> Sine </H3>
<DL>
<DT>Definition:
<DD><TT> sin(a)</TT>
<DT>Name / Usage:
<DD>
<DT>SIN (g)
<DD>R&lt;-SIN(R), D&lt;-SIN(D), C&lt;-SIN(C), Z&lt;-SIN(Z) !
<DT>SIN
<DD>R&lt;-SIN(R)
<DT>DSIN
<DD>D&lt;-DSIN(D)
<DT>CSIN
<DD>C&lt;-CSIN(C)
<DT>CDSIN
<DD>Z&lt;-CDSIN(Z) !
<DT>Notes:
<DD>All angles are assumed to be in radians.
<BR><BR>The result of a complex function is the principal value.
<BR><BR>!&nbsp; is an extension to FORTRAN 77.
</DL>
<H3 ID="Cosine"> Cosine </H3>
<DL>
<DT>Definition:
<DD><TT> cos(a)</TT>
<DT>Name / Usage:
<DD>
<DT>COS (g)
<DD>R&lt;-COS(R), D&lt;-COS(D), C&lt;-COS(C), Z&lt;-COS(Z) !
<DT>COS
<DD>R&lt;-COS(R)
<DT>DCOS
<DD>D&lt;-DCOS(D)
<DT>CCOS
<DD>C&lt;-CCOS(C)
<DT>CDCOS
<DD>Z&lt;-CDCOS(Z) !
<DT>Notes:
<DD>All angles are assumed to be in radians.
<BR><BR>The result of a complex function is the principal value.
<BR><BR>!&nbsp; is an extension to FORTRAN 77.
</DL>
<H3 ID="Tangent"> Tangent </H3>
<DL>
<DT>Definition:
<DD><TT> tan(a)</TT>
<DT>Name / Usage:
<DD>
<DT>TAN (g)
<DD>R&lt;-TAN(R), D&lt;-TAN(D)
<DT>TAN
<DD>R&lt;-TAN(R)
<DT>DTAN
<DD>D&lt;-DTAN(D)
<DT>Notes:
<DD>All angles are assumed to be in radians.
</DL>
<H3 ID="Cotangent"> Cotangent </H3>
<DL>
<DT>Definition:
<DD><TT> cotan(a)</TT>
<DT>Name / Usage:
<DD>
<DT>COTAN (g) !
<DD>R&lt;-COTAN(R), D&lt;-COTAN(D)
<DT>COTAN
<DD>R&lt;-COTAN(R) !
<DT>DCOTAN
<DD>D&lt;-DCOTAN(D) !
<DT>Notes:
<DD>All angles are assumed to be in radians.
<BR><BR>!&nbsp; is an extension to FORTRAN 77.
</DL>
<H3 ID="Arcsine"> Arcsine </H3>
<DL>
<DT>Definition:
<DD><TT> arcsin(a)</TT>
<DT>Name / Usage:
<DD>
<DT>ASIN (g)
<DD>R&lt;-ASIN(R), D&lt;-ASIN(D)
<DT>ASIN
<DD>R&lt;-ASIN(R)
<DT>DASIN
<DD>D&lt;-DASIN(D)
<DT>Notes:
<DD>The absolute value of the argument of ASIN and DASIN must be &lt;= 1.&nbsp; The result is such that -pi/2 &lt;= result &lt;=
pi/2.
</DL>
<H3 ID="Arccosine"> Arccosine </H3>
<DL>
<DT>Definition:
<DD><TT> arccos(a)</TT>
<DT>Name / Usage:
<DD>
<DT>ACOS (g)
<DD>R&lt;-ACOS(R), D&lt;-ACOS(D)
<DT>ACOS
<DD>R&lt;-ACOS(R)
<DT>DACOS
<DD>D&lt;-DACOS(D)
<DT>Notes:
<DD>The absolute value of the argument of ACOS and DACOS must be &lt;= 1.&nbsp; The result is such that 0 &lt;= result &lt;= pi.
</DL>
<H3 ID="Arctangent"> Arctangent </H3>
<DL>
<DT>Definition:
<DD><TT> arctan(a)</TT>
<DT>Name / Usage:
<DD>
<DT>ATAN (g)
<DD>R&lt;-ATAN(R), D&lt;-ATAN(D)
<DT>ATAN
<DD>R&lt;-ATAN(R)
<DT>DATAN
<DD>D&lt;-DATAN(D)
<DT>Definition:
<DD><TT> arctan(a1/a2)</TT>
<DT>Name / Usage:
<DD>
<DT>ATAN2 (g)
<DD>R&lt;-ATAN2(R,R), D&lt;-ATAN2(D,D)
<DT>ATAN2
<DD>R&lt;-ATAN2(R,R)
<DT>DATAN2
<DD>D&lt;-DATAN2(D,D)
<DT>Notes:
<DD>The result of ATAN and DATAN is such that -pi/2 &lt;= result &lt;= pi/2.&nbsp; If the value of the first argument of ATAN2
and DATAN2 is positive then the result is positive.&nbsp; If the value of the first argument is 0, the result is 0 if the
second argument is positive and pi if the second argument is negative.&nbsp; If the value of the first argument is negative,
the result is negative.&nbsp; If the value of the second argument is 0, the absolute value of the result is pi/2.&nbsp; The
arguments must not both be 0.&nbsp; The result of ATAN2 and DATAN2 is such that -pi &lt; result &lt;= pi.
</DL>
<H3 ID="Hyperbolic_Sine"> Hyperbolic Sine </H3>
<DL>
<DT>Definition:
<DD><TT> sinh(a)</TT>
<DT>Name / Usage:
<DD>
<DT>SINH (g)
<DD>R&lt;-SINH(R) D&lt;-SINH(D)
<DT>SINH
<DD>R&lt;-SINH(R)
<DT>DSINH
<DD>D&lt;-DSINH(D)
</DL>
<H3 ID="Hyperbolic_Cosine"> Hyperbolic Cosine </H3>
<DL>
<DT>Definition:
<DD><TT> cosh(a)</TT>
<DT>Name / Usage:
<DD>
<DT>COSH (g)
<DD>R&lt;-COSH(R), D&lt;-COSH(D)
<DT>COSH
<DD>R&lt;-COSH(R)
<DT>DCOSH
<DD>D&lt;-DCOSH(D)
</DL>
<H3 ID="Hyperbolic_Tangent"> Hyperbolic Tangent </H3>
<DL>
<DT>Definition:
<DD><TT> tanh(a)</TT>
<DT>Name / Usage:
<DD>
<DT>TANH (g)
<DD>R&lt;-TANH(R), D&lt;-TANH(D)
<DT>TANH
<DD>R&lt;-TANH(R)
<DT>DTANH
<DD>D&lt;-DTANH(D)
</DL>
<H3 ID="Gamma_Function"> Gamma Function </H3>
<DL>
<DT>Definition:
<DD><TT> gamma(a)</TT>
<DT>Name / Usage:
<DD>
<DT>GAMMA (g)
<DD>R&lt;-GAMMA(R), D&lt;-GAMMA(D)
<DT>GAMMA
<DD>R&lt;-GAMMA(R)
<DT>DGAMMA
<DD>D&lt;-DGAMMA(D)
</DL>
<H3 ID="Natural_Log_of_Gamma_Function"> Natural Log of Gamma Function </H3>
<DL>
<DT>Definition:
<DD>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; log (gamma(a))</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e</TT>
<DT>Name / Usage:
<DD>
<DT>LGAMMA (g)
<DD>R&lt;-LGAMMA(R), D&lt;-LGAMMA(D)
<DT>ALGAMA
<DD>R&lt;-ALGAMA(R)
<DT>DLGAMA
<DD>D&lt;-DLGAMA(D)
</DL>
<H3 ID="Error_Function"> Error Function </H3>
<DL>
<DT>Definition:
<DD><TT> erf(a)</TT>
<DT>Name / Usage:
<DD>
<DT>ERF (g)
<DD>R&lt;-ERF(R), D&lt;-ERF(D)
<DT>ERF
<DD>R&lt;-ERF(R)
<DT>DERF
<DD>D&lt;-DERF(D)
</DL>
<H3 ID="Complement_of_Error_Function"> Complement of Error Function </H3>
<DL>
<DT>Definition:
<DD><TT> 1-erf(a)</TT>
<DT>Name / Usage:
<DD>
<DT>ERFC (g)
<DD>R&lt;-ERFC(R), D&lt;-ERFC(D)
<DT>ERFC
<DD>R&lt;-ERFC(R)
<DT>DERFC
<DD>D&lt;-DERFC(D)
</DL>
<H3 ID="Lexically_Greater_Than_or_Equal"> Lexically Greater Than or Equal </H3>
<DL>
<DT>Definition:
<DD>a1&gt;=a2
<DT>Name / Usage:
<DD>
<DT>LGE
<DD>L&lt;-LGE(CH,CH)
<DT>Notes:
<DD>The ASCII collating sequence is used to evaluate the relation.
</DL>
<H3 ID="Lexically_Greater_Than"> Lexically Greater Than </H3>
<DL>
<DT>Definition:
<DD>a1&gt;a2
<DT>Name / Usage:
<DD>
<DT>LGT
<DD>L&lt;-LGT(CH,CH)
<DT>Notes:
<DD>The ASCII collating sequence is used to evaluate the relation.
</DL>
<H3 ID="Lexically_Less_Than_or_Equal"> Lexically Less Than or Equal </H3>
<DL>
<DT>Definition:
<DD>a1&lt;=a2
<DT>Name / Usage:
<DD>
<DT>LLE
<DD>L&lt;-LLE(CH,CH)
<DT>Notes:
<DD>The ASCII collating sequence is used to evaluate the relation.
</DL>
<H3 ID="Lexically_Less_Than"> Lexically Less Than </H3>
<DL>
<DT>Definition:
<DD>a1&lt;a2
<DT>Name / Usage:
<DD>
<DT>LLT
<DD>L&lt;-LLT(CH,CH)
<DT>Notes:
<DD>The ASCII collating sequence is used to evaluate the relation.
</DL>
<H3 ID="Binary_Pattern_Processing_Functions__Boolean_AND"> Binary Pattern Processing Functions:&nbsp; Boolean AND </H3>
<DL>
<DT>Definition:
<DD><TT> iand(i,j)</TT> Boolean AND
<DT>Name / Usage:
<DD>
<DT>IAND (g)
<DD>I&lt;-IAND(I,I), I1&lt;-IAND(I1,I1), I2&lt;-IAND(I2,I2)
<DT>IAND
<DD>I&lt;-IAND(I,I)
<DT>I1AND
<DD>I1&lt;-I1AND(I1,I1)
<DT>I2AND
<DD>I2&lt;-I2AND(I2,I2)
</DL>
<H3 ID="Binary_Pattern_Processing_Functions__Boolean_Inclusive_OR"> Binary Pattern Processing Functions:&nbsp; Boolean Inclusive OR </H3>
<DL>
<DT>Definition:
<DD><TT> ior(i,j)</TT> Boolean inclusive OR
<DT>Name / Usage:
<DD>
<DT>IOR (g)
<DD>I&lt;-IOR(I,I), I1&lt;-IOR(I1,I1), I2&lt;-IOR(I2,I2)
<DT>IOR
<DD>I&lt;-IOR(I,I)
<DT>I1OR
<DD>I1&lt;-I1OR(I1,I1)
<DT>I2OR
<DD>I2&lt;-I2OR(I2,I2)
</DL>
<H3 ID="Binary_Pattern_Processing_Functions__Boolean_Exclusive_OR"> Binary Pattern Processing Functions:&nbsp; Boolean Exclusive OR </H3>
<DL>
<DT>Definition:
<DD><TT> ieor(i,j)</TT> Boolean exclusive OR
<DT>Name / Usage:
<DD>
<DT>IEOR (g)
<DD>I&lt;-IEOR(I,I), I1&lt;-IEOR(I1,I1), I2&lt;-IEOR(I2,I2)
<DT>IEOR
<DD>I&lt;-IEOR(I,I)
<DT>I1EOR
<DD>I1&lt;-I1EOR(I1,I1)
<DT>I2EOR
<DD>I2&lt;-I2EOR(I2,I2)
</DL>
<H3 ID="Binary_Pattern_Processing_Functions__Boolean_Complement"> Binary Pattern Processing Functions:&nbsp; Boolean Complement </H3>
<DL>
<DT>Definition:
<DD><TT> not(i)</TT> Boolean complement
<DT>Name / Usage:
<DD>
<DT>NOT (g)
<DD>I&lt;-NOT(I), I1&lt;-NOT(I1), I2&lt;-NOT(I2)
<DT>NOT
<DD>I&lt;-NOT(I)
<DT>I1NOT
<DD>I1&lt;-I1NOT(I1)
<DT>I2NOT
<DD>I2&lt;-I2NOT(I2)
</DL>
<H3 ID="Binary_Pattern_Processing_Functions__Logical_Shift"> Binary Pattern Processing Functions:&nbsp; Logical Shift </H3>
<DL>
<DT>Definition:
<DD><TT> ishl(j,n)</TT> Logical shift
<DT>Name / Usage:
<DD>
<DT>ISHL (g)
<DD>I&lt;-ISHL(I,I), I1&lt;-ISHL(I1,I1), I2&lt;-ISHL(I2,I2)
<DT>ISHL
<DD>I&lt;-ISHL(I,I)
<DT>I1ISHL
<DD>I1&lt;-I1SHL(I1,I1)
<DT>I2ISHL
<DD>I2&lt;-I2SHL(I2,I2)
</DL>
<DL>
<DT>Definition:
<DD><TT> ishft(j,n)</TT> Logical shift
<DT>Name / Usage:
<DD>
<DT>ISHFT (g)
<DD>I&lt;-ISHFT(I,I), I1&lt;-ISHFT(I1,I1), I2&lt;-ISHFT(I2,I2)
<DT>ISHFT
<DD>I&lt;-ISHFT(I,I)
<DT>I1ISHFT
<DD>I1&lt;-I1SHFT(I1,I1)
<DT>I2ISHFT
<DD>I2&lt;-I2SHFT(I2,I2)
<DT>Notes:
<DD>There are three shift operations:&nbsp; logical, arithmetic and circular.&nbsp; These shift operations are implemented as
integer functions having two arguments.&nbsp; The first argument,<TT> j,</TT> is the value to be shifted and the second argument,<TT>
n,</TT> is the number of bits to shift.&nbsp; If<TT> n</TT> is less than 0, a right shift is performed.&nbsp; If<TT> n</TT>
is greater than 0, a left shift is performed.&nbsp; If<TT> n</TT> is equal to 0, no shift is performed.&nbsp; Note that the
arguments are not modified.
<BR><BR>In a logical shift, bits shifted out from the left or right are lost.&nbsp; Zeros are shifted in from the opposite
end.
<BR><BR>In an arithmetic shift,<TT> j</TT> is considered a signed integer.&nbsp; In the case of a right shift, zeros are shifted
into the left if<TT> j</TT> is positive and ones if<TT> j</TT> is negative.&nbsp; Bits shifted out of the right are lost.
&nbsp;In the case of a left shift, zeros are shifted into the right and bits shifted out of the left are lost.
<BR><BR>In a circular shift, bits shifted out one end are shifted into the opposite end.&nbsp; No bits are lost.
</DL>
<H3 ID="Binary_Pattern_Processing_Functions__Arithmetic_Shift"> Binary Pattern Processing Functions:&nbsp; Arithmetic Shift </H3>
<DL>
<DT>Definition:
<DD><TT> isha(j,n)</TT> Arithmetic shift
<DT>Name / Usage:
<DD>
<DT>ISHA (g)
<DD>I&lt;-ISHA(I,I), I1&lt;-ISHA(I1,I1), I2&lt;-ISHA(I2,I2)
<DT>ISHA
<DD>I&lt;-ISHA(I,I)
<DT>I1ISHA
<DD>I1&lt;-I1SHA(I1,I1)
<DT>I2ISHA
<DD>I2&lt;-I2SHA(I2,I2)
<DT>Notes:
<DD>There are three shift operations:&nbsp; logical, arithmetic and circular.&nbsp; These shift operations are implemented as
integer functions having two arguments.&nbsp; The first argument,<TT> j,</TT> is the value to be shifted and the second argument,<TT>
n,</TT> is the number of bits to shift.&nbsp; If<TT> n</TT> is less than 0, a right shift is performed.&nbsp; If<TT> n</TT>
is greater than 0, a left shift is performed.&nbsp; If<TT> n</TT> is equal to 0, no shift is performed.&nbsp; Note that the
arguments are not modified.
<BR><BR>In a logical shift, bits shifted out from the left or right are lost.&nbsp; Zeros are shifted in from the opposite
end.
<BR><BR>In an arithmetic shift,<TT> j</TT> is considered a signed integer.&nbsp; In the case of a right shift, zeros are shifted
into the left if<TT> j</TT> is positive and ones if<TT> j</TT> is negative.&nbsp; Bits shifted out of the right are lost.
&nbsp;In the case of a left shift, zeros are shifted into the right and bits shifted out of the left are lost.
<BR><BR>In a circular shift, bits shifted out one end are shifted into the opposite end.&nbsp; No bits are lost.
</DL>
<H3 ID="Binary_Pattern_Processing_Functions__Circular_Shift"> Binary Pattern Processing Functions:&nbsp; Circular Shift </H3>
<DL>
<DT>Definition:
<DD><TT> ishc(j,n)</TT> Circular shift
<DT>Name / Usage:
<DD>
<DT>ISHC (g)
<DD>I&lt;-ISHC(I,I), I1&lt;-ISHC(I1,I1), I2&lt;-ISHC(I2,I2)
<DT>ISHC
<DD>I&lt;-ISHC(I,I)
<DT>I1ISHC
<DD>I1&lt;-I1SHC(I1,I1)
<DT>I2ISHC
<DD>I2&lt;-I2SHC(I2,I2)
<DT>Notes:
<DD>There are three shift operations:&nbsp; logical, arithmetic and circular.&nbsp; These shift operations are implemented as
integer functions having two arguments.&nbsp; The first argument,<TT> j,</TT> is the value to be shifted and the second argument,<TT>
n,</TT> is the number of bits to shift.&nbsp; If<TT> n</TT> is less than 0, a right shift is performed.&nbsp; If<TT> n</TT>
is greater than 0, a left shift is performed.&nbsp; If<TT> n</TT> is equal to 0, no shift is performed.&nbsp; Note that the
arguments are not modified.
<BR><BR>In a logical shift, bits shifted out from the left or right are lost.&nbsp; Zeros are shifted in from the opposite
end.
<BR><BR>In an arithmetic shift,<TT> j</TT> is considered a signed integer.&nbsp; In the case of a right shift, zeros are shifted
into the left if<TT> j</TT> is positive and ones if<TT> j</TT> is negative.&nbsp; Bits shifted out of the right are lost.
&nbsp;In the case of a left shift, zeros are shifted into the right and bits shifted out of the left are lost.
<BR><BR>In a circular shift, bits shifted out one end are shifted into the opposite end.&nbsp; No bits are lost.
</DL>
<H3 ID="Binary_Pattern_Processing_Functions__Bit_Testing"> Binary Pattern Processing Functions:&nbsp; Bit Testing </H3>
<DL>
<DT>Definition:
<DD>Test bit - a2'th bit of a1 is tested.&nbsp; If it is 1, .TRUE.&nbsp; is returned.&nbsp; If it is 0, .FALSE.&nbsp; is returned.
<DT>Name / Usage:
<DD>
<DT>BTEST (g)
<DD>L&lt;-BTEST(I,I), L&lt;-BTEST(I1,I1), L&lt;-BTEST(I2,I2)
<DT>BTEST
<DD>L&lt;-BTEST(I,I)
<DT>I1BTEST
<DD>L&lt;-I1BTEST(I1,I1)
<DT>I2BTEST
<DD>L&lt;-I2BTEST(I2,I2)
</DL>
<H3 ID="Binary_Pattern_Processing_Functions__Set_Bit"> Binary Pattern Processing Functions:&nbsp; Set Bit </H3>
<DL>
<DT>Definition:
<DD>Set bit - Return a1 with a2'th bit set.
<DT>Name / Usage:
<DD>
<DT>IBSET (g)
<DD>I&lt;-IBSET(I,I), I1&lt;-IBSET(I1,I1), I2&lt;-IBSET(I2,I2)
<DT>IBSET
<DD>I&lt;-IBSET(I,I)
<DT>I1IBSET
<DD>I1&lt;-I1BSET(I1,I1)
<DT>I2IBSET
<DD>I2&lt;-I2BSET(I2,I2)
</DL>
<H3 ID="Binary_Pattern_Processing_Functions__Clear_Bit"> Binary Pattern Processing Functions:&nbsp; Clear Bit </H3>
<DL>
<DT>Definition:
<DD>Clear bit - Return a1 with a2'th bit cleared.
<DT>Name / Usage:
<DD>
<DT>IBCLR (g)
<DD>I&lt;-IBCLR(I,I), I1&lt;-IBCLR(I1,I1), I2&lt;-IBCLR(I2,I2)
<DT>IBCLR
<DD>I&lt;-IBCLR(I,I)
<DT>I1IBCLR
<DD>I1&lt;-I1BCLR(I1,I1)
<DT>I2IBCLR
<DD>I2&lt;-I2BCLR(I2,I2)
</DL>
<H3 ID="Binary_Pattern_Processing_Functions__Change_Bit"> Binary Pattern Processing Functions:&nbsp; Change Bit </H3>
<DL>
<DT>Definition:
<DD>Change bit - Return a1 with a2'th bit complemented.
<DT>Name / Usage:
<DD>
<DT>IBCHNG (g)
<DD>I&lt;-IBCHNG(I,I), I1&lt;-IBCHNG(I1,I1), I2&lt;-IBCHNG(I2,I2)
<DT>IBCHNG
<DD>I&lt;-IBCHNG(I,I)
<DT>I1IBCHNG
<DD>I1&lt;-I1BCHNG(I1,I1)
<DT>I2IBCHNG
<DD>I2&lt;-I2BCHNG(I2,I2)
</DL>
<H3 ID="Binary_Pattern_Processing_Functions__Arithmetic_Shifts"> Binary Pattern Processing Functions:&nbsp; Arithmetic Shifts </H3>
<DL>
<DT>Definition:
<DD><TT> lshift(j,n)</TT> Arithmetic left shift
<DT>Name / Usage:
<DD>
<DT>LSHIFT (g)
<DD>I&lt;-LSHIFT(I,I), I1&lt;-LSHIFT(I1,I1), I2&lt;-LSHIFT(I2,I2)
<DT>LSHIFT
<DD>I&lt;-LSHIFT(I,I)
<DT>I1LSHIFT
<DD>I1&lt;-I1LSHIFT(I1,I1)
<DT>I2LSHIFT
<DD>I2&lt;-I2LSHIFT(I2,I2)
</DL>
<DL>
<DT>Definition:
<DD><TT> rshift(j,n)</TT> Arithmetic right shift
<DT>Name / Usage:
<DD>
<DT>RSHIFT (g)
<DD>I&lt;-RSHIFT(I,I), I1&lt;-RSHIFT(I1,I1), I2&lt;-RSHIFT(I2,I2)
<DT>RSHIFT
<DD>I&lt;-RSHIFT(I,I)
<DT>I1RSHIFT
<DD>I1&lt;-I1RSHIFT(I1,I1)
<DT>I2RSHIFT
<DD>I2&lt;-I2RSHIFT(I2,I2)
<DT>Notes:
<DD>
<BR><BR>With these shift functions,<TT> n</TT> must be a non-negative integer.&nbsp; In an arithmetic shift,<TT> j</TT> is
considered a signed integer.&nbsp; In the case of a left shift, zeros are shifted into the right and bits shifted out of the
left are lost.&nbsp; In the case of a right shift, zeros are shifted into the left if<TT> j</TT> is positive and ones if<TT>
j</TT> is negative.&nbsp; Bits shifted out of the right are lost.
<BR><BR>If<TT> n</TT> is equal to 0, no shift is performed.&nbsp; Note that the arguments are not modified.
<BR><BR>These functions are compiled as in-line code unless they are passed as arguments.
</DL>
<H3 ID="Allocated_Array"> Allocated Array </H3>
<DL>
<DT>Definition:
<DD>Is array A allocated?
<DT>Name / Usage:
<DD>
<DT>ALLOCATED
<DD>L&lt;-ALLOCATED(A)
</DL>
<H3 ID="Memory_Location"> Memory Location </H3>
<DL>
<DT>Definition:
<DD>Location of A where A is any variable, array or array element
<DT>Name / Usage:
<DD>
<DT>LOC
<DD>I&lt;-LOC(A)
</DL>
<H3 ID="Size_of_Variable_or_Structure"> Size of Variable or Structure </H3>
<DL>
<DT>Definition:
<DD>Size of A in bytes where A is any constant, variable, array, or structure
<DT>Name / Usage:
<DD>
<DT>ISIZEOF
<DD>I&lt;-ISIZEOF(A)
<DT>Notes:
<DD>The size reported for a constant or simple variable is based on its type.&nbsp; The size of a CHARACTER constant is the number
of characters in the constant.&nbsp; The size reported for an array is the size of the storage area required for the array.
&nbsp;The size reported for a structure is the size of the storage area required for the structure.&nbsp; An assumed-size
CHARACTER variable, assumed-size array, or allocatable array has size 0.
</DL>
<H3 ID="Volatile_Reference"> Volatile Reference </H3>
<DL>
<DT>Definition:
<DD>A is a volatile reference
<DT>Name / Usage:
<DD>
<DT>VOLATILE
<DD>A&lt;-VOLATILE(A)
<DT>Notes:
<DD>A volatile reference to a symbol indicates that the value of the symbol may be modified in ways that are unknown to the subprogram.
&nbsp;For example, a symbol in common being referenced in a subprogram may be modified by another subprogram that is processing
an asynchronous interrupt.&nbsp; Therefore, any subprogram that is referencing the symbol to determine its value should reference
this symbol using the<TT> VOLATILE</TT> intrinsic function so that the value currently being evaluated agrees with the value
last stored.
</DL>
<H2 ID="External_Functions"> External Functions </H2>
<BR>An<B> external function</B> is a program unit that has a<TT> FUNCTION</TT> statement as its first statement.&nbsp; It
is defined externally to the program units that reference it.&nbsp; The form of a<TT> FUNCTION</TT> statement is defined in
the chapter entitled <A HREF="#FORTRAN_Statements">FORTRAN Statements</A>.
<BR><BR>The name of an external function is treated as if it was a variable.&nbsp; It is through the function name that the
result of an external function becomes defined.&nbsp; This variable must become defined before the execution of the external
function is completed.&nbsp; Once defined, it can be referenced or redefined.&nbsp; The value of this variable when a<TT>
RETURN</TT> or<TT> END</TT> statement is executed is the result returned by the external function.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER FUNCTION VECSUM( A, N )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER A(N), I</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECSUM = 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO 10 I = 1, N</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VECSUM = VECSUM + A(I)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 10&nbsp;&nbsp;&nbsp; CONTINUE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>If the variable representing the return value of the external function is of type CHARACTER with a length specification
of<TT> (*),</TT> it must not be the operand of a concatenation operator unless it appears in a character assignment statement.
<BR><BR>It is also possible for an external function to return results through its dummy arguments by assigning to them.&nbsp;
The following example demonstrates this.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER MARKS(40), N</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REAL AVG, STDDEV, MEAN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'Enter number of marks'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ( 5, * ) N</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'Enter marks'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ( 5, * ) (MARKS(I), I = 1, N)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AVG = MEAN( MARKS, N, STDDEV )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'Mean = ', AVG,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Standard
Deviation = ', STDDEV</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * Define function MEAN to return the average by</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * defining the function name and return the standard</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * deviation by defining a dummy argument.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REAL FUNCTION MEAN( A, N, STDDEV )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER A, N, I</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REAL STDDEV</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DIMENSION A(N)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MEAN = 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO 10 I = 1, N</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MEAN = MEAN + A(I)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 10&nbsp;&nbsp;&nbsp; CONTINUE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MEAN = MEAN / N</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STDDEV = 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO 20 I = 1, N</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STDDEV = STDDEV + ( A(I) - MEAN
)**2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 20&nbsp;&nbsp;&nbsp; CONTINUE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STDDEV = SQRT( STDDEV / (N - 1) )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<H3 ID="Referencing_an_External_Function"> Referencing an External Function </H3>
<BR>When an external function is referenced in an expression or a<TT> CALL</TT> statement, the following steps are performed.
<OL>
<LI>The actual arguments are evaluated.
<LI>The actual arguments are associated with the corresponding dummy arguments.
<LI>The external function is executed.
</OL>
<BR>The type of the external function reference must be the same as the type of the function name in the external function
subprogram.&nbsp; If the external function is of type CHARACTER, the length must also match.
<H3 ID="Actual_Arguments_for_an_External_Function"> Actual Arguments for an External Function </H3>
<BR>An actual argument must be one of the following.
<OL>
<LI>Any expression except a character expression involving the concatenation of an operand whose length specification is<TT>
(*)</TT> unless the operand is a symbolic constant.
<LI>An array name.
<LI>An intrinsic function name (must be the specific name) that has appeared in an<TT> INTRINSIC</TT> statement.
<LI>An external procedure name.
<LI>A dummy procedure name.
</OL>
<BR>The actual arguments of an external function reference must match the order, number and type of the corresponding dummy
arguments.&nbsp; If a subroutine is an actual argument, then type agreement is not required since a subroutine has no type.
<H3 ID="External_Function_Subprogram_Restrictions"> External Function Subprogram Restrictions </H3>
<OL>
<LI>The name of an external function is a global name and must not be the same as any other global name or name local to the
subprogram whose name is that of the external function.&nbsp; Note that the external function name is treated as a variable
within the external function subprogram.
<LI>The name of a dummy argument is a name local to the subprogram and must not appear in an<TT> EQUIVALENCE</TT>,<TT> PARAMETER</TT>,<TT>
SAVE</TT>,<TT> INTRINSIC</TT> or<TT> DATA</TT> statement within the same subprogram.&nbsp; It may appear in a<TT> COMMON</TT>
statement only as the name of a common block.
<LI>The name of the external function can in no way, directly or indirectly, be referenced as a subprogram from within the
subprogram it defines.&nbsp; It can appear in a type statement to establish its type only if the type has not been established
in the<TT> FUNCTION</TT> statement.
</OL>
<H2 ID="Subroutines"> Subroutines </H2>
<BR>A<B> subroutine</B> is a program unit that has a<TT> SUBROUTINE</TT> statement as it first statement.&nbsp; It is defined
externally to the program units that reference it.&nbsp; The form of a<TT> SUBROUTINE</TT> statement can be found in the chapter
entitled <A HREF="#FORTRAN_Statements">FORTRAN Statements</A>.
<BR><BR>A subroutine differs from a function in that it does not return a result and hence has no type associated with it.
&nbsp;However, it is possible to return values from a subroutine by defining or redefining the dummy arguments of the subroutine.
<H3 ID="Referencing_a_Subroutine__The_CALL_Statement"> Referencing a Subroutine:&nbsp; The CALL Statement </H3>
<BR>Unlike a function, a subroutine cannot appear in an expression.&nbsp; Subroutines are referenced by using a<TT> CALL</TT>
statement.&nbsp; See the chapter entitled <A HREF="#FORTRAN_Statements">FORTRAN Statements</A> for details on the<TT> CALL</TT>
statement.&nbsp; When a<TT> CALL</TT> statement is executed, the following steps are performed.
<OL>
<LI>The actual arguments are evaluated.
<LI>The actual arguments are associated with the corresponding dummy arguments.
<LI>The subroutine is executed.
</OL>
<BR>A subroutine can be called from any subprogram but must not be called by itself, indirectly or directly.
<H3 ID="Actual_Arguments_for_a_Subroutine"> Actual Arguments for a Subroutine </H3>
<BR>Each actual argument in a subroutine call must be one of the following.
<OL>
<LI>Any expression except a character expression involving the concatenation of an operand whose length specification is<TT>
(*)</TT> unless the operand is a symbolic constant.
<LI>An array name.
<LI>An intrinsic function name (must be the specific name) that has appeared in an<TT> INTRINSIC</TT> statement.
<LI>An external procedure name.
<LI>A dummy procedure name.
<LI>An<B> alternate return specifier</B> of the form<TT> *s</TT> where<TT> s</TT> is a statement number of an executable statement
in the subprogram which contained the<TT> CALL</TT> statement.&nbsp; This will be covered in more detail when the<TT> RETURN</TT>
statement is discussed.
</OL>
<BR>The actual arguments must agree in order, number and type with the corresponding dummy arguments.&nbsp; The type agreement
does not apply to an actual argument which is an alternate return specifier or a subroutine name since neither has a type.
<H3 ID="Subroutine_Subprogram_Restrictions"> Subroutine Subprogram Restrictions </H3>
<OL>
<LI>A subroutine subprogram can contain any statement except a<TT> FUNCTION</TT>,<TT> BLOCK DATA</TT> or<TT> PROGRAM</TT>
statement.
<LI>The name of a subroutine is a global name and must not be used as another global name.&nbsp; Furthermore, no local name
in the subroutine subprogram can have the same name as the subroutine.
<LI>The name of a dummy argument is local to the subroutine subprogram and must not appear in an<TT> EQUIVALENCE</TT>,<TT>
PARAMETER</TT>,<TT> SAVE</TT>,<TT> INTRINSIC</TT> or<TT> DATA</TT> statement.&nbsp; It may appear in a<TT> COMMON</TT> statement
only as the name of a common block.
</OL>
<H2 ID="The_ENTRY_Statement"> The ENTRY Statement </H2>
<BR>An<TT> ENTRY</TT> statement allows execution of a subprogram to begin at a particular executable statement within the
subprogram in which it appears.&nbsp; An<TT> ENTRY</TT> statement defines an alternate<B> entry point</B> into a subprogram
and can appear anywhere after the<TT> FUNCTION</TT> statement in a function subprogram or the<TT> SUBROUTINE</TT> statement
in a subroutine subprogram.&nbsp; Also, it must not appear as a statement between the beginning and end of a control structure.
&nbsp;For example, an<TT> ENTRY</TT> statement cannot appear between a block<TT> IF</TT> statement and its corresponding<TT>
END IF</TT> statement or between a<TT> DO</TT> statement and the corresponding terminal statement.&nbsp; It is possible to
have more than one<TT> ENTRY</TT> statement in a subprogram.&nbsp; An<TT> ENTRY</TT> statement is a non-executable statement.
&nbsp;The form of an<TT> ENTRY</TT> statement can be found in the chapter entitled <A HREF="#FORTRAN_Statements">FORTRAN Statements</A>.
<BR><BR>Each entry name defines an external function if it appears in a function, or an external subroutine if it appears
in a subroutine and is referenced in the same way as the actual function or subroutine name would be referenced.&nbsp; Execution
begins at the first executable statement that follows the<TT> ENTRY</TT> statement.&nbsp; The order, number, type and names
of the dummy argument lists of an<TT> ENTRY</TT> statement may be different from that of a<TT> FUNCTION</TT>,<TT> SUBROUTINE</TT>
or other<TT> ENTRY</TT> statement.&nbsp; However, there must still be agreement between the actual argument list used to reference
an entry name and the dummy argument list in the corresponding<TT> ENTRY</TT> statement.
<H3 ID="ENTRY_Statements_in_External_Functions"> ENTRY Statements in External Functions </H3>
<BR>Entry names may also appear in type statements.&nbsp; Their type may or may not be the same type as other entry names
or the actual name of the external function unless the function is of type CHARACTER.&nbsp; If the function is of type CHARACTER
then the type of all the entry names must be of type CHARACTER.&nbsp; Conversely, if an entry name is of type CHARACTER, then
all other entry names and the function name must be of type CHARACTER.&nbsp; An entry name, like external function names,
is treated as a variable within the subprogram it appears.&nbsp; Within a function subprogram, there is an association between
variables whose name is an entry name and the variable whose name corresponds to the external function.&nbsp; When such a
variable becomes defined, all other such variables of the<B> same</B> type also become defined and other such variables not
of the same type become undefined.&nbsp; This can be best illustrated by an example.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, EVAL(2), EVAL3(4.0)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER FUNCTION EVAL( X )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER EVAL2, X</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REAL EVAL3, Y</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C = 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GOTO 10</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENTRY EVAL2( X )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C = 2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GOTO 10</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENTRY EVAL3( Y )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C = 3</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 10&nbsp;&nbsp;&nbsp; EVAL2 = C * X</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>In the previous example, invoking<TT> EVAL</TT> would cause the result of 2 to be returned even though<TT> EVAL</TT>
was never assigned to in the function<TT> EVAL</TT> but since<TT> EVAL2</TT> and<TT> EVAL</TT> are of the same type they are
associated and hence defining<TT> EVAL2</TT> causes<TT> EVAL</TT> to be defined.&nbsp; However, invoking<TT> EVAL3</TT> would
cause an undefined result to be returned since<TT> EVAL3</TT> is of type REAL and<TT> EVAL2</TT> is of type INTEGER and hence
are not associated.<TT>&nbsp; EVAL3</TT> does not become defined.
<H3 ID="ENTRY_Statement_Restrictions"> ENTRY Statement Restrictions </H3>
<OL>
<LI>An entry name may not appear in any statement previous to the<TT> ENTRY</TT> statement containing the entry name except
in a type statement.
<LI>If an entry name in a function is of type CHARACTER, each entry name and the name of the function must also be of type
CHARACTER.&nbsp; If the name of the function or the name of any entry point has a length specification of<TT> (*),</TT> then
all such entities must have a length specification of<TT> (*)</TT> otherwise they must all have a length specification of
the same integer value.
<LI>If a dummy argument appears in an executable statement, then that statement can be executed provided that the dummy argument
is in the dummy argument list of the procedure name referenced.
<LI>A name that appears as a dummy argument in an<TT> ENTRY</TT> statement must not appear in the expression of a statement
function unless it is a dummy argument of the statement function, it has appeared in the dummy argument list of a<TT> FUNCTION</TT>
or<TT> SUBROUTINE</TT> statement, or the<TT> ENTRY</TT> statement appears before the statement function statement.
<LI>A name that appears as a dummy argument in an<TT> ENTRY</TT> statement must not appear in an executable statement preceding
the<TT> ENTRY</TT> statement unless it has also appeared in a<TT> FUNCTION</TT>,<TT> SUBROUTINE</TT>, or<TT> ENTRY</TT> statement
that precedes the executable statement.
</OL>
<H2 ID="The_RETURN_Statement"> The RETURN Statement </H2>
<BR>A<TT> RETURN</TT> statement is a way to terminate the execution of a function or subroutine subprogram and return control
to the program unit that referenced it.&nbsp; As an extension to FORTRAN 77, Open Watcom FORTRAN 77 permits the use of the<TT>
RETURN</TT> statement in the main program.&nbsp; A subprogram (or main program) may contain more than one<TT> RETURN</TT>
statement or it may contain no<TT> RETURN</TT> statement.&nbsp; In the latter case, the<TT> END</TT> statement has the same
effect as a<TT> RETURN</TT> statement.
<BR><BR>Execution of a<TT> RETURN</TT> or<TT> END</TT> statement causes all local entities to become undefined except for
the following.
<OL>
<LI>Entities specified in a<TT> SAVE</TT> statement.
<LI>Entities in blank common.
<LI>Initially defined entities that have neither been redefined nor become undefined.
<LI>Entities in a named common block that appears in the subprogram and in a program unit that references the subprogram directly
or indirectly.
</OL>
<H3 ID="RETURN_Statement_in_the_Main_Program_LExtensionR"> RETURN Statement in the Main Program (Extension) </H3>
<BR>The form of a<TT> RETURN</TT> statement in a main program is:
<BR><BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RETURN</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR>When a<TT> RETURN</TT> statement is executed in the main program, program execution terminates in the same manner as the<TT>
STOP</TT> or<TT> END</TT> statement.&nbsp; This is an extension to FORTRAN 77.
<H3 ID="RETURN_Statement_in_Function_Subprograms"> RETURN Statement in Function Subprograms </H3>
<BR>The form of a<TT> RETURN</TT> statement in a function subprogram is:
<BR><BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RETURN</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<BR>When a<TT> RETURN</TT> statement is executed in a function subprogram, the function value must be defined.&nbsp; Control
is then passed back to the program unit that referenced it.
<H3 ID="RETURN_Statement_in_Subroutine_Subprograms"> RETURN Statement in Subroutine Subprograms </H3>
<BR>The form of a<TT> RETURN</TT> statement in a subroutine subprogram is:
<BR><BR> <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RETURN [ e ]</TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; <TT><TT></TT>
<BR> <TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT><TT>
<BR></TT><TT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT></TT>
<DL>
<DT><B><I>where:</I></B>
<DD><B><I> </I></B>
<DT>e
<DD>is an integer expression.
</DL>
<BR>If the expression<TT> e</TT> is omitted or has a value less than one or greater than the number of asterisks appearing
in the dummy argument list of the subroutine or entry name referenced, then control is returned to the next executable statement
that follows the<TT> CALL</TT> statement in the referencing program unit.&nbsp; If 1 &lt;=<TT> e</TT> &lt;=<TT> n</TT> where<TT>
n</TT> is the number of asterisks appearing in the<TT> SUBROUTINE</TT> or<TT> ENTRY</TT> statement which contains the referenced
name, then the expression<TT> e</TT> identifies the<TT> e</TT>th asterisk in the dummy argument list.&nbsp; Control is returned
to the statement identified by the alternate return specified in the<TT> CALL</TT> statement that corresponds to the<TT> e</TT>th
asterisk in the dummy argument list of the referenced subroutine.&nbsp; The following example demonstrates the use of alternate
return specifiers in conjunction with the<TT> RETURN</TT> statement.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REAL X, Y</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ *, X, Y</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALL CMP( X, Y, *10, *20 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'X equals Y'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GOTO 30</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 10&nbsp;&nbsp;&nbsp; PRINT *, 'X less than Y'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GOTO 30</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 20&nbsp;&nbsp;&nbsp; PRINT *, 'X greater than Y'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 30&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SUBROUTINE CMP( X, Y, *, * )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( X .LT. Y )RETURN 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( X .GT. Y )RETURN 2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RETURN</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<H2 ID="Subprogram_Arguments"> Subprogram Arguments </H2>
<BR>Arguments provide a means of communication between program units.&nbsp; Arguments are passed to subprograms through argument
lists and are received by subprograms through argument lists.&nbsp; The argument list used to pass arguments to a subprogram
is called the<B> actual argument list</B> and the arguments are called<B> actual arguments.</B>&nbsp; The argument list of
the receiving subprogram is called the<B> dummy argument list</B> and the arguments are called<B> dummy arguments.</B>&nbsp;
The actual argument list must agree with the dummy argument list in number, order and type.
<H3 ID="Dummy_Arguments"> Dummy Arguments </H3>
<BR>Statement function, external functions and subroutines use dummy arguments to define the type of actual arguments they
expect.&nbsp; A dummy argument is one of the following.
<OL>
<LI>Variable.
<LI>Array.
<LI>Dummy procedure.
<LI>Asterisk<TT> (*)</TT> indicating a statement label.
</OL>
<BR><B>Notes:</B>
<OL>
<LI>A statement function dummy argument may only be a variable.
<LI>An asterisk can only be a dummy argument for a subroutine subprogram.
</OL>
<BR>Dummy arguments that are variables of type INTEGER can be used in dummy array declarators.&nbsp; No dummy argument may
appear in an<TT> EQUIVALENCE</TT>,<TT> DATA</TT>,<TT> PARAMETER</TT>,<TT> SAVE</TT>,<TT> INTRINSIC</TT> or<TT> COMMON</TT>
statement except as a common block name.&nbsp; A dummy argument must not be the same name as the subprogram name specified
in the<TT> FUNCTION</TT>,<TT> SUBROUTINE</TT> or<TT> ENTRY</TT> statement.&nbsp; Other than these restrictions, dummy arguments
can be used in the same way an actual name of the same class would be used.
<H3 ID="Actual_Arguments"> Actual Arguments </H3>
<BR>Actual arguments specify the entities that are to be associated with the dummy arguments when referencing a subroutine
or function.&nbsp; Actual arguments can be any of the following.
<OL>
<LI>Any expression, except character expression involving the concatenation of an operand whose length specification is<TT>
(*)</TT> unless the operand is a symbolic constant.
<LI>An array name.
<LI>An intrinsic function name.
<LI>An external function or subroutine name.
<LI>A dummy procedure name.
<LI>An<B> alternate return specifier</B> of the form<TT> *s</TT> where<TT> s</TT> is a statement number of an executable statement
in the subprogram which contained the<TT> CALL</TT> statement.
</OL>
<BR><B>Notes:</B>
<OL>
<LI>A statement function actual argument can only be a variable or an expression.
<LI>An alternate return specifier can only be an actual argument in the actual argument list of a subroutine reference.
</OL>
<H3 ID="Association_of_Actual_and_Dummy_Arguments"> Association of Actual and Dummy Arguments </H3>
<BR>When a function or subroutine reference is executed, an association is established between the actual arguments and the
corresponding dummy arguments.&nbsp; The first dummy argument is associated with the first actual argument, the second dummy
argument is associated with the second actual argument, etc.&nbsp; Association requires that the types of the actual and dummy
arguments agree.&nbsp; A subroutine has no type and when used as an actual argument must be associated with a dummy procedure.
&nbsp;An alternate return specifier has no type and must be associated with an asterisk.&nbsp; Arguments can be passed through
more than one level of procedure reference.&nbsp; In this case, valid association must exist at all intermediate levels as
well as the last level.&nbsp; Argument association is terminated upon the execution of a<TT> RETURN</TT> or<TT> END</TT> statement.
<H4 ID="Length_of_Character_Actual_and_Dummy_Arguments"> Length of Character Actual and Dummy Arguments </H4>
<BR>If a dummy argument is of type CHARACTER, the corresponding actual argument must also be of type CHARACTER and the length
of the dummy argument must be less than or equal to the length of the actual argument.&nbsp; If the length of the dummy argument
is<TT> len</TT> then the<TT> len</TT> leftmost characters of the actual argument are associated with the dummy argument.
<BR><BR>If a dummy argument of type CHARACTER is an array name, then the restriction on the length is on the whole array and
not for each array element.&nbsp; The length of an array element of the dummy argument may be different from the length of
the array element of the corresponding actual array, array element, or array element substring, but the dummy array argument
must not extend beyond the end of the associated actual array.
<H4 ID="Variables_as_Dummy_Arguments"> Variables as Dummy Arguments </H4>
<BR>A dummy argument that is a variable may be associated with an actual argument that is a variable, array element, substring
or expression.&nbsp; Only if the actual argument is a variable, array element or substring can the corresponding actual argument
be redefined.
<H4 ID="Arrays_as_Dummy_Arguments"> Arrays as Dummy Arguments </H4>
<BR>A dummy argument that is an array may be associated with an actual argument that is an array, array element or array element
substring.&nbsp; The number and size of the dimensions in the actual argument array declarator may be different from the number
and size of the dimensions in the dummy argument array declarator.
<BR><BR>If the actual argument is a non-character array name, then the size of the dummy argument array must not exceed the
size of the actual argument array.&nbsp; An element of the actual array becomes associated with the element in the dummy array
with the same subscript value.&nbsp; Association by array element of character arrays exists only if the lengths of the array
elements are the same.&nbsp; If their lengths are not the same, the dummy and actual array elements will not consist of the
same characters.
<BR><BR>If the actual argument is a non-character array element name whose subscript value is<B> asv</B> the size of the dummy
argument array must not exceed the size of the actual argument array less<B> asv - 1.</B>&nbsp; Furthermore, the dummy argument
array element whose subscript value is<B> dsv</B> becomes associated with the actual argument array element whose subscript
value is<B> asv + dsv - 1.</B>&nbsp; Consider the following example.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DIMENSION A(10)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALL SAM( A(3) )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SUBROUTINE SAM( B )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DIMENSION B(5)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><BR>In the previous example, array<TT> A</TT> is an actual argument and the array<TT> B</TT> is the dummy argument.&nbsp;
Suppose we wanted to know which element of<TT> A</TT> is associated with the 4th element of<TT> B.</TT>&nbsp; Then<B> asv</B>
would have value 3 since the array element<TT> A(3)</TT> is the actual argument, and<B> dsv</B> is 4.&nbsp; Then the 4th element
in<TT> B</TT> is 3 + 4 - 1 = 6th element of A.
<BR><BR>If the actual argument is a character array name, character array element name or character array element substring
which begins at character storage unit<B> ach,</B> then the character storage unit<B> dch</B> of the dummy argument array
is associated with the character storage unit<B> ach + dch - 1</B> of the actual array.&nbsp; The size of the dummy character
array must not exceed the size of the actual argument array.
<H4 ID="Procedures_as_Dummy_Arguments"> Procedures as Dummy Arguments </H4>
<BR>A dummy argument that is a dummy procedure can only be associated with an actual argument that is one of the following.
<OL>
<LI>Intrinsic function.
<LI>External function.
<LI>External Subroutine.
<LI>Another dummy procedure.
</OL>
<BR>If the dummy argument is used as a subroutine (that is it is invoked using a<TT> CALL</TT> statement) then the corresponding
actual argument must either be a subroutine or a dummy procedure.&nbsp; If the dummy argument is used as an external function,
then the corresponding actual argument must be an intrinsic function, external function or dummy procedure.&nbsp; Note that
it may not be possible to determine in a given program unit whether a dummy procedure is associated with a function or subroutine.
&nbsp;In the following example it is not possible to tell by looking at this program unit whether<TT> PROC</TT> is an external
subroutine or function.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SUBROUTINE SAM( PROC )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EXTERNAL PROC</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALL SAM1( PROC )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<H4 ID="Asterisks_as_Dummy_Arguments"> Asterisks as Dummy Arguments </H4>
<BR>A dummy argument that is an asterisk may only appear in the dummy argument list of a<TT> SUBROUTINE</TT> statement or
an<TT> ENTRY</TT> statement in a subroutine subprogram and may be associated only with an actual argument that is an alternate
return specifier in a<TT> CALL</TT> statement which references the subroutine.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*10 RECORD(5)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I = 2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALL SAM( I, *999, 3HSAM )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'I should be skipped'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 999&nbsp;&nbsp; PRINT *, 'I should be printed'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SUBROUTINE SAM( I, *, K)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*3 K</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, K</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RETURN 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</TT>
<H1 ID="Open_Watcom_FORTRAN_77_Extensions_to_Standard_FORTRAN_77"> Open Watcom FORTRAN 77 Extensions to Standard FORTRAN 77 </H1>
<BR><BR>This appendix summarizes the extensions supported by Open Watcom FORTRAN 77.
<OL>
<LI>The<TT> INCLUDE</TT> statement for embedding source from another file is supported.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INCLUDE 'SRC'</TT>
<LI>Symbolic names are unique up to 32 characters.&nbsp; Also, '$', '_', and lowercase letters are allowed in symbolic names.
<LI>Lowercase and uppercase letters are treated in the same way except in:
<OL>
<LI>character and hollerith constants
<LI>apostrophe and H edit descriptors
</OL>
<LI>End-of-line comments are permitted.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, 'Hello world'&nbsp; ! print 'Hello World'</TT>
<LI>The<TT> IMPLICIT NONE</TT> statement is supported.
<LI>An asterisk enclosed in parentheses is allowed with the type<TT> CHARACTER</TT> when specified in an<TT> IMPLICIT</TT>
statement.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IMPLICIT CHARACTER*(*) (Z)</TT>
<LI>Length specifiers are allowed with types specified in<TT> IMPLICIT</TT> statements.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IMPLICIT INTEGER*2 (I-N)</TT>
<LI>Length specifiers are allowed with type specification statements.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOGICAL*1, LOGICAL*4</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER*1, INTEGER*2, INTEGER*4</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REAL*4, REAL*8</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; COMPLEX*8, COMPLEX*16</TT>
<BR><BR>Length specifiers are also allowed with the type specified in<TT> FUNCTION</TT> statements.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; COMPLEX*16 FUNCTION ZADD( X, Y )</TT>
<LI>Length specifiers are allowed with symbol names.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER I*2, A*2(10), B(20)*2</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; COMPLEX FUNCTION ZADD*16( X, Y )</TT>
<LI>The<TT> DOUBLE COMPLEX</TT> statement is supported (equivalent to<TT> COMPLEX*16</TT>).
<LI>Double precision complex constants are allowed.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Z = (1D0, 2D0)</TT>
<LI>Mixing operands of type<TT> DOUBLE PRECISION</TT> and<TT> COMPLEX</TT> to yield a<TT> COMPLEX*16</TT> result is allowed.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DOUBLE PRECISION X</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; COMPLEX Y, Z*16</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Z = X + Y</TT>
<LI>User-defined structures are supported.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STRUCTURE/END STRUCTURE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UNION/END UNION</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MAP/END MAP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RECORD</TT>
<LI>Both character and non-character data are allowed in the same common block.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER X</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER C</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; COMMON /BLK/ X, C</TT>
<LI>Data initialization of variables in common without a block data subprogram is allowed.
<LI>Equivalencing character to non-character data is permitted.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER X</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER C</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EQUIVALENCE (X, C)</TT>
<LI>Single subscripts for multi-dimensional arrays is permitted in<TT> EQUIVALENCE</TT> statements.
<LI>Data initialization in a type specification statement is allowed.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DOUBLE PRECISION X/4.3D1/</TT>
<LI>Data initialization with hexadecimal constants is allowed.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INTEGER I/Z00000007/</TT>
<LI>Initializing character items with numeric data is permitted.
<LI>Hexadecimal and octal constants of the form<TT> 'abc'x</TT> and<TT> '567'o</TT> are supported.
<LI>A character constant of the form<TT> 'abcdef'c</TT> places a NUL character (CHAR(0)) at the end of the character string.
<LI>Hollerith constants can be used interchangeably with character constants.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*10 A, B</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A = '1234567890'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B = 10H123456790</TT>
<LI>Several additional intrinsic functions are supported:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ALGAMA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ALLOCATED&nbsp;&nbsp;&nbsp;&nbsp; BTEST
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CDABS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CDCOS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CDSIN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; CDEXP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CDSQRT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CDLOG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; COTAN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; DCMPLX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DCONJG</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DCOTAN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DERF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; DERFC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DFLOAT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DGAMMA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DIMAG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; DLGAMA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DREAL</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ERF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ERFC&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; GAMMA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HFIX</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; IAND&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IBCHNG&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; IBCLR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IBSET</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; IEOR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IOR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; ISHA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ISHC</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ISHFT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ISHL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; ISIZEOF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LENTRIM</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; LGAMMA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; NOT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VOLATILE</TT>
<LI>The<TT> LOC</TT> intrinsic function returns the address of an expression.
<LI>The<TT> ISIZEOF</TT> intrinsic function returns the size of a structure name, the size of an array with a constant array
declarator, or the size of a variable.
<LI>The<TT> CHAR</TT> intrinsic function is allowed in constant expressions.
<LI>The<TT> ALLOCATE</TT> and<TT> DEALLOCATE</TT> statements may be used to dynamically allocate and deallocate arrays.
<LI>The<TT> ALLOCATED</TT> intrinsic function may be used to determine if an allocatable array is allocated.
<LI>The following additional I/O specifiers for the<TT> OPEN</TT> statement are supported.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ACTION=</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CARRIAGECONTROL=</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; RECORDTYPE=</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; RECL= is also allowed for files opened for</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sequential access</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ACCESS='APPEND'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; BLOCKSIZE=</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SHARE=</TT>
<LI>The following additional I/O specifiers for the<TT> INQUIRE</TT> statement are supported.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ACTION=</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CARRIAGECONTROL=</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; RECORDTYPE=</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; BLOCKSIZE=</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SHARE=</TT>
<LI>In the<TT> INQUIRE</TT> statement, character data may also be returned in variables or array elements with a substring
operation.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER FN*20</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INQUIRE( UNIT=1, FILE=FN(10:20) )</TT>
<LI>List-directed I/O is allowed with internal files.
<LI>No asterisk is required for list-directed I/O.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT, X, Y</TT>
<LI>The<TT> NAMELIST</TT> statement is supported.
<LI>Non-character arrays are allowed as format specifiers.
<LI>The following format edit descriptors are allowed:
<DL>
<DT>Z
<DD>for displaying data in hexadecimal format
<DT>Ew.dDe
<DD>same as Ew.dEe except D is used as exponentiation character
<DT>$ or \
<DD>leave cursor at end of line
</DL>
<LI>A repeat count is not required for the X edit descriptor (a repeat count of one is assumed).
<LI>Commas are optional between format edit descriptors.
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 100&nbsp;&nbsp; FORMAT( 1X I5 )</TT>
<LI>It is possible to substring the return values of functions and statement functions.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHARACTER*7 F, G</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; F() = '1234567'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRINT *, F()(1:3), G()(4:7)</TT>
<LI>Functions may be invoked via the<TT> CALL</TT> statement.&nbsp; This allows the return value of functions to be ignored.
<LI>A<TT> RETURN</TT> statement is allowed in the main program.
<LI>Integer constants with more than 5 digits are allowed in the<TT> STOP</TT> and<TT> PAUSE</TT> statements.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PAUSE 123456</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STOP 123456</TT>
<LI>Multiple assignment is allowed.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X = Y = Z = 0.0</TT>
<LI>The<TT> .XOR.</TT>&nbsp; operator is supported (equivalent to<TT> .NEQV.</TT>).
<LI>The<TT> .AND.</TT>,<TT> .OR.</TT>,<TT> .NEQV.</TT>,<TT> .EQV.</TT>&nbsp; and<TT> .XOR.</TT>&nbsp; operators may take integer
arguments.&nbsp; They can be used to perform bit operations on integers.
<LI>Several additional program structure control statements are supported:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOOP-ENDLOOP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UNTIL (can be used with WHILE and LOOP)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WHILE-ENDWILE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GUESS-ADMIT-ENDGUESS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ATENDDO-ENDATEND</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ATEND</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SELECT-ENDSELECT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DOWHILE-ENDDO</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO-ENDDO (no statement number)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REMOTEBLOCK-ENDBLOCK</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EXECUTE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; QUIT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EXIT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CYCLE</TT>
<LI>Block labels can be used to identify blocks of code.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOOP : OUTER_LOOP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;statements&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOOP : INNER_LOOP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;statements&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF( X
.GT.100 ) QUIT : OUTER_LOOP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;statements&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDLOOP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;statements&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDLOOP</TT>
<LI>An integer expression in an<TT> IF</TT>,<TT> ELSE IF</TT>,<TT> DO WHILE</TT>,<TT> WHILE</TT> or<TT> UNTIL</TT> statement
is allowed.&nbsp; The result of the integer expression is compared for inequality to the integer value 0.
</OL>
</BODY>
