<HEAD>
<TITLE> Open Watcom 2.0 Developer's Guide </TITLE>
</HEAD>
<BODY>
<H1 ID="Index_of_Topics"> Index of Topics </H1>
<DL>
<DT>- 3 -
<DD><A HREF="#32Mbit_Windows_runMtime_DLLs">32-bit Windows run-time DLLs</A>
<DT>- B -
<DD><A HREF="#The_bld_directory">The bld directory</A>
<BR><A HREF="#Build_Architecture">Build Architecture</A>
<BR><A HREF="#Build_Process">Build Process</A>
<BR><A HREF="#Builder">Builder</A>
<BR><A HREF="#Building_Online_Help_Documentation">Building Online Help Documentation</A>
<BR><A HREF="#Building_PostScript_Documentation">Building PostScript Documentation</A>
<DT>- C -
<DD><A HREF="#The_Clean_Target">The Clean Target</A>
<BR><A HREF="#Connecting_up">Connecting up</A>
<DT>- D -
<DD><A HREF="#Diagnostic_Messages">Diagnostic Messages</A>
<BR><A HREF="#DLLs_and_Windowed_Apps">DLLs and Windowed Apps</A>
<DT>- E -
<DD><A HREF="#Editing_the_Documentation">Editing the Documentation</A>
<BR><A HREF="#Executive_Summary">Executive Summary</A>
<DT>- F -
<DD><A HREF="#First_Steps">First Steps</A>
<DT>- G -
<DD><A HREF="#Gearing_up_for_Building">Gearing up for Building</A>
<BR><A HREF="#Guided_Tour">Guided Tour</A>
<DT>- H -
<DD><A HREF="#Help_the_compiler_and_it_will_help_you">Help the compiler and it will help you</A>
<BR><A HREF="#History">History</A>
<DT>- I -
<DD><A HREF="#Include_Paths">Include Paths</A>
<DT>- M -
<DD><A HREF="#Makefiles">Makefiles</A>
<BR><A HREF="#Makeinit">Makeinit</A>
<BR><A HREF="#Memory_Trackers">Memory Trackers</A>
<BR><A HREF="#Misc_Conventions">Misc Conventions</A>
<DT>- P -
<DD><A HREF="#Pmake">Pmake</A>
<BR><A HREF="#Pmake_Support">Pmake Support</A>
<BR><A HREF="#Producing_Documentation">Producing Documentation</A>
<BR><A HREF="#Programming_Style">Programming Style</A>
<BR><A HREF="#Project_Names">Project Names</A>
<BR><A HREF="#Project_Overview">Project Overview</A>
<DT>- R -
<DD><A HREF="#Requirements_To_Build">Requirements To Build</A>
<BR><A HREF="#Running_the_tests">Running the tests</A>
<BR><A HREF="#The_Runtime_DLL_Libraries">The Runtime DLL Libraries</A>
<DT>- S -
<DD><A HREF="#Setting_up">Setting up</A>
<BR><A HREF="#Source_file_structure">Source file structure</A>
<DT>- T -
<DD><A HREF="#Testing">Testing</A>
</DL>
<H1 ID="Project_Overview"> Project Overview </H1>
<BR>This document serves as an introduction and a guide for developers of the Open Watcom compilers and tools.&nbsp; It is
not particularly useful for the users (who are also developers) of Open Watcom compilers - they are encouraged to read the
User's Guide, Programmer's Guide, C Language Reference and other user oriented books.
<BR>It should not be assumed that this book is in any way final or the ultimate reference.&nbsp; Readers are encouraged to
add, change and modify this document to better reflect evolution of the Open Watcom project.
<H2 ID="History"> History </H2>
<BR>The history of the Open Watcom project is rather long, in terms of Interned years it would probably span millennia.&nbsp;
The origins can be traced back to 1965.&nbsp; That summer a team of undergraduate students at the University of Waterloo develped
a FORTRAN compiler (called WATFOR) that ran on the University's IBM 7040 systems.&nbsp; The compiler was soon ported to IBM
360 and later to the famous DEC PDP-11.
<BR><BR>In early 1980s a brand new version of the compiler was created that supported the FORTRAN 77 language.&nbsp; It ran
on two platforms, the IBM 370 and the emerging IBM PC.&nbsp; The PC version of WATFOR-77 was finished in 1985 and in the same
year support for Japanese was added.&nbsp; In 1986, WATFOR-77 was ported to the QNX operating system.
<BR><BR>The early compilers were written in a portable language called WSL or Watcom Systems Language.&nbsp; In late 1980s
the developers rewrote the existing code in C and from then on all new developments were done on C, later with traces of C++
here and there.
<BR><BR>In parallel to the FORTRAN compilers Watcom developed optimizing C compilers.&nbsp; When the first PC version (Watcom
C 6.0) was introduced in 1987, it immediately attracted attention by producing faster code than other compilers available
at that time.
<BR><BR>In 1988 work started on an advanced highly optimizing code generator that supported both the C language and FORTRAN
and was portable across multiple platforms.&nbsp; Generation of tight code, availability on multiple platforms (DOS, Windows,
OS/2 and Windows NT in one package) and the ability to cross-compile made Watcom C and C++ compilers quite popular in mid-1990s.
&nbsp;Around 1993-1996, nearly all DOS games were developed with Watcom C, including famous titles such as DOOM, Descent or
Duke Nukem 3D.
<BR><BR>Watcom International, Inc.&nbsp; had other successful products besides its highly acclaimed compilers.&nbsp; VX-REXX
was a popular GUI RAD tool for OS/2 and Watcom SQL was a cross-platform &quot;embeddable&quot; SQL database.
<BR><BR>In mid-1990s, Watcom International, Inc.&nbsp; was acquired by PowerSoft, the maker of Power++, PowerDesigner and
other GUI RAD tools for the Windows platform.&nbsp; PowerSoft used Watcom compiler technology as a back-end for their GUI
tools besides continuing to market and develop existing Watcom tools.
<BR><BR>PowerSoft itself had merged with Sybase, Inc.&nbsp; in 1994.&nbsp; PowerSoft's development tools nicely complemented
Sybase's database servers.&nbsp; Sybase was also interested in Watcom SQL which was enhanced and turned into Sybase SQL Anywhere.
<BR><BR>Sybase continued to sell Watcom C/C++ and FORTRAN compilers version 11 but it was obvious that Sybase couldn't compete
with Microsoft in the languages market.&nbsp; Sybase decided to end-of-life the Watcom compilers effective 2000.
<BR><BR>But that's not the end of the story.&nbsp; Many customers did not want to give up the Watcom compilers because there
was no suitable replacement in many areas.&nbsp; One of these customers was Kendall Bennett of SciTech Software, Inc.&nbsp;
SciTech entered into negotiations with Sybase and in an unprecedented move, Sybase agreed upon open sourcing the Watcom compilers
and tools.&nbsp; One of the reasons why this was possible at all was the fact that Watcom had very little reliance on third-party
tools and source code and had developed practically everything in-house, from YACC to IDE.
<BR><BR>The process of opening the source was longer than originally anticipated (all software related projects tend to work
out this way for some inexplicable reason) but in the first half of 2002, the source was finally made available under the
Sybase Open Watcom Public License version 1.0.
<H2 ID="Guided_Tour"> Guided Tour </H2>
<BR>This section will take you on a guided tour of the Open Watcom source tree, presenting an overview of its structure and
highlighting some of the more memorable sights.
<BR><BR>The Open Watcom directory structure mostly mirrors the layout used by the Watcom/Sybase build server but it has been
cleaned up, straightened out and unified, although there still may be some warts.
<BR><BR>The root of the Open Watcom directory tree can be in the root of any drive (if your OS uses drive letters) or in any
directory, for instance<TT> e:\ow.</TT>&nbsp; Long filenames are not recommended if compatibility with DOS tools is desired.
&nbsp;Directory names which include spaces are highly discouraged in any case.
<BR><BR>The main subdirectories in the Open Watcom root are the following:
<DL>
<DT>build
<DD>contains main builder control files and other useful files.&nbsp; One extremely important file lives here:<B>&nbsp; makeinit.</B>
&nbsp;This file controls the operation of wmake and is the key to understanding of the build process.&nbsp; Since wmake looks
for<B> makeinit</B> along the<TT> PATH,</TT> the<B> build</B> directory should be placed at or near the start of your<TT>
PATH</TT> environment variable.
<DT>build/bin
<DD>contains binaries created during first build phase (bootstrap) and used during main building process (second build phase).
<DT>build/mif
<DD>contains all main make files (global).
<DT>bld
<DD>is<B> the</B> directory where it's at.&nbsp; It contains all the Open Watcom source code.&nbsp; It is so important (and huge)
that it deserves its own section.
<DT>docs
<DD>contains source files for the Open Watcom documentation as well as binaries needed to translate the sources into PostScript,
HTML or various online help formats.&nbsp; The source files of this document are stored under this directory.&nbsp; For more
information please refer the the chapter entitled Documentation later in this manual.
<DT>rel
<DD>is the &quot;release&quot; directory is where the binaries and other files produced in the course of the build process end
up.&nbsp; The structure of this directory mirrors the<B> WATCOM</B> directory of a typical Open Watcom installation.
</DL>
<H2 ID="The_bld_directory"> The bld directory </H2>
<BR>Following is a brief description of all subdirectories of bld.&nbsp; Each subdirectory roughly corresponds to one &quot;project&quot;.
&nbsp;There's a lot of projects!
<DL>
<DT>as
<DD>the Alpha AXP and PowerPC assembler.&nbsp; The x86 assembler lives separately.
<DT>aui
<DD>user interface library employed by the debugger and profiler.
<DT>bdiff
<DD>binary diff and patch utilities.
<DT>bmp2eps
<DD>a utility for converting Windows bitmap files into EPS format, used for building documentation.
<DT>brinfo
<DD>part of the C++ source browser.
<DT>browser
<DD>the GUI C++ source browser.
<DT>builder
<DD>builder tool controlled by those<B> builder.ctl</B> files that are all over the place.
<DT>causeway
<DD>the popular CauseWay DOS extender, in a form buildable with Open Watcom tools.
<DT>cc
<DD>the C compiler front end.
<DT>cfloat
<DD>utility function for conversion between various floating point binary formats.
<DT>cg
<DD>Open Watcom code generators, the heart of the compilers.&nbsp; These are shared by all languages (C, C++, FORTRAN).&nbsp;
Currently supported targets are 16-bit and 32-bit x86 as well as Alpha AXP.
<DT>clib
<DD>the C runtime library.&nbsp; Pretty big project in itself.
<DT>cmdedit
<DD>command line editing utilities, pretty much obsolete.
<DT>comp_cfg
<DD>compiler configuration header files for various targets.
<DT>cpp
<DD>a simple C style preprocessor used by several other projects.
<DT>ctest
<DD>C compiler regression tests.&nbsp; Run them often.
<DT>cvpack
<DD>the CV pack utility (for CodeView style debugging information).
<DT>diff
<DD>Open Watcom version of the popular utility.
<DT>dig
<DD>files used primarily by the debugger - this directory contains files that are shared between debugger, profiler, trap files
and Dr.&nbsp; Watcom.
<DT>dip
<DD>Debug Information Processors, used by debugger.&nbsp; The DIPs provide an interface between the debugger and various debug
information formats.
<DT>dmpobj
<DD>a simple OMF dump utility.
<DT>dwarf
<DD>library for reading and writing DWARF style debugging information.
<DT>editdll
<DD>interface modules between the IDE and external editors.
<DT>fpuemu
<DD>8087 and 80387 emulator library.
<DT>f77
<DD>FORTRAN 77 compiler front end, runtime library and samples.&nbsp; All the FORTRAN stuff is crowded in there.
<DT>f77test
<DD>FORTRAN 77 compiler regression tests.
<DT>fe_misc
<DD>miscellaneous compiler front-end stuff shared between projects.
<DT>fmedit
<DD>form edit library, part of the SDK tools.
<DT>graphlib
<DD>Open Watcom graphics library for DOS.
<DT>gui
<DD>GUI library used by IDE, debugger, source browser and other tools.
<DT>hdr
<DD>source files of header files distributed with the compilers.
<DT>help
<DD>character mode help viewer (WHELP).
<DT>ide
<DD>the Open Watcom IDE.
<DT>idebatch
<DD>batch processor for the IDE.
<DT>idedemo
<DD>IDE demo program.
<DT>lib_misc
<DD>miscellaneous files shared between clib and other tools.
<DT>mad
<DD>Machine Architecture Description used by debugger.
<DT>mathlib
<DD>the math library.
<DT>misc
<DD>stuff that didn't fit anywhere else.&nbsp; Not much really.
<DT>mstools
<DD>Microsoft clone tools, front ends for compilers and utilities.
<DT>ncurses
<DD>a version of the ncurses library used by Linux console tools.
<DT>ndisasm
<DD>the disassembler supporting variety of file format and instruction sets.&nbsp; Very handy.
<DT>nwlib
<DD>the library manager.
<DT>online
<DD>place for finished online help files and associated header files.
<DT>orl
<DD>Object Reader Library, reads OMF, COFF and ELF object files.
<DT>os2api
<DD>headers and libraries for the OS/2 API (both 16-bit and 32-bit).
<DT>owl
<DD>Object Writer Library, brother of ORL.
<DT>pgchart
<DD>presentation graphics and chart library for DOS (part of the graph library).
<DT>plusplus
<DD>another huge directory containing all C++ stuff.&nbsp; Compiler, runtime libraries, all that.
<DT>plustest
<DD>C++ regression test utilities.&nbsp; Extremely worthy of the attention of compiler developers.
<DT>pmake
<DD>parallel make, tool used in the build process to roughly control what gets built.
<DT>posix
<DD>a bunch of POSIX utilites like cp, rm and so on.&nbsp; Not suffering from creeping featuritis but they do the job and they're
portable.
<DT>rcsdll
<DD>interface to various revision control systems, used by IDE and editor.
<DT>re2c
<DD>regular expression to C converter, used in C++ compiler build.
<DT>redist
<DD>miscellaneous redistributable files.
<DT>rtdll
<DD>C, C++ and math runtime DLLs.
<DT>sdk
<DD>SDK tools like resource editor, resource compiler or dialog editor.&nbsp; Also the home of wres library which is used by many
other projects.
<DT>setupgui
<DD>source for the Open Watcom installer.
<DT>src
<DD>sample source code distributed with the compiler, some of it is used in the documentation.
<DT>ssl
<DD>internal tool used for debugger builds.
<DT>techinfo
<DD>ancient system information utility.
<DT>trap
<DD>trap files (both local and remote), the heart of the debugger containing platform specific debugging code.&nbsp; Heavy stuff.
<DT>trmem
<DD>memory tracker library (good for discovering and plugging memory leaks).
<DT>ui
<DD>user interface library.
<DT>vi
<DD>Open Watcom vi editor, clone of the popular (or not) Unix editor.
<DT>w16api
<DD>headers and libraries for the Windows 3.x API.
<DT>w32api
<DD>headers and libraries for the Win32 API.
<DT>w32loadr
<DD>loaders for OS independent (OSI) binaries.
<DT>wasm
<DD>the x86 assembler.&nbsp; Large parts of the source are shared between standalone wasm and inline assembler support for compilers
targeting x86 platforms.
<DT>wasmtest
<DD>the x86 assembler regression tests.
<DT>watcom
<DD>contains internal headers and libraries shared by many projects.
<DT>wclass
<DD>an Open Watcom C++ class library.
<DT>wdisasm
<DD>old x86 disassembler, nearly obsolete.
<DT>whpcvt
<DD>Watcom Help Converter used for producing online documentation.
<DT>wic
<DD>utility for converting include files between various languages.
<DT>win386
<DD>the Windows 386 extender.
<DT>wl
<DD>the Open Watcom linker, also contains the overlay manager library.
<DT>wmake
<DD>the make utility.
<DT>womp
<DD>Watcom Object Module Processor, primarily for conversion between debug info formats.&nbsp; Some source files are shared with
other projects.
<DT>wpack
<DD>simple file compression/decompression utility.
<DT>wpi
<DD>macros and helper functions for facilitating development of Windows and OS/2 GUI programs from single source code.
<DT>wprof
<DD>the Open Watcom profiler.
<DT>wsample
<DD>the execution sampler, companion tool to the profiler.
<DT>wstrip
<DD>strip utility for detaching or attaching debug information and/or resources.
<DT>wstub
<DD>stub program for DOS/4GW.
<DT>wtouch
<DD>a touch utility.
<DT>wv
<DD>the debugger (used to be called WVIDEO, hence the name).
<DT>yacc
<DD>Watcom's version of YACC used for building compilers/assemblers.
</DL>
<BR>As you can see, there's a lot of stuff!&nbsp; Some of these projects contain specific documentation pertaining to them,
usually located in a directory called 'doc' or somesuch.&nbsp; For the most part, the truly uptodate and comprehensive documentation
is the source code.
<H1 ID="First_Steps"> First Steps </H1>
<BR>This chapter briefly describes the prerequisite steps necessary to build and/or contribute to the Open Watcom project
- how to get the source code and how to set up the build environment.
<H2 ID="Connecting_up"> Connecting up </H2>
<BR>The most uptodate version of the Open Watcom source code lives on the Open Watcom Perforce server.&nbsp; It is possible
to go straight to the Perforce repository but most people will find it much easier to get a source archive first.&nbsp; The
source archives can be found at the Open Watcom web site,<TT> http://www.openwatcom.org/</TT> along with latest information
on Perforce setup.&nbsp; You will generally need a working installation of the previous release of Open Watcom C/C++ and some
free disk space to burn (one gigabyte should do).
<BR><BR>The Open Watcom source tree can be located in any directory on any drive.&nbsp; After extracting the source archive
you will find a very important batch file called<B> setvars</B> in your Open Watcom root directory.&nbsp; This will set up
a bunch of necessary environment variables but first you'll have to edit it to reflect your directory structure etc.&nbsp;
It also contains the necessary Perforce settings.
<BR><BR>Now is the time to connect to Perforce.&nbsp; Again, most uptodate information can be found on the Open Watcom web
site.&nbsp; If you followed the instructions correctly, no servers are down and no other unpredictable (or maybe predictable)
things happened, you will have brought your source tree to the latest revision (aka tip or head revision).
<H2 ID="Gearing_up_for_Building"> Gearing up for Building </H2>
<BR>Before you start building the Open Watcom tools proper, you will need to build several helper tools:<B>&nbsp; builder,
pmake, cdsay</B> and a few others.&nbsp; These tools have to be built manually because the build process won't work without
them.
<BR><BR>The tools can be found in appropriately named subdirectory of the<B> bld</B> directory, which is named<B> builder</B>
(showing complete lack of imagination).
<BR><BR>To build the required executables, go to a subdirectory of the project<B> builder</B> directory which sounds like
it would be appropriate for your host platform and run<B> wmake.</B>&nbsp; If you set up everything correctly, you will end
up with working binaries that were automatically copied into the right subdirectory of the<B> build</B> directory, and that
directory is already on the<TT> PATH.</TT>&nbsp; If not, it's back to square one - the most likely source of problems is incorrectly
set up<B> setvars</B> batch file.
<BR><BR>If you've got this far - congratulations, you've finished the one-time steps.&nbsp; You shouldn't need to redo them
unless you decide to start from scratch, your harddrive decides to die or some similarly catastrophic event occurs.
<BR><BR>You should now read the next chapter that describes the build architecture and also lists the magic incantations necessary
to invoke builds.
<H1 ID="Build_Architecture"> Build Architecture </H1>
<BR>In an effort to clean up the build process, make it easier for projects to compile on various people's machines and allow
for easier ports to other architectures, every project which is developed under the Open Watcom Project should follow certain
conventions as far as makefile layout is concerned.&nbsp; This section describes the conventions and requirements for these
makefiles, as well as the steps needed to get projects to compile.
<BR>For those who do not desire a lecture on the preparation and maintenance of makefiles, feel free to skip straight to the
Executive Summary at the end.
<BR><BR>Every development and build machine must have the mif project (<B> build\mif</B> ) installed.&nbsp; That is taken
care of by uncompressing the Open Watcom source archive and/or syncing up with Perforce.
<H2 ID="Makeinit"> Makeinit </H2>
<BR>All the magic starts with<B> makeinit.</B>&nbsp; Every development machine must have a<B> makeinit</B> file with the following
defined therein:
<DL>
<DT>mif_dir:
<DD>must point to the directory in which the mif project has been installed
</DL>
<BR>For each project with name X you wish to have on the build machine,<TT> X_dir</TT> must be set to the directory containing
the project.&nbsp; That is, if you want the code generator on your machine (and who wouldn't?), it is officially named cg
(see Project Names below) and so you would define<TT> cg_dir.</TT>
<BR>Alternatively, if all of your projects are in directories which correspond to their project names under a common directory,
you can set dev_dir and<B> !include cdirs.mif</B> in your<B> makeinit.</B>&nbsp; This is the recommended setup and default
for Open Watcom.&nbsp; You do not have to take any extra action to use it.
<BR><BR>Alternatively, you can do the above and then redefine<TT> X_dir</TT> for any projects which are not under the<TT>
dev_dir.</TT>
<H2 ID="Project_Names"> Project Names </H2>
<BR>Each project must be given a unique name, which should also be a valid directory name under FAT file systems (8.3 convention).
<H2 ID="Makefiles"> Makefiles </H2>
<BR>Each makefile should be located in the object file directory - ie.&nbsp; no more of this silly cd'ing into the object
directory based on crystal-balls and what not.&nbsp; The makefile must define the following:
<DL>
<DT>host_os:
<DD>os which the resulting executable code will run on
<DT>host_cpu:
<DD>architecture which the resulting executable code will run on.
<DT>proj_name:
<DD>the project name
</DL>
<BR>Valid values for<TT> host_cpu</TT> are 386, i86, axp, mps, ppc, x64.&nbsp; These should be self-explanatory.&nbsp; Valid
values for<TT> host_os</TT> are dos, nt, os2, nov, qnx, win, osi, linux.&nbsp; These should be self-explanatory for the most
part, with one possible exception:&nbsp; osi stands for OS Independent, the executables can run on multiple OSes if appropriate
loader stub is provided.
<BR><BR>The makefile must then include<B> cproj.mif.</B>&nbsp; This will define all sorts of make variables, which can then
be used to build the project.&nbsp; A list of the most important of these variables and what they can be used for is included
below.
<BR><BR>A makefile should also include<B> defrule.mif,</B> which has the default build rules for C, C++ and assembly sources,
and<B> deftarg.mif,</B> for definition of the required clean target.
<BR><BR>A makefile is free to override these defaults as long as it follows the following conventions:
<OL>
<LI>Tools which have macros defined for them must be referred to by the macros - these are currently (any additions should
be brought to my attention):
<DL>
<DT>$(CC):
<DD>The C compiler
<DT>$(CPP):
<DD>The C++ compiler
<DT>$(LINKER):
<DD>The linker
<DT>$(LIBRARIAN):
<DD>The librarian
<DT>$(AS):
<DD>The assembler, if applicable
<DT>$(RC):
<DD>The resource compiler
<DT>$(EDIT):
<DD>Our VI editor
<DT>$(YACC):
<DD>Our version of yacc
<DT>$(RE2C):
<DD>The regular-expression to C compiler
</DL>
<LI>When referring to other projects, a makefile should use the<TT> X_dir</TT> macro, where X is the name of the project.
</OL>
<H2 ID="Requirements_To_Build"> Requirements To Build </H2>
<BR>A project should be able to build either a -d2 (if<TT> $(proj_name)_release</TT> != 1) or releaseable (if<TT> $(proj_name)_release</TT>
== 1 ) executable providing the following are done:
<UL>
<LI>the project is uptodate and<TT> $(proj_name)_dir</TT> is set correctly
<LI>the mif project is uptodate and make knows to look for .mif files in there
<LI>all depended upon projects are uptodate and have<TT> $(proj_name)_dir</TT> set correctly
<LI>all depended upon projects have been built
<LI>any required executables from under<B> build/bin</B> are in the path
</UL>
<BR>Note that there are no other requirements here - it is very annoying when a project requires you to define handles for
tools, create directories in which it can deposit stuff, scrounge up obscure tools from who knows where or pretend to be Jim
Welch in order to get a debuggable version of the executable.
<BR><BR>There is more than one way to switch between development and release build.&nbsp; A<TT> OWDEBUGBUILD</TT> environment
variable provides global control.&nbsp; When set to 1, debug builds are produced, otherwise release builds are created.&nbsp;
When building individual projects with wmake, it is also possible to give the<B> release</B> macro on the wmake command line
(0 means debug build, 1 means release build).
<BR><BR>Perhaps it should be noted that &quot;releasable&quot; build still contains debugging information, but only at the
-d1 level and in a separate .sym file.&nbsp; In case of crashes or other highly unusual behaviour, release build should be
enough to point you in the right direction but usually not sufficient to fully diagnose and rectify the problem.
<BR><BR>Now, if you wish to allow certain abberant behaviours based upon cryptic make variables, that is fine, as long as
the project can build both a debuggable (ie full -d2) version as well as a release (ie no -d2, -d1 only and no memory tracker)
version without these things being set.&nbsp; That is, if you want stupid stuff in your<B> makeinit</B> - fine, but don't
require others to do this in order to build the project.
<BR><BR>Any non-standard makefile variables which you do use should be prepended by the name of your project and an underscore,
to prevent namespace clutter and clashes.
<BR><BR>Tools required to build are an issue that will have to be handled on a case-by-case basis.&nbsp; For example, stuff
to bind up DOS protected mode apps will likely be added to the standard suite of tools available, and macros made for them.
&nbsp;Before we do this, we should standardize on one extender and use it wherever possible.&nbsp; Any small special purpose
tools should be checked in along with the project and built as part of the build process (so that we don't have to check in
zillions of binaries for all supported platforms).&nbsp; An important future consideration will be the ability to build on
a different architecture.&nbsp; Please try and avoid weirdo tools that have no hope of running on an Alpha or PPC running
NT or on Linux.&nbsp; These tools should be referenced from the makefile as<TT> $(bld_dir)\tool.</TT>&nbsp; If your tool cannot
run under a particular OS, you should at least put a batchfile in that bin which echoes a message to that effect (to alert
people to the fact that you've just made their life difficult).&nbsp; More general tools (yacc, re2c, w32bind) that are likely
to be used by several projects should be copied up into the build/bin directory.
<H2 ID="The_Runtime_DLL_Libraries"> The Runtime DLL Libraries </H2>
<BR>If you set<TT> $(proj_name)_rtdll</TT> = 1, the -br switch should be thrown for you automatically, providing the target
os supports it.
<H2 ID="Memory_Trackers"> Memory Trackers </H2>
<BR>The memory tracker is an useful development aid - it tracks all dynamic memory allocations and deallocations, making it
easy to spot memory leaks and helping to pinpoint heap corruption or other unsociable behaviour that so rarely happens in
our code.
<BR><BR>If the memory tracker is an optional part of your project, and independant of the release mode, it is suggested that
you enable it if<TT> $(proj_name)_trmem</TT> is set to 1, and disable it otherwise.
<BR><BR>The source to the memory tracker can be found in<B> bld\trmem.</B>
<H2 ID="The_Clean_Target"> The Clean Target </H2>
<BR>Each makefile should support a clean target.&nbsp; This should not be part of the default target list, and should delete
every makefile generated file.&nbsp; Which means that after running &quot;wmake clean&quot;, the directory should look exactly
like a new installation of the project on a bare drive.&nbsp; !including<B> deftarg.mif</B> should do for most people who
do not get creative with file extensions or generated source files.&nbsp; If you do get creative, you may still use the default
clean rule if you define the<TT> additional_cleanup</TT> macro that will identify your fancy file names and/or extensions.
<BR><BR>Do not underestimate the importance of proper cleanup.&nbsp; It guarantees that every part of a project can be built
from scratch, ensuring that there will be no nasty surprises when stuff breaks for people after a clean install just because
you had a generated file hanging around and never discovered that it can no longer be made.
<H2 ID="Pmake_Support"> Pmake Support </H2>
<BR>Every makefile should contain a pmake line at the top.&nbsp; Pmake is a tool which was invented in order to make life
easier with the clib project - most people are not interested in building all 40+ versions of the clib when they're working
on just one version.&nbsp; Pmake, when run from a root directory, crawls down all subdirectories looking for files called<B>
makefile.</B>&nbsp; When it finds one, it checks to see if there is a wmake comment which looks like:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pmake: &lt;some identifiers&gt;</TT>
<BR><BR>If there is such a comment, and any identifiers in the list given to pmake appear in the list after the colon, then
wmake is invoked in that directory.&nbsp; This provides a handy way to control selective builds and destroys.&nbsp; Some tokens
which should be used by the appropriate makefiles are:
<DL>
<DT>all
<DD>is implicit in every makefile and does not need to be listed explicitly
<DT>build
<DD>indicates that wmake should be run in this directory as part of the build process
<DT>os_x
<DD>for each x in the list of the valid host_os tokens (os_nt, os_dos, etc)
<DT>cpu_x
<DD>for each x in the list of the valid host_cpu tokens (cpu_386, cpu_ppc, etc)
<DT>target_x
<DD>for each x in the list of valid host_cpu tokens (for compilers and targetted apps)
<DT>tiny, small, compact, medium, large, huge, flat, nomodel
<DD>the memory model
<DT>inline, calls
<DD>whether an app uses inline 8087 stuff or fp calls
</DL>
<BR>For example, an executable which is going to run on the PPC version of NT should have a pmake line which contains, at
a minimum:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pmake: build os_nt cpu_ppc</TT>
<BR><BR>Pmake also supports the concept of priority.&nbsp; The priority is specified as /nnn after the #pmake but before the
colon (:) like so:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pmake/50: build os_nt cpu_ppc</TT>
<BR><BR>Makefiles with lower priority are visited first.&nbsp; The default priority if not explicitly specified is 100.&nbsp;
Pmake will visit subdirectories in depth first traversal order unless changed by the<B> -r</B> option or the<B> priority</B>
value.
<BR><BR>You are free to add as many mnemonic identifiers as you want, of course, but anything which you feel is an abstract
classification that would apply to other projects, please bring to our collective attention and if deemed useful, it will
get added to the appropriate places (and the list above).
<BR><BR>For an example of where this is useful, if we suddenly found out that our NT headers were bogus and everything including
them needed a recompile, we could do the following on the build machine:&nbsp; &quot;pmake os_nt -h clean &amp; pmake os_nt
-h&quot;.
<BR><BR>Another very useful property of this setup is that it allows people to build libraries/binaries only for their host
platform.&nbsp; This is especially convenient if they don't have all the necessary SDKs, Toolkits and whatnot installed and/or
cannot run some or all of the platform specific tools required during builds.&nbsp; And this situation is the norm rather
than exception - only dedicated build servers usually have all necessary files in place.
<H2 ID="Misc_Conventions"> Misc Conventions </H2>
<BR>To make it easy to see what projects are required to make a given project, all needed projects should be listed in a makefile
comment in the main makefile of the dependant project.&nbsp; Hopefully, this main makefile should be called<B> master.mif</B>
and be in the root directory, or a mif subdirectory thereof, of the project.
<BR><BR>Also, it is suggested that the object file directory name be a combination of the<TT> host_os</TT> followed by the<TT>
host_cpu,</TT> if convenient.&nbsp; For example, NT versions for the PPC should be genned into a ntppc directory.&nbsp; If
a directory structure which is different than this is used for some reason, then comments explaining exactly what is built
where would be nice in the<B> master.mif</B> file.
<BR><BR>Things get more interesting if cross compilers are thrown into the mix.&nbsp; In that case three components are required
in the name:&nbsp; for instance a<B> ntaxp.386</B> directory can hold the Alpha AXP NT compiler producing 386 code.
<BR><BR>This is also why the macro names are somewhat counterintuitive - most people would think of the<TT> host_os</TT> and<TT>
host_cpu,</TT> as target OS and CPU.&nbsp; However, the 'target' designation is reserved for the target architecture of the
generated binary.&nbsp; In the above case of a compiler that runs on Alpha AXP NT and produces 386 code, the makefile contains:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; host_os&nbsp;&nbsp;&nbsp; = nt</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; host_cpu&nbsp;&nbsp; = axp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; target_cpu = 386</TT>
<H2 ID="DLLs_and_Windowed_Apps"> DLLs and Windowed Apps </H2>
<BR>Set<TT> host_os</TT> and<TT> host_cpu</TT> as normal, and then, if creating a windowed app, set<TT> sys_windowed</TT>
= 1.&nbsp; If creating a DLL, set<TT> sys_dll</TT> = 1.&nbsp; Delightfully simple.
<H2 ID="Include_Paths"> Include Paths </H2>
<BR>The<TT> inc_path</TT> macro is composed of several other variables.&nbsp; Projects are able to hook any of these variables
by redefining them after<B> cproj.mif</B> is included.&nbsp; The current structure looks like this:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; inc_path&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = inc_dirs | inc_dirs_$(host_os) | inc_dirs_sys</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; inc_dirs_sys&nbsp; = inc_dirs_lang | inc_dirs_sys_$(host_os)</TT>
<BR><BR>$(inc_dirs_lang) contains headers delivered with the compiler.
<BR><BR>$(inc_dirs_sys_$(host_os)) contains OS specific headers typically delivered by OS vendor.
<BR><BR>So, a project should put any include directories it needs into<B> inc_dirs</B> - note that this does not include<TT>
$(watcom_dir)\h</TT> which is part of the default include directory set.
<BR><BR>If it needs to, a project can override any and all of these - for instance, the clib needs to be built with the next
release header files, and so would redefine<TT> inc_dirs_lang.</TT>
<BR><BR>Any OS-specific header files needed by the project can be set in<TT> inc_dirs_$(host_os)</TT> - again, this should
not include the standard system header files, which will be defined in<TT> inc_dirs_sys_$(host_os).</TT>
<BR><BR>Note that the build system previously used to set the<TT> INCLUDE</TT> environment variable to hold the contents of<B>
inc_dirs</B> macro.&nbsp; This mechanism is now considered obsolete and should no longer used.&nbsp; Instead, include paths
are passed directly on the command line.&nbsp; This also means that all include paths must be prepended with a -I switch,
for example:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; inc_dirs_sys_nt&nbsp;&nbsp;&nbsp; = -I$(lang_root)\h\nt</TT>
<H2 ID="Executive_Summary"> Executive Summary </H2>
<BR>In order to convert a project to this new structure or create a new (and conforming) project, do the following:
<OL>
<LI>Create an object file directory for each combination of host_os/host_cpu under your project.
<LI>Give your project a name, for instance Foo.
<LI>Create a<B> master.mif</B> in the root of your project.
<LI>Put all the normal makefile gear in this<B> master.mif.</B>
<LI>Add<TT> proj_name</TT> = Foo to the top of master.mif
<LI>Include the following files (in this order)<B> cproj.mif, defrule.mif, deftarg.mif</B> in<B> master.mif</B>
<LI>Add<TT> inc_dirs</TT> = {list of directories, separated by spaces and each prepended with -I, which your project needs
in include path - this does not include OS-specific includes (ie<B> \lang\h\win</B> )}
<LI>Add<TT> extra_c_flags</TT> = {list of c flags, not including optimization, -w4, -zq.&nbsp; -we and memory model info,
needed to compile your application} These should be host_os/host_cpu independent.
<LI>Add<TT> extra_l_flags</TT> = {list of linker directives, not incuding system or debug directives} Should be host_os/host_cpu
independent.
<LI>Use following to compile:<TT>&nbsp; $(cc) $(cflags)</TT> filename etc...
<LI>Use following to link:<TT>&nbsp; $(linker) $(lflags)</TT> file { list of obj files }
<LI>Use following to create libraries:<TT>&nbsp; $(librarian)</TT>
<LI>In each object file directory, create a makefile which looks like the following:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pmake: build os_x cpu_y</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; host_os&nbsp; = x</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; host_cpu = y</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; !include ../master.mif</TT>
</OL>
<BR>That's it!&nbsp; The only downside is that sticking to these guidelines will make everyone's life less exciting.
<H1 ID="Technical_Notes"> Technical Notes </H1>
<H2 ID="32Mbit_Windows_runMtime_DLLs"> 32-bit Windows run-time DLLs </H2>
<BR>Most of Open Watcom run-time Windows DLLs have predefined loading address.&nbsp; Bellow is table with address for each
DLL.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0x69000000&nbsp; wppdxxxx.dll&nbsp; (C++ compiler)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0x69400000&nbsp; wccdxxxx.dll&nbsp; (C compiler)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0x69800000&nbsp; wrc.dll&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Resource compiler)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0x69900000&nbsp; wr.dll&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Resource library)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0x69c00000&nbsp; wlinkd.dll&nbsp;&nbsp;&nbsp; (Linker)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0x6a000000&nbsp; wlibd.dll&nbsp;&nbsp;&nbsp;&nbsp; (Librarian)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0x6e800000&nbsp; javavm.dll&nbsp;&nbsp;&nbsp; (Debugger DIP)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0x6e900000&nbsp; all trap dlls (Debugger TRAP)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0x6eb00000&nbsp; madx86.dll&nbsp;&nbsp;&nbsp; (Debugger MAD)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0x6ec00000&nbsp; export.dll&nbsp;&nbsp;&nbsp; (Debugger DIP)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0x6ed00000&nbsp; codeview.dll&nbsp; (Debugger DIP)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0x6ee00000&nbsp; watcom.dll&nbsp;&nbsp;&nbsp; (Debugger DIP)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0x6ef00000&nbsp; dwarf.dll&nbsp;&nbsp;&nbsp;&nbsp; (Debugger DIP)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0x6fa00000&nbsp; wrtxxxx.dll&nbsp;&nbsp; (run-time DLL combined C, math and C++ library)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0x6fd00000&nbsp; plbxxxx.dll&nbsp;&nbsp; (run-time DLL C++ library)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0x6fe00000&nbsp; clbxxxx.dll&nbsp;&nbsp; (run-time DLL C library)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0x6ff00000&nbsp; mtxxxx.dll&nbsp;&nbsp;&nbsp; (run-time DLL math library)</TT>
<BR><BR>You shouldn't use these addresses for your own DLLs.
<H1 ID="Build_Process"> Build Process </H1>
<BR>We use the (Open) Watcom C/C++ compilers and Watcom<B> wmake</B> to build our tools, but at the top level we have a custom
tool which oversees traversing the build tree, deciding which projects to build for what platforms, logging the results to
a file, and copying the finished software into the release tree (rel), making fully automated builds a possibility.&nbsp;
If nothing goes wrong that is.
<H2 ID="Builder"> Builder </H2>
<BR>This wondrous tool is called<B> builder.</B>&nbsp; You can see<B> bld\builder\builder.doc</B> for detailed info on the
tool and/or look at the source if the documentation doesn't satisfy you.
<BR><BR>So how does builder work?&nbsp; Each project has a<B> lang.ctl</B> builder script file.&nbsp; If you go to a project
directory and run builder, it will make only that project; if you go to<B> bld</B> and run builder, it will build everything
under the sun.&nbsp; The overall build uses<B> bat\lang.ctl</B> which includes all of the individual project<B> lang.ctl</B>
files that we use.&nbsp; Note that if you run builder, it will traverse directories upwards until it finds a<B> lang.ctl</B>
(or it hits the root and still doesn't find anything, but then you must have surely done something wrong).&nbsp; Results are
logged to<B> build.log</B> in the current project directory and the previous<B> build.log</B> file is copied to<B> build.lo1.</B>
&nbsp;The log file contains captured console output (both stdout and stderr).
<BR><BR>Common commands:
<DL>
<DT>builder build
<DD>- build the software
<DT>builder rel
<DD>- build the software, and copy it into the &quot;rel&quot; release tree
<DT>builder clean
<DD>- erase object files, executables, etc.&nbsp; so you can build from scratch
</DL>
<H2 ID="Pmake"> Pmake </H2>
<BR>Many of the projects use the &quot;pmake&quot; features of builder (see<B> builder.doc</B> ) or standalone pmake tool.
&nbsp;If you want to see its guts, the<B> pmake</B> source is in<B> bld\pmake.</B>
<BR><BR>Each makefile has a comment line at the top of the file which is read by<B> pmake.</B>&nbsp; Most of our<B> lang.ctl</B>
files will have a line similar to this:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; pmake -d build -h ...</TT>
<BR><BR>this will cause<B> wmake</B> to be run in every subdirectory where the makefile contains<TT> &quot;build&quot;</TT>
on the<TT> #pmake</TT> line.&nbsp; See for instance the C compiler makefiles (in<B> bld\cc)</B> for an example.
<BR><BR>You can also specify more parmeters to build a smaller subset of files.&nbsp; This is especially useful if you do
not have all required tools/headers/libraries for all target platforms.
<BR><BR>For example:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; builder rel os_nt</TT>
<BR><BR>will (generally) build only the NT version of the tools.
<BR><BR>A word of warning:&nbsp; running a full build may take upwards of two hours on a 1GHz machine.&nbsp; There is a LOT
to build!&nbsp; This is not your ol' OS kernel or a single-host, single-target C/C++ compiler.
<BR><BR>It is generally possible to build specific binaries/libraries by going to their directory and running<B> wmake.</B>
&nbsp;For instance to build the OS/2 version of<B> wlink</B> you can go to<B> bld\wl\os2386</B> and run<B> wmake</B> there
(note that the process won't successfully finish unless several required libraries had been built).&nbsp; Builder is useful
for making full &quot;release&quot; builds while running<B> wmake</B> in the right spot is the thing to do during development.
<BR><BR>Happy Building!
<H1 ID="Testing"> Testing </H1>
<BR>There is undoubtedly a question on your mind:&nbsp; Now that I have the Open Watcom compilers, libraries and tools built,
what do I do next?&nbsp; The answer is simpler than you may have expected:&nbsp; Ensure that what you built actually works.
<BR>Fortunately there is a number of more or less automated test available in the source tree.&nbsp; Currently these tests
are not part of the build process per se, although that might (and perhaps should) change in future.
<BR><BR>There are two major classes of situations when the tests should be run:
<UL>
<LI>After building on a fresh system for the first time, running (and passing) the tests verifies that what was built behaves
at least somewhat as expected.&nbsp; In this case it might be prudent to run as many tests as possible, especially when building
on a new, not yet widely tested platform.
<LI>After making modifications to a particular tool or library, run the appropriate tests exercising the component (if available)
to ensure that the changes didn't cause any serious regressions.
</UL>
<BR>If a bug is discovered and fixed, it is a good practice to code up a simple test verifying the fix.&nbsp; That way we
can prevent (or at least expediently discover) regressions in future builds.&nbsp; In other words, we won't be embarrassed
by the same bug cropping up again.&nbsp; Just because commercial compiler vendors occasionally have this problem doesn't mean
we have to as well!
<BR><BR>Passing the automated tests can never completely guarantee that everything works perfectly as designed, but it does
let you sleep easier at night, comfortable in the knowledge that there aren't any really major problems.
<H2 ID="Running_the_tests"> Running the tests </H2>
<BR>This section maps the major test nests and gives brief description on how to run the tests and how they're constructed.
&nbsp;There is often a single batch file or script that will build and run all the tests for a given project, the end result
being either &quot;all set to go&quot; or &quot;we have a bug infestation problem at location xyz, send out bug swat team
immediately&quot;.
<BR><BR>To make automated testing feasible, the test programs do not require user input (unless they were testing user input
of course).&nbsp; Some test programs do their work and then decide whether everything worked as expected or not and output
a message to that effect.&nbsp; Other test programs ouput messages mapping their progress as they go and the output is then
compared with a file containing the 'good' output.&nbsp; Which method exactly is used depends mostly on what is being tested.
&nbsp;When testing error and warning messages printed by the compilers and tools, it is natural to compare the captured output
to the expected text.&nbsp; When testing the runtime library for instance, it makes sense for the test program itself to decide
whether the function call results are what was expected.
<BR><BR>Now we'll go through the projects alphabetically and make a stop whenever there's something interesting to see.&nbsp;
Note that not all of the tests are automated, the really extensive tests are however.&nbsp; Being a lazy folk, programmers
are likely to bang together an automated test suite if that helps them avoid babysitting the tests.
<DL>
<DT>as
<DD>In<B> bld\as\alpha\test</B> there are several tests exercising the Alpha AXP assembler, using C wrappers for infrastructure.
<DT>aui
<DD>Not a real test, nevertheless the sample programs in<B> bld\aui\sample</B> are useful in demonstrating and informally testing
the user interface library.
<DT>brinfo
<DD>In<B> bld\brinfo\test</B> there is a simple browser information test program.
<DT>browser
<DD>Tests exercising the class browser are located in<B> bld\browser\test.</B>
<DT>cg
<DD>In<B> cg\test\far16</B> there is a test exercising the<TT> __far16</TT> keyword.&nbsp; Real code generator tests are found
elsewhere.
<DT>clib
<DD>The C runtime library tests are located in<B> bld\clib\qa.</B>&nbsp; These tests are not terribly comprehensive but they do
verify the basic C runtime functionality.
<DT>gui
<DD>Again not a real test, there is a GUI library sample in<B> bld\gui\sample.</B>
<DT>ndisasm
<DD>Tests for the 'new' disassembler (not many at this point) are located in<B> bld\ndisasm\test.</B>
<DT>orl
<DD>The Object Reader Library tests are in<B> bld\orl\test.</B>
<DT>plustest
<DD>This project holds<B> the</B> test suite.&nbsp; Ostensibly designed to exercise the C++ compiler, the tests also verify the
functionality of the code generator and some are designed for the C compiler.&nbsp; Running these tests can take a while as
there are over a thousand test cases.&nbsp; Highly recommended.
<DT>ssl
<DD>In<B> bld\ssl\test</B> there are several simple test scripts for SSL.
<DT>trmem
<DD>While the memory tracker is not a test, it bears mentioning here.&nbsp; This can be used for testing many other projects for
memory leaks, memory overwrites and other cases of rude behaviour.
<DT>viprdemo
<DD>Again not a test per se, the 'Viper demo' is a good way to verify basic IDE functionality.
<DT>wasm
<DD>Extensive assembler test can be found (rather predictably) in<B> bld\wasmtest.</B>
<DT>wdisasm
<DD>Tests for the 'old' disassembler are located in<B> bld\wdisasm\test.</B>
<DT>wmake
<DD>Extensive make utility tests can be found in<B> bld\wmake\regress.</B>
<DT>wprof
<DD>A profiler test program is located in<B> bld\wprof\test.</B>
<DT>yacc
<DD>Several sample/test YACC input files are in<B> bld\yacc\y.</B>
</DL>
<H1 ID="Programming_Style"> Programming Style </H1>
<BR>Programming style is, unfortunately, a religious matter.&nbsp; Many holy wars have been fought over it with no clear result
(because the losing side usually survives).&nbsp; Still, with a project the size of Open Watcom (that is, a very big project)
there is a clear need for common programming style.
<BR>Conformance of all projects to a common style has several benefits.&nbsp; Programmers who know this style will be easily
able to find their way around any of the multitude of projects.&nbsp; Various projects will easily fit together.&nbsp; And
last but not least, consistent style looks good.
<BR><BR>Note:&nbsp; the fact that certain Open Watcom projects do not adhere to the common programming style should not be
construed as an endorsement of non-conformance.&nbsp; It is simply a result of the long and varied history of the project.
<BR><BR>The following sections examine various aspects of programming practice and give specific guidelines where applicable.
&nbsp;Note that these are guidelines, not rules or laws.&nbsp; Violating them is not a crime and not even a mortal sin.&nbsp;
In fact, you might have a very good reason not to stick to the guidelines, and we always prefer common sense to fixed rules.
&nbsp;However breaking the guidelines with no good reason is bad for your karma.&nbsp; Don't do it!
<H2 ID="Source_file_structure"> Source file structure </H2>
<BR>First a few words on source file structure.&nbsp; Every source file should start with a copyright header.&nbsp; This only
applies to source and include files (regardless of programming language used).&nbsp; Other types of files such as makefiles,
scripts, etc.&nbsp; do not need a copyright header.&nbsp; The header should also contain a short description of the source
file, one or two lines is usually enough.&nbsp; Longer comments explaining specifics of the implementation should be placed
after the header.
<BR><BR>The rest of the source file structure depends on the language used.&nbsp; Here we will only examine the most common
kind, which is a C source file.&nbsp; The overall structure is as follows:
<UL>
<LI>copyright header
<LI><B><I> #include</I></B> directives
<LI>function declarations and global variable definitions
<LI>function implementation
</UL>
<BR>As you can see, nothing fancy.&nbsp; Many programmers prefer to order functions so as to minimize forward declarations,
ie.&nbsp; a<TT> main()</TT> function would be located at the end and every function fully defined before it is first used.
<BR><BR>You can use<B><I> extern</I></B> declarations but you should be very careful.&nbsp; It is strongly encouraged that
all declarations of external functions and variable be located in header files which are included in modules that use them
as well as modules that define them.&nbsp; The reason is simple - this way the compiler will tell you if you change the definition
but not the header file.&nbsp; If you use ad-hoc<B><I> extern</I></B> declarations, you better make sure they're in sync with
the actual definitions.
<H2 ID="Help_the_compiler_and_it_will_help_you"> Help the compiler and it will help you </H2>
<BR>While the compiler is a rather sophisticated piece of software, it cannot divine your intentions.&nbsp; Hence you have
to help it a bit by giving hints here and there.&nbsp; And if you help the compiler in this way, it will be better able to
help you.
<BR><BR>First of all, always compile with maximum warning level.&nbsp; Just because a message is called a warning and not
error doesn't mean you can ignore it.&nbsp; In fact many projects treat warnings as errors and will not build if any warnings
are present.&nbsp; That is a Good Thing.
<BR><BR>Use the<B><I> static</I></B> keyword often because it is good.&nbsp; This is a multi-faceted keyword and its exact
semantics depend on where it is applied:
<DL>
<DT>globals
<DD>here the<B><I> static</I></B> modifier does not change the storage class but makes the variables local to the module where
they are defined, that is they won't be visible from other modules.&nbsp; If a variable needs to be global but doesn't have
to be accessed from other modules, you should definitely make it static.&nbsp; That way you will not needlessly pollute the
global namespace (reducing the chance of name clashes) and if you stop using the variable, the compiler will warn you.&nbsp;
If you have a non-static global variable that is unused, the compiler cannot warn you as it has to assume that it is used
from other modules.
<DT>locals
<DD>in this case the<B><I> static</I></B> keyword changes the storage class and the variable will be stored in data segment instead
of on stack.&nbsp; If you need a variable that has global lifetime but only needs to be accessible from one function, making
it local and static is a good choice.
<DT>functions
<DD>the effect of the<B><I> static</I></B> keyword here is similar to the global variables.&nbsp; The function will not be visible
from other modules.&nbsp; Again, the compiler will warn you if you stop using such a function.&nbsp; But declaring a function
static also helps the optimizer.&nbsp; For instance if the optimizer inlines a static function, it can completely remove the
non-inlined version.&nbsp; If the function weren't static, the non-inlined version always has to be present for potential
external callers.
</DL>
<BR>Similar in vein to the<B><I> static</I></B> keyword is the<B><I> const</I></B> keyword.&nbsp; Again it can be applied
in various ways and it helps the compiler and optimizer by giving it hints about how you intend to use a particular variable
or argument.&nbsp; Saying that a variable is constant is essentially the same as saying that it's read-only.&nbsp; The compiler/linker
might place such variable in a read-only segment.&nbsp; While it is possible to circumvent the<B><I> const</I></B> modifier
by taking the address of a constant variable and modifying it through a pointer, this is a bad thing to do and it may not
work at all because the variable might be not be physically writable.&nbsp; It is perhaps worthwhile to remark that there
are three possible outomes of applying the<B><I> const</I></B> modifier to a pointer:
<UL>
<LI>a constant pointer, that is the value of the pointer is constant but the data it points to isn't
<LI>a pointer to a constant, that is the pointer itself is not constant but the value it points to cannot be modified through
it
<LI>a constant pointer to a constant, that is both the pointer itself and the value it points to are constant.
</UL>
<BR>The<B><I> const</I></B> keyword is especially useful when used in function declarations.&nbsp; Consider the following
typical declaration:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char *strcpy( char *s1, const char *s2 );</TT>
<BR><BR>Here we have a function which takes two arguments that are both pointers to char but one of them is a pointer to a
constant.&nbsp; In the function body the compiler will not let you modify the contents of<TT> *s2</TT> but the declaration
is also important for the caller.&nbsp; In the calling funtion, the optimizer now knows that the data the<TT> s2</TT> argument
points to will not be modified by<TT> strcpy()</TT> and it can take advantage of this knowledge.
<H1 ID="Producing_Documentation"> Producing Documentation </H1>
<BR><BR>The purpose of this document is twofold:&nbsp; to provide an overview of the Open Watcom documentation system togehter
with the steps necessary for editing and producing online or printed documents, and at the same time serve as an example of
the documentation system usage.
<BR>It is useful to note that the online documentation is almost, but not quite, independent of the rest of the Open Watcom
compilers and tools.&nbsp; One important exception is online help files for Open Watcom GUI tools.&nbsp; Formatting online
documentation generates include files containing symbolic constants designating help entries.&nbsp; These are used during
building of the tools binaries.&nbsp; If the binaries are not built with the right header files, the online help will be out
of sync and not all that helpful.
<BR><BR>There's one other link going in the other direction:&nbsp; certain documentation files live with their respective
projects and not in the documents tree.&nbsp; This is especially true for error message documentation for the compilers and
tools.
<H2 ID="Setting_up"> Setting up </H2>
<BR>A Win32 or OS/2 system can be used to produce most of the documentation.&nbsp; OS/2 Warp is required for the final step
in producing the OS/2 online help files and Win32 system is needed for producing Windows help files (unless you can run the
required help compilers on your host platform).&nbsp; DOS may work for producing some of the documentation but is untested
at this time.
<BR><BR>The environment variable<TT> doc_root</TT> must point to the root of the docunmentation tree.&nbsp; Add<TT> %doc_root%\cmds</TT>
to your<TT> PATH.</TT>&nbsp; Your<TT> PATH</TT> must also contain the Open Watcom C/C++ binary directories appropriate for
your host platform (for wmake).&nbsp; This is taken care of automatically by using<TT> setvars.cmd/setvars.bat.</TT>
<BR><BR>Note that to produce Windows and/or OS/2 online documentation, you will need the appropriate SDKs and Toolkits containing
the platform specific online help compilers.
<H2 ID="Building_PostScript_Documentation"> Building PostScript Documentation </H2>
<BR>Here are the steps to formatting a book for printing on a PostScript printer.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; cd %doc_root%\ps</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; wmake hbook=&lt;bn&gt;</TT>
<BR><BR>where<TT> &lt;bn&gt;</TT> is one of
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; devguide&nbsp;&nbsp;&nbsp; Developer's Guide (this document)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; c_readme&nbsp;&nbsp;&nbsp; C/C++ Read Me First</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; cguide&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C/C++ User's Guide</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; cguideq&nbsp;&nbsp;&nbsp;&nbsp; C/C++ User's Guide for QNX</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; clib&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C Library Reference (for all systems except
QNX)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; clibqnx&nbsp;&nbsp;&nbsp;&nbsp; C Library Reference for QNX (stale)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; cpplib&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C++ Class Library Reference</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ctools&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C/C++ Tools User's Guide</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; cw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CauseWay User's Guide</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; f77graph&nbsp;&nbsp;&nbsp; F77 Graphics Library Reference</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; f_readme&nbsp;&nbsp;&nbsp; F77 Read Me First</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; fpguide&nbsp;&nbsp;&nbsp;&nbsp; F77 Programmer's Guide</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ftools&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; F77 Tools User's Guide</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; fuguide&nbsp;&nbsp;&nbsp;&nbsp; F77 User's Guide</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; guitool&nbsp;&nbsp;&nbsp;&nbsp; Graphical Tools User's Guide</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ide&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IDE User's Guide</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; lguide&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Linker User's Guide</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; pguide&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C/C++ Programmer's Guide</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; wd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Debugger User's Guide</TT>
<BR><BR>The output file is of type<TT> .ps.</TT>&nbsp; You should be able to send this file to any PostScript printer or view
it in GhostScript or convert it to PDF or do whatever it is you do with PostScript files.
<H2 ID="Building_Online_Help_Documentation"> Building Online Help Documentation </H2>
<BR>For Microsoft Help format (old Windows 3.x help format):
<UL>
<LI>Switch to the appropriate directory:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; cd %doc_root%\win</TT>
<LI>Run<TT> wmake</TT> to create all online help.
<LI>Note that you must have the Microsoft Help Compiler (HC) installed.
</UL>
<BR>For Microsoft Help format (&quot;new&quot; Windows NT/95 help format):
<UL>
<LI>Switch to the appropriate directory:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; cd %doc_root%\nt</TT>
<LI>Run<TT> wmake</TT> to create all online help.
<LI>Note that you must have the Microsoft Help Compiler (HCRTF) installed.
</UL>
<BR>For Watcom Help format (for the WHELP command):
<UL>
<LI>Switch to the appropriate directory:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; cd %doc_root%\dos</TT>
<LI>Run<TT> wmake</TT> to create all online help.
</UL>
<BR>For OS/2 Help format:
<UL>
<LI>Switch to the appropriate directory:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; cd %doc_root%\os2</TT>
<LI>Run<TT> wmake</TT> to create all OS/2 online help.
<LI>Note that this will only work on an OS/2 system with the IBM IPF Compiler (IPFC) installed.
</UL>
<BR>To format one document at a time, go to the appropriate directory (for instance<TT> docs\os2</TT> ) and run wmake with
argument<TT> hbook=&lt;book_name&gt;</TT> where<TT> &lt;book_name&gt;</TT> is one of the online books listed above.
<H2 ID="Editing_the_Documentation"> Editing the Documentation </H2>
<BR>All the documentation is stored in ASCII text files with the file extension &quot;GML&quot;.&nbsp; The files are annotated
with a combination of Script and GML (Generalized Markup Language) tags.
<BR><BR>The Script tags are of the form &quot;.tag&quot; (i.e., they begin with a period and are followed by two or more letters
or digits).&nbsp; Script tags will be most familiar to anyone who has ever used Waterloo Script or IBM Script.&nbsp; The tagged
format is also similar in idea to other tagged formatting systems like RUNOFF or ROFF.
<BR><BR>The GML tags are of the form &quot;:TAG.&quot; (i.e., they begin with a colon, followed by some letters and digits
and end with a period).&nbsp; GML tags will be most familiar to anyone who has ever used IBM GML or Waterloo GML.&nbsp; This
tag set is a variant of SGML.&nbsp; The most familiar SGML tag format is<TT> &lt;TAG&gt;.</TT>&nbsp; In Watcom GML, the &quot;&lt;&quot;
and &quot;&gt;&quot; are replaced by the &quot;:&quot; and &quot;.&quot;.&nbsp; If you know HTML, you know how tags work -
HTML is just another variant of SGML.
<BR><BR>The tag set includes a base set of predefined tags.&nbsp; In addition to this base set, you can define an extended
tag set using the built-in macro language.&nbsp; The base Script tag set employs two letters (e.g., two, three, four or more
letters (e.g.&nbsp; .chapter, .section, .beglevel).&nbsp; For a good example of user-defined Script tags, see<TT> %doc_root%\doc\gml\fmtmacro.gml.</TT>
&nbsp;GML tags can also be defined.&nbsp; For a good example of user-defined GML tags, see<TT> %doc_root%\doc\gml\cppextra.gml.</TT>
<BR><BR>These tags are described here for you, not so that you can begin defining your own tags, but so that you will recognize
them in the ASCII text that comprises the documentation.&nbsp; But of course no-one's stopping you from defining your own
tags should you feel so inclined.
<BR><BR>Here's a snippet from one of the doc files.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .np</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The recommended options for generating the fastest 16-bit Intel code</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; are:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .ix 'fastest 16-bit code'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .begnote</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .note Pentium Pro</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -oneatx -oh -oi+ -ei -zp8 -6 -fpi87 -fp6</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .note Pentium</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -oneatx -oh -oi+ -ei -zp8 -5 -fpi87 -fp5</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .note 486</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -oneatx -oh -oi+ -ei -zp8 -4 -fpi87 -fp3</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .note 386</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -oneatx -oh -oi+ -ei -zp8 -3 -fpi87 -fp3</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .note 286</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -oneatx -oh -oi+ -ei -zp8 -2 -fpi87 -fp2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .note 186</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -oneatx -oh -oi+ -ei -zp8 -1 -fpi87</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .note 8086</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -oneatx -oh -oi+ -ei -zp8 -0 -fpi87</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .endnote</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .np</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The recommended options for generating the fastest 32-bit Intel code</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; are:</TT>
<BR><BR>The &quot;.np&quot; is a user-defined tag for &quot;start a new paragraph&quot;.&nbsp; The &quot;.ix&quot; creates
an index entry in the index.&nbsp; It doesn't appear with the text.&nbsp; In on-line help, this index entry becomes a searchable
item.&nbsp; The &quot;.begnote&quot;, &quot;.note&quot;, and &quot;.endnote&quot; user-defined tags are used to create an
unordered list.&nbsp; Every piece of text entered into the source file is identified by tags like these.
<BR><BR>The best way to understand what the tags do is to look at a printed copy of the document and see what it looks like.
&nbsp;Luckily for you, you don't have to look very far:
<BR><BR>The recommended options for generating the fastest 16-bit Intel code are:&nbsp; 
<DL>
<DT>Pentium Pro
<DD>-oneatx -oh -oi+ -ei -zp8 -6 -fpi87 -fp6
<DT>Pentium
<DD>-oneatx -oh -oi+ -ei -zp8 -5 -fpi87 -fp5
<DT>486
<DD>-oneatx -oh -oi+ -ei -zp8 -4 -fpi87 -fp3
<DT>386
<DD>-oneatx -oh -oi+ -ei -zp8 -3 -fpi87 -fp3
<DT>286
<DD>-oneatx -oh -oi+ -ei -zp8 -2 -fpi87 -fp2
<DT>186
<DD>-oneatx -oh -oi+ -ei -zp8 -1 -fpi87
<DT>8086
<DD>-oneatx -oh -oi+ -ei -zp8 -0 -fpi87
</DL>
<BR>The recommended options for generating the fastest 32-bit Intel code are:
<BR><BR>The WATCOM GML program (WGML) is a compiler/interpreter that reads the document's source files to produce an output
file.&nbsp; In our case, we want PostScript for printing and we want another form for generation of online help.&nbsp; This
second form is a non-printable form that is suitable for post-processing to turn it into IPF for the OS/2 IPF compiler, RTF
for the WinHelp tools, special Watcom-defined format for use with a DOS-based help tool (WHELP) or the ever-popular HTML.
<BR><BR>If you are a programmer, and that is likely, you'll be somewhat comfortable with the whole process of turning ASCII
text into documentation.&nbsp; WGML is a text processor (compiler) that reads a source file (GML) which, in turn, imbeds other
source files, and produces an output file (the object file).&nbsp; WGML is very fast.&nbsp; It was very fast in the old 20MHz
386 days and is, of course, much faster with today's processors.&nbsp; The C Library Reference comprising 1,241 pages takes
one minute to format into PostScript on a 600 MHz Pentium-III.
<BR><BR>If you ever used TeX or LaTeX you will be comfortable with the concept of nonvisual content-driven formatting.&nbsp;
If you only know so-called WYSIWYG word processors heavily relying on visual formatting, you might be surprised to find that
it is possible to let the computer do lot of the hard work.&nbsp; Just give up the idea of controlling every pixel - it never
works right anyway.&nbsp; Instead of saying &quot;this is Arial 10pt Bold&quot; you will say &quot;this is a keyword&quot;
or &quot;this is a code example&quot; and let the machine worry about formatting.
<H2 ID="Diagnostic_Messages"> Diagnostic Messages </H2>
<BR>If you see<TT> ***WARNING***</TT> messages issued by WGML, you can ignore them.&nbsp; Of course it is better if you don't
and correct whatever is causing the warnings.&nbsp; If you see<TT> ***ERROR***</TT> messages, you cannot ignore them and have
to fix them before any output is produced.
</BODY>
