<HEAD>
<TITLE> Open Watcom 2.0 FORTRAN 77 Graphics Library Reference </TITLE>
</HEAD>
<BODY>
<H1 ID="Index_of_Topics"> Index of Topics </H1>
<DL>
<DT>- _ -
<DD><A HREF="#_arc">_arc, _arc_w, _arc_wxy</A>
<BR><A HREF="#_clearscreen">_clearscreen</A>
<BR><A HREF="#_displaycursor">_displaycursor</A>
<BR><A HREF="#_ellipse">_ellipse, _ellipse_w, _ellipse_wxy</A>
<BR><A HREF="#_floodfill">_floodfill, _floodfill_w</A>
<BR><A HREF="#_getactivepage">_getactivepage</A>
<BR><A HREF="#_getarcinfo">_getarcinfo</A>
<BR><A HREF="#_getbkcolor">_getbkcolor</A>
<BR><A HREF="#_getcliprgn">_getcliprgn</A>
<BR><A HREF="#_getcolor">_getcolor</A>
<BR><A HREF="#_getcurrentposition">_getcurrentposition, _getcurrentposition_w</A>
<BR><A HREF="#_getfillmask">_getfillmask</A>
<BR><A HREF="#_getfontinfo">_getfontinfo</A>
<BR><A HREF="#_getgtextextent">_getgtextextent</A>
<BR><A HREF="#_getgtextvector">_getgtextvector</A>
<BR><A HREF="#_getimage">_getimage, _getimage_w, _getimage_wxy</A>
<BR><A HREF="#_getlinestyle">_getlinestyle</A>
<BR><A HREF="#_getphyscoord">_getphyscoord</A>
<BR><A HREF="#_getpixel">_getpixel, _getpixel_w</A>
<BR><A HREF="#_getplotaction">_getplotaction</A>
<BR><A HREF="#_gettextcolor">_gettextcolor</A>
<BR><A HREF="#_gettextcursor">_gettextcursor</A>
<BR><A HREF="#_gettextextent">_gettextextent</A>
<BR><A HREF="#_gettextposition">_gettextposition</A>
<BR><A HREF="#_gettextsettings">_gettextsettings</A>
<BR><A HREF="#_gettextwindow">_gettextwindow</A>
<BR><A HREF="#_getvideoconfig">_getvideoconfig</A>
<BR><A HREF="#_getviewcoord">_getviewcoord, _getviewcoord_w, _getviewcoord_wxy</A>
<BR><A HREF="#_getvisualpage">_getvisualpage</A>
<BR><A HREF="#_getwindowcoord">_getwindowcoord</A>
<BR><A HREF="#_grstatus">_grstatus</A>
<BR><A HREF="#_grtext">_grtext, _grtext_w</A>
<BR><A HREF="#_imagesize">_imagesize, _imagesize_w, _imagesize_wxy</A>
<BR><A HREF="#_lineto">_lineto, _lineto_w</A>
<BR><A HREF="#_moveto">_moveto, _moveto_w</A>
<BR><A HREF="#_outgtext">_outgtext</A>
<BR><A HREF="#_outmem">_outmem</A>
<BR><A HREF="#_outtext">_outtext</A>
<BR><A HREF="#_pg_analyzechart">_pg_analyzechart, _pg_analyzechartms</A>
<BR><A HREF="#_pg_analyzepie">_pg_analyzepie</A>
<BR><A HREF="#_pg_analyzescatter">_pg_analyzescatter, _pg_analyzescatterms</A>
<BR><A HREF="#_pg_chart">_pg_chart, _pg_chartms</A>
<BR><A HREF="#_pg_chartpie">_pg_chartpie</A>
<BR><A HREF="#_pg_chartscatter">_pg_chartscatter, _pg_chartscatterms</A>
<BR><A HREF="#_pg_defaultchart">_pg_defaultchart</A>
<BR><A HREF="#_pg_getchardef">_pg_getchardef</A>
<BR><A HREF="#_pg_getpalette">_pg_getpalette</A>
<BR><A HREF="#_pg_getstyleset">_pg_getstyleset</A>
<BR><A HREF="#_pg_hlabelchart">_pg_hlabelchart</A>
<BR><A HREF="#_pg_initchart">_pg_initchart</A>
<BR><A HREF="#_pg_resetpalette">_pg_resetpalette</A>
<BR><A HREF="#_pg_resetstyleset">_pg_resetstyleset</A>
<BR><A HREF="#_pg_setchardef">_pg_setchardef</A>
<BR><A HREF="#_pg_setpalette">_pg_setpalette</A>
<BR><A HREF="#_pg_setstyleset">_pg_setstyleset</A>
<BR><A HREF="#_pg_vlabelchart">_pg_vlabelchart</A>
<BR><A HREF="#_pie">_pie, _pie_w, _pie_wxy</A>
<BR><A HREF="#_polygon">_polygon, _polygon_w, _polygon_wxy</A>
<BR><A HREF="#_putimage">_putimage, _putimage_w</A>
<BR><A HREF="#_rectangle">_rectangle, _rectangle_w, _rectangle_wxy</A>
<BR><A HREF="#_registerfonts">_registerfonts</A>
<BR><A HREF="#_remapallpalette">_remapallpalette</A>
<BR><A HREF="#_remappalette">_remappalette</A>
<BR><A HREF="#_scrolltextwindow">_scrolltextwindow</A>
<BR><A HREF="#_selectpalette">_selectpalette</A>
<BR><A HREF="#_setactivepage">_setactivepage</A>
<BR><A HREF="#_setbkcolor">_setbkcolor</A>
<BR><A HREF="#_setcharsize">_setcharsize, _setcharsize_w</A>
<BR><A HREF="#_setcharspacing">_setcharspacing, _setcharspacing_w</A>
<BR><A HREF="#_setcliprgn">_setcliprgn</A>
<BR><A HREF="#_setcolor">_setcolor</A>
<BR><A HREF="#_setfillmask">_setfillmask</A>
<BR><A HREF="#_setfont">_setfont</A>
<BR><A HREF="#_setgtextvector">_setgtextvector</A>
<BR><A HREF="#_setlinestyle">_setlinestyle</A>
<BR><A HREF="#_setpixel">_setpixel, _setpixel_w</A>
<BR><A HREF="#_setplotaction">_setplotaction</A>
<BR><A HREF="#_settextalign">_settextalign</A>
<BR><A HREF="#_settextcolor">_settextcolor</A>
<BR><A HREF="#_settextcursor">_settextcursor</A>
<BR><A HREF="#_settextorient">_settextorient</A>
<BR><A HREF="#_settextpath">_settextpath</A>
<BR><A HREF="#_settextposition">_settextposition</A>
<BR><A HREF="#_settextrows">_settextrows</A>
<BR><A HREF="#_settextwindow">_settextwindow</A>
<BR><A HREF="#_setvideomode">_setvideomode</A>
<BR><A HREF="#_setvideomoderows">_setvideomoderows</A>
<BR><A HREF="#_setvieworg">_setvieworg</A>
<BR><A HREF="#_setviewport">_setviewport</A>
<BR><A HREF="#_setvisualpage">_setvisualpage</A>
<BR><A HREF="#_setwindow">_setwindow</A>
<BR><A HREF="#_unregisterfonts">_unregisterfonts</A>
<BR><A HREF="#_wrapon">_wrapon</A>
<DT>- A -
<DD><A HREF="#Analyze_Routines">Analyze Routines</A>
<BR><A HREF="#Attribute_Routines">Attribute Routines</A>
<DT>- C -
<DD><A HREF="#Classes_of_Graphics_Routines">Classes of Graphics Routines</A>
<BR><A HREF="#Coordinate_System_Routines">Coordinate System Routines</A>
<DT>- D -
<DD><A HREF="#Display_Routines">Display Routines</A>
<BR><A HREF="#Drawing_Routines">Drawing Routines</A>
<DT>- E -
<DD><A HREF="#Environment_Routines">Environment Routines</A>
<DT>- F -
<DD><A HREF="#Font_Manipulation_Routines">Font Manipulation Routines</A>
<DT>- G -
<DD><A HREF="#Graphics_Adapters">Graphics Adapters</A>
<BR><A HREF="#Graphics_Library">Graphics Library</A>
<BR><A HREF="#Graphics_Library_Routines">Graphics Library Routines</A>
<BR><A HREF="#Graphics_Routines">Graphics Routines</A>
<BR><A HREF="#Graphics_Text_Routines">Graphics Text Routines</A>
<DT>- I -
<DD><A HREF="#Image_Manipulation_Routines">Image Manipulation Routines</A>
<BR><A HREF="#Include_Files">Include Files</A>
<DT>- P -
<DD><A HREF="#Presentation_Graphics_Routines">Presentation Graphics Routines</A>
<DT>- T -
<DD><A HREF="#Text_Routines">Text Routines</A>
<DT>- U -
<DD><A HREF="#Utility_Routines">Utility Routines</A>
</DL>
<H1 ID="Graphics_Library"> Graphics Library </H1>
<BR>The Open Watcom FORTRAN 77 Graphics Library consists of a large number of routines that provide graphical image support
under DOS and QNX.&nbsp; This chapter provides an overview of this support.&nbsp; The following topics are discussed.
<UL>
<LI>Graphics Routines
<LI>Graphics Adapters
<LI>Classes of Graphics Routines
<OL>
<LI>Environment Routines
<LI>Coordinate System Routines
<LI>Attribute Routines
<LI>Drawing Routines
<LI>Text Routines
<LI>Graphics Text Routines
<LI>Image Manipulation Routines
<LI>Font Manipulation Routines
<LI>Presentation Graphics Routines
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp; Display Routines
<BR>&nbsp;&nbsp;&nbsp;&nbsp; Analyze Routines
<BR>&nbsp;&nbsp;&nbsp;&nbsp; Utility Routines
</OL>
<LI>Include Files
</UL>
<H2 ID="Graphics_Routines"> Graphics Routines </H2>
<BR>Graphics routines are used to display graphical images such as lines and circles upon the computer screen.&nbsp; Routines
are also provided for displaying text along with the graphics output.
<H2 ID="Graphics_Adapters"> Graphics Adapters </H2>
<BR>Support is provided for both color and monochrome screens which are connected to the computer using any of the following
graphics adapters:
<UL>
<LI>IBM Monochrome Display/Printer Adapter (MDPA)
<LI>IBM Color Graphics Adapter (CGA)
<LI>IBM Enhanced Graphics Adapter (EGA)
<LI>IBM Multi-Color Graphics Array (MCGA)
<LI>IBM Video Graphics Array (VGA)
<LI>Hercules Monochrome Adapter
<LI>SuperVGA adapters (SVGA) supplied by various manufacturers
</UL>
<H2 ID="Classes_of_Graphics_Routines"> Classes of Graphics Routines </H2>
<BR>The routines in the Open Watcom FORTRAN 77 Graphics Library can be organized into a number of classes:
<DL>
<DT>Environment Routines
<DD>
<BR><BR>These routines deal with the hardware environment.
<DT>Coordinate System Routines
<DD>
<BR><BR>These routines deal with coordinate systems and mapping coordinates from one system to another.
<DT>Attribute Routines
<DD>
<BR><BR>These routines control the display of graphical images.
<DT>Drawing Routines
<DD>
<BR><BR>These routines display graphical images such as lines and ellipses.
<DT>Text Routines
<DD>
<BR><BR>These routines deal with displaying text in both graphics and text modes.
<DT>Graphics Text Routines
<DD>
<BR><BR>These routines deal with displaying graphics text.
<DT>Image Manipulation Routines
<DD>
<BR><BR>These routines store and retrieve screen images.
<DT>Font Manipulation Routines
<DD>
<BR><BR>These routines deal with displaying font based text.
<DT>Presentation Graphics Routines
<DD>
<BR><BR>These routines deal with displaying presentation graphics elements such as bar charts and pie charts.
</DL>
<BR>The following subsections describe these routine classes in more detail.&nbsp; Each routine in the class is noted with
a brief description of its purpose.
<H3 ID="Environment_Routines"> Environment Routines </H3>
<BR>These routines deal with the hardware environment.&nbsp; The <TT> _getvideoconfig</TT> routine returns information about
the current video mode and the hardware configuration.&nbsp; The <TT> _setvideomode</TT> routine selects a new video mode.
<BR><BR>Some video modes support multiple pages of screen memory.&nbsp; The visual page (the one displayed on the screen)
may be different than the active page (the one to which objects are being written).
<BR><BR>The following routines are defined:
<DL>
<DT><A HREF="#_getactivepage">_getactivepage</A>
<DD>get the number of the current active graphics page
<DT><A HREF="#_getvideoconfig">_getvideoconfig</A>
<DD>get information about the graphics configuration
<DT><A HREF="#_getvisualpage">_getvisualpage</A>
<DD>get the number of the current visual graphics page
<DT><A HREF="#_grstatus">_grstatus</A>
<DD>get the status of the most recently called graphics library routine
<DT><A HREF="#_setactivepage">_setactivepage</A>
<DD>set the active graphics page (the page to which graphics objects are drawn)
<DT><A HREF="#_settextrows">_settextrows</A>
<DD>set the number of rows of text displayed on the screen
<DT><A HREF="#_setvideomode">_setvideomode</A>
<DD>select the video mode to be used
<DT><A HREF="#_setvideomoderows">_setvideomoderows</A>
<DD>select the video mode and the number of text rows to be used
<DT><A HREF="#_setvisualpage">_setvisualpage</A>
<DD>set the visual graphics page (the page displayed on the screen)
</DL>
<H3 ID="Coordinate_System_Routines"> Coordinate System Routines </H3>
<BR>These routines deal with coordinate systems and mapping coordinates from one system to another.&nbsp; The Open Watcom
FORTRAN 77 Graphics Library supports three coordinate systems:&nbsp; 
<OL>
<LI>Physical coordinates
<LI>View coordinates
<LI>Window coordinates
</OL>
<BR>Physical coordinates match the physical dimensions of the screen.&nbsp; The physical origin, denoted (0,0), is located
at the top left corner of the screen.&nbsp; A pixel to the right of the origin has a positive x-coordinate and a pixel below
the origin will have a positive y-coordinate.&nbsp; The x- and y-coordinates will never be negative values.
<BR><BR>The view coordinate system can be defined upon the physical coordinate system by moving the origin from the top left
corner of the screen to any physical coordinate (see the <TT> _setvieworg</TT> routine).&nbsp; In the view coordinate system,
negative x- and y-coordinates are allowed.&nbsp; The scale of the view and physical coordinate systems is identical (both
are in terms of pixels).
<BR><BR>The window coordinate system is defined in terms of a range of user-specified values (see the <TT> _setwindow</TT>
routine).&nbsp; These values are scaled to map onto the physical coordinates of the screen.&nbsp; This allows for consistent
pictures regardless of the resolution (number of pixels) of the screen.
<BR><BR>The following routines are defined:
<DL>
<DT><A HREF="#_getcliprgn">_getcliprgn</A>
<DD>get the boundary of the current clipping region
<DT><A HREF="#_getphyscoord">_getphyscoord</A>
<DD>get the physical coordinates of a point in view coordinates
<DT><A HREF="#_getviewcoord">_getviewcoord</A>
<DD>get the view coordinates of a point in physical coordinates
<DT>_getviewcoord_w (see <A HREF="#_getviewcoord">_getviewcoord</A>)
<DD>get the view coordinates of a point in window coordinates
<DT>_getviewcoord_wxy (see <A HREF="#_getviewcoord">_getviewcoord</A>)
<DD>get the view coordinates of a point in window coordinates
<DT><A HREF="#_getwindowcoord">_getwindowcoord</A>
<DD>get the window coordinates of a point in view coordinates
<DT><A HREF="#_setcliprgn">_setcliprgn</A>
<DD>set the boundary of the clipping region
<DT><A HREF="#_setvieworg">_setvieworg</A>
<DD>set the position to be used as the origin of the view coordinate system
<DT><A HREF="#_setviewport">_setviewport</A>
<DD>set the boundary of the clipping region and the origin of the view coordinate system
<DT><A HREF="#_setwindow">_setwindow</A>
<DD>define the boundary of the window coordinate system
</DL>
<H3 ID="Attribute_Routines"> Attribute Routines </H3>
<BR>These routines control the display of graphical images such as lines and circles.&nbsp; Lines and figures are drawn using
the current color (see the <TT> _setcolor</TT> routine), the current line style (see the <TT> _setlinestyle</TT> routine),
the current fill mask (see the <TT> _setfillmask</TT> routine), and the current plotting action (see the <TT> _setplotaction</TT>
routine).
<BR><BR>The following routines are defined:
<DL>
<DT><A HREF="#_getarcinfo">_getarcinfo</A>
<DD>get the endpoints of the most recently drawn arc
<DT><A HREF="#_getbkcolor">_getbkcolor</A>
<DD>get the background color
<DT><A HREF="#_getcolor">_getcolor</A>
<DD>get the current color
<DT><A HREF="#_getfillmask">_getfillmask</A>
<DD>get the current fill mask
<DT><A HREF="#_getlinestyle">_getlinestyle</A>
<DD>get the current line style
<DT><A HREF="#_getplotaction">_getplotaction</A>
<DD>get the current plotting action
<DT><A HREF="#_remapallpalette">_remapallpalette</A>
<DD>assign colors for all pixel values
<DT><A HREF="#_remappalette">_remappalette</A>
<DD>assign color for one pixel value
<DT><A HREF="#_selectpalette">_selectpalette</A>
<DD>select a palette
<DT><A HREF="#_setbkcolor">_setbkcolor</A>
<DD>set the background color
<DT><A HREF="#_setcolor">_setcolor</A>
<DD>set the current color
<DT><A HREF="#_setfillmask">_setfillmask</A>
<DD>set the current fill mask
<DT><A HREF="#_setlinestyle">_setlinestyle</A>
<DD>set the current line style
<DT><A HREF="#_setplotaction">_setplotaction</A>
<DD>set the current plotting action
</DL>
<H3 ID="Drawing_Routines"> Drawing Routines </H3>
<BR>These routines display graphical images such as lines and ellipses.&nbsp; Routines exist to draw straight lines (see the
<TT> _lineto</TT> routines), rectangles (see the <TT> _rectangle</TT> routines), polygons (see the <TT> _polygon</TT> routines),
ellipses (see the <TT> _ellipse</TT> routines), elliptical arcs (see the <TT> _arc</TT> routines) and pie-shaped wedges from
ellipses (see the <TT> _pie</TT> routines).
<BR><BR>These figures are drawn using the attributes described in the previous section.&nbsp; The routines ending with<TT>
_w</TT> or<TT> _wxy</TT> use the window coordinate system; the others use the view coordinate system.
<BR><BR>The following routines are defined:
<DL>
<DT><A HREF="#_arc">_arc</A>
<DD>draw an arc
<DT>_arc_w (see <A HREF="#_arc">_arc</A>)
<DD>draw an arc using window coordinates
<DT>_arc_wxy (see <A HREF="#_arc">_arc</A>)
<DD>draw an arc using window coordinates
<DT><A HREF="#_clearscreen">_clearscreen</A>
<DD>clear the screen and fill with the background color
<DT><A HREF="#_ellipse">_ellipse</A>
<DD>draw an ellipse
<DT>_ellipse_w (see <A HREF="#_ellipse">_ellipse</A>)
<DD>draw an ellipse using window coordinates
<DT>_ellipse_wxy (see <A HREF="#_ellipse">_ellipse</A>)
<DD>draw an ellipse using window coordinates
<DT><A HREF="#_floodfill">_floodfill</A>
<DD>fill an area of the screen with the current color
<DT>_floodfill_w (see <A HREF="#_floodfill">_floodfill</A>)
<DD>fill an area of the screen in window coordinates with the current color
<DT><A HREF="#_getcurrentposition">_getcurrentposition</A>
<DD>get the coordinates of the current output position
<DT>_getcurrentposition_w (see <A HREF="#_getcurrentposition">_getcurrentposition</A>)
<DD>get the window coordinates of the current output position
<DT><A HREF="#_getpixel">_getpixel</A>
<DD>get the color of the pixel at the specified position
<DT>_getpixel_w (see <A HREF="#_getpixel">_getpixel</A>)
<DD>get the color of the pixel at the specified position in window coordinates
<DT><A HREF="#_lineto">_lineto</A>
<DD>draw a line from the current position to a specified position
<DT>_lineto_w (see <A HREF="#_lineto">_lineto</A>)
<DD>draw a line from the current position to a specified position in window coordinates
<DT><A HREF="#_moveto">_moveto</A>
<DD>set the current output position
<DT>_moveto_w (see <A HREF="#_moveto">_moveto</A>)
<DD>set the current output position using window coordinates
<DT><A HREF="#_pie">_pie</A>
<DD>draw a wedge of a &quot;pie&quot;
<DT>_pie_w (see <A HREF="#_pie">_pie</A>)
<DD>draw a wedge of a &quot;pie&quot; using window coordinates
<DT>_pie_wxy (see <A HREF="#_pie">_pie</A>)
<DD>draw a wedge of a &quot;pie&quot; using window coordinates
<DT><A HREF="#_polygon">_polygon</A>
<DD>draw a polygon
<DT>_polygon_w (see <A HREF="#_polygon">_polygon</A>)
<DD>draw a polygon using window coordinates
<DT>_polygon_wxy (see <A HREF="#_polygon">_polygon</A>)
<DD>draw a polygon using window coordinates
<DT><A HREF="#_rectangle">_rectangle</A>
<DD>draw a rectangle
<DT>_rectangle_w (see <A HREF="#_rectangle">_rectangle</A>)
<DD>draw a rectangle using window coordinates
<DT>_rectangle_wxy (see <A HREF="#_rectangle">_rectangle</A>)
<DD>draw a rectangle using window coordinates
<DT><A HREF="#_setpixel">_setpixel</A>
<DD>set the color of the pixel at the specified position
<DT>_setpixel_w (see <A HREF="#_setpixel">_setpixel</A>)
<DD>set the color of the pixel at the specified position in window coordinates
</DL>
<H3 ID="Text_Routines"> Text Routines </H3>
<BR>These routines deal with displaying text in both graphics and text modes.&nbsp; This type of text output can be displayed
in only one size.
<BR><BR>This text is displayed using the <TT> _outtext</TT> and <TT> _outmem</TT> routines.&nbsp; The output position for
text follows the last text that was displayed or can be reset (see the <TT> _settextposition</TT> routine).&nbsp; Text windows
can be created (see the <TT> _settextwindow</TT> routine) in which the text will scroll.&nbsp; Text is displayed with the
current text color (see the <TT> _settextcolor</TT> routine).
<BR><BR>The following routines are defined:
<DL>
<DT><A HREF="#_clearscreen">_clearscreen</A>
<DD>clear the screen and fill with the background color
<DT><A HREF="#_displaycursor">_displaycursor</A>
<DD>determine whether the cursor is to be displayed after a graphics routine completes execution
<DT><A HREF="#_getbkcolor">_getbkcolor</A>
<DD>get the background color
<DT><A HREF="#_gettextcolor">_gettextcolor</A>
<DD>get the color used to display text
<DT><A HREF="#_gettextcursor">_gettextcursor</A>
<DD>get the shape of the text cursor
<DT><A HREF="#_gettextposition">_gettextposition</A>
<DD>get the current output position for text
<DT><A HREF="#_gettextwindow">_gettextwindow</A>
<DD>get the boundary of the current text window
<DT><A HREF="#_outmem">_outmem</A>
<DD>display a text string of a specified length
<DT><A HREF="#_outtext">_outtext</A>
<DD>display a text string
<DT><A HREF="#_scrolltextwindow">_scrolltextwindow</A>
<DD>scroll the contents of the text window
<DT><A HREF="#_setbkcolor">_setbkcolor</A>
<DD>set the background color
<DT><A HREF="#_settextcolor">_settextcolor</A>
<DD>set the color used to display text
<DT><A HREF="#_settextcursor">_settextcursor</A>
<DD>set the shape of the text cursor
<DT><A HREF="#_settextposition">_settextposition</A>
<DD>set the output position for text
<DT><A HREF="#_settextwindow">_settextwindow</A>
<DD>set the boundary of the region used to display text
<DT><A HREF="#_wrapon">_wrapon</A>
<DD>permit or disallow wrap-around of text in a text window
</DL>
<H3 ID="Graphics_Text_Routines"> Graphics Text Routines </H3>
<BR>These routines deal with displaying graphics text.&nbsp; Graphics text is displayed as a sequence of line segments, and
can be drawn in different sizes (see the <TT> _setcharsize</TT> routine), with different orientations (see the <TT> _settextorient</TT>
routine) and alignments (see the <TT> _settextalign</TT> routine).&nbsp; The routines ending with<TT> _w</TT> use the window
coordinate system; the others use the view coordinate system.
<BR><BR>The following routines are defined:
<DL>
<DT><A HREF="#_gettextextent">_gettextextent</A>
<DD>get the bounding rectangle for a graphics text string
<DT><A HREF="#_gettextsettings">_gettextsettings</A>
<DD>get information about the current settings used to display graphics text
<DT><A HREF="#_grtext">_grtext</A>
<DD>display graphics text
<DT>_grtext_w (see <A HREF="#_grtext">_grtext</A>)
<DD>display graphics text using window coordinates
<DT><A HREF="#_setcharsize">_setcharsize</A>
<DD>set the character size used to display graphics text
<DT>_setcharsize_w (see <A HREF="#_setcharsize">_setcharsize</A>)
<DD>set the character size in window coordinates used to display graphics text
<DT><A HREF="#_setcharspacing">_setcharspacing</A>
<DD>set the character spacing used to display graphics text
<DT>_setcharspacing_w (see <A HREF="#_setcharspacing">_setcharspacing</A>)
<DD>set the character spacing in window coordinates used to display graphics text
<DT><A HREF="#_settextalign">_settextalign</A>
<DD>set the alignment used to display graphics text
<DT><A HREF="#_settextorient">_settextorient</A>
<DD>set the orientation used to display graphics text
<DT><A HREF="#_settextpath">_settextpath</A>
<DD>set the path used to display graphics text
</DL>
<H3 ID="Image_Manipulation_Routines"> Image Manipulation Routines </H3>
<BR>These routines are used to transfer screen images.&nbsp; The <TT> _getimage</TT> routine transfers a rectangular image
from the screen into memory.&nbsp; The <TT> _putimage</TT> routine transfers an image from memory back onto the screen.&nbsp;
The routines ending with<TT> _w</TT> or<TT> _wxy</TT> use the window coordinate system; the others use the view coordinate
system.
<BR><BR>The following routines are defined:
<DL>
<DT><A HREF="#_getimage">_getimage</A>
<DD>store an image of an area of the screen into memory
<DT>_getimage_w (see <A HREF="#_getimage">_getimage</A>)
<DD>store an image of an area of the screen in window coordinates into memory
<DT>_getimage_wxy (see <A HREF="#_getimage">_getimage</A>)
<DD>store an image of an area of the screen in window coordinates into memory
<DT><A HREF="#_imagesize">_imagesize</A>
<DD>get the size of a screen area
<DT>_imagesize_w (see <A HREF="#_imagesize">_imagesize</A>)
<DD>get the size of a screen area in window coordinates
<DT>_imagesize_wxy (see <A HREF="#_imagesize">_imagesize</A>)
<DD>get the size of a screen area in window coordinates
<DT><A HREF="#_putimage">_putimage</A>
<DD>display an image from memory on the screen
<DT>_putimage_w (see <A HREF="#_putimage">_putimage</A>)
<DD>display an image from memory on the screen using window coordinates
</DL>
<H3 ID="Font_Manipulation_Routines"> Font Manipulation Routines </H3>
<BR>These routines are for the display of fonts compatible with Microsoft Windows.&nbsp; Fonts are contained in files with
an extension of<TT> .FON.</TT>&nbsp; Before font based text can be displayed, the fonts must be registered with the <TT> _registerfonts</TT>
routine, and a font must be selected with the <TT> _setfont</TT> routine.
<BR><BR>The following routines are defined:
<DL>
<DT><A HREF="#_getfontinfo">_getfontinfo</A>
<DD>get information about the currently selected font
<DT><A HREF="#_getgtextextent">_getgtextextent</A>
<DD>get the length in pixels of a text string
<DT><A HREF="#_getgtextvector">_getgtextvector</A>
<DD>get the current value of the font text orientation vector
<DT><A HREF="#_outgtext">_outgtext</A>
<DD>display a string of text in the current font
<DT><A HREF="#_registerfonts">_registerfonts</A>
<DD>initialize the font graphics system
<DT><A HREF="#_setfont">_setfont</A>
<DD>select a font from among the registered fonts
<DT><A HREF="#_setgtextvector">_setgtextvector</A>
<DD>set the font text orientation vector
<DT><A HREF="#_unregisterfonts">_unregisterfonts</A>
<DD>frees memory allocated by the font graphics system
</DL>
<H3 ID="Presentation_Graphics_Routines"> Presentation Graphics Routines </H3>
<BR>These routines provide a system for displaying and manipulating presentation graphics elements such as bar charts and
pie charts.&nbsp; The presentation graphics routines can be further divided into three classes:
<DL>
<DT>Display Routines
<DD>
<BR><BR>These routines are for the initialization of the presentation graphics system and the displaying of charts.
<DT>Analyze Routines
<DD>
<BR><BR>These routines calculate default values for chart elements without actually displaying the chart.
<DT>Utility Routines
<DD>
<BR><BR>These routines provide additional support to control the appearance of presentation graphics elements.
</DL>
<BR>The following subsections describe these routine classes in more detail.&nbsp; Each routine in the class is noted with
a brief description of its purpose.
<H4 ID="Display_Routines"> Display Routines </H4>
<BR>These routines are for the initialization of the presentation graphics system and the displaying of charts.&nbsp; The
<TT> _pg_initchart</TT> routine initializes the system and should be the first presentation graphics routine called.&nbsp;
The single-series routines display a single set of data on a chart; the multi-series routines (those ending with<TT> ms)</TT>
display several sets of data on the same chart.
<BR><BR>The following routines are defined:
<DL>
<DT><A HREF="#_pg_chart">_pg_chart</A>
<DD>display a bar, column or line chart
<DT>_pg_chartms (see <A HREF="#_pg_chart">_pg_chart</A>)
<DD>display a multi-series bar, column or line chart
<DT><A HREF="#_pg_chartpie">_pg_chartpie</A>
<DD>display a pie chart
<DT><A HREF="#_pg_chartscatter">_pg_chartscatter</A>
<DD>display a scatter chart
<DT>_pg_chartscatterms (see <A HREF="#_pg_chartscatter">_pg_chartscatter</A>)
<DD>display a multi-series scatter chart
<DT><A HREF="#_pg_defaultchart">_pg_defaultchart</A>
<DD>initialize the chart environment for a specific chart type
<DT><A HREF="#_pg_initchart">_pg_initchart</A>
<DD>initialize the presentation graphics system
</DL>
<H4 ID="Analyze_Routines"> Analyze Routines </H4>
<BR>These routines calculate default values for chart elements without actually displaying the chart.&nbsp; The routines ending
with<TT> ms</TT> analyze multi-series charts; the others analyze single-series charts.
<BR><BR>The following routines are defined:
<DL>
<DT><A HREF="#_pg_analyzechart">_pg_analyzechart</A>
<DD>analyze a bar, column or line chart
<DT>_pg_analyzechartms (see <A HREF="#_pg_analyzechart">_pg_analyzechart</A>)
<DD>analyze a multi-series bar, column or line chart
<DT><A HREF="#_pg_analyzepie">_pg_analyzepie</A>
<DD>analyze a pie chart
<DT><A HREF="#_pg_analyzescatter">_pg_analyzescatter</A>
<DD>analyze a scatter chart
<DT>_pg_analyzescatterms (see <A HREF="#_pg_analyzescatter">_pg_analyzescatter</A>)
<DD>analyze a multi-series scatter chart
</DL>
<H4 ID="Utility_Routines"> Utility Routines </H4>
<BR>These routines provide additional support to control the appearance of presentation graphics elements.
<BR><BR>The following routines are defined:
<DL>
<DT><A HREF="#_pg_getchardef">_pg_getchardef</A>
<DD>get bit-map definition for a specific character
<DT><A HREF="#_pg_getpalette">_pg_getpalette</A>
<DD>get presentation graphics palette (colors, line styles, fill patterns and plot characters)
<DT><A HREF="#_pg_getstyleset">_pg_getstyleset</A>
<DD>get presentation graphics style-set (line styles for window borders and grid lines)
<DT><A HREF="#_pg_hlabelchart">_pg_hlabelchart</A>
<DD>display text horizontally on a chart
<DT><A HREF="#_pg_resetpalette">_pg_resetpalette</A>
<DD>reset presentation graphics palette to default values
<DT><A HREF="#_pg_resetstyleset">_pg_resetstyleset</A>
<DD>reset presentation graphics style-set to default values
<DT><A HREF="#_pg_setchardef">_pg_setchardef</A>
<DD>set bit-map definition for a specific character
<DT><A HREF="#_pg_setpalette">_pg_setpalette</A>
<DD>set presentation graphics palette (colors, line styles, fill patterns and plot characters)
<DT><A HREF="#_pg_setstyleset">_pg_setstyleset</A>
<DD>set presentation graphics style-set (line styles for window borders and grid lines)
<DT><A HREF="#_pg_vlabelchart">_pg_vlabelchart</A>
<DD>display text vertically on a chart
</DL>
<H2 ID="Include_Files"> Include Files </H2>
<BR>All program modules which use the Graphics Library should include the file<TT> graphapi.fi.</TT>&nbsp; This file contains
definitions of all the routines in the library.&nbsp; As well, each routine should include<TT> graph.fi</TT> which contains
all the structure and constant definitions.
<BR><BR>Modules using the presentation graphics routines should also include the file<TT> pgapi.fi.</TT>&nbsp; As well, each
routine should include<TT> pg.fi.</TT>
<H1 ID="Graphics_Library_Routines"> Graphics Library Routines </H1>
<BR>This chapter contains, in alphabetical order, descriptions of the routines which comprise the graphics library.&nbsp;
Each description consists of a number of subsections:
<DL>
<DT>Synopsis:
<DD>
<BR><BR>This subsection gives an example of a declaration for the routine, showing the types of the routine and its arguments.
<DT>Description:
<DD>
<BR><BR>This subsection is a description of the routine.
<DT>Returns:
<DD>
<BR><BR>This subsection describes the return value (if any) for the routine.
<DT>See Also:
<DD>
<BR><BR>This subsection provides a list of related routines.
<DT>Example:
<DD>
<BR><BR>This subsection consists of an example program demonstrating the use of the routine.&nbsp; In some cases the output
from the program is also displayed.
<DT>Classification:
<DD>
<BR><BR>This subsection provides an indication of where the routine is commonly found.&nbsp; The following notation is used:
<DL>
<DT>PC Graphics
<DD>These &amp;routiness are part of the PC graphics library.
</DL>
<DT>Systems:
<DD>This subsection provides an indication of where the routine is supported.&nbsp; The following notation is used:
<DL>
<DT>DOS
<DD>This routine is available on both 16-bit DOS and 32-bit extended DOS.
<DT>QNX
<DD>This routine is available on QNX Software Systems' 16 or 32-bit operating systems.
</DL>
</DL>
<H2 ID="_arc"> _arc, _arc_w, _arc_wxy </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>integer*2 function _arc( x1, y1, x2, y2,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; x3, y3, x4, y4 )</TT>
<BR><TT>integer*2 x1, y1</TT>
<BR><TT>integer*2 x2, y2</TT>
<BR><TT>integer*2 x3, y3</TT>
<BR><TT>integer*2 x4, y4</TT>
<BR><BR><TT>integer*2 function _arc_w( x1, y1, x2, y2,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x3, y3, x4, y4 )</TT>
<BR><TT>double precision x1, y1</TT>
<BR><TT>double precision x2, y2</TT>
<BR><TT>double precision x3, y3</TT>
<BR><TT>double precision x4, y4</TT>
<BR><BR><TT>integer*2 function _arc_wxy( p1, p2, p3, p4 )</TT>
<BR><TT>record /_wxycoord/ p1</TT>
<BR><TT>record /_wxycoord/ p2</TT>
<BR><TT>record /_wxycoord/ p3</TT>
<BR><TT>record /_wxycoord/ p4</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _arc</TT> routines draw elliptical arcs.&nbsp; The<TT> _arc</TT> routine uses the view coordinate system.&nbsp; The<TT>
_arc_w</TT> and<TT> _arc_wxy</TT> routines use the window coordinate system.
<BR><BR>The center of the arc is the center of the rectangle established by the points<TT> (x1,y1)</TT> and<TT> (x2,y2).</TT>
&nbsp;The arc is a segment of the ellipse drawn within this bounding rectangle.&nbsp; The arc starts at the point on this
ellipse that intersects the vector from the centre of the ellipse to the point<TT> (x3,y3).</TT>&nbsp; The arc ends at the
point on this ellipse that intersects the vector from the centre of the ellipse to the point<TT> (x4,y4).</TT>&nbsp; The arc
is drawn in a counter-clockwise direction with the current plot action using the current color and the current line style.
<BR><BR>The following picture illustrates the way in which the bounding rectangle and the vectors specifying the start and
end points are defined.
<BR><BR><IMG SRC="pic1.bmp" ALIGN=MIDDLE>
<BR>When the coordinates<TT> (x1,y1)</TT> and<TT> (x2,y2)</TT> establish a line or a point (this happens when one or more
of the x-coordinates or y-coordinates are equal), nothing is drawn.
<BR><BR>The current output position for graphics output is set to be the point at the end of the arc that was drawn.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _arc</TT> routines return a non-zero value when the arc was successfully drawn; otherwise, zero is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_ellipse">_ellipse</A>, <A HREF="#_pie">_pie</A>, <A HREF="#_rectangle">_rectangle</A>, <A HREF="#_getarcinfo">_getarcinfo</A>,
<A HREF="#_setcolor">_setcolor</A>, <A HREF="#_setlinestyle">_setlinestyle</A>, <A HREF="#_setplotaction">_setplotaction</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _arc( 120, 90, 520, 390, 500, 20, 450, 460 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>produces the following:
<BR><BR><IMG SRC="eg_arc.bmp" ALIGN=MIDDLE>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD><TT> _arc - DOS</TT>
<BR><BR><TT>_arc_w - DOS</TT>
<BR><TT>_arc_wxy - DOS</TT>
</DL>
<H2 ID="_clearscreen"> _clearscreen </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>subroutine _clearscreen( area )</TT>
<BR><TT>integer*2 area</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _clearscreen</TT> routine clears the indicated<B> area</B> and fills it with the background color.&nbsp; The<B> area</B>
argument must be one of the following values:
<DL>
<DT>_GCLEARSCREEN
<DD>area is entire screen
<DT>_GVIEWPORT
<DD>area is current viewport or clip region
<DT>_GWINDOW
<DD>area is current text window
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_setbkcolor">_setbkcolor</A>, <A HREF="#_setviewport">_setviewport</A>, <A HREF="#_setcliprgn">_setcliprgn</A>,
<A HREF="#_settextwindow">_settextwindow</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _rectangle( _GFILLINTERIOR,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; 100, 100, 540, 380 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setviewport( 200, 200, 440, 280 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _clearscreen( _GVIEWPORT )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_displaycursor"> _displaycursor </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>integer*2 function _displaycursor( mode )</TT>
<BR><TT>integer*2 mode</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _displaycursor</TT> routine is used to establish whether the text cursor is to be displayed when graphics routines
complete.&nbsp; On entry to a graphics routine, the text cursor is turned off.&nbsp; When the routine completes, the<B> mode</B>
setting determines whether the cursor is turned back on.&nbsp; The<B> mode</B> argument can have one of the following values:
<DL>
<DT>_GCURSORON
<DD>the cursor will be displayed
<DT>_GCURSOROFF
<DD>the cursor will not be displayed
</DL>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _displaycursor</TT> routine returns the previous setting for<B> mode</B>.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_gettextcursor">_gettextcursor</A>, <A HREF="#_settextcursor">_settextcursor</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character*30 name</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _TEXTC80 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _settextposition( 2, 1 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _displaycursor( _GCURSORON )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _outtext( 'Cursor ON'//char(10)//char(10)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;//'Enter your name &gt;'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; read( *, '(a30)' ) name</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _displaycursor( _GCURSOROFF )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _settextposition( 6, 1 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _outtext( 'Cursor OFF'//char(10)//char(10)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;//'Enter your name &gt;'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; read( *, '(a30)' ) name</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_ellipse"> _ellipse, _ellipse_w, _ellipse_wxy </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>integer*2 function _ellipse( fill, x1, y1, x2, y2 )</TT>
<BR><TT>integer*2 fill</TT>
<BR><TT>integer*2 x1, y1</TT>
<BR><TT>integer*2 x2, y2</TT>
<BR><BR><TT>integer*2 function _ellipse_w( fill, x1, y1, x2, y2 )</TT>
<BR><TT>integer*2 fill,</TT>
<BR><TT>double precision x1, y1</TT>
<BR><TT>double precision x2, y2</TT>
<BR><BR><TT>integer*2 function _ellipse_wxy( fill, p1, p2 )</TT>
<BR><TT>integer*2 fill,</TT>
<BR><TT>record /_wxycoord/ p1, p2</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _ellipse</TT> routines draw ellipses.&nbsp; The<TT> _ellipse</TT> routine uses the view coordinate system.&nbsp; The<TT>
_ellipse_w</TT> and<TT> _ellipse_wxy</TT> routines use the window coordinate system.
<BR><BR>The center of the ellipse is the center of the rectangle established by the points<TT> (x1,y1)</TT> and<TT> (x2,y2).</TT>
<BR><BR>The argument<B> fill</B> determines whether the ellipse is filled in or has only its outline drawn.&nbsp; The argument
can have one of two values:
<DL>
<DT>_GFILLINTERIOR
<DD>fill the interior by writing pixels with the current plot action using the current color and the current fill mask
<DT>_GBORDER
<DD>leave the interior unchanged; draw the outline of the figure with the current plot action using the current color and line
style
</DL>
<BR>When the coordinates<TT> (x1,y1)</TT> and<TT> (x2,y2)</TT> establish a line or a point (this happens when one or more
of the x-coordinates or y-coordinates are equal), nothing is drawn.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _ellipse</TT> routines return a non-zero value when the ellipse was successfully drawn; otherwise, zero is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_arc">_arc</A>, <A HREF="#_rectangle">_rectangle</A>, <A HREF="#_setcolor">_setcolor</A>, <A HREF="#_setfillmask">_setfillmask</A>,
<A HREF="#_setlinestyle">_setlinestyle</A>, <A HREF="#_setplotaction">_setplotaction</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _ellipse( _GBORDER, 120, 90, 520, 390 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>produces the following:
<BR><BR><IMG SRC="eg_ellip.bmp" ALIGN=MIDDLE>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD><TT> _ellipse - DOS</TT>
<BR><BR><TT>_ellipse_w - DOS</TT>
<BR><TT>_ellipse_wxy - DOS</TT>
</DL>
<H2 ID="_floodfill"> _floodfill, _floodfill_w </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>integer*2 function _floodfill( x, y, stop_color )</TT>
<BR><TT>integer*2 x, y</TT>
<BR><TT>integer*2 stop_color</TT>
<BR><BR><TT>integer*2 function _floodfill_w( x, y, stop_color )</TT>
<BR><TT>double precision x, y</TT>
<BR><TT>integer*2 stop_color</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _floodfill</TT> routines fill an area of the screen.&nbsp; The<TT> _floodfill</TT> routine uses the view coordinate
system.&nbsp; The<TT> _floodfill_w</TT> routine uses the window coordinate system.
<BR><BR>The filling starts at the point<TT> (x,y)</TT> and continues in all directions:&nbsp; when a pixel is filled, the
neighbouring pixels (horizontally and vertically) are then considered for filling.&nbsp; Filling is done using the current
color and fill mask.&nbsp; No filling will occur if the point<TT> (x,y)</TT> lies outside the clipping region.
<BR><BR>If the argument<B> stop_color</B> is a valid pixel value, filling will occur in each direction until a pixel is encountered
with a pixel value of<B> stop_color</B>.&nbsp; The filled area will be the area around<TT> (x,y),</TT> bordered by<B> stop_color</B>.
&nbsp;No filling will occur if the point<TT> (x,y)</TT> has the pixel value<B> stop_color</B>.
<BR><BR>If<B> stop_color</B> has the value (-1), filling occurs until a pixel is encountered with a pixel value different
from the pixel value of the starting point<TT> (x,y).</TT>&nbsp; No filling will occur if the pixel value of the point<TT>
(x,y)</TT> is the current color.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _floodfill</TT> routines return zero when no filling takes place; a non-zero value is returned to indicate that filling
has occurred.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_setcliprgn">_setcliprgn</A>, <A HREF="#_setcolor">_setcolor</A>, <A HREF="#_setfillmask">_setfillmask</A>, <A HREF="#_setplotaction">_setplotaction</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setcolor( 1 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _ellipse( _GBORDER, 120, 90, 520, 390 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setcolor( 2 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _floodfill( 320, 240, 1 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD><TT> _floodfill - DOS</TT>
<BR><BR><TT>_floodfill_w - DOS</TT>
</DL>
<H2 ID="_getactivepage"> _getactivepage </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>integer*2 function _getactivepage()</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _getactivepage</TT> routine returns the number of the currently selected active graphics page.
<BR><BR>Only some combinations of video modes and hardware allow multiple pages of graphics to exist.&nbsp; When multiple
pages are supported, the active page may differ from the visual page.&nbsp; The graphics information in the visual page determines
what is displayed upon the screen.&nbsp; Animation may be accomplished by alternating the visual page.&nbsp; A graphics page
can be constructed without affecting the screen by setting the active page to be different than the visual page.
<BR><BR>The number of available video pages can be determined by using the <TT> _getvideoconfig</TT> routine.&nbsp; The default
video page is 0.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _getactivepage</TT> routine returns the number of the currently selected active graphics page.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_setactivepage">_setactivepage</A>, <A HREF="#_setvisualpage">_setvisualpage</A>, <A HREF="#_getvisualpage">_getvisualpage</A>,
<A HREF="#_getvideoconfig">_getvideoconfig</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer old_apage, old_vpage</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _HRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; old_apage = _getactivepage()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; old_vpage = _getvisualpage()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! draw an ellipse on page 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setactivepage( 0 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvisualpage( 0 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _ellipse( _GFILLINTERIOR, 100, 50,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 540, 150 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! draw a rectangle on page 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setactivepage( 1 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _rectangle( _GFILLINTERIOR, 100, 50,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 540, 150 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! display page 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvisualpage( 1 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setactivepage( old_apage )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvisualpage( old_vpage )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_getarcinfo"> _getarcinfo </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>integer*2 function _getarcinfo( start_pt, end_pt,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inside_pt )</TT>
<BR><TT>record /xycoord/ start_pt</TT>
<BR><TT>record /xycoord/ end_pt</TT>
<BR><TT>record /xycoord/ inside_pt</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _getarcinfo</TT> routine returns information about the arc most recently drawn by the <TT> _arc</TT> or <TT> _pie</TT>
routines.&nbsp; The arguments<B> start_pt</B> and<B> end_pt</B> are set to contain the endpoints of the arc.&nbsp; The argument<B>
inside_pt</B> will contain the coordinates of a point within the pie.&nbsp; The points are all specified in the view coordinate
system.
<BR><BR>The endpoints of the arc can be used to connect other lines to the arc.&nbsp; The interior point can be used to fill
the pie.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _getarcinfo</TT> routine returns a non-zero value when successful.&nbsp; If the previous arc or pie was not successfully
drawn, zero is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_arc">_arc</A>, <A HREF="#_pie">_pie</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /xycoord/ start_pt, end_pt, inside_pt</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _arc( 120, 90, 520, 390, 520, 90, 120, 390 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _getarcinfo( start_pt, end_pt, inside_pt )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _moveto( start_pt.xcoord, start_pt.ycoord )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _lineto( end_pt.xcoord, end_pt.ycoord )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>produces the following:
<BR><BR><IMG SRC="eg_getai.bmp" ALIGN=MIDDLE>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_getbkcolor"> _getbkcolor </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>integer*4 function _getbkcolor()</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _getbkcolor</TT> routine returns the current background color.&nbsp; In text modes, the background color controls
the area behind each individual character.&nbsp; In graphics modes, the background refers to the entire screen.&nbsp; The
default background color is 0.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _getbkcolor</TT> routine returns the current background color.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_setbkcolor">_setbkcolor</A>, <A HREF="#_remappalette">_remappalette</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer bk, old_bk</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer colors(16)/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _BLACK, _BLUE, _GREEN,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _CYAN, _RED, _MAGENTA,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _BROWN, _WHITE, _GRAY, _LIGHTBLUE,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _LIGHTGREEN, _LIGHTCYAN, _LIGHTRED,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _LIGHTMAGENTA, _YELLOW, _BRIGHTWHITE/</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; old_bk = _getbkcolor()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do bk = 1, 16</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setbkcolor( colors( bk ) )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enddo</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setbkcolor( old_bk )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_getcliprgn"> _getcliprgn </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>subroutine _getcliprgn( x1, y1, x2, y2 )</TT>
<BR><TT>integer*2 x1, y1</TT>
<BR><TT>integer*2 x2, y2</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _getcliprgn</TT> routine returns the location of the current clipping region.&nbsp; A clipping region is defined with
the <TT> _setcliprgn</TT> or <TT> _setviewport</TT> routines.&nbsp; By default, the clipping region is the entire screen.
<BR><BR>The current clipping region is a rectangular area of the screen to which graphics output is restricted.&nbsp; The
top left corner of the clipping region is placed in the arguments<TT> (x1,y1).</TT>&nbsp; The bottom right corner of the clipping
region is placed in<TT> (x2,y2).</TT>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_setcliprgn">_setcliprgn</A>, <A HREF="#_setviewport">_setviewport</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 x1, y1, x2, y2</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _getcliprgn( x1, y1, x2, y2 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setcliprgn( 130, 100, 510, 380 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _ellipse( _GBORDER, 120, 90, 520, 390 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setcliprgn( x1, y1, x2, y2 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_getcolor"> _getcolor </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>integer*2 function _getcolor()</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _getcolor</TT> routine returns the pixel value for the current color.&nbsp; This is the color used for displaying
graphics output.&nbsp; The default color value is one less than the maximum number of colors in the current video mode.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _getcolor</TT> routine returns the pixel value for the current color.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_setcolor">_setcolor</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer col, old_col</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; old_col = _getcolor()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do col = 0, 15</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setcolor( col )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _rectangle( _GFILLINTERIOR,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 100, 100, 540, 380 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enddo</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setcolor( old_col )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_getcurrentposition"> _getcurrentposition, _getcurrentposition_w </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>record /xycoord/ function _getcurrentposition()</TT>
<BR><BR><TT>record /_wxycoord/ function _getcurrentposition_w()</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _getcurrentposition</TT> routines return the current output position for graphics.&nbsp; The<TT> _getcurrentposition</TT>
routine returns the point in view coordinates.&nbsp; The<TT> _getcurrentposition_w</TT> routine returns the point in window
coordinates.
<BR><BR>The current position defaults to the origin,<TT> (0,0),</TT> when a new video mode is selected.&nbsp; It is changed
by successful calls to the <TT> _arc</TT>, <TT> _moveto</TT> and <TT> _lineto</TT> routines as well as the <TT> _setviewport</TT>
routine.
<BR><BR>Note that the output position for graphics output differs from that for text output.&nbsp; The output position for
text output can be set by use of the <TT> _settextposition</TT> routine.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _getcurrentposition</TT> routines return the current output position for graphics.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_moveto">_moveto</A>, <A HREF="#_settextposition">_settextposition</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /xycoord/ old_pos</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; old_pos = _getcurrentposition()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _moveto( 100, 100 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _lineto( 540, 100 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _lineto( 320, 380 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _lineto( 100, 100 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _moveto( old_pos.xcoord, old_pos.ycoord )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD><TT> _getcurrentposition - DOS</TT>
<BR><BR><TT>_getcurrentposition_w - DOS</TT>
</DL>
<H2 ID="_getfillmask"> _getfillmask </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>subroutine _getfillmask( mask )</TT>
<BR><TT>integer*1 mask(8)</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _getfillmask</TT> routine copies the current fill mask into the area located by the argument<B> mask</B>.&nbsp; The
fill mask is used by the <TT> _ellipse</TT>, <TT> _floodfill</TT>, <TT> _pie</TT>, <TT> _polygon</TT> and <TT> _rectangle</TT>
routines that fill an area of the screen.
<BR><BR>The fill mask is an eight-byte array which is interpreted as a square pattern (8 by 8) of 64 bits.&nbsp; Each bit
in the mask corresponds to a pixel.&nbsp; When a region is filled, each point in the region is mapped onto the fill mask.
&nbsp;When a bit from the mask is one, the pixel value of the corresponding point is set using the current plotting action
with the current color; when the bit is zero, the pixel value of that point is not affected.
<BR><BR>When the fill mask is not set, a fill operation will set all points in the fill region to have a pixel value of the
current color.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_floodfill">_floodfill</A>, <A HREF="#_setfillmask">_setfillmask</A>, <A HREF="#_setplotaction">_setplotaction</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*1 old_mask(8)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*1 new_mask(8)/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
'81'x, '42'x, '24'x, '18'x,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
'18'x, '24'x, '42'x, '81'x/</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _getfillmask( old_mask )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setfillmask( new_mask )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _rectangle( _GFILLINTERIOR,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; 100, 100, 540, 380 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setfillmask( old_mask )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_getfontinfo"> _getfontinfo </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>integer*2 function _getfontinfo( info )</TT>
<BR><TT>record /_fontinfo/ info</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _getfontinfo</TT> routine returns information about the currently selected font.&nbsp; Fonts are selected with the
<TT> _setfont</TT> routine.&nbsp; The font information is returned in the<TT> _fontinfo</TT> structure indicated by the argument<B>
info</B>.&nbsp; The structure contains the following fields:
<DL>
<DT>type
<DD>1 for a vector font, 0 for a bit-mapped font
<DT>ascent
<DD>distance from top of character to baseline in pixels
<DT>pixwidth
<DD>character width in pixels (0 for a proportional font)
<DT>pixheight
<DD>character height in pixels
<DT>avgwidth
<DD>average character width in pixels
<DT>filename
<DD>name of the file containing the current font
<DT>facename
<DD>name of the current font
</DL>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _getfontinfo</TT> routine returns zero if the font information is returned successfully; otherwise a negative value
is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_registerfonts">_registerfonts</A>, <A HREF="#_unregisterfonts">_unregisterfonts</A>, <A HREF="#_setfont">_setfont</A>,
<A HREF="#_outgtext">_outgtext</A>, <A HREF="#_getgtextextent">_getgtextextent</A>, <A HREF="#_setgtextvector">_setgtextvector</A>,
<A HREF="#_getgtextvector">_getgtextvector</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /_fontinfo/ info</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer width</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _getfontinfo( info )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _moveto( 100, 100 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _outgtext( 'WATCOM Graphics'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; width = _getgtextextent( 'WATCOM Graphics'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _rectangle( _GBORDER, 100, 100,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; 100 + width, 100 + info.pixheight )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_getgtextextent"> _getgtextextent </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>integer*2 function _getgtextextent( text )</TT>
<BR><TT>character*(*) text</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _getgtextextent</TT> routine returns the length in pixels of the argument<B> text</B> as it would be displayed in
the current font by the routine <TT> _outgtext</TT>.&nbsp; Note that the text is not displayed on the screen, only its length
is determined.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _getgtextextent</TT> routine returns the length in pixels of a string.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_registerfonts">_registerfonts</A>, <A HREF="#_unregisterfonts">_unregisterfonts</A>, <A HREF="#_setfont">_setfont</A>,
<A HREF="#_getfontinfo">_getfontinfo</A>, <A HREF="#_outgtext">_outgtext</A>, <A HREF="#_setgtextvector">_setgtextvector</A>,
<A HREF="#_getgtextvector">_getgtextvector</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /_fontinfo/ info</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer width</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _getfontinfo( info )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _moveto( 100, 100 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _outgtext( 'WATCOM Graphics'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; width = _getgtextextent( 'WATCOM Graphics'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _rectangle( _GBORDER, 100, 100,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; 100 + width, 100 + info.pixheight )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_getgtextvector"> _getgtextvector </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>record /xycoord/ function _getgtextvector()</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _getgtextvector</TT> routine returns the current value of the text orientation vector.&nbsp; This is the direction
used when text is displayed by the <TT> _outgtext</TT> routine.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _getgtextvector</TT> routine returns, as an<TT> xycoord</TT> structure, the current value of the text orientation
vector.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_registerfonts">_registerfonts</A>, <A HREF="#_unregisterfonts">_unregisterfonts</A>, <A HREF="#_setfont">_setfont</A>,
<A HREF="#_getfontinfo">_getfontinfo</A>, <A HREF="#_outgtext">_outgtext</A>, <A HREF="#_getgtextextent">_getgtextextent</A>,
<A HREF="#_setgtextvector">_setgtextvector</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /xycoord/ old_vec</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; old_vec = _getgtextvector()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setgtextvector( 0, -1 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _moveto( 100, 100 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _outgtext( 'WATCOM Graphics'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setgtextvector( old_vec.xcoord, old_vec.ycoord )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_getimage"> _getimage, _getimage_w, _getimage_wxy </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>subroutine _getimage( x1, y1, x2, y2, image )</TT>
<BR><TT>integer*2 x1, y1</TT>
<BR><TT>integer*2 x2, y2</TT>
<BR><TT>integer*1 image(*)</TT>
<BR><BR><TT>subroutine _getimage_w( x1, y1, x2, y2, image )</TT>
<BR><TT>double precision x1, y1</TT>
<BR><TT>double precision x2, y2</TT>
<BR><TT>integer*1 image(*)</TT>
<BR><BR><TT>subroutine _getimage_wxy( p1, p2, image )</TT>
<BR><TT>record /_wxycoord/ p1, p2</TT>
<BR><TT>integer*1 image(*)</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _getimage</TT> routines store a copy of an area of the screen into the buffer indicated by the<B> image</B> argument.
&nbsp;The<TT> _getimage</TT> routine uses the view coordinate system.&nbsp; The<TT> _getimage_w</TT> and<TT> _getimage_wxy</TT>
routines use the window coordinate system.
<BR><BR>The screen image is the rectangular area defined by the points<TT> (x1,y1)</TT> and<TT> (x2,y2).</TT>&nbsp; The buffer<B>
image</B> must be large enough to contain the image (the size of the image can be determined by using the <TT> _imagesize</TT>
routine).&nbsp; The image may be displayed upon the screen at some later time by using the <TT> _putimage</TT> routines.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_imagesize">_imagesize</A>, <A HREF="#_putimage">_putimage</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*1 image(:)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer y, image_size, istat</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _ellipse( _GFILLINTERIOR,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;100, 100, 200, 200 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; image_size = _imagesize( 100, 100, 201, 201 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; allocate( image(image_size), stat = istat )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( istat .eq. 0 )then</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _getimage( 100, 100, 201, 201, image )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _putimage( 260, 200, image, _GPSET )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _putimage( 420, 100, image, _GPSET )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do y = 100, 280, 20</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _putimage( 420, y,
image, _GXOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _putimage( 420, y+20,
image, _GXOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enddo</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; deallocate( image )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endif</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD><TT> _getimage - DOS</TT>
<BR><BR><TT>_getimage_w - DOS</TT>
<BR><TT>_getimage_wxy - DOS</TT>
</DL>
<H2 ID="_getlinestyle"> _getlinestyle </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>integer*2 function _getlinestyle()</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _getlinestyle</TT> routine returns the current line-style mask.
<BR><BR>The line-style mask determines the style by which lines and arcs are drawn.&nbsp; The mask is treated as an array
of 16 bits.&nbsp; As a line is drawn, a pixel at a time, the bits in this array are cyclically tested.&nbsp; When a bit in
the array is 1, the pixel value for the current point is set using the current color according to the current plotting action;
otherwise, the pixel value for the point is left unchanged.&nbsp; A solid line would result from a value of<TT> 'FFFF'x</TT>
and a dashed line would result from a value of<TT> 'F0F0'x.</TT>
<BR><BR>The default line style mask is<TT> 'FFFF'x.</TT>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _getlinestyle</TT> routine returns the current line-style mask.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_lineto">_lineto</A>, <A HREF="#_pie">_pie</A>, <A HREF="#_rectangle">_rectangle</A>, <A HREF="#_polygon">_polygon</A>,
<A HREF="#_setlinestyle">_setlinestyle</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer DASHED</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameter (DASHED='f0f0'x)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer old_style</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; old_style = _getlinestyle()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setlinestyle( DASHED )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _rectangle( _GBORDER, 100, 100, 540, 380 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setlinestyle( old_style )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_getphyscoord"> _getphyscoord </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>record /xycoord/ function _getphyscoord( x, y )</TT>
<BR><TT>integer*2 x, y</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _getphyscoord</TT> routine returns the physical coordinates of the position with view coordinates<TT> (x,y).</TT>
&nbsp;View coordinates are defined by the <TT> _setvieworg</TT> and <TT> _setviewport</TT> routines.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _getphyscoord</TT> routine returns the physical coordinates, as an<TT> xycoord</TT> structure, of the given point.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getviewcoord">_getviewcoord</A>, <A HREF="#_setvieworg">_setvieworg</A>, <A HREF="#_setviewport">_setviewport</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /xycoord/ pos</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real urand</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer seed</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; seed = 75347</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvieworg(</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mod( int( urand( seed )*32767 ), 640 ),</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mod( int( urand( seed )*32767 ), 480 ) )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pos = _getphyscoord( 0, 0 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _rectangle( _GBORDER,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - pos.xcoord, - pos.ycoord,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 639 - pos.xcoord, 479 - pos.ycoord
)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_getpixel"> _getpixel, _getpixel_w </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>integer*2 function _getpixel( x, y )</TT>
<BR><TT>integer*2 x, y</TT>
<BR><BR><TT>integer*2 function _getpixel_w( x, y )</TT>
<BR><TT>double precision x, y</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _getpixel</TT> routines return the pixel value for the point with coordinates<TT> (x,y).</TT>&nbsp; The<TT> _getpixel</TT>
routine uses the view coordinate system.&nbsp; The<TT> _getpixel_w</TT> routine uses the window coordinate system.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _getpixel</TT> routines return the pixel value for the given point when the point lies within the clipping region;
otherwise, (-1) is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_setpixel">_setpixel</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer x, y, i</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real urand</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer seed</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; seed = 75347</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _rectangle( _GBORDER, 100, 100, 540, 380 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do i = 0, 60000</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = 101 + mod( int( urand( seed )*32767 ),</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; 439 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y = 101 + mod( int( urand( seed )*32767 ),</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; 279 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setcolor( _getpixel( x, y ) + 1 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setpixel( x, y )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enddo</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD><TT> _getpixel - DOS</TT>
<BR><BR><TT>_getpixel_w - DOS</TT>
</DL>
<H2 ID="_getplotaction"> _getplotaction </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>integer*2 function _getplotaction()</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _getplotaction</TT> routine returns the current plotting action.
<BR><BR>The drawing routines cause pixels to be set with a pixel value.&nbsp; By default, the value to be set is obtained
by replacing the original pixel value with the supplied pixel value.&nbsp; Alternatively, the replaced value may be computed
as a function of the original and the supplied pixel values.
<BR><BR>The plotting action can have one of the following values:
<DL>
<DT>_GPSET
<DD>replace the original screen pixel value with the supplied pixel value
<DT>_GAND
<DD>replace the original screen pixel value with the<B> bitwise and</B> of the original pixel value and the supplied pixel value
<DT>_GOR
<DD>replace the original screen pixel value with the<B> bitwise or</B> of the original pixel value and the supplied pixel value
<DT>_GXOR
<DD>replace the original screen pixel value with the<B> bitwise exclusive-or</B> of the original pixel value and the supplied
pixel value.&nbsp; Performing this operation twice will restore the original screen contents, providing an efficient method
to produce animated effects.
</DL>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _getplotaction</TT> routine returns the current plotting action.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_setplotaction">_setplotaction</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer old_act</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; old_act = _getplotaction()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setplotaction( _GPSET )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _rectangle( _GFILLINTERIOR, 100, 100,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 540, 380 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setplotaction( _GXOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _rectangle( _GFILLINTERIOR, 100, 100,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 540, 380 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setplotaction( old_act )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_gettextcolor"> _gettextcolor </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>integer*2 function _gettextcolor()</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _gettextcolor</TT> routine returns the pixel value of the current text color.&nbsp; This is the color used for displaying
text with the <TT> _outtext</TT> and <TT> _outmem</TT> routines.&nbsp; The default text color value is set to 7 whenever a
new video mode is selected.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _gettextcolor</TT> routine returns the pixel value of the current text color.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_settextcolor">_settextcolor</A>, <A HREF="#_setcolor">_setcolor</A>, <A HREF="#_outtext">_outtext</A>, <A HREF="#_outmem">_outmem</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer old_col</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer old_bk</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _TEXTC80 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; old_col = _gettextcolor()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; old_bk = _getbkcolor()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _settextcolor( 7 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setbkcolor( _BLUE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _outtext( ' WATCOM '//char(10)//</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;'Graphics'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _settextcolor( old_col )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setbkcolor( old_bk )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_gettextcursor"> _gettextcursor </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>integer*2 function _gettextcursor()</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _gettextcursor</TT> routine returns the current cursor attribute, or shape.&nbsp; The cursor shape is set with the
<TT> _settextcursor</TT> routine.&nbsp; See the <TT> _settextcursor</TT> routine for a description of the value returned by
the<TT> _gettextcursor</TT> routine.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _gettextcursor</TT> routine returns the current cursor shape when successful; otherwise, (-1) is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_settextcursor">_settextcursor</A>, <A HREF="#_displaycursor">_displaycursor</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 old_shape</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; old_shape = _gettextcursor()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _settextcursor( '0007'x )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _outtext(</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char(10)//'Block cursor'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _settextcursor( '0407'x )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _outtext(</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char(10)//'Half height cursor'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _settextcursor( '2000'x )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _outtext(</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char(10)//'No cursor'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_gettextextent"> _gettextextent </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>subroutine _gettextextent( x, y, text, concat, extent )</TT>
<BR><TT>integer*2 x, y</TT>
<BR><TT>character*(*) text</TT>
<BR><TT>record /xycoord/ concat</TT>
<BR><TT>record /xycoord/ extent(4)</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _gettextextent</TT> routine simulates the effect of using the <TT> _grtext</TT> routine to display the text string<B>
text</B> at the position<TT> (x,y),</TT> using the current text settings.&nbsp; The concatenation point is returned in the
argument<B> concat</B>.&nbsp; The text extent parallelogram is returned in the array<B> extent</B>.
<BR><BR>The concatenation point is the position to use to output text after the given string.&nbsp; The text extent parallelogram
outlines the area where the text string would be displayed.&nbsp; The four points are returned in counter-clockwise order,
starting at the upper-left corner.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_grtext">_grtext</A>, <A HREF="#_gettextsettings">_gettextsettings</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /xycoord/ concat, extent(4)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _grtext( 100, 100, 'hot'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _gettextextent( 100, 100, 'hot'c,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; concat, extent )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _polygon( _GBORDER, 4, extent )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _grtext( concat.xcoord, concat.ycoord,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
'dog'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>produces the following:
<BR><BR><IMG SRC="eg_gette.bmp" ALIGN=MIDDLE>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_gettextposition"> _gettextposition </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>record /rccoord/ function _gettextposition()</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _gettextposition</TT> routine returns the current output position for text.&nbsp; This position is in terms of characters,
not pixels.
<BR><BR>The current position defaults to the top left corner of the screen,<TT> (1,1),</TT> when a new video mode is selected.
&nbsp;It is changed by successful calls to the <TT> _outtext</TT>, <TT> _outmem</TT>, <TT> _settextposition</TT> and <TT>
_settextwindow</TT> routines.
<BR><BR>Note that the output position for graphics output differs from that for text output.&nbsp; The output position for
graphics output can be set by use of the <TT> _moveto</TT> routine.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _gettextposition</TT> routine returns, as an<TT> rccoord</TT> structure, the current output position for text.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_outtext">_outtext</A>, <A HREF="#_outmem">_outmem</A>, <A HREF="#_settextposition">_settextposition</A>, <A HREF="#_settextwindow">_settextwindow</A>,
<A HREF="#_moveto">_moveto</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /rccoord/ old_pos</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _TEXTC80 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; old_pos = _gettextposition()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _settextposition( 10, 40 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _outtext( 'WATCOM Graphics'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _settextposition( old_pos.row, old_pos.col )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_gettextsettings"> _gettextsettings </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>subroutine _gettextsettings( settings )</TT>
<BR><TT>record /textsettings/ settings</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _gettextsettings</TT> routine returns information about the current text settings used when text is displayed by the
<TT> _grtext</TT> routine.&nbsp; The information is stored in the<TT> textsettings</TT> structure indicated by the argument<B>
settings</B>.&nbsp; The structure contains the following fields (all are<TT> integer*2</TT> fields):
<DL>
<DT>basevectorx
<DD>x-component of the current base vector
<DT>basevectory
<DD>y-component of the current base vector
<DT>path
<DD>current text path
<DT>height
<DD>current text height (in pixels)
<DT>width
<DD>current text width (in pixels)
<DT>spacing
<DD>current text spacing (in pixels)
<DT>horizalign
<DD>horizontal component of the current text alignment
<DT>vertalign
<DD>vertical component of the current text alignment
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_grtext">_grtext</A>, <A HREF="#_setcharsize">_setcharsize</A>, <A HREF="#_setcharspacing">_setcharspacing</A>,
<A HREF="#_settextalign">_settextalign</A>, <A HREF="#_settextpath">_settextpath</A>, <A HREF="#_settextorient">_settextorient</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /textsettings/ ts</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _gettextsettings( ts )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _grtext( 100, 100, 'WATCOM'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setcharsize( 2 * ts.height, 2 * ts.width )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _grtext( 100, 300, 'Graphics'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setcharsize( ts.height, ts.width )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_gettextwindow"> _gettextwindow </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>subroutine _gettextwindow( row1, col1, row2, col2 )</TT>
<BR><TT>integer*2 row1, col1</TT>
<BR><TT>integer*2 row2, col2</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _gettextwindow</TT> routine returns the location of the current text window.&nbsp; A text window is defined with the
<TT> _settextwindow</TT> routine.&nbsp; By default, the text window is the entire screen.
<BR><BR>The current text window is a rectangular area of the screen.&nbsp; Text display is restricted to be within this window.
&nbsp;The top left corner of the text window is placed in the arguments<TT> (row1,col1).</TT>&nbsp; The bottom right corner
of the text window is placed in<TT> (row2,col2).</TT>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_settextwindow">_settextwindow</A>, <A HREF="#_outtext">_outtext</A>, <A HREF="#_outmem">_outmem</A>, <A HREF="#_settextposition">_settextposition</A>,
<A HREF="#_scrolltextwindow">_scrolltextwindow</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer i</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 r1, c1, r2, c2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character*80 buff</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _TEXTC80 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _gettextwindow( r1, c1, r2, c2 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _settextwindow( 5, 20, 20, 40 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do i = 1, 20</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write( buff, '(''Line '', i2, a1, a1 )' )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i, char(10), char(0)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _outtext( buff )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enddo</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _settextwindow( r1, c1, r2, c2 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_getvideoconfig"> _getvideoconfig </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>subroutine _getvideoconfig( config )</TT>
<BR><TT>record /videoconfig/ config</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _getvideoconfig</TT> routine returns information about the current video mode and the hardware configuration.&nbsp;
The information is returned in the<TT> videoconfig</TT> structure indicated by the argument<B> config</B>.&nbsp; The structure
contains the following fields (all are<TT> integer*2</TT> fields):
<DL>
<DT>numxpixels
<DD>number of pixels in x-axis
<DT>numypixels
<DD>number of pixels in y-axis
<DT>numtextcols
<DD>number of text columns
<DT>numtextrows
<DD>number of text rows
<DT>numcolors
<DD>number of actual colors
<DT>bitsperpixel
<DD>number of bits in a pixel value
<DT>numvideopages
<DD>number of video pages
<DT>mode
<DD>current video mode
<DT>adapter
<DD>adapter type
<DT>monitor
<DD>monitor type
<DT>memory
<DD>number of kilobytes (1024 characters) of video memory
</DL>
<BR>The<TT> adapter</TT> field will contain one of the following values:
<DL>
<DT>_NODISPLAY
<DD>no display adapter attached
<DT>_UNKNOWN
<DD>unknown adapter/monitor type
<DT>_MDPA
<DD>Monochrome Display/Printer Adapter
<DT>_CGA
<DD>Color Graphics Adapter
<DT>_HERCULES
<DD>Hercules Monochrome Adapter
<DT>_MCGA
<DD>Multi-Color Graphics Array
<DT>_EGA
<DD>Enhanced Graphics Adapter
<DT>_VGA
<DD>Video Graphics Array
<DT>_SVGA
<DD>SuperVGA Adapter
</DL>
<BR>The<TT> monitor</TT> field will contain one of the following values:
<DL>
<DT>_MONO
<DD>regular monochrome
<DT>_COLOR
<DD>regular color
<DT>_ENHANCED
<DD>enhanced color
<DT>_ANALOGMONO
<DD>analog monochrome
<DT>_ANALOGCOLOR
<DD>analog color
</DL>
<BR>The amount of memory reported by<TT> _getvideoconfig</TT> will not always be correct for SuperVGA adapters.&nbsp; Since
it is not always possible to determine the amount of memory,<TT> _getvideoconfig</TT> will always report 256K, the minimum
amount.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_setvideomode">_setvideomode</A>, <A HREF="#_setvideomoderows">_setvideomoderows</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer mode</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /videoconfig/ vc</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character*80 buff</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _getvideoconfig( vc )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select( vc.adapter )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case( _VGA, _SVGA )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode = _VRES16COLOR</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case( _MCGA )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode = _MRES256COLOR</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case( _EGA )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( vc.monitor .eq. _MONO )then</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode = _ERESNOCOLOR</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode = _ERESCOLOR</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endif</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case( _CGA )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode = _MRES4COLOR</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case( _HERCULES )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode = _HERCMONO</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case default</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stop 'No graphics adapter'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endselect</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( _setvideomode( mode ) .ne. 0 )then</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _getvideoconfig( vc )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write( buff,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '( i3, '' x '',
i3, '' x '', i3, a1 )' )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vc.numxpixels,
vc.numypixels,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vc.numcolors, char(0)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _outtext( buff )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endif</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_getviewcoord"> _getviewcoord, _getviewcoord_w, _getviewcoord_wxy </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>record /xycoord/ function _getviewcoord( x, y )</TT>
<BR><TT>integer*2 x, y</TT>
<BR><BR><TT>record /xycoord/ function _getviewcoord_w( x, y )</TT>
<BR><TT>double precision x, y</TT>
<BR><BR><TT>record /xycoord/ function _getviewcoord_wxy( p )</TT>
<BR><TT>record /_wxycoord/ p</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _getviewcoord</TT> routines translate a point from one coordinate system to viewport coordinates.&nbsp; The<TT> _getviewcoord</TT>
routine translates the point<TT> (x,y)</TT> from physical coordinates.&nbsp; The<TT> _getviewcoord_w</TT> and<TT> _getviewcoord_wxy</TT>
routines translate the point from the window coordinate system.
<BR><BR>Viewport coordinates are defined by the <TT> _setvieworg</TT> and <TT> _setviewport</TT> routines.&nbsp; Window coordinates
are defined by the <TT> _setwindow</TT> routine.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _getviewcoord</TT> routines return the viewport coordinates, as an<TT> xycoord</TT> structure, of the given point.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getphyscoord">_getphyscoord</A>, <A HREF="#_setvieworg">_setvieworg</A>, <A HREF="#_setviewport">_setviewport</A>,
<A HREF="#_setwindow">_setwindow</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /xycoord/ pos1, pos2</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer seed</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real urand</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; seed = 75347</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvieworg(</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mod( int( urand( seed )*32767 ), 640 ),</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mod( int( urand( seed )*32767 ), 480 ) )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pos1 = _getviewcoord( 0, 0 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pos2 = _getviewcoord( 639, 479 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _rectangle( _GBORDER,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; pos1.xcoord, pos1.ycoord,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; pos2.xcoord, pos2.ycoord )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD><TT> _getviewcoord - DOS</TT>
<BR><BR><TT>_getviewcoord_w - DOS</TT>
<BR><TT>_getviewcoord_wxy - DOS</TT>
</DL>
<H2 ID="_getvisualpage"> _getvisualpage </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>integer*2 function _getvisualpage()</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _getvisualpage</TT> routine returns the number of the currently selected visual graphics page.
<BR><BR>Only some combinations of video modes and hardware allow multiple pages of graphics to exist.&nbsp; When multiple
pages are supported, the active page may differ from the visual page.&nbsp; The graphics information in the visual page determines
what is displayed upon the screen.&nbsp; Animation may be accomplished by alternating the visual page.&nbsp; A graphics page
can be constructed without affecting the screen by setting the active page to be different than the visual page.
<BR><BR>The number of available video pages can be determined by using the <TT> _getvideoconfig</TT> routine.&nbsp; The default
video page is 0.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _getvisualpage</TT> routine returns the number of the currently selected visual graphics page.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_setvisualpage">_setvisualpage</A>, <A HREF="#_setactivepage">_setactivepage</A>, <A HREF="#_getactivepage">_getactivepage</A>,
<A HREF="#_getvideoconfig">_getvideoconfig</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer old_apage, old_vpage</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _HRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; old_apage = _getactivepage()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; old_vpage = _getvisualpage()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! draw an ellipse on page 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setactivepage( 0 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvisualpage( 0 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _ellipse( _GFILLINTERIOR, 100, 50,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 540, 150 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! draw a rectangle on page 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setactivepage( 1 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _rectangle( _GFILLINTERIOR, 100, 50,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 540, 150 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! display page 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvisualpage( 1 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setactivepage( old_apage )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvisualpage( old_vpage )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_getwindowcoord"> _getwindowcoord </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>record /_wxycoord/ function _getwindowcoord( x, y )</TT>
<BR><TT>integer*2 x, y</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _getwindowcoord</TT> routine returns the window coordinates of the position with view coordinates<TT> (x,y).</TT>
&nbsp;Window coordinates are defined by the <TT> _setwindow</TT> routine.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _getwindowcoord</TT> routine returns the window coordinates, as a<TT> _wxycoord</TT> structure, of the given point.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_setwindow">_setwindow</A>, <A HREF="#_getviewcoord">_getviewcoord</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /xycoord/ centre</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /_wxycoord/ pos1, pos2</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _MAXRESMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! draw a box 50 pixels square</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! in the middle of the screen</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; centre = _getviewcoord_w( 0.5, 0.5 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pos1 = _getwindowcoord( centre.xcoord - 25,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; centre.ycoord - 25 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pos2 = _getwindowcoord( centre.xcoord + 25,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; centre.ycoord + 25 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _rectangle_wxy( _GBORDER, pos1, pos2 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_grstatus"> _grstatus </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>integer*2 function _grstatus()</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _grstatus</TT> routine returns the status of the most recently called graphics library routine.&nbsp; The routine
can be called after any graphics routine to determine if any errors or warnings occurred.&nbsp; The routine returns 0 if the
previous routine was successful.&nbsp; Values less than 0 indicate an error occurred; values greater than 0 indicate a warning
condition.
<BR><BR>The following values can be returned:&nbsp; uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 uindex=2
uindex=2 uindex=2 
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Constant&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Value
&nbsp;Explanation</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _GROK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp; no error</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _GRERROR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-1&nbsp;&nbsp;&nbsp; graphics error</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _GRMODENOTSUPPORTED&nbsp;&nbsp;&nbsp; -2&nbsp;&nbsp;&nbsp; video mode not supported</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _GRNOTINPROPERMODE&nbsp;&nbsp;&nbsp;&nbsp; -3&nbsp;&nbsp;&nbsp; routine n/a in this mode</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _GRINVALIDPARAMETER&nbsp;&nbsp;&nbsp; -4&nbsp;&nbsp;&nbsp; invalid parameter(s)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _GRINSUFFICIENTMEMORY&nbsp; -5&nbsp;&nbsp;&nbsp; out of memory</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _GRFONTFILENOTFOUND&nbsp;&nbsp;&nbsp; -6&nbsp;&nbsp;&nbsp; can't open font file</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _GRINVALIDFONTFILE&nbsp;&nbsp;&nbsp;&nbsp; -7&nbsp;&nbsp;&nbsp; font file has invalid format</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _GRNOOUTPUT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;
&nbsp; nothing was done</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _GRCLIPPED&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
2&nbsp;&nbsp;&nbsp; output clipped</TT>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _grstatus</TT> routine returns the status of the most recently called graphics library routine.
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer x, y</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real urand</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer seed</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; seed = 75347</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( _grstatus() .eq. _GROK )do</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = mod( int( urand( seed )*32767 ), 700 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y = mod( int( urand( seed )*32767 ), 500 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setpixel( x, y )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endwhile</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_grtext"> _grtext, _grtext_w </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>integer*2 function _grtext( x, y, text )</TT>
<BR><TT>integer*2 x, y</TT>
<BR><TT>character*(*) text</TT>
<BR><BR><TT>integer*2 function _grtext_w( x, y, text )</TT>
<BR><TT>double precision x, y</TT>
<BR><TT>character*(*) text</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _grtext</TT> routines display a character string.&nbsp; The<TT> _grtext</TT> routine uses the view coordinate system.
&nbsp;The<TT> _grtext_w</TT> routine uses the window coordinate system.
<BR><BR>The character string<B> text</B> is displayed at the point<TT> (x,y).</TT>&nbsp; The string must be terminated by
a null character (char(0)).&nbsp; The text is displayed in the current color using the current text settings.
<BR><BR>The graphics library can display text in three different ways.
<OL>
<LI>The <TT> _outtext</TT> and <TT> _outmem</TT> routines can be used in any video mode.&nbsp; However, this variety of text
can be displayed in only one size.
<LI>The <TT> _grtext</TT> routine displays text as a sequence of line segments, and can be drawn in different sizes, with
different orientations and alignments.
<LI>The <TT> _outgtext</TT> routine displays text in the currently selected font.&nbsp; Both bit-mapped and vector fonts are
supported; the size and type of text depends on the fonts that are available.
</OL>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _grtext</TT> routines return a non-zero value when the text was successfully drawn; otherwise, zero is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_outtext">_outtext</A>, <A HREF="#_outmem">_outmem</A>, <A HREF="#_outgtext">_outgtext</A>, <A HREF="#_setcharsize">_setcharsize</A>,
<A HREF="#_settextalign">_settextalign</A>, <A HREF="#_settextpath">_settextpath</A>, <A HREF="#_settextorient">_settextorient</A>,
<A HREF="#_setcharspacing">_setcharspacing</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _grtext( 200, 100, ' WATCOM'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _grtext( 200, 200, 'Graphics'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>produces the following:
<BR><BR><IMG SRC="eg_grtxt.bmp" ALIGN=MIDDLE>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD><TT> _grtext - DOS</TT>
<BR><BR><TT>_grtext_w - DOS</TT>
</DL>
<H2 ID="_imagesize"> _imagesize, _imagesize_w, _imagesize_wxy </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>integer*4 function _imagesize( x1, y1, x2, y2 )</TT>
<BR><TT>integer*2 x1, y1</TT>
<BR><TT>integer*2 x2, y2</TT>
<BR><BR><TT>integer*4 function _imagesize_w( x1, y1, x2, y2 )</TT>
<BR><TT>double precision x1, y1</TT>
<BR><TT>double precision x2, y2</TT>
<BR><BR><TT>integer*4 function _imagesize_wxy( p1, p2 )</TT>
<BR><TT>record /_wxycoord/ p1, p2</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _imagesize</TT> routines compute the number of bytes required to store a screen image.&nbsp; The<TT> _imagesize</TT>
routine uses the view coordinate system.&nbsp; The<TT> _imagesize_w</TT> and<TT> _imagesize_wxy</TT> routines use the window
coordinate system.
<BR><BR>The screen image is the rectangular area defined by the points<TT> (x1,y1)</TT> and<TT> (x2,y2).</TT>&nbsp; The storage
area used by the <TT> _getimage</TT> routines must be at least this large (in bytes).
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _imagesize</TT> routines return the size of a screen image.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getimage">_getimage</A>, <A HREF="#_putimage">_putimage</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*1 image(:)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer y, image_size, istat</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _ellipse( _GFILLINTERIOR,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;100, 100, 200, 200 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; image_size = _imagesize( 100, 100, 201, 201 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; allocate( image(image_size), stat = istat )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( istat .eq. 0 )then</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _getimage( 100, 100, 201, 201, image )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _putimage( 260, 200, image, _GPSET )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _putimage( 420, 100, image, _GPSET )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do y = 100, 280, 20</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _putimage( 420, y,
image, _GXOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _putimage( 420, y+20,
image, _GXOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enddo</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; deallocate( image )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endif</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD><TT> _imagesize - DOS</TT>
<BR><BR><TT>_imagesize_w - DOS</TT>
<BR><TT>_imagesize_wxy - DOS</TT>
</DL>
<H2 ID="_lineto"> _lineto, _lineto_w </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>integer*2 function _lineto( x, y )</TT>
<BR><TT>integer*2 x, y</TT>
<BR><BR><TT>integer*2 function _lineto_w( x, y )</TT>
<BR><TT>double precision x, y</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _lineto</TT> routines draw straight lines.&nbsp; The<TT> _lineto</TT> routine uses the view coordinate system.&nbsp;
The<TT> _lineto_w</TT> routine uses the window coordinate system.
<BR><BR>The line is drawn from the current position to the point at the coordinates<TT> (x,y).</TT>&nbsp; The point<TT> (x,y)</TT>
becomes the new current position.&nbsp; The line is drawn with the current plotting action using the current line style and
the current color.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _lineto</TT> routines return a non-zero value when the line was successfully drawn; otherwise, zero is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_moveto">_moveto</A>, <A HREF="#_setcolor">_setcolor</A>, <A HREF="#_setlinestyle">_setlinestyle</A>, <A HREF="#_setplotaction">_setplotaction</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _moveto( 100, 100 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _lineto( 540, 100 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _lineto( 320, 380 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _lineto( 100, 100 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>produces the following:
<BR><BR><IMG SRC="eg_movto.bmp" ALIGN=MIDDLE>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD><TT> _lineto - DOS</TT>
<BR><BR><TT>_lineto_w - DOS</TT>
</DL>
<H2 ID="_moveto"> _moveto, _moveto_w </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>record /xycoord/ function _moveto( x, y )</TT>
<BR><TT>integer*2 x, y</TT>
<BR><BR><TT>record /_wxycoord/ function _moveto_w( x, y )</TT>
<BR><TT>double precision x, y</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _moveto</TT> routines set the current output position for graphics.&nbsp; The<TT> _moveto</TT> routine uses the view
coordinate system.&nbsp; The<TT> _moveto_w</TT> routine uses the window coordinate system.
<BR><BR>The current output position is set to be the point at the coordinates<TT> (x,y).</TT>&nbsp; Nothing is drawn by the
routine.&nbsp; The <TT> _lineto</TT> routine uses the current output position as the starting point when a line is drawn.
<BR><BR>Note that the output position for graphics output differs from that for text output.&nbsp; The output position for
text output can be set by use of the <TT> _settextposition</TT> routine.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _moveto</TT> routines return the previous value of the output position for graphics.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getcurrentposition">_getcurrentposition</A>, <A HREF="#_lineto">_lineto</A>, <A HREF="#_settextposition">_settextposition</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _moveto( 100, 100 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _lineto( 540, 100 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _lineto( 320, 380 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _lineto( 100, 100 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD><TT> _moveto - DOS</TT>
<BR><BR><TT>_moveto_w - DOS</TT>
</DL>
<H2 ID="_outgtext"> _outgtext </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>subroutine _outgtext( text )</TT>
<BR><TT>character*(*) text</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _outgtext</TT> routine displays the character string indicated by the argument<B> text</B>.&nbsp; The string must
be terminated by a null character (char(0)).
<BR><BR>The string is displayed starting at the current position (see the <TT> _moveto</TT> routine) in the current color
and in the currently selected font (see the <TT> _setfont</TT> routine).&nbsp; The current position is updated to follow the
displayed text.
<BR><BR>When no font has been previously selected with <TT> _setfont</TT>, a default font will be used.&nbsp; The default
font is an 8-by-8 bit-mapped font.
<BR><BR>The graphics library can display text in three different ways.
<OL>
<LI>The <TT> _outtext</TT> and <TT> _outmem</TT> routines can be used in any video mode.&nbsp; However, this variety of text
can be displayed in only one size.
<LI>The <TT> _grtext</TT> routine displays text as a sequence of line segments, and can be drawn in different sizes, with
different orientations and alignments.
<LI>The <TT> _outgtext</TT> routine displays text in the currently selected font.&nbsp; Both bit-mapped and vector fonts are
supported; the size and type of text depends on the fonts that are available.
</OL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_registerfonts">_registerfonts</A>, <A HREF="#_unregisterfonts">_unregisterfonts</A>, <A HREF="#_setfont">_setfont</A>,
<A HREF="#_getfontinfo">_getfontinfo</A>, <A HREF="#_getgtextextent">_getgtextextent</A>, <A HREF="#_setgtextvector">_setgtextvector</A>,
<A HREF="#_getgtextvector">_getgtextvector</A>, <A HREF="#_outtext">_outtext</A>, <A HREF="#_outmem">_outmem</A>, <A HREF="#_grtext">_grtext</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer i, n</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character*10 buff</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n = _registerfonts( '*.fon'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do i = 0, n - 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write( buff, '(''n'', i2.2, a1 )' ) i, char(0)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setfont( buff )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _moveto( 100, 100 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _outgtext( 'WATCOM Graphics'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _clearscreen( _GCLEARSCREEN )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enddo</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _unregisterfonts()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_outmem"> _outmem </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>subroutine _outmem( text, length )</TT>
<BR><TT>character*(*) text</TT>
<BR><TT>integer*2 length</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _outmem</TT> routine displays the character string indicated by the argument<B> text</B>.&nbsp; The argument<B> length</B>
specifies the number of characters to be displayed.&nbsp; Unlike the <TT> _outtext</TT> routine,<TT> _outmem</TT> will display
the graphical representation of characters such as ASCII 10 and 0, instead of interpreting them as control characters.
<BR><BR>The text is displayed using the current text color (see the <TT> _settextcolor</TT> routine), starting at the current
text position (see the <TT> _settextposition</TT> routine).&nbsp; The text position is updated to follow the end of the displayed
text.
<BR><BR>The graphics library can display text in three different ways.
<OL>
<LI>The <TT> _outtext</TT> and <TT> _outmem</TT> routines can be used in any video mode.&nbsp; However, this variety of text
can be displayed in only one size.
<LI>The <TT> _grtext</TT> routine displays text as a sequence of line segments, and can be drawn in different sizes, with
different orientations and alignments.
<LI>The <TT> _outgtext</TT> routine displays text in the currently selected font.&nbsp; Both bit-mapped and vector fonts are
supported; the size and type of text depends on the fonts that are available.
</OL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_settextcolor">_settextcolor</A>, <A HREF="#_settextposition">_settextposition</A>, <A HREF="#_settextwindow">_settextwindow</A>,
<A HREF="#_grtext">_grtext</A>, <A HREF="#_outtext">_outtext</A>, <A HREF="#_outgtext">_outgtext</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer i</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character*20 buf</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _clearscreen( _GCLEARSCREEN )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do i = 0, 255</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _settextposition( 1 + mod( i, 16 ),</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 + 5 * ( i / 16 ) )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buf( 1:1 ) = char( i )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _outmem( buf, 1 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enddo</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_outtext"> _outtext </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>subroutine _outtext( text )</TT>
<BR><TT>character*(*) text</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _outtext</TT> routine displays the character string indicated by the argument<B> text</B>.&nbsp; The string must be
terminated by a null character (char(0)).&nbsp; When a line-feed character (char(10)) is encountered in the string, the characters
following will be displayed on the next row of the screen.
<BR><BR>The text is displayed using the current text color (see the <TT> _settextcolor</TT> routine), starting at the current
text position (see the <TT> _settextposition</TT> routine).&nbsp; The text position is updated to follow the end of the displayed
text.
<BR><BR>The graphics library can display text in three different ways.
<OL>
<LI>The <TT> _outtext</TT> and <TT> _outmem</TT> routines can be used in any video mode.&nbsp; However, this variety of text
can be displayed in only one size.
<LI>The <TT> _grtext</TT> routine displays text as a sequence of line segments, and can be drawn in different sizes, with
different orientations and alignments.
<LI>The <TT> _outgtext</TT> routine displays text in the currently selected font.&nbsp; Both bit-mapped and vector fonts are
supported; the size and type of text depends on the fonts that are available.
</OL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_settextcolor">_settextcolor</A>, <A HREF="#_settextposition">_settextposition</A>, <A HREF="#_settextwindow">_settextwindow</A>,
<A HREF="#_grtext">_grtext</A>, <A HREF="#_outmem">_outmem</A>, <A HREF="#_outgtext">_outgtext</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _TEXTC80 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _settextposition( 10, 30 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _outtext( 'WATCOM Graphics'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_pg_analyzechart"> _pg_analyzechart, _pg_analyzechartms </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>integer*2 function _pg_analyzechart( env, cat, values, n )</TT>
<BR><TT>record /chartenv/ env</TT>
<BR><TT>integer*4 cat(*)</TT>
<BR><TT>real values(*)</TT>
<BR><TT>integer*2 n</TT>
<BR><BR><TT>integer*2 function _pg_analyzechartms( env, cat, values,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nseries, n,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dim, labels )</TT>
<BR><TT>record /chartenv/ env</TT>
<BR><TT>integer*4 cat(*)</TT>
<BR><TT>real values(*)</TT>
<BR><TT>integer*2 nseries, n, dim</TT>
<BR><TT>integer*4 labels(*)</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _pg_analyzechart</TT> routines analyze either a single-series or a multi-series bar, column or line chart.&nbsp; These
routines calculate default values for chart elements without actually displaying the chart.
<BR><BR>The<TT> _pg_analyzechart</TT> routine analyzes a single-series bar, column or line chart.&nbsp; The chart environment
structure<B> env</B> is filled with default values based on the type of chart and the values of the<B> cat</B> and<B> values</B>
arguments.&nbsp; The arguments are the same as for the <TT> _pg_chart</TT> routine.
<BR><BR>The<TT> _pg_analyzechartms</TT> routine analyzes a multi-series bar, column or line chart.&nbsp; The chart environment
structure<B> env</B> is filled with default values based on the type of chart and the values of the<B> cat</B>,<B> values</B>
and<B> labels</B> arguments.&nbsp; The arguments are the same as for the <TT> _pg_chartms</TT> routine.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _pg_analyzechart</TT> routines return zero if successful; otherwise, a non-zero value is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_pg_defaultchart">_pg_defaultchart</A>, <A HREF="#_pg_initchart">_pg_initchart</A>, <A HREF="#_pg_chart">_pg_chart</A>,
<A HREF="#_pg_chartpie">_pg_chartpie</A>, <A HREF="#_pg_chartscatter">_pg_chartscatter</A>, <A HREF="#_pg_analyzepie">_pg_analyzepie</A>,
<A HREF="#_pg_analyzescatter">_pg_analyzescatter</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pgapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pg.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer NUM_VALUES</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameter (NUM_VALUES=4)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 categories( NUM_VALUES )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real values( NUM_VALUES )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / 20, 45,
30, 25 /</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /chartenv/ env</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 1 ) = loc( 'Jan'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 2 ) = loc( 'Feb'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 3 ) = loc( 'Mar'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 4 ) = loc( 'Apr'c )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_initchart()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_defaultchart( env,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; _PG_COLUMNCHART, _PG_PLAINBARS )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env.maintitle.title = 'Column Chart'c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_analyzechart( env, categories,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; values, NUM_VALUES )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! use manual scaling</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env.yaxis.autoscale = 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env.yaxis.scalemin = 0.0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env.yaxis.scalemax = 100.0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env.yaxis.ticinterval = 25.0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_chart( env, categories,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; values, NUM_VALUES )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD><TT> _pg_analyzechart - DOS</TT>
<BR><BR><TT>_pg_analyzechartms - DOS</TT>
</DL>
<H2 ID="_pg_analyzepie"> _pg_analyzepie </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>integer*2 function _pg_analyzepie( env, cat, values,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; explode, n )</TT>
<BR><TT>record /chartenv/ env</TT>
<BR><TT>integer*4 cat(*)</TT>
<BR><TT>real values(*)</TT>
<BR><TT>integer*2 explode(*), n</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _pg_analyzepie</TT> routine analyzes a pie chart.&nbsp; This routine calculates default values for chart elements
without actually displaying the chart.
<BR><BR>The chart environment structure<B> env</B> is filled with default values based on the values of the<B> cat</B>,<B>
values</B> and<B> explode</B> arguments.&nbsp; The arguments are the same as for the <TT> _pg_chartpie</TT> routine.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _pg_analyzepie</TT> routine returns zero if successful; otherwise, a non-zero value is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_pg_defaultchart">_pg_defaultchart</A>, <A HREF="#_pg_initchart">_pg_initchart</A>, <A HREF="#_pg_chart">_pg_chart</A>,
<A HREF="#_pg_chartpie">_pg_chartpie</A>, <A HREF="#_pg_chartscatter">_pg_chartscatter</A>, <A HREF="#_pg_analyzechart">_pg_analyzechart</A>,
<A HREF="#_pg_analyzescatter">_pg_analyzescatter</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pgapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pg.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer NUM_VALUES</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameter (NUM_VALUES=4)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 categories( NUM_VALUES )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real values( NUM_VALUES )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / 20, 45,
30, 25 /</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 explode( NUM_VALUES )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / 1, 0, 0,
0 /</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /chartenv/ env</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 1 ) = loc( 'Jan'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 2 ) = loc( 'Feb'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 3 ) = loc( 'Mar'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 4 ) = loc( 'Apr'c )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_initchart()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_defaultchart( env,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; _PG_PIECHART, _PG_NOPERCENT )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env.maintitle.title = 'Pie Chart'c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env.legend.place = _PG_BOTTOM</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_analyzepie( env, categories,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; values, explode, NUM_VALUES )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! make legend window same width as data window</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env.legend.autosize = 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env.legend.legendwindow.x1 = env.datawindow.x1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env.legend.legendwindow.x2 = env.datawindow.x2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_chartpie( env, categories,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; values, explode, NUM_VALUES )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_pg_analyzescatter"> _pg_analyzescatter, _pg_analyzescatterms </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>integer*2 function _pg_analyzescatter( env, x, y, n )</TT>
<BR><TT>record /chartenv/ env</TT>
<BR><TT>real x(*), y(*)</TT>
<BR><TT>integer*2 n</TT>
<BR><BR><TT>integer*2 function _pg_analyzescatterms( env, x, y,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nseries,
n,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dim,
labels )</TT>
<BR><TT>record /chartenv/ env</TT>
<BR><TT>real x(*), y(*)</TT>
<BR><TT>integer*2 nseries, n, dim</TT>
<BR><TT>integer*4 labels(*)</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _pg_analyzescatter</TT> routines analyze either a single-series or a multi-series scatter chart.&nbsp; These routines
calculate default values for chart elements without actually displaying the chart.
<BR><BR>The<TT> _pg_analyzescatter</TT> routine analyzes a single-series scatter chart.&nbsp; The chart environment structure<B>
env</B> is filled with default values based on the values of the<B> x</B> and<B> y</B> arguments.&nbsp; The arguments are
the same as for the <TT> _pg_chartscatter</TT> routine.
<BR><BR>The<TT> _pg_analyzescatterms</TT> routine analyzes a multi-series scatter chart.&nbsp; The chart environment structure<B>
env</B> is filled with default values based on the values of the<B> x</B>,<B> y</B> and<B> labels</B> arguments.&nbsp; The
arguments are the same as for the <TT> _pg_chartscatterms</TT> routine.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _pg_analyzescatter</TT> routines return zero if successful; otherwise, a non-zero value is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_pg_defaultchart">_pg_defaultchart</A>, <A HREF="#_pg_initchart">_pg_initchart</A>, <A HREF="#_pg_chart">_pg_chart</A>,
<A HREF="#_pg_chartpie">_pg_chartpie</A>, <A HREF="#_pg_chartscatter">_pg_chartscatter</A>, <A HREF="#_pg_analyzechart">_pg_analyzechart</A>,
<A HREF="#_pg_analyzepie">_pg_analyzepie</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pgapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pg.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer NUM_VALUES</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameter (NUM_VALUES=4)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer NUM_SERIES</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameter (NUM_SERIES=2)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 labels( NUM_SERIES )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real x( NUM_SERIES, NUM_VALUES )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / 5, 15,
30, 40, 10, 20, 30, 45 /</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real y( NUM_SERIES, NUM_VALUES )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / 10, 15,
30, 45, 40, 30, 15, 5 /</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /chartenv/ env</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; labels( 1 ) = loc( 'Jan'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; labels( 2 ) = loc( 'Feb'c )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_initchart()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_defaultchart( env,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
_PG_SCATTERCHART, _PG_POINTANDLINE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env.maintitle.title = 'Scatter Chart'c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_analyzescatterms( env, x, y, NUM_SERIES,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; NUM_VALUES, NUM_VALUES, labels )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! display x-axis labels with 2 decimal places</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env.xaxis.autoscale = 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env.xaxis.ticdecimals = 2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_chartscatterms( env, x, y, NUM_SERIES,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; NUM_VALUES, NUM_VALUES, labels )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD><TT> _pg_analyzescatter - DOS</TT>
<BR><BR><TT>_pg_analyzescatterms - DOS</TT>
</DL>
<H2 ID="_pg_chart"> _pg_chart, _pg_chartms </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>integer*2 function _pg_chart( env, cat, values, n )</TT>
<BR><TT>record /chartenv/ env</TT>
<BR><TT>integer*4 cat(*)</TT>
<BR><TT>real values(*)</TT>
<BR><TT>integer*2 n</TT>
<BR><BR><TT>integer*2 function _pg_chartms( env, cat, values, nseries,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n, dim, labels )</TT>
<BR><TT>record /chartenv/ env</TT>
<BR><TT>integer*4 cat(*)</TT>
<BR><TT>real values(*)</TT>
<BR><TT>integer*2 nseries, n, dim</TT>
<BR><TT>integer*4 labels(*)</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _pg_chart</TT> routines display either a single-series or a multi-series bar, column or line chart.&nbsp; The type
of chart displayed and other chart options are contained in the<B> env</B> argument.&nbsp; The argument<B> cat</B> is an array
of addresses of strings.&nbsp; These strings describe the categories against which the data in the<B> values</B> array is
charted.
<BR><BR>The<TT> _pg_chart</TT> routine displays a bar, column or line chart from the single series of data contained in the<B>
values</B> array.&nbsp; The argument<B> n</B> specifies the number of values to chart.
<BR><BR>The<TT> _pg_chartms</TT> routine displays a multi-series bar, column or line chart.&nbsp; The argument<B> nseries</B>
specifies the number of series of data to chart.&nbsp; The argument<B> values</B> is assumed to be a two-dimensional array
defined as follows:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; real values( nseries, dim )</TT>
<BR><BR>The number of values used from each series is given by the argument<B> n</B>, where<B> n</B> is less than or equal
to<B> dim</B>.&nbsp; The argument<B> labels</B> is an array of addresses of strings.&nbsp; These strings describe each of
the series and are used in the chart legend.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _pg_chart</TT> routines return zero if successful; otherwise, a non-zero value is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_pg_defaultchart">_pg_defaultchart</A>, <A HREF="#_pg_initchart">_pg_initchart</A>, <A HREF="#_pg_chartpie">_pg_chartpie</A>,
<A HREF="#_pg_chartscatter">_pg_chartscatter</A>, <A HREF="#_pg_analyzechart">_pg_analyzechart</A>, <A HREF="#_pg_analyzepie">_pg_analyzepie</A>,
<A HREF="#_pg_analyzescatter">_pg_analyzescatter</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pgapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pg.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer NUM_VALUES</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameter (NUM_VALUES=4)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 categories( NUM_VALUES )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real values( NUM_VALUES )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / 20, 45,
30, 25 /</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /chartenv/ env</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 1 ) = loc( 'Jan'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 2 ) = loc( 'Feb'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 3 ) = loc( 'Mar'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 4 ) = loc( 'Apr'c )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_initchart()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_defaultchart( env,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; _PG_COLUMNCHART, _PG_PLAINBARS )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env.maintitle.title = 'Column Chart'c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_chart( env, categories,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; values, NUM_VALUES )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>produces the following:
<BR><BR><IMG SRC="eg_pgc.bmp" ALIGN=MIDDLE>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD><TT> _pg_chart - DOS</TT>
<BR><BR><TT>_pg_chartms - DOS</TT>
</DL>
<H2 ID="_pg_chartpie"> _pg_chartpie </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>integer*2 function _pg_chartpie( env, cat, values, explode, n )</TT>
<BR><TT>record /chartenv/ env</TT>
<BR><TT>integer*4 cat(*)</TT>
<BR><TT>real values(*)</TT>
<BR><TT>integer*2 explode(*), n</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _pg_chartpie</TT> routine displays a pie chart.&nbsp; The chart is displayed using the options specified in the<B>
env</B> argument.
<BR><BR>The pie chart is created from the data contained in the<B> values</B> array.&nbsp; The argument<B> n</B> specifies
the number of values to chart.
<BR><BR>The argument<B> cat</B> is an array of addresses of strings.&nbsp; These strings describe each of the pie slices and
are used in the chart legend.&nbsp; The argument<B> explode</B> is an array of values corresponding to each of the pie slices.
&nbsp;For each non-zero element in the array, the corresponding pie slice is drawn &quot;exploded&quot;, or slightly offset
from the rest of the pie.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _pg_chartpie</TT> routine returns zero if successful; otherwise, a non-zero value is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_pg_defaultchart">_pg_defaultchart</A>, <A HREF="#_pg_initchart">_pg_initchart</A>, <A HREF="#_pg_chart">_pg_chart</A>,
<A HREF="#_pg_chartscatter">_pg_chartscatter</A>, <A HREF="#_pg_analyzechart">_pg_analyzechart</A>, <A HREF="#_pg_analyzepie">_pg_analyzepie</A>,
<A HREF="#_pg_analyzescatter">_pg_analyzescatter</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pgapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pg.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer NUM_VALUES</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameter (NUM_VALUES=4)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 categories( NUM_VALUES )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real values( NUM_VALUES )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / 20, 45,
30, 25 /</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 explode( NUM_VALUES )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / 1, 0, 0,
0 /</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /chartenv/ env</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 1 ) = loc( 'Jan'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 2 ) = loc( 'Feb'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 3 ) = loc( 'Mar'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 4 ) = loc( 'Apr'c )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_initchart()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_defaultchart( env,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; _PG_PIECHART, _PG_NOPERCENT )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env.maintitle.title = 'Pie Chart'c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_chartpie( env, categories,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; values, explode, NUM_VALUES )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>produces the following:
<BR><BR><IMG SRC="eg_pgcp.bmp" ALIGN=MIDDLE>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_pg_chartscatter"> _pg_chartscatter, _pg_chartscatterms </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>integer*2 function _pg_chartscatter( env, x, y, n )</TT>
<BR><TT>record /chartenv/ env</TT>
<BR><TT>float x(*), y(*)</TT>
<BR><TT>integer*2 n</TT>
<BR><BR><TT>integer*2 function _pg_chartscatterms( env, x, y, nseries,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n, dim, labels
)</TT>
<BR><TT>record /chartenv/ env</TT>
<BR><TT>real x(*), y(*)</TT>
<BR><TT>integer*2 nseries, n, dim</TT>
<BR><TT>integer*4 labels(*)</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _pg_chartscatter</TT> routines display either a single-series or a multi-series scatter chart.&nbsp; The chart is
displayed using the options specified in the<B> env</B> argument.
<BR><BR>The<TT> _pg_chartscatter</TT> routine displays a scatter chart from the single series of data contained in the arrays<B>
x</B> and<B> y</B>.&nbsp; The argument<B> n</B> specifies the number of values to chart.
<BR><BR>The<TT> _pg_chartscatterms</TT> routine displays a multi-series scatter chart.&nbsp; The argument<B> nseries</B> specifies
the number of series of data to chart.&nbsp; The arguments<B> x</B> and<B> y</B> are assumed to be two-dimensional arrays
defined as follows:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; real x( nseries, dim )</TT>
<BR><BR>The number of values used from each series is given by the argument<B> n</B>, where<B> n</B> is less than or equal
to<B> dim</B>.&nbsp; The argument<B> labels</B> is an array of addresses of strings.&nbsp; These strings describe each of
the series and are used in the chart legend.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _pg_chartscatter</TT> routines return zero if successful; otherwise, a non-zero value is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_pg_defaultchart">_pg_defaultchart</A>, <A HREF="#_pg_initchart">_pg_initchart</A>, <A HREF="#_pg_chart">_pg_chart</A>,
<A HREF="#_pg_chartpie">_pg_chartpie</A>, <A HREF="#_pg_analyzechart">_pg_analyzechart</A>, <A HREF="#_pg_analyzepie">_pg_analyzepie</A>,
<A HREF="#_pg_analyzescatter">_pg_analyzescatter</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pgapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pg.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer NUM_VALUES</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameter (NUM_VALUES=4)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer NUM_SERIES</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameter (NUM_SERIES=2)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 labels( NUM_SERIES )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real x( NUM_SERIES, NUM_VALUES )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / 5, 15,
30, 40, 10, 20, 30, 45 /</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real y( NUM_SERIES, NUM_VALUES )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / 10, 15,
30, 45, 40, 30, 15, 5 /</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /chartenv/ env</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; labels( 1 ) = loc( 'Jan'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; labels( 2 ) = loc( 'Feb'c )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_initchart()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_defaultchart( env,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
_PG_SCATTERCHART, _PG_POINTANDLINE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env.maintitle.title = 'Scatter Chart'c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_chartscatterms( env, x, y, NUM_SERIES,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; NUM_VALUES, NUM_VALUES, labels )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>produces the following:
<BR><BR><IMG SRC="eg_pgcs.bmp" ALIGN=MIDDLE>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD><TT> _pg_chartscatter - DOS</TT>
<BR><BR><TT>_pg_chartscatterms - DOS</TT>
</DL>
<H2 ID="_pg_defaultchart"> _pg_defaultchart </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>integer*2 function _pg_defaultchart( env, type, style )</TT>
<BR><TT>record /chartenv/ env</TT>
<BR><TT>integer*2 type, style</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _pg_defaultchart</TT> routine initializes the chart structure<B> env</B> to contain default values before a chart
is drawn.&nbsp; All values in the chart structure are initialized, including blanking of all titles.&nbsp; The chart type
in the structure is initialized to the value<B> type</B>, and the chart style is initialized to<B> style</B>.
<BR><BR>The argument<B> type</B> can have one of the following values:
<DL>
<DT>_PG_BARCHART
<DD>Bar chart (horizontal bars)
<DT>_PG_COLUMNCHART
<DD>Column chart (vertical bars)
<DT>_PG_LINECHART
<DD>Line chart
<DT>_PG_SCATTERCHART
<DD>Scatter chart
<DT>_PG_PIECHART
<DD>Pie chart
</DL>
<BR>Each type of chart can be drawn in one of two styles.&nbsp; For each chart type the argument<B> style</B> can have one
of the following values:&nbsp; uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Style 1&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Style 2</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Bar&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _PG_PLAINBARS
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _PG_STACKEDBARS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Column&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _PG_PLAINBARS&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _PG_STACKEDBARS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Line&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _PG_POINTANDLINE&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _PG_POINTONLY</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Scatter&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _PG_POINTANDLINE&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; _PG_POINTONLY</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Pie&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _PG_PERCENT&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _PG_NOPERCENT</TT>
<BR><BR>For single-series bar and column charts, the chart style is ignored.&nbsp; The &quot;plain&quot; (clustered) and &quot;stacked&quot;
styles only apply when there is more than one series of data.&nbsp; The &quot;percent&quot; style for pie charts causes percentages
to be displayed beside each of the pie slices.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _pg_defaultchart</TT> routine returns zero if successful; otherwise, a non-zero value is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_pg_initchart">_pg_initchart</A>, <A HREF="#_pg_chart">_pg_chart</A>, <A HREF="#_pg_chartpie">_pg_chartpie</A>,
<A HREF="#_pg_chartscatter">_pg_chartscatter</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pgapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pg.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer NUM_VALUES</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameter (NUM_VALUES=4)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 categories( NUM_VALUES )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real values( NUM_VALUES )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / 20, 45,
30, 25 /</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /chartenv/ env</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 1 ) = loc( 'Jan'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 2 ) = loc( 'Feb'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 3 ) = loc( 'Mar'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 4 ) = loc( 'Apr'c )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_initchart()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_defaultchart( env,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; _PG_COLUMNCHART, _PG_PLAINBARS )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env.maintitle.title = 'Column Chart'c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_chart( env, categories,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; values, NUM_VALUES )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_pg_getchardef"> _pg_getchardef </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>integer*2 function _pg_getchardef( ch, def )</TT>
<BR><TT>integer*2 ch</TT>
<BR><TT>integer*1 def(8)</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _pg_getchardef</TT> routine retrieves the current bit-map definition for the character<B> ch</B>.&nbsp; The bit-map
is placed in the array<B> def</B>.&nbsp; The current font must be an 8-by-8 bit-mapped font.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _pg_getchardef</TT> routine returns zero if successful; otherwise, a non-zero value is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_pg_defaultchart">_pg_defaultchart</A>, <A HREF="#_pg_initchart">_pg_initchart</A>, <A HREF="#_pg_chart">_pg_chart</A>,
<A HREF="#_pg_chartpie">_pg_chartpie</A>, <A HREF="#_pg_chartscatter">_pg_chartscatter</A>, <A HREF="#_pg_setchardef">_pg_setchardef</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pgapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pg.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer NUM_VALUES</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameter (NUM_VALUES=4)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real x( NUM_VALUES )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / 5, 25,
45, 65 /</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real y( NUM_VALUES )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / 5, 45,
25, 65 /</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*1 diamond( 8 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / '10'x, '28'x,
'44'x, '82'x,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '44'x,
'28'x, '10'x, '00'x /</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /chartenv/ env</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*1 old_def( 8 )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_initchart()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_defaultchart( env,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
_PG_SCATTERCHART, _PG_POINTANDLINE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env.maintitle.title = 'Scatter Chart'c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! change asterisk character to diamond</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_getchardef( ichar( '*' ), old_def )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_setchardef( ichar( '*' ), diamond )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_chartscatter( env, x, y, NUM_VALUES )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_setchardef( ichar( '*' ), old_def )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_pg_getpalette"> _pg_getpalette </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>integer*2 function _pg_getpalette( pal )</TT>
<BR><TT>record /paletteentry/ pal(*)</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _pg_getpalette</TT> routine retrieves the internal palette of the presentation graphics system.&nbsp; The palette
controls the colors, line styles, fill patterns and plot characters used to display each series of data in a chart.
<BR><BR>The argument<B> pal</B> is an array of palette structures that will contain the palette.&nbsp; Each element of the
palette is a structure containing the following fields:
<DL>
<DT>color
<DD>color used to display series
<DT>style
<DD>line style used for line and scatter charts
<DT>fill
<DD>fill pattern used to fill interior of bar and pie sections
<DT>plotchar
<DD>character plotted on line and scatter charts
</DL>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _pg_getpalette</TT> routine returns zero if successful; otherwise, a non-zero value is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_pg_defaultchart">_pg_defaultchart</A>, <A HREF="#_pg_initchart">_pg_initchart</A>, <A HREF="#_pg_chart">_pg_chart</A>,
<A HREF="#_pg_chartpie">_pg_chartpie</A>, <A HREF="#_pg_chartscatter">_pg_chartscatter</A>, <A HREF="#_pg_setpalette">_pg_setpalette</A>,
<A HREF="#_pg_resetpalette">_pg_resetpalette</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pgapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pg.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer NUM_VALUES</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameter (NUM_VALUES=4)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 categories( NUM_VALUES )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real values( NUM_VALUES )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / 20, 45,
30, 25 /</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*1 bricks( 8 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / 'ff'x,
'80'x, '80'x, '80'x,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
'ff'x, '08'x, '08'x, '08'x /</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /chartenv/ env</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /paletteentry/ pal( _PG_PALETTELEN )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer i</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 1 ) = loc( 'Jan'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 2 ) = loc( 'Feb'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 3 ) = loc( 'Mar'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 4 ) = loc( 'Apr'c )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_initchart()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_defaultchart( env,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; _PG_COLUMNCHART, _PG_PLAINBARS )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env.maintitle.title = 'Column Chart'c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! get default palette and change 1st entry</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_getpalette( pal )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pal( 2 ).color = 12</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do i = 1, 8</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pal( 2 ).fill( i ) = bricks( i )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enddo</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! use new palette</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_setpalette( pal )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_chart( env, categories,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; values, NUM_VALUES )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! reset palette to default</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_resetpalette()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_pg_getstyleset"> _pg_getstyleset </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>subroutine _pg_getstyleset( style )</TT>
<BR><TT>integer*2 style(*)</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _pg_getstyleset</TT> routine retrieves the internal style-set of the presentation graphics system.&nbsp; The style-set
is a set of line styles used for drawing window borders and grid-lines.&nbsp; The argument<B> style</B> is an array that will
contain the style-set.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_pg_defaultchart">_pg_defaultchart</A>, <A HREF="#_pg_initchart">_pg_initchart</A>, <A HREF="#_pg_chart">_pg_chart</A>,
<A HREF="#_pg_chartpie">_pg_chartpie</A>, <A HREF="#_pg_chartscatter">_pg_chartscatter</A>, <A HREF="#_pg_setstyleset">_pg_setstyleset</A>,
<A HREF="#_pg_resetstyleset">_pg_resetstyleset</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pgapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pg.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer NUM_VALUES</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameter (NUM_VALUES=4)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 categories( NUM_VALUES )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real values( NUM_VALUES )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / 20, 45,
30, 25 /</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /chartenv/ env</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 style( _PG_PALETTELEN )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 1 ) = loc( 'Jan'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 2 ) = loc( 'Feb'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 3 ) = loc( 'Mar'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 4 ) = loc( 'Apr'c )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_initchart()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_defaultchart( env,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; _PG_COLUMNCHART, _PG_PLAINBARS )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env.maintitle.title = 'Column Chart'c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! turn on yaxis grid, and use style 2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env.yaxis.grid = 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env.yaxis.gridstyle = 2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! get default style-set and change entry 2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_getstyleset( style )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; style( 3 ) = '8888'x</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! use new style-set</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_setstyleset( style )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_chart( env, categories,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; values, NUM_VALUES )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! reset style-set to default</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_resetstyleset()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_pg_hlabelchart"> _pg_hlabelchart </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>integer*2 function _pg_hlabelchart( env, x, y,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; color, label )</TT>
<BR><TT>record /chartenv/ env</TT>
<BR><TT>integer*2 x, y, color</TT>
<BR><TT>character*(*) label</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _pg_hlabelchart</TT> routine displays the text string<B> label</B> on the chart described by the<B> env</B> chart
structure.&nbsp; The string is displayed horizontally starting at the point<TT> (x,y),</TT> relative to the upper left corner
of the chart.&nbsp; The<B> color</B> specifies the palette color used to display the string.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _pg_hlabelchart</TT> routine returns zero if successful; otherwise, a non-zero value is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_pg_defaultchart">_pg_defaultchart</A>, <A HREF="#_pg_initchart">_pg_initchart</A>, <A HREF="#_pg_chart">_pg_chart</A>,
<A HREF="#_pg_chartpie">_pg_chartpie</A>, <A HREF="#_pg_chartscatter">_pg_chartscatter</A>, <A HREF="#_pg_vlabelchart">_pg_vlabelchart</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pgapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pg.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer NUM_VALUES</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameter (NUM_VALUES=4)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 categories( NUM_VALUES )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real values( NUM_VALUES )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / 20, 45,
30, 25 /</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /chartenv/ env</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 1 ) = loc( 'Jan'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 2 ) = loc( 'Feb'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 3 ) = loc( 'Mar'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 4 ) = loc( 'Apr'c )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_initchart()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_defaultchart( env,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; _PG_COLUMNCHART, _PG_PLAINBARS )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env.maintitle.title = 'Column Chart'c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_chart( env, categories,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; values, NUM_VALUES )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_hlabelchart( env, 64, 32, 1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; 'Horizontal label'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_vlabelchart( env, 48, 32, 1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; 'Vertical label'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_pg_initchart"> _pg_initchart </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>integer*2 function _pg_initchart()</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _pg_initchart</TT> routine initializes the presentation graphics system.&nbsp; This includes initializing the internal
palette and style-set used when drawing charts.&nbsp; This routine must be called before any of the other presentation graphics
routines.
<BR><BR>The initialization of the presentation graphics system requires that a valid graphics mode has been selected.&nbsp;
For this reason the <TT> _setvideomode</TT> routine must be called before<TT> _pg_initchart</TT> is called.&nbsp; If a font
has been selected (with the <TT> _setfont</TT> routine), that font will be used when text is displayed in a chart.&nbsp; Font
selection should also be done before initializing the presentation graphics system.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _pg_initchart</TT> routine returns zero if successful; otherwise, a non-zero value is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_pg_defaultchart">_pg_defaultchart</A>, <A HREF="#_pg_chart">_pg_chart</A>, <A HREF="#_pg_chartpie">_pg_chartpie</A>,
<A HREF="#_pg_chartscatter">_pg_chartscatter</A>, <A HREF="#_setvideomode">_setvideomode</A>, <A HREF="#_setfont">_setfont</A>,
<A HREF="#_registerfonts">_registerfonts</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pgapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pg.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer NUM_VALUES</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameter (NUM_VALUES=4)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 categories( NUM_VALUES )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real values( NUM_VALUES )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / 20, 45,
30, 25 /</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /chartenv/ env</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 1 ) = loc( 'Jan'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 2 ) = loc( 'Feb'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 3 ) = loc( 'Mar'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 4 ) = loc( 'Apr'c )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_initchart()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_defaultchart( env,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; _PG_COLUMNCHART, _PG_PLAINBARS )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env.maintitle.title = 'Column Chart'c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_chart( env, categories,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; values, NUM_VALUES )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_pg_resetpalette"> _pg_resetpalette </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>integer*2 function _pg_resetpalette()</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _pg_resetpalette</TT> routine resets the internal palette of the presentation graphics system to default values.&nbsp;
The palette controls the colors, line styles, fill patterns and plot characters used to display each series of data in a chart.
&nbsp;The default palette chosen is dependent on the current video mode.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _pg_resetpalette</TT> routine returns zero if successful; otherwise, a non-zero value is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_pg_defaultchart">_pg_defaultchart</A>, <A HREF="#_pg_initchart">_pg_initchart</A>, <A HREF="#_pg_chart">_pg_chart</A>,
<A HREF="#_pg_chartpie">_pg_chartpie</A>, <A HREF="#_pg_chartscatter">_pg_chartscatter</A>, <A HREF="#_pg_getpalette">_pg_getpalette</A>,
<A HREF="#_pg_setpalette">_pg_setpalette</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pgapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pg.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer NUM_VALUES</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameter (NUM_VALUES=4)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 categories( NUM_VALUES )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real values( NUM_VALUES )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / 20, 45,
30, 25 /</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*1 bricks( 8 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / 'ff'x,
'80'x, '80'x, '80'x,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
'ff'x, '08'x, '08'x, '08'x /</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /chartenv/ env</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /paletteentry/ pal( _PG_PALETTELEN )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer i</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 1 ) = loc( 'Jan'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 2 ) = loc( 'Feb'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 3 ) = loc( 'Mar'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 4 ) = loc( 'Apr'c )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_initchart()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_defaultchart( env,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; _PG_COLUMNCHART, _PG_PLAINBARS )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env.maintitle.title = 'Column Chart'c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! get default palette and change 1st entry</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_getpalette( pal )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pal( 2 ).color = 12</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do i = 1, 8</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pal( 2 ).fill( i ) = bricks( i )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enddo</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! use new palette</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_setpalette( pal )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_chart( env, categories,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; values, NUM_VALUES )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! reset palette to default</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_resetpalette()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_pg_resetstyleset"> _pg_resetstyleset </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>subroutine _pg_resetstyleset()</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _pg_resetstyleset</TT> routine resets the internal style-set of the presentation graphics system to default values.
&nbsp;The style-set is a set of line styles used for drawing window borders and grid-lines.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_pg_defaultchart">_pg_defaultchart</A>, <A HREF="#_pg_initchart">_pg_initchart</A>, <A HREF="#_pg_chart">_pg_chart</A>,
<A HREF="#_pg_chartpie">_pg_chartpie</A>, <A HREF="#_pg_chartscatter">_pg_chartscatter</A>, <A HREF="#_pg_getstyleset">_pg_getstyleset</A>,
<A HREF="#_pg_setstyleset">_pg_setstyleset</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pgapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pg.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer NUM_VALUES</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameter (NUM_VALUES=4)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 categories( NUM_VALUES )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real values( NUM_VALUES )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / 20, 45,
30, 25 /</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /chartenv/ env</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 style( _PG_PALETTELEN )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 1 ) = loc( 'Jan'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 2 ) = loc( 'Feb'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 3 ) = loc( 'Mar'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 4 ) = loc( 'Apr'c )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_initchart()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_defaultchart( env,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; _PG_COLUMNCHART, _PG_PLAINBARS )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env.maintitle.title = 'Column Chart'c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! turn on yaxis grid, and use style 2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env.yaxis.grid = 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env.yaxis.gridstyle = 2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! get default style-set and change entry 2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_getstyleset( style )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; style( 3 ) = '8888'x</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! use new style-set</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_setstyleset( style )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_chart( env, categories,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; values, NUM_VALUES )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! reset style-set to default</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_resetstyleset()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_pg_setchardef"> _pg_setchardef </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>integer*2 function _pg_setchardef( ch, def )</TT>
<BR><TT>integer*2 ch</TT>
<BR><TT>integer*1 def(8)</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _pg_setchardef</TT> routine sets the current bit-map definition for the character<B> ch</B>.&nbsp; The bit-map is
contained in the array<B> def</B>.&nbsp; The current font must be an 8-by-8 bit-mapped font.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _pg_setchardef</TT> routine returns zero if successful; otherwise, a non-zero value is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_pg_defaultchart">_pg_defaultchart</A>, <A HREF="#_pg_initchart">_pg_initchart</A>, <A HREF="#_pg_chart">_pg_chart</A>,
<A HREF="#_pg_chartpie">_pg_chartpie</A>, <A HREF="#_pg_chartscatter">_pg_chartscatter</A>, <A HREF="#_pg_getchardef">_pg_getchardef</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pgapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pg.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer NUM_VALUES</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameter (NUM_VALUES=4)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real x( NUM_VALUES )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / 5, 25,
45, 65 /</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real y( NUM_VALUES )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / 5, 45,
25, 65 /</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*1 diamond( 8 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / '10'x, '28'x,
'44'x, '82'x,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '44'x,
'28'x, '10'x, '00'x /</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /chartenv/ env</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*1 old_def( 8 )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_initchart()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_defaultchart( env,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
_PG_SCATTERCHART, _PG_POINTANDLINE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env.maintitle.title = 'Scatter Chart'c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! change asterisk character to diamond</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_getchardef( ichar( '*' ), old_def )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_setchardef( ichar( '*' ), diamond )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_chartscatter( env, x, y, NUM_VALUES )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_setchardef( ichar( '*' ), old_def )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_pg_setpalette"> _pg_setpalette </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>integer*2 function _pg_setpalette( pal )</TT>
<BR><TT>record /paletteentry/ pal(*)</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _pg_setpalette</TT> routine sets the internal palette of the presentation graphics system.&nbsp; The palette controls
the colors, line styles, fill patterns and plot characters used to display each series of data in a chart.
<BR><BR>The argument<B> pal</B> is an array of palette structures containing the new palette.&nbsp; Each element of the palette
is a structure containing the following fields:
<DL>
<DT>color
<DD>color used to display series
<DT>style
<DD>line style used for line and scatter charts
<DT>fill
<DD>fill pattern used to fill interior of bar and pie sections
<DT>plotchar
<DD>character plotted on line and scatter charts
</DL>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _pg_setpalette</TT> routine returns zero if successful; otherwise, a non-zero value is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_pg_defaultchart">_pg_defaultchart</A>, <A HREF="#_pg_initchart">_pg_initchart</A>, <A HREF="#_pg_chart">_pg_chart</A>,
<A HREF="#_pg_chartpie">_pg_chartpie</A>, <A HREF="#_pg_chartscatter">_pg_chartscatter</A>, <A HREF="#_pg_getpalette">_pg_getpalette</A>,
<A HREF="#_pg_resetpalette">_pg_resetpalette</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pgapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pg.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer NUM_VALUES</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameter (NUM_VALUES=4)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 categories( NUM_VALUES )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real values( NUM_VALUES )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / 20, 45,
30, 25 /</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*1 bricks( 8 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / 'ff'x,
'80'x, '80'x, '80'x,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
'ff'x, '08'x, '08'x, '08'x /</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /chartenv/ env</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /paletteentry/ pal( _PG_PALETTELEN )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer i</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 1 ) = loc( 'Jan'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 2 ) = loc( 'Feb'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 3 ) = loc( 'Mar'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 4 ) = loc( 'Apr'c )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_initchart()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_defaultchart( env,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; _PG_COLUMNCHART, _PG_PLAINBARS )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env.maintitle.title = 'Column Chart'c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! get default palette and change 1st entry</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_getpalette( pal )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pal( 2 ).color = 12</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do i = 1, 8</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pal( 2 ).fill( i ) = bricks( i )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enddo</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! use new palette</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_setpalette( pal )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_chart( env, categories,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; values, NUM_VALUES )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! reset palette to default</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_resetpalette()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_pg_setstyleset"> _pg_setstyleset </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>subroutine _pg_setstyleset( style )</TT>
<BR><TT>integer*2 style(*)</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _pg_setstyleset</TT> routine retrieves the internal style-set of the presentation graphics system.&nbsp; The style-set
is a set of line styles used for drawing window borders and grid-lines.&nbsp; The argument<B> style</B> is an array containing
the new style-set.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_pg_defaultchart">_pg_defaultchart</A>, <A HREF="#_pg_initchart">_pg_initchart</A>, <A HREF="#_pg_chart">_pg_chart</A>,
<A HREF="#_pg_chartpie">_pg_chartpie</A>, <A HREF="#_pg_chartscatter">_pg_chartscatter</A>, <A HREF="#_pg_getstyleset">_pg_getstyleset</A>,
<A HREF="#_pg_resetstyleset">_pg_resetstyleset</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pgapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pg.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer NUM_VALUES</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameter (NUM_VALUES=4)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 categories( NUM_VALUES )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real values( NUM_VALUES )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / 20, 45,
30, 25 /</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /chartenv/ env</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 style( _PG_PALETTELEN )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 1 ) = loc( 'Jan'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 2 ) = loc( 'Feb'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 3 ) = loc( 'Mar'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 4 ) = loc( 'Apr'c )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_initchart()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_defaultchart( env,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; _PG_COLUMNCHART, _PG_PLAINBARS )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env.maintitle.title = 'Column Chart'c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! turn on yaxis grid, and use style 2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env.yaxis.grid = 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env.yaxis.gridstyle = 2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! get default style-set and change entry 2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_getstyleset( style )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; style( 3 ) = '8888'x</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! use new style-set</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_setstyleset( style )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_chart( env, categories,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; values, NUM_VALUES )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! reset style-set to default</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_resetstyleset()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_pg_vlabelchart"> _pg_vlabelchart </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>integer*2 function _pg_vlabelchart( env, x, y,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; color, label )</TT>
<BR><TT>record /chartenv/ env</TT>
<BR><TT>integer*2 x, y, color</TT>
<BR><TT>character*(*) label</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _pg_vlabelchart</TT> routine displays the text string<B> label</B> on the chart described by the<B> env</B> chart
structure.&nbsp; The string is displayed vertically starting at the point<TT> (x,y),</TT> relative to the upper left corner
of the chart.&nbsp; The<B> color</B> specifies the palette color used to display the string.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _pg_vlabelchart</TT> routine returns zero if successful; otherwise, a non-zero value is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_pg_defaultchart">_pg_defaultchart</A>, <A HREF="#_pg_initchart">_pg_initchart</A>, <A HREF="#_pg_chart">_pg_chart</A>,
<A HREF="#_pg_chartpie">_pg_chartpie</A>, <A HREF="#_pg_chartscatter">_pg_chartscatter</A>, <A HREF="#_pg_hlabelchart">_pg_hlabelchart</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pgapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pg.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer NUM_VALUES</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameter (NUM_VALUES=4)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 categories( NUM_VALUES )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real values( NUM_VALUES )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / 20, 45,
30, 25 /</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /chartenv/ env</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 1 ) = loc( 'Jan'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 2 ) = loc( 'Feb'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 3 ) = loc( 'Mar'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 4 ) = loc( 'Apr'c )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_initchart()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_defaultchart( env,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; _PG_COLUMNCHART, _PG_PLAINBARS )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env.maintitle.title = 'Column Chart'c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_chart( env, categories,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; values, NUM_VALUES )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_hlabelchart( env, 64, 32, 1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; 'Horizontal label'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_vlabelchart( env, 48, 32, 1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; 'Vertical label'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_pie"> _pie, _pie_w, _pie_wxy </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>integer*2 function _pie( fill, x1, y1, x2, y2,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x3, y3, x4, y4 )</TT>
<BR><TT>integer*2 fill</TT>
<BR><TT>integer*2 x1, y1</TT>
<BR><TT>integer*2 x2, y2</TT>
<BR><TT>integer*2 x3, y3</TT>
<BR><TT>integer*2 x4, y4</TT>
<BR><BR><TT>integer*2 function _pie_w( fill, x1, y1, x2, y2,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x3, y3, x4, y4 )</TT>
<BR><TT>integer*2 fill</TT>
<BR><TT>double precision x1, y1</TT>
<BR><TT>double precision x2, y2</TT>
<BR><TT>double precision x3, y3</TT>
<BR><TT>double precision x4, y4</TT>
<BR><BR><TT>integer*2 function _pie_wxy( fill, p1, p2, p3, p4 )</TT>
<BR><TT>integer*2 fill,</TT>
<BR><TT>record /_wxycoord/ p1, p2</TT>
<BR><TT>record /_wxycoord/ p3, p4</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _pie</TT> routines draw pie-shaped wedges.&nbsp; The<TT> _pie</TT> routine uses the view coordinate system.&nbsp;
The<TT> _pie_w</TT> and<TT> _pie_wxy</TT> routines use the window coordinate system.
<BR><BR>The pie wedges are drawn by drawing an elliptical arc (in the way described for the <TT> _arc</TT> routines) and then
joining the center of the rectangle that contains the ellipse to the two endpoints of the arc.
<BR><BR>The elliptical arc is drawn with its center at the center of the rectangle established by the points<TT> (x1,y1)</TT>
and<TT> (x2,y2).</TT>&nbsp; The arc is a segment of the ellipse drawn within this bounding rectangle.&nbsp; The arc starts
at the point on this ellipse that intersects the vector from the centre of the ellipse to the point<TT> (x3,y3).</TT>&nbsp;
The arc ends at the point on this ellipse that intersects the vector from the centre of the ellipse to the point<TT> (x4,y4).</TT>
&nbsp;The arc is drawn in a counter-clockwise direction with the current plot action using the current color and the current
line style.
<BR><BR>The following picture illustrates the way in which the bounding rectangle and the vectors specifying the start and
end points are defined.
<BR><BR><IMG SRC="pic2.bmp" ALIGN=MIDDLE>
<BR>When the coordinates<TT> (x1,y1)</TT> and<TT> (x2,y2)</TT> establish a line or a point (this happens when one or more
of the x-coordinates or y-coordinates are equal), nothing is drawn.
<BR><BR>The argument<B> fill</B> determines whether the figure is filled in or has only its outline drawn.&nbsp; The argument
can have one of two values:
<DL>
<DT>_GFILLINTERIOR
<DD>fill the interior by writing pixels with the current plot action using the current color and the current fill mask
<DT>_GBORDER
<DD>leave the interior unchanged; draw the outline of the figure with the current plot action using the current color and line
style
</DL>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _pie</TT> routines return a non-zero value when the figure was successfully drawn; otherwise, zero is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_arc">_arc</A>, <A HREF="#_ellipse">_ellipse</A>, <A HREF="#_setcolor">_setcolor</A>, <A HREF="#_setfillmask">_setfillmask</A>,
<A HREF="#_setlinestyle">_setlinestyle</A>, <A HREF="#_setplotaction">_setplotaction</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pie( _GBORDER, 120, 90, 520, 390,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 140, 20, 190, 460 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>produces the following:
<BR><BR><IMG SRC="eg_pie.bmp" ALIGN=MIDDLE>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD><TT> _pie - DOS</TT>
<BR><BR><TT>_pie_w - DOS</TT>
<BR><TT>_pie_wxy - DOS</TT>
</DL>
<H2 ID="_polygon"> _polygon, _polygon_w, _polygon_wxy </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>integer*2 function _polygon( fill, numpts, points )</TT>
<BR><TT>integer*2 fill</TT>
<BR><TT>integer*2 numpts</TT>
<BR><TT>record /xycoord/ points(*)</TT>
<BR><BR><TT>integer*2 function _polygon_w( fill, numpts, points )</TT>
<BR><TT>integer*2 fill</TT>
<BR><TT>integer*2 numpts</TT>
<BR><TT>double precision points(*)</TT>
<BR><BR><TT>integer*2 function _polygon_wxy( fill, numpts, points )</TT>
<BR><TT>integer*2 fill</TT>
<BR><TT>integer*2 numpts</TT>
<BR><TT>record /_wxycoord/ points(*)</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _polygon</TT> routines draw polygons.&nbsp; The<TT> _polygon</TT> routine uses the view coordinate system.&nbsp; The<TT>
_polygon_w</TT> and<TT> _polygon_wxy</TT> routines use the window coordinate system.
<BR><BR>The polygon is defined as containing<B> numpts</B> points whose coordinates are given in the array<B> points</B>.
<BR><BR>The argument<B> fill</B> determines whether the polygon is filled in or has only its outline drawn.&nbsp; The argument
can have one of two values:
<DL>
<DT>_GFILLINTERIOR
<DD>fill the interior by writing pixels with the current plot action using the current color and the current fill mask
<DT>_GBORDER
<DD>leave the interior unchanged; draw the outline of the figure with the current plot action using the current color and line
style
</DL>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _polygon</TT> routines return a non-zero value when the polygon was successfully drawn; otherwise, zero is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_setcolor">_setcolor</A>, <A HREF="#_setfillmask">_setfillmask</A>, <A HREF="#_setlinestyle">_setlinestyle</A>,
<A HREF="#_setplotaction">_setplotaction</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /xycoord/ points(5)/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 319, 140, 224, 209, 261, 320,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 378, 320, 415, 209/</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _polygon( _GBORDER, 5, points )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>produces the following:
<BR><BR><IMG SRC="eg_polyg.bmp" ALIGN=MIDDLE>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD><TT> _polygon - DOS</TT>
<BR><BR><TT>_polygon_w - DOS</TT>
<BR><TT>_polygon_wxy - DOS</TT>
</DL>
<H2 ID="_putimage"> _putimage, _putimage_w </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>subroutine _putimage( x, y, image, mode )</TT>
<BR><TT>integer*2 x, y</TT>
<BR><TT>integer*1 image(*)</TT>
<BR><TT>integer*2 mode</TT>
<BR><BR><TT>subroutine _putimage_w( x, y, image, mode )</TT>
<BR><TT>double precision x, y</TT>
<BR><TT>integer*1 image(*)</TT>
<BR><TT>integer*2 mode</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _putimage</TT> routines display the screen image indicated by the argument<B> image</B>.&nbsp; The<TT> _putimage</TT>
routine uses the view coordinate system.&nbsp; The<TT> _putimage_w</TT> routine uses the window coordinate system.
<BR><BR>The image is displayed upon the screen with its top left corner located at the point with coordinates<TT> (x,y).</TT>
&nbsp;The image was previously saved using the <TT> _getimage</TT> routines.&nbsp; The image is displayed in a rectangle whose
size is the size of the rectangular image saved by the <TT> _getimage</TT> routines.
<BR><BR>The image can be displayed in a number of ways, depending upon the value of the<B> mode</B> argument.&nbsp; This argument
can have the following values:
<DL>
<DT>_GPSET
<DD>replace the rectangle on the screen by the saved image
<DT>_GPRESET
<DD>replace the rectangle on the screen with the pixel values of the saved image inverted; this produces a negative image
<DT>_GAND
<DD>produce a new image on the screen by ANDing together the pixel values from the screen with those from the saved image
<DT>_GOR
<DD>produce a new image on the screen by ORing together the pixel values from the screen with those from the saved image
<DT>_GXOR
<DD>produce a new image on the screen by exclusive ORing together the pixel values from the screen with those from the saved image;
the original screen is restored by two successive calls to the _putimage routine with this value, providing an efficient method
to produce animated effects
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getimage">_getimage</A>, <A HREF="#_imagesize">_imagesize</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*1 image(:)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer y, image_size, istat</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _ellipse( _GFILLINTERIOR,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;100, 100, 200, 200 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; image_size = _imagesize( 100, 100, 201, 201 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; allocate( image(image_size), stat = istat )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( istat .eq. 0 )then</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _getimage( 100, 100, 201, 201, image )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _putimage( 260, 200, image, _GPSET )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _putimage( 420, 100, image, _GPSET )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do y = 100, 280, 20</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _putimage( 420, y,
image, _GXOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _putimage( 420, y+20,
image, _GXOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enddo</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; deallocate( image )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endif</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD><TT> _putimage - DOS</TT>
<BR><BR><TT>_putimage_w - DOS</TT>
</DL>
<H2 ID="_rectangle"> _rectangle, _rectangle_w, _rectangle_wxy </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>integer*2 function _rectangle( fill, x1, y1, x2, y2 )</TT>
<BR><TT>integer*2 fill</TT>
<BR><TT>integer*2 x1, y1</TT>
<BR><TT>integer*2 x2, y2</TT>
<BR><BR><TT>integer*2 function _rectangle_w( fill, x1, y1, x2, y2 )</TT>
<BR><TT>integer*2 fill</TT>
<BR><TT>double precision x1, y1</TT>
<BR><TT>double precision x2, y2</TT>
<BR><BR><TT>integer*2 function _rectangle_wxy( fill, p1, p2 )</TT>
<BR><TT>integer*2 fill</TT>
<BR><TT>record /_wxycoord/ p1, p2</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _rectangle</TT> routines draw rectangles.&nbsp; The<TT> _rectangle</TT> routine uses the view coordinate system.&nbsp;
The<TT> _rectangle_w</TT> and<TT> _rectangle_wxy</TT> routines use the window coordinate system.
<BR><BR>The rectangle is defined with opposite corners established by the points<TT> (x1,y1)</TT> and<TT> (x2,y2).</TT>
<BR><BR>The argument<B> fill</B> determines whether the rectangle is filled in or has only its outline drawn.&nbsp; The argument
can have one of two values:
<DL>
<DT>_GFILLINTERIOR
<DD>fill the interior by writing pixels with the current plot action using the current color and the current fill mask
<DT>_GBORDER
<DD>leave the interior unchanged; draw the outline of the figure with the current plot action using the current color and line
style
</DL>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _rectangle</TT> routines return a non-zero value when the rectangle was successfully drawn; otherwise, zero is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_setcolor">_setcolor</A>, <A HREF="#_setfillmask">_setfillmask</A>, <A HREF="#_setlinestyle">_setlinestyle</A>,
<A HREF="#_setplotaction">_setplotaction</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _rectangle( _GBORDER, 100, 100, 540, 380 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>produces the following:
<BR><BR><IMG SRC="eg_rect.bmp" ALIGN=MIDDLE>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD><TT> _rectangle - DOS</TT>
<BR><BR><TT>_rectangle_w - DOS</TT>
<BR><TT>_rectangle_wxy - DOS</TT>
</DL>
<H2 ID="_registerfonts"> _registerfonts </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>integer*2 function _registerfonts( path )</TT>
<BR><TT>character*(*) path</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _registerfonts</TT> routine initializes the font graphics system.&nbsp; Fonts must be registered, and a font selected,
before text can be displayed with the <TT> _outgtext</TT> routine.
<BR><BR>The argument<B> path</B> specifies the location of the font files.&nbsp; This argument is a file specification, and
can contain drive and directory components and may contain wildcard characters.&nbsp; The<TT> _registerfonts</TT> routine
opens each of the font files specified and reads the font information.&nbsp; Memory is allocated to store the characteristics
of the font.&nbsp; These font characteristics are used by the <TT> _setfont</TT> routine when selecting a font.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _registerfonts</TT> routine returns the number of fonts that were registered if the routine is successful; otherwise,
a negative number is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_unregisterfonts">_unregisterfonts</A>, <A HREF="#_setfont">_setfont</A>, <A HREF="#_getfontinfo">_getfontinfo</A>,
<A HREF="#_outgtext">_outgtext</A>, <A HREF="#_getgtextextent">_getgtextextent</A>, <A HREF="#_setgtextvector">_setgtextvector</A>,
<A HREF="#_getgtextvector">_getgtextvector</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer i, n</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character*10 buff</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n = _registerfonts( '*.fon'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do i = 0, n - 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write( buff, '(''n'', i2.2, a1 )' ) i, char(0)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setfont( buff )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _moveto( 100, 100 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _outgtext( 'WATCOM Graphics'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _clearscreen( _GCLEARSCREEN )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enddo</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _unregisterfonts()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_remapallpalette"> _remapallpalette </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>integer*2 function _remapallpalette( colors )</TT>
<BR><TT>integer*4 colors(*)</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _remapallpalette</TT> routine sets (or remaps) all of the colors in the palette.&nbsp; The color values in the palette
are replaced by the array of color values given by the argument<B> colors</B>.&nbsp; This routine is supported in all video
modes, but only works with EGA, MCGA and VGA adapters.
<BR><BR>The array<B> colors</B> must contain at least as many elements as there are supported colors.&nbsp; The newly mapped
palette will cause the complete screen to change color wherever there is a pixel value of a changed color in the palette.
<BR><BR>The representation of colors depends upon the hardware being used.&nbsp; The number of colors in the palette can be
determined by using the <TT> _getvideoconfig</TT> routine.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _remapallpalette</TT> routine returns (-1) if the palette is remapped successfully and zero otherwise.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_remappalette">_remappalette</A>, <A HREF="#_getvideoconfig">_getvideoconfig</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer colors(16)/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _BRIGHTWHITE, _YELLOW, _LIGHTMAGENTA,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _LIGHTRED, _LIGHTCYAN, _LIGHTGREEN,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _LIGHTBLUE, _GRAY, _WHITE, _BROWN,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _MAGENTA, _RED, _CYAN,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _GREEN, _BLUE, _BLACK/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer x, y</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do y = 0, 3</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do x = 0, 3</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setcolor( x + 4 *
y )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _rectangle( _GFILLINTERIOR,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
x * 160, y * 120,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
( x + 1 ) * 160, ( y + 1 ) * 120 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enddo</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enddo</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _remapallpalette( colors )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_remappalette"> _remappalette </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>integer*4 function _remappalette( pixval, color )</TT>
<BR><TT>integer*2 pixval</TT>
<BR><TT>integer*4 color</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _remappalette</TT> routine sets (or remaps) the palette color<B> pixval</B> to be the color<B> color</B>.&nbsp; This
routine is supported in all video modes, but only works with EGA, MCGA and VGA adapters.
<BR><BR>The argument<B> pixval</B> is an index in the color palette of the current video mode.&nbsp; The argument<B> color</B>
specifies the actual color displayed on the screen by pixels with pixel value<B> pixval</B>.&nbsp; Color values are selected
by specifying the red, green and blue intensities that make up the color.&nbsp; Each intensity can be in the range from 0
to 63, resulting in 262144 possible different colors.&nbsp; A given color value can be conveniently specified as a value of
type<TT> integer*4.</TT>&nbsp; The color value is of the form<TT> '00bbggrr'x,</TT> where<TT> bb</TT> is the blue intensity,<TT>
gg</TT> is the green intensity and<TT> rr</TT> is the red intensity of the selected color.&nbsp; The file<TT> graph.fi</TT>
defines constants containing the color intensities of each of the 16 default colors.
<BR><BR>The<TT> _remappalette</TT> routine takes effect immediately.&nbsp; All pixels on the complete screen which have a
pixel value equal to the value of<B> pixval</B> will now have the color indicated by the argument<B> color</B>.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _remappalette</TT> routine returns the previous color for the pixel value if the palette is remapped successfully;
otherwise, (-1) is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_remapallpalette">_remapallpalette</A>, <A HREF="#_setvideomode">_setvideomode</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer col</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer colors(16)/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _BLACK, _BLUE, _GREEN,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _CYAN, _RED, _MAGENTA,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _BROWN, _WHITE, _GRAY, _LIGHTBLUE,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _LIGHTGREEN, _LIGHTCYAN, _LIGHTRED,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _LIGHTMAGENTA, _YELLOW, _BRIGHTWHITE/</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do col = 1, 16</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _remappalette( 0, colors(col) )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enddo</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_scrolltextwindow"> _scrolltextwindow </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>subroutine _scrolltextwindow( rows )</TT>
<BR><TT>integer*2 rows</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _scrolltextwindow</TT> routine scrolls the lines in the current text window.&nbsp; A text window is defined with the
<TT> _settextwindow</TT> routine.&nbsp; By default, the text window is the entire screen.
<BR><BR>The argument<B> rows</B> specifies the number of rows to scroll.&nbsp; A positive value means to scroll the text window
up or towards the top of the screen.&nbsp; A negative value means to scroll the text window down or towards the bottom of
the screen.&nbsp; Specifying a number of rows greater than the height of the text window is equivalent to clearing the text
window with the <TT> _clearscreen</TT> routine.
<BR><BR>Two constants are defined that can be used with the<TT> _scrolltextwindow</TT> routine:
<DL>
<DT>_GSCROLLUP
<DD>the contents of the text window are scrolled up (towards the top of the screen) by one row
<DT>_GSCROLLDOWN
<DD>the contents of the text window are scrolled down (towards the bottom of the screen) by one row
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_settextwindow">_settextwindow</A>, <A HREF="#_clearscreen">_clearscreen</A>, <A HREF="#_outtext">_outtext</A>,
<A HREF="#_outmem">_outmem</A>, <A HREF="#_settextposition">_settextposition</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer i</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character*80 buff</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _TEXTC80 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _settextwindow( 5, 20, 20, 40 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do i = 1, 10</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write( buff, '(''Line '', i2, a1, a1 )' )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i, char(10), char(0)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _outtext( buff )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enddo</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _scrolltextwindow( _GSCROLLDOWN )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _scrolltextwindow( _GSCROLLUP )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_selectpalette"> _selectpalette </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>integer*2 function _selectpalette( palnum )</TT>
<BR><TT>integer*2 palnum</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _selectpalette</TT> routine selects the palette indicated by the argument<B> palnum</B> from the color palettes available.
&nbsp;This routine is only supported by the video modes<TT> _MRES4COLOR</TT> and<TT> _MRESNOCOLOR.</TT>
<BR><BR>Mode<TT> _MRES4COLOR</TT> supports four palettes of four colors.&nbsp; In each palette, color 0, the background color,
can be any of the 16 possible colors.&nbsp; The color values associated with the other three pixel values, (1, 2 and 3), are
determined by the selected palette.
<BR><BR>The following table outlines the available color palettes:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Palette&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Pixel
Values</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Number&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; green&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; red&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; brown</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp; cyan&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; magenta&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; white</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp; light green&nbsp;&nbsp;&nbsp;&nbsp; light red
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yellow</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp; light cyan&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; light
magenta&nbsp;&nbsp; bright white</TT>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _selectpalette</TT> routine returns the number of the previously selected palette.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_setvideomode">_setvideomode</A>, <A HREF="#_getvideoconfig">_getvideoconfig</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer x, y, pal</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _MRES4COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do y = 0, 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do x = 0, 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setcolor( x + 2 *
y )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _rectangle( _GFILLINTERIOR,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
x * 160, y * 100,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
( x + 1 ) * 160, ( y + 1 ) * 100 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enddo</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enddo</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do pal = 0, 3</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _selectpalette( pal )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enddo</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_setactivepage"> _setactivepage </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>integer*2 function _setactivepage( pagenum )</TT>
<BR><TT>integer*2 pagenum</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _setactivepage</TT> routine selects the page (in memory) to which graphics output is written.&nbsp; The page to be
selected is given by the<B> pagenum</B> argument.
<BR><BR>Only some combinations of video modes and hardware allow multiple pages of graphics to exist.&nbsp; When multiple
pages are supported, the active page may differ from the visual page.&nbsp; The graphics information in the visual page determines
what is displayed upon the screen.&nbsp; Animation may be accomplished by alternating the visual page.&nbsp; A graphics page
can be constructed without affecting the screen by setting the active page to be different than the visual page.
<BR><BR>The number of available video pages can be determined by using the <TT> _getvideoconfig</TT> routine.&nbsp; The default
video page is 0.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _setactivepage</TT> routine returns the number of the previous page when the active page is set successfully; otherwise,
a negative number is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getactivepage">_getactivepage</A>, <A HREF="#_setvisualpage">_setvisualpage</A>, <A HREF="#_getvisualpage">_getvisualpage</A>,
<A HREF="#_getvideoconfig">_getvideoconfig</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer old_apage, old_vpage</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _HRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; old_apage = _getactivepage()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; old_vpage = _getvisualpage()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! draw an ellipse on page 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setactivepage( 0 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvisualpage( 0 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _ellipse( _GFILLINTERIOR, 100, 50,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 540, 150 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! draw a rectangle on page 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setactivepage( 1 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _rectangle( _GFILLINTERIOR, 100, 50,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 540, 150 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! display page 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvisualpage( 1 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setactivepage( old_apage )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvisualpage( old_vpage )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_setbkcolor"> _setbkcolor </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>integer*4 function _setbkcolor( color )</TT>
<BR><TT>integer*4 color</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _setbkcolor</TT> routine sets the current background color to be that of the<B> color</B> argument.&nbsp; In text
modes, the background color controls the area behind each individual character.&nbsp; In graphics modes, the background refers
to the entire screen.&nbsp; The default background color is 0.
<BR><BR>When the current video mode is a graphics mode, any pixels with a zero pixel value will change to the color of the<B>
color</B> argument.&nbsp; When the current video mode is a text mode, nothing will immediately change; only subsequent output
is affected.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _setbkcolor</TT> routine returns the previous background color.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getbkcolor">_getbkcolor</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer bk, old_bk</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer colors(16)/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _BLACK, _BLUE, _GREEN,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _CYAN, _RED, _MAGENTA,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _BROWN, _WHITE, _GRAY, _LIGHTBLUE,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _LIGHTGREEN, _LIGHTCYAN, _LIGHTRED,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _LIGHTMAGENTA, _YELLOW, _BRIGHTWHITE/</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; old_bk = _getbkcolor()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do bk = 1, 16</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setbkcolor( colors( bk ) )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enddo</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setbkcolor( old_bk )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_setcharsize"> _setcharsize, _setcharsize_w </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>subroutine _setcharsize( height, width )</TT>
<BR><TT>integer*2 height, width</TT>
<BR><BR><TT>subroutine _setcharsize_w( height, width )</TT>
<BR><TT>double precision height, width</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _setcharsize</TT> routines set the character height and width to the values specified by the arguments<B> height</B>
and<B> width</B>.&nbsp; For the<TT> _setcharsize</TT> routine, the arguments<B> height</B> and<B> width</B> represent a number
of pixels.&nbsp; For the<TT> _setcharsize_w</TT> routine, the arguments<B> height</B> and<B> width</B> represent lengths along
the y-axis and x-axis in the window coordinate system.
<BR><BR>These sizes are used when displaying text with the <TT> _grtext</TT> routine.&nbsp; The default character sizes are
dependent on the graphics mode selected, and can be determined by the <TT> _gettextsettings</TT> routine.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_grtext">_grtext</A>, <A HREF="#_gettextsettings">_gettextsettings</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /textsettings/ ts</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _gettextsettings( ts )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _grtext( 100, 100, 'WATCOM'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setcharsize( 2 * ts.height, 2 * ts.width )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _grtext( 100, 300, 'Graphics'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setcharsize( ts.height, ts.width )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>produces the following:
<BR><BR><IMG SRC="eg_getts.bmp" ALIGN=MIDDLE>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD><TT> _setcharsize - DOS</TT>
<BR><BR><TT>_setcharsize_w - DOS</TT>
</DL>
<H2 ID="_setcharspacing"> _setcharspacing, _setcharspacing_w </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>subroutine _setcharspacing( space )</TT>
<BR><TT>integer*2 space</TT>
<BR><BR><TT>subroutine _setcharspacing_w( space )</TT>
<BR><TT>double precision space</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _setcharspacing</TT> routines set the current character spacing to have the value of the argument<B> space</B>.&nbsp;
For the<TT> _setcharspacing</TT> routine,<B> space</B> represents a number of pixels.&nbsp; For the<TT> _setcharspacing_w</TT>
routine,<B> space</B> represents a length along the x-axis in the window coordinate system.
<BR><BR>The character spacing specifies the additional space to leave between characters when a text string is displayed with
the <TT> _grtext</TT> routine.&nbsp; A negative value can be specified to cause the characters to be drawn closer together.
&nbsp;The default value of the character spacing is 0.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_grtext">_grtext</A>, <A HREF="#_gettextsettings">_gettextsettings</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _grtext( 100, 100, 'WATCOM'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setcharspacing( 20 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _grtext( 100, 300, 'Graphics'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>produces the following:
<BR><BR><IMG SRC="eg_setcs.bmp" ALIGN=MIDDLE>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD><TT> _setcharspacing - DOS</TT>
<BR><BR><TT>_setcharspacing_w - DOS</TT>
</DL>
<H2 ID="_setcliprgn"> _setcliprgn </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>subroutine _setcliprgn( x1, y1, x2, y2 )</TT>
<BR><TT>integer*2 x1, y1</TT>
<BR><TT>integer*2 x2, y2</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _setcliprgn</TT> routine restricts the display of graphics output to the clipping region.&nbsp; This region is a rectangle
whose opposite corners are established by the physical points<TT> (x1,y1)</TT> and<TT> (x2,y2).</TT>
<BR><BR>The<TT> _setcliprgn</TT> routine does not affect text output using the <TT> _outtext</TT> and <TT> _outmem</TT> routines.
&nbsp;To control the location of text output, see the <TT> _settextwindow</TT> routine.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_settextwindow">_settextwindow</A>, <A HREF="#_setvieworg">_setvieworg</A>, <A HREF="#_setviewport">_setviewport</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 x1, y1, x2, y2</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _getcliprgn( x1, y1, x2, y2 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setcliprgn( 130, 100, 510, 380 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _ellipse( _GBORDER, 120, 90, 520, 390 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setcliprgn( x1, y1, x2, y2 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_setcolor"> _setcolor </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>integer*2 function _setcolor( pixval )</TT>
<BR><TT>integer*2 pixval</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _setcolor</TT> routine sets the pixel value for the current color to be that indicated by the<B> pixval</B> argument.
&nbsp;The current color is only used by the routines that produce graphics output; text output with <TT> _outtext</TT> uses
the current text color (see the <TT> _settextcolor</TT> routine).&nbsp; The default color value is one less than the maximum
number of colors in the current video mode.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _setcolor</TT> routine returns the previous value of the current color.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getcolor">_getcolor</A>, <A HREF="#_settextcolor">_settextcolor</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer col, old_col</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; old_col = _getcolor()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do col = 0, 15</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setcolor( col )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _rectangle( _GFILLINTERIOR,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 100, 100, 540, 380 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enddo</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setcolor( old_col )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_setfillmask"> _setfillmask </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>subroutine _setfillmask( mask )</TT>
<BR><TT>integer*1 mask(8)</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _setfillmask</TT> routine sets the current fill mask to the value of the argument<B> mask</B>.
<BR><BR>The fill mask is an eight-byte array which is interpreted as a square pattern (8 by 8) of 64 bits.&nbsp; Each bit
in the mask corresponds to a pixel.&nbsp; When a region is filled, each point in the region is mapped onto the fill mask.
&nbsp;When a bit from the mask is one, the pixel value of the corresponding point is set using the current plotting action
with the current color; when the bit is zero, the pixel value of that point is not affected.
<BR><BR>When the fill mask is not set, a fill operation will set all points in the fill region to have a pixel value of the
current color.&nbsp; By default, no fill mask is set.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getfillmask">_getfillmask</A>, <A HREF="#_ellipse">_ellipse</A>, <A HREF="#_floodfill">_floodfill</A>, <A HREF="#_rectangle">_rectangle</A>,
<A HREF="#_polygon">_polygon</A>, <A HREF="#_pie">_pie</A>, <A HREF="#_setcolor">_setcolor</A>, <A HREF="#_setplotaction">_setplotaction</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*1 old_mask(8)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*1 new_mask(8)/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
'81'x, '42'x, '24'x, '18'x,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
'18'x, '24'x, '42'x, '81'x/</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _getfillmask( old_mask )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setfillmask( new_mask )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _rectangle( _GFILLINTERIOR,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; 100, 100, 540, 380 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setfillmask( old_mask )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>produces the following:
<BR><BR><IMG SRC="eg_getfm.bmp" ALIGN=MIDDLE>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_setfont"> _setfont </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>integer*2 function _setfont( opt )</TT>
<BR><TT>character*(*) opt</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _setfont</TT> routine selects a font from the list of registered fonts (see the <TT> _registerfonts</TT> routine).
&nbsp;The font selected becomes the current font and is used whenever text is displayed with the <TT> _outgtext</TT> routine.
&nbsp;The routine will fail if no fonts have been registered, or if a font cannot be found that matches the given characteristics.
<BR><BR>The argument<B> opt</B> is a string of characters specifying the characteristics of the desired font.&nbsp; These
characteristics determine which font is selected.&nbsp; The options may be separated by blanks and are not case-sensitive.
&nbsp;Any number of options may be specified and in any order.&nbsp; The available options are:
<DL>
<DT>hX
<DD>character height X (in pixels)
<DT>wX
<DD>character width X (in pixels)
<DT>f
<DD>choose a fixed-width font
<DT>p
<DD>choose a proportional-width font
<DT>r
<DD>choose a raster (bit-mapped) font
<DT>v
<DD>choose a vector font
<DT>b
<DD>choose the font that best matches the options
<DT>nX
<DD>choose font number X (the number of fonts is returned by the <TT> _registerfonts</TT> routine)
<DT>t'facename'
<DD>choose a font with specified facename
</DL>
<BR>The facename option is specified as a &quot;t&quot; followed by a facename enclosed in single quotes.&nbsp; The available
facenames are:
<DL>
<DT>Courier
<DD>fixed-width raster font with serifs
<DT>Helv
<DD>proportional-width raster font without serifs
<DT>Tms Rmn
<DD>proportional-width raster font with serifs
<DT>Script
<DD>proportional-width vector font that appears similar to hand-writing
<DT>Modern
<DD>proportional-width vector font without serifs
<DT>Roman
<DD>proportional-width vector font with serifs
</DL>
<BR>When &quot;nX&quot; is specified to select a particular font, the other options are ignored.
<BR><BR>If the best fit option (&quot;b&quot;) is specified,<TT> _setfont</TT> will always be able to select a font.&nbsp;
The font chosen will be the one that best matches the options specified.&nbsp; The following precedence is given to the options
when selecting a font:
<OL>
<LI>Pixel height (higher precedence is given to heights less than the specified height)
<LI>Facename
<LI>Pixel width
<LI>Font type (fixed or proportional)
</OL>
<BR>When a pixel height or width does not match exactly and a vector font has been selected, the font will be stretched appropriately
to match the given size.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _setfont</TT> routine returns zero if successful; otherwise, (-1) is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_registerfonts">_registerfonts</A>, <A HREF="#_unregisterfonts">_unregisterfonts</A>, <A HREF="#_getfontinfo">_getfontinfo</A>,
<A HREF="#_outgtext">_outgtext</A>, <A HREF="#_getgtextextent">_getgtextextent</A>, <A HREF="#_setgtextvector">_setgtextvector</A>,
<A HREF="#_getgtextvector">_getgtextvector</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer i, n</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character*10 buff</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n = _registerfonts( '*.fon'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do i = 0, n - 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write( buff, '(''n'', i2.2, a1 )' ) i, char(0)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setfont( buff )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _moveto( 100, 100 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _outgtext( 'WATCOM Graphics'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _clearscreen( _GCLEARSCREEN )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enddo</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _unregisterfonts()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_setgtextvector"> _setgtextvector </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>record /xycoord/ function _setgtextvector( x, y )</TT>
<BR><TT>integer*2 x, y</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _setgtextvector</TT> routine sets the orientation for text output used by the <TT> _outgtext</TT> routine to the vector
specified by the arguments<TT> (x,y).</TT>&nbsp; Each of the arguments can have a value of -1, 0 or 1, allowing for text to
be displayed at any multiple of a 45-degree angle.&nbsp; The default text orientation, for normal left-to-right text, is the
vector<TT> (1,0).</TT>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _setgtextvector</TT> routine returns, as an<TT> xycoord</TT> structure, the previous value of the text orientation
vector.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_registerfonts">_registerfonts</A>, <A HREF="#_unregisterfonts">_unregisterfonts</A>, <A HREF="#_setfont">_setfont</A>,
<A HREF="#_getfontinfo">_getfontinfo</A>, <A HREF="#_outgtext">_outgtext</A>, <A HREF="#_getgtextextent">_getgtextextent</A>,
<A HREF="#_getgtextvector">_getgtextvector</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /xycoord/ old_vec</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; old_vec = _getgtextvector()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setgtextvector( 0, -1 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _moveto( 100, 100 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _outgtext( 'WATCOM Graphics'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setgtextvector( old_vec.xcoord, old_vec.ycoord )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_setlinestyle"> _setlinestyle </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>subroutine _setlinestyle( style )</TT>
<BR><TT>integer*2 style</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _setlinestyle</TT> routine sets the current line-style mask to the value of the<B> style</B> argument.
<BR><BR>The line-style mask determines the style by which lines and arcs are drawn.&nbsp; The mask is treated as an array
of 16 bits.&nbsp; As a line is drawn, a pixel at a time, the bits in this array are cyclically tested.&nbsp; When a bit in
the array is 1, the pixel value for the current point is set using the current color according to the current plotting action;
otherwise, the pixel value for the point is left unchanged.&nbsp; A solid line would result from a value of<TT> 'FFFF'x</TT>
and a dashed line would result from a value of<TT> 'F0F0'x.</TT>
<BR><BR>The default line style mask is<TT> 'FFFF'x.</TT>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getlinestyle">_getlinestyle</A>, <A HREF="#_lineto">_lineto</A>, <A HREF="#_rectangle">_rectangle</A>, <A HREF="#_polygon">_polygon</A>,
<A HREF="#_setplotaction">_setplotaction</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer DASHED</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameter (DASHED='f0f0'x)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer old_style</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; old_style = _getlinestyle()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setlinestyle( DASHED )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _rectangle( _GBORDER, 100, 100, 540, 380 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setlinestyle( old_style )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>produces the following:
<BR><BR><IMG SRC="eg_getls.bmp" ALIGN=MIDDLE>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_setpixel"> _setpixel, _setpixel_w </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>integer*2 function _setpixel( x, y )</TT>
<BR><TT>integer*2 x, y</TT>
<BR><BR><TT>integer*2 function _setpixel_w( x, y )</TT>
<BR><TT>double precision x, y</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _setpixel</TT> routine sets the pixel value of the point<TT> (x,y)</TT> using the current plotting action with the
current color.&nbsp; The<TT> _setpixel</TT> routine uses the view coordinate system.&nbsp; The<TT> _setpixel_w</TT> routine
uses the window coordinate system.
<BR><BR>A pixel value is associated with each point.&nbsp; The values range from 0 to the number of colors (less one) that
can be represented in the palette for the current video mode.&nbsp; The color displayed at the point is the color in the palette
corresponding to the pixel number.&nbsp; For example, a pixel value of 3 causes the fourth color in the palette to be displayed
at the point in question.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _setpixel</TT> routines return the previous value of the indicated pixel if the pixel value can be set; otherwise,
(-1) is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getpixel">_getpixel</A>, <A HREF="#_setcolor">_setcolor</A>, <A HREF="#_setplotaction">_setplotaction</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer x, y, i</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real urand</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer seed</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; seed = 75347</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _rectangle( _GBORDER, 100, 100, 540, 380 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do i = 0, 60000</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = 101 + mod( int( urand( seed )*32767 ),</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; 439 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y = 101 + mod( int( urand( seed )*32767 ),</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; 279 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setcolor( _getpixel( x, y ) + 1 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setpixel( x, y )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enddo</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD><TT> _setpixel - DOS</TT>
<BR><BR><TT>_setpixel_w - DOS</TT>
</DL>
<H2 ID="_setplotaction"> _setplotaction </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>integer*2 function _setplotaction( action )</TT>
<BR><TT>integer*2 action</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _setplotaction</TT> routine sets the current plotting action to the value of the<B> action</B> argument.
<BR><BR>The drawing routines cause pixels to be set with a pixel value.&nbsp; By default, the value to be set is obtained
by replacing the original pixel value with the supplied pixel value.&nbsp; Alternatively, the replaced value may be computed
as a function of the original and the supplied pixel values.
<BR><BR>The plotting action can have one of the following values:
<DL>
<DT>_GPSET
<DD>replace the original screen pixel value with the supplied pixel value
<DT>_GAND
<DD>replace the original screen pixel value with the<B> bitwise and</B> of the original pixel value and the supplied pixel value
<DT>_GOR
<DD>replace the original screen pixel value with the<B> bitwise or</B> of the original pixel value and the supplied pixel value
<DT>_GXOR
<DD>replace the original screen pixel value with the<B> bitwise exclusive-or</B> of the original pixel value and the supplied
pixel value.&nbsp; Performing this operation twice will restore the original screen contents, providing an efficient method
to produce animated effects.
</DL>
</DL>
<DL>
<DT>Returns:
<DD>The previous value of the plotting action is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getplotaction">_getplotaction</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer old_act</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; old_act = _getplotaction()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setplotaction( _GPSET )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _rectangle( _GFILLINTERIOR, 100, 100,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 540, 380 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setplotaction( _GXOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _rectangle( _GFILLINTERIOR, 100, 100,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 540, 380 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setplotaction( old_act )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_settextalign"> _settextalign </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>subroutine _settextalign( horiz, vert )</TT>
<BR><TT>integer*2 horiz, vert</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _settextalign</TT> routine sets the current text alignment to the values specified by the arguments<B> horiz</B> and<B>
vert</B>.&nbsp; When text is displayed with the <TT> _grtext</TT> routine, it is aligned (justified) horizontally and vertically
about the given point according to the current text alignment settings.
<BR><BR>The horizontal component of the alignment can have one of the following values:
<DL>
<DT>_NORMAL
<DD>use the default horizontal alignment for the current setting of the text path
<DT>_LEFT
<DD>the text string is left justified at the given point
<DT>_CENTER
<DD>the text string is centred horizontally about the given point
<DT>_RIGHT
<DD>the text string is right justified at the given point
</DL>
<BR>The vertical component of the alignment can have one of the following values:
<DL>
<DT>_NORMAL
<DD>use the default vertical alignment for the current setting of the text path
<DT>_TOP
<DD>the top of the text string is aligned at the given point
<DT>_CAP
<DD>the cap line of the text string is aligned at the given point
<DT>_HALF
<DD>the text string is centred vertically about the given point
<DT>_BASE
<DD>the base line of the text string is aligned at the given point
<DT>_BOTTOM
<DD>the bottom of the text string is aligned at the given point
</DL>
<BR>The default is to use<TT> _LEFT</TT> alignment for the horizontal component unless the text path is<TT> _PATH_LEFT,</TT>
in which case<TT> _RIGHT</TT> alignment is used.&nbsp; The default value for the vertical component is<TT> _TOP</TT> unless
the text path is<TT> _PATH_UP,</TT> in which case<TT> _BOTTOM</TT> alignment is used.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_grtext">_grtext</A>, <A HREF="#_gettextsettings">_gettextsettings</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _grtext( 200, 100, 'WATCOM'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setpixel( 200, 100 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _settextalign( _CENTER, _HALF )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _grtext( 200, 200, 'Graphics'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setpixel( 200, 200 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>produces the following:
<BR><BR><IMG SRC="eg_setta.bmp" ALIGN=MIDDLE>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_settextcolor"> _settextcolor </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>integer*2 function _settextcolor( pixval )</TT>
<BR><TT>integer*2 pixval</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _settextcolor</TT> routine sets the current text color to be the color indicated by the pixel value of the<B> pixval</B>
argument.&nbsp; This is the color value used for displaying text with the <TT> _outtext</TT> and <TT> _outmem</TT> routines.
&nbsp;Use the <TT> _setcolor</TT> routine to change the color of graphics output.&nbsp; The default text color value is set
to 7 whenever a new video mode is selected.
<BR><BR>The pixel value<B> pixval</B> is a number in the range 0-31.&nbsp; Colors in the range 0-15 are displayed normally.
&nbsp;In text modes, blinking colors are specified by adding 16 to the normal color values.&nbsp; The following table specifies
the default colors in color text modes.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Pixel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Color&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Pixel
&nbsp;&nbsp;&nbsp;&nbsp; Color</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; value&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; value</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Black&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Gray</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Blue&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; 9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Light Blue</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Green&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; 10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Light Green</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Cyan&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; 11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Light Cyan</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Red&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; 12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Light Red</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Magenta&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Light Magenta</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Brown&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; 14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Yellow</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; White&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; 15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Bright White</TT>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _settextcolor</TT> routine returns the pixel value of the previous text color.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_gettextcolor">_gettextcolor</A>, <A HREF="#_outtext">_outtext</A>, <A HREF="#_outmem">_outmem</A>, <A HREF="#_setcolor">_setcolor</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer old_col</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer old_bk</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _TEXTC80 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; old_col = _gettextcolor()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; old_bk = _getbkcolor()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _settextcolor( 7 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setbkcolor( _BLUE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _outtext( ' WATCOM '//char(10)//</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;'Graphics'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _settextcolor( old_col )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setbkcolor( old_bk )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_settextcursor"> _settextcursor </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>integer*2 function _settextcursor( cursor )</TT>
<BR><TT>integer*2 cursor</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _settextcursor</TT> routine sets the attribute, or shape, of the cursor in text modes.&nbsp; The argument<B> cursor</B>
specifies the new cursor shape.&nbsp; The cursor shape is selected by specifying the top and bottom rows in the character
matrix.&nbsp; The high byte of<B> cursor</B> specifies the top row of the cursor; the low byte specifies the bottom row.
<BR><BR>Some typical values for<B> cursor</B> are:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Cursor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Shape</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; '0607'x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; normal underline cursor</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; '0007'x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; full block cursor</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; '0407'x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; half-height block cursor</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; '2000'x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; no cursor</TT>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _settextcursor</TT> routine returns the previous cursor shape when the shape is set successfully; otherwise, (-1)
is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_gettextcursor">_gettextcursor</A>, <A HREF="#_displaycursor">_displaycursor</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 old_shape</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; old_shape = _gettextcursor()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _settextcursor( '0007'x )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _outtext(</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char(10)//'Block cursor'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _settextcursor( '0407'x )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _outtext(</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char(10)//'Half height cursor'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _settextcursor( '2000'x )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _outtext(</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char(10)//'No cursor'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_settextorient"> _settextorient </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>subroutine _settextorient( vecx, vecy )</TT>
<BR><TT>integer*2 vecx, vecy</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _settextorient</TT> routine sets the current text orientation to the vector specified by the arguments<TT> (vecx,vecy).</TT>
&nbsp;The text orientation specifies the direction of the base-line vector when a text string is displayed with the <TT> _grtext</TT>
routine.&nbsp; The default text orientation, for normal left-to-right text, is the vector<TT> (1,0).</TT>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_grtext">_grtext</A>, <A HREF="#_gettextsettings">_gettextsettings</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _grtext( 200, 100, 'WATCOM'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _settextorient( 1, 1 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _grtext( 200, 200, 'Graphics'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>produces the following:
<BR><BR><IMG SRC="eg_setto.bmp" ALIGN=MIDDLE>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_settextpath"> _settextpath </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>subroutine _settextpath( path )</TT>
<BR><TT>integer*2 path</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _settextpath</TT> routine sets the current text path to have the value of the<B> path</B> argument.&nbsp; The text
path specifies the writing direction of the text displayed by the <TT> _grtext</TT> routine.&nbsp; The argument can have one
of the following values:
<DL>
<DT>_PATH_RIGHT
<DD>subsequent characters are drawn to the right of the previous character
<DT>_PATH_LEFT
<DD>subsequent characters are drawn to the left of the previous character
<DT>_PATH_UP
<DD>subsequent characters are drawn above the previous character
<DT>_PATH_DOWN
<DD>subsequent characters are drawn below the previous character
</DL>
<BR>The default value of the text path is<TT> _PATH_RIGHT.</TT>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_grtext">_grtext</A>, <A HREF="#_gettextsettings">_gettextsettings</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _grtext( 200, 100, 'WATCOM'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _settextpath( _PATH_DOWN )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _grtext( 200, 200, 'Graphics'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>produces the following:
<BR><BR><IMG SRC="eg_settx.bmp" ALIGN=MIDDLE>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_settextposition"> _settextposition </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>record /rccoord/ function _settextposition( row, col )</TT>
<BR><TT>integer*2 row, col</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _settextposition</TT> routine sets the current output position for text to be<TT> (row,col)</TT> where this position
is in terms of characters, not pixels.
<BR><BR>The text position is relative to the current text window.&nbsp; It defaults to the top left corner of the screen,<TT>
(1,1),</TT> when a new video mode is selected, or when a new text window is set.&nbsp; The position is updated as text is
drawn with the <TT> _outtext</TT> and <TT> _outmem</TT> routines.
<BR><BR>Note that the output position for graphics output differs from that for text output.&nbsp; The output position for
graphics output can be set by use of the <TT> _moveto</TT> routine.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _settextposition</TT> routine returns, as an<TT> rccoord</TT> structure, the previous output position for text.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_gettextposition">_gettextposition</A>, <A HREF="#_outtext">_outtext</A>, <A HREF="#_outmem">_outmem</A>, <A HREF="#_settextwindow">_settextwindow</A>,
<A HREF="#_moveto">_moveto</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /rccoord/ old_pos</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _TEXTC80 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; old_pos = _gettextposition()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _settextposition( 10, 40 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _outtext( 'WATCOM Graphics'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _settextposition( old_pos.row, old_pos.col )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_settextrows"> _settextrows </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>integer*2 function _settextrows( rows )</TT>
<BR><TT>integer*2 rows</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _settextrows</TT> routine selects the number of rows of text displayed on the screen.&nbsp; The number of rows is
specified by the argument<B> rows</B>.&nbsp; Computers equipped with EGA, MCGA and VGA adapters can support different numbers
of text rows.&nbsp; The number of rows that can be selected depends on the current video mode and the type of monitor attached.
<BR><BR>If the argument<B> rows</B> has the value<B> _MAXTEXTROWS</B>, the maximum number of text rows will be selected for
the current video mode and hardware configuration.&nbsp; In text modes the maximum number of rows is 43 for EGA adapters,
and 50 for MCGA and VGA adapters.&nbsp; Some graphics modes will support 43 rows for EGA adapters and 60 rows for MCGA and
VGA adapters.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _settextrows</TT> routine returns the number of screen rows when the number of rows is set successfully; otherwise,
zero is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getvideoconfig">_getvideoconfig</A>, <A HREF="#_setvideomode">_setvideomode</A>, <A HREF="#_setvideomoderows">_setvideomoderows</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer valid_rows(8)/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 14, 25, 28, 30,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 34, 43, 50, 60/</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer i, j, rows</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character*80 buff</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do i = 0, 7</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rows = valid_rows( i )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( _settextrows( rows ) .eq. rows )then</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do j = 1, rows</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
write( buff, '(''Line '', i2, a1 )' )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; j, char(0)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
call _settextposition( j, 1 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
call _outtext( buff )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enddo</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endif</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enddo</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_settextwindow"> _settextwindow </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>subroutine _settextwindow( row1, col1, row2, col2 )</TT>
<BR><TT>integer*2 row1, col1</TT>
<BR><TT>integer*2 row2, col2</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _settextwindow</TT> routine sets the text window to be the rectangle with a top left corner at<TT> (row1,col1)</TT>
and a bottom right corner at<TT> (row2,col2).</TT>&nbsp; These coordinates are in terms of characters not pixels.
<BR><BR>The initial text output position is<TT> (1,1).</TT>&nbsp; Subsequent text positions are reported (by the <TT> _gettextposition</TT>
routine) and set (by the <TT> _outtext</TT>, <TT> _outmem</TT> and <TT> _settextposition</TT> routines) relative to this rectangle.
<BR><BR>Text is displayed from the current output position for text proceeding along the current row and then downwards.&nbsp;
When the window is full, the lines scroll upwards one line and then text is displayed on the last line of the window.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_gettextposition">_gettextposition</A>, <A HREF="#_outtext">_outtext</A>, <A HREF="#_outmem">_outmem</A>, <A HREF="#_settextposition">_settextposition</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer i</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 r1, c1, r2, c2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character*80 buff</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _TEXTC80 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _gettextwindow( r1, c1, r2, c2 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _settextwindow( 5, 20, 20, 40 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do i = 1, 20</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write( buff, '(''Line '', i2, a1, a1 )' )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i, char(10), char(0)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _outtext( buff )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enddo</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _settextwindow( r1, c1, r2, c2 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_setvideomode"> _setvideomode </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>integer*2 function _setvideomode( mode )</TT>
<BR><TT>integer*2 mode</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _setvideomode</TT> routine sets the video mode according to the value of the<B> mode</B> argument.&nbsp; The value
of<B> mode</B> can be one of the following:&nbsp; uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 uindex=2
uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 uindex=2
uindex=2 uindex=2 uindex=2 
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Mode&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Type&nbsp;&nbsp;&nbsp; Size
&nbsp;&nbsp; Colors&nbsp;&nbsp;&nbsp; Adapter</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _MAXRESMODE&nbsp;&nbsp; (graphics mode with highest resolution)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _MAXCOLORMODE (graphics mode with most colors)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _DEFAULTMODE&nbsp; (restores screen to original mode)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXTBW40&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; M,T&nbsp;&nbsp;&nbsp; 40 x 25&nbsp;&nbsp;&nbsp; 16
&nbsp; MDPA,HGC,VGA,SVGA</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXTC40&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C,T&nbsp;&nbsp;&nbsp; 40 x 25&nbsp;&nbsp;&nbsp;
16&nbsp;&nbsp; CGA,EGA,MCGA,VGA,SVGA</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXTBW80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; M,T&nbsp;&nbsp;&nbsp; 80 x 25&nbsp;&nbsp;&nbsp; 16
&nbsp; MDPA,HGC,VGA,SVGA</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXTC80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C,T&nbsp;&nbsp;&nbsp; 80 x 25&nbsp;&nbsp;&nbsp;
16&nbsp;&nbsp; CGA,EGA,MCGA,VGA,SVGA</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _MRES4COLOR&nbsp;&nbsp;&nbsp; C,G&nbsp;&nbsp; 320 x 200&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp; CGA,EGA,MCGA,VGA,SVGA</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _MRESNOCOLOR&nbsp;&nbsp; C,G&nbsp;&nbsp; 320 x 200&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp; CGA,EGA,MCGA,VGA,SVGA</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _HRESBW&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C,G&nbsp;&nbsp; 640 x 200&nbsp;&nbsp;&nbsp;
2&nbsp;&nbsp; CGA,EGA,MCGA,VGA,SVGA</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXTMONO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; M,T&nbsp;&nbsp;&nbsp; 80 x 25&nbsp;&nbsp;&nbsp; 16
&nbsp; MDPA,HGC,VGA,SVGA</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _HERCMONO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; M,G&nbsp;&nbsp; 720 x 350&nbsp;&nbsp;&nbsp; 2&nbsp;
&nbsp;HGC</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _MRES16COLOR&nbsp;&nbsp; C,G&nbsp;&nbsp; 320 x 200&nbsp;&nbsp; 16&nbsp;&nbsp; EGA,VGA,SVGA</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _HRES16COLOR&nbsp;&nbsp; C,G&nbsp;&nbsp; 640 x 200&nbsp;&nbsp; 16&nbsp;&nbsp; EGA,VGA,SVGA</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _ERESNOCOLOR&nbsp;&nbsp; M,G&nbsp;&nbsp; 640 x 350&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp; EGA,VGA,SVGA</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _ERESCOLOR&nbsp;&nbsp;&nbsp;&nbsp; C,G&nbsp;&nbsp; 640 x 350&nbsp; 4/16&nbsp; EGA,VGA,SVGA</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _VRES2COLOR&nbsp;&nbsp;&nbsp; C,G&nbsp;&nbsp; 640 x 480&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp; MCGA,VGA,SVGA</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _VRES16COLOR&nbsp;&nbsp; C,G&nbsp;&nbsp; 640 x 480&nbsp;&nbsp; 16&nbsp;&nbsp; VGA,SVGA</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _MRES256COLOR&nbsp; C,G&nbsp;&nbsp; 320 x 200&nbsp; 256&nbsp;&nbsp; MCGA,VGA,SVGA</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _URES256COLOR&nbsp; C,G&nbsp;&nbsp; 640 x 400&nbsp; 256&nbsp;&nbsp; SVGA</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _VRES256COLOR&nbsp; C,G&nbsp;&nbsp; 640 x 480&nbsp; 256&nbsp;&nbsp; SVGA</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _SVRES16COLOR&nbsp; C,G&nbsp;&nbsp; 800 x 600&nbsp;&nbsp; 16&nbsp;&nbsp; SVGA</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _SVRES256COLOR C,G&nbsp;&nbsp; 800 x 600&nbsp; 256&nbsp;&nbsp; SVGA</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _XRES16COLOR&nbsp;&nbsp; C,G&nbsp; 1024 x 768&nbsp;&nbsp; 16&nbsp;&nbsp; SVGA</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _XRES256COLOR&nbsp; C,G&nbsp; 1024 x 768&nbsp; 256&nbsp;&nbsp; SVGA</TT>
<BR><BR>In the preceding table, the Type column contains the following letters:
<DL>
<DT>M
<DD>indicates monochrome; multiple colors are shades of grey
<DT>C
<DD>indicates color
<DT>G
<DD>indicates graphics mode; size is in pixels
<DT>T
<DD>indicates text mode; size is in columns and rows of characters
</DL>
<BR>The Adapter column contains the following codes:
<DL>
<DT>MDPA
<DD>IBM Monochrome Display/Printer Adapter
<DT>CGA
<DD>IBM Color Graphics Adapter
<DT>EGA
<DD>IBM Enhanced Graphics Adapter
<DT>VGA
<DD>IBM Video Graphics Array
<DT>MCGA
<DD>IBM Multi-Color Graphics Array
<DT>HGC
<DD>Hercules Graphics Adapter
<DT>SVGA
<DD>SuperVGA adapters
</DL>
<BR>The modes<TT> _MAXRESMODE</TT> and<TT> _MAXCOLORMODE</TT> will select from among the video modes supported by the current
graphics adapter the one that has the highest resolution or the greatest number of colors.&nbsp; The video mode will be selected
from the standard modes, not including the SuperVGA modes.
<BR><BR>Selecting a new video mode resets the current output positions for graphics and text to be the top left corner of
the screen.&nbsp; The background color is reset to black and the default color value is set to be one less than the number
of colors in the selected mode.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _setvideomode</TT> routine returns the number of text rows when the new mode is successfully selected; otherwise,
zero is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getvideoconfig">_getvideoconfig</A>, <A HREF="#_settextrows">_settextrows</A>, <A HREF="#_setvideomoderows">_setvideomoderows</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer mode</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /videoconfig/ vc</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character*80 buff</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _getvideoconfig( vc )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select( vc.adapter )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case( _VGA, _SVGA )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode = _VRES16COLOR</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case( _MCGA )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode = _MRES256COLOR</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case( _EGA )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( vc.monitor .eq. _MONO )then</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode = _ERESNOCOLOR</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode = _ERESCOLOR</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endif</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case( _CGA )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode = _MRES4COLOR</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case( _HERCULES )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode = _HERCMONO</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case default</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stop 'No graphics adapter'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endselect</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( _setvideomode( mode ) .ne. 0 )then</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _getvideoconfig( vc )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write( buff,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '( i3, '' x '',
i3, '' x '', i3, a1 )' )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vc.numxpixels,
vc.numypixels,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vc.numcolors, char(0)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _outtext( buff )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endif</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_setvideomoderows"> _setvideomoderows </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>integer*2 function _setvideomoderows( mode, rows )</TT>
<BR><TT>integer*2 mode</TT>
<BR><TT>integer*2 rows</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _setvideomoderows</TT> routine selects a video mode and the number of rows of text displayed on the screen.&nbsp;
The video mode is specified by the argument<B> mode</B> and is selected with the <TT> _setvideomode</TT> routine.&nbsp; The
number of rows is specified by the argument<B> rows</B> and is selected with the <TT> _settextrows</TT> routine.
<BR><BR>Computers equipped with EGA, MCGA and VGA adapters can support different numbers of text rows.&nbsp; The number of
rows that can be selected depends on the video mode and the type of monitor attached.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _setvideomoderows</TT> routine returns the number of screen rows when the mode and number of rows are set successfully;
otherwise, zero is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getvideoconfig">_getvideoconfig</A>, <A HREF="#_setvideomode">_setvideomode</A>, <A HREF="#_settextrows">_settextrows</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer rows</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character*80 buff</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rows = _setvideomoderows( _TEXTC80, _MAXTEXTROWS )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( rows .ne. 0 )then</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write( buff,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '(''Number of rows
is '', i2, a1 )' )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rows, char(0)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _outtext( buff )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endif</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_setvieworg"> _setvieworg </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>record /xycoord/ function _setvieworg( x, y )</TT>
<BR><TT>integer*2 x, y</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _setvieworg</TT> routine sets the origin of the view coordinate system,<TT> (0,0),</TT> to be located at the physical
point<TT> (x,y).</TT>&nbsp; This causes subsequently drawn images to be translated by the amount<TT> (x,y).</TT>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _setvieworg</TT> routine returns, as an<TT> xycoord</TT> structure, the physical coordinates of the previous origin.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getviewcoord">_getviewcoord</A>, <A HREF="#_getphyscoord">_getphyscoord</A>, <A HREF="#_setcliprgn">_setcliprgn</A>,
<A HREF="#_setviewport">_setviewport</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvieworg( 320, 240 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _ellipse( _GBORDER, -200, -150, 200, 150 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_setviewport"> _setviewport </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>subroutine _setviewport( x1, y1, x2, y2 )</TT>
<BR><TT>integer*2 x1, y1</TT>
<BR><TT>integer*2 x2, y2</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _setviewport</TT> routine restricts the display of graphics output to the clipping region and then sets the origin
of the view coordinate system to be the top left corner of the region.&nbsp; This region is a rectangle whose opposite corners
are established by the physical points<TT> (x1,y1)</TT> and<TT> (x2,y2).</TT>
<BR><BR>The<TT> _setviewport</TT> routine does not affect text output using the <TT> _outtext</TT> and <TT> _outmem</TT> routines.
&nbsp;To control the location of text output, see the <TT> _settextwindow</TT> routine.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_setcliprgn">_setcliprgn</A>, <A HREF="#_setvieworg">_setvieworg</A>, <A HREF="#_settextwindow">_settextwindow</A>,
<A HREF="#_setwindow">_setwindow</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer XSIZE, YSIZE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameter (XSIZE=380)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameter (YSIZE=280)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setviewport( 130, 100,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; 130 + XSIZE, 100 + YSIZE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _ellipse( _GBORDER, 0, 0, XSIZE, YSIZE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_setvisualpage"> _setvisualpage </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>integer*2 function _setvisualpage( pagenum )</TT>
<BR><TT>integer*2 pagenum</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _setvisualpage</TT> routine selects the page (in memory) from which graphics output is displayed.&nbsp; The page to
be selected is given by the<B> pagenum</B> argument.
<BR><BR>Only some combinations of video modes and hardware allow multiple pages of graphics to exist.&nbsp; When multiple
pages are supported, the active page may differ from the visual page.&nbsp; The graphics information in the visual page determines
what is displayed upon the screen.&nbsp; Animation may be accomplished by alternating the visual page.&nbsp; A graphics page
can be constructed without affecting the screen by setting the active page to be different than the visual page.
<BR><BR>The number of available video pages can be determined by using the <TT> _getvideoconfig</TT> routine.&nbsp; The default
video page is 0.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _setvisualpage</TT> routine returns the number of the previous page when the visual page is set successfully; otherwise,
a negative number is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getvisualpage">_getvisualpage</A>, <A HREF="#_setactivepage">_setactivepage</A>, <A HREF="#_getactivepage">_getactivepage</A>,
<A HREF="#_getvideoconfig">_getvideoconfig</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer old_apage, old_vpage</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _HRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; old_apage = _getactivepage()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; old_vpage = _getvisualpage()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! draw an ellipse on page 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setactivepage( 0 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvisualpage( 0 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _ellipse( _GFILLINTERIOR, 100, 50,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 540, 150 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! draw a rectangle on page 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setactivepage( 1 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _rectangle( _GFILLINTERIOR, 100, 50,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 540, 150 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! display page 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvisualpage( 1 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setactivepage( old_apage )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvisualpage( old_vpage )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_setwindow"> _setwindow </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>integer*2 function _setwindow( invert, x1, y1, x2, y2 )</TT>
<BR><TT>logical invert</TT>
<BR><TT>double precision x1, y1</TT>
<BR><TT>double precision x2, y2</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _setwindow</TT> routine defines a window for the window coordinate system.&nbsp; Window coordinates are specified
as a user-defined range of values.&nbsp; This allows for consistent pictures regardless of the video mode.
<BR><BR>The window is defined as the region with opposite corners established by the points<TT> (x1,y1)</TT> and<TT> (x2,y2).</TT>
&nbsp;The argument<B> invert</B> specifies the direction of the y-axis.&nbsp; If the value is<TT> .TRUE.,</TT> the y values
increase from the bottom of the screen to the top, otherwise, the y values increase as you move down the screen.
<BR><BR>The window defined by the<TT> _setwindow</TT> routine is displayed in the current viewport.&nbsp; A viewport is defined
by the <TT> _setviewport</TT> routine.
<BR><BR>By default, the window coordinate system is defined with the point<TT> (0.0,0.0)</TT> located at the lower left corner
of the screen, and the point<TT> (1.0,1.0)</TT> at the upper right corner.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _setwindow</TT> routine returns a non-zero value when the window is set successfully; otherwise, zero is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_setviewport">_setviewport</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _MAXRESMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call draw_house( 'Default window'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setwindow( .TRUE., -0.5, -0.5, 1.5, 1.5 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call draw_house( 'Larger window'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setwindow( .TRUE., 0.0, 0.0, 0.5, 1.0 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call draw_house( 'Left side'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subroutine draw_house( msg )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character*80 msg</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _clearscreen( _GCLEARSCREEN )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _outtext( msg )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _rectangle_w( _GBORDER, 0.2, 0.1, 0.8, 0.6 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _moveto_w( 0.1, 0.5 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _lineto_w( 0.5, 0.9 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _lineto_w( 0.9, 0.5 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _arc_w( 0.4, 0.5, 0.6, 0.3,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.6,
0.4, 0.4, 0.4 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _rectangle_w( _GBORDER, 0.4, 0.1, 0.6, 0.4 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_unregisterfonts"> _unregisterfonts </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>subroutine _unregisterfonts()</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _unregisterfonts</TT> routine frees the memory previously allocated by the <TT> _registerfonts</TT> routine.&nbsp;
The currently selected font is also unloaded.
<BR><BR>Attempting to use the <TT> _setfont</TT> routine after calling<TT> _unregisterfonts</TT> will result in an error.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_registerfonts">_registerfonts</A>, <A HREF="#_setfont">_setfont</A>, <A HREF="#_getfontinfo">_getfontinfo</A>,
<A HREF="#_outgtext">_outgtext</A>, <A HREF="#_getgtextextent">_getgtextextent</A>, <A HREF="#_setgtextvector">_setgtextvector</A>,
<A HREF="#_getgtextvector">_getgtextvector</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer i, n</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character*10 buff</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n = _registerfonts( '*.fon'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do i = 0, n - 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write( buff, '(''n'', i2.2, a1 )' ) i, char(0)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setfont( buff )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _moveto( 100, 100 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _outgtext( 'WATCOM Graphics'c )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _clearscreen( _GCLEARSCREEN )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enddo</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _unregisterfonts()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_wrapon"> _wrapon </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>integer*2 function _wrapon( wrap )</TT>
<BR><TT>integer*2 wrap</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _wrapon</TT> routine is used to control the display of text when the text output reaches the right side of the text
window.&nbsp; This is text displayed with the <TT> _outtext</TT> and <TT> _outmem</TT> routines.&nbsp; The<B> wrap</B> argument
can take one of the following values:
<DL>
<DT>_GWRAPON
<DD>causes lines to wrap at the window border
<DT>_GWRAPOFF
<DD>causes lines to be truncated at the window border
</DL>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _wrapon</TT> routine returns the previous setting for wrapping.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_outtext">_outtext</A>, <A HREF="#_outmem">_outmem</A>, <A HREF="#_settextwindow">_settextwindow</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer i</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character buff*80</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _TEXTC80 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _settextwindow( 5, 20, 20, 30 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _wrapon( _GWRAPOFF )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do i = 1, 3</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _settextposition( 2 * i, 1 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write( buff,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '(''Very very long
line '', i2, a1)' )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i, char(0)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _outtext( buff )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enddo</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _wrapon( _GWRAPON )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do i = 4, 6</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _settextposition( 2 * i, 1 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write( buff,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '(''Very very long
line '', i2, a1)' )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i, char(0)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _outtext( buff )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enddo</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
</BODY>
