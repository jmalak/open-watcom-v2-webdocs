<HEAD>
<TITLE> Open Watcom 2.0 C++ Class Library Reference </TITLE>
</HEAD>
<BODY>
<H1 ID="Index_of_Topics"> Index of Topics </H1>
<DL>
<DT>- A -
<DD><A HREF="#String__alloc_mult_sizeLR">alloc_mult_size() [String]</A>
<BR><A HREF="#strstreambuf__alloc_size_incrementLR">alloc_size_increment() [strstreambuf]</A>
<BR><A HREF="#streambuf__allocateLR">allocate() [streambuf]</A>
<BR><A HREF="#WCIsvSListXTypeY__appendLR__WCIsvDListXTypeY__appendLR">append() [WCIsvSList&lt;Type&gt;,WCIsvDList&lt;Type&gt;]</A>
<BR><A HREF="#WCIsvSListIterXTypeY__appendLR__WCIsvDListIterXTypeY__appendLR">append() [WCIsvSListIter&lt;Type&gt;,WCIsvDListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrOrderedVectorXTypeY__appendLR">append() [WCPtrOrderedVector&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrSListXTypeY__appendLR__WCPtrDListXTypeY__appendLR">append() [WCPtrSList&lt;Type&gt;,WCPtrDList&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrSListIterXTypeY__appendLR__WCPtrDListIterXTypeY__appendLR">append() [WCPtrSListIter&lt;Type&gt;,WCPtrDListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCValOrderedVectorXTypeY__appendLR">append() [WCValOrderedVector&lt;Type&gt;]</A>
<BR><A HREF="#WCValSListXTypeY__appendLR__WCValDListXTypeY__appendLR">append() [WCValSList&lt;Type&gt;,WCValDList&lt;Type&gt;]</A>
<BR><A HREF="#WCValSListIterXTypeY__appendLR__WCValDListIterXTypeY__appendLR">append() [WCValSListIter&lt;Type&gt;,WCValDListIter&lt;Type&gt;]</A>
<BR><A HREF="#filebuf__attachLR">attach() [filebuf]</A>
<BR><A HREF="#fstreambase__attachLR">attach() [fstreambase]</A>
<DT>- B -
<DD><A HREF="#ios__badLR">bad() [ios]</A>
<BR><A HREF="#streambuf__baseLR">base() [streambuf]</A>
<BR><A HREF="#ios__bitallocLR">bitalloc() [ios]</A>
<BR><A HREF="#WCPtrHashDictXKey_ValueY__bitHashLR">bitHash() [WCPtrHashDict&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCPtrHashTableXTypeY__bitHashLR__WCPtrHashSetXTypeY__bitHashLR">bitHash() [WCPtrHashTable&lt;Type&gt;,WCPtrHashSet&lt;Type&gt;]</A>
<BR><A HREF="#WCValHashDictXKey_ValueY__bitHashLR">bitHash() [WCValHashDict&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCValHashTableXTypeY__bitHashLR__WCValHashSetXTypeY__bitHashLR">bitHash() [WCValHashTable&lt;Type&gt;,WCValHashSet&lt;Type&gt;]</A>
<BR><A HREF="#streambuf__blenLR">blen() [streambuf]</A>
<BR><A HREF="#WCPtrHashDictXKey_ValueY__bucketsLR">buckets() [WCPtrHashDict&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCPtrHashTableXTypeY__bucketsLR__WCPtrHashSetXTypeY__bucketsLR">buckets() [WCPtrHashTable&lt;Type&gt;,WCPtrHashSet&lt;Type&gt;]</A>
<BR><A HREF="#WCValHashDictXKey_ValueY__bucketsLR">buckets() [WCValHashDict&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCValHashTableXTypeY__bucketsLR__WCValHashSetXTypeY__bucketsLR">buckets() [WCValHashTable&lt;Type&gt;,WCValHashSet&lt;Type&gt;]</A>
<DT>- C -
<DD><A HREF="#cerr">cerr</A>
<BR><A HREF="#cin">cin</A>
<BR><A HREF="#ios__clearLR">clear() [ios]</A>
<BR><A HREF="#WCIsvSListXTypeY__clearLR__WCIsvDListXTypeY__clearLR">clear() [WCIsvSList&lt;Type&gt;,WCIsvDList&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrHashDictXKey_ValueY__clearLR">clear() [WCPtrHashDict&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCPtrHashTableXTypeY__clearLR__WCPtrHashSetXTypeY__clearLR">clear() [WCPtrHashTable&lt;Type&gt;,WCPtrHashSet&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrSkipListXTypeY__clearLR__WCPtrSkipListSetXTypeY__clearLR">clear() [WCPtrSkipList&lt;Type&gt;,WCPtrSkipListSet&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrSkipListDictXKey_ValueY__clearLR">clear() [WCPtrSkipListDict&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCPtrSListXTypeY__clearLR__WCPtrDListXTypeY__clearLR">clear() [WCPtrSList&lt;Type&gt;,WCPtrDList&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrSortedVectorXTypeY__clearLR__WCPtrOrderedVectorXTypeY__clearLR">clear() [WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrVectorXTypeY__clearLR">clear() [WCPtrVector&lt;Type&gt;]</A>
<BR><A HREF="#WCQueueXType_FTypeY__clearLR">clear() [WCQueue&lt;Type,FType&gt;]</A>
<BR><A HREF="#WCStackXType_FTypeY__clearLR">clear() [WCStack&lt;Type,FType&gt;]</A>
<BR><A HREF="#WCValHashDictXKey_ValueY__clearLR">clear() [WCValHashDict&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCValHashTableXTypeY__clearLR__WCValHashSetXTypeY__clearLR">clear() [WCValHashTable&lt;Type&gt;,WCValHashSet&lt;Type&gt;]</A>
<BR><A HREF="#WCValSkipListXTypeY__clearLR__WCValSkipListSetXTypeY__clearLR">clear() [WCValSkipList&lt;Type&gt;,WCValSkipListSet&lt;Type&gt;]</A>
<BR><A HREF="#WCValSkipListDictXKey_ValueY__clearLR">clear() [WCValSkipListDict&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCValSListXTypeY__clearLR__WCValDListXTypeY__clearLR">clear() [WCValSList&lt;Type&gt;,WCValDList&lt;Type&gt;]</A>
<BR><A HREF="#WCValSortedVectorXTypeY__clearLR__WCValOrderedVectorXTypeY__clearLR">clear() [WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;]</A>
<BR><A HREF="#WCValVectorXTypeY__clearLR">clear() [WCValVector&lt;Type&gt;]</A>
<BR><A HREF="#WCIsvSListXTypeY_WCIsvDListXTypeY__clearAndDestroyLR">clearAndDestroy() [WCIsvSList&lt;Type&gt;,WCIsvDList&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrHashDictXKey_ValueY__clearAndDestroyLR">clearAndDestroy() [WCPtrHashDict&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCPtrHashTableXTypeY_WCPtrHashSetXTypeY__clearAndDestroyLR">clearAndDestroy() [WCPtrHashTable&lt;Type&gt;,WCPtrHashSet&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrSkipListXTypeY_WCPtrSkipListSetXTypeY__clearAndDestroyLR">clearAndDestroy() [WCPtrSkipList&lt;Type&gt;,WCPtrSkipListSet&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrSkipListDictXKey_ValueY__clearAndDestroyLR">clearAndDestroy() [WCPtrSkipListDict&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCPtrSListXTypeY_WCPtrDListXTypeY__clearAndDestroyLR">clearAndDestroy() [WCPtrSList&lt;Type&gt;,WCPtrDList&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrSortedVectorXTypeY_WCPtrOrderedVectorXTypeY__clearAndDestroyLR">clearAndDestroy() [WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrVectorXTypeY__clearAndDestroyLR">clearAndDestroy() [WCPtrVector&lt;Type&gt;]</A>
<BR><A HREF="#WCValSListXTypeY_WCValDListXTypeY__clearAndDestroyLR">clearAndDestroy() [WCValSList&lt;Type&gt;,WCValDList&lt;Type&gt;]</A>
<BR><A HREF="#clog">clog</A>
<BR><A HREF="#filebuf__closeLR">close() [filebuf]</A>
<BR><A HREF="#fstreambase__closeLR">close() [fstreambase]</A>
<BR><A HREF="#Common_Types">Common Types</A>
<BR><A HREF="#Complex_absLR">Complex abs() [Complex]</A>
<BR><A HREF="#Complex_acosLR">Complex acos() [Complex]</A>
<BR><A HREF="#Complex_acoshLR">Complex acosh() [Complex]</A>
<BR><A HREF="#Complex_argLR">Complex arg() [Complex]</A>
<BR><A HREF="#Complex_asinLR">Complex asin() [Complex]</A>
<BR><A HREF="#Complex_asinhLR">Complex asinh() [Complex]</A>
<BR><A HREF="#Complex_atanLR">Complex atan() [Complex]</A>
<BR><A HREF="#Complex_atanhLR">Complex atanh() [Complex]</A>
<BR><A HREF="#Complex_Class">Complex Class</A>
<BR><A HREF="#Complex_Class_Description">Complex Class Description</A>
<BR><A HREF="#Complex_conjLR">Complex conj() [Complex]</A>
<BR><A HREF="#Complex_cosLR">Complex cos() [Complex]</A>
<BR><A HREF="#Complex_coshLR">Complex cosh() [Complex]</A>
<BR><A HREF="#Complex_expLR">Complex exp() [Complex]</A>
<BR><A HREF="#Complex_imagLR">Complex imag() [Complex]</A>
<BR><A HREF="#Complex_logLR">Complex log() [Complex]</A>
<BR><A HREF="#Complex_log10LR">Complex log10() [Complex]</A>
<BR><A HREF="#Complex_normLR">Complex norm() [Complex]</A>
<BR><A HREF="#Complex_operator__ELR">Complex operator !=() [Complex]</A>
<BR><A HREF="#Complex_operator_TLR">Complex operator *() [Complex]</A>
<BR><A HREF="#Complex_operator_PLR">Complex operator +() [Complex]</A>
<BR><A HREF="#Complex_operator_MLR">Complex operator -() [Complex]</A>
<BR><A HREF="#Complex_operator_DLR">Complex operator /() [Complex]</A>
<BR><A HREF="#Complex_operator_XXLR">Complex operator &lt;&lt;() [Complex]</A>
<BR><A HREF="#Complex_operator_EELR">Complex operator ==() [Complex]</A>
<BR><A HREF="#Complex_operator_YYLR">Complex operator &gt;&gt;() [Complex]</A>
<BR><A HREF="#Complex_polarLR">Complex polar() [Complex]</A>
<BR><A HREF="#Complex_powLR">Complex pow() [Complex]</A>
<BR><A HREF="#Complex_realLR">Complex real() [Complex]</A>
<BR><A HREF="#Complex_sinLR">Complex sin() [Complex]</A>
<BR><A HREF="#Complex_sinhLR">Complex sinh() [Complex]</A>
<BR><A HREF="#Complex_sqrtLR">Complex sqrt() [Complex]</A>
<BR><A HREF="#Complex_tanLR">Complex tan() [Complex]</A>
<BR><A HREF="#Complex_tanhLR">Complex tanh() [Complex]</A>
<BR><A HREF="#Complex__ComplexLR">Complex() [Complex]</A>
<BR><A HREF="#Container_Allocators_and_Deallocators">Container Allocators and Deallocators</A>
<BR><A HREF="#Container_Exception_Classes">Container Exception Classes</A>
<BR><A HREF="#WCIsvConstSListIterXTypeY_WCIsvConstDListIterXTypeY__containerLR">container() [WCIsvConstSListIter&lt;Type&gt;,WCIsvConstDListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCIsvSListIterXTypeY_WCIsvDListIterXTypeY__containerLR">container() [WCIsvSListIter&lt;Type&gt;,WCIsvDListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrConstSListIterXTypeY_WCPtrConstDListIterXTypeY__containerLR">container() [WCPtrConstSListIter&lt;Type&gt;,WCPtrConstDListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrHashDictIterXKey_ValueY__containerLR">container() [WCPtrHashDictIter&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCPtrHashSetIterXTypeY_WCPtrHashTableIterXTypeY__containerLR">container() [WCPtrHashSetIter&lt;Type&gt;,WCPtrHashTableIter&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrSListIterXTypeY_WCPtrDListIterXTypeY__containerLR">container() [WCPtrSListIter&lt;Type&gt;,WCPtrDListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCValConstSListIterXTypeY_WCValConstDListIterXTypeY__containerLR">container() [WCValConstSListIter&lt;Type&gt;,WCValConstDListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCValHashDictIterXKey_ValueY__containerLR">container() [WCValHashDictIter&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCValHashSetIterXTypeY_WCValHashTableIterXTypeY__containerLR">container() [WCValHashSetIter&lt;Type&gt;,WCValHashTableIter&lt;Type&gt;]</A>
<BR><A HREF="#WCValSListIterXTypeY_WCValDListIterXTypeY__containerLR">container() [WCValSListIter&lt;Type&gt;,WCValDListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCIsvSListXTypeY__containsLR__WCIsvDListXTypeY__containsLR">contains() [WCIsvSList&lt;Type&gt;,WCIsvDList&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrHashDictXKey_ValueY__containsLR">contains() [WCPtrHashDict&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCPtrHashTableXTypeY__containsLR__WCPtrHashSetXTypeY__containsLR">contains() [WCPtrHashTable&lt;Type&gt;,WCPtrHashSet&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrSkipListXTypeY__containsLR__WCPtrSkipListSetXTypeY__containsLR">contains() [WCPtrSkipList&lt;Type&gt;,WCPtrSkipListSet&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrSkipListDictXKey_ValueY__containsLR">contains() [WCPtrSkipListDict&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCPtrSListXTypeY__containsLR__WCPtrDListXTypeY__containsLR">contains() [WCPtrSList&lt;Type&gt;,WCPtrDList&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrSortedVectorXTypeY_WCPtrOrderedVectorXTypeY__containsLR">contains() [WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;]</A>
<BR><A HREF="#WCValHashDictXKey_ValueY__containsLR">contains() [WCValHashDict&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCValHashTableXTypeY__containsLR__WCValHashSetXTypeY__containsLR">contains() [WCValHashTable&lt;Type&gt;,WCValHashSet&lt;Type&gt;]</A>
<BR><A HREF="#WCValSkipListXTypeY__containsLR__WCValSkipListSetXTypeY__containsLR">contains() [WCValSkipList&lt;Type&gt;,WCValSkipListSet&lt;Type&gt;]</A>
<BR><A HREF="#WCValSkipListDictXKey_ValueY__containsLR">contains() [WCValSkipListDict&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCValSListXTypeY__containsLR__WCValDListXTypeY__containsLR">contains() [WCValSList&lt;Type&gt;,WCValDList&lt;Type&gt;]</A>
<BR><A HREF="#WCValSortedVectorXTypeY_WCValOrderedVectorXTypeY__containsLR">contains() [WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;]</A>
<BR><A HREF="#cout">cout</A>
<BR><A HREF="#WCIsvConstSListIterXTypeY__currentLR__WCIsvConstDListIterXTypeY__currentLR">current() [WCIsvConstSListIter&lt;Type&gt;,WCIsvConstDListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCIsvSListIterXTypeY__currentLR__WCIsvDListIterXTypeY__currentLR">current() [WCIsvSListIter&lt;Type&gt;,WCIsvDListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrConstSListIterXTypeY__currentLR__WCPtrConstDListIterXTypeY__currentLR">current() [WCPtrConstSListIter&lt;Type&gt;,WCPtrConstDListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrHashSetIterXTypeY__currentLR__WCPtrHashTableIterXTypeY__currentLR">current() [WCPtrHashSetIter&lt;Type&gt;,WCPtrHashTableIter&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrSListIterXTypeY__currentLR__WCPtrDListIterXTypeY__currentLR">current() [WCPtrSListIter&lt;Type&gt;,WCPtrDListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCValConstSListIterXTypeY__currentLR__WCValConstDListIterXTypeY__currentLR">current() [WCValConstSListIter&lt;Type&gt;,WCValConstDListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCValHashSetIterXTypeY__currentLR__WCValHashTableIterXTypeY__currentLR">current() [WCValHashSetIter&lt;Type&gt;,WCValHashTableIter&lt;Type&gt;]</A>
<BR><A HREF="#WCValSListIterXTypeY__currentLR__WCValDListIterXTypeY__currentLR">current() [WCValSListIter&lt;Type&gt;,WCValDListIter&lt;Type&gt;]</A>
<DT>- D -
<DD><A HREF="#streambuf__dbpLR">dbp() [streambuf]</A>
<BR><A HREF="#streambuf__do_sgetnLR">do_sgetn() [streambuf]</A>
<BR><A HREF="#streambuf__do_sputnLR">do_sputn() [streambuf]</A>
<BR><A HREF="#streambuf__doallocateLR">doallocate() [streambuf]</A>
<BR><A HREF="#strstreambuf__doallocateLR">doallocate() [strstreambuf]</A>
<DT>- E -
<DD><A HREF="#istream__eatwhiteLR">eatwhite() [istream]</A>
<BR><A HREF="#streambuf__ebackLR">eback() [streambuf]</A>
<BR><A HREF="#streambuf__ebufLR">ebuf() [streambuf]</A>
<BR><A HREF="#streambuf__egptrLR">egptr() [streambuf]</A>
<BR><A HREF="#WCIsvSListXTypeY__entriesLR__WCIsvDListXTypeY__entriesLR">entries() [WCIsvSList&lt;Type&gt;,WCIsvDList&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrHashDictXKey_ValueY__entriesLR">entries() [WCPtrHashDict&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCPtrHashTableXTypeY__entriesLR__WCPtrHashSetXTypeY__entriesLR">entries() [WCPtrHashTable&lt;Type&gt;,WCPtrHashSet&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrSkipListXTypeY__entriesLR__WCPtrSkipListSetXTypeY__entriesLR">entries() [WCPtrSkipList&lt;Type&gt;,WCPtrSkipListSet&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrSkipListDictXKey_ValueY__entriesLR">entries() [WCPtrSkipListDict&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCPtrSListXTypeY__entriesLR__WCPtrDListXTypeY__entriesLR">entries() [WCPtrSList&lt;Type&gt;,WCPtrDList&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrSortedVectorXTypeY__entriesLR__WCPtrOrderedVectorXTypeY__entriesLR">entries() [WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;]</A>
<BR><A HREF="#WCQueueXType_FTypeY__entriesLR">entries() [WCQueue&lt;Type,FType&gt;]</A>
<BR><A HREF="#WCStackXType_FTypeY__entriesLR">entries() [WCStack&lt;Type,FType&gt;]</A>
<BR><A HREF="#WCValHashDictXKey_ValueY__entriesLR">entries() [WCValHashDict&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCValHashTableXTypeY__entriesLR__WCValHashSetXTypeY__entriesLR">entries() [WCValHashTable&lt;Type&gt;,WCValHashSet&lt;Type&gt;]</A>
<BR><A HREF="#WCValSkipListXTypeY__entriesLR__WCValSkipListSetXTypeY__entriesLR">entries() [WCValSkipList&lt;Type&gt;,WCValSkipListSet&lt;Type&gt;]</A>
<BR><A HREF="#WCValSkipListDictXKey_ValueY__entriesLR">entries() [WCValSkipListDict&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCValSListXTypeY__entriesLR__WCValDListXTypeY__entriesLR">entries() [WCValSList&lt;Type&gt;,WCValDList&lt;Type&gt;]</A>
<BR><A HREF="#WCValSortedVectorXTypeY__entriesLR__WCValOrderedVectorXTypeY__entriesLR">entries() [WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;]</A>
<BR><A HREF="#ios__eofLR">eof() [ios]</A>
<BR><A HREF="#streambuf__epptrLR">epptr() [streambuf]</A>
<BR><A HREF="#ios__exceptionsLR">exceptions() [ios]</A>
<BR><A HREF="#WCExcept__exceptionsLR">exceptions() [WCExcept]</A>
<BR><A HREF="#WCIterExcept__exceptionsLR">exceptions() [WCIterExcept]</A>
<DT>- F -
<DD><A HREF="#ios__failLR">fail() [ios]</A>
<BR><A HREF="#filebuf__fdLR">fd() [filebuf]</A>
<BR><A HREF="#fstreambase__fdLR">fd() [fstreambase]</A>
<BR><A HREF="#filebuf_Class_Description">filebuf Class Description</A>
<BR><A HREF="#filebuf__filebufLR">filebuf() [filebuf]</A>
<BR><A HREF="#ios__fillLR">fill() [ios]</A>
<BR><A HREF="#WCIsvSListXTypeY__findLR__WCIsvDListXTypeY__findLR">find() [WCIsvSList&lt;Type&gt;,WCIsvDList&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrHashDictXKey_ValueY__findLR">find() [WCPtrHashDict&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCPtrHashTableXTypeY__findLR__WCPtrHashSetXTypeY__findLR">find() [WCPtrHashTable&lt;Type&gt;,WCPtrHashSet&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrSkipListXTypeY__findLR__WCPtrSkipListSetXTypeY__findLR">find() [WCPtrSkipList&lt;Type&gt;,WCPtrSkipListSet&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrSkipListDictXKey_ValueY__findLR">find() [WCPtrSkipListDict&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCPtrSListXTypeY__findLR__WCPtrDListXTypeY__findLR">find() [WCPtrSList&lt;Type&gt;,WCPtrDList&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrSortedVectorXTypeY__findLR__WCPtrOrderedVectorXTypeY__findLR">find() [WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;]</A>
<BR><A HREF="#WCValHashDictXKey_ValueY__findLR">find() [WCValHashDict&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCValHashTableXTypeY__findLR__WCValHashSetXTypeY__findLR">find() [WCValHashTable&lt;Type&gt;,WCValHashSet&lt;Type&gt;]</A>
<BR><A HREF="#WCValSkipListXTypeY__findLR__WCValSkipListSetXTypeY__findLR">find() [WCValSkipList&lt;Type&gt;,WCValSkipListSet&lt;Type&gt;]</A>
<BR><A HREF="#WCValSkipListDictXKey_ValueY__findLR">find() [WCValSkipListDict&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCValSListXTypeY__findLR__WCValDListXTypeY__findLR">find() [WCValSList&lt;Type&gt;,WCValDList&lt;Type&gt;]</A>
<BR><A HREF="#WCValSortedVectorXTypeY__findLR__WCValOrderedVectorXTypeY__findLR">find() [WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrHashDictXKey_ValueY__findKeyAndValueLR">findKeyAndValue() [WCPtrHashDict&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCPtrSkipListDictXKey_ValueY__findKeyAndValueLR">findKeyAndValue() [WCPtrSkipListDict&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCValHashDictXKey_ValueY__findKeyAndValueLR">findKeyAndValue() [WCValHashDict&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCValSkipListDictXKey_ValueY__findKeyAndValueLR">findKeyAndValue() [WCValSkipListDict&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCIsvSListXTypeY__findLastLR__WCIsvDListXTypeY__findLastLR">findLast() [WCIsvSList&lt;Type&gt;,WCIsvDList&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrSListXTypeY__findLastLR__WCPtrDListXTypeY__findLastLR">findLast() [WCPtrSList&lt;Type&gt;,WCPtrDList&lt;Type&gt;]</A>
<BR><A HREF="#WCValSListXTypeY__findLastLR__WCValDListXTypeY__findLastLR">findLast() [WCValSList&lt;Type&gt;,WCValDList&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrSortedVectorXTypeY__firstLR__WCPtrOrderedVectorXTypeY__firstLR">first() [WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;]</A>
<BR><A HREF="#WCQueueXType_FTypeY__firstLR">first() [WCQueue&lt;Type,FType&gt;]</A>
<BR><A HREF="#WCValSortedVectorXTypeY__firstLR__WCValOrderedVectorXTypeY__firstLR">first() [WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;]</A>
<BR><A HREF="#ios__flagsLR">flags() [ios]</A>
<BR><A HREF="#ostream__flushLR">flush() [ostream]</A>
<BR><A HREF="#ios__fmtflags">fmtflags [ios]</A>
<BR><A HREF="#WCIsvSListXTypeY__forAllLR__WCIsvDListXTypeY__forAllLR">forAll() [WCIsvSList&lt;Type&gt;,WCIsvDList&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrHashDictXKey_ValueY__forAllLR">forAll() [WCPtrHashDict&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCPtrHashTableXTypeY__forAllLR__WCPtrHashSetXTypeY__forAllLR">forAll() [WCPtrHashTable&lt;Type&gt;,WCPtrHashSet&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrSkipListXTypeY__forAllLR__WCPtrSkipListSetXTypeY__forAllLR">forAll() [WCPtrSkipList&lt;Type&gt;,WCPtrSkipListSet&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrSkipListDictXKey_ValueY__forAllLR">forAll() [WCPtrSkipListDict&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCPtrSListXTypeY__forAllLR__WCPtrDListXTypeY__forAllLR">forAll() [WCPtrSList&lt;Type&gt;,WCPtrDList&lt;Type&gt;]</A>
<BR><A HREF="#WCValHashDictXKey_ValueY__forAllLR">forAll() [WCValHashDict&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCValHashTableXTypeY__forAllLR__WCValHashSetXTypeY__forAllLR">forAll() [WCValHashTable&lt;Type&gt;,WCValHashSet&lt;Type&gt;]</A>
<BR><A HREF="#WCValSkipListXTypeY__forAllLR__WCValSkipListSetXTypeY__forAllLR">forAll() [WCValSkipList&lt;Type&gt;,WCValSkipListSet&lt;Type&gt;]</A>
<BR><A HREF="#WCValSkipListDictXKey_ValueY__forAllLR">forAll() [WCValSkipListDict&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCValSListXTypeY__forAllLR__WCValDListXTypeY__forAllLR">forAll() [WCValSList&lt;Type&gt;,WCValDList&lt;Type&gt;]</A>
<BR><A HREF="#Formatted_Input__Extractors">Formatted Input:&nbsp; Extractors</A>
<BR><A HREF="#Formatted_Output__Inserters">Formatted Output:&nbsp; Inserters</A>
<BR><A HREF="#strstreambuf__freezeLR">freeze() [strstreambuf]</A>
<BR><A HREF="#fstream_Class_Description">fstream Class Description</A>
<BR><A HREF="#fstream__fstreamLR">fstream() [fstream]</A>
<BR><A HREF="#fstreambase_Class_Description">fstreambase Class Description</A>
<BR><A HREF="#fstreambase__fstreambaseLR">fstreambase() [fstreambase]</A>
<DT>- G -
<DD><A HREF="#streambuf__gbumpLR">gbump() [streambuf]</A>
<BR><A HREF="#istream__gcountLR">gcount() [istream]</A>
<BR><A HREF="#istream__getLR">get() [istream]</A>
<BR><A HREF="#WCIsvSListXTypeY__getLR__WCIsvDListXTypeY__getLR">get() [WCIsvSList&lt;Type&gt;,WCIsvDList&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrSListXTypeY__getLR__WCPtrDListXTypeY__getLR">get() [WCPtrSList&lt;Type&gt;,WCPtrDList&lt;Type&gt;]</A>
<BR><A HREF="#WCQueueXType_FTypeY__getLR">get() [WCQueue&lt;Type,FType&gt;]</A>
<BR><A HREF="#WCValSListXTypeY__getLR__WCValDListXTypeY__getLR">get() [WCValSList&lt;Type&gt;,WCValDList&lt;Type&gt;]</A>
<BR><A HREF="#String__get_atLR">get_at() [String]</A>
<BR><A HREF="#istream__getlineLR">getline() [istream]</A>
<BR><A HREF="#ios__goodLR">good() [ios]</A>
<BR><A HREF="#streambuf__gptrLR">gptr() [streambuf]</A>
<DT>- H -
<DD><A HREF="#Hash_Containers">Hash Containers</A>
<BR><A HREF="#Hash_Iterators">Hash Iterators</A>
<BR><A HREF="#Header_Files">Header Files</A>
<DT>- I -
<DD><A HREF="#ifstream_Class_Description">ifstream Class Description</A>
<BR><A HREF="#ifstream__ifstreamLR">ifstream() [ifstream]</A>
<BR><A HREF="#istream__ignoreLR">ignore() [istream]</A>
<BR><A HREF="#Complex__imagLR">imag() [Complex]</A>
<BR><A HREF="#streambuf__in_availLR">in_avail() [streambuf]</A>
<BR><A HREF="#String__indexLR">index() [String]</A>
<BR><A HREF="#WCIsvSListXTypeY__indexLR__WCIsvDListXTypeY__indexLR">index() [WCIsvSList&lt;Type&gt;,WCIsvDList&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrSListXTypeY__indexLR__WCPtrDListXTypeY__indexLR">index() [WCPtrSList&lt;Type&gt;,WCPtrDList&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrSortedVectorXTypeY__indexLR__WCPtrOrderedVectorXTypeY__indexLR">index() [WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;]</A>
<BR><A HREF="#WCValSListXTypeY__indexLR__WCValDListXTypeY__indexLR">index() [WCValSList&lt;Type&gt;,WCValDList&lt;Type&gt;]</A>
<BR><A HREF="#WCValSortedVectorXTypeY__indexLR__WCValOrderedVectorXTypeY__indexLR">index() [WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;]</A>
<BR><A HREF="#ios__initLR">init() [ios]</A>
<BR><A HREF="#InputDOutput_Classes">Input/Output Classes</A>
<BR><A HREF="#WCIsvDListIterXTypeY__insertLR">insert() [WCIsvDListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCIsvSListXTypeY__insertLR__WCIsvDListXTypeY__insertLR">insert() [WCIsvSList&lt;Type&gt;,WCIsvDList&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrDListIterXTypeY__insertLR">insert() [WCPtrDListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrHashDictXKey_ValueY__insertLR">insert() [WCPtrHashDict&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCPtrHashTableXTypeY__insertLR__WCPtrHashSetXTypeY__insertLR">insert() [WCPtrHashTable&lt;Type&gt;,WCPtrHashSet&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrSkipListXTypeY__insertLR__WCPtrSkipListSetXTypeY__insertLR">insert() [WCPtrSkipList&lt;Type&gt;,WCPtrSkipListSet&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrSkipListDictXKey_ValueY__insertLR">insert() [WCPtrSkipListDict&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCPtrSListXTypeY__insertLR__WCPtrDListXTypeY__insertLR">insert() [WCPtrSList&lt;Type&gt;,WCPtrDList&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrSortedVectorXTypeY__insertLR__WCPtrOrderedVectorXTypeY__insertLR">insert() [WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;]</A>
<BR><A HREF="#WCQueueXType_FTypeY__insertLR">insert() [WCQueue&lt;Type,FType&gt;]</A>
<BR><A HREF="#WCValDListIterXTypeY__insertLR">insert() [WCValDListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCValHashDictXKey_ValueY__insertLR">insert() [WCValHashDict&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCValHashTableXTypeY__insertLR__WCValHashSetXTypeY__insertLR">insert() [WCValHashTable&lt;Type&gt;,WCValHashSet&lt;Type&gt;]</A>
<BR><A HREF="#WCValSkipListXTypeY__insertLR__WCValSkipListSetXTypeY__insertLR">insert() [WCValSkipList&lt;Type&gt;,WCValSkipListSet&lt;Type&gt;]</A>
<BR><A HREF="#WCValSkipListDictXKey_ValueY__insertLR">insert() [WCValSkipListDict&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCValSListXTypeY__insertLR__WCValDListXTypeY__insertLR">insert() [WCValSList&lt;Type&gt;,WCValDList&lt;Type&gt;]</A>
<BR><A HREF="#WCValSortedVectorXTypeY__insertLR__WCValOrderedVectorXTypeY__insertLR">insert() [WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrOrderedVectorXTypeY__insertAtLR">insertAt() [WCPtrOrderedVector&lt;Type&gt;]</A>
<BR><A HREF="#WCValOrderedVectorXTypeY__insertAtLR">insertAt() [WCValOrderedVector&lt;Type&gt;]</A>
<BR><A HREF="#ios_Class_Description">ios Class Description</A>
<BR><A HREF="#ios__iosLR">ios() [ios]</A>
<BR><A HREF="#ios__iostate">iostate [ios]</A>
<BR><A HREF="#iostream_Class_Description">iostream Class Description</A>
<BR><A HREF="#iostream__iostreamLR">iostream() [iostream]</A>
<BR><A HREF="#istream__ipfxLR">ipfx() [istream]</A>
<BR><A HREF="#filebuf__is_openLR">is_open() [filebuf]</A>
<BR><A HREF="#fstreambase__is_openLR">is_open() [fstreambase]</A>
<BR><A HREF="#WCIsvSListXTypeY__isEmptyLR__WCIsvDListXTypeY__isEmptyLR">isEmpty() [WCIsvSList&lt;Type&gt;,WCIsvDList&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrHashDictXKey_ValueY__isEmptyLR">isEmpty() [WCPtrHashDict&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCPtrHashTableXTypeY__isEmptyLR__WCPtrHashSetXTypeY__isEmptyLR">isEmpty() [WCPtrHashTable&lt;Type&gt;,WCPtrHashSet&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrSkipListXTypeY__isEmptyLR__WCPtrSkipListSetXTypeY__isEmptyLR">isEmpty() [WCPtrSkipList&lt;Type&gt;,WCPtrSkipListSet&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrSkipListDictXKey_ValueY__isEmptyLR">isEmpty() [WCPtrSkipListDict&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCPtrSListXTypeY__isEmptyLR__WCPtrDListXTypeY__isEmptyLR">isEmpty() [WCPtrSList&lt;Type&gt;,WCPtrDList&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrSortedVectorXTypeY_WCPtrOrderedVectorXTypeY__isEmptyLR">isEmpty() [WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;]</A>
<BR><A HREF="#WCQueueXType_FTypeY__isEmptyLR">isEmpty() [WCQueue&lt;Type,FType&gt;]</A>
<BR><A HREF="#WCStackXType_FTypeY__isEmptyLR">isEmpty() [WCStack&lt;Type,FType&gt;]</A>
<BR><A HREF="#WCValHashDictXKey_ValueY__isEmptyLR">isEmpty() [WCValHashDict&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCValHashTableXTypeY__isEmptyLR__WCValHashSetXTypeY__isEmptyLR">isEmpty() [WCValHashTable&lt;Type&gt;,WCValHashSet&lt;Type&gt;]</A>
<BR><A HREF="#WCValSkipListXTypeY__isEmptyLR__WCValSkipListSetXTypeY__isEmptyLR">isEmpty() [WCValSkipList&lt;Type&gt;,WCValSkipListSet&lt;Type&gt;]</A>
<BR><A HREF="#WCValSkipListDictXKey_ValueY__isEmptyLR">isEmpty() [WCValSkipListDict&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCValSListXTypeY__isEmptyLR__WCValDListXTypeY__isEmptyLR">isEmpty() [WCValSList&lt;Type&gt;,WCValDList&lt;Type&gt;]</A>
<BR><A HREF="#WCValSortedVectorXTypeY_WCValOrderedVectorXTypeY__isEmptyLR">isEmpty() [WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;]</A>
<BR><A HREF="#istream__isfxLR">isfx() [istream]</A>
<BR><A HREF="#istream_Class_Description">istream Class Description</A>
<BR><A HREF="#istream_Input">istream Input</A>
<BR><A HREF="#istream__istreamLR">istream() [istream]</A>
<BR><A HREF="#istrstream_Class_Description">istrstream Class Description</A>
<BR><A HREF="#istrstream__istrstreamLR">istrstream() [istrstream]</A>
<BR><A HREF="#ios__iwordLR">iword() [ios]</A>
<DT>- K -
<DD><A HREF="#WCPtrHashDictIterXKey_ValueY__keyLR">key() [WCPtrHashDictIter&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCValHashDictIterXKey_ValueY__keyLR">key() [WCValHashDictIter&lt;Key,Value&gt;]</A>
<DT>- L -
<DD><A HREF="#WCPtrSortedVectorXTypeY__lastLR__WCPtrOrderedVectorXTypeY__lastLR">last() [WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;]</A>
<BR><A HREF="#WCQueueXType_FTypeY__lastLR">last() [WCQueue&lt;Type,FType&gt;]</A>
<BR><A HREF="#WCValSortedVectorXTypeY__lastLR__WCValOrderedVectorXTypeY__lastLR">last() [WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;]</A>
<BR><A HREF="#String__lengthLR">length() [String]</A>
<BR><A HREF="#WCPtrVectorXTypeY__lengthLR">length() [WCPtrVector&lt;Type&gt;]</A>
<BR><A HREF="#WCValVectorXTypeY__lengthLR">length() [WCValVector&lt;Type&gt;]</A>
<BR><A HREF="#Library_Functions_and_Types">Library Functions and Types</A>
<BR><A HREF="#List_Containers">List Containers</A>
<BR><A HREF="#List_Iterators">List Iterators</A>
<BR><A HREF="#String__lowerLR">lower() [String]</A>
<DT>- M -
<DD><A HREF="#manipulator_decLR">manipulator dec() [manipulator]</A>
<BR><A HREF="#manipulator_endlLR">manipulator endl() [manipulator]</A>
<BR><A HREF="#manipulator_endsLR">manipulator ends() [manipulator]</A>
<BR><A HREF="#manipulator_flushLR">manipulator flush() [manipulator]</A>
<BR><A HREF="#manipulator_hexLR">manipulator hex() [manipulator]</A>
<BR><A HREF="#manipulator_octLR">manipulator oct() [manipulator]</A>
<BR><A HREF="#manipulator_resetiosflagsLR">manipulator resetiosflags() [manipulator]</A>
<BR><A HREF="#manipulator_setbaseLR">manipulator setbase() [manipulator]</A>
<BR><A HREF="#manipulator_setfillLR">manipulator setfill() [manipulator]</A>
<BR><A HREF="#manipulator_setiosflagsLR">manipulator setiosflags() [manipulator]</A>
<BR><A HREF="#manipulator_setprecisionLR">manipulator setprecision() [manipulator]</A>
<BR><A HREF="#manipulator_setwLR">manipulator setw() [manipulator]</A>
<BR><A HREF="#manipulator_setwidthLR">manipulator setwidth() [manipulator]</A>
<BR><A HREF="#manipulator_wsLR">manipulator ws() [manipulator]</A>
<BR><A HREF="#Manipulators">Manipulators [manipulator]</A>
<BR><A HREF="#String__matchLR">match() [String]</A>
<DT>- O -
<DD><A HREF="#WCPtrHashTableXTypeY__occurencesOfLR">occurencesOf() [WCPtrHashTable&lt;Type&gt;]</A>
<BR><A HREF="#WCValHashTableXTypeY__occurencesOfLR">occurencesOf() [WCValHashTable&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrSkipListXTypeY__occurrencesOfLR">occurrencesOf() [WCPtrSkipList&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrSortedVectorXTypeY_WCPtrOrderedVectorXTypeY__occurrencesOfLR">occurrencesOf() [WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;]</A>
<BR><A HREF="#WCValSkipListXTypeY__occurrencesOfLR">occurrencesOf() [WCValSkipList&lt;Type&gt;]</A>
<BR><A HREF="#WCValSortedVectorXTypeY_WCValOrderedVectorXTypeY__occurrencesOfLR">occurrencesOf() [WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;]</A>
<BR><A HREF="#ofstream_Class_Description">ofstream Class Description</A>
<BR><A HREF="#ofstream__ofstreamLR">ofstream() [ofstream]</A>
<BR><A HREF="#filebuf__openLR">open() [filebuf]</A>
<BR><A HREF="#fstream__openLR">open() [fstream]</A>
<BR><A HREF="#fstreambase__openLR">open() [fstreambase]</A>
<BR><A HREF="#ifstream__openLR">open() [ifstream]</A>
<BR><A HREF="#ofstream__openLR">open() [ofstream]</A>
<BR><A HREF="#ios__openmode">openmode [ios]</A>
<BR><A HREF="#filebuf__openprot">openprot [filebuf]</A>
<BR><A HREF="#ios__operator__LR">operator !() [ios]</A>
<BR><A HREF="#String__operator__LR">operator !() [String]</A>
<BR><A HREF="#String__operator_LRLR">operator ()() [String]</A>
<BR><A HREF="#WCIsvConstSListIterXTypeY_WCIsvConstDListIterXTypeY__operator_LRLR">operator ()() [WCIsvConstSListIter&lt;Type&gt;,WCIsvConstDListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCIsvSListIterXTypeY_WCIsvDListIterXTypeY__operator_LRLR">operator ()() [WCIsvSListIter&lt;Type&gt;,WCIsvDListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrConstSListIterXTypeY_WCPtrConstDListIterXTypeY__operator_LRLR">operator ()() [WCPtrConstSListIter&lt;Type&gt;,WCPtrConstDListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrHashDictIterXKey_ValueY__operator_LRLR">operator ()() [WCPtrHashDictIter&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCPtrHashSetIterXTypeY_WCPtrHashTableIterXTypeY__operator_LRLR">operator ()() [WCPtrHashSetIter&lt;Type&gt;,WCPtrHashTableIter&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrSListIterXTypeY_WCPtrDListIterXTypeY__operator_LRLR">operator ()() [WCPtrSListIter&lt;Type&gt;,WCPtrDListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCValConstSListIterXTypeY_WCValConstDListIterXTypeY__operator_LRLR">operator ()() [WCValConstSListIter&lt;Type&gt;,WCValConstDListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCValHashDictIterXKey_ValueY__operator_LRLR">operator ()() [WCValHashDictIter&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCValHashSetIterXTypeY_WCValHashTableIterXTypeY__operator_LRLR">operator ()() [WCValHashSetIter&lt;Type&gt;,WCValHashTableIter&lt;Type&gt;]</A>
<BR><A HREF="#WCValSListIterXTypeY_WCValDListIterXTypeY__operator_LRLR">operator ()() [WCValSListIter&lt;Type&gt;,WCValDListIter&lt;Type&gt;]</A>
<BR><A HREF="#Complex__operator_TELR">operator *=() [Complex]</A>
<BR><A HREF="#Complex__operator_PLR">operator +() [Complex]</A>
<BR><A HREF="#WCIsvConstSListIterXTypeY_WCIsvConstDListIterXTypeY__operator_PPLR">operator ++() [WCIsvConstSListIter&lt;Type&gt;,WCIsvConstDListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCIsvSListIterXTypeY_WCIsvDListIterXTypeY__operator_PPLR">operator ++() [WCIsvSListIter&lt;Type&gt;,WCIsvDListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrConstSListIterXTypeY_WCPtrConstDListIterXTypeY__operator_PPLR">operator ++() [WCPtrConstSListIter&lt;Type&gt;,WCPtrConstDListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrHashDictIterXKey_ValueY__operator_PPLR">operator ++() [WCPtrHashDictIter&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCPtrHashSetIterXTypeY_WCPtrHashTableIterXTypeY__operator_PPLR">operator ++() [WCPtrHashSetIter&lt;Type&gt;,WCPtrHashTableIter&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrSListIterXTypeY_WCPtrDListIterXTypeY__operator_PPLR">operator ++() [WCPtrSListIter&lt;Type&gt;,WCPtrDListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCValConstSListIterXTypeY_WCValConstDListIterXTypeY__operator_PPLR">operator ++() [WCValConstSListIter&lt;Type&gt;,WCValConstDListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCValHashDictIterXKey_ValueY__operator_PPLR">operator ++() [WCValHashDictIter&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCValHashSetIterXTypeY_WCValHashTableIterXTypeY__operator_PPLR">operator ++() [WCValHashSetIter&lt;Type&gt;,WCValHashTableIter&lt;Type&gt;]</A>
<BR><A HREF="#WCValSListIterXTypeY_WCValDListIterXTypeY__operator_PPLR">operator ++() [WCValSListIter&lt;Type&gt;,WCValDListIter&lt;Type&gt;]</A>
<BR><A HREF="#Complex__operator_PELR">operator +=() [Complex]</A>
<BR><A HREF="#String__operator_PELR">operator +=() [String]</A>
<BR><A HREF="#WCIsvConstSListIterXTypeY_WCIsvConstDListIterXTypeY__operator_PELR">operator +=() [WCIsvConstSListIter&lt;Type&gt;,WCIsvConstDListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCIsvSListIterXTypeY_WCIsvDListIterXTypeY__operator_PELR">operator +=() [WCIsvSListIter&lt;Type&gt;,WCIsvDListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrConstSListIterXTypeY_WCPtrConstDListIterXTypeY__operator_PELR">operator +=() [WCPtrConstSListIter&lt;Type&gt;,WCPtrConstDListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrSListIterXTypeY_WCPtrDListIterXTypeY__operator_PELR">operator +=() [WCPtrSListIter&lt;Type&gt;,WCPtrDListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCValConstSListIterXTypeY_WCValConstDListIterXTypeY__operator_PELR">operator +=() [WCValConstSListIter&lt;Type&gt;,WCValConstDListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCValSListIterXTypeY_WCValDListIterXTypeY__operator_PELR">operator +=() [WCValSListIter&lt;Type&gt;,WCValDListIter&lt;Type&gt;]</A>
<BR><A HREF="#Complex__operator_MLR">operator -() [Complex]</A>
<BR><A HREF="#WCIsvConstDListIterXTypeY__operator_MMLR">operator --() [WCIsvConstDListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCIsvDListIterXTypeY__operator_MMLR">operator --() [WCIsvDListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrConstDListIterXTypeY__operator_MMLR">operator --() [WCPtrConstDListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrDListIterXTypeY__operator_MMLR">operator --() [WCPtrDListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCValConstDListIterXTypeY__operator_MMLR">operator --() [WCValConstDListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCValDListIterXTypeY__operator_MMLR">operator --() [WCValDListIter&lt;Type&gt;]</A>
<BR><A HREF="#Complex__operator_MELR">operator -=() [Complex]</A>
<BR><A HREF="#WCIsvConstDListIterXTypeY__operator_MELR">operator -=() [WCIsvConstDListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCIsvDListIterXTypeY__operator_MELR">operator -=() [WCIsvDListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrConstDListIterXTypeY__operator_MELR">operator -=() [WCPtrConstDListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrDListIterXTypeY__operator_MELR">operator -=() [WCPtrDListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCValConstDListIterXTypeY__operator_MELR">operator -=() [WCValConstDListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCValDListIterXTypeY__operator_MELR">operator -=() [WCValDListIter&lt;Type&gt;]</A>
<BR><A HREF="#Complex__operator_DELR">operator /=() [Complex]</A>
<BR><A HREF="#ostream__operator_XXLR">operator &lt;&lt;() [ostream]</A>
<BR><A HREF="#Complex__operator_ELR">operator =() [Complex]</A>
<BR><A HREF="#iostream__operator_ELR">operator =() [iostream]</A>
<BR><A HREF="#istream__operator_ELR">operator =() [istream]</A>
<BR><A HREF="#ostream__operator_ELR">operator =() [ostream]</A>
<BR><A HREF="#String__operator_ELR">operator =() [String]</A>
<BR><A HREF="#WCIsvSListXTypeY__operator_ELR__WCIsvDListXTypeY__operator_ELR">operator =() [WCIsvSList&lt;Type&gt;,WCIsvDList&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrHashDictXKey_ValueY__operator_ELR">operator =() [WCPtrHashDict&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCPtrHashTableXTypeY__operator_ELR__WCPtrHashSetXTypeY__operator_ELR">operator =() [WCPtrHashTable&lt;Type&gt;,WCPtrHashSet&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrSkipListXTypeY__operator_ELR__WCPtrSkipListSetXTypeY__operator_ELR">operator =() [WCPtrSkipList&lt;Type&gt;,WCPtrSkipListSet&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrSkipListDictXKey_ValueY__operator_ELR">operator =() [WCPtrSkipListDict&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCPtrSListXTypeY__operator_ELR__WCPtrDListXTypeY__operator_ELR">operator =() [WCPtrSList&lt;Type&gt;,WCPtrDList&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrSortedVectorXTypeY_WCPtrOrderedVectorXTypeY__operator_ELR">operator =() [WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrVectorXTypeY__operator_ELR">operator =() [WCPtrVector&lt;Type&gt;]</A>
<BR><A HREF="#WCValHashDictXKey_ValueY__operator_ELR">operator =() [WCValHashDict&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCValHashTableXTypeY__operator_ELR__WCValHashSetXTypeY__operator_ELR">operator =() [WCValHashTable&lt;Type&gt;,WCValHashSet&lt;Type&gt;]</A>
<BR><A HREF="#WCValSkipListXTypeY__operator_ELR__WCValSkipListSetXTypeY__operator_ELR">operator =() [WCValSkipList&lt;Type&gt;,WCValSkipListSet&lt;Type&gt;]</A>
<BR><A HREF="#WCValSkipListDictXKey_ValueY__operator_ELR">operator =() [WCValSkipListDict&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCValSListXTypeY__operator_ELR__WCValDListXTypeY__operator_ELR">operator =() [WCValSList&lt;Type&gt;,WCValDList&lt;Type&gt;]</A>
<BR><A HREF="#WCValSortedVectorXTypeY_WCValOrderedVectorXTypeY__operator_ELR">operator =() [WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;]</A>
<BR><A HREF="#WCValVectorXTypeY__operator_ELR">operator =() [WCValVector&lt;Type&gt;]</A>
<BR><A HREF="#WCIsvSListXTypeY__operator_EELR__WCIsvDListXTypeY__operator_EELR">operator ==() [WCIsvSList&lt;Type&gt;,WCIsvDList&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrHashDictXKey_ValueY__operator_EELR">operator ==() [WCPtrHashDict&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCPtrHashTableXTypeY__operator_EELR__WCPtrHashSetXTypeY__operator_EELR">operator ==() [WCPtrHashTable&lt;Type&gt;,WCPtrHashSet&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrSkipListXTypeY__operator_EELR__WCPtrSkipListSetXTypeY__operator_EELR">operator ==() [WCPtrSkipList&lt;Type&gt;,WCPtrSkipListSet&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrSkipListDictXKey_ValueY__operator_EELR">operator ==() [WCPtrSkipListDict&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCPtrSListXTypeY__operator_EELR__WCPtrDListXTypeY__operator_EELR">operator ==() [WCPtrSList&lt;Type&gt;,WCPtrDList&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrSortedVectorXTypeY_WCPtrOrderedVectorXTypeY__operator_EELR">operator ==() [WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrVectorXTypeY__operator_EELR">operator ==() [WCPtrVector&lt;Type&gt;]</A>
<BR><A HREF="#WCValHashDictXKey_ValueY__operator_EELR">operator ==() [WCValHashDict&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCValHashTableXTypeY__operator_EELR__WCValHashSetXTypeY__operator_EELR">operator ==() [WCValHashTable&lt;Type&gt;,WCValHashSet&lt;Type&gt;]</A>
<BR><A HREF="#WCValSkipListXTypeY__operator_EELR__WCValSkipListSetXTypeY__operator_EELR">operator ==() [WCValSkipList&lt;Type&gt;,WCValSkipListSet&lt;Type&gt;]</A>
<BR><A HREF="#WCValSkipListDictXKey_ValueY__operator_EELR">operator ==() [WCValSkipListDict&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCValSListXTypeY__operator_EELR__WCValDListXTypeY__operator_EELR">operator ==() [WCValSList&lt;Type&gt;,WCValDList&lt;Type&gt;]</A>
<BR><A HREF="#WCValSortedVectorXTypeY_WCValOrderedVectorXTypeY__operator_EELR">operator ==() [WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;]</A>
<BR><A HREF="#WCValVectorXTypeY__operator_EELR">operator ==() [WCValVector&lt;Type&gt;]</A>
<BR><A HREF="#istream__operator_YYLR">operator &gt;&gt;() [istream]</A>
<BR><A HREF="#String__operator_UVLR">operator []() [String]</A>
<BR><A HREF="#WCPtrHashDictXKey_ValueY__operator_UVLR">operator []() [WCPtrHashDict&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCPtrSkipListDictXKey_ValueY__operator_UVLR">operator []() [WCPtrSkipListDict&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCPtrSortedVectorXTypeY_WCPtrOrderedVectorXTypeY__operator_UVLR">operator []() [WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrVectorXTypeY__operator_UVLR">operator []() [WCPtrVector&lt;Type&gt;]</A>
<BR><A HREF="#WCValHashDictXKey_ValueY__operator_UVLR">operator []() [WCValHashDict&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCValSkipListDictXKey_ValueY__operator_UVLR">operator []() [WCValSkipListDict&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCValSortedVectorXTypeY_WCValOrderedVectorXTypeY__operator_UVLR">operator []() [WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;]</A>
<BR><A HREF="#WCValVectorXTypeY__operator_UVLR">operator []() [WCValVector&lt;Type&gt;]</A>
<BR><A HREF="#String__operator_char_const_TLR">operator char const *() [String]</A>
<BR><A HREF="#String__operator_charLR">operator char() [String]</A>
<BR><A HREF="#ios__operator_void_TLR">operator void *() [ios]</A>
<BR><A HREF="#ostream__opfxLR">opfx() [ostream]</A>
<BR><A HREF="#ostream__osfxLR">osfx() [ostream]</A>
<BR><A HREF="#ostream_Class_Description">ostream Class Description</A>
<BR><A HREF="#ostream_Output">ostream Output</A>
<BR><A HREF="#ostream__ostreamLR">ostream() [ostream]</A>
<BR><A HREF="#ostrstream_Class_Description">ostrstream Class Description</A>
<BR><A HREF="#ostrstream__ostrstreamLR">ostrstream() [ostrstream]</A>
<BR><A HREF="#streambuf__out_waitingLR">out_waiting() [streambuf]</A>
<BR><A HREF="#filebuf__overflowLR">overflow() [filebuf]</A>
<BR><A HREF="#stdiobuf__overflowLR">overflow() [stdiobuf]</A>
<BR><A HREF="#streambuf__overflowLR">overflow() [streambuf]</A>
<BR><A HREF="#strstreambuf__overflowLR">overflow() [strstreambuf]</A>
<DT>- P -
<DD><A HREF="#filebuf__pbackfailLR">pbackfail() [filebuf]</A>
<BR><A HREF="#streambuf__pbackfailLR">pbackfail() [streambuf]</A>
<BR><A HREF="#streambuf__pbaseLR">pbase() [streambuf]</A>
<BR><A HREF="#streambuf__pbumpLR">pbump() [streambuf]</A>
<BR><A HREF="#ostrstream__pcountLR">pcount() [ostrstream]</A>
<BR><A HREF="#istream__peekLR">peek() [istream]</A>
<BR><A HREF="#WCStackXType_FTypeY__popLR">pop() [WCStack&lt;Type,FType&gt;]</A>
<BR><A HREF="#streambuf__pptrLR">pptr() [streambuf]</A>
<BR><A HREF="#ios__precisionLR">precision() [ios]</A>
<BR><A HREF="#Predefined_Objects">Predefined Objects</A>
<BR><A HREF="#WCPtrOrderedVectorXTypeY__prependLR">prepend() [WCPtrOrderedVector&lt;Type&gt;]</A>
<BR><A HREF="#WCValOrderedVectorXTypeY__prependLR">prepend() [WCValOrderedVector&lt;Type&gt;]</A>
<BR><A HREF="#WCStackXType_FTypeY__pushLR">push() [WCStack&lt;Type,FType&gt;]</A>
<BR><A HREF="#ostream__putLR">put() [ostream]</A>
<BR><A HREF="#String__put_atLR">put_at() [String]</A>
<BR><A HREF="#istream__putbackLR">putback() [istream]</A>
<BR><A HREF="#ios__pwordLR">pword() [ios]</A>
<DT>- Q -
<DD><A HREF="#Queue_Container">Queue Container</A>
<DT>- R -
<DD><A HREF="#fstreambase__rdbufLR">rdbuf() [fstreambase]</A>
<BR><A HREF="#ios__rdbufLR">rdbuf() [ios]</A>
<BR><A HREF="#strstreambase__rdbufLR">rdbuf() [strstreambase]</A>
<BR><A HREF="#ios__rdstateLR">rdstate() [ios]</A>
<BR><A HREF="#istream__readLR">read() [istream]</A>
<BR><A HREF="#Complex__realLR">real() [Complex]</A>
<BR><A HREF="#WCPtrHashDictXKey_ValueY__removeLR">remove() [WCPtrHashDict&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCPtrHashTableXTypeY__removeLR__WCPtrHashSetXTypeY__removeLR">remove() [WCPtrHashTable&lt;Type&gt;,WCPtrHashSet&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrSkipListXTypeY__removeLR__WCPtrSkipListSetXTypeY__removeLR">remove() [WCPtrSkipList&lt;Type&gt;,WCPtrSkipListSet&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrSkipListDictXKey_ValueY__removeLR">remove() [WCPtrSkipListDict&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCPtrSortedVectorXTypeY__removeLR__WCPtrOrderedVectorXTypeY__removeLR">remove() [WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;]</A>
<BR><A HREF="#WCValHashDictXKey_ValueY__removeLR">remove() [WCValHashDict&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCValHashTableXTypeY__removeLR__WCValHashSetXTypeY__removeLR">remove() [WCValHashTable&lt;Type&gt;,WCValHashSet&lt;Type&gt;]</A>
<BR><A HREF="#WCValSkipListXTypeY__removeLR__WCValSkipListSetXTypeY__removeLR">remove() [WCValSkipList&lt;Type&gt;,WCValSkipListSet&lt;Type&gt;]</A>
<BR><A HREF="#WCValSkipListDictXKey_ValueY__removeLR">remove() [WCValSkipListDict&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCValSortedVectorXTypeY__removeLR__WCValOrderedVectorXTypeY__removeLR">remove() [WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrHashTableXTypeY__removeAllLR">removeAll() [WCPtrHashTable&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrSkipListXTypeY__removeAllLR">removeAll() [WCPtrSkipList&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrSortedVectorXTypeY_WCPtrOrderedVectorXTypeY__removeAllLR">removeAll() [WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;]</A>
<BR><A HREF="#WCValHashTableXTypeY__removeAllLR">removeAll() [WCValHashTable&lt;Type&gt;]</A>
<BR><A HREF="#WCValSkipListXTypeY__removeAllLR">removeAll() [WCValSkipList&lt;Type&gt;]</A>
<BR><A HREF="#WCValSortedVectorXTypeY_WCValOrderedVectorXTypeY__removeAllLR">removeAll() [WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrSortedVectorXTypeY_WCPtrOrderedVectorXTypeY__removeAtLR">removeAt() [WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;]</A>
<BR><A HREF="#WCValSortedVectorXTypeY_WCValOrderedVectorXTypeY__removeAtLR">removeAt() [WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrSortedVectorXTypeY_WCPtrOrderedVectorXTypeY__removeFirstLR">removeFirst() [WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;]</A>
<BR><A HREF="#WCValSortedVectorXTypeY_WCValOrderedVectorXTypeY__removeFirstLR">removeFirst() [WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrSortedVectorXTypeY_WCPtrOrderedVectorXTypeY__removeLastLR">removeLast() [WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;]</A>
<BR><A HREF="#WCValSortedVectorXTypeY_WCValOrderedVectorXTypeY__removeLastLR">removeLast() [WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;]</A>
<BR><A HREF="#WCIsvConstSListIterXTypeY__resetLR__WCIsvConstDListIterXTypeY__resetLR">reset() [WCIsvConstSListIter&lt;Type&gt;,WCIsvConstDListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCIsvSListIterXTypeY__resetLR__WCIsvDListIterXTypeY__resetLR">reset() [WCIsvSListIter&lt;Type&gt;,WCIsvDListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrConstSListIterXTypeY__resetLR__WCPtrConstDListIterXTypeY__resetLR">reset() [WCPtrConstSListIter&lt;Type&gt;,WCPtrConstDListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrHashDictIterXKey_ValueY__resetLR">reset() [WCPtrHashDictIter&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCPtrHashSetIterXTypeY__resetLR__WCPtrHashTableIterXTypeY__resetLR">reset() [WCPtrHashSetIter&lt;Type&gt;,WCPtrHashTableIter&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrSListIterXTypeY__resetLR__WCPtrDListIterXTypeY__resetLR">reset() [WCPtrSListIter&lt;Type&gt;,WCPtrDListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCValConstSListIterXTypeY__resetLR__WCValConstDListIterXTypeY__resetLR">reset() [WCValConstSListIter&lt;Type&gt;,WCValConstDListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCValHashDictIterXKey_ValueY__resetLR">reset() [WCValHashDictIter&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCValHashSetIterXTypeY__resetLR__WCValHashTableIterXTypeY__resetLR">reset() [WCValHashSetIter&lt;Type&gt;,WCValHashTableIter&lt;Type&gt;]</A>
<BR><A HREF="#WCValSListIterXTypeY__resetLR__WCValDListIterXTypeY__resetLR">reset() [WCValSListIter&lt;Type&gt;,WCValDListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrHashDictXKey_ValueY__resizeLR">resize() [WCPtrHashDict&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCPtrHashTableXTypeY__resizeLR__WCPtrHashSetXTypeY__resizeLR">resize() [WCPtrHashTable&lt;Type&gt;,WCPtrHashSet&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrSortedVectorXTypeY__resizeLR__WCPtrOrderedVectorXTypeY__resizeLR">resize() [WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrVectorXTypeY__resizeLR">resize() [WCPtrVector&lt;Type&gt;]</A>
<BR><A HREF="#WCValHashDictXKey_ValueY__resizeLR">resize() [WCValHashDict&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCValHashTableXTypeY__resizeLR__WCValHashSetXTypeY__resizeLR">resize() [WCValHashTable&lt;Type&gt;,WCValHashSet&lt;Type&gt;]</A>
<BR><A HREF="#WCValSortedVectorXTypeY__resizeLR__WCValOrderedVectorXTypeY__resizeLR">resize() [WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;]</A>
<BR><A HREF="#WCValVectorXTypeY__resizeLR">resize() [WCValVector&lt;Type&gt;]</A>
<DT>- S -
<DD><A HREF="#streambuf__sbumpcLR">sbumpc() [streambuf]</A>
<BR><A HREF="#ios__seekdir">seekdir [ios]</A>
<BR><A HREF="#istream__seekgLR">seekg() [istream]</A>
<BR><A HREF="#filebuf__seekoffLR">seekoff() [filebuf]</A>
<BR><A HREF="#streambuf__seekoffLR">seekoff() [streambuf]</A>
<BR><A HREF="#strstreambuf__seekoffLR">seekoff() [strstreambuf]</A>
<BR><A HREF="#ostream__seekpLR">seekp() [ostream]</A>
<BR><A HREF="#streambuf__seekposLR">seekpos() [streambuf]</A>
<BR><A HREF="#streambuf__setbLR">setb() [streambuf]</A>
<BR><A HREF="#filebuf__setbufLR">setbuf() [filebuf]</A>
<BR><A HREF="#fstreambase__setbufLR">setbuf() [fstreambase]</A>
<BR><A HREF="#streambuf__setbufLR">setbuf() [streambuf]</A>
<BR><A HREF="#strstreambuf__setbufLR">setbuf() [strstreambuf]</A>
<BR><A HREF="#ios__setfLR">setf() [ios]</A>
<BR><A HREF="#streambuf__setgLR">setg() [streambuf]</A>
<BR><A HREF="#streambuf__setpLR">setp() [streambuf]</A>
<BR><A HREF="#ios__setstateLR">setstate() [ios]</A>
<BR><A HREF="#streambuf__sgetcLR">sgetc() [streambuf]</A>
<BR><A HREF="#streambuf__sgetcharLR">sgetchar() [streambuf]</A>
<BR><A HREF="#streambuf__sgetnLR">sgetn() [streambuf]</A>
<BR><A HREF="#Skip_List_Containers">Skip List Containers</A>
<BR><A HREF="#streambuf__snextcLR">snextc() [streambuf]</A>
<BR><A HREF="#streambuf__speekcLR">speekc() [streambuf]</A>
<BR><A HREF="#streambuf__sputbackcLR">sputbackc() [streambuf]</A>
<BR><A HREF="#streambuf__sputcLR">sputc() [streambuf]</A>
<BR><A HREF="#streambuf__sputnLR">sputn() [streambuf]</A>
<BR><A HREF="#Stack_Container">Stack Container</A>
<BR><A HREF="#stdiobuf_Class_Description">stdiobuf Class Description</A>
<BR><A HREF="#stdiobuf__stdiobufLR">stdiobuf() [stdiobuf]</A>
<BR><A HREF="#streambuf__stosscLR">stossc() [streambuf]</A>
<BR><A HREF="#ostrstream__strLR">str() [ostrstream]</A>
<BR><A HREF="#strstream__strLR">str() [strstream]</A>
<BR><A HREF="#strstreambuf__strLR">str() [strstreambuf]</A>
<BR><A HREF="#streambuf_Class_Description">streambuf Class Description</A>
<BR><A HREF="#streambuf__streambufLR">streambuf() [streambuf]</A>
<BR><A HREF="#String_Class">String Class</A>
<BR><A HREF="#String_Class_Description">String Class Description</A>
<BR><A HREF="#String_operator__ELR">String operator !=() [String]</A>
<BR><A HREF="#String_operator_PLR">String operator +() [String]</A>
<BR><A HREF="#String_operator_XLR">String operator &lt;() [String]</A>
<BR><A HREF="#String_operator_XXLR">String operator &lt;&lt;() [String]</A>
<BR><A HREF="#String_operator_XELR">String operator &lt;=() [String]</A>
<BR><A HREF="#String_operator_EELR">String operator ==() [String]</A>
<BR><A HREF="#String_operator_YLR">String operator &gt;() [String]</A>
<BR><A HREF="#String_operator_YELR">String operator &gt;=() [String]</A>
<BR><A HREF="#String_operator_YYLR">String operator &gt;&gt;() [String]</A>
<BR><A HREF="#String_validLR">String valid() [String]</A>
<BR><A HREF="#String__StringLR">String() [String]</A>
<BR><A HREF="#strstream_Class_Description">strstream Class Description</A>
<BR><A HREF="#strstream__strstreamLR">strstream() [strstream]</A>
<BR><A HREF="#strstreambase_Class_Description">strstreambase Class Description</A>
<BR><A HREF="#strstreambase__strstreambaseLR">strstreambase() [strstreambase]</A>
<BR><A HREF="#strstreambuf_Class_Description">strstreambuf Class Description</A>
<BR><A HREF="#strstreambuf__strstreambufLR">strstreambuf() [strstreambuf]</A>
<BR><A HREF="#filebuf__syncLR">sync() [filebuf]</A>
<BR><A HREF="#istream__syncLR">sync() [istream]</A>
<BR><A HREF="#stdiobuf__syncLR">sync() [stdiobuf]</A>
<BR><A HREF="#streambuf__syncLR">sync() [streambuf]</A>
<BR><A HREF="#strstreambuf__syncLR">sync() [strstreambuf]</A>
<BR><A HREF="#ios__sync_with_stdioLR">sync_with_stdio() [ios]</A>
<DT>- T -
<DD><A HREF="#istream__tellgLR">tellg() [istream]</A>
<BR><A HREF="#ostream__tellpLR">tellp() [ostream]</A>
<BR><A HREF="#ios__tieLR">tie() [ios]</A>
<BR><A HREF="#WCStackXType_FTypeY__topLR">top() [WCStack&lt;Type,FType&gt;]</A>
<DT>- U -
<DD><A HREF="#streambuf__unbufferedLR">unbuffered() [streambuf]</A>
<BR><A HREF="#filebuf__underflowLR">underflow() [filebuf]</A>
<BR><A HREF="#stdiobuf__underflowLR">underflow() [stdiobuf]</A>
<BR><A HREF="#streambuf__underflowLR">underflow() [streambuf]</A>
<BR><A HREF="#strstreambuf__underflowLR">underflow() [strstreambuf]</A>
<BR><A HREF="#Unformatted_Input">Unformatted Input</A>
<BR><A HREF="#Unformatted_Output">Unformatted Output</A>
<BR><A HREF="#ios__unsetfLR">unsetf() [ios]</A>
<BR><A HREF="#String__upperLR">upper() [String]</A>
<DT>- V -
<DD><A HREF="#String__validLR">valid() [String]</A>
<BR><A HREF="#WCPtrHashDictIterXKey_ValueY__valueLR">value() [WCPtrHashDictIter&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCValHashDictIterXKey_ValueY__valueLR">value() [WCValHashDictIter&lt;Key,Value&gt;]</A>
<BR><A HREF="#Vector_Containers">Vector Containers</A>
<DT>- W -
<DD><A HREF="#WCExcept__wc_state">wc_state [WCExcept]</A>
<BR><A HREF="#WCDLink_Class_Description">WCDLink Class Description</A>
<BR><A HREF="#WCDLink__WCDLinkLR">WCDLink() [WCDLink]</A>
<BR><A HREF="#WCExcept_Class_Description">WCExcept Class Description</A>
<BR><A HREF="#WCExcept__WCExceptLR">WCExcept() [WCExcept]</A>
<BR><A HREF="#WCIsvConstDListIterXTypeY__WCIsvConstDListIterLR">WCIsvConstDListIter() [WCIsvConstDListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCIsvConstSListIterXTypeY__WCIsvConstSListIterLR">WCIsvConstSListIter() [WCIsvConstSListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCIsvConstSListIterXTypeY__WCIsvConstDListIterXTypeY_Class_Description">WCIsvConstSListIter&lt;Type&gt;, WCIsvConstDListIter&lt;Type&gt; Class Description</A>
<BR><A HREF="#WCIsvDListXTypeY__WCIsvDListLR">WCIsvDList() [WCIsvDList&lt;Type&gt;]</A>
<BR><A HREF="#WCIsvDListIterXTypeY__WCIsvDListIterLR">WCIsvDListIter() [WCIsvDListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCIsvSListXTypeY__WCIsvSListLR">WCIsvSList() [WCIsvSList&lt;Type&gt;]</A>
<BR><A HREF="#WCIsvSListXTypeY__WCIsvDListXTypeY_Class_Description">WCIsvSList&lt;Type&gt;, WCIsvDList&lt;Type&gt; Class Description</A>
<BR><A HREF="#WCIsvSListIterXTypeY__WCIsvSListIterLR">WCIsvSListIter() [WCIsvSListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCIsvSListIterXTypeY__WCIsvDListIterXTypeY_Class_Description">WCIsvSListIter&lt;Type&gt;, WCIsvDListIter&lt;Type&gt; Class Description</A>
<BR><A HREF="#WCIterExcept__wciter_state">wciter_state [WCIterExcept]</A>
<BR><A HREF="#WCIterExcept_Class_Description">WCIterExcept Class Description</A>
<BR><A HREF="#WCIterExcept__WCIterExceptLR">WCIterExcept() [WCIterExcept]</A>
<BR><A HREF="#WCPtrConstDListIterXTypeY__WCPtrConstDListIterLR">WCPtrConstDListIter() [WCPtrConstDListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrConstSListIterXTypeY__WCPtrConstSListIterLR">WCPtrConstSListIter() [WCPtrConstSListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrConstSListIterXTypeY__WCPtrConstDListIterXTypeY_Class_Description">WCPtrConstSListIter&lt;Type&gt;, WCPtrConstDListIter&lt;Type&gt; Class Description</A>
<BR><A HREF="#WCPtrDListXTypeY__WCPtrDListLR">WCPtrDList() [WCPtrDList&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrDListIterXTypeY__WCPtrDListIterLR">WCPtrDListIter() [WCPtrDListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrHashDictXKey_ValueY__WCPtrHashDictLR">WCPtrHashDict() [WCPtrHashDict&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCPtrHashDictXKey_ValueY_Class_Description">WCPtrHashDict&lt;Key,Value&gt; Class Description</A>
<BR><A HREF="#WCPtrHashDictIterXKey_ValueY__WCPtrHashDictIterLR">WCPtrHashDictIter() [WCPtrHashDictIter&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCPtrHashDictIterXKey_ValueY_Class_Description">WCPtrHashDictIter&lt;Key,Value&gt; Class Description</A>
<BR><A HREF="#WCPtrHashSetXTypeY__WCPtrHashSetLR">WCPtrHashSet() [WCPtrHashSet&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrHashSetIterXTypeY__WCPtrHashSetIterLR">WCPtrHashSetIter() [WCPtrHashSetIter&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrHashSetIterXTypeY__WCPtrHashTableIterXTypeY_Class_Description">WCPtrHashSetIter&lt;Type&gt;, WCPtrHashTableIter&lt;Type&gt; Class Description</A>
<BR><A HREF="#WCPtrHashTableXTypeY__WCPtrHashTableLR">WCPtrHashTable() [WCPtrHashTable&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrHashTableXTypeY__WCPtrHashSetXTypeY_Class_Description">WCPtrHashTable&lt;Type&gt;, WCPtrHashSet&lt;Type&gt; Class Description</A>
<BR><A HREF="#WCPtrHashTableIterXTypeY__WCPtrHashTableIterLR">WCPtrHashTableIter() [WCPtrHashTableIter&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrOrderedVectorXTypeY__WCPtrOrderedVectorLR">WCPtrOrderedVector() [WCPtrOrderedVector&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrSkipListXTypeY__WCPtrSkipListLR">WCPtrSkipList() [WCPtrSkipList&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrSkipListXTypeY__WCPtrSkipListSetXTypeY_Class_Description">WCPtrSkipList&lt;Type&gt;, WCPtrSkipListSet&lt;Type&gt; Class Description</A>
<BR><A HREF="#WCPtrSkipListDictXKey_ValueY__WCPtrSkipListDictLR">WCPtrSkipListDict() [WCPtrSkipListDict&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCPtrSkipListDictXKey_ValueY_Class_Description">WCPtrSkipListDict&lt;Key,Value&gt; Class Description</A>
<BR><A HREF="#WCPtrSkipListSetXTypeY__WCPtrSkipListSetLR">WCPtrSkipListSet() [WCPtrSkipListSet&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrSListXTypeY__WCPtrSListLR">WCPtrSList() [WCPtrSList&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrSListXTypeY__WCPtrDListXTypeY_Class_Description">WCPtrSList&lt;Type&gt;, WCPtrDList&lt;Type&gt; Class Description</A>
<BR><A HREF="#WCPtrSListIterXTypeY__WCPtrSListIterLR">WCPtrSListIter() [WCPtrSListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrSListIterXTypeY__WCPtrDListIterXTypeY_Class_Description">WCPtrSListIter&lt;Type&gt;, WCPtrDListIter&lt;Type&gt; Class Description</A>
<BR><A HREF="#WCPtrSortedVectorXTypeY__WCPtrSortedVectorLR">WCPtrSortedVector() [WCPtrSortedVector&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrSortedVectorXTypeY__WCPtrOrderedVectorXTypeY_Class_Description">WCPtrSortedVector&lt;Type&gt;, WCPtrOrderedVector&lt;Type&gt; Class Description</A>
<BR><A HREF="#WCPtrVectorXTypeY__WCPtrVectorLR">WCPtrVector() [WCPtrVector&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrVectorXTypeY_Class_Description">WCPtrVector&lt;Type&gt; Class Description</A>
<BR><A HREF="#WCQueueXType_FTypeY__WCQueueLR">WCQueue() [WCQueue&lt;Type,FType&gt;]</A>
<BR><A HREF="#WCQueueXType_FTypeY_Class_Description">WCQueue&lt;Type,FType&gt; Class Description</A>
<BR><A HREF="#WCSLink_Class_Description">WCSLink Class Description</A>
<BR><A HREF="#WCSLink__WCSLinkLR">WCSLink() [WCSLink]</A>
<BR><A HREF="#WCStackXType_FTypeY__WCStackLR">WCStack() [WCStack&lt;Type,FType&gt;]</A>
<BR><A HREF="#WCStackXType_FTypeY_Class_Description">WCStack&lt;Type,FType&gt; Class Description</A>
<BR><A HREF="#WCValConstDListIterXTypeY__WCValConstDListIterLR">WCValConstDListIter() [WCValConstDListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCValConstSListIterXTypeY__WCValConstSListIterLR">WCValConstSListIter() [WCValConstSListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCValConstSListIterXTypeY__WCValConstDListIterXTypeY_Class_Description">WCValConstSListIter&lt;Type&gt;, WCValConstDListIter&lt;Type&gt; Class Description</A>
<BR><A HREF="#WCValDListXTypeY__WCValDListLR">WCValDList() [WCValDList&lt;Type&gt;]</A>
<BR><A HREF="#WCValDListIterXTypeY__WCValDListIterLR">WCValDListIter() [WCValDListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCValHashDictXKey_ValueY__WCValHashDictLR">WCValHashDict() [WCValHashDict&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCValHashDictXKey_ValueY_Class_Description">WCValHashDict&lt;Key,Value&gt; Class Description</A>
<BR><A HREF="#WCValHashDictIterXKey_ValueY__WCValHashDictIterLR">WCValHashDictIter() [WCValHashDictIter&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCValHashDictIterXKey_ValueY_Class_Description">WCValHashDictIter&lt;Key,Value&gt; Class Description</A>
<BR><A HREF="#WCValHashSetXTypeY__WCValHashSetLR">WCValHashSet() [WCValHashSet&lt;Type&gt;]</A>
<BR><A HREF="#WCValHashSetIterXTypeY__WCValHashSetIterLR">WCValHashSetIter() [WCValHashSetIter&lt;Type&gt;]</A>
<BR><A HREF="#WCValHashSetIterXTypeY__WCValHashTableIterXTypeY_Class_Description">WCValHashSetIter&lt;Type&gt;, WCValHashTableIter&lt;Type&gt; Class Description</A>
<BR><A HREF="#WCValHashTableXTypeY__WCValHashTableLR">WCValHashTable() [WCValHashTable&lt;Type&gt;]</A>
<BR><A HREF="#WCValHashTableXTypeY__WCValHashSetXTypeY_Class_Description">WCValHashTable&lt;Type&gt;, WCValHashSet&lt;Type&gt; Class Description</A>
<BR><A HREF="#WCValHashTableIterXTypeY__WCValHashTableIterLR">WCValHashTableIter() [WCValHashTableIter&lt;Type&gt;]</A>
<BR><A HREF="#WCValOrderedVectorXTypeY__WCValOrderedVectorLR">WCValOrderedVector() [WCValOrderedVector&lt;Type&gt;]</A>
<BR><A HREF="#WCValSkipListXTypeY__WCValSkipListLR">WCValSkipList() [WCValSkipList&lt;Type&gt;]</A>
<BR><A HREF="#WCValSkipListXTypeY__WCValSkipListSetXTypeY_Class_Description">WCValSkipList&lt;Type&gt;, WCValSkipListSet&lt;Type&gt; Class Description</A>
<BR><A HREF="#WCValSkipListDictXKey_ValueY__WCValSkipListDictLR">WCValSkipListDict() [WCValSkipListDict&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCValSkipListDictXKey_ValueY_Class_Description">WCValSkipListDict&lt;Key,Value&gt; Class Description</A>
<BR><A HREF="#WCValSkipListSetXTypeY__WCValSkipListSetLR">WCValSkipListSet() [WCValSkipListSet&lt;Type&gt;]</A>
<BR><A HREF="#WCValSListXTypeY__WCValSListLR">WCValSList() [WCValSList&lt;Type&gt;]</A>
<BR><A HREF="#WCValSListXTypeY__WCValDListXTypeY_Class_Description">WCValSList&lt;Type&gt;, WCValDList&lt;Type&gt; Class Description</A>
<BR><A HREF="#WCValSListIterXTypeY__WCValSListIterLR">WCValSListIter() [WCValSListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCValSListIterXTypeY__WCValDListIterXTypeY_Class_Description">WCValSListIter&lt;Type&gt;, WCValDListIter&lt;Type&gt; Class Description</A>
<BR><A HREF="#WCValSortedVectorXTypeY__WCValSortedVectorLR">WCValSortedVector() [WCValSortedVector&lt;Type&gt;]</A>
<BR><A HREF="#WCValSortedVectorXTypeY__WCValOrderedVectorXTypeY_Class_Description">WCValSortedVector&lt;Type&gt;, WCValOrderedVector&lt;Type&gt; Class Description</A>
<BR><A HREF="#WCValVectorXTypeY__WCValVectorLR">WCValVector() [WCValVector&lt;Type&gt;]</A>
<BR><A HREF="#WCValVectorXTypeY_Class_Description">WCValVector&lt;Type&gt; Class Description</A>
<BR><A HREF="#ios__widthLR">width() [ios]</A>
<BR><A HREF="#ostream__writeLR">write() [ostream]</A>
<DT>- X -
<DD><A HREF="#ios__xallocLR">xalloc() [ios]</A>
<DT>-&nbsp; -
<DD><A HREF="#Complex____ComplexLR">Complex() [Complex]</A>
<BR><A HREF="#filebuf____filebufLR">filebuf() [filebuf]</A>
<BR><A HREF="#fstream____fstreamLR">fstream() [fstream]</A>
<BR><A HREF="#fstreambase____fstreambaseLR">fstreambase() [fstreambase]</A>
<BR><A HREF="#ifstream____ifstreamLR">ifstream() [ifstream]</A>
<BR><A HREF="#ios____iosLR">ios() [ios]</A>
<BR><A HREF="#iostream____iostreamLR">iostream() [iostream]</A>
<BR><A HREF="#istream____istreamLR">istream() [istream]</A>
<BR><A HREF="#istrstream____istrstreamLR">istrstream() [istrstream]</A>
<BR><A HREF="#ofstream____ofstreamLR">ofstream() [ofstream]</A>
<BR><A HREF="#ostream____ostreamLR">ostream() [ostream]</A>
<BR><A HREF="#ostrstream____ostrstreamLR">ostrstream() [ostrstream]</A>
<BR><A HREF="#stdiobuf____stdiobufLR">stdiobuf() [stdiobuf]</A>
<BR><A HREF="#streambuf____streambufLR">streambuf() [streambuf]</A>
<BR><A HREF="#String____StringLR">String() [String]</A>
<BR><A HREF="#strstream____strstreamLR">strstream() [strstream]</A>
<BR><A HREF="#strstreambase____strstreambaseLR">strstreambase() [strstreambase]</A>
<BR><A HREF="#strstreambuf____strstreambufLR">strstreambuf() [strstreambuf]</A>
<BR><A HREF="#WCDLink____WCDLinkLR">WCDLink() [WCDLink]</A>
<BR><A HREF="#WCExcept____WCExceptLR">WCExcept() [WCExcept]</A>
<BR><A HREF="#WCIsvConstDListIterXTypeY____WCIsvConstDListIterLR">WCIsvConstDListIter() [WCIsvConstDListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCIsvConstSListIterXTypeY____WCIsvConstSListIterLR">WCIsvConstSListIter() [WCIsvConstSListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCIsvDListXTypeY____WCIsvDListLR">WCIsvDList() [WCIsvDList&lt;Type&gt;]</A>
<BR><A HREF="#WCIsvDListIterXTypeY____WCIsvDListIterLR">WCIsvDListIter() [WCIsvDListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCIsvSListXTypeY____WCIsvSListLR">WCIsvSList() [WCIsvSList&lt;Type&gt;]</A>
<BR><A HREF="#WCIsvSListIterXTypeY____WCIsvSListIterLR">WCIsvSListIter() [WCIsvSListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCIterExcept____WCIterExceptLR">WCIterExcept() [WCIterExcept]</A>
<BR><A HREF="#WCPtrConstDListIterXTypeY____WCPtrConstDListIterLR">WCPtrConstDListIter() [WCPtrConstDListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrConstSListIterXTypeY____WCPtrConstSListIterLR">WCPtrConstSListIter() [WCPtrConstSListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrDListXTypeY____WCPtrDListLR">WCPtrDList() [WCPtrDList&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrDListIterXTypeY____WCPtrDListIterLR">WCPtrDListIter() [WCPtrDListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrHashDictXKey_ValueY____WCPtrHashDictLR">WCPtrHashDict() [WCPtrHashDict&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCPtrHashDictIterXKey_ValueY____WCPtrHashDictIterLR">WCPtrHashDictIter() [WCPtrHashDictIter&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCPtrHashSetXTypeY____WCPtrHashSetLR">WCPtrHashSet() [WCPtrHashSet&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrHashSetIterXTypeY____WCPtrHashSetIterLR">WCPtrHashSetIter() [WCPtrHashSetIter&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrHashTableXTypeY____WCPtrHashTableLR">WCPtrHashTable() [WCPtrHashTable&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrHashTableIterXTypeY____WCPtrHashTableIterLR">WCPtrHashTableIter() [WCPtrHashTableIter&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrOrderedVectorXTypeY____WCPtrOrderedVectorLR">WCPtrOrderedVector() [WCPtrOrderedVector&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrSkipListXTypeY____WCPtrSkipListLR">WCPtrSkipList() [WCPtrSkipList&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrSkipListDictXKey_ValueY____WCPtrSkipListDictLR">WCPtrSkipListDict() [WCPtrSkipListDict&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCPtrSkipListSetXTypeY____WCPtrSkipListSetLR">WCPtrSkipListSet() [WCPtrSkipListSet&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrSListXTypeY____WCPtrSListLR">WCPtrSList() [WCPtrSList&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrSListIterXTypeY____WCPtrSListIterLR">WCPtrSListIter() [WCPtrSListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrSortedVectorXTypeY____WCPtrSortedVectorLR">WCPtrSortedVector() [WCPtrSortedVector&lt;Type&gt;]</A>
<BR><A HREF="#WCPtrVectorXTypeY____WCPtrVectorLR">WCPtrVector() [WCPtrVector&lt;Type&gt;]</A>
<BR><A HREF="#WCQueueXType_FTypeY____WCQueueLR">WCQueue() [WCQueue&lt;Type,FType&gt;]</A>
<BR><A HREF="#WCSLink____WCSLinkLR">WCSLink() [WCSLink]</A>
<BR><A HREF="#WCStackXType_FTypeY____WCStackLR">WCStack() [WCStack&lt;Type,FType&gt;]</A>
<BR><A HREF="#WCValConstDListIterXTypeY____WCValConstDListIterLR">WCValConstDListIter() [WCValConstDListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCValConstSListIterXTypeY____WCValConstSListIterLR">WCValConstSListIter() [WCValConstSListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCValDListXTypeY____WCValDListLR">WCValDList() [WCValDList&lt;Type&gt;]</A>
<BR><A HREF="#WCValDListIterXTypeY____WCValDListIterLR">WCValDListIter() [WCValDListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCValHashDictXKey_ValueY____WCValHashDictLR">WCValHashDict() [WCValHashDict&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCValHashDictIterXKey_ValueY____WCValHashDictIterLR">WCValHashDictIter() [WCValHashDictIter&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCValHashSetXTypeY____WCValHashSetLR">WCValHashSet() [WCValHashSet&lt;Type&gt;]</A>
<BR><A HREF="#WCValHashSetIterXTypeY____WCValHashSetIterLR">WCValHashSetIter() [WCValHashSetIter&lt;Type&gt;]</A>
<BR><A HREF="#WCValHashTableXTypeY____WCValHashTableLR">WCValHashTable() [WCValHashTable&lt;Type&gt;]</A>
<BR><A HREF="#WCValHashTableIterXTypeY____WCValHashTableIterLR">WCValHashTableIter() [WCValHashTableIter&lt;Type&gt;]</A>
<BR><A HREF="#WCValOrderedVectorXTypeY____WCValOrderedVectorLR">WCValOrderedVector() [WCValOrderedVector&lt;Type&gt;]</A>
<BR><A HREF="#WCValSkipListXTypeY____WCValSkipListLR">WCValSkipList() [WCValSkipList&lt;Type&gt;]</A>
<BR><A HREF="#WCValSkipListDictXKey_ValueY____WCValSkipListDictLR">WCValSkipListDict() [WCValSkipListDict&lt;Key,Value&gt;]</A>
<BR><A HREF="#WCValSkipListSetXTypeY____WCValSkipListSetLR">WCValSkipListSet() [WCValSkipListSet&lt;Type&gt;]</A>
<BR><A HREF="#WCValSListXTypeY____WCValSListLR">WCValSList() [WCValSList&lt;Type&gt;]</A>
<BR><A HREF="#WCValSListIterXTypeY____WCValSListIterLR">WCValSListIter() [WCValSListIter&lt;Type&gt;]</A>
<BR><A HREF="#WCValSortedVectorXTypeY____WCValSortedVectorLR">WCValSortedVector() [WCValSortedVector&lt;Type&gt;]</A>
<BR><A HREF="#WCValVectorXTypeY____WCValVectorLR">WCValVector() [WCValVector&lt;Type&gt;]</A>
</DL>
<H1 ID="Header_Files"> Header Files </H1>
<BR>The following header files are supplied with the Open Watcom C++ library.&nbsp; When a class or function from the library
is used in a source file the related header file should be included in that source file.&nbsp; The header files can be included
multiple times and in any order with no ill effect.
<BR><BR>The facilities of the C standard library can be used in C++ programs by including the appropriate &quot;cname&quot;
header.&nbsp; In that case all of the C standard library functions are in namespace<TT> std.</TT>&nbsp; For example, to use
function<TT> std::printf</TT> one should include the header cstdio.&nbsp; Note that the cname headers declare in the global
namespace any non-standard names they contain as extensions.&nbsp; It is also possible to include in a C++ program the same
headers used by C programs.&nbsp; In that case, the standard functions are in both the global namespace as well as in namespace<TT>
std.</TT>
<BR><BR>Some of C++ standard library headers described below come in a form with a .h extension and in a form without an extension.
&nbsp;The extensionless headers declare their library classes and functions in namespace<TT> std.</TT>&nbsp; The headers with
a .h extension declare their library classes and functions in both the global namespace and in namespace<TT> std.</TT>&nbsp;
Such headers are provided as a convenience and for compatibility with legacy code.&nbsp; Programs that intend to conform to
Standard C++ should use the extensionless headers to access the facilities of the C++ standard library.
<BR><BR>Certain headers defined by Standard C++ have names that are longer than the 8.3 limit imposed by the FAT16 filesystem.
&nbsp;Such headers are provided with names that are truncated to eight characters so they can be used with the DOS host.&nbsp;
However, one can still refer to them in #include directives using their full names as defined by the standard.&nbsp; If the
Open Watcom C++ compiler is unable to open a header with the long name, it will truncate the name and try again.
<BR><BR>The Open Watcom C++ library contains some components that were developed before C++ was standardized.&nbsp; These
legacy components continue to be supported and are described in this documentation.
<BR><BR>The header files are all located in the<TT> \WATCOM\H</TT> directory.
<DL>
<DT>algorithm (algorith)
<DD>This header file defines the standard algorithm templates.
<DT>complex
<DD>This header file defines the<TT> std::complex</TT> class template and related function templates.&nbsp; This template can
be instantiated for the three different floating point types.&nbsp; It can be used to represent complex numbers and to perform
complex arithmetic.
<DT>complex.h
<DD>This header file defines the legacy<TT> Complex</TT> class.&nbsp; This class is used to represent complex numbers and to perform
complex arithmetic.&nbsp; The class defined in this header is not the Standard C++<TT> std::complex</TT> class template.
<DT>exception/exception.h (exceptio/exceptio.h)
<DD>This header file defines components to be used with the exception handling mechanism.&nbsp; It defines the base class of the
standard exception hierarchy.
<DT>functional (function)
<DD>This header file defines the standard functional templates.&nbsp; This includes the functors and binders described by Standard
C++.
<DT>fstream/fstream.h
<DD>This header file defines the<TT> filebuf</TT>,<TT> fstreambase</TT>,<TT> ifstream</TT>,<TT> ofstream</TT>, and<TT> fstream</TT>
classes.&nbsp; These classes are used to perform C++ file input and output operations.&nbsp; The various class members are
declared and inline member functions for the classes are defined.
<DT>generic.h
<DD>This header file is part of the macro support required to implement generic containers prior to the introduction of templates
in the C++ language.&nbsp; It is retained for backwards compatibility.
<DT>iomanip/iomanip.h
<DD>This header file defines the parameterized manipulators.
<DT>ios/ios.h
<DD>This header file defines the class<TT> ios</TT> that is used as a base of the other iostream classes.
<DT>iosfwd/iosfwd.h
<DD>This header file provides forward declarations of the iostream classes.&nbsp; It should be used in cases where the full class
definitions are not needed but where one still wants to declare pointers or references to iostream related objects.&nbsp;
Typically this occurs in a header for another class that wants to provide overloaded inserter or extractor operators.&nbsp;
By including<TT> iosfwd</TT> instead of<TT> iostream</TT> (for example), compilation speed can be improved because less material
must be processed by the compiler.
<BR><BR>Note that including<TT> iosfwd</TT> is the only appropriate way to forward declare the iostream classes.&nbsp; Manually
writing forward declarations is not recommended.
<DT>iostream/iostream.h
<DD>This header file (indirectly) defines the<TT> ios</TT>,<TT> istream</TT>,<TT> ostream</TT>, and<TT> iostream</TT> classes.
&nbsp;These classes form the basis of the C++ formatted input and output support.&nbsp; The various class members are declared
and inline member functions for the classes are defined.&nbsp; The<TT> cin</TT>,<TT> cout</TT>,<TT> cerr</TT>, and<TT> clog</TT>
predefined objects are declared along with the non-parameterized manipulators.
<DT>istream/istream.h
<DD>This header file defines class<TT> istream</TT> and class<TT> iostream.</TT>&nbsp; It also defines their associated parameterless
manipulators.
<DT>iterator
<DD>This header file defines several templates to facilitate the handling of iterators.&nbsp; In particular, it defines the<TT>
std::iterator_traits</TT> template as well as several other supporting iterator related templates.
<DT>limits
<DD>This header file defines the<TT> std::numeric_limits</TT> template and provides specializations of that template for each
of the built-in types.
<BR><BR>Note that this header is not directly related to the header limits.h from the C standard library (or to the C++ form
of that header, climits).
<DT>list
<DD>This header file defines the<TT> std::list</TT> class template.&nbsp; It provides a way to make a sequence of objects with
efficient insert and erase operations.
<DT>map
<DD>This header file defines the<TT> std::map</TT> and<TT> std::multimap</TT> class templates.&nbsp; They provide ways to associate
keys to values.
<DT>memory
<DD>This header file defines the default allocator template,<TT> std::allocator,</TT> as well as several function templates for
manipulating raw (uninitialized) memory regions.&nbsp; In addition this header defines the<TT> std::auto_ptr</TT> template.
<BR><BR>Note that the header<TT> memory.h</TT> is part of the Open Watcom C library and is unrelated to<TT> memory.</TT>
<DT>new/new.h
<DD>This header file provides declarations to be used with the intrinsic<TT> operator new</TT> and<TT> operator delete</TT> memory
management functions.
<DT>numeric
<DD>This header file defines several standard algorithm templates pertaining to numerical computation.
<DT>ostream/ostream.h
<DD>This header file defines class<TT> ostream.</TT>&nbsp; It also defines its associated parameterless manipulators.
<DT>set
<DD>This header file defines the<TT> std::set</TT> and<TT> std::multiset</TT> class templates.&nbsp; They provide ways to make
ordered collections of objects with efficient insert, erase, and find operations.
<DT>stdiobuf.h
<DD>This header file defines the<TT> stdiobuf</TT> class which provides the support for the C++ input and output operations to
standard input, standard output, and standard error streams.
<DT>streambuf/streambuf.h (streambu/streambu.h)
<DD>This header file defines the<TT> streambuf</TT> class which provides the support for buffering of input and output operations.
&nbsp;This header file is automatically included by the<TT> iostream.h</TT> header file.
<DT>string
<DD>This header file defines the<TT> std::basic_string</TT> class template.&nbsp; It also contains the type definitions for<TT>
std::string</TT> and<TT> std::wstring.</TT>&nbsp; In addition, this header contains specializations of the<TT> std::char_traits</TT>
template for both characters and wide characters.
<DT>string.hpp
<DD>This header file defines the legacy<TT> String</TT> class.&nbsp; The<TT> String</TT> class is used to manipulate character
strings.&nbsp; Note that the<TT> hpp</TT> extension is used to avoid colliding with the Standard C<TT> string.h</TT> header
file.&nbsp; The class defined in this header is not the Standard C++<TT> std::string</TT> class.
<DT>strstream.h (strstrea.h)
<DD>This header files defines the<TT> strstreambuf</TT>,<TT> strstreambase</TT>,<TT> istrstream</TT>,<TT> ostrstream</TT>, and<TT>
strstream</TT> classes.&nbsp; These classes are used to perform C++ in-memory formatting.&nbsp; The various class members
are declared and inline member functions for the classes are defined.
<DT>vector
<DD>This header contains the<TT> std::vector</TT> class template.
<DT>wcdefs.h
<DD>This header file contains definitions used by the Open Watcom legacy container libraries.&nbsp; If a container class needs
any of these definitions, the file is automatically included.
<BR><BR>Note that all headers having names that start with &quot;wc&quot; are related to the legacy container libraries.
<DT>wclbase.h
<DD>This header file defines the base classes which are used by the list containers.
<DT>wclcom.h
<DD>This header file defines the classes which are common to the list containers.
<DT>wclibase.h
<DD>This header file defines the base classes which are used by the list iterators.
<DT>wclist.h
<DD>This header file defines the<TT> list</TT> container classes.&nbsp; The available list container classes are single and double
linked versions of intrusive, value and pointer lists.
<DT>wclistit.h
<DD>This header file defines the<TT> iterator</TT> classes that correspond to the list containers.
<DT>wcqueue.h
<DD>This header file defines the<TT> queue</TT> class.&nbsp; Entries in a queue class are accessed first in, first out.
<DT>wcstack.h
<DD>This header file defines the<TT> stack</TT> class.&nbsp; Entries in a stack class are accessed last in, first out.
</DL>
<H1 ID="Common_Types"> Common Types </H1>
<BR>The set of classes that make up the C++ class library use several common typedefs and macros.&nbsp; They are declared
in<TT> &lt;iostream.h&gt;</TT> and<TT> &lt;fstream.h&gt;</TT>.
<BR><BR><TT>typedef long streampos;</TT>
<BR><TT>typedef long streamoff;</TT>
<BR><TT>typedef int filedesc;</TT>
<BR><TT>#define __NOT_EOF 0</TT>
<BR><TT>#define EOF -1</TT>
<BR><BR>The<TT> streampos</TT> type represents an absolute position within the file.&nbsp; For Open Watcom C++, the file position
can be represented by an integral type.&nbsp; For some file systems, or at a lower level within the file system, the stream
position might be represented by an aggregate (structure) containing information such as cylinder, track, sector and offset.
<BR>The<TT> streamoff</TT> type represents a relative position within the file.&nbsp; The offset can always be represented
as a signed integer quantity since it is a number of characters before or after an absolute position within the file.
<BR><BR>The<TT> filedesc</TT> type represents the type of a C library file handle.&nbsp; It is used in places where the I/O
stream library takes a C library file handle as an argument.
<BR><BR>The<TT> __NOT_EOF</TT> macro is defined for cases where a function needs to return something other than<TT> EOF</TT>
to indicate success.
<BR><BR>The<TT> EOF</TT> macro is defined to be identical to the value provided by the<TT> &lt;stdio.h&gt;</TT> header file.
<H1 ID="Predefined_Objects"> Predefined Objects </H1>
<BR>Most programs interact in some manner with the keyboard and screen.&nbsp; The C programming language provides three values,<TT>
stdin</TT>,<TT> stdout</TT> and<TT> stderr</TT>, that are used for communicating with these &quot;standard&quot; devices,
which are opened before the user program starts execution at<TT> main()</TT>.&nbsp; These three values are<TT> FILE</TT> pointers
and can be used in virtually any file operation supported by the C library.
<BR><BR>In a similar manner, C++ provides seven objects for communicating with the same &quot;standard&quot; devices.&nbsp;
C++ provides the three C<TT> FILE</TT> pointers<TT> stdin</TT>,<TT> stdout</TT> and<TT> stderr</TT>, but they cannot be used
with the extractors and inserters provided as part of the C++ library.&nbsp; C++ provides four new objects, called<TT> cin</TT>,<TT>
cout</TT>,<TT> cerr</TT> and<TT> clog</TT>, which correspond to<TT> stdin</TT>,<TT> stdout</TT>,<TT> stderr</TT> and buffered<TT>
stderr</TT>.
<H2 ID="cin"> cin </H2>
<BR><TT>cin</TT> is an<TT> istream</TT> object which is connected to &quot;standard input&quot; (usually the keyboard) prior
to program execution.&nbsp; Values extracted using the<TT> istream operator &gt;&gt;</TT> class extractor operators are read
from standard input and interpreted according to the type of the object being extracted.
<BR><BR>Extractions from standard input via<TT> cin</TT> skip whitespace characters by default because the<TT> ios::skipws</TT>
bit is on.&nbsp; The default behavior can be changed with the<TT> ios::setf</TT> public member function or with the<TT> setiosflags</TT>
manipulator.
<H2 ID="cout"> cout </H2>
<BR><TT>cout</TT> is an<TT> ostream</TT> object which is connected to &quot;standard output&quot; (usually the screen) prior
to program execution.&nbsp; Values inserted using the<TT> ostream operator &lt;&lt;</TT> class inserter operators are converted
to characters and written to standard output according to the type of the object being inserted.
<BR><BR>Insertions to standard output via<TT> cout</TT> are buffered by default because the<TT> ios::unitbuf</TT> bit is not
on.&nbsp; The default behavior can be changed with the<TT> ios::setf</TT> public member function or with the<TT> setiosflags</TT>
manipulator.
<H2 ID="cerr"> cerr </H2>
<BR><TT>cerr</TT> is an<TT> ostream</TT> object which is connected to &quot;standard error&quot; (the screen) prior to program
execution.&nbsp; Values inserted using the<TT> ostream operator &lt;&lt;</TT> class inserter operators are converted to characters
and written to standard error according to the type of the object being inserted.
<BR><BR>Insertions to standard error via<TT> cerr</TT> are not buffered by default because the<TT> ios::unitbuf</TT> bit is
on.&nbsp; The default behavior can be changed with the<TT> ios::setf</TT> public member function or with the<TT> setiosflags</TT>
manipulator.
<H2 ID="clog"> clog </H2>
<BR><TT>clog</TT> is an<TT> ostream</TT> object which is connected to &quot;standard error&quot; (the screen) prior to program
execution.&nbsp; Values inserted using the<TT> ostream operator &lt;&lt;</TT> class inserter operators are converted to characters
and written to standard error according to the type of the object being inserted.
<BR><BR>Insertions to standard error via<TT> clog</TT> are buffered by default because the<TT> ios::unitbuf</TT> bit is not
on.&nbsp; The default behavior can be changed with the<TT> ios::setf</TT> public member function or with the<TT> setiosflags</TT>
manipulator.
<H1 ID="istream_Input"> istream Input </H1>
<BR>This chapter describes formatted and unformatted input.
<H2 ID="Formatted_Input__Extractors"> Formatted Input:&nbsp; Extractors </H2>
<BR>The<TT> operator &gt;&gt;</TT> function is used to read formatted values from a stream.&nbsp; It is called an<B> extractor</B>.
&nbsp;Characters are read and interpreted according to the type of object being extracted.
<BR><BR>All<TT> operator &gt;&gt;</TT> functions perform the same basic sequence of operations.&nbsp; First, the input prefix
function<TT> ipfx</TT> is called with a parameter of zero, causing leading whitespace characters to be discarded if<TT> ios::skipws</TT>
is set in<TT> ios::fmtflags</TT>.&nbsp; If the input prefix function fails and returns zero, the<TT> operator &gt;&gt;</TT>
function also fails and returns immediately.&nbsp; If the input prefix function succeeds, characters are read from the stream
and interpreted in terms of the type of object being extracted and<TT> ios::fmtflags</TT>.&nbsp; Finally, the input suffix
function<TT> isfx</TT> is called.
<BR><BR>The<TT> operator &gt;&gt;</TT> functions return a reference to the specified stream so that multiple extractions can
be done in one statement.
<BR><BR>Errors are indicated via<TT> ios::iostate</TT>.<TT>&nbsp; ios::failbit</TT> is set if the characters read from the
stream could not be interpreted for the required type.<TT>&nbsp; ios::badbit</TT> is set if the extraction of characters from
the stream failed in such a way as to make subsequent extractions impossible.<TT>&nbsp; ios::eofbit</TT> is set if the stream
was located at the end when the extraction was attempted.
<H2 ID="Unformatted_Input"> Unformatted Input </H2>
<BR>The unformatted input functions are used to read characters from the stream without interpretation.
<BR><BR>Like the extractors, the unformatted input functions follow a pattern.&nbsp; First, they call<TT> ipfx</TT>, the input
prefix function, with a parameter of one, causing no leading whitespace characters to be discarded.&nbsp; If the input prefix
function fails and returns zero, the unformatted input function also fails and returns immediately.&nbsp; If the input prefix
function succeeds, characters are read from the stream without interpretation.&nbsp; Finally,<TT> isfx</TT>, the input suffix
function, is called.
<BR><BR>Errors are indicated via the iostate bits.<TT>&nbsp; ios::failbit</TT> is set if the extraction of characters from
the stream failed.<TT>&nbsp; ios::eofbit</TT> is set if the stream was located at the end of input when the operation was
attempted.
<H1 ID="ostream_Output"> ostream Output </H1>
<BR>This chapter describes formatted and unformatted output.
<H2 ID="Formatted_Output__Inserters"> Formatted Output:&nbsp; Inserters </H2>
<BR>The<TT> operator &lt;&lt;</TT> function is used to write formatted values to a stream.&nbsp; It is called an<B> inserter</B>.
&nbsp;Values are formatted and written according to the type of object being inserted and<TT> ios::fmtflags</TT>.
<BR><BR>All<TT> operator &lt;&lt;</TT> functions perform the same basic sequence of operations.&nbsp; First, the output prefix
function<TT> opfx</TT> is called.&nbsp; If it fails and returns zero, the<TT> operator &lt;&lt;</TT> function also fails and
returns immediately.&nbsp; If the output prefix function succeeds, the object is formatted according to its type and<TT> ios::fmtflags</TT>.
&nbsp;The formatted sequence of characters is then written to the specified stream.&nbsp; Finally, the output suffix function<TT>
osfx</TT> is called.
<BR><BR>The<TT> operator &lt;&lt;</TT> functions return a reference to the specified stream so that multiple insertions can
be done in one statement.
<BR><BR>For details on the interpretation of<TT> ios::fmtflags</TT>, see the<TT> ios::fmtflags</TT> section of the Library
Functions and Types Chapter.
<BR><BR>Errors are indicated via<TT> ios::iostate</TT>.<TT>&nbsp; ios::failbit</TT> is set if the<TT> operator &lt;&lt;</TT>
function fails while writing the characters to the stream.
<H2 ID="Unformatted_Output"> Unformatted Output </H2>
<BR>The unformatted output functions are used to write characters to the stream without conversion.
<BR><BR>Like the inserters, the unformatted output functions follow a pattern.&nbsp; First, they call the output prefix function<TT>
opfx</TT> and fail if it fails.&nbsp; Then the characters are written without conversion.&nbsp; Finally, the output suffix
function<TT> osfx</TT> is called.
<BR><BR>Errors are indicated via<TT> ios::iostate</TT>.<TT>&nbsp; ios::failbit</TT> is set if the function fails while writing
the characters to the stream.
<H1 ID="Library_Functions_and_Types"> Library Functions and Types </H1>
<BR>Each of the classes and functions in the Class Library is described in this chapter.&nbsp; Each description consists of
a number of subsections:
<DL>
<DT>Declared:
<DD>This optional subsection specifies which header file contains the declaration for a class.&nbsp; It is only found in sections
describing class declarations.
<DT>Derived From:
<DD>This optional subsection shows the inheritance for a class.&nbsp; It is only found in sections describing class declarations.
<DT>Derived By:
<DD>This optional subsection shows which classes inherit from this class.&nbsp; It is only found in sections describing class
declarations.
<DT>Synopsis:
<DD>This subsection gives the name of the header file that contains the declaration of the function.&nbsp; This header file must
be included in order to reference the function.
<BR><BR>For class member functions, the protection associated with the function is indicated via the presence of one of the<TT>
private</TT>,<TT> protected</TT>, or<TT> public</TT> keywords.
<BR><BR>The full function prototype is specified.&nbsp; Virtual class member functions are indicated via the presence of the<TT>
virtual</TT> keyword in the function prototype.
<DT>Semantics:
<DD>This subsection is a description of the function.
<DT>Derived Implementation Protocol:
<DD>This optional subsection is present for virtual member functions.&nbsp; It describes how derived implementations of the virtual
member function should behave.
<DT>Default Implementation:
<DD>This optional subsection is present for virtual member functions.&nbsp; It describes how the default implementation provided
with the base class definition behaves.
<DT>Results:
<DD>This optional subsection describes the function's return value, if any, and the impact of a member function on its object's
state.
<DT>See Also:
<DD>This optional subsection provides a list of related functions or classes.
</DL>
<H1 ID="Complex_Class"> Complex Class </H1>
<BR>This class is used for the storage and manipulation of complex numbers, which are often represented by<B> real</B> and<B>
imaginary</B> components (Cartesian coordinates), or by<B> magnitude</B> and<B> angle</B> (polar coordinates).&nbsp; Each
object stores exactly one complex number.&nbsp; An object may be used in expressions in the same manner as floating-point
values.
<BR><BR>The class documented here is the Open Watcom legacy complex class.&nbsp; It is not the<TT> std::complex</TT> class
template specified by Standard C++.
<H2 ID="Complex_Class_Description"> Complex Class Description </H2>
<DL>
<DT>Declared:
<DD><TT> complex.h</TT>
<BR><BR>The<TT> Complex</TT> class is used for the storage and manipulation of complex numbers, which are often represented
by<B> real</B> and<B> imaginary</B> components (Cartesian coordinates), or by<B> magnitude</B> and<B> angle</B> (polar coordinates).
&nbsp;Each<TT> Complex</TT> object stores exactly one complex number.&nbsp; A<TT> Complex</TT> object may be used in expressions
in the same manner as floating-point values.
<BR><BR><B>Public Member Functions</B>
<BR><BR>The following constructors and destructors are declared:
<BR><BR><TT>Complex();</TT>
<BR><TT> Complex( Complex const &amp; );</TT>
<BR><TT> Complex( double, double = 0.0 );</TT>
<BR><TT> ~Complex();</TT>
<BR><BR>The following arithmetic member functions are declared:
<BR><BR><TT>Complex &amp;operator =( Complex const &amp; );</TT>
<BR><TT> Complex &amp;operator =( double );</TT>
<BR><TT> Complex &amp;operator +=( Complex const &amp; );</TT>
<BR><TT> Complex &amp;operator +=( double );</TT>
<BR><TT> Complex &amp;operator -=( Complex const &amp; );</TT>
<BR><TT> Complex &amp;operator -=( double );</TT>
<BR><TT> Complex &amp;operator *=( Complex const &amp; );</TT>
<BR><TT> Complex &amp;operator *=( double );</TT>
<BR><TT> Complex &amp;operator /=( Complex const &amp; );</TT>
<BR><TT> Complex &amp;operator /=( double );</TT>
<BR><TT> Complex operator +() const;</TT>
<BR><TT> Complex operator -() const;</TT>
<BR><TT> double imag() const;</TT>
<BR><TT> double real() const;</TT>
<BR><BR><B>Friend Functions</B>
<BR><BR>The following I/O Stream inserter and extractor friend functions are declared:
<BR><BR><TT>friend istream &amp;operator &gt;&gt;( istream &amp;, Complex &amp; );</TT>
<BR><TT>friend ostream &amp;operator &lt;&lt;( ostream &amp;, Complex const &amp; );</TT>
<BR><BR><B>Related Operators</B>
<BR><BR>The following operators are declared:
<BR><BR><TT>Complex operator&nbsp; +( Complex const &amp;, Complex const &amp; );</TT>
<BR><TT>Complex operator&nbsp; +( Complex const &amp;, double );</TT>
<BR><TT>Complex operator&nbsp; +( double&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; , Complex const &amp; );</TT>
<BR><TT>Complex operator&nbsp; -( Complex const &amp;, Complex const &amp; );</TT>
<BR><TT>Complex operator&nbsp; -( Complex const &amp;, double );</TT>
<BR><TT>Complex operator&nbsp; -( double&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; , Complex const &amp; );</TT>
<BR><TT>Complex operator&nbsp; *( Complex const &amp;, Complex const &amp; );</TT>
<BR><TT>Complex operator&nbsp; *( Complex const &amp;, double );</TT>
<BR><TT>Complex operator&nbsp; *( double&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; , Complex const &amp; );</TT>
<BR><TT>Complex operator&nbsp; /( Complex const &amp;, Complex const &amp; );</TT>
<BR><TT>Complex operator&nbsp; /( Complex const &amp;, double );</TT>
<BR><TT>Complex operator&nbsp; /( double&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; , Complex const &amp; );</TT>
<BR><TT>int&nbsp;&nbsp;&nbsp;&nbsp; operator ==( Complex const &amp;, Complex const &amp; );</TT>
<BR><TT>int&nbsp;&nbsp;&nbsp;&nbsp; operator ==( Complex const &amp;, double );</TT>
<BR><TT>int&nbsp;&nbsp;&nbsp;&nbsp; operator ==( double&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; , Complex const &amp;
);</TT>
<BR><TT>int&nbsp;&nbsp;&nbsp;&nbsp; operator !=( Complex const &amp;, Complex const &amp; );</TT>
<BR><TT>int&nbsp;&nbsp;&nbsp;&nbsp; operator !=( Complex const &amp;, double );</TT>
<BR><TT>int&nbsp;&nbsp;&nbsp;&nbsp; operator !=( double&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; , Complex const &amp;
);</TT>
<BR><BR><B>Related Functions</B>
<BR><BR>The following related functions are declared:
<BR><BR><TT>double&nbsp; abs&nbsp; ( Complex const &amp; );</TT>
<BR><TT>Complex acos ( Complex const &amp; );</TT>
<BR><TT>Complex acosh( Complex const &amp; );</TT>
<BR><TT>double&nbsp; arg&nbsp; ( Complex const &amp; );</TT>
<BR><TT>Complex asin ( Complex const &amp; );</TT>
<BR><TT>Complex asinh( Complex const &amp; );</TT>
<BR><TT>Complex atan ( Complex const &amp; );</TT>
<BR><TT>Complex atanh( Complex const &amp; );</TT>
<BR><TT>Complex conj ( Complex const &amp; );</TT>
<BR><TT>Complex cos&nbsp; ( Complex const &amp; );</TT>
<BR><TT>Complex cosh ( Complex const &amp; );</TT>
<BR><TT>Complex exp&nbsp; ( Complex const &amp; );</TT>
<BR><TT>double&nbsp; imag ( Complex const &amp; );</TT>
<BR><TT>Complex log&nbsp; ( Complex const &amp; );</TT>
<BR><TT>Complex log10( Complex const &amp; );</TT>
<BR><TT>double&nbsp; norm ( Complex const &amp; );</TT>
<BR><TT>Complex polar( double&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; , double = 0 );</TT>
<BR><TT>Complex pow&nbsp; ( Complex const &amp;, Complex const &amp; );</TT>
<BR><TT>Complex pow&nbsp; ( Complex const &amp;, double );</TT>
<BR><TT>Complex pow&nbsp; ( double&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; , Complex const &amp; );</TT>
<BR><TT>Complex pow&nbsp; ( Complex const &amp;, int );</TT>
<BR><TT>double&nbsp; real ( Complex const &amp; );</TT>
<BR><TT>Complex sin&nbsp; ( Complex const &amp; );</TT>
<BR><TT>Complex sinh ( Complex const &amp; );</TT>
<BR><TT>Complex sqrt ( Complex const &amp; );</TT>
<BR><TT>Complex tan&nbsp; ( Complex const &amp; );</TT>
<BR><TT>Complex tanh ( Complex const &amp; );</TT>
</DL>
<H2 ID="Complex_absLR"> Complex abs() [Complex] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;complex.h&gt;</TT>
<BR><TT>double abs( Complex const &amp;num );</TT>
<DT>Semantics:
<DD>The<TT> abs</TT> function computes the magnitude of<B> num</B>, which is equivalent to the length (magnitude) of the vector
when the<B> num</B> is represented in polar coordinates.
<DT>Results:
<DD>The<TT> abs</TT> function returns the magnitude of<B> num</B>.
<DT>See Also:
<DD><TT> arg</TT>,<TT> norm</TT>,<TT> polar</TT>
</DL>
<H2 ID="Complex_acosLR"> Complex acos() [Complex] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;complex.h&gt;</TT>
<BR><TT>Complex acos( Complex const &amp;num );</TT>
<DT>Semantics:
<DD>The<TT> acos</TT> function computes the arccosine of<B> num</B>.
<DT>Results:
<DD>The<TT> acos</TT> function returns the arccosine of<B> num</B>.
<DT>See Also:
<DD><TT> asin</TT>,<TT> atan</TT>,<TT> cos</TT>
</DL>
<H2 ID="Complex_acoshLR"> Complex acosh() [Complex] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;complex.h&gt;</TT>
<BR><TT>Complex acosh( Complex const &amp;num );</TT>
<DT>Semantics:
<DD>The<TT> acosh</TT> function computes the inverse hyperbolic cosine of<B> num</B>.
<DT>Results:
<DD>The<TT> acosh</TT> function returns the inverse hyperbolic cosine of<B> num</B>.
<DT>See Also:
<DD><TT> asinh</TT>,<TT> atanh</TT>,<TT> cosh</TT>
</DL>
<H2 ID="Complex_argLR"> Complex arg() [Complex] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;complex.h&gt;</TT>
<BR><TT>double arg( Complex const &amp;num );</TT>
<DT>Semantics:
<DD>The<TT> arg</TT> function computes the angle of the vector when the<B> num</B> is represented in polar coordinates.&nbsp;
The angle has the same sign as the real component of the<B> num</B>.&nbsp; It is positive in the 1st and 2nd quadrants, and
negative in the 3rd and 4th quadrants.
<DT>Results:
<DD>The<TT> arg</TT> function returns the angle of the vector when the<B> num</B> is represented in polar coordinates.
<DT>See Also:
<DD><TT> abs</TT>,<TT> norm</TT>,<TT> polar</TT>
</DL>
<H2 ID="Complex_asinLR"> Complex asin() [Complex] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;complex.h&gt;</TT>
<BR><TT>Complex asin( Complex const &amp;num );</TT>
<DT>Semantics:
<DD>The<TT> asin</TT> function computes the arcsine of<B> num</B>.
<DT>Results:
<DD>The<TT> asin</TT> function returns the arcsine of<B> num</B>.
<DT>See Also:
<DD><TT> acos</TT>,<TT> atan</TT>,<TT> sin</TT>
</DL>
<H2 ID="Complex_asinhLR"> Complex asinh() [Complex] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;complex.h&gt;</TT>
<BR><TT>Complex asinh( Complex const &amp;num );</TT>
<DT>Semantics:
<DD>The<TT> asinh</TT> function computes the inverse hyperbolic sine of<B> num</B>.
<DT>Results:
<DD>The<TT> asinh</TT> function returns the inverse hyperbolic sine of<B> num</B>.
<DT>See Also:
<DD><TT> acosh</TT>,<TT> atanh</TT>,<TT> sinh</TT>
</DL>
<H2 ID="Complex_atanLR"> Complex atan() [Complex] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;complex.h&gt;</TT>
<BR><TT>Complex atan( Complex const &amp;num );</TT>
<DT>Semantics:
<DD>The<TT> atan</TT> function computes the arctangent of<B> num</B>.
<DT>Results:
<DD>The<TT> atan</TT> function returns the arctangent of<B> num</B>.
<DT>See Also:
<DD><TT> acos</TT>,<TT> asin</TT>,<TT> tan</TT>
</DL>
<H2 ID="Complex_atanhLR"> Complex atanh() [Complex] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;complex.h&gt;</TT>
<BR><TT>Complex atanh( Complex const &amp;num );</TT>
<DT>Semantics:
<DD>The<TT> atanh</TT> function computes the inverse hyperbolic tangent of<B> num</B>.
<DT>Results:
<DD>The<TT> atanh</TT> function returns the inverse hyperbolic tangent of<B> num</B>.
<DT>See Also:
<DD><TT> acosh</TT>,<TT> asinh</TT>,<TT> tanh</TT>
</DL>
<H2 ID="Complex__ComplexLR"> Complex() [Complex] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;complex.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Complex::Complex();</TT>
<DT>Semantics:
<DD>This form of the public<TT> Complex</TT> constructor creates a default<TT> Complex</TT> object with value zero for both the
real and imaginary components.
<DT>Results:
<DD>This form of the public<TT> Complex</TT> constructor produces a default<TT> Complex</TT> object.
<DT>See Also:
<DD><TT> ~Complex</TT>,<TT> real</TT>,<TT> imag</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;complex.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Complex::Complex( Complex const &amp;num );</TT>
<DT>Semantics:
<DD>This form of the public<TT> Complex</TT> constructor creates a<TT> Complex</TT> object with the same value as<B> num</B>.
<DT>Results:
<DD>This form of the public<TT> Complex</TT> constructor produces a<TT> Complex</TT> object.
<DT>See Also:
<DD><TT> ~Complex</TT>,<TT> real</TT>,<TT> imag</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;complex.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Complex::Complex( double real, double imag = 0.0 );</TT>
<DT>Semantics:
<DD>This form of the public<TT> Complex</TT> constructor creates a<TT> Complex</TT> object with the real component set to<B> real</B>
and the imaginary component set to<B> imag</B>.&nbsp; If no imaginary component is specified,<B> imag</B> takes the default
value of zero.
<DT>Results:
<DD>This form of the public<TT> Complex</TT> constructor produces a<TT> Complex</TT> object.
<DT>See Also:
<DD><TT> ~Complex</TT>,<TT> real</TT>,<TT> imag</TT>
</DL>
<H2 ID="Complex____ComplexLR"> ~Complex() [Complex] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;complex.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Complex::~Complex();</TT>
<DT>Semantics:
<DD>The public<TT> ~Complex</TT> destructor destroys the<TT> Complex</TT> object.&nbsp; The call to the public<TT> ~Complex</TT>
destructor is inserted implicitly by the compiler at the point where the<TT> Complex</TT> object goes out of scope.
<DT>Results:
<DD>The<TT> Complex</TT> object is destroyed.
<DT>See Also:
<DD><TT> Complex</TT>
</DL>
<H2 ID="Complex_conjLR"> Complex conj() [Complex] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;complex.h&gt;</TT>
<BR><TT>Complex conj( Complex const &amp;num );</TT>
<DT>Semantics:
<DD>The<TT> conj</TT> function computes the conjugate of<B> num</B>.&nbsp; The conjugate consists of the unchanged real component,
and the negative of the imaginary component.
<DT>Results:
<DD>The<TT> conj</TT> function returns the conjugate of<B> num</B>.
</DL>
<H2 ID="Complex_cosLR"> Complex cos() [Complex] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;complex.h&gt;</TT>
<BR><TT>Complex cos( Complex const &amp;num );</TT>
<DT>Semantics:
<DD>The<TT> cos</TT> function computes the cosine of<B> num</B>.
<DT>Results:
<DD>The<TT> cos</TT> function returns the cosine of<B> num</B>.
<DT>See Also:
<DD><TT> acos</TT>,<TT> sin</TT>,<TT> tan</TT>
</DL>
<H2 ID="Complex_coshLR"> Complex cosh() [Complex] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;complex.h&gt;</TT>
<BR><TT>Complex cosh( Complex const &amp;num );</TT>
<DT>Semantics:
<DD>The<TT> cosh</TT> function computes the hyperbolic cosine of<B> num</B>.
<DT>Results:
<DD>The<TT> cosh</TT> function returns the hyperbolic cosine of<B> num</B>.
<DT>See Also:
<DD><TT> acosh</TT>,<TT> sinh</TT>,<TT> tanh</TT>
</DL>
<H2 ID="Complex_expLR"> Complex exp() [Complex] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;complex.h&gt;</TT>
<BR><TT>Complex exp( Complex const &amp;num );</TT>
<DT>Semantics:
<DD>The<TT> exp</TT> function computes the value of<B> e</B> raised to the power<B> num</B>.
<DT>Results:
<DD>The<TT> exp</TT> function returns the value of<B> e</B> raised to the power<B> num</B>.
<DT>See Also:
<DD><TT> log</TT>,<TT> log10</TT>,<TT> pow</TT>,<TT> sqrt</TT>
</DL>
<H2 ID="Complex__imagLR"> imag() [Complex] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;complex.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>double Complex::imag();</TT>
<DT>Semantics:
<DD>The<TT> imag</TT> public member function extracts the imaginary component of the<TT> Complex</TT> object.
<DT>Results:
<DD>The<TT> imag</TT> public member function returns the imaginary component of the<TT> Complex</TT> object.
<DT>See Also:
<DD><TT> imag</TT>,<TT> real</TT>
<BR><BR><TT>Complex::real</TT>
</DL>
<H2 ID="Complex_imagLR"> Complex imag() [Complex] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;complex.h&gt;</TT>
<BR><TT>double imag( Complex const &amp;num );</TT>
<DT>Semantics:
<DD>The<TT> imag</TT> function extracts the imaginary component of<B> num</B>.
<DT>Results:
<DD>The<TT> imag</TT> function returns the imaginary component of<B> num</B>.
<DT>See Also:
<DD><TT> real</TT>
<BR><BR><TT>Complex::imag</TT>,<TT> real</TT>
</DL>
<H2 ID="Complex_logLR"> Complex log() [Complex] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;complex.h&gt;</TT>
<BR><TT>Complex log( Complex const &amp;num );</TT>
<DT>Semantics:
<DD>The<TT> log</TT> function computes the natural, or base<B> e</B>, logarithm of<B> num</B>.
<DT>Results:
<DD>The<TT> log</TT> function returns the natural, or base<B> e</B>, logarithm of<B> num</B>.
<DT>See Also:
<DD><TT> exp</TT>,<TT> log10</TT>,<TT> pow</TT>,<TT> sqrt</TT>
</DL>
<H2 ID="Complex_log10LR"> Complex log10() [Complex] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;complex.h&gt;</TT>
<BR><TT>Complex log10( Complex const &amp;num );</TT>
<DT>Semantics:
<DD>The<TT> log10</TT> function computes the base 10 logarithm of<B> num</B>.
<DT>Results:
<DD>The<TT> log10</TT> function returns the base 10 logarithm of<B> num</B>.
<DT>See Also:
<DD><TT> exp</TT>,<TT> log</TT>,<TT> pow</TT>,<TT> sqrt</TT>
</DL>
<H2 ID="Complex_normLR"> Complex norm() [Complex] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;complex.h&gt;</TT>
<BR><TT>double norm( Complex const &amp;num );</TT>
<DT>Semantics:
<DD>The<TT> norm</TT> function computes the square of the magnitude of<B> num</B>, which is equivalent to the square of the length
(magnitude) of the vector when<B> num</B> is represented in polar coordinates.
<DT>Results:
<DD>The<TT> norm</TT> function returns the square of the magnitude of<B> num</B>.
<DT>See Also:
<DD><TT> arg</TT>,<TT> polar</TT>
</DL>
<H2 ID="Complex_operator__ELR"> Complex operator !=() [Complex] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;complex.h&gt;</TT>
<BR><TT>int operator !=( Complex const &amp;num1, Complex const &amp;num2 );</TT>
<BR><TT>int operator !=( Complex const &amp;num1, double num2 );</TT>
<BR><TT>int operator !=( double num1, Complex const &amp;num2 );</TT>
<DT>Semantics:
<DD>The<TT> operator !=</TT> function compares<B> num1</B> and<B> num2</B> for inequality.&nbsp; At least one of the parameters
must be a<TT> Complex</TT> object for this function to be called.
<BR><BR>Two<TT> Complex</TT> objects are not equal if either of their corresponding real or imaginary components are not equal.
<BR><BR>If the<TT> operator !=</TT> function is used with a<TT> Complex</TT> object and an object of any other built-in numeric
type, the non-<TT> Complex</TT> object is converted to a<TT> double</TT> and the second or third form of the<TT> operator
!=</TT> function is used.
<DT>Results:
<DD>The<TT> operator !=</TT> function returns a non-zero value if<B> num1</B> is not equal to<B> num2</B>, otherwise zero is returned.
<DT>See Also:
<DD><TT> operator ==</TT>
</DL>
<H2 ID="Complex_operator_TLR"> Complex operator *() [Complex] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;complex.h&gt;</TT>
<BR><TT>Complex operator *( Complex const &amp;num1, Complex const &amp;num2 );</TT>
<BR><TT>Complex operator *( Complex const &amp;num1, double num2 );</TT>
<BR><TT>Complex operator *( double num1, Complex const &amp;num2 );</TT>
<DT>Semantics:
<DD>The<TT> operator *</TT> function is used to multiply<B> num1</B> by<B> num2</B> yielding a<TT> Complex</TT> object.
<BR><BR>The first<TT> operator *</TT> function multiplies two<TT> Complex</TT> objects.
<BR><BR>The second<TT> operator *</TT> function multiplies a<TT> Complex</TT> object and a floating-point value.&nbsp; In
effect, the real and imaginary components of the<TT> Complex</TT> object are multiplied by the floating-point value.
<BR><BR>The third<TT> operator *</TT> function multiplies a floating-point value and a<TT> Complex</TT> object.&nbsp; In effect,
the real and imaginary components of the<TT> Complex</TT> object are multiplied by the floating-point value.
<BR><BR>If the<TT> operator *</TT> function is used with a<TT> Complex</TT> object and an object of any other built-in numeric
type, the non-<TT> Complex</TT> object is converted to a<TT> double</TT> and the second or third form of the<TT> operator
*</TT> function is used.
<DT>Results:
<DD>The<TT> operator *</TT> function returns a<TT> Complex</TT> object that is the product of<B> num1</B> and<B> num2</B>.
<DT>See Also:
<DD><TT> operator +</TT>,<TT> operator -</TT>,<TT> operator /</TT>
<BR><BR><TT>Complex::operator *=</TT>
</DL>
<H2 ID="Complex__operator_TELR"> operator *=() [Complex] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;complex.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Complex &amp;Complex::operator *=( Complex const &amp;num );</TT>
<BR><TT> Complex &amp;Complex::operator *=( double num );</TT>
<DT>Semantics:
<DD>The<TT> operator *=</TT> public member function is used to multiply the<B> num</B> argument into the<TT> Complex</TT> object.
<BR><BR>The first form of the<TT> operator *=</TT> public member function multiplies the<TT> Complex</TT> object by the<TT>
Complex</TT> parameter.
<BR><BR>The second form of the<TT> operator *=</TT> public member function multiplies the real and imaginary components of
the<TT> Complex</TT> object by<B> num</B>.
<BR><BR>A call to the<TT> operator *=</TT> public member function where<B> num</B> is any of the other built-in numeric types,
causes<B> num</B> to be promoted to<TT> double</TT> and the second form of the<TT> operator *=</TT> public member function
to be used.
<DT>Results:
<DD>The<TT> operator *=</TT> public member function returns a reference to the target of the assignment.
<DT>See Also:
<DD><TT> operator *</TT>
<BR><BR><TT>Complex::operator +=</TT>,<TT> operator -=</TT>,<TT> operator /=</TT>,<TT> operator =</TT>
</DL>
<H2 ID="Complex__operator_PLR"> operator +() [Complex] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;complex.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Complex Complex::operator +();</TT>
<DT>Semantics:
<DD>The unary<TT> operator +</TT> public member function is provided for completeness.&nbsp; It performs no operation on the<TT>
Complex</TT> object.
<DT>Results:
<DD>The unary<TT> operator +</TT> public member function returns a<TT> Complex</TT> object with the same value as the original<TT>
Complex</TT> object.
<DT>See Also:
<DD><TT> operator +</TT>
<BR><BR><TT>Complex::operator +=</TT>,<TT> operator -</TT>
</DL>
<H2 ID="Complex_operator_PLR"> Complex operator +() [Complex] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;complex.h&gt;</TT>
<BR><TT>Complex operator +( Complex const &amp;num1, Complex const &amp;num2 );</TT>
<BR><TT>Complex operator +( Complex const &amp;num1, double num2 );</TT>
<BR><TT>Complex operator +( double num1, Complex const &amp;num2 );</TT>
<DT>Semantics:
<DD>The<TT> operator +</TT> function is used to add<B> num1</B> to<B> num2</B> yielding a<TT> Complex</TT> object.
<BR><BR>The first<TT> operator +</TT> function adds two<TT> Complex</TT> objects.
<BR><BR>The second<TT> operator +</TT> function adds a<TT> Complex</TT> object and a floating-point value.&nbsp; In effect,
the floating-point value is added to the real component of the<TT> Complex</TT> object.
<BR><BR>The third<TT> operator +</TT> function adds a floating-point value and a<TT> Complex</TT> object.&nbsp; In effect,
the floating-point value is added to the real component of the<TT> Complex</TT> object.
<BR><BR>If the<TT> operator +</TT> function is used with a<TT> Complex</TT> object and an object of any other built-in numeric
type, the non-<TT> Complex</TT> object is converted to a<TT> double</TT> and the second or third form of the<TT> operator
+</TT> function is used.
<DT>Results:
<DD>The<TT> operator +</TT> function returns a<TT> Complex</TT> object that is the sum of<B> num1</B> and<B> num2</B>.
<DT>See Also:
<DD><TT> operator *</TT>,<TT> operator -</TT>,<TT> operator /</TT>
<BR><BR><TT>Complex::operator +</TT>,<TT> operator +=</TT>
</DL>
<H2 ID="Complex__operator_PELR"> operator +=() [Complex] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;complex.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Complex &amp;Complex::operator +=( Complex const &amp;num );</TT>
<BR><TT> Complex &amp;Complex::operator +=( double num );</TT>
<DT>Semantics:
<DD>The<TT> operator +=</TT> public member function is used to add<B> num</B> to the value of the<TT> Complex</TT> object.&nbsp;
The second form of the<TT> operator +=</TT> public member function adds<B> num</B> to the real component of the<TT> Complex</TT>
object.
<BR><BR>A call to the<TT> operator +=</TT> public member function where<B> num</B> is any of the other built-in numeric types,
causes<B> num</B> to be promoted to<TT> double</TT> and the second form of the<TT> operator +=</TT> public member function
to be used.
<DT>Results:
<DD>The<TT> operator +=</TT> public member function returns a reference to the target of the assignment.
<DT>See Also:
<DD><TT> operator +</TT>
<BR><BR><TT>Complex::operator *=</TT>,<TT> operator +</TT>,<TT> operator /=</TT>,<TT> operator -=</TT>,<TT> operator =</TT>
</DL>
<H2 ID="Complex__operator_MLR"> operator -() [Complex] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;complex.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Complex Complex::operator -();</TT>
<DT>Semantics:
<DD>The unary<TT> operator -</TT> public member function yields a<TT> Complex</TT> object with the real and imaginary components
having the same magnitude as those of the original object, but with opposite sign.
<DT>Results:
<DD>The unary<TT> operator -</TT> public member function returns a<TT> Complex</TT> object with the same magnitude as the original<TT>
Complex</TT> object and with opposite sign.
<DT>See Also:
<DD><TT> operator -</TT>
<BR><BR><TT>Complex::operator +</TT>,<TT> operator -=</TT>
</DL>
<H2 ID="Complex_operator_MLR"> Complex operator -() [Complex] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;complex.h&gt;</TT>
<BR><TT>Complex operator -( Complex const &amp;num1, Complex const &amp;num2 );</TT>
<BR><TT>Complex operator -( Complex const &amp;num1, double num2 );</TT>
<BR><TT>Complex operator -( double num1, Complex const &amp;num2 );</TT>
<DT>Semantics:
<DD>The<TT> operator -</TT> function is used to subtract<B> num2</B> from<B> num1</B> yielding a<TT> Complex</TT> object.
<BR><BR>The first<TT> operator -</TT> function computes the difference between two<TT> Complex</TT> objects.
<BR><BR>The second<TT> operator -</TT> function computes the difference between a<TT> Complex</TT> object and a floating-point
value.&nbsp; In effect, the floating-point value is subtracted from the real component of the<TT> Complex</TT> object.
<BR><BR>The third<TT> operator -</TT> function computes the difference between a floating-point value and a<TT> Complex</TT>
object.&nbsp; In effect, the real component of the result is<B> num1</B> minus the real component of<B> num2</B> :CONT, and
the imaginary component of the result is the negative of the imaginary component of<B> num2</B>.
<BR><BR>If the<TT> operator -</TT> function is used with a<TT> Complex</TT> object and an object of any other built-in numeric
type, the non-<TT> Complex</TT> object is converted to a<TT> double</TT> and the second or third form of the<TT> operator
-</TT> function is used.
<DT>Results:
<DD>The<TT> operator -</TT> function returns a<TT> Complex</TT> object that is the difference between<B> num1</B> and<B> num2</B>.
<DT>See Also:
<DD><TT> operator *</TT>,<TT> operator +</TT>,<TT> operator /</TT>
<BR><BR><TT>Complex::operator -</TT>,<TT> operator -=</TT>
</DL>
<H2 ID="Complex__operator_MELR"> operator -=() [Complex] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;complex.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Complex &amp;Complex::operator -=( Complex const &amp;num );</TT>
<BR><TT> Complex &amp;Complex::operator -=( double num );</TT>
<DT>Semantics:
<DD>The<TT> operator -=</TT> public member function is used to subtract<B> num</B> from the value of the<TT> Complex</TT> object.
&nbsp;The second form of the<TT> operator -=</TT> public member function subtracts<B> num</B> from the real component of the
*obj..
<BR><BR>A call to the<TT> operator -=</TT> public member function where<B> num</B> is any of the other built-in numeric types,
causes<B> num</B> to be promoted to<TT> double</TT> and the second form of the<TT> operator -=</TT> public member function
to be used.
<DT>Results:
<DD>The<TT> operator -=</TT> public member function returns a reference to the target of the assignment.
<DT>See Also:
<DD><TT> operator -</TT>
<BR><BR><TT>Complex::operator *=</TT>,<TT> operator +=</TT>,<TT> operator -</TT>,<TT> operator /=</TT>,<TT> operator =</TT>
</DL>
<H2 ID="Complex_operator_DLR"> Complex operator /() [Complex] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;complex.h&gt;</TT>
<BR><TT>Complex operator /( Complex const &amp;num1, Complex const &amp;num2 );</TT>
<BR><TT>Complex operator /( Complex const &amp;num1, double num2 );</TT>
<BR><TT>Complex operator /( double num1, Complex const &amp;num2 );</TT>
<DT>Semantics:
<DD>The<TT> operator /</TT> function is used to divide<B> num1</B> by<B> num2</B> yielding a<TT> Complex</TT> object.
<BR><BR>The first<TT> operator /</TT> function divides two<TT> Complex</TT> objects.
<BR><BR>The second<TT> operator /</TT> function divides a<TT> Complex</TT> object by a floating-point value.&nbsp; In effect,
the real and imaginary components of the complex number are divided by the floating-point value.
<BR><BR>The third<TT> operator /</TT> function divides a floating-point value by a<TT> Complex</TT> object.&nbsp; Conceptually,
the floating-point value is converted to a<TT> Complex</TT> object and then the division is done.
<BR><BR>If the<TT> operator /</TT> function is used with a<TT> Complex</TT> object and an object of any other built-in numeric
type, the non-<TT> Complex</TT> object is converted to a<TT> double</TT> and the second or third form of the<TT> operator
/</TT> function is used.
<DT>Results:
<DD>The<TT> operator /</TT> function returns a<TT> Complex</TT> object that is the quotient of<B> num1</B> divided by<B> num2</B>.
<DT>See Also:
<DD><TT> operator *</TT>,<TT> operator +</TT>,<TT> operator -</TT>
<BR><BR><TT>Complex::operator /=</TT>
</DL>
<H2 ID="Complex__operator_DELR"> operator /=() [Complex] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;complex.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Complex &amp;Complex::operator /=( Complex const &amp;num );</TT>
<BR><TT> Complex &amp;Complex::operator /=( double num );</TT>
<DT>Semantics:
<DD>The<TT> operator /=</TT> public member function is used to divide the<TT> Complex</TT> object by<B> num</B>.&nbsp; The second
form of the<TT> operator /=</TT> public member function divides the real and imaginary components of the<TT> Complex</TT>
object by<B> num</B>.
<BR><BR>A call to the<TT> operator /=</TT> public member function where<B> num</B> is any of the other built-in numeric types,
causes<B> num</B> to be promoted to<TT> double</TT> and the second form of the<TT> operator /=</TT> public member function
to be used.
<DT>Results:
<DD>The<TT> operator /=</TT> public member function returns a reference to the target of the assignment.
<DT>See Also:
<DD><TT> operator /</TT>
<BR><BR><TT>Complex::operator *=</TT>,<TT> operator +=</TT>,<TT> operator -=</TT>,<TT> operator =</TT>
</DL>
<H2 ID="Complex_operator_XXLR"> Complex operator &lt;&lt;() [Complex] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;complex.h&gt;</TT>
<BR><TT>friend ostream &amp;operator &lt;&lt;( ostream &amp;strm, Complex &amp;num );</TT>
<DT>Semantics:
<DD>The<TT> operator &lt;&lt;</TT> function is used to write<TT> Complex</TT> objects to an I/O stream.&nbsp; The<TT> Complex</TT>
object is always written in the form:
<BR><BR><TT>(real,imag)</TT>
<BR><BR>The real and imaginary components are written using the normal rules for formatting floating-point numbers.&nbsp;
Any formatting options specified prior to inserting the<B> num</B> apply to both the real and imaginary components.&nbsp;
If the real and imaginary components are to be inserted using different formats, the<TT> real</TT> and<TT> imag</TT> member
functions should be used to insert each component separately.
<DT>Results:
<DD>The<TT> operator &lt;&lt;</TT> function returns a reference to the<B> strm</B> object.
<DT>See Also:
<DD><TT> istream</TT>
</DL>
<H2 ID="Complex__operator_ELR"> operator =() [Complex] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;complex.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Complex &amp;Complex::operator =( Complex const &amp;num );</TT>
<BR><TT> Complex &amp;Complex::operator =( double num );</TT>
<DT>Semantics:
<DD>The<TT> operator =</TT> public member function is used to set the value of the<TT> Complex</TT> object to<B> num</B>.&nbsp;
The first assignment operator copies the value of<B> num</B> into the<TT> Complex</TT> object.
<BR><BR>The second assignment operator sets the real component of the<TT> Complex</TT> object to<B> num</B> and the imaginary
component to zero.
<BR><BR>A call to the<TT> operator =</TT> public member function where<B> num</B> is any of the other built-in numeric types,
causes<B> num</B> to be promoted to<TT> double</TT> and the second form of the<TT> operator =</TT> public member function
to be used.
<DT>Results:
<DD>The<TT> operator =</TT> public member function returns a reference to the target of the assignment.
<DT>See Also:
<DD><TT> Complex::operator *=</TT>,<TT> operator +=</TT>,<TT> operator -=</TT>,<TT> operator /=</TT>
</DL>
<H2 ID="Complex_operator_EELR"> Complex operator ==() [Complex] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;complex.h&gt;</TT>
<BR><TT>int operator ==( Complex const &amp;num1, Complex const &amp;num2 );</TT>
<BR><TT>int operator ==( Complex const &amp;num1, double num2 );</TT>
<BR><TT>int operator ==( double num1, Complex const &amp;num2 );</TT>
<DT>Semantics:
<DD>The<TT> operator ==</TT> function compares<B> num1</B> and<B> num2</B> for equality.&nbsp; At least one of the arguments must
be a<TT> Complex</TT> object for this function to be called.
<BR><BR>Two<TT> Complex</TT> objects are equal if their corresponding real and imaginary components are equal.
<BR><BR>If the<TT> operator ==</TT> function is used with a<TT> Complex</TT> object and an object of any other built-in numeric
type, the non-<TT> Complex</TT> object is converted to a<TT> double</TT> and the second or third form of the<TT> operator
==</TT> function is used.
<DT>Results:
<DD>The<TT> operator ==</TT> function returns a non-zero value if<B> num1</B> is equal to<B> num2</B>, otherwise zero is returned.
<DT>See Also:
<DD><TT> operator !=</TT>
</DL>
<H2 ID="Complex_operator_YYLR"> Complex operator &gt;&gt;() [Complex] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;complex.h&gt;</TT>
<BR><TT>friend istream &amp;operator &gt;&gt;( istream &amp;strm, Complex &amp;num );</TT>
<DT>Semantics:
<DD>The<TT> operator &gt;&gt;</TT> function is used to read a<TT> Complex</TT> object from an I/O stream.&nbsp; A valid complex
value is of one of the following forms:
<BR><BR><TT>(real,imag)</TT>
<BR><BR><TT>real,imag</TT>
<BR><TT>(real)</TT>
<BR>If the imaginary portion is omitted, zero is assumed.
<BR><BR>While reading a<TT> Complex</TT> object, whitespace is ignored before and between the various components of the number
if the<TT> ios::skipws</TT> bit is set in<TT> ios::fmtflags</TT>.
<DT>Results:
<DD>The<TT> operator &gt;&gt;</TT> function returns a reference to<B> strm</B>.<B>&nbsp; num</B> contains the value read from<B>
strm</B> on success, otherwise it is unchanged.
<DT>See Also:
<DD><TT> istream</TT>
</DL>
<H2 ID="Complex_polarLR"> Complex polar() [Complex] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;complex.h&gt;</TT>
<BR><TT>Complex polar( double mag, double angle = 0.0 );</TT>
<DT>Semantics:
<DD>The<TT> polar</TT> function converts<B> mag</B> and<B> angle</B> (polar coordinates) into a complex number.&nbsp; The<B> angle</B>
is optional and defaults to zero if it is unspecified.
<DT>Results:
<DD>The<TT> polar</TT> function returns a<TT> Complex</TT> object that is<B> mag</B> and<B> angle</B> interpreted as polar coordinates.
<DT>See Also:
<DD><TT> abs</TT>,<TT> arg</TT>,<TT> norm</TT>
</DL>
<H2 ID="Complex_powLR"> Complex pow() [Complex] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;complex.h&gt;</TT>
<BR><TT>Complex pow( Complex const &amp;num, Complex const &amp;exp );</TT>
<BR><TT>Complex pow( Complex const &amp;num, double exp );</TT>
<BR><TT>Complex pow( double num, Complex const &amp;exp );</TT>
<BR><TT>Complex pow( Complex const &amp;num, int exp );</TT>
<DT>Semantics:
<DD>The<TT> pow</TT> function computes<B> num</B> raised to the power<B> exp</B>.&nbsp; The various forms are provided to minimize
the amount of floating-point calculation performed.
<DT>Results:
<DD>The<TT> pow</TT> function returns a<TT> Complex</TT> object that is<B> num</B> raised to the power a<TT> Complex</TT> object
that is<B> exp</B>.
<DT>See Also:
<DD><TT> exp</TT>,<TT> log</TT>,<TT> log10</TT>,<TT> sqrt</TT>
</DL>
<H2 ID="Complex__realLR"> real() [Complex] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;complex.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>double Complex::real();</TT>
<DT>Semantics:
<DD>The<TT> real</TT> public member function extracts the real component of the<TT> Complex</TT> object.
<DT>Results:
<DD>The<TT> real</TT> public member function returns the real component of the<TT> Complex</TT> object.
<DT>See Also:
<DD><TT> imag</TT>,<TT> real</TT>
<BR><BR><TT>Complex::imag</TT>
</DL>
<H2 ID="Complex_realLR"> Complex real() [Complex] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;complex.h&gt;</TT>
<BR><TT>double real( Complex const &amp;num );</TT>
<DT>Semantics:
<DD>The<TT> real</TT> function extracts the real component of<B> num</B>.
<DT>Results:
<DD>The<TT> real</TT> function returns the real component of<B> num</B>.
<DT>See Also:
<DD><TT> imag</TT>
<BR><BR><TT>Complex::imag</TT>,<TT> real</TT>
</DL>
<H2 ID="Complex_sinLR"> Complex sin() [Complex] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;complex.h&gt;</TT>
<BR><TT>Complex sin( Complex const &amp;num );</TT>
<DT>Semantics:
<DD>The<TT> sin</TT> function computes the sine of<B> num</B>.
<DT>Results:
<DD>The<TT> sin</TT> function returns the sine of<B> num</B>.
<DT>See Also:
<DD><TT> asin</TT>,<TT> cos</TT>,<TT> tan</TT>
</DL>
<H2 ID="Complex_sinhLR"> Complex sinh() [Complex] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;complex.h&gt;</TT>
<BR><TT>Complex sinh( Complex const &amp;num );</TT>
<DT>Semantics:
<DD>The<TT> sinh</TT> function computes the hyperbolic sine of<B> num</B>.
<DT>Results:
<DD>The<TT> sinh</TT> function returns the hyperbolic sine of<B> num</B>.
<DT>See Also:
<DD><TT> asinh</TT>,<TT> cosh</TT>,<TT> tanh</TT>
</DL>
<H2 ID="Complex_sqrtLR"> Complex sqrt() [Complex] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;complex.h&gt;</TT>
<BR><TT>Complex sqrt( Complex const &amp;num );</TT>
<DT>Semantics:
<DD>The<TT> sqrt</TT> function computes the square root of<B> num</B>.
<DT>Results:
<DD>The<TT> sqrt</TT> function returns the square root of<B> num</B>.
<DT>See Also:
<DD><TT> exp</TT>,<TT> log</TT>,<TT> log10</TT>,<TT> pow</TT>
</DL>
<H2 ID="Complex_tanLR"> Complex tan() [Complex] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;complex.h&gt;</TT>
<BR><TT>Complex tan( Complex const &amp;num );</TT>
<DT>Semantics:
<DD>The<TT> tan</TT> function computes the tangent of<B> num</B>.
<DT>Results:
<DD>The<TT> tan</TT> function returns the tangent of<B> num</B>.
<DT>See Also:
<DD><TT> atan</TT>,<TT> cos</TT>,<TT> sin</TT>
</DL>
<H2 ID="Complex_tanhLR"> Complex tanh() [Complex] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;complex.h&gt;</TT>
<BR><TT>Complex tanh( Complex const &amp;num );</TT>
<DT>Semantics:
<DD>The<TT> tanh</TT> function computes the hyperbolic tangent of<B> num</B>.
<DT>Results:
<DD>The<TT> tanh</TT> function returns the hyperbolic tangent of<B> num</B>.
<DT>See Also:
<DD><TT> atanh</TT>,<TT> cosh</TT>,<TT> sinh</TT>
</DL>
<H1 ID="Container_Exception_Classes"> Container Exception Classes </H1>
<BR>This chapter describes exception handling for the container classes.
<H2 ID="WCExcept_Class_Description"> WCExcept Class Description </H2>
<DL>
<DT>Declared:
<DD><TT> wcexcept.h</TT>
<BR><BR>The<TT> WCExcept</TT> class provides the exception handling for the container classes.&nbsp; If you have compiled
your code with exception handling enabled, the C++ exception processing can be used to catch errors.&nbsp; Your source file
must be compiled with the exception handling compile switch for C++ exception processing to occur.&nbsp; The container classes
will attempt to set the container object into a reasonable state if there is an error and exception handling is not enabled,
or if the trap for the specific error has not been enabled by your program.
<BR>By default, no exception traps are enabled and no exceptions will be thrown.&nbsp; Exception traps are enabled by setting
the exception state with the<TT> exceptions</TT> member function.
<BR><BR>The<TT> wcexcept.h</TT> header file is included by the header files for each of the container classes.&nbsp; There
is normally no need to explicitly include the<TT> wcexcept.h</TT> header file, but no errors will result if it is included.
&nbsp;This class is inherited as a base class for each of the containers.&nbsp; You do not need to derive from it directly.
<BR><BR>The<TT> WCListExcept</TT> class (formally used by the list container classes) has been replaced by the<TT> WCExcept</TT>
class.&nbsp; A typedef of the<TT> WCListExcept</TT> class to the<TT> WCExcept</TT> class and the<TT> wclist_state</TT> type
to the<TT> wc_state</TT> type provide backward compatability with previous versions of the list containers.
<BR><BR><B>Public Enumerations</B>
<BR><BR>The following enumeration typedefs are declared in the public interface:
<BR><BR><TT>typedef int wc_state;</TT>
<BR><BR><B>Public Member Functions</B>
<BR><BR>The following public member functions are declared:
<BR><BR><TT>WCExcept();</TT>
<BR><TT> virtual ~WCExcept();</TT>
<BR><TT> wc_state exceptions() const;</TT>
<BR><TT> wc_state exceptions( wc_state );</TT>
</DL>
<H2 ID="WCExcept__WCExceptLR"> WCExcept() [WCExcept] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcexcept.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCExcept();</TT>
<DT>Semantics:
<DD>This form of the public<TT> WCExcept</TT> constructor creates an<TT> WCExcept</TT> object.
<BR><BR>The public<TT> WCExcept</TT> constructor is used implicitly by the compiler when it generates a constructor for a
derived class.&nbsp; It is automatically used by the list container classes, and should not be required in any user derived
classes.
<DT>Results:
<DD>The public<TT> WCExcept</TT> constructor produces an initialized<TT> WCExcept</TT> object with no exception traps enabled.
<DT>See Also:
<DD><TT> ~WCExcept</TT>
</DL>
<H2 ID="WCExcept____WCExceptLR"> ~WCExcept() [WCExcept] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcexcept.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>virtual ~WCExcept();</TT>
<DT>Semantics:
<DD>The public<TT> ~WCExcept</TT> destructor does not do anything explicit.&nbsp; The call to the public<TT> ~WCExcept</TT> destructor
is inserted implicitly by the compiler at the point where the object derived from<TT> WCExcept</TT> goes out of scope.
<DT>Results:
<DD>The object derived from<TT> WCExcept</TT> is destroyed.
<DT>See Also:
<DD><TT> WCExcept</TT>
</DL>
<H2 ID="WCExcept__exceptionsLR"> exceptions() [WCExcept] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcexcept.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>wc_state exceptions() const;</TT>
<BR><TT> wc_state exceptions( wc_state set_flags );</TT>
<DT>Semantics:
<DD>The<TT> exceptions</TT> public member function queries and/or sets the bits that control which exceptions are enabled for
the list class.&nbsp; Each bit corresponds to an exception, and is set if the exception is enabled.&nbsp; The first form of
the<TT> exceptions</TT> public member function returns the current settings of the exception bits.&nbsp; The second form of
the function sets the exception bits to those specified by<B> set_flags</B>.
<DT>Results:
<DD>The current exception bits are returned.&nbsp; If a new set of bits are being set, the returned value is the old set of exception
bits.
</DL>
<H2 ID="WCExcept__wc_state"> wc_state [WCExcept] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcexcept.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>enum wcstate {</TT>
<BR><TT>all_fine = 0x0000, // - no errors</TT>
<BR><TT> check_none = all_fine,// - throw no exceptions</TT>
<BR><TT> not_empty = 0x0001, // - container not empty</TT>
<BR><TT> index_range = 0x0002, // - index is out of range</TT>
<BR><TT> empty_container= 0x0004, // - empty container error</TT>
<BR><TT> out_of_memory = 0x0008, // - allocation failed</TT>
<BR><TT> resize_required= 0x0010, // - request needs resize</TT>
<BR><TT> not_unique = 0x0020, // - adding duplicate</TT>
<BR><TT> zero_buckets = 0x0040, // - resizing hash to zero</TT>
<BR><TT> // value to use to check for all errors</TT>
<BR><TT>check_all = (not_empty|index_range|empty_container</TT>
<BR><TT> |out_of_memory|resize_required</TT>
<BR><TT>|not_unique|zero_buckets)</TT>
<BR><TT>};</TT>
<BR><TT>typedef int wc_state;</TT>
<DT>Semantics:
<DD>The type<TT> WCExcept::wcstate</TT> is a set of bits representing the current state of the container object.&nbsp; The<TT>
WCExcept::wc_state</TT> member typedef represents the same set of bits, but uses an<TT> int</TT> to represent the values,
thereby avoiding problems made possible by the compiler's ability to use smaller types for enumerations.&nbsp; All uses of
these bits should use the<TT> WCExcept::wc_state</TT> member typedef.
<BR><BR>The bit values defined by the<TT> WCExcept::wc_state</TT> member typedef can be read and set by the<TT> exceptions</TT>
member function, which is also used to control exception handling.
<BR><BR>The<TT> WCExcept::not_empty</TT> bit setting traps the destruction of a container when the container has at one or
more entries.&nbsp; If this error is not trapped, memory may not be properly released back to the system.
<BR><BR>The<TT> WCExcept::index_range</TT> state setting traps an attempt to access a container item by an index value that
is either not positive or is larger than the index of the last item in the container.
<BR><BR>The<TT> WCExcept::empty_container</TT> bit setting traps an attempt to perform and invalid operation on a container
with no entries.
<BR><BR>The<TT> WCExcept::out_of_memory</TT> bit setting traps any container class allocation failures.&nbsp; If this exception
is not enabled, the operation in which the allocation failed will return a FALSE (zero) value.&nbsp; Container class copy
constructors and assignment operators can also throw this exception, and if not enabled incomplete copies may result.
<BR><BR>The<TT> WCExcept::resize_required</TT> bit setting traps any vector operations which cannot be performed unless the
vector is resized to a larger size.&nbsp; If this exception is not enabled, the vector class will attempt an appropriate resize
when necessary for an operation.
<BR><BR>The<TT> WCExcept::not_unique</TT> bit setting traps an attempt to add a duplicate value to a set container, or a duplicate
key to a dictionary container.&nbsp; The duplicate value is not added to the container object regardless of the exception
trap state.
<BR><BR>The<TT> WCExcept::zero_buckets</TT> bit setting traps an attempt to resize of hash container to have zero buckets.
&nbsp;No resize is performed whether or not the exception is enabled.
</DL>
<H2 ID="WCIterExcept_Class_Description"> WCIterExcept Class Description </H2>
<DL>
<DT>Declared:
<DD><TT> wcexcept.h</TT>
<BR><BR>The<TT> WCIterExcept</TT> class provides the exception handling for the container iterators.&nbsp; If you have compiled
your code with exception handling enabled, the C++ exception processing can be used to catch errors.&nbsp; Your source file
must be compiled with the exception handling compile switch for C++ exception processing to occur.&nbsp; The iterators will
attempt to set the class into a reasonable state if there is an error and exception handling is not enabled, or if the trap
for the specific error has not been enabled by your program.
<BR>By default, no exception traps are enabled and no exceptions will be thrown.&nbsp; Exception traps are enabled by setting
the exception state with the<TT> exceptions</TT> member function.
<BR><BR>The<TT> wcexcept.h</TT> header file is included by the header files for each of the iterator classes.&nbsp; There
is normally no need to explicitly include the<TT> wcexcept.h</TT> header file, but no errors will result if it is included.
&nbsp;This class is inherited as part of the base construction for each of the iterators.&nbsp; You do not need to derive
from it directly.
<BR><BR><B>Public Enumerations</B>
<BR><BR>The following enumeration typedefs are declared in the public interface:
<BR><BR><TT>typedef int wciter_state;</TT>
<BR><BR><B>Public Member Functions</B>
<BR><BR>The following public member functions are declared:
<BR><BR><TT>WCIterExcept();</TT>
<BR><TT> virtual ~WCIterExcept();</TT>
<BR><TT> wciter_state exceptions() const;</TT>
<BR><TT> wciter_state exceptions( wciter_state );</TT>
</DL>
<H2 ID="WCIterExcept__WCIterExceptLR"> WCIterExcept() [WCIterExcept] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcexcept.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCIterExcept();</TT>
<DT>Semantics:
<DD>This form of the public<TT> WCIterExcept</TT> constructor creates an<TT> WCIterExcept</TT> object.
<BR><BR>The public<TT> WCIterExcept</TT> constructor is used implicitly by the compiler when it generates a constructor for
a derived class.
<DT>Results:
<DD>The public<TT> WCIterExcept</TT> constructor produces an initialized<TT> WCIterExcept</TT> object with no exception traps
enabled.
<DT>See Also:
<DD><TT> ~WCIterExcept</TT>
</DL>
<H2 ID="WCIterExcept____WCIterExceptLR"> ~WCIterExcept() [WCIterExcept] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcexcept.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>virtual ~WCIterExcept();</TT>
<DT>Semantics:
<DD>The public<TT> ~WCIterExcept</TT> destructor does not do anything explicit.&nbsp; The call to the public<TT> ~WCIterExcept</TT>
destructor is inserted implicitly by the compiler at the point where the object derived from<TT> WCIterExcept</TT> goes out
of scope.
<DT>Results:
<DD>The object derived from<TT> WCIterExcept</TT> is destroyed.
<DT>See Also:
<DD><TT> WCIterExcept</TT>
</DL>
<H2 ID="WCIterExcept__exceptionsLR"> exceptions() [WCIterExcept] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcexcept.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>wciter_state exceptions() const;</TT>
<BR><TT> wciter_state exceptions( wciter_state set_flags );</TT>
<DT>Semantics:
<DD>The<TT> exceptions</TT> public member function queries and/or sets the bits that control which exceptions are enabled for
the iterator class.&nbsp; Each bit corresponds to an exception, and is set if the exception is enabled.&nbsp; The first form
of the<TT> exceptions</TT> public member function returns the current settings of the exception bits.&nbsp; The second form
of the function sets the exception bits to those specified by<B> set_flags</B>.
<DT>Results:
<DD>The current exception bits are returned.&nbsp; If a new set of bits are being set, the returned value is the old set of exception
bits.
</DL>
<H2 ID="WCIterExcept__wciter_state"> wciter_state [WCIterExcept] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcexcept.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>enum wciterstate {</TT>
<BR><TT>all_fine = 0x0000, // - no errors</TT>
<BR><TT> check_none = all_fine,// - disable all exceptions</TT>
<BR><TT> undef_iter = 0x0001, // - position is undefined</TT>
<BR><TT> undef_item = 0x0002, // - iterator item is undefined</TT>
<BR><TT> iter_range = 0x0004, // - advance value is bad</TT>
<BR><TT> // value to use to check for all errors</TT>
<BR><TT>check_all= (undef_iter|undef_item|iter_range)</TT>
<BR><TT> };</TT>
<BR><TT>typedef int wciter_state;</TT>
<DT>Semantics:
<DD>The type<TT> WCIterExcept::wciterstate</TT> is a set of bits representing the current state of the iterator.&nbsp; The<TT>
WCIterExcept::wciter_state</TT> member typedef represents the same set of bits, but uses an<TT> int</TT> to represent the
values, thereby avoiding problems made possible by the compiler's ability to use smaller types for enumerations.&nbsp; All
uses of these bits should use the<TT> WCIterExcept::wciter_state</TT> member typedef.
<BR><BR>The bit values defined by the<TT> WCIterExcept::wciter_state</TT> member typedef can be read and set by the member
function<TT> exceptions</TT>, which is used to control exception handling.
<BR><BR>The<TT> WCIterExcept::undef_iter</TT> bit setting traps the use of the iterator when the position within the container
object is undefined.&nbsp; Trying to operate on an iterator with no associated container object, increment an iterator which
is after the last element, or decrement an iterator positioned before the first element is an undefined operation.
<BR><BR>The<TT> WCIterExcept::undef_item</TT> bit setting traps an attempt to obtain the current element of the iterator when
the iterator has no associated container object, or is positioned either before or after the container elements.&nbsp; The<TT>
undef_item</TT> exception can be thrown only by the<TT> key</TT> and<TT> value</TT> dictionary iterator member functions,
and the<TT> current</TT> member function for non-dictionary iterators.
<BR><BR>The<TT> WCIterExcept::iter_range</TT> bit setting traps an attempt to use a iteration count value that would place
the iterator more than one element past the end or before the beginning of the container elements.&nbsp; The<TT> iter_range</TT>
exception can be thrown only by the<TT> operator +=</TT> and<TT> operator -=</TT> operators.
</DL>
<H1 ID="Container_Allocators_and_Deallocators"> Container Allocators and Deallocators </H1>
<BR><B>Example</B>
<BR><BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>#include &lt;wcskipit.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>#pragma warning 549 9</TT>
<BR><BR><TT>const int ElemsPerBlock = 50;</TT>
<BR><BR><TT>//</TT>
<BR><TT>// Simple block allocation class.&nbsp; Allocate blocks for ElemsPerBlock</TT>
<BR><TT>// elements, and use part of the block for each of the next ElemsPerBlock</TT>
<BR><TT>// allocations, incrementing the number allocated elements.&nbsp; Repeat getting</TT>
<BR><TT>// more blocks as needed.</TT>
<BR><TT>//</TT>
<BR><TT>// Store the blocks in an intrusive single linked list.</TT>
<BR><TT>//</TT>
<BR><TT>// On a element deallocation, assume we allocated the memory and just</TT>
<BR><TT>// decrement the count of allocated elements.&nbsp; When the count gets to zero,</TT>
<BR><TT>// free all allocated blocks</TT>
<BR><TT>//</TT>
<BR><TT>// This implementation assumes sizeof( char ) == 1</TT>
<BR><TT>//</TT>
<BR><BR><TT>class BlockAlloc {</TT>
<BR><TT>private:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; // the size of elements (in bytes)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned elem_size;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; // number of elements allocated</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned num_allocated;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; // free space of this number of elements available in first block</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned num_free_in_block;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; // list of blocks used to store elements (block are chunks of memory,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; // pointed by (char *) pointers.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; WCPtrSList&lt;char&gt; block_list;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; // pointer to the first block in the list</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char *curr_block;</TT>
<BR><BR><TT>public:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; inline BlockAlloc( unsigned size )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : elem_size( size ), num_allocated(
0 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; , num_free_in_block( 0
) {};</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; inline BlockAlloc() {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; block_list.clearAndDestroy();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; // get memory for an element using block allocation</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; void *allocator( size_t elem_size );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; // free memory for an element using block allocation and deallocation</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; void deallocator( void *old_ptr, size_t elem_size );</TT>
<BR><TT>};</TT>
<BR><BR><TT>void *BlockAlloc::allocator( size_t size ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; // need a new block to perform allocation</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( num_free_in_block == 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // allocate memory for ElemsPerBlock elements</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; curr_block = new char [size * ElemsPerBlock];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( curr_block == 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // allocation failed</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( 0 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // add new block to beginning of list</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( !block_list.insert( curr_block ) ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // allocation of list element failed</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete[] curr_block;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( 0 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; num_free_in_block = ElemsPerBlock;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; // curr block points to a block of memory with some free memory</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; num_allocated++;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; num_free_in_block--;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; // return pointer to a free part of the block, starting at the end</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; // of the block</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; return( curr_block + num_free_in_block * size );</TT>
<BR><TT>}</TT>
<BR><BR><TT>void BlockAlloc::deallocator( void *, size_t ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; // just decrement the count</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; // don't free anything until all elements are deallocated</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; num_allocated--;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( num_allocated == 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // all the elements allocated BlockAlloc object have now been</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // deallocated, free all the blocks</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; block_list.clearAndDestroy();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; num_free_in_block = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
<BR><BR><TT>const unsigned NumTestElems = 200;</TT>
<BR><BR><TT>// array with random elements</TT>
<BR><TT>static unsigned test_elems[ NumTestElems ];</TT>
<BR><BR><TT>static void fill_test_elems() {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( int i = 0; i &lt; NumTestElems; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; test_elems[ i ] = rand();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
<BR><BR><TT>void test_isv_list();</TT>
<BR><TT>void test_val_list();</TT>
<BR><TT>void test_val_skip_list();</TT>
<BR><BR><TT>void main() {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fill_test_elems();</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; test_isv_list();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; test_val_list();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; test_val_skip_list();</TT>
<BR><TT>}</TT>
<BR><BR><TT>// An intrusive list class</TT>
<BR><BR><TT>class isvInt : public WCSLink {</TT>
<BR><TT>public:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; static BlockAlloc memory_manage;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int data;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; isvInt( int datum ) : data( datum ) {};</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; void *operator new( size_t size ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( memory_manage.allocator( size ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; void operator delete( void *old, size_t size ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memory_manage.deallocator( old, size );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>};</TT>
<BR><BR><TT>// define static member data</TT>
<BR><TT>BlockAlloc isvInt::memory_manage( sizeof( isvInt ) );</TT>
<BR><BR><TT>void test_isv_list() {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; WCIsvSList&lt;isvInt&gt; list;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; for( int i = 0; i &lt; NumTestElems; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; list.insert( new isvInt( test_elems[ i ] ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; WCIsvSListIter&lt;isvInt&gt; iter( list );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; while( ++iter ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; iter.current()-&gt;data &lt;&lt; &quot; &quot;;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; cout &lt;&lt; &quot;\n\n\n&quot;;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; list.clearAndDestroy();</TT>
<BR><TT>}</TT>
<BR><BR><TT>// WCValSList&lt;int&gt; memory allocator/dealloctor support</TT>
<BR><TT>static BlockAlloc val_list_manager( WCValSListItemSize( int ) );</TT>
<BR><BR><TT>static void *val_list_alloc( size_t size ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; return( val_list_manager.allocator( size ) );</TT>
<BR><TT>}</TT>
<BR><BR><TT>static void val_list_dealloc( void *old, size_t size ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; val_list_manager.deallocator( old, size );</TT>
<BR><TT>}</TT>
<BR><BR><TT>// test WCValSList&lt;int&gt;</TT>
<BR><TT>void test_val_list() {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; WCValSList&lt;int&gt; list( &amp;val_list_alloc, &amp;val_list_dealloc );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; for( int i = 0; i &lt; NumTestElems; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; list.insert( test_elems[ i ] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; WCValSListIter&lt;int&gt; iter( list );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; while( ++iter ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; iter.current() &lt;&lt; &quot; &quot;;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; cout &lt;&lt; &quot;\n\n\n&quot;;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; list.clear();</TT>
<BR><TT>}</TT>
<BR><BR><TT>// skip list allocator dealloctors: just use allocator and dealloctor</TT>
<BR><TT>// functions on skip list elements with one and two pointers</TT>
<BR><TT>// (this will handle 94% of the elements)</TT>
<BR><TT>const int one_ptr_size = WCValSkipListItemSize( int, 1 );</TT>
<BR><TT>const int two_ptr_size = WCValSkipListItemSize( int, 2 );</TT>
<BR><BR><TT>static BlockAlloc one_ptr_manager( one_ptr_size );</TT>
<BR><TT>static BlockAlloc two_ptr_manager( two_ptr_size );</TT>
<BR><BR><TT>static void *val_skip_list_alloc( size_t size ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; switch( size ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; case one_ptr_size:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( one_ptr_manager.allocator( size ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; case two_ptr_size:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( two_ptr_manager.allocator( size ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; default:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( new char[ size ] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
<BR><BR><TT>static void val_skip_list_dealloc( void *old, size_t size ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; switch( size ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; case one_ptr_size:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; one_ptr_manager.deallocator( old, size );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; case two_ptr_size:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; two_ptr_manager.deallocator( old, size );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; default:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete old;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
<BR><BR><TT>// test WCValSkipList&lt;int&gt;</TT>
<BR><TT>void test_val_skip_list() {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; WCValSkipList&lt;int&gt; skiplist( WCSKIPLIST_PROB_QUARTER</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; , WCDEFAULT_SKIPLIST_MAX_PTRS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; , &amp;val_skip_list_alloc</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; , &amp;val_skip_list_dealloc );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; for( int i = 0; i &lt; NumTestElems; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; skiplist.insert( test_elems[ i ] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; WCValSkipListIter&lt;int&gt; iter( skiplist );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; while( ++iter ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; iter.current() &lt;&lt; &quot; &quot;;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; cout &lt;&lt; &quot;\n\n\n&quot;;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; skiplist.clear();</TT>
<BR><TT>}</TT>
<H1 ID="Hash_Containers"> Hash Containers </H1>
<BR>This chapter describes hash containers.
<H2 ID="WCPtrHashDictXKey_ValueY_Class_Description"> WCPtrHashDict&lt;Key,Value&gt; Class Description </H2>
<DL>
<DT>Declared:
<DD><TT> wchash.h</TT>
<BR><BR>The<TT> WCPtrHashDict&lt;Key,Value&gt;</TT> class is a templated class used to store objects in a dictionary.&nbsp;
Dictionaries store values with an associated key, which may be of any type.&nbsp; One example of a dictionary used in everyday
life is the phone book.&nbsp; The phone numbers are the data values, and the customer name is the key.&nbsp; An example of
a specialized dictionary is a vector, where the key value is the integer index.
<BR>As an element is looked up or inserted into the dictionary, the associated key is hashed.&nbsp; Hashing converts the key
into a numeric index value which is used to locate the value.&nbsp; The storage area referenced by the hash value is usually
called a bucket.&nbsp; If more than one key results in the same hash, the values associated with the keys are placed in a
list stored in the bucket.&nbsp; The equality operator of the key's type is used to locate the key-value pairs.
<BR><BR>In the description of each member function, the text<TT> Key</TT> is used to indicate the template parameter defining
the type of the indices pointed to by the pointers stored in the dictionary.&nbsp; The text<TT> Value</TT> is used to indicate
the template parameter defining the type of the data pointed to by the pointers stored in the dictionary.
<BR><BR>The constructor for the<TT> WCPtrHashDict&lt;Key,Value&gt;</TT> class requires a hashing function, which given a reference
to<TT> Key,</TT> returns an<TT> unsigned</TT> value.&nbsp; The returned value modulo the number of buckets determines the
bucket into which the key-value pair will be located.&nbsp; The return values of the hash function can be spread over the
entire range of unsigned numbers.&nbsp; The hash function return value must be the same for values which are equivalent by
the equivalence operator for<TT> Key.</TT>
<BR><BR>Note that pointers to the key values are stored in the dictionary.&nbsp; Destructors are not called on the keys pointed
to.&nbsp; The key values pointed to in the dictionary should not be changed such that the equivalence to the old value is
modified.
<BR><BR>The<TT> WCExcept</TT> class is a base class of the<TT> WCPtrHashDict&lt;Key,Value&gt;</TT> class and provides the<TT>
exceptions</TT> member function.&nbsp; This member function controls the exceptions which can be thrown by the<TT> WCPtrHashDict&lt;Key,Value&gt;</TT>
object.&nbsp; No exceptions are enabled unless they are set by the<TT> exceptions</TT> member function.
<BR><BR><B>Requirements of Key</B>
<BR><BR>The<TT> WCPtrHashDict&lt;Key,Value&gt;</TT> class requires<TT> Key</TT> to have:
<BR>A well defined equivalence operator with constant parameters
<BR><BR>(<TT> int operator ==( const Key &amp; ) const</TT> ).
<BR><BR><B>Public Member Functions</B>
<BR><BR>The following member functions are declared in the public interface:
<BR><BR><TT>WCPtrHashDict( unsigned (*hash_fn)( const Key &amp; ), unsigned = WC_DEFAULT_HASH_SIZE );</TT>
<BR><TT> WCPtrHashDict( unsigned (*hash_fn)( const Key &amp; ), unsigned = WC_DEFAULT_HASH_SIZE, void * (*user_alloc)( size_t
size ), void (*user_dealloc)( void *old, size_t size ) );</TT>
<BR><TT> WCPtrHashDict( const WCPtrHashDict &amp; );</TT>
<BR><TT> virtual ~WCPtrHashDict();</TT>
<BR><TT> static unsigned bitHash( const void *, size_t );</TT>
<BR><TT> unsigned buckets() const;</TT>
<BR><TT> void clear();</TT>
<BR><TT> void clearAndDestroy();</TT>
<BR><TT> int contains( const Key * ) const;</TT>
<BR><TT> unsigned entries() const;</TT>
<BR><TT> Value * find( const Key * ) const;</TT>
<BR><TT> Value * findKeyAndValue( const Key *, Key * &amp; ) const;</TT>
<BR><TT> void forAll( void (*user_fn)( Key *, Value *, void * ) , void * );</TT>
<BR><TT> int insert( Key *, Value * );</TT>
<BR><TT> int isEmpty() const;</TT>
<BR><TT> Value * remove( const Key * );</TT>
<BR><TT> void resize( unsigned );</TT>
<BR><BR><B>Public Member Operators</B>
<BR><BR>The following member operators are declared in the public interface:
<BR><BR><TT>Value * &amp; operator []( const Key &amp; );</TT>
<BR><TT> const Value * &amp; operator []( const Key &amp; ) const;</TT>
<BR><TT> WCPtrHashDict &amp; operator =( const WCPtrHashDict &amp; );</TT>
<BR><TT> int operator ==( const WCPtrHashDict &amp; ) const;</TT>
</DL>
<H2 ID="WCPtrHashDictXKey_ValueY__WCPtrHashDictLR"> WCPtrHashDict() [WCPtrHashDict&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCPtrHashDict( unsigned (*hash_fn)( const Key &amp; ),</TT>
<BR><TT> unsigned = WC_DEFAULT_HASH_SIZE );</TT>
<DT>Semantics:
<DD>The public<TT> WCPtrHashDict&lt;Key,Value&gt;</TT> constructor creates an<TT> WCPtrHashDict&lt;Key,Value&gt;</TT> object with
no entries and with the number of buckets in the second optional parameter, which defaults to the constant<TT> WC_DEFAULT_HASH_SIZE</TT>
(currently defined as 101).&nbsp; The number of buckets specified must be greater than zero, and will be forced to at least
one.&nbsp; If the hash dictionary object can be created, but an allocation failure occurs when creating the buckets, the table
will be created with zero buckets.&nbsp; If the<TT> out_of_memory</TT> exception is enabled, then attempting to insert into
a hash table with zero buckets with throw an<TT> out_of_memory</TT> error.
<BR><BR>The hash function<TT> hash_fn</TT> is used to determine which bucket each key-value pair will be assigned.&nbsp; If
no hash function exists, the static member function<TT> bitHash</TT> is available to help create one.
<DT>Results:
<DD>The public<TT> WCPtrHashDict&lt;Key,Value&gt;</TT> constructor creates an initialized<TT> WCPtrHashDict&lt;Key,Value&gt;</TT>
object with the specified number of buckets and hash function.
<DT>See Also:
<DD><TT> ~WCPtrHashDict</TT>,<TT> bitHash</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCPtrHashDict( unsigned (*hash_fn)( const Key &amp; ),</TT>
<BR><TT> unsigned = WC_DEFAULT_HASH_SIZE,</TT>
<BR><TT>void * (*user_alloc)( size_t ),</TT>
<BR><TT>void (*user_dealloc)( void *, size_t ) );</TT>
<DT>Semantics:
<DD>Allocator and deallocator functions are specified for use when entries are inserted and removed from the hash dictionary.
&nbsp;The semantics of this constructor are the same as the constructor without the memory management functions.
<BR><BR>The allocation function must return a zero if it cannot perform the allocation.&nbsp; The deallocation function is
passed the size as well as the pointer to the data.&nbsp; Your allocation system may take advantage of the characteristic
that the allocation function will always be called with the same size value for any particular instantiation of a hash dictionary.
&nbsp;To determine the size of the objects that the memory management functions will be required to allocate and free, the
following macro may be used:
<BR><BR><TT>WCPtrHashDictItemSize( Key, Value )</TT>
<DT>Results:
<DD>The public<TT> WCPtrHashDict&lt;Key,Value&gt;</TT> constructor creates an initialized<TT> WCPtrHashDict&lt;Key,Value&gt;</TT>
object with the specified number of buckets and hash function.
<DT>See Also:
<DD><TT> ~WCPtrHashDict</TT>,<TT> bitHash</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCPtrHashDict( const WCPtrHashDict &amp; );</TT>
<DT>Semantics:
<DD>The public<TT> WCPtrHashDict&lt;Key,Value&gt;</TT> constructor is the copy constructor for the<TT> WCPtrHashDict&lt;Key,Value&gt;</TT>
class.&nbsp; The new dictionary is created with the same number of buckets, hash function, all values or pointers stored in
the dictionary, and the exception trap states.&nbsp; If the hash dictionary object can be created, but an allocation failure
occurs when creating the buckets, the table will be created with zero buckets.&nbsp; If there is not enough memory to copy
all of the values in the dictionary, then only some will be copied, and the number of entries will correctly reflect the number
copied.&nbsp; If all of the elements cannot be copied, then the<TT> out_of_memory</TT> exception is thrown if it is enabled.
<DT>Results:
<DD>The public<TT> WCPtrHashDict&lt;Key,Value&gt;</TT> constructor creates an<TT> WCPtrHashDict&lt;Key,Value&gt;</TT> object which
is a copy of the passed dictionary.
<DT>See Also:
<DD><TT> ~WCPtrHashDict</TT>,<TT> operator =</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<H2 ID="WCPtrHashDictXKey_ValueY____WCPtrHashDictLR"> ~WCPtrHashDict() [WCPtrHashDict&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>virtual ~WCPtrHashDict();</TT>
<DT>Semantics:
<DD>The public<TT> ~WCPtrHashDict&lt;Key,Value&gt;</TT> destructor is the destructor for the<TT> WCPtrHashDict&lt;Key,Value&gt;</TT>
class.&nbsp; If the number of dictionary elements is not zero and the<TT> not_empty</TT> exception is enabled, the exception
is thrown.&nbsp; Otherwise, the dictionary elements are cleared using the<TT> clear</TT> member function.&nbsp; The objects
which the dictionary elements point to are not deleted unless the<TT> clearAndDestroy</TT> member function is explicitly called
before the destructor is called.&nbsp; The call to the public<TT> ~WCPtrHashDict&lt;Key,Value&gt;</TT> destructor is inserted
implicitly by the compiler at the point where the<TT> WCPtrHashDict&lt;Key,Value&gt;</TT> object goes out of scope.
<DT>Results:
<DD>The public<TT> ~WCPtrHashDict&lt;Key,Value&gt;</TT> destructor destroys an<TT> WCPtrHashDict&lt;Key,Value&gt;</TT> object.
<DT>See Also:
<DD><TT> clear</TT>,<TT> clearAndDestroy</TT>,<TT> WCExcept::not_empty</TT>
</DL>
<H2 ID="WCPtrHashDictXKey_ValueY__bitHashLR"> bitHash() [WCPtrHashDict&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>static unsigned bitHash( void *, size_t );</TT>
<DT>Semantics:
<DD>The<TT> bitHash</TT> public member function can be used to implement a hashing function for any type.&nbsp; A hashing value
is generated from the value stored for the number of specified bytes pointed to by the first parameter.
<DT>Results:
<DD>The<TT> bitHash</TT> public member function returns an unsigned value which can be used as the basis of a user defined hash
function.
<DT>See Also:
<DD><TT> WCPtrHashDict</TT>
</DL>
<H2 ID="WCPtrHashDictXKey_ValueY__bucketsLR"> buckets() [WCPtrHashDict&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>unsigned buckets const;</TT>
<DT>Semantics:
<DD>The<TT> buckets</TT> public member function is used to find the number of buckets contained in the<TT> WCPtrHashDict&lt;Key,Value&gt;</TT>
object.
<DT>Results:
<DD>The<TT> buckets</TT> public member function returns the number of buckets in the dictionary.
<DT>See Also:
<DD><TT> resize</TT>
</DL>
<H2 ID="WCPtrHashDictXKey_ValueY__clearLR"> clear() [WCPtrHashDict&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void clear();</TT>
<DT>Semantics:
<DD>The<TT> clear</TT> public member function is used to clear the dictionary so that it has no entries.&nbsp; The number of buckets
remain unaffected.&nbsp; Objects pointed to by the dictionary elements are not deleted.&nbsp; The dictionary object is not
destroyed and re-created by this function, so the object destructor is not invoked.
<DT>Results:
<DD>The<TT> clear</TT> public member function clears the dictionary to have no elements.
<DT>See Also:
<DD><TT> ~WCPtrHashDict</TT>,<TT> clearAndDestroy</TT>,<TT> operator =</TT>
</DL>
<H2 ID="WCPtrHashDictXKey_ValueY__clearAndDestroyLR"> clearAndDestroy() [WCPtrHashDict&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void clearAndDestroy();</TT>
<DT>Semantics:
<DD>The<TT> clearAndDestroy</TT> public member function is used to clear the dictionary and delete the objects pointed to by the
dictionary elements.&nbsp; The dictionary object is not destroyed and re-created by this function, so the dictionary object
destructor is not invoked.
<DT>Results:
<DD>The<TT> clearAndDestroy</TT> public member function clears the dictionary by deleting the objects pointed to by the dictionary
elements.
<DT>See Also:
<DD><TT> clear</TT>
</DL>
<H2 ID="WCPtrHashDictXKey_ValueY__containsLR"> contains() [WCPtrHashDict&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int contains( const Key * ) const;</TT>
<DT>Semantics:
<DD>The<TT> contains</TT> public member function returns non-zero if an element with the specified key is stored in the dictionary,
or zero if there is no equivalent element.&nbsp; Note that equivalence is based on the equivalence operator of the<TT> Key</TT>
type.
<DT>Results:
<DD>The<TT> contains</TT> public member function returns a non-zero value if the<TT> Key</TT> is found in the dictionary.
<DT>See Also:
<DD><TT> find</TT>,<TT> findKeyAndValue</TT>
</DL>
<H2 ID="WCPtrHashDictXKey_ValueY__entriesLR"> entries() [WCPtrHashDict&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>unsigned entries() const;</TT>
<DT>Semantics:
<DD>The<TT> entries</TT> public member function is used to return the current number of elements stored in the dictionary.
<DT>Results:
<DD>The<TT> entries</TT> public member function returns the number of elements in the dictionary.
<DT>See Also:
<DD><TT> buckets</TT>,<TT> isEmpty</TT>
</DL>
<H2 ID="WCPtrHashDictXKey_ValueY__findLR"> find() [WCPtrHashDict&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Value * find( const Key * ) const;</TT>
<DT>Semantics:
<DD>The<TT> find</TT> public member function is used to find an element with an equivalent key in the dictionary.&nbsp; If an
equivalent element is found, a pointer to the element<TT> Value</TT> is returned.&nbsp; Zero is returned if the element is
not found.&nbsp; Note that equivalence is based on the equivalence operator of the<TT> Key</TT> type.
<DT>Results:
<DD>The element equivalent to the passed key is located in the dictionary.
<DT>See Also:
<DD><TT> findKeyAndValue</TT>
</DL>
<H2 ID="WCPtrHashDictXKey_ValueY__findKeyAndValueLR"> findKeyAndValue() [WCPtrHashDict&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Value * findKeyAndValue( const Key *,</TT>
<BR><TT> Key &amp;, Value &amp; ) const;</TT>
<DT>Semantics:
<DD>The<TT> findKeyAndValue</TT> public member function is used to find an element in the dictionary with an key equivalent to
the first parameter.&nbsp; If an equivalent element is found, a pointer to the element<TT> Value</TT> is returned.&nbsp; The
reference to a<TT> Key</TT> passed as the second parameter is assigned the found element's key.&nbsp; Zero is returned if
the element is not found.&nbsp; Note that equivalence is based on the equivalence operator of the<TT> Key</TT> type.
<DT>Results:
<DD>The element equivalent to the passed key is located in the dictionary.
<DT>See Also:
<DD><TT> findKeyAndValue</TT>
</DL>
<H2 ID="WCPtrHashDictXKey_ValueY__forAllLR"> forAll() [WCPtrHashDict&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void forAll(</TT>
<BR><TT> void (*user_fn)( Key *, Value *, void * ),</TT>
<BR><TT>void * );</TT>
<DT>Semantics:
<DD>The<TT> forAll</TT> public member function causes the user supplied function to be invoked for every key-value pair in the
dictionary.&nbsp; The user function has the prototype
<BR><BR><TT>void user_func( Key * key, Value * value, void * data );</TT>
<BR><BR>As the elements are visited, the user function is invoked with the<TT> Key</TT> and<TT> Value</TT> components of the
element passed as the first two parameters.&nbsp; The second parameter of the<TT> forAll</TT> function is passed as the third
parameter to the user function.&nbsp; This value can be used to pass any appropriate data from the main code to the user function.
<DT>Results:
<DD>The elements in the dictionary are all visited, with the user function being invoked for each one.
<DT>See Also:
<DD><TT> find</TT>,<TT> findKeyAndValue</TT>
</DL>
<H2 ID="WCPtrHashDictXKey_ValueY__insertLR"> insert() [WCPtrHashDict&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int insert( Key *, Value * );</TT>
<DT>Semantics:
<DD>The<TT> insert</TT> public member function inserts a key and value into the dictionary, using the hash function on the key
to determine to which bucket it should be stored.&nbsp; If allocation of the node to store the key-value pair fails, then
the<TT> out_of_memory</TT> exception is thrown if it is enabled.&nbsp; If the exception is not enabled, the insert will not
be completed.
<BR><BR>At some point, the number of buckets initially selected may be too small for the number of elements inserted.&nbsp;
The resize of the dictionary can be controlled by the insertion mechanism by using<TT> WCPtrHashDict</TT> as a base class,
and providing an insert member function to do a resize when appropriate.&nbsp; This insert could then call<TT> WCPtrHashDict::insert</TT>
to insert the element.&nbsp; Note that copy constructors and assignment operators are not inherited in your class, but you
can provide the following inline definitions (assuming that the class inherited from WCPtrHashDict is named MyHashDict):
<BR><BR><TT>inline MyHashDict( const MyHashDict &amp;orig ) : WCPtrHashDict( orig ) {};</TT>
<BR><TT>inline MyHashDict &amp;operator=( const MyHashDict &amp;orig ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; return( WCPtrHashDict::operator=( orig ) );</TT>
<BR><TT>}</TT>
<DT>Results:
<DD>The<TT> insert</TT> public member function inserts a key and value into the dictionary.&nbsp; If the insert is successful,
a non-zero will returned.&nbsp; A zero will be returned if the insert fails.
<DT>See Also:
<DD><TT> operator =</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<H2 ID="WCPtrHashDictXKey_ValueY__isEmptyLR"> isEmpty() [WCPtrHashDict&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int isEmpty() const;</TT>
<DT>Semantics:
<DD>The<TT> isEmpty</TT> public member function is used to determine if the dictionary is empty.
<DT>Results:
<DD>The<TT> isEmpty</TT> public member function returns zero if it contains at least one entry, non-zero if the dictionary is
empty.
<DT>See Also:
<DD><TT> buckets</TT>,<TT> entries</TT>
</DL>
<H2 ID="WCPtrHashDictXKey_ValueY__operator_UVLR"> operator []() [WCPtrHashDict&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Value * &amp; operator[]( const Key &amp; );</TT>
<DT>Semantics:
<DD><TT> operator []</TT> is the dictionary index operator.&nbsp; A reference to the object stored in the dictionary with the
given<TT> Key</TT> is returned.&nbsp; If no equivalent element is found, then a new key-value pair is created with the specified<TT>
Key</TT> value, and initialized with the default constructor.&nbsp; The returned reference can then be assigned to, so that
insertions can be made with the operator.&nbsp; If an allocation error occurs while inserting a new key-value pair, then the<TT>
out_of_memory</TT> exception is thrown if it is enabled.&nbsp; If the exception is not enabled, then a reference to address
zero will be returned.&nbsp; This will result in a run-time error on systems which trap address zero references.
<DT>Results:
<DD>The<TT> operator []</TT> public member function returns a reference to the element at the given key value.&nbsp; If the key
does not exist, a reference to a created element is returned.&nbsp; The result of the operator may be assigned to.
<DT>See Also:
<DD><TT> WCExcept::out_of_memory</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Value * const &amp; operator[]( const Key * ) const;</TT>
<DT>Semantics:
<DD><TT> operator []</TT> is the dictionary index operator.&nbsp; A constant reference to the object stored in the dictionary
with the given<TT> Key</TT> is returned.&nbsp; If no equivalent element is found, then the<TT> index_range</TT> exception
is thrown if it is enabled.&nbsp; If the exception is not enabled, then a reference to address zero will be returned.&nbsp;
This will result in a run-time error on systems which trap address zero references.
<DT>Results:
<DD>The<TT> operator []</TT> public member function returns a constant reference to the element at the given key value.&nbsp;
The result of the operator may not be assigned to.
<DT>See Also:
<DD><TT> WCExcept::index_range</TT>
</DL>
<H2 ID="WCPtrHashDictXKey_ValueY__operator_ELR"> operator =() [WCPtrHashDict&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCPtrHashDict &amp; operator =( const WCPtrHashDict &amp; );</TT>
<DT>Semantics:
<DD>The<TT> operator =</TT> public member function is the assignment operator for the<TT> WCPtrHashDict&lt;Key,Value&gt;</TT>
class.&nbsp; The left hand side dictionary is first cleared using the<TT> clear</TT> member function, and then the right hand
side dictionary is copied.&nbsp; The hash function, exception trap states, and all of the dictionary elements are copied.
&nbsp;If an allocation failure occurs when creating the buckets, the table will be created with zero buckets, and the<TT>
out_of_memory</TT> exception is thrown if it is enabled.&nbsp; If there is not enough memory to copy all of the values or
pointers in the dictionary, then only some will be copied, and the<TT> out_of_memory</TT> exception is thrown if it is enabled.
&nbsp;The number of entries will correctly reflect the number copied.
<DT>Results:
<DD>The<TT> operator =</TT> public member function assigns the left hand side dictionary to be a copy of the right hand side.
<DT>See Also:
<DD><TT> clear</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<H2 ID="WCPtrHashDictXKey_ValueY__operator_EELR"> operator ==() [WCPtrHashDict&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int operator ==( const WCPtrHashDict &amp; ) const;</TT>
<DT>Semantics:
<DD>The<TT> operator ==</TT> public member function is the equivalence operator for the<TT> WCPtrHashDict&lt;Key,Value&gt;</TT>
class.&nbsp; Two dictionary objects are equivalent if they are the same object and share the same address.
<DT>Results:
<DD>A TRUE (non-zero) value is returned if the left hand side and right hand side dictionary are the same object.&nbsp; A FALSE
(zero) value is returned otherwise.
</DL>
<H2 ID="WCPtrHashDictXKey_ValueY__removeLR"> remove() [WCPtrHashDict&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Value * remove( const Key * );</TT>
<DT>Semantics:
<DD>The<TT> remove</TT> public member function is used to remove the specified element from the dictionary.&nbsp; If an equivalent
element is found, the pointer value is returned.&nbsp; Zero is returned if the element is not found.&nbsp; Note that equivalence
is based on the equivalence operator of the<TT> Key</TT> type.
<DT>Results:
<DD>The element is removed from the dictionary if it found.
</DL>
<H2 ID="WCPtrHashDictXKey_ValueY__resizeLR"> resize() [WCPtrHashDict&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void resize( unsigned );</TT>
<DT>Semantics:
<DD>The<TT> resize</TT> public member function is used to change the number of buckets contained in the dictionary.&nbsp; If the
new number is larger than the previous dictionary size, then the hash function will be used on all of the stored elements
to determine which bucket they should be stored into.&nbsp; Entries are not destroyed or created in the process of being moved.
&nbsp;If there is not enough memory to resize the dictionary, the<TT> out_of_memory</TT> exception is thrown if it is enabled,
and the dictionary will contain the number of buckets it contained before the resize.&nbsp; If the new number is zero, then
the<TT> zero_buckets</TT> exception is thrown if it is enabled, and no resize will be performed.&nbsp; The dictionary is guaranteed
to contain the same number of entries after the resize.
<DT>Results:
<DD>The dictionary is resized to the new number of buckets.
<DT>See Also:
<DD><TT> WCExcept::out_of_memory</TT>,<TT> WCExcept::zero_buckets</TT>
</DL>
<H2 ID="WCPtrHashTableXTypeY__WCPtrHashSetXTypeY_Class_Description"> WCPtrHashTable&lt;Type&gt;, WCPtrHashSet&lt;Type&gt; Class Description </H2>
<DL>
<DT>Declared:
<DD><TT> wchash.h</TT>
<BR><BR><TT>WCPtrHashTable&lt;Type&gt;</TT> and<TT> WCPtrHashSet&lt;Type&gt;</TT> classes are templated classes used to store
objects in a hash.&nbsp; A hash saves objects in such a way as to make it efficient to locate and retrieve an element.&nbsp;
As an element is looked up or inserted into the hash, the value of the element is hashed.&nbsp; Hashing results in a numeric
index which is used to locate the value.&nbsp; The storage area referenced by the hash value is usually called a bucket.&nbsp;
If more than one element results in the same hash, the value associated with the hash is placed in a list stored in the bucket.
&nbsp;A hash table allows more than one copy of an element that is equivalent, while the hash set allows only one copy.&nbsp;
The equality operator of the element's type is used to locate the value.
<BR>In the description of each member function, the text<TT> Type</TT> is used to indicate the template parameter defining
the type of the data pointed to by the pointers stored in the hash.
<BR><BR>The constructor for the<TT> WCPtrHashTable&lt;Type&gt;</TT> and<TT> WCPtrHashSet&lt;Type&gt;</TT> classes requires
a hashing function, which given a reference to<TT> Type,</TT> returns an<TT> unsigned</TT> value.&nbsp; The returned value
modulo the number of buckets determines the bucket into which the element will be located.&nbsp; The return values of the
hash function can be spread over the entire range of unsigned numbers.&nbsp; The hash function return value must be the same
for values which are equivalent by the equivalence operator for<TT> Type.</TT>
<BR><BR>Note that pointers to the elements are stored in the hash.&nbsp; Destructors are not called on the elements pointed
to.&nbsp; The data values pointed to in the hash should not be changed such that the equivalence to the old value is modified.
<BR><BR>The<TT> WCExcept</TT> class is a base class of the<TT> WCPtrHashTable&lt;Type&gt;</TT> and<TT> WCPtrHashSet&lt;Type&gt;</TT>
classes and provides the<TT> exceptions</TT> member function.&nbsp; This member function controls the exceptions which can
be thrown by the<TT> WCPtrHashTable&lt;Type&gt;</TT> and<TT> WCPtrHashSet&lt;Type&gt;</TT> objects.&nbsp; No exceptions are
enabled unless they are set by the<TT> exceptions</TT> member function.
<BR><BR><B>Requirements of Type</B>
<BR><BR>The<TT> WCPtrHashTable&lt;Type&gt;</TT> and<TT> WCPtrHashSet&lt;Type&gt;</TT> classes requires<TT> Type</TT> to have:
<BR>A well defined equivalence operator with constant parameters
<BR><BR>(<TT> int operator ==( const Type &amp; ) const</TT> ).
<BR><BR><B>Public Member Functions</B>
<BR><BR>The following member functions are declared in the public interface:
<BR><BR><TT>WCPtrHashSet( unsigned (*hash_fn)( const Type &amp; ), unsigned = WC_DEFAULT_HASH_SIZE );</TT>
<BR><TT> WCPtrHashSet( unsigned (*hash_fn)( const Type &amp; ), unsigned = WC_DEFAULT_HASH_SIZE, void * (*user_alloc)( size_t
size ), void (*user_dealloc)( void *old, size_t size ) );</TT>
<BR><TT> WCPtrHashSet( const WCPtrHashSet &amp; );</TT>
<BR><TT> virtual ~WCPtrHashSet();</TT>
<BR><TT> WCPtrHashTable( unsigned (*hash_fn)( const Type &amp; ), unsigned = WC_DEFAULT_HASH_SIZE );</TT>
<BR><TT> WCPtrHashTable( unsigned (*hash_fn)( const Type &amp; ), unsigned = WC_DEFAULT_HASH_SIZE, void * (*user_alloc)( size_t
size ), void (*user_dealloc)( void *old, size_t size ) );</TT>
<BR><TT> WCPtrHashTable( const WCPtrHashTable &amp; );</TT>
<BR><TT> virtual ~WCPtrHashTable();</TT>
<BR><TT> static unsigned bitHash( const void *, size_t );</TT>
<BR><TT> unsigned buckets() const;</TT>
<BR><TT> void clear();</TT>
<BR><TT> void clearAndDestroy();</TT>
<BR><TT> int contains( const Type * ) const;</TT>
<BR><TT> unsigned entries() const;</TT>
<BR><TT> Type * find( const Type * ) const;</TT>
<BR><TT> void forAll( void (*user_fn)( Type *, void * ) , void * );</TT>
<BR><TT> int insert( Type * );</TT>
<BR><TT> int isEmpty() const;</TT>
<BR><TT> Type * remove( const Type * );</TT>
<BR><TT> void resize( unsigned );</TT>
<BR><BR>The following public member functions are available for the<TT> WCPtrHashTable</TT> class only:
<BR><BR><TT>unsigned occurrencesOf( const Type * ) const;</TT>
<BR><TT> unsigned removeAll( const Type * );</TT>
<BR><BR><B>Public Member Operators</B>
<BR><BR>The following member operators are declared in the public interface:
<BR><BR><TT>WCPtrHashSet &amp; operator =( const WCPtrHashSet &amp; );</TT>
<BR><TT> int operator ==( const WCPtrHashSet &amp; ) const;</TT>
<BR><TT> WCPtrHashTable &amp; operator =( const WCPtrHashTable &amp; );</TT>
<BR><TT> int operator ==( const WCPtrHashTable &amp; ) const;</TT>
</DL>
<H2 ID="WCPtrHashSetXTypeY__WCPtrHashSetLR"> WCPtrHashSet() [WCPtrHashSet&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCPtrHashSet( unsigned (*hash_fn)( const Type &amp; ),</TT>
<BR><TT> unsigned = WC_DEFAULT_HASH_SIZE );</TT>
<DT>Semantics:
<DD>The<TT> WCPtrHashSet&lt;Type&gt;</TT> constructor creates a<TT> WCPtrHashSet</TT> object with no entries and with the number
of buckets in the second optional parameter, which defaults to the constant<TT> WC_DEFAULT_HASH_SIZE</TT> (currently defined
as 101).&nbsp; The number of buckets specified must be greater than zero, and will be forced to at least one.&nbsp; If the
hash object can be created, but an allocation failure occurs when creating the buckets, the table will be created with zero
buckets.&nbsp; If the<TT> out_of_memory</TT> exception is enabled, then attempting to insert into a hash table with zero buckets
with throw an<TT> out_of_memory</TT> error.
<BR><BR>The hash function<TT> hash_fn</TT> is used to determine which bucket each value will be assigned to.&nbsp; If no hash
function exists, the static member function<TT> bitHash</TT> is available to help create one.
<DT>Results:
<DD>The<TT> WCPtrHashSet&lt;Type&gt;</TT> constructor creates an initialized<TT> WCPtrHashSet</TT> object with the specified number
of buckets and hash function.
<DT>See Also:
<DD><TT> ~WCPtrHashSet</TT>,<TT> bitHash</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCPtrHashSet( unsigned (*hash_fn)( const Type &amp; ),</TT>
<BR><TT> unsigned = WC_DEFAULT_HASH_SIZE,</TT>
<BR><TT>void * (*user_alloc)( size_t ),</TT>
<BR><TT>void (*user_dealloc)( void *, size_t ) );</TT>
<DT>Semantics:
<DD>Allocator and deallocator functions are specified for use when entries are inserted and removed from the hash.&nbsp; The semantics
of this constructor are the same as the constructor without the memory management functions.
<BR><BR>The allocation function must return a zero if it cannot perform the allocation.&nbsp; The deallocation function is
passed the size as well as the pointer to the data.&nbsp; Your allocation system may take advantage of the characteristic
that the allocation function will always be called with the same size value for any particular instantiation of a hash.&nbsp;
To determine the size of the objects that the memory management functions will be required to allocate and free, the following
macro may be used:
<BR><BR><TT>WCPtrHashSetItemSize( Type )</TT>
<DT>Results:
<DD>The<TT> WCPtrHashSet&lt;Type&gt;</TT> constructor creates an initialized<TT> WCPtrHashSet</TT> object with the specified number
of buckets and hash function.
<DT>See Also:
<DD><TT> ~WCPtrHashSet</TT>,<TT> bitHash</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCPtrHashSet( const WCPtrHashSet &amp; );</TT>
<DT>Semantics:
<DD>The<TT> WCPtrHashSet&lt;Type&gt;</TT> is the copy constructor for the<TT> WCPtrHashSet</TT> class.&nbsp; The new hash is created
with the same number of buckets, hash function, all values or pointers stored in the hash, and the exception trap states.
&nbsp;If the hash object can be created, but an allocation failure occurs when creating the buckets, the hash will be created
with zero buckets.&nbsp; If there is not enough memory to copy all of the values, then only some will be copied, and the number
of entries will correctly reflect the number copied.&nbsp; If all of the elements cannot be copied, then the<TT> out_of_memory</TT>
exception is thrown if it is enabled.
<DT>Results:
<DD>The<TT> WCPtrHashSet&lt;Type&gt;</TT> constructor creates a<TT> WCPtrHashSet</TT> object which is a copy of the passed hash.
<DT>See Also:
<DD><TT> ~WCPtrHashSet</TT>,<TT> operator =</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<H2 ID="WCPtrHashSetXTypeY____WCPtrHashSetLR"> ~WCPtrHashSet() [WCPtrHashSet&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>virtual ~WCPtrHashSet();</TT>
<DT>Semantics:
<DD>The<TT> WCPtrHashSet&lt;Type&gt;</TT> destructor is the destructor for the<TT> WCPtrHashSet</TT> class.&nbsp; If the number
of elements is not zero and the<TT> not_empty</TT> exception is enabled, the exception is thrown.&nbsp; Otherwise, the hash
elements are cleared using the<TT> clear</TT> member function.&nbsp; The objects which the hash elements point to are not
deleted unless the<TT> clearAndDestroy</TT> member function is explicitly called before the destructor is called.&nbsp; The
call to the<TT> WCPtrHashSet&lt;Type&gt;</TT> destructor is inserted implicitly by the compiler at the point where the<TT>
WCPtrHashSet</TT> object goes out of scope.
<DT>Results:
<DD>The call to the<TT> WCPtrHashSet&lt;Type&gt;</TT> destructor destroys a<TT> WCPtrHashSet</TT> object.
<DT>See Also:
<DD><TT> clear</TT>,<TT> clearAndDestroy</TT>,<TT> WCExcept::not_empty</TT>
</DL>
<H2 ID="WCPtrHashTableXTypeY__WCPtrHashTableLR"> WCPtrHashTable() [WCPtrHashTable&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCPtrHashTable( unsigned (*hash_fn)( const Type &amp; ),</TT>
<BR><TT> unsigned = WC_DEFAULT_HASH_SIZE );</TT>
<DT>Semantics:
<DD>The<TT> WCPtrHashTable&lt;Type&gt;</TT> constructor creates a<TT> WCPtrHashTable</TT> object with no entries and with the
number of buckets in the second optional parameter, which defaults to the constant<TT> WC_DEFAULT_HASH_SIZE</TT> (currently
defined as 101).&nbsp; The number of buckets specified must be greater than zero, and will be forced to at least one.&nbsp;
If the hash object can be created, but an allocation failure occurs when creating the buckets, the table will be created with
zero buckets.&nbsp; If the<TT> out_of_memory</TT> exception is enabled, then attempting to insert into a hash table with zero
buckets with throw an<TT> out_of_memory</TT> error.
<BR><BR>The hash function<TT> hash_fn</TT> is used to determine which bucket each value will be assigned to.&nbsp; If no hash
function exists, the static member function<TT> bitHash</TT> is available to help create one.
<DT>Results:
<DD>The<TT> WCPtrHashTable&lt;Type&gt;</TT> constructor creates an initialized<TT> WCPtrHashTable</TT> object with the specified
number of buckets and hash function.
<DT>See Also:
<DD><TT> ~WCPtrHashTable</TT>,<TT> bitHash</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCPtrHashTable( unsigned (*hash_fn)( const Type &amp; ),</TT>
<BR><TT> unsigned = WC_DEFAULT_HASH_SIZE,</TT>
<BR><TT>void * (*user_alloc)( size_t ),</TT>
<BR><TT>void (*user_dealloc)( void *, size_t ) );</TT>
<DT>Semantics:
<DD>Allocator and deallocator functions are specified for use when entries are inserted and removed from the hash.&nbsp; The semantics
of this constructor are the same as the constructor without the memory management functions.
<BR><BR>The allocation function must return a zero if it cannot perform the allocation.&nbsp; The deallocation function is
passed the size as well as the pointer to the data.&nbsp; Your allocation system may take advantage of the characteristic
that the allocation function will always be called with the same size value for any particular instantiation of a hash.&nbsp;
To determine the size of the objects that the memory management functions will be required to allocate and free, the following
macro may be used:
<BR><BR><TT>WCPtrHashTableItemSize( Type )</TT>
<DT>Results:
<DD>The<TT> WCPtrHashTable&lt;Type&gt;</TT> constructor creates an initialized<TT> WCPtrHashTable</TT> object with the specified
number of buckets and hash function.
<DT>See Also:
<DD><TT> ~WCPtrHashTable</TT>,<TT> bitHash</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCPtrHashTable( const WCPtrHashTable &amp; );</TT>
<DT>Semantics:
<DD>The<TT> WCPtrHashTable&lt;Type&gt;</TT> is the copy constructor for the<TT> WCPtrHashTable</TT> class.&nbsp; The new hash
is created with the same number of buckets, hash function, all values or pointers stored in the hash, and the exception trap
states.&nbsp; If the hash object can be created, but an allocation failure occurs when creating the buckets, the hash will
be created with zero buckets.&nbsp; If there is not enough memory to copy all of the values, then only some will be copied,
and the number of entries will correctly reflect the number copied.&nbsp; If all of the elements cannot be copied, then the<TT>
out_of_memory</TT> exception is thrown if it is enabled.
<DT>Results:
<DD>The<TT> WCPtrHashTable&lt;Type&gt;</TT> constructor creates a<TT> WCPtrHashTable</TT> object which is a copy of the passed
hash.
<DT>See Also:
<DD><TT> ~WCPtrHashTable</TT>,<TT> operator =</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<H2 ID="WCPtrHashTableXTypeY____WCPtrHashTableLR"> ~WCPtrHashTable() [WCPtrHashTable&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>virtual ~WCPtrHashTable();</TT>
<DT>Semantics:
<DD>The<TT> WCPtrHashTable&lt;Type&gt;</TT> destructor is the destructor for the<TT> WCPtrHashTable</TT> class.&nbsp; If the number
of elements is not zero and the<TT> not_empty</TT> exception is enabled, the exception is thrown.&nbsp; Otherwise, the hash
elements are cleared using the<TT> clear</TT> member function.&nbsp; The objects which the hash elements point to are not
deleted unless the<TT> clearAndDestroy</TT> member function is explicitly called before the destructor is called.&nbsp; The
call to the<TT> WCPtrHashTable&lt;Type&gt;</TT> destructor is inserted implicitly by the compiler at the point where the<TT>
WCPtrHashTable</TT> object goes out of scope.
<DT>Results:
<DD>The call to the<TT> WCPtrHashTable&lt;Type&gt;</TT> destructor destroys a<TT> WCPtrHashTable</TT> object.
<DT>See Also:
<DD><TT> clear</TT>,<TT> clearAndDestroy</TT>,<TT> WCExcept::not_empty</TT>
</DL>
<H2 ID="WCPtrHashTableXTypeY__bitHashLR__WCPtrHashSetXTypeY__bitHashLR"> bitHash() [WCPtrHashTable&lt;Type&gt;,WCPtrHashSet&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>static unsigned bitHash( void *, size_t );</TT>
<DT>Semantics:
<DD>The<TT> bitHash</TT> public member function can be used to implement a hashing function for any type.&nbsp; A hashing value
is generated from the value stored for the number of specified bytes pointed to by the first parameter.
<DT>Results:
<DD>The<TT> bitHash</TT> public member function returns an unsigned value which can be used as the basis of a user defined hash
function.
<DT>See Also:
<DD><TT> WCPtrHashSet</TT>,<TT> WCPtrHashTable</TT>
</DL>
<H2 ID="WCPtrHashTableXTypeY__bucketsLR__WCPtrHashSetXTypeY__bucketsLR"> buckets() [WCPtrHashTable&lt;Type&gt;,WCPtrHashSet&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>unsigned buckets() const;</TT>
<DT>Semantics:
<DD>The<TT> buckets</TT> public member function is used to find the number of buckets contained in the hash object.
<DT>Results:
<DD>The<TT> buckets</TT> public member function returns the number of buckets in the hash.
<DT>See Also:
<DD><TT> resize</TT>
</DL>
<H2 ID="WCPtrHashTableXTypeY__clearLR__WCPtrHashSetXTypeY__clearLR"> clear() [WCPtrHashTable&lt;Type&gt;,WCPtrHashSet&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void clear();</TT>
<DT>Semantics:
<DD>The<TT> clear</TT> public member function is used to clear the hash so that it has no entries.&nbsp; The number of buckets
remain unaffected.&nbsp; Objects pointed to by the hash elements are not deleted.&nbsp; The hash object is not destroyed and
re-created by this function, so the object destructor is not invoked.
<DT>Results:
<DD>The<TT> clear</TT> public member function clears the hash to have no elements.
<DT>See Also:
<DD><TT> ~WCPtrHashSet</TT>,<TT> ~WCPtrHashTable</TT>,<TT> clearAndDestroy</TT>,<TT> operator =</TT>
</DL>
<H2 ID="WCPtrHashTableXTypeY_WCPtrHashSetXTypeY__clearAndDestroyLR"> clearAndDestroy() [WCPtrHashTable&lt;Type&gt;,WCPtrHashSet&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void clearAndDestroy();</TT>
<DT>Semantics:
<DD>The<TT> clearAndDestroy</TT> public member function is used to clear the hash and delete the objects pointed to by the hash
elements.&nbsp; The hash object is not destroyed and re-created by this function, so the hash object destructor is not invoked.
<DT>Results:
<DD>The<TT> clearAndDestroy</TT> public member function clears the hash by deleting the objects pointed to by the hash elements.
<DT>See Also:
<DD><TT> clear</TT>
</DL>
<H2 ID="WCPtrHashTableXTypeY__containsLR__WCPtrHashSetXTypeY__containsLR"> contains() [WCPtrHashTable&lt;Type&gt;,WCPtrHashSet&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int contains( const Type * ) const;</TT>
<DT>Semantics:
<DD>The<TT> contains</TT> public member function returns non-zero if the element is stored in the hash, or zero if there is no
equivalent element.&nbsp; Note that equivalence is based on the equivalence operator of the element type.
<DT>Results:
<DD>The<TT> contains</TT> public member function returns a non-zero value if the element is found in the hash.
<DT>See Also:
<DD><TT> find</TT>
</DL>
<H2 ID="WCPtrHashTableXTypeY__entriesLR__WCPtrHashSetXTypeY__entriesLR"> entries() [WCPtrHashTable&lt;Type&gt;,WCPtrHashSet&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>unsigned entries() const;</TT>
<DT>Semantics:
<DD>The<TT> entries</TT> public member function is used to return the current number of elements stored in the hash.
<DT>Results:
<DD>The<TT> entries</TT> public member function returns the number of elements in the hash.
<DT>See Also:
<DD><TT> buckets</TT>,<TT> isEmpty</TT>
</DL>
<H2 ID="WCPtrHashTableXTypeY__findLR__WCPtrHashSetXTypeY__findLR"> find() [WCPtrHashTable&lt;Type&gt;,WCPtrHashSet&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Type * find( const Type * ) const;</TT>
<DT>Semantics:
<DD>The<TT> find</TT> public member function is used to find an element with an equivalent key in the hash.&nbsp; If an equivalent
element is found, a pointer to the element is returned.&nbsp; Zero is returned if the element is not found.&nbsp; Note that
equivalence is based on the equivalence operator of the element type.
<DT>Results:
<DD>The element equivalent to the passed key is located in the hash.
</DL>
<H2 ID="WCPtrHashTableXTypeY__forAllLR__WCPtrHashSetXTypeY__forAllLR"> forAll() [WCPtrHashTable&lt;Type&gt;,WCPtrHashSet&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void forAll(</TT>
<BR><TT> void (*user_fn)( Type *, void * ),</TT>
<BR><TT>void * );</TT>
<DT>Semantics:
<DD>The<TT> forAll</TT> public member function causes the user supplied function to be invoked for every value in the hash.&nbsp;
The user function has the prototype
<BR><BR><TT>void user_func( Type * value, void * data );</TT>
<BR><BR>As the elements are visited, the user function is invoked with the element passed as the first.&nbsp; The second parameter
of the<TT> forAll</TT> function is passed as the second parameter to the user function.&nbsp; This value can be used to pass
any appropriate data from the main code to the user function.
<DT>Results:
<DD>The elements in the hash are all visited, with the user function being invoked for each one.
<DT>See Also:
<DD><TT> find</TT>
</DL>
<H2 ID="WCPtrHashTableXTypeY__insertLR__WCPtrHashSetXTypeY__insertLR"> insert() [WCPtrHashTable&lt;Type&gt;,WCPtrHashSet&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int insert( Type * );</TT>
<DT>Semantics:
<DD>The<TT> insert</TT> public member function inserts a value into the hash, using the hash function to determine to which bucket
it should be stored.&nbsp; If allocation of the node to store the value fails, then the<TT> out_of_memory</TT> exception is
thrown if it is enabled.&nbsp; If the exception is not enabled, the insert will not be completed.
<BR><BR>With a<TT> WCPtrHashSet,</TT> there must be only one equivalent element in the set.&nbsp; If an element equivalent
to the inserted element is already in the hash set, the hash set will remain unchanged, and the<TT> not_unique</TT> exception
is thrown if it is enabled.&nbsp; If the exception is not enabled, the insert will not be completed.
<BR><BR>At some point, the number of buckets initially selected may be too small for the number of elements inserted.&nbsp;
The resize of the hash can be controlled by the insertion mechanism by using<TT> WCPtrHashSet</TT> (or<TT> WCPtrHashTable</TT>)
as a base class, and providing an insert member function to do a resize when appropriate.&nbsp; This insert could then call<TT>
WCPtrHashSet::insert</TT> (or<TT> WCPtrHashTable::insert</TT>) to insert the element.&nbsp; Note that copy constructors and
assignment operators are not inherited in your class, but you can provide the following inline definitions (assuming that
the class inherited from WCPtrHashTable is named MyHashTable):
<BR><BR><TT>inline MyHashTable( const MyHashTable &amp;orig )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; : WCPtrHashTable( orig ) {};</TT>
<BR><TT>inline MyHashTable &amp;operator=( const MyHashTable &amp;orig ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; return( WCPtrHashTable::operator=( orig ) );</TT>
<BR><TT>}</TT>
<DT>Results:
<DD>The<TT> insert</TT> public member function inserts a value into the hash.&nbsp; If the insert is successful, a non-zero will
returned.&nbsp; A zero will be returned if the insert fails.
<DT>See Also:
<DD><TT> operator =</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<H2 ID="WCPtrHashTableXTypeY__isEmptyLR__WCPtrHashSetXTypeY__isEmptyLR"> isEmpty() [WCPtrHashTable&lt;Type&gt;,WCPtrHashSet&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int isEmpty() const;</TT>
<DT>Semantics:
<DD>The<TT> isEmpty</TT> public member function is used to determine if the hash is empty.
<DT>Results:
<DD>The<TT> isEmpty</TT> public member function returns zero if it contains at least one entry, non-zero if the hash is empty.
<DT>See Also:
<DD><TT> buckets</TT>,<TT> entries</TT>
</DL>
<H2 ID="WCPtrHashTableXTypeY__occurencesOfLR"> occurencesOf() [WCPtrHashTable&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>unsigned occurrencesOf( const Type * ) const;</TT>
<DT>Semantics:
<DD>The<TT> occurencesOf</TT> public member function is used to return the current number of elements stored in the hash which
are equivalent to the passed value.&nbsp; Note that equivalence is based on the equivalence operator of the element type.
<DT>Results:
<DD>The<TT> occurencesOf</TT> public member function returns the number of elements in the hash.
<DT>See Also:
<DD><TT> buckets</TT>,<TT> entries</TT>,<TT> find</TT>,<TT> isEmpty</TT>
</DL>
<H2 ID="WCPtrHashTableXTypeY__operator_ELR__WCPtrHashSetXTypeY__operator_ELR"> operator =() [WCPtrHashTable&lt;Type&gt;,WCPtrHashSet&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCPtrHashSet &amp; operator =( const WCPtrHashSet &amp; );</TT>
<BR><TT> WCPtrHashTable &amp; operator =( const WCPtrHashTable &amp; );</TT>
<DT>Semantics:
<DD>The<TT> operator =</TT> public member function is the assignment operator for the<TT> WCPtrHashTable&lt;Type&gt;</TT> and<TT>
WCPtrHashSet&lt;Type&gt;</TT> classes.&nbsp; The left hand side hash is first cleared using the<TT> clear</TT> member function,
and then the right hand side hash is copied.&nbsp; The hash function, exception trap states, and all of the hash elements
are copied.&nbsp; If an allocation failure occurs when creating the buckets, the table will be created with zero buckets,
and the<TT> out_of_memory</TT> exception is thrown if it is enabled.&nbsp; If there is not enough memory to copy all of the
values or pointers in the hash, then only some will be copied, and the<TT> out_of_memory</TT> exception is thrown if it is
enabled.&nbsp; The number of entries will correctly reflect the number copied.
<DT>Results:
<DD>The<TT> operator =</TT> public member function assigns the left hand side hash to be a copy of the right hand side.
<DT>See Also:
<DD><TT> clear</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<H2 ID="WCPtrHashTableXTypeY__operator_EELR__WCPtrHashSetXTypeY__operator_EELR"> operator ==() [WCPtrHashTable&lt;Type&gt;,WCPtrHashSet&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int operator ==( const WCPtrHashSet &amp; ) const;</TT>
<BR><TT> int operator ==( const WCPtrHashTable &amp; ) const;</TT>
<DT>Semantics:
<DD>The<TT> operator ==</TT> public member function is the equivalence operator for the<TT> WCPtrHashTable&lt;Type&gt;</TT> and<TT>
WCPtrHashSet&lt;Type&gt;</TT> classes.&nbsp; Two hash objects are equivalent if they are the same object and share the same
address.
<DT>Results:
<DD>A TRUE (non-zero) value is returned if the left hand side and right hand side hash are the same object.&nbsp; A FALSE (zero)
value is returned otherwise.
</DL>
<H2 ID="WCPtrHashTableXTypeY__removeLR__WCPtrHashSetXTypeY__removeLR"> remove() [WCPtrHashTable&lt;Type&gt;,WCPtrHashSet&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Type * remove( const Type * );</TT>
<DT>Semantics:
<DD>The<TT> remove</TT> public member function is used to remove the specified element from the hash.&nbsp; If an equivalent element
is found, the pointer value is returned.&nbsp; Zero is returned if the element is not found.&nbsp; If the hash is a table
and there is more than one element equivalent to the specified element, then the first equivalent element added to the table
is removed.&nbsp; Note that equivalence is based on the equivalence operator of the element type.
<DT>Results:
<DD>The element is removed from the hash if it found.
</DL>
<H2 ID="WCPtrHashTableXTypeY__removeAllLR"> removeAll() [WCPtrHashTable&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>unsigned removeAll( const Type * );</TT>
<DT>Semantics:
<DD>The<TT> removeAll</TT> public member function is used to remove all elements equivalent to the specified element from the
hash.&nbsp; Zero is returned if no equivalent elements are found.&nbsp; Note that equivalence is based on the equivalence
operator of the element type.
<DT>Results:
<DD>All equivalent elements are removed from the hash.
</DL>
<H2 ID="WCPtrHashTableXTypeY__resizeLR__WCPtrHashSetXTypeY__resizeLR"> resize() [WCPtrHashTable&lt;Type&gt;,WCPtrHashSet&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void resize( unsigned );</TT>
<DT>Semantics:
<DD>The<TT> resize</TT> public member function is used to change the number of buckets contained in the hash.&nbsp; If the new
number is larger than the previous hash size, then the hash function will be used on all of the stored elements to determine
which bucket they should be stored into.&nbsp; Entries are not destroyed or created in the process of being moved.&nbsp; If
there is not enough memory to resize the hash, the<TT> out_of_memory</TT> exception is thrown if it is enabled, and the hash
will contain the number of buckets it contained before the resize.&nbsp; If the new number is zero, then the<TT> zero_buckets</TT>
exception is thrown if it is enabled, and no resize will be performed.&nbsp; The hash is guaranteed to contain the same number
of entries after the resize.
<DT>Results:
<DD>The hash is resized to the new number of buckets.
<DT>See Also:
<DD><TT> WCExcept::out_of_memory</TT>,<TT> WCExcept::zero_buckets</TT>
</DL>
<H2 ID="WCValHashDictXKey_ValueY_Class_Description"> WCValHashDict&lt;Key,Value&gt; Class Description </H2>
<DL>
<DT>Declared:
<DD><TT> wchash.h</TT>
<BR><BR>The<TT> WCValHashDict&lt;Key,Value&gt;</TT> class is a templated class used to store objects in a dictionary.&nbsp;
Dictionaries store values with an associated key, which may be of any type.&nbsp; One example of a dictionary used in everyday
life is the phone book.&nbsp; The phone numbers are the data values, and the customer name is the key.&nbsp; An example of
a specialized dictionary is a vector, where the key value is the integer index.
<BR>As an element is looked up or inserted into the dictionary, the associated key is hashed.&nbsp; Hashing converts the key
into a numeric index value which is used to locate the value.&nbsp; The storage area referenced by the hash value is usually
called a bucket.&nbsp; If more than one key results in the same hash, the values associated with the keys are placed in a
list stored in the bucket.&nbsp; The equality operator of the key's type is used to locate the key-value pairs.
<BR><BR>In the description of each member function, the text<TT> Key</TT> is used to indicate the template parameter defining
the type of the indices used to store data in the dictionary.&nbsp; The text<TT> Value</TT> is used to indicate the template
parameter defining the type of the data stored in the dictionary.
<BR><BR>The constructor for the<TT> WCValHashDict&lt;Key,Value&gt;</TT> class requires a hashing function, which given a reference
to<TT> Key,</TT> returns an<TT> unsigned</TT> value.&nbsp; The returned value modulo the number of buckets determines the
bucket into which the key-value pair will be located.&nbsp; The return values of the hash function can be spread over the
entire range of unsigned numbers.&nbsp; The hash function return value must be the same for values which are equivalent by
the equivalence operator for<TT> Key.</TT>
<BR><BR>Values are copied into the dictionary, which could be undesirable if the stored objects are complicated and copying
is expensive.&nbsp; Value dictionaries should not be used to store objects of a base class if any derived types of different
sizes would be stored in the dictionary, or if the destructor for a derived class must be called.
<BR><BR>The<TT> WCExcept</TT> class is a base class of the<TT> WCValHashDict&lt;Key,Value&gt;</TT> class and provides the<TT>
exceptions</TT> member function.&nbsp; This member function controls the exceptions which can be thrown by the<TT> WCValHashDict&lt;Key,Value&gt;</TT>
object.&nbsp; No exceptions are enabled unless they are set by the<TT> exceptions</TT> member function.
<BR><BR><B>Requirements of Key and Value</B>
<BR><BR>The<TT> WCValHashDict&lt;Key,Value&gt;</TT> class requires<TT> Key</TT> to have:
<BR>A default constructor (<TT> Key::Key()</TT> ).
<BR><BR>A well defined copy constructor (<TT> Key::Key( const Key &amp; )</TT> ).
<BR><BR>A well defined assignment operator (<TT> Key &amp; operator =( const Key &amp; )</TT> ).
<BR><BR>A well defined equivalence operator with constant parameters
<BR><BR>(<TT> int operator ==( const Key &amp; ) const</TT> ).
<BR>The<TT> WCValHashDict&lt;Key,Value&gt;</TT> class requires<TT> Value</TT> to have:
<BR><BR>A default constructor (<TT> Value::Value()</TT> ).
<BR><BR>A well defined copy constructor (<TT> Value::Value( const Value &amp; )</TT> ).
<BR><BR>A well defined assignment operator (<TT> Value &amp; operator =( const Value &amp; )</TT> ).
<BR><BR><B>Public Member Functions</B>
<BR><BR>The following member functions are declared in the public interface:
<BR><BR><TT>WCValHashDict( unsigned (*hash_fn)( const Key &amp; ), unsigned = WC_DEFAULT_HASH_SIZE );</TT>
<BR><TT> WCValHashDict( unsigned (*hash_fn)( const Key &amp; ), unsigned = WC_DEFAULT_HASH_SIZE, void * (*user_alloc)( size_t
size ), void (*user_dealloc)( void *old, size_t size ) );</TT>
<BR><TT> WCValHashDict( const WCValHashDict &amp; );</TT>
<BR><TT> virtual ~WCValHashDict();</TT>
<BR><TT> static unsigned bitHash( const void *, size_t );</TT>
<BR><TT> unsigned buckets() const;</TT>
<BR><TT> void clear();</TT>
<BR><TT> int contains( const Key &amp; ) const;</TT>
<BR><TT> unsigned entries() const;</TT>
<BR><TT> int find( const Key &amp;, Value &amp; ) const;</TT>
<BR><TT> int findKeyAndValue( const Key &amp;, Key &amp;, Value &amp; ) const;</TT>
<BR><TT> void forAll( void (*user_fn)( Key, Value, void * ), void * );</TT>
<BR><TT> int insert( const Key &amp;, const Value &amp; );</TT>
<BR><TT> int isEmpty() const;</TT>
<BR><TT> int remove( const Key &amp; );</TT>
<BR><TT> void resize( unsigned );</TT>
<BR><BR><B>Public Member Operators</B>
<BR><BR>The following member operators are declared in the public interface:
<BR><BR><TT>Value &amp; operator []( const Key &amp; );</TT>
<BR><TT> const Value &amp; operator []( const Key &amp; ) const;</TT>
<BR><TT> WCValHashDict &amp; operator =( const WCValHashDict &amp; );</TT>
<BR><TT> int operator ==( const WCValHashDict &amp; ) const;</TT>
</DL>
<H2 ID="WCValHashDictXKey_ValueY__WCValHashDictLR"> WCValHashDict() [WCValHashDict&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCValHashDict( unsigned (*hash_fn)( const Key &amp; ),</TT>
<BR><TT> unsigned = WC_DEFAULT_HASH_SIZE );</TT>
<DT>Semantics:
<DD>The public<TT> WCValHashDict&lt;Key,Value&gt;</TT> constructor creates an<TT> WCValHashDict&lt;Key,Value&gt;</TT> object with
no entries and with the number of buckets in the second optional parameter, which defaults to the constant<TT> WC_DEFAULT_HASH_SIZE</TT>
(currently defined as 101).&nbsp; The number of buckets specified must be greater than zero, and will be forced to at least
one.&nbsp; If the hash dictionary object can be created, but an allocation failure occurs when creating the buckets, the table
will be created with zero buckets.&nbsp; If the<TT> out_of_memory</TT> exception is enabled, then attempting to insert into
a hash table with zero buckets with throw an<TT> out_of_memory</TT> error.
<BR><BR>The hash function<TT> hash_fn</TT> is used to determine which bucket each key-value pair will be assigned.&nbsp; If
no hash function exists, the static member function<TT> bitHash</TT> is available to help create one.
<DT>Results:
<DD>The public<TT> WCValHashDict&lt;Key,Value&gt;</TT> constructor creates an initialized<TT> WCValHashDict&lt;Key,Value&gt;</TT>
object with the specified number of buckets and hash function.
<DT>See Also:
<DD><TT> ~WCValHashDict</TT>,<TT> bitHash</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCValHashDict( unsigned (*hash_fn)( const Key &amp; ),</TT>
<BR><TT> unsigned = WC_DEFAULT_HASH_SIZE,</TT>
<BR><TT>void * (*user_alloc)( size_t ),</TT>
<BR><TT>void (*user_dealloc)( void *, size_t ) );</TT>
<DT>Semantics:
<DD>Allocator and deallocator functions are specified for use when entries are inserted and removed from the hash dictionary.
&nbsp;The semantics of this constructor are the same as the constructor without the memory management functions.
<BR><BR>The allocation function must return a zero if it cannot perform the allocation.&nbsp; The deallocation function is
passed the size as well as the pointer to the data.&nbsp; Your allocation system may take advantage of the characteristic
that the allocation function will always be called with the same size value for any particular instantiation of a hash dictionary.
&nbsp;To determine the size of the objects that the memory management functions will be required to allocate and free, the
following macro may be used:
<BR><BR><TT>WCValHashDictItemSize( Key, Value )</TT>
<DT>Results:
<DD>The public<TT> WCValHashDict&lt;Key,Value&gt;</TT> constructor creates an initialized<TT> WCValHashDict&lt;Key,Value&gt;</TT>
object with the specified number of buckets and hash function.
<DT>See Also:
<DD><TT> ~WCValHashDict</TT>,<TT> bitHash</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCValHashDict( const WCValHashDict &amp; );</TT>
<DT>Semantics:
<DD>The public<TT> WCValHashDict&lt;Key,Value&gt;</TT> constructor is the copy constructor for the<TT> WCValHashDict&lt;Key,Value&gt;</TT>
class.&nbsp; The new dictionary is created with the same number of buckets, hash function, all values or pointers stored in
the dictionary, and the exception trap states.&nbsp; If the hash dictionary object can be created, but an allocation failure
occurs when creating the buckets, the table will be created with zero buckets.&nbsp; If there is not enough memory to copy
all of the values in the dictionary, then only some will be copied, and the number of entries will correctly reflect the number
copied.&nbsp; If all of the elements cannot be copied, then the<TT> out_of_memory</TT> exception is thrown if it is enabled.
<DT>Results:
<DD>The public<TT> WCValHashDict&lt;Key,Value&gt;</TT> constructor creates an<TT> WCValHashDict&lt;Key,Value&gt;</TT> object which
is a copy of the passed dictionary.
<DT>See Also:
<DD><TT> ~WCValHashDict</TT>,<TT> operator =</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<H2 ID="WCValHashDictXKey_ValueY____WCValHashDictLR"> ~WCValHashDict() [WCValHashDict&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>virtual ~WCValHashDict();</TT>
<DT>Semantics:
<DD>The public<TT> ~WCValHashDict&lt;Key,Value&gt;</TT> destructor is the destructor for the<TT> WCValHashDict&lt;Key,Value&gt;</TT>
class.&nbsp; If the number of dictionary elements is not zero and the<TT> not_empty</TT> exception is enabled, the exception
is thrown.&nbsp; Otherwise, the dictionary elements are cleared using the<TT> clear</TT> member function.&nbsp; The call to
the public<TT> ~WCValHashDict&lt;Key,Value&gt;</TT> destructor is inserted implicitly by the compiler at the point where the<TT>
WCValHashDict&lt;Key,Value&gt;</TT> object goes out of scope.
<DT>Results:
<DD>The public<TT> ~WCValHashDict&lt;Key,Value&gt;</TT> destructor destroys an<TT> WCValHashDict&lt;Key,Value&gt;</TT> object.
<DT>See Also:
<DD><TT> clear</TT>,<TT> WCExcept::not_empty</TT>
</DL>
<H2 ID="WCValHashDictXKey_ValueY__bitHashLR"> bitHash() [WCValHashDict&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>static unsigned bitHash( void *, size_t );</TT>
<DT>Semantics:
<DD>The<TT> bitHash</TT> public member function can be used to implement a hashing function for any type.&nbsp; A hashing value
is generated from the value stored for the number of specified bytes pointed to by the first parameter.&nbsp; For example:
<BR><BR><TT>unsigned my_hash_fn( const int &amp; key ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; return( WCValHashDict&lt;int,String&gt;::bitHash( &amp;key, sizeof( int ) );</TT>
<BR><TT>}</TT>
<BR><TT>WCValHashDict&lt;int,String&gt; data_object( &amp;my_hash_fn );</TT>
<DT>Results:
<DD>The<TT> bitHash</TT> public member function returns an unsigned value which can be used as the basis of a user defined hash
function.
<DT>See Also:
<DD><TT> WCValHashDict</TT>
</DL>
<H2 ID="WCValHashDictXKey_ValueY__bucketsLR"> buckets() [WCValHashDict&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>unsigned buckets const;</TT>
<DT>Semantics:
<DD>The<TT> buckets</TT> public member function is used to find the number of buckets contained in the<TT> WCValHashDict&lt;Key,Value&gt;</TT>
object.
<DT>Results:
<DD>The<TT> buckets</TT> public member function returns the number of buckets in the dictionary.
<DT>See Also:
<DD><TT> resize</TT>
</DL>
<H2 ID="WCValHashDictXKey_ValueY__clearLR"> clear() [WCValHashDict&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void clear();</TT>
<DT>Semantics:
<DD>The<TT> clear</TT> public member function is used to clear the dictionary so that it has no entries.&nbsp; The number of buckets
remain unaffected.&nbsp; Elements stored in the dictionary are destroyed using the destructors of<TT> Key</TT> and of<TT>
Value.</TT>&nbsp; The dictionary object is not destroyed and re-created by this function, so the object destructor is not
invoked.
<DT>Results:
<DD>The<TT> clear</TT> public member function clears the dictionary to have no elements.
<DT>See Also:
<DD><TT> ~WCValHashDict</TT>,<TT> operator =</TT>
</DL>
<H2 ID="WCValHashDictXKey_ValueY__containsLR"> contains() [WCValHashDict&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int contains( const Key &amp; ) const;</TT>
<DT>Semantics:
<DD>The<TT> contains</TT> public member function returns non-zero if an element with the specified key is stored in the dictionary,
or zero if there is no equivalent element.&nbsp; Note that equivalence is based on the equivalence operator of the<TT> Key</TT>
type.
<DT>Results:
<DD>The<TT> contains</TT> public member function returns a non-zero value if the<TT> Key</TT> is found in the dictionary.
<DT>See Also:
<DD><TT> find</TT>,<TT> findKeyAndValue</TT>
</DL>
<H2 ID="WCValHashDictXKey_ValueY__entriesLR"> entries() [WCValHashDict&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>unsigned entries() const;</TT>
<DT>Semantics:
<DD>The<TT> entries</TT> public member function is used to return the current number of elements stored in the dictionary.
<DT>Results:
<DD>The<TT> entries</TT> public member function returns the number of elements in the dictionary.
<DT>See Also:
<DD><TT> buckets</TT>,<TT> isEmpty</TT>
</DL>
<H2 ID="WCValHashDictXKey_ValueY__findLR"> find() [WCValHashDict&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int find( const Key &amp;, Value &amp; ) const;</TT>
<DT>Semantics:
<DD>The<TT> find</TT> public member function is used to find an element with an equivalent key in the dictionary.&nbsp; If an
equivalent element is found, a non-zero value is returned.&nbsp; The reference to a<TT> Value</TT> passed as the second argument
is assigned the found element's<TT> Value.</TT>&nbsp; Zero is returned if the element is not found.&nbsp; Note that equivalence
is based on the equivalence operator of the<TT> Key</TT> type.
<DT>Results:
<DD>The element equivalent to the passed key is located in the dictionary.
<DT>See Also:
<DD><TT> findKeyAndValue</TT>
</DL>
<H2 ID="WCValHashDictXKey_ValueY__findKeyAndValueLR"> findKeyAndValue() [WCValHashDict&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int findKeyAndValue( const Key &amp;, Key &amp;, Value &amp; ) const;</TT>
<DT>Semantics:
<DD>The<TT> findKeyAndValue</TT> public member function is used to find an element in the dictionary with an key equivalent to
the first parameter.&nbsp; If an equivalent element is found, a non-zero value is returned.&nbsp; The reference to a<TT> Key</TT>
passed as the second parameter is assigned the found element's key.&nbsp; The reference to a<TT> Value</TT> passed as the
third argument is assigned the found element's<TT> Value.</TT>&nbsp; Zero is returned if the element is not found.&nbsp; Note
that equivalence is based on the equivalence operator of the<TT> Key</TT> type.
<DT>Results:
<DD>The element equivalent to the passed key is located in the dictionary.
<DT>See Also:
<DD><TT> findKeyAndValue</TT>
</DL>
<H2 ID="WCValHashDictXKey_ValueY__forAllLR"> forAll() [WCValHashDict&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void forAll(</TT>
<BR><TT> void (*user_fn)( Key, Value, void * ),</TT>
<BR><TT>void * );</TT>
<DT>Semantics:
<DD>The<TT> forAll</TT> public member function causes the user supplied function to be invoked for every key-value pair in the
dictionary.&nbsp; The user function has the prototype
<BR><BR><TT>void user_func( Key key, Value value, void * data );</TT>
<BR><BR>As the elements are visited, the user function is invoked with the<TT> Key</TT> and<TT> Value</TT> components of the
element passed as the first two parameters.&nbsp; The second parameter of the<TT> forAll</TT> function is passed as the third
parameter to the user function.&nbsp; This value can be used to pass any appropriate data from the main code to the user function.
<DT>Results:
<DD>The elements in the dictionary are all visited, with the user function being invoked for each one.
<DT>See Also:
<DD><TT> find</TT>,<TT> findKeyAndValue</TT>
</DL>
<H2 ID="WCValHashDictXKey_ValueY__insertLR"> insert() [WCValHashDict&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int insert( const Key &amp;, const Value &amp; );</TT>
<DT>Semantics:
<DD>The<TT> insert</TT> public member function inserts a key and value into the dictionary, using the hash function on the key
to determine to which bucket it should be stored.&nbsp; If allocation of the node to store the key-value pair fails, then
the<TT> out_of_memory</TT> exception is thrown if it is enabled.&nbsp; If the exception is not enabled, the insert will not
be completed.
<BR><BR>At some point, the number of buckets initially selected may be too small for the number of elements inserted.&nbsp;
The resize of the dictionary can be controlled by the insertion mechanism by using<TT> WCValHashDict</TT> as a base class,
and providing an insert member function to do a resize when appropriate.&nbsp; This insert could then call<TT> WCValHashDict::insert</TT>
to insert the element.&nbsp; Note that copy constructors and assignment operators are not inherited in your class, but you
can provide the following inline definitions (assuming that the class inherited from WCValHashDict is named MyHashDict):
<BR><BR><TT>inline MyHashDict( const MyHashDict &amp;orig ) : WCValHashDict( orig ) {};</TT>
<BR><TT>inline MyHashDict &amp;operator=( const MyHashDict &amp;orig ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; return( WCValHashDict::operator=( orig ) );</TT>
<BR><TT>}</TT>
<DT>Results:
<DD>The<TT> insert</TT> public member function inserts a key and value into the dictionary.&nbsp; If the insert is successful,
a non-zero will returned.&nbsp; A zero will be returned if the insert fails.
<DT>See Also:
<DD><TT> operator =</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<H2 ID="WCValHashDictXKey_ValueY__isEmptyLR"> isEmpty() [WCValHashDict&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int isEmpty() const;</TT>
<DT>Semantics:
<DD>The<TT> isEmpty</TT> public member function is used to determine if the dictionary is empty.
<DT>Results:
<DD>The<TT> isEmpty</TT> public member function returns zero if it contains at least one entry, non-zero if the dictionary is
empty.
<DT>See Also:
<DD><TT> buckets</TT>,<TT> entries</TT>
</DL>
<H2 ID="WCValHashDictXKey_ValueY__operator_UVLR"> operator []() [WCValHashDict&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Value &amp; operator[]( const Key &amp; );</TT>
<DT>Semantics:
<DD><TT> operator []</TT> is the dictionary index operator.&nbsp; A reference to the object stored in the dictionary with the
given<TT> Key</TT> is returned.&nbsp; If no equivalent element is found, then a new key-value pair is created with the specified<TT>
Key</TT> value, and initialized with the default constructor.&nbsp; The returned reference can then be assigned to, so that
insertions can be made with the operator.
<BR><BR><TT>WCValHashDict&lt;int,String&gt; data_object( &amp;my_hash_fn );</TT>
<BR><TT>data_object[ 5 ] = &quot;Hello&quot;;</TT>
<BR><BR>If an allocation error occurs while inserting a new key-value pair, then the<TT> out_of_memory</TT> exception is thrown
if it is enabled.&nbsp; If the exception is not enabled, then a reference to address zero will be returned.&nbsp; This will
result in a run-time error on systems which trap address zero references.
<DT>Results:
<DD>The<TT> operator []</TT> public member function returns a reference to the element at the given key value.&nbsp; If the key
does not exist, a reference to a created element is returned.&nbsp; The result of the operator may be assigned to.
<DT>See Also:
<DD><TT> WCExcept::out_of_memory</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>const Value &amp; operator[]( const Key &amp; ) const;</TT>
<DT>Semantics:
<DD><TT> operator []</TT> is the dictionary index operator.&nbsp; A constant reference to the object stored in the dictionary
with the given<TT> Key</TT> is returned.&nbsp; If no equivalent element is found, then the<TT> index_range</TT> exception
is thrown if it is enabled.&nbsp; If the exception is not enabled, then a reference to address zero will be returned.&nbsp;
This will result in a run-time error on systems which trap address zero references.
<DT>Results:
<DD>The<TT> operator []</TT> public member function returns a constant reference to the element at the given key value.&nbsp;
The result of the operator may not be assigned to.
<DT>See Also:
<DD><TT> WCExcept::index_range</TT>
</DL>
<H2 ID="WCValHashDictXKey_ValueY__operator_ELR"> operator =() [WCValHashDict&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCValHashDict &amp; operator =( const WCValHashDict &amp; );</TT>
<DT>Semantics:
<DD>The<TT> operator =</TT> public member function is the assignment operator for the<TT> WCValHashDict&lt;Key,Value&gt;</TT>
class.&nbsp; The left hand side dictionary is first cleared using the<TT> clear</TT> member function, and then the right hand
side dictionary is copied.&nbsp; The hash function, exception trap states, and all of the dictionary elements are copied.
&nbsp;If an allocation failure occurs when creating the buckets, the table will be created with zero buckets, and the<TT>
out_of_memory</TT> exception is thrown if it is enabled.&nbsp; If there is not enough memory to copy all of the values or
pointers in the dictionary, then only some will be copied, and the<TT> out_of_memory</TT> exception is thrown if it is enabled.
&nbsp;The number of entries will correctly reflect the number copied.
<DT>Results:
<DD>The<TT> operator =</TT> public member function assigns the left hand side dictionary to be a copy of the right hand side.
<DT>See Also:
<DD><TT> clear</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<H2 ID="WCValHashDictXKey_ValueY__operator_EELR"> operator ==() [WCValHashDict&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int operator ==( const WCValHashDict &amp; ) const;</TT>
<DT>Semantics:
<DD>The<TT> operator ==</TT> public member function is the equivalence operator for the<TT> WCValHashDict&lt;Key,Value&gt;</TT>
class.&nbsp; Two dictionary objects are equivalent if they are the same object and share the same address.
<DT>Results:
<DD>A TRUE (non-zero) value is returned if the left hand side and right hand side dictionary are the same object.&nbsp; A FALSE
(zero) value is returned otherwise.
</DL>
<H2 ID="WCValHashDictXKey_ValueY__removeLR"> remove() [WCValHashDict&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int remove( const Key &amp; );</TT>
<DT>Semantics:
<DD>The<TT> remove</TT> public member function is used to remove the specified element from the dictionary.&nbsp; If an equivalent
element is found, a non-zero value is returned.&nbsp; Zero is returned if the element is not found.&nbsp; Note that equivalence
is based on the equivalence operator of the<TT> Key</TT> type.
<DT>Results:
<DD>The element is removed from the dictionary if it found.
</DL>
<H2 ID="WCValHashDictXKey_ValueY__resizeLR"> resize() [WCValHashDict&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void resize( unsigned );</TT>
<DT>Semantics:
<DD>The<TT> resize</TT> public member function is used to change the number of buckets contained in the dictionary.&nbsp; If the
new number is larger than the previous dictionary size, then the hash function will be used on all of the stored elements
to determine which bucket they should be stored into.&nbsp; Entries are not destroyed or created in the process of being moved.
&nbsp;If there is not enough memory to resize the dictionary, the<TT> out_of_memory</TT> exception is thrown if it is enabled,
and the dictionary will contain the number of buckets it contained before the resize.&nbsp; If the new number is zero, then
the<TT> zero_buckets</TT> exception is thrown if it is enabled, and no resize will be performed.&nbsp; The dictionary is guaranteed
to contain the same number of entries after the resize.
<DT>Results:
<DD>The dictionary is resized to the new number of buckets.
<DT>See Also:
<DD><TT> WCExcept::out_of_memory</TT>,<TT> WCExcept::zero_buckets</TT>
</DL>
<H2 ID="WCValHashTableXTypeY__WCValHashSetXTypeY_Class_Description"> WCValHashTable&lt;Type&gt;, WCValHashSet&lt;Type&gt; Class Description </H2>
<DL>
<DT>Declared:
<DD><TT> wchash.h</TT>
<BR><BR><TT>WCValHashTable&lt;Type&gt;</TT> and<TT> WCValHashSet&lt;Type&gt;</TT> classes are templated classes used to store
objects in a hash.&nbsp; A hash saves objects in such a way as to make it efficient to locate and retrieve an element.&nbsp;
As an element is looked up or inserted into the hash, the value of the element is hashed.&nbsp; Hashing results in a numeric
index which is used to locate the value.&nbsp; The storage area referenced by the hash value is usually called a bucket.&nbsp;
If more than one element results in the same hash, the value associated with the hash is placed in a list stored in the bucket.
&nbsp;A hash table allows more than one copy of an element that is equivalent, while the hash set allows only one copy.&nbsp;
The equality operator of the element's type is used to locate the value.
<BR>In the description of each member function, the text<TT> Type</TT> is used to indicate the template parameter defining
the type of the data to be stored in the hash.
<BR><BR>The constructor for the<TT> WCValHashTable&lt;Type&gt;</TT> and<TT> WCValHashSet&lt;Type&gt;</TT> classes requires
a hashing function, which given a reference to<TT> Type,</TT> returns an<TT> unsigned</TT> value.&nbsp; The returned value
modulo the number of buckets determines the bucket into which the element will be located.&nbsp; The return values of the
hash function can be spread over the entire range of unsigned numbers.&nbsp; The hash function return value must be the same
for values which are equivalent by the equivalence operator for<TT> Type.</TT>
<BR><BR>Values are copied into the hash, which could be undesirable if the stored objects are complicated and copying is expensive.
&nbsp;Value hashes should not be used to store objects of a base class if any derived types of different sizes would be stored
in the hash, or if the destructor for a derived class must be called.
<BR><BR>The<TT> WCExcept</TT> class is a base class of the<TT> WCValHashTable&lt;Type&gt;</TT> and<TT> WCValHashSet&lt;Type&gt;</TT>
classes and provides the<TT> exceptions</TT> member function.&nbsp; This member function controls the exceptions which can
be thrown by the<TT> WCValHashTable&lt;Type&gt;</TT> and<TT> WCValHashSet&lt;Type&gt;</TT> objects.&nbsp; No exceptions are
enabled unless they are set by the<TT> exceptions</TT> member function.
<BR><BR><B>Requirements of Type</B>
<BR><BR>The<TT> WCValHashTable&lt;Type&gt;</TT> and<TT> WCValHashSet&lt;Type&gt;</TT> classes requires<TT> Type</TT> to have:
<BR>A default constructor (<TT> Type::Type()</TT> ).
<BR><BR>A well defined copy constructor (<TT> Type::Type( const Type &amp; )</TT> ).
<BR><BR>A well defined assignment operator (<TT> Type &amp; operator =( const Type &amp; )</TT> ).
<BR><BR>A well defined equivalence operator with constant parameters
<BR><BR>(<TT> int operator ==( const Type &amp; ) const</TT> ).
<BR><BR><B>Public Member Functions</B>
<BR><BR>The following member functions are declared in the public interface:
<BR><BR><TT>WCValHashSet( unsigned (*hash_fn)( const Type &amp; ), unsigned = WC_DEFAULT_HASH_SIZE );</TT>
<BR><TT> WCValHashSet( unsigned (*hash_fn)( const Type &amp; ), unsigned = WC_DEFAULT_HASH_SIZE, void * (*user_alloc)( size_t
size ), void (*user_dealloc)( void *old, size_t size ) );</TT>
<BR><TT> WCValHashSet( const WCValHashSet &amp; );</TT>
<BR><TT> virtual ~WCValHashSet();</TT>
<BR><TT> WCValHashTable( unsigned (*hash_fn)( const Type &amp; ), unsigned = WC_DEFAULT_HASH_SIZE );</TT>
<BR><TT> WCValHashTable( unsigned (*hash_fn)( const Type &amp; ), unsigned = WC_DEFAULT_HASH_SIZE, void * (*user_alloc)( size_t
size ), void (*user_dealloc)( void *old, size_t size ) );</TT>
<BR><TT> WCValHashTable( const WCValHashTable &amp; );</TT>
<BR><TT> virtual ~WCValHashTable();</TT>
<BR><TT> static unsigned bitHash( const void *, size_t );</TT>
<BR><TT> unsigned buckets() const;</TT>
<BR><TT> void clear();</TT>
<BR><TT> int contains( const Type &amp; ) const;</TT>
<BR><TT> unsigned entries() const;</TT>
<BR><TT> int find( const Type &amp;, Type &amp; ) const;</TT>
<BR><TT> void forAll( void (*user_fn)( Type, void * ), void * );</TT>
<BR><TT> int insert( const Type &amp; );</TT>
<BR><TT> int isEmpty() const;</TT>
<BR><TT> int remove( const Type &amp; );</TT>
<BR><TT> void resize( unsigned );</TT>
<BR><BR>The following public member functions are available for the<TT> WCValHashTable</TT> class only:
<BR><BR><TT>unsigned occurrencesOf( const Type &amp; ) const;</TT>
<BR><TT> unsigned removeAll( const Type &amp; );</TT>
<BR><BR><B>Public Member Operators</B>
<BR><BR>The following member operators are declared in the public interface:
<BR><BR><TT>WCValHashSet &amp; operator =( const WCValHashSet &amp; );</TT>
<BR><TT> int operator ==( const WCValHashSet &amp; ) const;</TT>
<BR><TT> WCValHashTable &amp; operator =( const WCValHashTable &amp; );</TT>
<BR><TT> int operator ==( const WCValHashTable &amp; ) const;</TT>
</DL>
<H2 ID="WCValHashSetXTypeY__WCValHashSetLR"> WCValHashSet() [WCValHashSet&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCValHashSet( unsigned (*hash_fn)( const Type &amp; ),</TT>
<BR><TT> unsigned = WC_DEFAULT_HASH_SIZE );</TT>
<DT>Semantics:
<DD>The<TT> WCValHashSet&lt;Type&gt;</TT> constructor creates a<TT> WCValHashSet</TT> object with no entries and with the number
of buckets in the second optional parameter, which defaults to the constant<TT> WC_DEFAULT_HASH_SIZE</TT> (currently defined
as 101).&nbsp; The number of buckets specified must be greater than zero, and will be forced to at least one.&nbsp; If the
hash object can be created, but an allocation failure occurs when creating the buckets, the table will be created with zero
buckets.&nbsp; If the<TT> out_of_memory</TT> exception is enabled, then attempting to insert into a hash table with zero buckets
with throw an<TT> out_of_memory</TT> error.
<BR><BR>The hash function<TT> hash_fn</TT> is used to determine which bucket each value will be assigned to.&nbsp; If no hash
function exists, the static member function<TT> bitHash</TT> is available to help create one.
<DT>Results:
<DD>The<TT> WCValHashSet&lt;Type&gt;</TT> constructor creates an initialized<TT> WCValHashSet</TT> object with the specified number
of buckets and hash function.
<DT>See Also:
<DD><TT> ~WCValHashSet</TT>,<TT> bitHash</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCValHashSet( unsigned (*hash_fn)( const Type &amp; ),</TT>
<BR><TT> unsigned = WC_DEFAULT_HASH_SIZE,</TT>
<BR><TT>void * (*user_alloc)( size_t ),</TT>
<BR><TT>void (*user_dealloc)( void *, size_t ) );</TT>
<DT>Semantics:
<DD>Allocator and deallocator functions are specified for use when entries are inserted and removed from the hash.&nbsp; The semantics
of this constructor are the same as the constructor without the memory management functions.
<BR><BR>The allocation function must return a zero if it cannot perform the allocation.&nbsp; The deallocation function is
passed the size as well as the pointer to the data.&nbsp; Your allocation system may take advantage of the characteristic
that the allocation function will always be called with the same size value for any particular instantiation of a hash.&nbsp;
To determine the size of the objects that the memory management functions will be required to allocate and free, the following
macro may be used:
<BR><BR><TT>WCValHashSetItemSize( Type )</TT>
<DT>Results:
<DD>The<TT> WCValHashSet&lt;Type&gt;</TT> constructor creates an initialized<TT> WCValHashSet</TT> object with the specified number
of buckets and hash function.
<DT>See Also:
<DD><TT> ~WCValHashSet</TT>,<TT> bitHash</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCValHashSet( const WCValHashSet &amp; );</TT>
<DT>Semantics:
<DD>The<TT> WCValHashSet&lt;Type&gt;</TT> is the copy constructor for the<TT> WCValHashSet</TT> class.&nbsp; The new hash is created
with the same number of buckets, hash function, all values or pointers stored in the hash, and the exception trap states.
&nbsp;If the hash object can be created, but an allocation failure occurs when creating the buckets, the hash will be created
with zero buckets.&nbsp; If there is not enough memory to copy all of the values, then only some will be copied, and the number
of entries will correctly reflect the number copied.&nbsp; If all of the elements cannot be copied, then the<TT> out_of_memory</TT>
exception is thrown if it is enabled.
<DT>Results:
<DD>The<TT> WCValHashSet&lt;Type&gt;</TT> constructor creates a<TT> WCValHashSet</TT> object which is a copy of the passed hash.
<DT>See Also:
<DD><TT> ~WCValHashSet</TT>,<TT> operator =</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<H2 ID="WCValHashSetXTypeY____WCValHashSetLR"> ~WCValHashSet() [WCValHashSet&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>virtual ~WCValHashSet();</TT>
<DT>Semantics:
<DD>The<TT> WCValHashSet&lt;Type&gt;</TT> destructor is the destructor for the<TT> WCValHashSet</TT> class.&nbsp; If the number
of elements is not zero and the<TT> not_empty</TT> exception is enabled, the exception is thrown.&nbsp; Otherwise, the hash
elements are cleared using the<TT> clear</TT> member function.&nbsp; The call to the<TT> WCValHashSet&lt;Type&gt;</TT> destructor
is inserted implicitly by the compiler at the point where the<TT> WCValHashSet</TT> object goes out of scope.
<DT>Results:
<DD>The call to the<TT> WCValHashSet&lt;Type&gt;</TT> destructor destroys a<TT> WCValHashSet</TT> object.
<DT>See Also:
<DD><TT> clear</TT>,<TT> WCExcept::not_empty</TT>
</DL>
<H2 ID="WCValHashTableXTypeY__WCValHashTableLR"> WCValHashTable() [WCValHashTable&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCValHashTable( unsigned (*hash_fn)( const Type &amp; ),</TT>
<BR><TT> unsigned = WC_DEFAULT_HASH_SIZE );</TT>
<DT>Semantics:
<DD>The<TT> WCValHashTable&lt;Type&gt;</TT> constructor creates a<TT> WCValHashTable</TT> object with no entries and with the
number of buckets in the second optional parameter, which defaults to the constant<TT> WC_DEFAULT_HASH_SIZE</TT> (currently
defined as 101).&nbsp; The number of buckets specified must be greater than zero, and will be forced to at least one.&nbsp;
If the hash object can be created, but an allocation failure occurs when creating the buckets, the table will be created with
zero buckets.&nbsp; If the<TT> out_of_memory</TT> exception is enabled, then attempting to insert into a hash table with zero
buckets with throw an<TT> out_of_memory</TT> error.
<BR><BR>The hash function<TT> hash_fn</TT> is used to determine which bucket each value will be assigned to.&nbsp; If no hash
function exists, the static member function<TT> bitHash</TT> is available to help create one.
<DT>Results:
<DD>The<TT> WCValHashTable&lt;Type&gt;</TT> constructor creates an initialized<TT> WCValHashTable</TT> object with the specified
number of buckets and hash function.
<DT>See Also:
<DD><TT> ~WCValHashTable</TT>,<TT> bitHash</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCValHashTable( unsigned (*hash_fn)( const Type &amp; ),</TT>
<BR><TT> unsigned = WC_DEFAULT_HASH_SIZE,</TT>
<BR><TT>void * (*user_alloc)( size_t ),</TT>
<BR><TT>void (*user_dealloc)( void *, size_t ) );</TT>
<DT>Semantics:
<DD>Allocator and deallocator functions are specified for use when entries are inserted and removed from the hash.&nbsp; The semantics
of this constructor are the same as the constructor without the memory management functions.
<BR><BR>The allocation function must return a zero if it cannot perform the allocation.&nbsp; The deallocation function is
passed the size as well as the pointer to the data.&nbsp; Your allocation system may take advantage of the characteristic
that the allocation function will always be called with the same size value for any particular instantiation of a hash.&nbsp;
To determine the size of the objects that the memory management functions will be required to allocate and free, the following
macro may be used:
<BR><BR><TT>WCValHashTableItemSize( Type )</TT>
<DT>Results:
<DD>The<TT> WCValHashTable&lt;Type&gt;</TT> constructor creates an initialized<TT> WCValHashTable</TT> object with the specified
number of buckets and hash function.
<DT>See Also:
<DD><TT> ~WCValHashTable</TT>,<TT> bitHash</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCValHashTable( const WCValHashTable &amp; );</TT>
<DT>Semantics:
<DD>The<TT> WCValHashTable&lt;Type&gt;</TT> is the copy constructor for the<TT> WCValHashTable</TT> class.&nbsp; The new hash
is created with the same number of buckets, hash function, all values or pointers stored in the hash, and the exception trap
states.&nbsp; If the hash object can be created, but an allocation failure occurs when creating the buckets, the hash will
be created with zero buckets.&nbsp; If there is not enough memory to copy all of the values, then only some will be copied,
and the number of entries will correctly reflect the number copied.&nbsp; If all of the elements cannot be copied, then the<TT>
out_of_memory</TT> exception is thrown if it is enabled.
<DT>Results:
<DD>The<TT> WCValHashTable&lt;Type&gt;</TT> constructor creates a<TT> WCValHashTable</TT> object which is a copy of the passed
hash.
<DT>See Also:
<DD><TT> ~WCValHashTable</TT>,<TT> operator =</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<H2 ID="WCValHashTableXTypeY____WCValHashTableLR"> ~WCValHashTable() [WCValHashTable&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>virtual ~WCValHashTable();</TT>
<DT>Semantics:
<DD>The<TT> WCValHashTable&lt;Type&gt;</TT> destructor is the destructor for the<TT> WCValHashTable</TT> class.&nbsp; If the number
of elements is not zero and the<TT> not_empty</TT> exception is enabled, the exception is thrown.&nbsp; Otherwise, the hash
elements are cleared using the<TT> clear</TT> member function.&nbsp; The call to the<TT> WCValHashTable&lt;Type&gt;</TT> destructor
is inserted implicitly by the compiler at the point where the<TT> WCValHashTable</TT> object goes out of scope.
<DT>Results:
<DD>The call to the<TT> WCValHashTable&lt;Type&gt;</TT> destructor destroys a<TT> WCValHashTable</TT> object.
<DT>See Also:
<DD><TT> clear</TT>,<TT> WCExcept::not_empty</TT>
</DL>
<H2 ID="WCValHashTableXTypeY__bitHashLR__WCValHashSetXTypeY__bitHashLR"> bitHash() [WCValHashTable&lt;Type&gt;,WCValHashSet&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>static unsigned bitHash( void *, size_t );</TT>
<DT>Semantics:
<DD>The<TT> bitHash</TT> public member function can be used to implement a hashing function for any type.&nbsp; A hashing value
is generated from the value stored for the number of specified bytes pointed to by the first parameter.&nbsp; For example:
<BR><BR><TT>unsigned my_hash_fn( const int &amp; elem ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; return( WCValHashSet&lt;int,String&gt;::bitHash(&amp;elem, sizeof(int));</TT>
<BR><TT>}</TT>
<BR><TT>WCValHashSet&lt;int&gt; data_object( &amp;my_hash_fn );</TT>
<DT>Results:
<DD>The<TT> bitHash</TT> public member function returns an unsigned value which can be used as the basis of a user defined hash
function.
<DT>See Also:
<DD><TT> WCValHashSet</TT>,<TT> WCValHashTable</TT>
</DL>
<H2 ID="WCValHashTableXTypeY__bucketsLR__WCValHashSetXTypeY__bucketsLR"> buckets() [WCValHashTable&lt;Type&gt;,WCValHashSet&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>unsigned buckets() const;</TT>
<DT>Semantics:
<DD>The<TT> buckets</TT> public member function is used to find the number of buckets contained in the hash object.
<DT>Results:
<DD>The<TT> buckets</TT> public member function returns the number of buckets in the hash.
<DT>See Also:
<DD><TT> resize</TT>
</DL>
<H2 ID="WCValHashTableXTypeY__clearLR__WCValHashSetXTypeY__clearLR"> clear() [WCValHashTable&lt;Type&gt;,WCValHashSet&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void clear();</TT>
<DT>Semantics:
<DD>The<TT> clear</TT> public member function is used to clear the hash so that it has no entries.&nbsp; The number of buckets
remain unaffected.&nbsp; Elements stored in the hash are destroyed using the destructors of<TT> Type.</TT>&nbsp; The hash
object is not destroyed and re-created by this function, so the object destructor is not invoked.
<DT>Results:
<DD>The<TT> clear</TT> public member function clears the hash to have no elements.
<DT>See Also:
<DD><TT> ~WCValHashSet</TT>,<TT> ~WCValHashTable</TT>,<TT> operator =</TT>
</DL>
<H2 ID="WCValHashTableXTypeY__containsLR__WCValHashSetXTypeY__containsLR"> contains() [WCValHashTable&lt;Type&gt;,WCValHashSet&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int contains( const Type &amp; ) const;</TT>
<DT>Semantics:
<DD>The<TT> contains</TT> public member function returns non-zero if the element is stored in the hash, or zero if there is no
equivalent element.&nbsp; Note that equivalence is based on the equivalence operator of the element type.
<DT>Results:
<DD>The<TT> contains</TT> public member function returns a non-zero value if the element is found in the hash.
<DT>See Also:
<DD><TT> find</TT>
</DL>
<H2 ID="WCValHashTableXTypeY__entriesLR__WCValHashSetXTypeY__entriesLR"> entries() [WCValHashTable&lt;Type&gt;,WCValHashSet&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>unsigned entries() const;</TT>
<DT>Semantics:
<DD>The<TT> entries</TT> public member function is used to return the current number of elements stored in the hash.
<DT>Results:
<DD>The<TT> entries</TT> public member function returns the number of elements in the hash.
<DT>See Also:
<DD><TT> buckets</TT>,<TT> isEmpty</TT>
</DL>
<H2 ID="WCValHashTableXTypeY__findLR__WCValHashSetXTypeY__findLR"> find() [WCValHashTable&lt;Type&gt;,WCValHashSet&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int find( const Type &amp;, Type &amp; ) const;</TT>
<DT>Semantics:
<DD>The<TT> find</TT> public member function is used to find an element with an equivalent key in the hash.&nbsp; If an equivalent
element is found, a non-zero value is returned.&nbsp; The reference to the element passed as the second argument is assigned
the found element's value.&nbsp; Zero is returned if the element is not found.&nbsp; Note that equivalence is based on the
equivalence operator of the element type.
<DT>Results:
<DD>The element equivalent to the passed key is located in the hash.
</DL>
<H2 ID="WCValHashTableXTypeY__forAllLR__WCValHashSetXTypeY__forAllLR"> forAll() [WCValHashTable&lt;Type&gt;,WCValHashSet&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void forAll(</TT>
<BR><TT> void (*user_fn)( Type, void * ),</TT>
<BR><TT>void * );</TT>
<DT>Semantics:
<DD>The<TT> forAll</TT> public member function causes the user supplied function to be invoked for every value in the hash.&nbsp;
The user function has the prototype
<BR><BR><TT>void user_func( Type &amp; value, void * data );</TT>
<BR><BR>As the elements are visited, the user function is invoked with the element passed as the first.&nbsp; The second parameter
of the<TT> forAll</TT> function is passed as the second parameter to the user function.&nbsp; This value can be used to pass
any appropriate data from the main code to the user function.
<DT>Results:
<DD>The elements in the hash are all visited, with the user function being invoked for each one.
<DT>See Also:
<DD><TT> find</TT>
</DL>
<H2 ID="WCValHashTableXTypeY__insertLR__WCValHashSetXTypeY__insertLR"> insert() [WCValHashTable&lt;Type&gt;,WCValHashSet&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int insert( const Type &amp; );</TT>
<DT>Semantics:
<DD>The<TT> insert</TT> public member function inserts a value into the hash, using the hash function to determine to which bucket
it should be stored.&nbsp; If allocation of the node to store the value fails, then the<TT> out_of_memory</TT> exception is
thrown if it is enabled.&nbsp; If the exception is not enabled, the insert will not be completed.
<BR><BR>With a<TT> WCValHashSet,</TT> there must be only one equivalent element in the set.&nbsp; If an element equivalent
to the inserted element is already in the hash set, the hash set will remain unchanged, and the<TT> not_unique</TT> exception
is thrown if it is enabled.&nbsp; If the exception is not enabled, the insert will not be completed.
<BR><BR>At some point, the number of buckets initially selected may be too small for the number of elements inserted.&nbsp;
The resize of the hash can be controlled by the insertion mechanism by using<TT> WCValHashSet</TT> (or<TT> WCValHashTable</TT>)
as a base class, and providing an insert member function to do a resize when appropriate.&nbsp; This insert could then call<TT>
WCValHashSet::insert</TT> (or<TT> WCValHashTable::insert</TT>) to insert the element.&nbsp; Note that copy constructors and
assignment operators are not inherited in your class, but you can provide the following inline definitions (assuming that
the class inherited from WCValHashTable is named MyHashTable):
<BR><BR><TT>inline MyHashTable( const MyHashTable &amp;orig )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; : WCValHashTable( orig ) {};</TT>
<BR><TT>inline MyHashTable &amp;operator=( const MyHashTable &amp;orig ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; return( WCValHashTable::operator=( orig ) );</TT>
<BR><TT>}</TT>
<DT>Results:
<DD>The<TT> insert</TT> public member function inserts a value into the hash.&nbsp; If the insert is successful, a non-zero will
returned.&nbsp; A zero will be returned if the insert fails.
<DT>See Also:
<DD><TT> operator =</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<H2 ID="WCValHashTableXTypeY__isEmptyLR__WCValHashSetXTypeY__isEmptyLR"> isEmpty() [WCValHashTable&lt;Type&gt;,WCValHashSet&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int isEmpty() const;</TT>
<DT>Semantics:
<DD>The<TT> isEmpty</TT> public member function is used to determine if the hash is empty.
<DT>Results:
<DD>The<TT> isEmpty</TT> public member function returns zero if it contains at least one entry, non-zero if the hash is empty.
<DT>See Also:
<DD><TT> buckets</TT>,<TT> entries</TT>
</DL>
<H2 ID="WCValHashTableXTypeY__occurencesOfLR"> occurencesOf() [WCValHashTable&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>unsigned occurrencesOf( const Type &amp; ) const;</TT>
<DT>Semantics:
<DD>The<TT> occurencesOf</TT> public member function is used to return the current number of elements stored in the hash which
are equivalent to the passed value.&nbsp; Note that equivalence is based on the equivalence operator of the element type.
<DT>Results:
<DD>The<TT> occurencesOf</TT> public member function returns the number of elements in the hash.
<DT>See Also:
<DD><TT> buckets</TT>,<TT> entries</TT>,<TT> find</TT>,<TT> isEmpty</TT>
</DL>
<H2 ID="WCValHashTableXTypeY__operator_ELR__WCValHashSetXTypeY__operator_ELR"> operator =() [WCValHashTable&lt;Type&gt;,WCValHashSet&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCValHashSet &amp; operator =( const WCValHashSet &amp; );</TT>
<BR><TT> WCValHashTable &amp; operator =( const WCValHashTable &amp; );</TT>
<DT>Semantics:
<DD>The<TT> operator =</TT> public member function is the assignment operator for the<TT> WCValHashTable&lt;Type&gt;</TT> and<TT>
WCValHashSet&lt;Type&gt;</TT> classes.&nbsp; The left hand side hash is first cleared using the<TT> clear</TT> member function,
and then the right hand side hash is copied.&nbsp; The hash function, exception trap states, and all of the hash elements
are copied.&nbsp; If an allocation failure occurs when creating the buckets, the table will be created with zero buckets,
and the<TT> out_of_memory</TT> exception is thrown if it is enabled.&nbsp; If there is not enough memory to copy all of the
values or pointers in the hash, then only some will be copied, and the<TT> out_of_memory</TT> exception is thrown if it is
enabled.&nbsp; The number of entries will correctly reflect the number copied.
<DT>Results:
<DD>The<TT> operator =</TT> public member function assigns the left hand side hash to be a copy of the right hand side.
<DT>See Also:
<DD><TT> clear</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<H2 ID="WCValHashTableXTypeY__operator_EELR__WCValHashSetXTypeY__operator_EELR"> operator ==() [WCValHashTable&lt;Type&gt;,WCValHashSet&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int operator ==( const WCValHashSet &amp; ) const;</TT>
<BR><TT> int operator ==( const WCValHashTable &amp; ) const;</TT>
<DT>Semantics:
<DD>The<TT> operator ==</TT> public member function is the equivalence operator for the<TT> WCValHashTable&lt;Type&gt;</TT> and<TT>
WCValHashSet&lt;Type&gt;</TT> classes.&nbsp; Two hash objects are equivalent if they are the same object and share the same
address.
<DT>Results:
<DD>A TRUE (non-zero) value is returned if the left hand side and right hand side hash are the same object.&nbsp; A FALSE (zero)
value is returned otherwise.
</DL>
<H2 ID="WCValHashTableXTypeY__removeLR__WCValHashSetXTypeY__removeLR"> remove() [WCValHashTable&lt;Type&gt;,WCValHashSet&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int remove( const Type &amp; );</TT>
<DT>Semantics:
<DD>The<TT> remove</TT> public member function is used to remove the specified element from the hash.&nbsp; If an equivalent element
is found, a non-zero value is returned.&nbsp; Zero is returned if the element is not found.&nbsp; If the hash is a table and
there is more than one element equivalent to the specified element, then the first equivalent element added to the table is
removed.&nbsp; Note that equivalence is based on the equivalence operator of the element type.
<DT>Results:
<DD>The element is removed from the hash if it found.
</DL>
<H2 ID="WCValHashTableXTypeY__removeAllLR"> removeAll() [WCValHashTable&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>unsigned removeAll( const Type &amp; );</TT>
<DT>Semantics:
<DD>The<TT> removeAll</TT> public member function is used to remove all elements equivalent to the specified element from the
hash.&nbsp; Zero is returned if no equivalent elements are found.&nbsp; Note that equivalence is based on the equivalence
operator of the element type.
<DT>Results:
<DD>All equivalent elements are removed from the hash.
</DL>
<H2 ID="WCValHashTableXTypeY__resizeLR__WCValHashSetXTypeY__resizeLR"> resize() [WCValHashTable&lt;Type&gt;,WCValHashSet&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchash.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void resize( unsigned );</TT>
<DT>Semantics:
<DD>The<TT> resize</TT> public member function is used to change the number of buckets contained in the hash.&nbsp; If the new
number is larger than the previous hash size, then the hash function will be used on all of the stored elements to determine
which bucket they should be stored into.&nbsp; Entries are not destroyed or created in the process of being moved.&nbsp; If
there is not enough memory to resize the hash, the<TT> out_of_memory</TT> exception is thrown if it is enabled, and the hash
will contain the number of buckets it contained before the resize.&nbsp; If the new number is zero, then the<TT> zero_buckets</TT>
exception is thrown if it is enabled, and no resize will be performed.&nbsp; The hash is guaranteed to contain the same number
of entries after the resize.
<DT>Results:
<DD>The hash is resized to the new number of buckets.
<DT>See Also:
<DD><TT> WCExcept::out_of_memory</TT>,<TT> WCExcept::zero_buckets</TT>
</DL>
<H1 ID="Hash_Iterators"> Hash Iterators </H1>
<BR>Hash iterators are used to step through a hash one or more elements at a time.&nbsp; Iterators which are newly constructed
or reset are positioned before the first element in the hash.&nbsp; The hash may be traversed one element at a time using
the pre-increment or call operator.&nbsp; An increment operation causing the iterator to be positioned after the end of the
hash returns zero.&nbsp; Further increments will cause the<TT> undef_iter</TT> exception to be thrown, if it is enabled.&nbsp;
The<TT> WCIterExcept</TT> class provides the common exception handling control interface for all of the iterators.
<BR><BR>Since the iterator classes are all template classes, most of the functionality was derived from common base classes.
&nbsp;In the listing of class member functions, those public member functions which appear to be in the iterator class but
are actually defined in the common base class are identified as if they were explicitly specified in the iterator class.
<H2 ID="WCPtrHashDictIterXKey_ValueY_Class_Description"> WCPtrHashDictIter&lt;Key,Value&gt; Class Description </H2>
<DL>
<DT>Declared:
<DD><TT> wchiter.h</TT>
<BR><BR>The<TT> WCPtrHashDictIter&lt;Key,Value&gt;</TT> class is the templated class used to create iterator objects for<TT>
WCPtrHashDict&lt;Key,Value&gt;</TT> objects.&nbsp; In the description of each member function, the text<TT> Key</TT> is used
to indicate the template parameter defining the type of the indices pointed to by the pointers stored in the dictionary.&nbsp;
The text<TT> Value</TT> is used to indicate the template parameter defining the type of the data pointed to by the pointers
stored in the dictionary.&nbsp; The<TT> WCIterExcept</TT> class is a base class of the<TT> WCPtrHashDictIter&lt;Key,Value&gt;</TT>
class and provides the<TT> exceptions</TT> member function.&nbsp; This member function controls the exceptions which can be
thrown by the<TT> WCPtrHashDictIter&lt;Key,Value&gt;</TT> object.&nbsp; No exceptions are enabled unless they are set by the<TT>
exceptions</TT> member function.
<BR><BR><B>Public Member Functions</B>
<BR><BR>The following member functions are declared in the public interface:
<BR><BR><TT>WCPtrHashDictIter();</TT>
<BR><TT> WCPtrHashDictIter( const WCPtrHashDict&lt;Key,Value&gt; &amp; );</TT>
<BR><TT> ~WCPtrHashDictIter();</TT>
<BR><TT> const WCPtrHashDict&lt;Key,Value&gt; *container() const;</TT>
<BR><TT> Key *key();</TT>
<BR><TT> void reset();</TT>
<BR><TT> void reset( WCPtrHashDict&lt;Key,Value&gt; &amp; );</TT>
<BR><TT> Value * value();</TT>
<BR><BR><B>Public Member Operators</B>
<BR><BR>The following member operators are declared in the public interface:
<BR><BR><TT>int operator ()();</TT>
<BR><TT> int operator ++();</TT>
</DL>
<H2 ID="WCPtrHashDictIterXKey_ValueY__WCPtrHashDictIterLR"> WCPtrHashDictIter() [WCPtrHashDictIter&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchiter.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCPtrHashDictIter();</TT>
<DT>Semantics:
<DD>The public<TT> WCPtrHashDictIter&lt;Key,Value&gt;</TT> constructor is the default constructor for the class and initializes
the iterator with no hash to operate on.&nbsp; The<TT> reset</TT> member function must be called to provide the iterator with
a hash to iterate over.
<DT>Results:
<DD>The public<TT> WCPtrHashDictIter&lt;Key,Value&gt;</TT> constructor creates an initialized<TT> WCPtrHashDictIter</TT> hash
iterator object.
<DT>See Also:
<DD><TT> ~WCPtrHashDictIter</TT>,<TT> reset</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchiter.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCPtrHashDictIter( WCPtrHashDict&lt;Key,Value&gt; &amp; );</TT>
<DT>Semantics:
<DD>The public<TT> WCPtrHashDictIter&lt;Key,Value&gt;</TT> constructor is a constructor for the class.&nbsp; The value passed
as a parameter is a<TT> WCPtrHashDict</TT> hash object.&nbsp; The iterator will be initialized for that hash object and positioned
before the first hash element.&nbsp; To position the iterator to a valid element within the hash, increment it using one of
the<TT> operator ++</TT> or<TT> operator ()</TT> operators.
<DT>Results:
<DD>The public<TT> WCPtrHashDictIter&lt;Key,Value&gt;</TT> constructor creates an initialized<TT> WCPtrHashDictIter</TT> hash
iterator object positioned before the first element in the hash.
<DT>See Also:
<DD><TT> ~WCPtrHashDictIter</TT>,<TT> operator ()</TT>,<TT> operator ++</TT>,<TT> reset</TT>
</DL>
<H2 ID="WCPtrHashDictIterXKey_ValueY____WCPtrHashDictIterLR"> ~WCPtrHashDictIter() [WCPtrHashDictIter&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchiter.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>~WCPtrHashDictIter();</TT>
<DT>Semantics:
<DD>The public<TT> ~WCPtrHashDictIter&lt;Key,Value&gt;</TT> destructor is the destructor for the class.&nbsp; The call to the
destructor is inserted implicitly by the compiler at the point where the<TT> WCPtrHashDictIter</TT> hash iterator object goes
out of scope.
<DT>Results:
<DD>The<TT> WCPtrHashDictIter</TT> hash iterator object is destroyed.
<DT>See Also:
<DD><TT> WCPtrHashDictIter</TT>
</DL>
<H2 ID="WCPtrHashDictIterXKey_ValueY__containerLR"> container() [WCPtrHashDictIter&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchiter.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCPtrHashDict&lt;Key,Value&gt; *container() const;</TT>
<DT>Semantics:
<DD>The<TT> container</TT> public member function returns a pointer to the hash container object.&nbsp; If the iterator has not
been initialized with a hash object, and the<TT> undef_iter</TT> exception is enabled, the exception is thrown.
<DT>Results:
<DD>A pointer to the hash object associated with the iterator is returned, or NULL(0) if the iterator has not been initialized
with a hash.
<DT>See Also:
<DD><TT> WCPtrHashDictIter</TT>,<TT> reset</TT>,<TT> WCIterExcept::undef_iter</TT>
</DL>
<H2 ID="WCPtrHashDictIterXKey_ValueY__keyLR"> key() [WCPtrHashDictIter&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchiter.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Key *key();</TT>
<DT>Semantics:
<DD>The<TT> key</TT> public member function returns a pointer to the<TT> Key</TT> value of the hash item at the current iterator
position.
<BR><BR>If the iterator is not associated with a hash, or the iterator position is either before the first element or past
the last element in the hash, the current iterator position is undefined.&nbsp; In this case the<TT> undef_item</TT> exception
is thrown, if enabled.
<DT>Results:
<DD>A pointer to<TT> Key</TT> at the current iterator element is returned.&nbsp; If the current element is undefined, an undefined
pointer is returned.
<DT>See Also:
<DD><TT> operator ()</TT>,<TT> operator ++</TT>,<TT> reset</TT>,<TT> WCIterExcept::undef_item</TT>
</DL>
<H2 ID="WCPtrHashDictIterXKey_ValueY__operator_LRLR"> operator ()() [WCPtrHashDictIter&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchiter.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int operator ()();</TT>
<DT>Semantics:
<DD>The<TT> operator ()</TT> public member function is the call operator for the class.&nbsp; The hash element which follows the
current item is set to be the new current item.&nbsp; If the previous current item was the last element in the hash, the iterator
is positioned after the end of the hash.
<BR><BR>The<TT> operator ()</TT> public member function has the same semantics as the pre-increment operator,<TT> operator
++.</TT>
<BR><BR>If the iterator was positioned before the first hash element, the current item will be set to the first element.&nbsp;
If the hash is empty, the iterator will be positioned after the end of the hash.
<BR><BR>If the iterator is not associated with a hash or the iterator position before the increment was past the last element
the hash, the<TT> undef_iter</TT> exception is thrown, if enabled.
<DT>Results:
<DD>The<TT> operator ()</TT> public member function returns a non-zero value if the iterator is positioned on a hash item.&nbsp;
Zero(0) is returned when the iterator is incremented past the end of the hash.
<DT>See Also:
<DD><TT> operator ++</TT>,<TT> reset</TT>,<TT> WCIterExcept::undef_iter</TT>
</DL>
<H2 ID="WCPtrHashDictIterXKey_ValueY__operator_PPLR"> operator ++() [WCPtrHashDictIter&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchiter.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int operator ++();</TT>
<DT>Semantics:
<DD>The<TT> operator ++</TT> public member function is the pre-increment operator for the class.&nbsp; The hash element which
follows the current item is set to be the new current item.&nbsp; If the previous current item was the last element in the
hash, the iterator is positioned after the end of the hash.
<BR><BR>The<TT> operator ++</TT> public member function has the same semantics as the call operator,<TT> operator ().</TT>
<BR><BR>The current item will be set to the first hash element if the iterator was positioned before the first element in
the hash.&nbsp; If the hash is empty, the iterator will be positioned after the end of the hash.
<BR><BR>If the iterator is not associated with a hash or the iterator position before the increment was past the last element
the hash, the<TT> undef_iter</TT> exception is thrown, if enabled.
<DT>Results:
<DD>The<TT> operator ++</TT> public member function returns a non-zero value if the iterator is positioned on a hash item.&nbsp;
Zero(0) is returned when the iterator is incremented past the end of the hash.
<DT>See Also:
<DD><TT> operator ()</TT>,<TT> reset</TT>,<TT> WCIterExcept::undef_iter</TT>
</DL>
<H2 ID="WCPtrHashDictIterXKey_ValueY__resetLR"> reset() [WCPtrHashDictIter&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchiter.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void reset();</TT>
<DT>Semantics:
<DD>The<TT> reset</TT> public member function resets the iterator to the initial state, positioning the iterator before the first
element in the associated hash.
<DT>Results:
<DD>The iterator is positioned before the first hash element.
<DT>See Also:
<DD><TT> WCPtrHashDictIter</TT>,<TT> container</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchiter.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void reset( WCPtrHashDict&lt;Key,Value&gt; &amp; );</TT>
<DT>Semantics:
<DD>The<TT> reset</TT> public member function resets the iterator to operate on the specified hash.&nbsp; The iterator is positioned
before the first element in the hash.
<DT>Results:
<DD>The iterator is positioned before the first element of the specified hash.
<DT>See Also:
<DD><TT> WCPtrHashDictIter</TT>,<TT> container</TT>
</DL>
<H2 ID="WCPtrHashDictIterXKey_ValueY__valueLR"> value() [WCPtrHashDictIter&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchiter.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Value *value();</TT>
<DT>Semantics:
<DD>The<TT> value</TT> public member function returns a pointer to the<TT> Value</TT> the current iterator position.
<BR><BR>If the iterator is not associated with a hash, or the iterator position is either before the first element or past
the last element in the hash, the current iterator position is undefined.&nbsp; In this case the<TT> undef_item</TT> exception
is thrown, if enabled.
<DT>Results:
<DD>A pointer to the<TT> Value</TT> at the current iterator element is returned.&nbsp; If the current element is undefined, an
undefined pointer is returned.
<DT>See Also:
<DD><TT> operator ()</TT>,<TT> operator ++</TT>,<TT> reset</TT>,<TT> WCIterExcept::undef_item</TT>
</DL>
<H2 ID="WCValHashDictIterXKey_ValueY_Class_Description"> WCValHashDictIter&lt;Key,Value&gt; Class Description </H2>
<DL>
<DT>Declared:
<DD><TT> wchiter.h</TT>
<BR><BR>The<TT> WCValHashDictIter&lt;Key,Value&gt;</TT> class is the templated class used to create iterator objects for<TT>
WCValHashDict&lt;Key,Value&gt;</TT> objects.&nbsp; In the description of each member function, the text<TT> Key</TT> is used
to indicate the template parameter defining the type of the indices used to store data in the dictionary.&nbsp; The text<TT>
Value</TT> is used to indicate the template parameter defining the type of the data stored in the dictionary.&nbsp; The<TT>
WCIterExcept</TT> class is a base class of the<TT> WCValHashDictIter&lt;Key,Value&gt;</TT> class and provides the<TT> exceptions</TT>
member function.&nbsp; This member function controls the exceptions which can be thrown by the<TT> WCValHashDictIter&lt;Key,Value&gt;</TT>
object.&nbsp; No exceptions are enabled unless they are set by the<TT> exceptions</TT> member function.
<BR><BR><B>Public Member Functions</B>
<BR><BR>The following member functions are declared in the public interface:
<BR><BR><TT>WCValHashDictIter();</TT>
<BR><TT> WCValHashDictIter( const WCValHashDict&lt;Key,Value&gt; &amp; );</TT>
<BR><TT> ~WCValHashDictIter();</TT>
<BR><TT> const WCValHashDict&lt;Key,Value&gt; *container() const;</TT>
<BR><TT> Key key();</TT>
<BR><TT> void reset();</TT>
<BR><TT> void reset( WCValHashDict&lt;Key,Value&gt; &amp; );</TT>
<BR><TT> Value value();</TT>
<BR><BR><B>Public Member Operators</B>
<BR><BR>The following member operators are declared in the public interface:
<BR><BR><TT>int operator ()();</TT>
<BR><TT> int operator ++();</TT>
</DL>
<H2 ID="WCValHashDictIterXKey_ValueY__WCValHashDictIterLR"> WCValHashDictIter() [WCValHashDictIter&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchiter.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCValHashDictIter();</TT>
<DT>Semantics:
<DD>The public<TT> WCValHashDictIter&lt;Key,Value&gt;</TT> constructor is the default constructor for the class and initializes
the iterator with no hash to operate on.&nbsp; The<TT> reset</TT> member function must be called to provide the iterator with
a hash to iterate over.
<DT>Results:
<DD>The public<TT> WCValHashDictIter&lt;Key,Value&gt;</TT> constructor creates an initialized<TT> WCValHashDictIter</TT> hash
iterator object.
<DT>See Also:
<DD><TT> ~WCValHashDictIter</TT>,<TT> reset</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchiter.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCValHashDictIter( WCValHashDict&lt;Key,Value&gt; &amp; );</TT>
<DT>Semantics:
<DD>The public<TT> WCValHashDictIter&lt;Key,Value&gt;</TT> constructor is a constructor for the class.&nbsp; The value passed
as a parameter is a<TT> WCValHashDict</TT> hash object.&nbsp; The iterator will be initialized for that hash object and positioned
before the first hash element.&nbsp; To position the iterator to a valid element within the hash, increment it using one of
the<TT> operator ++</TT> or<TT> operator ()</TT> operators.
<DT>Results:
<DD>The public<TT> WCValHashDictIter&lt;Key,Value&gt;</TT> constructor creates an initialized<TT> WCValHashDictIter</TT> hash
iterator object positioned before the first element in the hash.
<DT>See Also:
<DD><TT> ~WCValHashDictIter</TT>,<TT> operator ()</TT>,<TT> operator ++</TT>,<TT> reset</TT>
</DL>
<H2 ID="WCValHashDictIterXKey_ValueY____WCValHashDictIterLR"> ~WCValHashDictIter() [WCValHashDictIter&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchiter.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>~WCValHashDictIter();</TT>
<DT>Semantics:
<DD>The public<TT> ~WCValHashDictIter&lt;Key,Value&gt;</TT> destructor is the destructor for the class.&nbsp; The call to the
destructor is inserted implicitly by the compiler at the point where the<TT> WCValHashDictIter</TT> hash iterator object goes
out of scope.
<DT>Results:
<DD>The<TT> WCValHashDictIter</TT> hash iterator object is destroyed.
<DT>See Also:
<DD><TT> WCValHashDictIter</TT>
</DL>
<H2 ID="WCValHashDictIterXKey_ValueY__containerLR"> container() [WCValHashDictIter&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchiter.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCValHashDict&lt;Key,Value&gt; *container() const;</TT>
<DT>Semantics:
<DD>The<TT> container</TT> public member function returns a pointer to the hash container object.&nbsp; If the iterator has not
been initialized with a hash object, and the<TT> undef_iter</TT> exception is enabled, the exception is thrown.
<DT>Results:
<DD>A pointer to the hash object associated with the iterator is returned, or NULL(0) if the iterator has not been initialized
with a hash.
<DT>See Also:
<DD><TT> WCValHashDictIter</TT>,<TT> reset</TT>,<TT> WCIterExcept::undef_iter</TT>
</DL>
<H2 ID="WCValHashDictIterXKey_ValueY__keyLR"> key() [WCValHashDictIter&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchiter.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Key key();</TT>
<DT>Semantics:
<DD>The<TT> key</TT> public member function returns the value of<TT> Key</TT> at the current iterator position.
<BR><BR>If the iterator is not associated with a hash, or the iterator position is either before the first element or past
the last element in the hash, the current iterator position is undefined.&nbsp; In this case the<TT> undef_item</TT> exception
is thrown, if enabled.
<DT>Results:
<DD>The value of<TT> Key</TT> at the current iterator element is returned.&nbsp; If the current element is undefined, a default
initialized object is returned.
<DT>See Also:
<DD><TT> operator ()</TT>,<TT> operator ++</TT>,<TT> reset</TT>,<TT> WCIterExcept::undef_item</TT>
</DL>
<H2 ID="WCValHashDictIterXKey_ValueY__operator_LRLR"> operator ()() [WCValHashDictIter&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchiter.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int operator ()();</TT>
<DT>Semantics:
<DD>The<TT> operator ()</TT> public member function is the call operator for the class.&nbsp; The hash element which follows the
current item is set to be the new current item.&nbsp; If the previous current item was the last element in the hash, the iterator
is positioned after the end of the hash.
<BR><BR>The<TT> operator ()</TT> public member function has the same semantics as the pre-increment operator,<TT> operator
++.</TT>
<BR><BR>If the iterator was positioned before the first hash element, the current item will be set to the first element.&nbsp;
If the hash is empty, the iterator will be positioned after the end of the hash.
<BR><BR>If the iterator is not associated with a hash or the iterator position before the increment was past the last element
the hash, the<TT> undef_iter</TT> exception is thrown, if enabled.
<DT>Results:
<DD>The<TT> operator ()</TT> public member function returns a non-zero value if the iterator is positioned on a hash item.&nbsp;
Zero(0) is returned when the iterator is incremented past the end of the hash.
<DT>See Also:
<DD><TT> operator ++</TT>,<TT> reset</TT>,<TT> WCIterExcept::undef_iter</TT>
</DL>
<H2 ID="WCValHashDictIterXKey_ValueY__operator_PPLR"> operator ++() [WCValHashDictIter&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchiter.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int operator ++();</TT>
<DT>Semantics:
<DD>The<TT> operator ++</TT> public member function is the pre-increment operator for the class.&nbsp; The hash element which
follows the current item is set to be the new current item.&nbsp; If the previous current item was the last element in the
hash, the iterator is positioned after the end of the hash.
<BR><BR>The<TT> operator ++</TT> public member function has the same semantics as the call operator,<TT> operator ().</TT>
<BR><BR>The current item will be set to the first hash element if the iterator was positioned before the first element in
the hash.&nbsp; If the hash is empty, the iterator will be positioned after the end of the hash.
<BR><BR>If the iterator is not associated with a hash or the iterator position before the increment was past the last element
the hash, the<TT> undef_iter</TT> exception is thrown, if enabled.
<DT>Results:
<DD>The<TT> operator ++</TT> public member function returns a non-zero value if the iterator is positioned on a hash item.&nbsp;
Zero(0) is returned when the iterator is incremented past the end of the hash.
<DT>See Also:
<DD><TT> operator ()</TT>,<TT> reset</TT>,<TT> WCIterExcept::undef_iter</TT>
</DL>
<H2 ID="WCValHashDictIterXKey_ValueY__resetLR"> reset() [WCValHashDictIter&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchiter.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void reset();</TT>
<DT>Semantics:
<DD>The<TT> reset</TT> public member function resets the iterator to the initial state, positioning the iterator before the first
element in the associated hash.
<DT>Results:
<DD>The iterator is positioned before the first hash element.
<DT>See Also:
<DD><TT> WCValHashDictIter</TT>,<TT> container</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchiter.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void reset( WCValHashDict&lt;Key,Value&gt; &amp; );</TT>
<DT>Semantics:
<DD>The<TT> reset</TT> public member function resets the iterator to operate on the specified hash.&nbsp; The iterator is positioned
before the first element in the hash.
<DT>Results:
<DD>The iterator is positioned before the first element of the specified hash.
<DT>See Also:
<DD><TT> WCValHashDictIter</TT>,<TT> container</TT>
</DL>
<H2 ID="WCValHashDictIterXKey_ValueY__valueLR"> value() [WCValHashDictIter&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchiter.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Value value();</TT>
<DT>Semantics:
<DD>The<TT> value</TT> public member function returns the value of<TT> Value</TT> at the current iterator position.
<BR><BR>If the iterator is not associated with a hash, or the iterator position is either before the first element or past
the last element in the hash, the current iterator position is undefined.&nbsp; In this case the<TT> undef_item</TT> exception
is thrown, if enabled.
<DT>Results:
<DD>The value of the<TT> Value</TT> at the current iterator element is returned.&nbsp; If the current element is undefined, a
default initialized object is returned.
<DT>See Also:
<DD><TT> operator ()</TT>,<TT> operator ++</TT>,<TT> reset</TT>,<TT> WCIterExcept::undef_item</TT>
</DL>
<H2 ID="WCPtrHashSetIterXTypeY__WCPtrHashTableIterXTypeY_Class_Description"> WCPtrHashSetIter&lt;Type&gt;, WCPtrHashTableIter&lt;Type&gt; Class Description </H2>
<DL>
<DT>Declared:
<DD><TT> wchiter.h</TT>
<BR><BR>The<TT> WCPtrHashSetIter&lt;Type&gt;</TT> and<TT> WCPtrHashTableIter&lt;Type&gt;</TT> classes are the templated classes
used to create iterator objects for<TT> WCPtrHashTable&lt;Type&gt;</TT> and<TT> WCPtrHashSet&lt;Type&gt;</TT> objects.&nbsp;
In the description of each member function, the text<TT> Type</TT> is used to indicate the hash element type specified as
the template parameter.&nbsp; The<TT> WCIterExcept</TT> class is a base class of the<TT> WCPtrHashSetIter&lt;Type&gt;</TT>
and<TT> WCPtrHashTableIter&lt;Type&gt;</TT> classes and provides the<TT> exceptions</TT> member function.&nbsp; This member
function controls the exceptions which can be thrown by the<TT> WCPtrHashSetIter&lt;Type&gt;</TT> and<TT> WCPtrHashTableIter&lt;Type&gt;</TT>
objects.&nbsp; No exceptions are enabled unless they are set by the<TT> exceptions</TT> member function.
<BR><BR><B>Public Member Functions</B>
<BR><BR>The following member functions are declared in the public interface:
<BR><BR><TT>WCPtrHashSetIter();</TT>
<BR><TT> WCPtrHashSetIter( const WCPtrHashSet&lt;Type&gt; &amp; );</TT>
<BR><TT> ~WCPtrHashSetIter();</TT>
<BR><TT> WCPtrHashTableIter();</TT>
<BR><TT> WCPtrHashTableIter( const WCPtrHashTable&lt;Type&gt; &amp; );</TT>
<BR><TT> ~WCPtrHashTableIter();</TT>
<BR><TT> const WCPtrHashTable&lt;Type&gt; *container() const;</TT>
<BR><TT> const WCPtrHashSet&lt;Type&gt; *container() const;</TT>
<BR><TT> Type *current() const;</TT>
<BR><TT> void reset();</TT>
<BR><TT> void WCPtrHashSetIter&lt;Type&gt;::reset( WCPtrHashSet&lt;Type&gt; &amp; );</TT>
<BR><TT> void WCPtrHashTableIter&lt;Type&gt;::reset( WCPtrHashTable&lt;Type&gt; &amp; );</TT>
<BR><BR><B>Public Member Operators</B>
<BR><BR>The following member operators are declared in the public interface:
<BR><BR><TT>int operator ()();</TT>
<BR><TT> int operator ++();</TT>
</DL>
<H2 ID="WCPtrHashSetIterXTypeY__WCPtrHashSetIterLR"> WCPtrHashSetIter() [WCPtrHashSetIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchiter.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCPtrHashSetIter();</TT>
<DT>Semantics:
<DD>The public<TT> WCPtrHashSetIter&lt;Type&gt;</TT> constructor is the default constructor for the class and initializes the
iterator with no hash to operate on.&nbsp; The<TT> reset</TT> member function must be called to provide the iterator with
a hash to iterate over.
<DT>Results:
<DD>The public<TT> WCPtrHashSetIter&lt;Type&gt;</TT> constructor creates an initialized<TT> WCPtrHashSetIter</TT> hash iterator
object.
<DT>See Also:
<DD><TT> ~WCPtrHashSetIter</TT>,<TT> WCPtrHashTableIter</TT>,<TT> reset</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchiter.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCPtrHashSetIter( WCPtrHashSet&lt;Type&gt; &amp; );</TT>
<DT>Semantics:
<DD>The public<TT> WCPtrHashSetIter&lt;Type&gt;</TT> constructor is a constructor for the class.&nbsp; The value passed as a parameter
is a<TT> WCPtrHashSet</TT> hash object.&nbsp; The iterator will be initialized for that hash object and positioned before
the first hash element.&nbsp; To position the iterator to a valid element within the hash, increment it using one of the<TT>
operator ++</TT> or<TT> operator ()</TT> operators.
<DT>Results:
<DD>The public<TT> WCPtrHashSetIter&lt;Type&gt;</TT> constructor creates an initialized<TT> WCPtrHashSetIter</TT> hash iterator
object positioned before the first element in the hash.
<DT>See Also:
<DD><TT> ~WCPtrHashSetIter</TT>,<TT> operator ()</TT>,<TT> operator ++</TT>,<TT> reset</TT>
</DL>
<H2 ID="WCPtrHashSetIterXTypeY____WCPtrHashSetIterLR"> ~WCPtrHashSetIter() [WCPtrHashSetIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchiter.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>~WCPtrHashSetIter();</TT>
<DT>Semantics:
<DD>The public<TT> ~WCPtrHashSetIter&lt;Type&gt;</TT> destructor is the destructor for the class.&nbsp; The call to the destructor
is inserted implicitly by the compiler at the point where the<TT> WCPtrHashSetIter</TT> hash iterator object goes out of scope.
<DT>Results:
<DD>The<TT> WCPtrHashSetIter</TT> hash iterator object is destroyed.
<DT>See Also:
<DD><TT> WCPtrHashSetIter</TT>,<TT> WCPtrHashTableIter</TT>
</DL>
<H2 ID="WCPtrHashTableIterXTypeY__WCPtrHashTableIterLR"> WCPtrHashTableIter() [WCPtrHashTableIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchiter.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCPtrHashTableIter();</TT>
<DT>Semantics:
<DD>The public<TT> WCPtrHashTableIter&lt;Type&gt;</TT> constructor is the default constructor for the class and initializes the
iterator with no hash to operate on.&nbsp; The<TT> reset</TT> member function must be called to provide the iterator with
a hash to iterate over.
<DT>Results:
<DD>The public<TT> WCPtrHashTableIter&lt;Type&gt;</TT> constructor creates an initialized<TT> WCPtrHashTableIter</TT> hash iterator
object.
<DT>See Also:
<DD><TT> ~WCPtrHashTableIter</TT>,<TT> WCPtrHashSetIter</TT>,<TT> reset</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchiter.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCPtrHashTableIter( WCPtrHashTable&lt;Type&gt; &amp; );</TT>
<DT>Semantics:
<DD>The public<TT> WCPtrHashTableIter&lt;Type&gt;</TT> constructor is a constructor for the class.&nbsp; The value passed as a
parameter is a<TT> WCPtrHashTable</TT> hash object.&nbsp; The iterator will be initialized for that hash object and positioned
before the first hash element.&nbsp; To position the iterator to a valid element within the hash, increment it using one of
the<TT> operator ++</TT> or<TT> operator ()</TT> operators.
<DT>Results:
<DD>The public<TT> WCPtrHashTableIter&lt;Type&gt;</TT> constructor creates an initialized<TT> WCPtrHashTableIter</TT> hash iterator
object positioned before the first element in the hash.
<DT>See Also:
<DD><TT> ~WCPtrHashTableIter</TT>,<TT> operator ()</TT>,<TT> operator ++</TT>,<TT> reset</TT>
</DL>
<H2 ID="WCPtrHashTableIterXTypeY____WCPtrHashTableIterLR"> ~WCPtrHashTableIter() [WCPtrHashTableIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchiter.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>~WCPtrHashTableIter();</TT>
<DT>Semantics:
<DD>The<TT> WCPtrHashTableIter&lt;Type&gt;</TT> destructor is the destructor for the class.&nbsp; The call to the destructor is
inserted implicitly by the compiler at the point where the<TT> WCPtrHashTableIter</TT> hash iterator object goes out of scope.
<DT>Results:
<DD>The<TT> WCPtrHashTableIter</TT> hash iterator object is destroyed.
<DT>See Also:
<DD><TT> WCPtrHashSetIter</TT>,<TT> WCPtrHashTableIter</TT>
</DL>
<H2 ID="WCPtrHashSetIterXTypeY_WCPtrHashTableIterXTypeY__containerLR"> container() [WCPtrHashSetIter&lt;Type&gt;,WCPtrHashTableIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchiter.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCPtrHashTable&lt;Type&gt; *WCPtrHashTableIter&lt;Type&gt;::container() const;</TT>
<BR><TT> WCPtrHashSet&lt;Type&gt; *WCPtrHashSetIter&lt;Type&gt;::container() const;</TT>
<DT>Semantics:
<DD>The<TT> container</TT> public member function returns a pointer to the hash container object.&nbsp; If the iterator has not
been initialized with a hash object, and the<TT> undef_iter</TT> exception is enabled, the exception is thrown.
<DT>Results:
<DD>A pointer to the hash object associated with the iterator is returned, or NULL(0) if the iterator has not been initialized
with a hash.
<DT>See Also:
<DD><TT> WCPtrHashSetIter</TT>,<TT> WCPtrHashTableIter</TT>,<TT> reset</TT>,<TT> WCIterExcept::undef_iter</TT>
</DL>
<H2 ID="WCPtrHashSetIterXTypeY__currentLR__WCPtrHashTableIterXTypeY__currentLR"> current() [WCPtrHashSetIter&lt;Type&gt;,WCPtrHashTableIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchiter.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Type *current();</TT>
<DT>Semantics:
<DD>The<TT> current</TT> public member function returns a pointer to the hash item at the current iterator position.
<BR><BR>If the iterator is not associated with a hash, or the iterator position is either before the first element or past
the last element in the hash, the current iterator position is undefined.&nbsp; In this case the<TT> undef_item</TT> exception
is thrown, if enabled.
<DT>Results:
<DD>A pointer to the current iterator element is returned.&nbsp; If the current element is undefined, NULL(0) is returned.
<DT>See Also:
<DD><TT> operator ()</TT>,<TT> operator ++</TT>,<TT> reset</TT>,<TT> WCIterExcept::undef_item</TT>
</DL>
<H2 ID="WCPtrHashSetIterXTypeY_WCPtrHashTableIterXTypeY__operator_LRLR"> operator ()() [WCPtrHashSetIter&lt;Type&gt;,WCPtrHashTableIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchiter.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int operator ()();</TT>
<DT>Semantics:
<DD>The<TT> operator ()</TT> public member function is the call operator for the class.&nbsp; The hash element which follows the
current item is set to be the new current item.&nbsp; If the previous current item was the last element in the hash, the iterator
is positioned after the end of the hash.
<BR><BR>The<TT> operator ()</TT> public member function has the same semantics as the pre-increment operator,<TT> operator
++.</TT>
<BR><BR>If the iterator was positioned before the first hash element, the current item will be set to the first element.&nbsp;
If the hash is empty, the iterator will be positioned after the end of the hash.
<BR><BR>If the iterator is not associated with a hash or the iterator position before the increment was past the last element
the hash, the<TT> undef_iter</TT> exception is thrown, if enabled.
<DT>Results:
<DD>The<TT> operator ()</TT> public member function returns a non-zero value if the iterator is positioned on a hash item.&nbsp;
Zero(0) is returned when the iterator is incremented past the end of the hash.
<DT>See Also:
<DD><TT> operator ++</TT>,<TT> reset</TT>,<TT> WCIterExcept::undef_iter</TT>
</DL>
<H2 ID="WCPtrHashSetIterXTypeY_WCPtrHashTableIterXTypeY__operator_PPLR"> operator ++() [WCPtrHashSetIter&lt;Type&gt;,WCPtrHashTableIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchiter.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int operator ++();</TT>
<DT>Semantics:
<DD>The<TT> operator ++</TT> public member function is the pre-increment operator for the class.&nbsp; The hash element which
follows the current item is set to be the new current item.&nbsp; If the previous current item was the last element in the
hash, the iterator is positioned after the end of the hash.
<BR><BR>The<TT> operator ++</TT> public member function has the same semantics as the call operator,<TT> operator ().</TT>
<BR><BR>The current item will be set to the first hash element if the iterator was positioned before the first element in
the hash.&nbsp; If the hash is empty, the iterator will be positioned after the end of the hash.
<BR><BR>If the iterator is not associated with a hash or the iterator position before the increment was past the last element
the hash, the<TT> undef_iter</TT> exception is thrown, if enabled.
<DT>Results:
<DD>The<TT> operator ++</TT> public member function returns a non-zero value if the iterator is positioned on a hash item.&nbsp;
Zero(0) is returned when the iterator is incremented past the end of the hash.
<DT>See Also:
<DD><TT> current</TT>,<TT> operator ()</TT>,<TT> reset</TT>,<TT> WCIterExcept::undef_iter</TT>
</DL>
<H2 ID="WCPtrHashSetIterXTypeY__resetLR__WCPtrHashTableIterXTypeY__resetLR"> reset() [WCPtrHashSetIter&lt;Type&gt;,WCPtrHashTableIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchiter.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void reset();</TT>
<DT>Semantics:
<DD>The<TT> reset</TT> public member function resets the iterator to the initial state, positioning the iterator before the first
element in the associated hash.
<DT>Results:
<DD>The iterator is positioned before the first hash element.
<DT>See Also:
<DD><TT> WCPtrHashSetIter</TT>,<TT> WCPtrHashTableIter</TT>,<TT> container</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchiter.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void WCPtrHashSetIter&lt;Type&gt;::reset( WCPtrHashSet&lt;Type&gt; &amp; );</TT>
<BR><TT> void WCPtrHashTableIter&lt;Type&gt;::reset( WCPtrHashTable&lt;Type&gt; &amp; );</TT>
<DT>Semantics:
<DD>The<TT> reset</TT> public member function resets the iterator to operate on the specified hash.&nbsp; The iterator is positioned
before the first element in the hash.
<DT>Results:
<DD>The iterator is positioned before the first element of the specified hash.
<DT>See Also:
<DD><TT> WCPtrHashSetIter</TT>,<TT> WCPtrHashTableIter</TT>,<TT> container</TT>
</DL>
<H2 ID="WCValHashSetIterXTypeY__WCValHashTableIterXTypeY_Class_Description"> WCValHashSetIter&lt;Type&gt;, WCValHashTableIter&lt;Type&gt; Class Description </H2>
<DL>
<DT>Declared:
<DD><TT> wchiter.h</TT>
<BR><BR>The<TT> WCValHashSetIter&lt;Type&gt;</TT> and<TT> WCValHashTableIter&lt;Type&gt;</TT> classes are the templated classes
used to create iterator objects for<TT> WCValHashTable&lt;Type&gt;</TT> and<TT> WCValHashSet&lt;Type&gt;</TT> objects.&nbsp;
In the description of each member function, the text<TT> Type</TT> is used to indicate the hash element type specified as
the template parameter.&nbsp; The<TT> WCIterExcept</TT> class is a base class of the<TT> WCValHashSetIter&lt;Type&gt;</TT>
and<TT> WCValHashTableIter&lt;Type&gt;</TT> classes and provides the<TT> exceptions</TT> member function.&nbsp; This member
function controls the exceptions which can be thrown by the<TT> WCValHashSetIter&lt;Type&gt;</TT> and<TT> WCValHashTableIter&lt;Type&gt;</TT>
objects.&nbsp; No exceptions are enabled unless they are set by the<TT> exceptions</TT> member function.
<BR><BR><B>Public Member Functions</B>
<BR><BR>The following member functions are declared in the public interface:
<BR><BR><TT>WCValHashSetIter();</TT>
<BR><TT> WCValHashSetIter( const WCValHashSet&lt;Type&gt; &amp; );</TT>
<BR><TT> ~WCValHashSetIter();</TT>
<BR><TT> WCValHashTableIter();</TT>
<BR><TT> WCValHashTableIter( const WCValHashTable&lt;Type&gt; &amp; );</TT>
<BR><TT> ~WCValHashTableIter();</TT>
<BR><TT> const WCValHashTable&lt;Type&gt; *container() const;</TT>
<BR><TT> const WCValHashSet&lt;Type&gt; *container() const;</TT>
<BR><TT> Type current() const;</TT>
<BR><TT> void reset();</TT>
<BR><TT> void WCValHashSetIter&lt;Type&gt;::reset( WCValHashSet&lt;Type&gt; &amp; );</TT>
<BR><TT> void WCValHashTableIter&lt;Type&gt;::reset( WCValHashTable&lt;Type&gt; &amp; );</TT>
<BR><BR><B>Public Member Operators</B>
<BR><BR>The following member operators are declared in the public interface:
<BR><BR><TT>int operator ()();</TT>
<BR><TT> int operator ++();</TT>
</DL>
<H2 ID="WCValHashSetIterXTypeY__WCValHashSetIterLR"> WCValHashSetIter() [WCValHashSetIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchiter.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCValHashSetIter();</TT>
<DT>Semantics:
<DD>The public<TT> WCValHashSetIter&lt;Type&gt;</TT> constructor is the default constructor for the class and initializes the
iterator with no hash to operate on.&nbsp; The<TT> reset</TT> member function must be called to provide the iterator with
a hash to iterate over.
<DT>Results:
<DD>The public<TT> WCValHashSetIter&lt;Type&gt;</TT> constructor creates an initialized<TT> WCValHashSetIter</TT> hash iterator
object.
<DT>See Also:
<DD><TT> ~WCValHashSetIter</TT>,<TT> WCValHashTableIter</TT>,<TT> reset</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchiter.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCValHashSetIter( WCValHashSet&lt;Type&gt; &amp; );</TT>
<DT>Semantics:
<DD>The public<TT> WCValHashSetIter&lt;Type&gt;</TT> constructor is a constructor for the class.&nbsp; The value passed as a parameter
is a<TT> WCValHashSet</TT> hash object.&nbsp; The iterator will be initialized for that hash object and positioned before
the first hash element.&nbsp; To position the iterator to a valid element within the hash, increment it using one of the<TT>
operator ++</TT> or<TT> operator ()</TT> operators.
<DT>Results:
<DD>The public<TT> WCValHashSetIter&lt;Type&gt;</TT> constructor creates an initialized<TT> WCValHashSetIter</TT> hash iterator
object positioned before the first element in the hash.
<DT>See Also:
<DD><TT> ~WCValHashSetIter</TT>,<TT> operator ()</TT>,<TT> operator ++</TT>,<TT> reset</TT>
</DL>
<H2 ID="WCValHashSetIterXTypeY____WCValHashSetIterLR"> ~WCValHashSetIter() [WCValHashSetIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchiter.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>~WCValHashSetIter();</TT>
<DT>Semantics:
<DD>The public<TT> ~WCValHashSetIter&lt;Type&gt;</TT> destructor is the destructor for the class.&nbsp; The call to the destructor
is inserted implicitly by the compiler at the point where the<TT> WCValHashSetIter</TT> hash iterator object goes out of scope.
<DT>Results:
<DD>The<TT> WCValHashSetIter</TT> hash iterator object is destroyed.
<DT>See Also:
<DD><TT> WCValHashSetIter</TT>,<TT> WCValHashTableIter</TT>
</DL>
<H2 ID="WCValHashTableIterXTypeY__WCValHashTableIterLR"> WCValHashTableIter() [WCValHashTableIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchiter.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCValHashTableIter();</TT>
<DT>Semantics:
<DD>The public<TT> WCValHashTableIter&lt;Type&gt;</TT> constructor is the default constructor for the class and initializes the
iterator with no hash to operate on.&nbsp; The<TT> reset</TT> member function must be called to provide the iterator with
a hash to iterate over.
<DT>Results:
<DD>The public<TT> WCValHashTableIter&lt;Type&gt;</TT> constructor creates an initialized<TT> WCValHashTableIter</TT> hash iterator
object.
<DT>See Also:
<DD><TT> ~WCValHashTableIter</TT>,<TT> WCValHashSetIter</TT>,<TT> reset</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchiter.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCValHashTableIter( WCValHashTable&lt;Type&gt; &amp; );</TT>
<DT>Semantics:
<DD>The public<TT> WCValHashTableIter&lt;Type&gt;</TT> constructor is a constructor for the class.&nbsp; The value passed as a
parameter is a<TT> WCValHashTable</TT> hash object.&nbsp; The iterator will be initialized for that hash object and positioned
before the first hash element.&nbsp; To position the iterator to a valid element within the hash, increment it using one of
the<TT> operator ++</TT> or<TT> operator ()</TT> operators.
<DT>Results:
<DD>The public<TT> WCValHashTableIter&lt;Type&gt;</TT> constructor creates an initialized<TT> WCValHashTableIter</TT> hash iterator
object positioned before the first element in the hash.
<DT>See Also:
<DD><TT> ~WCValHashTableIter</TT>,<TT> operator ()</TT>,<TT> operator ++</TT>,<TT> reset</TT>
</DL>
<H2 ID="WCValHashTableIterXTypeY____WCValHashTableIterLR"> ~WCValHashTableIter() [WCValHashTableIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchiter.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>~WCValHashTableIter();</TT>
<DT>Semantics:
<DD>The<TT> WCValHashTableIter&lt;Type&gt;</TT> destructor is the destructor for the class.&nbsp; The call to the destructor is
inserted implicitly by the compiler at the point where the<TT> WCValHashTableIter</TT> hash iterator object goes out of scope.
<DT>Results:
<DD>The<TT> WCValHashTableIter</TT> hash iterator object is destroyed.
<DT>See Also:
<DD><TT> WCValHashSetIter</TT>,<TT> WCValHashTableIter</TT>
</DL>
<H2 ID="WCValHashSetIterXTypeY_WCValHashTableIterXTypeY__containerLR"> container() [WCValHashSetIter&lt;Type&gt;,WCValHashTableIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchiter.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCValHashTable&lt;Type&gt; *WCValHashTableIter&lt;Type&gt;::container() const;</TT>
<BR><TT> WCValHashSet&lt;Type&gt; *WCValHashSetIter&lt;Type&gt;::container() const;</TT>
<DT>Semantics:
<DD>The<TT> container</TT> public member function returns a pointer to the hash container object.&nbsp; If the iterator has not
been initialized with a hash object, and the<TT> undef_iter</TT> exception is enabled, the exception is thrown.
<DT>Results:
<DD>A pointer to the hash object associated with the iterator is returned, or NULL(0) if the iterator has not been initialized
with a hash.
<DT>See Also:
<DD><TT> WCValHashSetIter</TT>,<TT> WCValHashTableIter</TT>,<TT> reset</TT>,<TT> WCIterExcept::undef_iter</TT>
</DL>
<H2 ID="WCValHashSetIterXTypeY__currentLR__WCValHashTableIterXTypeY__currentLR"> current() [WCValHashSetIter&lt;Type&gt;,WCValHashTableIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchiter.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Type current();</TT>
<DT>Semantics:
<DD>The<TT> current</TT> public member function returns the value of the hash element at the current iterator position.
<BR><BR>If the iterator is not associated with a hash, or the iterator position is either before the first element or past
the last element in the hash, the current iterator position is undefined.&nbsp; In this case the<TT> undef_item</TT> exception
is thrown, if enabled.
<DT>Results:
<DD>The value at the current iterator element is returned.&nbsp; If the current element is undefined, a default initialized object
is returned.
<DT>See Also:
<DD><TT> operator ()</TT>,<TT> operator ++</TT>,<TT> reset</TT>,<TT> WCIterExcept::undef_item</TT>
</DL>
<H2 ID="WCValHashSetIterXTypeY_WCValHashTableIterXTypeY__operator_LRLR"> operator ()() [WCValHashSetIter&lt;Type&gt;,WCValHashTableIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchiter.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int operator ()();</TT>
<DT>Semantics:
<DD>The<TT> operator ()</TT> public member function is the call operator for the class.&nbsp; The hash element which follows the
current item is set to be the new current item.&nbsp; If the previous current item was the last element in the hash, the iterator
is positioned after the end of the hash.
<BR><BR>The<TT> operator ()</TT> public member function has the same semantics as the pre-increment operator,<TT> operator
++.</TT>
<BR><BR>If the iterator was positioned before the first hash element, the current item will be set to the first element.&nbsp;
If the hash is empty, the iterator will be positioned after the end of the hash.
<BR><BR>If the iterator is not associated with a hash or the iterator position before the increment was past the last element
the hash, the<TT> undef_iter</TT> exception is thrown, if enabled.
<DT>Results:
<DD>The<TT> operator ()</TT> public member function returns a non-zero value if the iterator is positioned on a hash item.&nbsp;
Zero(0) is returned when the iterator is incremented past the end of the hash.
<DT>See Also:
<DD><TT> operator ++</TT>,<TT> reset</TT>,<TT> WCIterExcept::undef_iter</TT>
</DL>
<H2 ID="WCValHashSetIterXTypeY_WCValHashTableIterXTypeY__operator_PPLR"> operator ++() [WCValHashSetIter&lt;Type&gt;,WCValHashTableIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchiter.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int operator ++();</TT>
<DT>Semantics:
<DD>The<TT> operator ++</TT> public member function is the pre-increment operator for the class.&nbsp; The hash element which
follows the current item is set to be the new current item.&nbsp; If the previous current item was the last element in the
hash, the iterator is positioned after the end of the hash.
<BR><BR>The<TT> operator ++</TT> public member function has the same semantics as the call operator,<TT> operator ().</TT>
<BR><BR>The current item will be set to the first hash element if the iterator was positioned before the first element in
the hash.&nbsp; If the hash is empty, the iterator will be positioned after the end of the hash.
<BR><BR>If the iterator is not associated with a hash or the iterator position before the increment was past the last element
the hash, the<TT> undef_iter</TT> exception is thrown, if enabled.
<DT>Results:
<DD>The<TT> operator ++</TT> public member function returns a non-zero value if the iterator is positioned on a hash item.&nbsp;
Zero(0) is returned when the iterator is incremented past the end of the hash.
<DT>See Also:
<DD><TT> current</TT>,<TT> operator ()</TT>,<TT> reset</TT>,<TT> WCIterExcept::undef_iter</TT>
</DL>
<H2 ID="WCValHashSetIterXTypeY__resetLR__WCValHashTableIterXTypeY__resetLR"> reset() [WCValHashSetIter&lt;Type&gt;,WCValHashTableIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchiter.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void reset();</TT>
<DT>Semantics:
<DD>The<TT> reset</TT> public member function resets the iterator to the initial state, positioning the iterator before the first
element in the associated hash.
<DT>Results:
<DD>The iterator is positioned before the first hash element.
<DT>See Also:
<DD><TT> WCValHashSetIter</TT>,<TT> WCValHashTableIter</TT>,<TT> container</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchiter.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void WCValHashSetIter&lt;Type&gt;::reset( WCValHashSet&lt;Type&gt; &amp; );</TT>
<BR><TT> void WCValHashTableIter&lt;Type&gt;::reset( WCValHashTable&lt;Type&gt; &amp; );</TT>
<DT>Semantics:
<DD>The<TT> reset</TT> public member function resets the iterator to operate on the specified hash.&nbsp; The iterator is positioned
before the first element in the hash.
<DT>Results:
<DD>The iterator is positioned before the first element of the specified hash.
<DT>See Also:
<DD><TT> WCValHashSetIter</TT>,<TT> WCValHashTableIter</TT>,<TT> container</TT>
</DL>
<H1 ID="List_Containers"> List Containers </H1>
<BR>List containers are single or double linked lists.&nbsp; The choice of which type of list to use is determined by the
direction in which the list is traversed and by what is stored in the list.&nbsp; A list to which items are just added and
removed may be most efficiently implemented as a single linked list.&nbsp; If frequent retrievals of items at given indexes
within the list are made, double linked lists can offer some improved search performance.
<BR><BR>There are three sets of list container classes:&nbsp; value, pointer and intrusive.
<BR><BR>Value lists are the simplest to use but have the most requirements on the type stored in the lists.&nbsp; Copies are
made of the values stored in the list, which could be undesirable if the stored objects are complicated and copying is expensive.
&nbsp;Value lists should not be used to store objects of a base class if any derived types of different sizes would be stored
in the list, or if the destructor for the derived class must be called.&nbsp; The<TT> WCValSList&lt;Type&gt;</TT> container
class implements single linked value lists, and the<TT> WCValDList&lt;Type&gt;</TT> class double linked value lists.
<BR><BR>Pointer list elements store pointers to objects.&nbsp; No creating, copying or destroying of objects stored in the
list occurs.&nbsp; The only requirement of the type pointed to is that an equivalence operator is provided so that lookups
can be performed.&nbsp; The<TT> WCPtrSList&lt;Type&gt;</TT> class implements single linked pointer lists, and the<TT> WCPtrDList&lt;Type&gt;</TT>
class double linked pointer lists.
<BR><BR>Intrusive lists require that the list elements are objects derived from the<TT> WCSLink</TT> or<TT> WCDLink</TT> class,
depending on whether a single or double linked list is used.&nbsp; The list classes require nothing else from the list elements.
&nbsp;No creating, destroying or copying of any object is performed by the intrusive list classes, and must be done by the
user of the class.&nbsp; One advantage of an intrusive list is a list element can be removed from one list and inserted into
another list without creating new list element objects or deleting old objects.&nbsp; The<TT> WCIsvSList&lt;Type&gt;</TT>
class implements single linked intrusive lists, and the<TT> WCIsvDList&lt;Type&gt;</TT> class double linked intrusive lists.
<BR><BR>A list may be traversed using the corresponding list iterator class.&nbsp; Iterators allow lists to be stepped through
one or more elements at a time.&nbsp; The iterator classes which correspond to single linked list containers have some functionality
inhibited.&nbsp; If backward traversal is required, the double linked containers and iterators must be used.
<BR><BR>The classes are presented in alphabetical order.&nbsp; The<TT> WCSLink</TT> and<TT> WCDLink</TT> class provide a common
control interface for the list elements for the intrusive classes.
<BR><BR>Since the container classes are all template classes, deriving most of the functionality from common base classes
was used.&nbsp; In the listing of class member functions, those public member functions which appear to be in the container
class but are actually defined in the common base class are identified as if they were explicitly specified in the container
class.
<H2 ID="WCDLink_Class_Description"> WCDLink Class Description </H2>
<DL>
<DT>Declared:
<DD><TT> wclcom.h</TT>
<DT>Derived from:
<DD><TT> WCSLink</TT>
<BR><BR>The<TT> WCDLink</TT> class is the building block for all of the double linked list classes.&nbsp; It is implemented
in terms of the<TT> WCSLink</TT> base class.&nbsp; Since no user data is stored directly with it, the<TT> WCDLink</TT> class
should only be used as a base class to derive a user defined class.
<BR>When creating a double linked intrusive list, the<TT> WCDLink</TT> class is used to derive the user defined class that
holds the data to be inserted into the list.
<BR><BR>The<TT> wclcom.h</TT> header file is included by the<TT> wclist.h</TT> header file.&nbsp; There is no need to explicitly
include the<TT> wclcom.h</TT> header file unless the<TT> wclist.h</TT> header file is not included.&nbsp; No errors will result
if it is included.
<BR><BR>Note that the destructor is non-virtual so that list elements are of minimum size.&nbsp; Objects created as a class
derived from the<TT> WCDLink</TT> class, but destroyed while typed as a<TT> WCDLink</TT> object will not invoke the destructor
of the derived class.
<BR><BR><B>Public Member Functions</B>
<BR><BR>The following public member functions are declared:
<BR><BR><TT>WCDLink();</TT>
<BR><TT> ~WCDLink();</TT>
<DT>See Also:
<DD><TT> WCSLink</TT>
</DL>
<H2 ID="WCDLink__WCDLinkLR"> WCDLink() [WCDLink] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCDLink();</TT>
<DT>Semantics:
<DD>The public<TT> WCDLink</TT> constructor creates an<TT> WCDLink</TT> object.&nbsp; The public<TT> WCDLink</TT> constructor
is used implicitly by the compiler when it generates a constructor for a derived class.
<DT>Results:
<DD>The public<TT> WCDLink</TT> constructor produces an initialized<TT> WCDLink</TT> object.
<DT>See Also:
<DD><TT> ~WCDLink</TT>
</DL>
<H2 ID="WCDLink____WCDLinkLR"> ~WCDLink() [WCDLink] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>~WCDLink();</TT>
<DT>Semantics:
<DD>The public<TT> ~WCDLink</TT> destructor does not do anything explicit.&nbsp; The call to the public<TT> ~WCDLink</TT> destructor
is inserted implicitly by the compiler at the point where the object derived from WCDLink goes out of scope.
<DT>Results:
<DD>The object derived from WCDLink is destroyed.
<DT>See Also:
<DD><TT> WCDLink</TT>
</DL>
<H2 ID="WCIsvSListXTypeY__WCIsvDListXTypeY_Class_Description"> WCIsvSList&lt;Type&gt;, WCIsvDList&lt;Type&gt; Class Description </H2>
<DL>
<DT>Declared:
<DD><TT> wclist.h</TT>
<BR><BR>The<TT> WCIsvSList&lt;Type&gt;</TT> and<TT> WCIsvDList&lt;Type&gt;</TT> classes are the templated classes used to
create objects which are single or double linked lists.&nbsp; The created list is intrusive, which means that list elements
which are inserted must be created with a library supplied base class.&nbsp; The class<TT> WCSLink</TT> provides the base
class definition for single linked lists, and should be inherited by the definition of any list item for single linked lists.
&nbsp;It provides the linkage that is used to traverse the list elements.&nbsp; Similarly, the class<TT> WCDLink</TT> provides
the base class definition for double lists, and should be inherited by the definition of any list item for double lists.
<BR>In the description of each member function, the text<TT> Type</TT> is used to indicate the type value specified as the
template parameter.<TT>&nbsp; Type</TT> is the type of the list elements, derived from<TT> WCSLink</TT> or<TT> WCDLink.</TT>
<BR><BR>The<TT> WCExcept</TT> class is a base class of the<TT> WCIsvSList&lt;Type&gt;</TT> and<TT> WCIsvDList&lt;Type&gt;</TT>
classes and provides the<TT> exceptions</TT> member function.&nbsp; This member function controls the exceptions which can
be thrown by the<TT> WCIsvSList&lt;Type&gt;</TT> and<TT> WCIsvDList&lt;Type&gt;</TT> objects.&nbsp; No exceptions are enabled
unless they are set by the<TT> exceptions</TT> member function.
<BR><BR><B>Requirements of Type</B>
<BR><BR>The<TT> WCIsvSList&lt;Type&gt;</TT> class requires only that<TT> Type</TT> is derived from<TT> WCSLink.</TT>&nbsp;
The<TT> WCIsvDList&lt;Type&gt;</TT> class requires only that<TT> Type</TT> is derived from<TT> WCDLink.</TT>
<BR><BR><B>Private Member Functions</B>
<BR><BR>In an intrusive list, copying a list is undefined.&nbsp; Setting the copy constructor and assignment operator as private
is the standard mechanism to ensure a copy cannot be made.&nbsp; The following member functions are declared private:
<BR><BR><TT>void WCIsvSList( const WCIsvSList &amp; );</TT>
<BR><TT> void WCIsvDList( const WCIsvDList &amp; );</TT>
<BR><TT> WCIsvSList &amp; WCIsvSList::operator =( const WCIsvSList &amp; );</TT>
<BR><TT> WCIsvDList &amp; WCIsvDList::operator =( const WCIsvDList &amp; );</TT>
<BR><BR><B>Public Member Functions</B>
<BR><BR>The following member functions are declared in the public interface:
<BR><BR><TT>WCIsvSList();</TT>
<BR><TT> ~WCIsvSList();</TT>
<BR><TT> WCIsvDList();</TT>
<BR><TT> ~WCIsvDList();</TT>
<BR><TT> int append( Type * );</TT>
<BR><TT> void clear();</TT>
<BR><TT> void clearAndDestroy();</TT>
<BR><TT> int contains( const Type * ) const;</TT>
<BR><TT> int entries() const;</TT>
<BR><TT> Type * find( int = 0 ) const;</TT>
<BR><TT> Type * findLast() const;</TT>
<BR><TT> void forAll( void (*)( Type *, void * ), void *);</TT>
<BR><TT> Type * get( int = 0 );</TT>
<BR><TT> int index( const Type * ) const;</TT>
<BR><TT> int index( int (*)( const Type *, void * ), void * ) const;</TT>
<BR><TT> int insert( Type * );</TT>
<BR><TT> int isEmpty() const;</TT>
<BR><BR><B>Public Member Operators</B>
<BR><BR>The following member operators are declared in the public interface:
<BR><BR><TT>int WCIsvSList::operator ==( const WCIsvSList &amp; ) const;</TT>
<BR><TT> int WCIsvDList::operator ==( const WCIsvDList &amp; ) const;</TT>
<BR><BR><B>Sample Program Using an Intrusive List</B>
<BR><BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><BR><TT>class int_ddata : public WCDLink {</TT>
<BR><TT>public:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; inline int_ddata() {};</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; inline int_ddata() {};</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; inline int_ddata( int datum ) : info( datum ) {};</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; info;</TT>
<BR><TT>};</TT>
<BR><BR><TT>static void test1( void );</TT>
<BR><BR><TT>void data_isv_prt( int_ddata * data, void * str ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; cout &lt;&lt; (char *)str &lt;&lt; &quot;[&quot; &lt;&lt; data-&gt;info &lt;&lt; &quot;]\n&quot;;</TT>
<BR><TT>}</TT>
<BR><BR><TT>void main() {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; try {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; test1();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; } catch( ... ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; &quot;we caught an unexpected exception\n&quot;;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; cout.flush();</TT>
<BR><TT>}</TT>
<BR><BR><TT>void test1 ( void ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; WCIsvDList&lt;int_ddata&gt;&nbsp;&nbsp; list;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int_ddata&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data1(1);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int_ddata&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data2(2);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int_ddata&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data3(3);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int_ddata&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data4(4);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int_ddata&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data5(5);</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; list.exceptions( WCExcept::check_all );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; list.append( &amp;data2 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; list.append( &amp;data3 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; list.append( &amp;data4 );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; list.insert( &amp;data1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; list.append( &amp;data5 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; cout &lt;&lt; &quot;&lt;intrusive double list for int_ddata&gt;\n&quot;;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; list.forAll( data_isv_prt, &quot;&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; data_isv_prt( list.find( 3 ), &quot;&lt;the fourth element&gt;&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; data_isv_prt( list.get( 2 ), &quot;&lt;the third element&gt;&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; data_isv_prt( list.get(), &quot;&lt;the first element&gt;&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; list.clear();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; cout.flush();</TT>
<BR><TT>}</TT>
</DL>
<H2 ID="WCIsvSListXTypeY__WCIsvSListLR"> WCIsvSList() [WCIsvSList&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCIsvSList();</TT>
<DT>Semantics:
<DD>The<TT> WCIsvSList</TT> public member function creates an empty<TT> WCIsvSList</TT> object.
<DT>Results:
<DD>The<TT> WCIsvSList</TT> public member function produces an initialized<TT> WCIsvSList</TT> object.
<DT>See Also:
<DD><TT> ~WCIsvSList</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>private:</TT>
<BR><TT>void WCIsvSList( const WCIsvSList &amp; );</TT>
<DT>Semantics:
<DD>The<TT> WCIsvSList</TT> private member function is the copy constructor for the single linked list class.&nbsp; Making a copy
of the list object would result in a error condition, since intrusive lists cannot share data items with other lists.
</DL>
<H2 ID="WCIsvSListXTypeY____WCIsvSListLR"> ~WCIsvSList() [WCIsvSList&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>~WCIsvSList();</TT>
<DT>Semantics:
<DD>The<TT> ~WCIsvSList</TT> public member function destroys the<TT> WCIsvSList</TT> object.&nbsp; If the list is not empty and
the<TT> not_empty</TT> exception is enabled, the exception is thrown.&nbsp; If the<TT> not_empty</TT> exception is not enabled
and the list is not empty, the list is cleared using the<TT> clear</TT> member function.&nbsp; The call to the<TT> ~WCIsvSList</TT>
public member function is inserted implicitly by the compiler at the point where the<TT> WCIsvSList</TT> object goes out of
scope.
<DT>Results:
<DD>The<TT> WCIsvSList</TT> object is destroyed.
<DT>See Also:
<DD><TT> WCIsvSList</TT>,<TT> clear</TT>,<TT> clearAndDestroy</TT>,<TT> WCExcept::not_empty</TT>
</DL>
<H2 ID="WCIsvDListXTypeY__WCIsvDListLR"> WCIsvDList() [WCIsvDList&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCIsvDList();</TT>
<DT>Semantics:
<DD>The<TT> WCIsvDList</TT> public member function creates an empty<TT> WCIsvDList</TT> object.
<DT>Results:
<DD>The<TT> WCIsvDList</TT> public member function produces an initialized<TT> WCIsvDList</TT> object.
<DT>See Also:
<DD><TT> ~WCIsvDList</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>private:</TT>
<BR><TT>WCIsvDList( const WCIsvDList &amp; );</TT>
<DT>Semantics:
<DD>The<TT> WCIsvDList</TT> private member function is the copy constructor for the double linked list class.&nbsp; Making a copy
of the list object would result in a error condition, since intrusive lists cannot share data items with other lists.
</DL>
<H2 ID="WCIsvDListXTypeY____WCIsvDListLR"> ~WCIsvDList() [WCIsvDList&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>~WCIsvDList();</TT>
<DT>Semantics:
<DD>The<TT> ~WCIsvDList</TT> public member function destroys the<TT> WCIsvDList</TT> object.&nbsp; If the list is not empty and
the<TT> not_empty</TT> exception is enabled, the exception is thrown.&nbsp; If the<TT> not_empty</TT> exception is not enabled
and the list is not empty, the list is cleared using the<TT> clear</TT> member function.&nbsp; The call to the<TT> ~WCIsvDList</TT>
public member function is inserted implicitly by the compiler at the point where the<TT> WCIsvDList</TT> object goes out of
scope.
<DT>Results:
<DD>The<TT> WCIsvDList</TT> object is destroyed.
<DT>See Also:
<DD><TT> WCIsvDList</TT>,<TT> clear</TT>,<TT> clearAndDestroy</TT>,<TT> WCExcept::not_empty</TT>
</DL>
<H2 ID="WCIsvSListXTypeY__appendLR__WCIsvDListXTypeY__appendLR"> append() [WCIsvSList&lt;Type&gt;,WCIsvDList&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int append( Type * );</TT>
<DT>Semantics:
<DD>The<TT> append</TT> public member function is used to append the list element object to the end of the list.&nbsp; The address
of (a pointer to) the list element object should be passed, not the value.&nbsp; Since the linkage information is stored in
the list element, it is not possible for the element to be in more than one list, or in the same list more than once.
<BR><BR>The passed list element should be constructed using the appropriate link class as a base.<TT>&nbsp; WCSLink</TT> must
be used as a list element base class for single linked lists, and<TT> WCDLink</TT> must be used as a list element base class
for double linked lists.
<DT>Results:
<DD>The list element is appended to the end of the list and a TRUE value (non-zero) is returned.
<DT>See Also:
<DD><TT> insert</TT>
</DL>
<H2 ID="WCIsvSListXTypeY__clearLR__WCIsvDListXTypeY__clearLR"> clear() [WCIsvSList&lt;Type&gt;,WCIsvDList&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void clear();</TT>
<DT>Semantics:
<DD>The<TT> clear</TT> public member function is used to clear the list object and set it to the state of the object just after
the initial construction.&nbsp; The list object is not destroyed and re-created by this operator, so the object destructor
is not invoked.&nbsp; The list elements are not cleared.&nbsp; Any list items still in the list are lost unless pointed to
by some pointer object in the program code.
<BR><BR>If any of the list elements are not allocated with<TT> new</TT> (local variable or global list elements), then the<TT>
clear</TT> public member function must be used.&nbsp; When all list elements are allocated with<TT> new,</TT> the<TT> clearAndDestory</TT>
member function should be used.
<DT>Results:
<DD>The<TT> clear</TT> public member function resets the list object to the state of the object immediately after the initial
construction.
<DT>See Also:
<DD><TT> ~WCIsvSList</TT>,<TT> ~WCIsvDList</TT>,<TT> clearAndDestroy</TT>,<TT> get</TT>,<TT> operator =</TT>
</DL>
<H2 ID="WCIsvSListXTypeY_WCIsvDListXTypeY__clearAndDestroyLR"> clearAndDestroy() [WCIsvSList&lt;Type&gt;,WCIsvDList&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void clearAndDestroy();</TT>
<DT>Semantics:
<DD>The<TT> clearAndDestroy</TT> public member function is used to clear the list object and set it to the state of the object
just after the initial construction.&nbsp; The list object is not destroyed and re-created by this operator, so the object
destructor is not invoked.&nbsp; The link elements are deleted before the list is re-initialized.
<BR><BR>If any elements in the list were not allocated by the<TT> new</TT> operator, the<TT> clearAndDestroy</TT> public member
function must not be called.&nbsp; The<TT> clearAndDestroy</TT> public member function destroys each list element with the
destructor for<TT> Type</TT> even if the list element was created as an object derived from<TT> Type,</TT> unless<TT> Type</TT>
has a pure virtual destructor.
<DT>Results:
<DD>The<TT> clearAndDestroy</TT> public member function resets the list object to the initial state of the object immediately
after the initial construction and deletes the list elements.
<DT>See Also:
<DD><TT> clear</TT>,<TT> get</TT>
</DL>
<H2 ID="WCIsvSListXTypeY__containsLR__WCIsvDListXTypeY__containsLR"> contains() [WCIsvSList&lt;Type&gt;,WCIsvDList&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int contains( const Type * ) const;</TT>
<DT>Semantics:
<DD>The<TT> contains</TT> public member function is used to determine if a list element object is already contained in the list.
&nbsp;The address of (a pointer to) the list element object should be passed, not the value.&nbsp; Each list element is compared
to the passed element object to determine if it has the same address.&nbsp; Note that the comparison is of the addresses of
the elements, not the contained values.
<DT>Results:
<DD>Zero(0) is returned if the passed list element object is not found in the list.&nbsp; A non-zero result is returned if the
element is found in the list.
<DT>See Also:
<DD><TT> find</TT>,<TT> index</TT>
</DL>
<H2 ID="WCIsvSListXTypeY__entriesLR__WCIsvDListXTypeY__entriesLR"> entries() [WCIsvSList&lt;Type&gt;,WCIsvDList&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int entries() const;</TT>
<DT>Semantics:
<DD>The<TT> entries</TT> public member function is used to determine the number of list elements contained in the list object.
<DT>Results:
<DD>The number of entries stored in the list is returned, zero(0) is returned if there are no list elements.
<DT>See Also:
<DD><TT> isEmpty</TT>
</DL>
<H2 ID="WCIsvSListXTypeY__findLR__WCIsvDListXTypeY__findLR"> find() [WCIsvSList&lt;Type&gt;,WCIsvDList&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Type * find( int = 0 ) const;</TT>
<DT>Semantics:
<DD>The<TT> find</TT> public member function returns a pointer to a list element in the list object.&nbsp; The list element is
not removed from the list, so care must be taken not to delete the element returned to you.&nbsp; The optional parameter specifies
which element to locate, and defaults to the first element.&nbsp; Since the first element of the list is the zero'th element,
the last element will be the number of list entries minus one.
<BR><BR>If the list is empty and the<TT> empty_container</TT> exception is enabled, the exception is thrown.&nbsp; If the<TT>
index_range</TT> exception is enabled, the exception is thrown if the index value is negative or is greater than the number
of list entries minus one.
<DT>Results:
<DD>A pointer to the selected list element or the closest list element is returned.&nbsp; If the index value is negative, the
closest list element is the first element.&nbsp; The last element is the closest element if the index value is greater than
the number of list entries minus one.&nbsp; A value of NULL(0) is returned if there are no elements in the list.
<DT>See Also:
<DD><TT> findLast</TT>,<TT> get</TT>,<TT> index</TT>,<TT> isEmpty</TT>,<TT> WCExcept::empty_container</TT>,<TT> WCExcept::index_range</TT>
</DL>
<H2 ID="WCIsvSListXTypeY__findLastLR__WCIsvDListXTypeY__findLastLR"> findLast() [WCIsvSList&lt;Type&gt;,WCIsvDList&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Type * findLast() const;</TT>
<DT>Semantics:
<DD>The<TT> findLast</TT> public member function returns a pointer to the last list element in the list object.&nbsp; The list
element is not removed from the list, so care must be taken not to delete the element returned to you.
<BR><BR>If the list is empty, one of two exceptions can be thrown.&nbsp; If the<TT> empty_container</TT> exception is enabled,
it is thrown.&nbsp; The<TT> index_range</TT> exception is thrown if it is enabled and the<TT> empty_container</TT> exception
is not enabled.
<DT>Results:
<DD>A pointer to the last list element is returned.&nbsp; A value of NULL(0) is returned if there are no elements in the list.
<DT>See Also:
<DD><TT> find</TT>,<TT> get</TT>,<TT> isEmpty</TT>,<TT> WCExcept::empty_container</TT>,<TT> WCExcept::index_range</TT>
</DL>
<H2 ID="WCIsvSListXTypeY__forAllLR__WCIsvDListXTypeY__forAllLR"> forAll() [WCIsvSList&lt;Type&gt;,WCIsvDList&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void forAll( void (*fn)( Type *, void * ), void *);</TT>
<DT>Semantics:
<DD>The<TT> forAll</TT> public member function is used to cause the function<B> fn</B> to be invoked for each list element.&nbsp;
The<B> fn</B> function should have the prototype
<BR><BR><TT>void (*fn)( Type *, void * )</TT>
<BR><BR>The first parameter of<B> fn</B> shall accept a pointer to the list element currently active.&nbsp; The second argument
passed to<B> fn</B> is the second argument of the<TT> forAll</TT> function.&nbsp; This allows a callback function to be defined
which can accept data appropriate for the point at which the<TT> forAll</TT> function is invoked.
<DT>See Also:
<DD><TT> WCIsvConstSListIter</TT>,<TT> WCIsvConstDListIter</TT>,<TT> WCIsvSListIter</TT>,<TT> WCIsvDListIter</TT>
</DL>
<H2 ID="WCIsvSListXTypeY__getLR__WCIsvDListXTypeY__getLR"> get() [WCIsvSList&lt;Type&gt;,WCIsvDList&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Type * get( int = 0 );</TT>
<DT>Semantics:
<DD>The<TT> get</TT> public member function returns a pointer to a list element in the list object.&nbsp; The list element is
also removed from the list.&nbsp; The optional parameter specifies which element to remove, and defaults to the first element.
&nbsp;Since the first element of the list is the zero'th element, the last element will be the number of list entries minus
one.
<BR><BR>If the list is empty and the<TT> empty_container</TT> exception is enabled, the exception is thrown.&nbsp; If the<TT>
index_range</TT> exception trap is enabled, the exception is thrown if the index value is negative or is greater than the
number of list entries minus one.
<DT>Results:
<DD>A pointer to the selected list element or the closest list element is removed and returned.&nbsp; If the index value is negative,
the closest list element is the first element.&nbsp; The last element is the closest element if the index value is greater
than the number of list entries minus one.&nbsp; A value of NULL(0) is returned if there are no elements in the list.
<DT>See Also:
<DD><TT> clear</TT>,<TT> clearAndDestroy</TT>,<TT> find</TT>,<TT> index</TT>,<TT> WCExcept::empty_container</TT>,<TT> WCExcept::index_range</TT>
</DL>
<H2 ID="WCIsvSListXTypeY__indexLR__WCIsvDListXTypeY__indexLR"> index() [WCIsvSList&lt;Type&gt;,WCIsvDList&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int index( const Type * ) const;</TT>
<DT>Semantics:
<DD>The<TT> index</TT> public member function is used to determine the index of the first list element equivalent to the passed
element.&nbsp; The address of (a pointer to) the list element object should be passed, not the value.&nbsp; Each list element
is compared to the passed element object to determine if it has the same address.&nbsp; Note that the comparison is of the
addresses of the elements, not the contained values.
<DT>Results:
<DD>The index of the first element equivalent to the passed element is returned.&nbsp; If the passed element is not in the list,
negative one (-1) is returned.
<DT>See Also:
<DD><TT> contains</TT>,<TT> find</TT>,<TT> get</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int index( int (*test_fn)( const Type *, void * ),</TT>
<BR><TT> void * ) const;</TT>
<DT>Semantics:
<DD>The<TT> index</TT> public member function is used to determine the index of the first list element for which the supplied<B>
test_fn</B> function returns true.&nbsp; The<B> test_fn</B> function must have the prototype:
<BR><BR><TT>int (*test_fn)( const Type *, void * );</TT>
<BR><BR>Each list element is passed in turn to the<B> test_fn</B> function as the first argument.&nbsp; The second parameter
passed is the second argument of the<TT> index</TT> function.&nbsp; This allows the<B> test_fn</B> callback function to accept
data appropriate for the point at which the<TT> index</TT> function is invoked.&nbsp; The supplied<B> test_fn</B> shall return
a TRUE (non-zero) value when the index of the passed element is desired.&nbsp; Otherwise, a FALSE (zero) value shall be returned.
<DT>Results:
<DD>The index of the first list element for which the<B> test_fn</B> function returns non-zero is returned.&nbsp; If the<B> test_fn</B>
function returns zero for all list elements, negative one (-1) is returned.
<DT>See Also:
<DD><TT> contains</TT>,<TT> find</TT>,<TT> get</TT>
</DL>
<H2 ID="WCIsvSListXTypeY__insertLR__WCIsvDListXTypeY__insertLR"> insert() [WCIsvSList&lt;Type&gt;,WCIsvDList&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int insert( Type * );</TT>
<DT>Semantics:
<DD>The<TT> insert</TT> public member function is used to insert the list element object to the beginning of the list.&nbsp; The
address of (a pointer to) the list element object should be passed, not the value.&nbsp; Since the linkage information is
stored in the list element, it is not possible for the element to be in more than one list, or in the same list more than
once.
<BR><BR>The passed list element should be constructed using the appropriate link class as a base.<TT>&nbsp; WCSLink</TT> must
be used as a list element base class for single linked lists, and<TT> WCDLink</TT> must be used as a list element base class
for double linked lists.
<DT>Results:
<DD>The list element is inserted as the first element of the list and a TRUE value (non-zero) is returned.
<DT>See Also:
<DD><TT> append</TT>
</DL>
<H2 ID="WCIsvSListXTypeY__isEmptyLR__WCIsvDListXTypeY__isEmptyLR"> isEmpty() [WCIsvSList&lt;Type&gt;,WCIsvDList&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int isEmpty() const;</TT>
<DT>Semantics:
<DD>The<TT> isEmpty</TT> public member function is used to determine if a list object has any list elements contained in it.
<DT>Results:
<DD>A TRUE value (non-zero) is returned if the list object does not have any list elements contained within it.&nbsp; A FALSE
(zero) result is returned if the list contains at least one element.
<DT>See Also:
<DD><TT> entries</TT>
</DL>
<H2 ID="WCIsvSListXTypeY__operator_ELR__WCIsvDListXTypeY__operator_ELR"> operator =() [WCIsvSList&lt;Type&gt;,WCIsvDList&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>private:</TT>
<BR><TT>WCIsvSList &amp; WCIsvSList::operator =( const WCIsvSList &amp; );</TT>
<BR><TT> WCIsvDList &amp; WCIsvDList::operator =( const WCIsvDList &amp; );</TT>
<DT>Semantics:
<DD>The<TT> operator =</TT> private member function is the assignment operator for the class.&nbsp; Since making a copy of the
list object would result in a error condition, it is made inaccessible by making it a private operator.
</DL>
<H2 ID="WCIsvSListXTypeY__operator_EELR__WCIsvDListXTypeY__operator_EELR"> operator ==() [WCIsvSList&lt;Type&gt;,WCIsvDList&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int WCIsvSList::operator ==( const WCIsvSList &amp; ) const;</TT>
<BR><TT> int WCIsvDList::operator ==( const WCIsvDList &amp; ) const;</TT>
<DT>Semantics:
<DD>The<TT> operator ==</TT> public member function is the equivalence operator for the<TT> WCIsvSList&lt;Type&gt;</TT> and<TT>
WCIsvDList&lt;Type&gt;</TT> classes.&nbsp; Two list objects are equivalent if they are the same object and share the same
address.
<DT>Results:
<DD>A TRUE (non-zero) value is returned if the left hand side object and the right hand side objects are the same object.&nbsp;
A FALSE (zero) value is returned otherwise.
</DL>
<H2 ID="WCPtrSListXTypeY__WCPtrDListXTypeY_Class_Description"> WCPtrSList&lt;Type&gt;, WCPtrDList&lt;Type&gt; Class Description </H2>
<DL>
<DT>Declared:
<DD><TT> wclist.h</TT>
<BR><BR>The<TT> WCPtrSList&lt;Type&gt;</TT> and<TT> WCPtrDList&lt;Type&gt;</TT> classes are the templated classes used to
create objects which are single or double linked lists.
<BR>In the description of each member function, the text<TT> Type</TT> is used to indicate the type value specified as the
template parameter.&nbsp; The pointers stored in the list point to values of type<TT> Type.</TT>
<BR><BR>The<TT> WCExcept</TT> class is a base class of the<TT> WCPtrSList&lt;Type&gt;</TT> and<TT> WCPtrDList&lt;Type&gt;</TT>
classes and provides the<TT> exceptions</TT> member function.&nbsp; This member function controls the exceptions which can
be thrown by the<TT> WCPtrSList&lt;Type&gt;</TT> and<TT> WCPtrDList&lt;Type&gt;</TT> objects.&nbsp; No exceptions are enabled
unless they are set by the<TT> exceptions</TT> member function.
<BR><BR><B>Requirements of Type</B>
<BR><BR>The<TT> WCPtrSList&lt;Type&gt;</TT> and<TT> WCPtrDList&lt;Type&gt;</TT> classes requires<TT> Type</TT> to have:
<BR>(1) an equivalence operator with constant parameters
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Type::operator ==( const Type &amp; ) const</TT>
<BR><BR><B>Public Member Functions</B>
<BR><BR>The following member functions are declared in the public interface:
<BR><BR><TT>WCPtrSList();</TT>
<BR><TT> WCPtrSList( void * (*)( size_t ), void (*)( void *, size_t ));</TT>
<BR><TT> WCPtrSList( const WCPtrSList &amp; );</TT>
<BR><TT> ~WCPtrSList();</TT>
<BR><TT> WCPtrDList();</TT>
<BR><TT> WCPtrDList( void * (*)( size_t ), void (*)( void *, size_t ));</TT>
<BR><TT> WCPtrDList( const WCPtrDList &amp; );</TT>
<BR><TT> ~WCPtrDList();</TT>
<BR><TT> int append( Type * );</TT>
<BR><TT> void clear();</TT>
<BR><TT> void clearAndDestroy();</TT>
<BR><TT> int contains( const Type * ) const;</TT>
<BR><TT> int entries() const;</TT>
<BR><TT> Type * find( int = 0 ) const;</TT>
<BR><TT> Type * findLast() const;</TT>
<BR><TT> void forAll( void (*)( Type *, void * ), void *) const;</TT>
<BR><TT> Type * get( int = 0 );</TT>
<BR><TT> int index( const Type * ) const;</TT>
<BR><TT> int insert( Type * );</TT>
<BR><TT> int isEmpty() const;</TT>
<BR><BR><B>Public Member Operators</B>
<BR><BR>The following member operators are declared in the public interface:
<BR><BR><TT>WCPtrSList &amp; WCPtrSList::operator =( const WCPtrSList &amp; );</TT>
<BR><TT> WCPtrDList &amp; WCPtrDList::operator =( const WCPtrDList &amp; );</TT>
<BR><TT> int WCPtrSList::operator ==( const WCPtrSList &amp; ) const;</TT>
<BR><TT> int WCPtrDList::operator ==( const WCPtrDList &amp; ) const;</TT>
<BR><BR><B>Sample Program Using a Pointer List</B>
<BR><BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><BR><TT>static void test1( void );</TT>
<BR><BR><TT>void data_ptr_prt( int * data, void * str ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; cout &lt;&lt; (char *)str &lt;&lt; &quot;[&quot; &lt;&lt; *data &lt;&lt; &quot;]\n&quot;;</TT>
<BR><TT>}</TT>
<BR><BR><TT>void main() {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; try {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; test1();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; } catch( ... ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; &quot;we caught an unexpected exception\n&quot;;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; cout.flush();</TT>
<BR><TT>}</TT>
<BR><BR><TT>void test1 ( void ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; WCPtrDList&lt;int&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; list;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; data1(1);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; data2(2);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; data3(3);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; data4(4);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; data5(5);</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; list.append( &amp;data2 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; list.append( &amp;data3 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; list.append( &amp;data4 );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; list.insert( &amp;data1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; list.append( &amp;data5 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; cout &lt;&lt; &quot;&lt;pointer double list for int&gt;\n&quot;;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; list.forAll( data_ptr_prt, &quot;&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; data_ptr_prt( list.find( 3 ), &quot;&lt;the fourth element&gt;&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; data_ptr_prt( list.get( 2 ), &quot;&lt;the third element&gt;&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; data_ptr_prt( list.get(), &quot;&lt;the first element&gt;&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; list.clear();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; cout.flush();</TT>
<BR><TT>}</TT>
</DL>
<H2 ID="WCPtrSListXTypeY__WCPtrSListLR"> WCPtrSList() [WCPtrSList&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCPtrSList();</TT>
<DT>Semantics:
<DD>The<TT> WCPtrSList</TT> public member function creates an empty<TT> WCPtrSList</TT> object.
<DT>Results:
<DD>The<TT> WCPtrSList</TT> public member function produces an initialized<TT> WCPtrSList</TT> object.
<DT>See Also:
<DD><TT> WCPtrSList</TT>,<TT> ~WCPtrSList</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCPtrSList( void *(*allocator)( size_t ),</TT>
<BR><TT> void (*deallocator)( void *, size_t ) );</TT>
<DT>Semantics:
<DD>The<TT> WCPtrSList</TT> public member function creates an empty<TT> WCPtrSList&lt;Type&gt;</TT> object.&nbsp; The<B> allocator</B>
function is registered to perform all memory allocations of the list elements, and the<B> deallocator</B> function to perform
all freeing of the list elements' memory.&nbsp; These functions provide the ability to control how the allocation and freeing
of memory is performed, allowing for more efficient memory handling than the general purpose global<TT> operator new()</TT>
and<TT> operator delete()</TT> can provide.&nbsp; Memory management optimizations may potentially be made through the<B> allocator</B>
and<B> deallocator</B> functions, but are not recommended before managing memory is understood and determined to be worth
while.
<BR><BR>The<B> allocator</B> function shall return a pointer to allocated memory of size at least the argument, or zero(0)
if the allocation cannot be performed.&nbsp; Initialization of the memory returned is performed by the<TT> WCPtrSList&lt;Type&gt;</TT>
class.
<BR><BR>The<TT> WCPtrSList&lt;Type&gt;</TT> class calls the<B> deallocator</B> function only on memory allocated by the<B>
allocator</B> function.&nbsp; The<B> deallocator</B> shall free the memory pointed to by the first argument which is of size
the second argument.&nbsp; The size passed to the<B> deallocator</B> function is guaranteed to be the same size passed to
the<B> allocator</B> function when the memory was allocated.
<BR><BR>The<B> allocator</B> and<B> deallocator</B> functions may assume that for a list object instance, the<B> allocator</B>
is always called with the same first argument (the size of the memory to be allocated).&nbsp; The<TT> WCValSListItemSize(Type)</TT>
macro returns the size of the elements which are allocated by the<B> allocator</B> function.
<DT>Results:
<DD>The<TT> WCPtrSList</TT> public member function creates an initialized<TT> WCPtrSList&lt;Type&gt;</TT> object and registers
the<B> allocator</B> and<B> deallocator</B> functions.
<DT>See Also:
<DD><TT> WCPtrSList</TT>,<TT> ~WCPtrSList</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void WCPtrSList( const WCPtrSList &amp; );</TT>
<DT>Semantics:
<DD>The<TT> WCPtrSList</TT> public member function is the copy constructor for the single linked list class.&nbsp; All of the
list elements are copied to the new list, as well as the exception trap states, and any registered<B> allocator</B> and<B>
deallocator</B> functions.
<BR><BR>If all of the elements cannot be copied and the<TT> out_of_memory</TT> is enabled in the list being copied, the exception
is thrown.&nbsp; The new list is created in a valid state, even if all of the list elements could not be copied.
<DT>Results:
<DD>The<TT> WCPtrSList</TT> public member function produces a copy of the list.
<DT>See Also:
<DD><TT> WCPtrSList</TT>,<TT> ~WCPtrSList</TT>,<TT> clear</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<H2 ID="WCPtrSListXTypeY____WCPtrSListLR"> ~WCPtrSList() [WCPtrSList&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>~WCPtrSList();</TT>
<DT>Semantics:
<DD>The<TT> ~WCPtrSList</TT> public member function destroys the<TT> WCPtrSList</TT> object.&nbsp; If the list is not empty and
the<TT> not_empty</TT> exception is enabled, the exception is thrown.&nbsp; If the<TT> not_empty</TT> exception is not enabled
and the list is not empty, the list is cleared using the<TT> clear</TT> member function.&nbsp; The call to the<TT> ~WCPtrSList</TT>
public member function is inserted implicitly by the compiler at the point where the<TT> WCPtrSList</TT> object goes out of
scope.
<DT>Results:
<DD>The<TT> WCPtrSList</TT> object is destroyed.
<DT>See Also:
<DD><TT> WCPtrSList</TT>,<TT> clear</TT>,<TT> clearAndDestroy</TT>,<TT> WCExcept::not_empty</TT>
</DL>
<H2 ID="WCPtrDListXTypeY__WCPtrDListLR"> WCPtrDList() [WCPtrDList&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCPtrDList();</TT>
<DT>Semantics:
<DD>The<TT> WCPtrDList</TT> public member function creates an empty<TT> WCPtrDList</TT> object.
<DT>Results:
<DD>The<TT> WCPtrDList</TT> public member function produces an initialized<TT> WCPtrDList</TT> object.
<DT>See Also:
<DD><TT> WCPtrDList</TT>,<TT> ~WCPtrDList</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCPtrDList( void *(*allocator)( size_t ),</TT>
<BR><TT> void (*deallocator)( void *, size_t ) );</TT>
<DT>Semantics:
<DD>The<TT> WCPtrDList</TT> public member function creates an empty<TT> WCPtrDList&lt;Type&gt;</TT> object.&nbsp; The<B> allocator</B>
function is registered to perform all memory allocations of the list elements, and the<B> deallocator</B> function to perform
all freeing of the list elements' memory.&nbsp; These functions provide the ability to control how the allocation and freeing
of memory is performed, allowing for more efficient memory handling than the general purpose global<TT> operator new()</TT>
and<TT> operator delete()</TT> can provide.&nbsp; Memory management optimizations may potentially be made through the<B> allocator</B>
and<B> deallocator</B> functions, but are not recommended before managing memory is understood and determined to be worth
while.
<BR><BR>The<B> allocator</B> function shall return a pointer to allocated memory of size at least the argument, or zero(0)
if the allocation cannot be performed.&nbsp; Initialization of the memory returned is performed by the<TT> WCPtrDList&lt;Type&gt;</TT>
class.
<BR><BR>The<TT> WCPtrDList&lt;Type&gt;</TT> class calls the<B> deallocator</B> function only on memory allocated by the<B>
allocator</B> function.&nbsp; The<B> deallocator</B> shall free the memory pointed to by the first argument which is of size
the second argument.&nbsp; The size passed to the<B> deallocator</B> function is guaranteed to be the same size passed to
the<B> allocator</B> function when the memory was allocated.
<BR><BR>The<B> allocator</B> and<B> deallocator</B> functions may assume that for a list object instance, the<B> allocator</B>
is always called with the same first argument (the size of the memory to be allocated).&nbsp; The<TT> WCValDListItemSize(Type)</TT>
macro returns the size of the elements which are allocated by the<B> allocator</B> function.
<DT>Results:
<DD>The<TT> WCPtrDList</TT> public member function creates an initialized<TT> WCPtrDList&lt;Type&gt;</TT> object and registers
the<B> allocator</B> and<B> deallocator</B> functions.
<DT>See Also:
<DD><TT> WCPtrDList</TT>,<TT> ~WCPtrDList</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCPtrDList( const WCPtrDList &amp; );</TT>
<DT>Semantics:
<DD>The<TT> WCPtrDList</TT> public member function is the copy constructor for the double linked list class.&nbsp; All of the
list elements are copied to the new list, as well as the exception trap states, and any registered<B> allocator</B> and<B>
deallocator</B> functions.
<BR><BR>If all of the elements cannot be copied and the<TT> out_of_memory</TT> is enabled in the list being copied, the exception
is thrown.&nbsp; The new list is created in a valid state, even if all of the list elements could not be copied.
<DT>Results:
<DD>The<TT> WCPtrDList</TT> public member function produces a copy of the list.
<DT>See Also:
<DD><TT> WCPtrDList</TT>,<TT> ~WCPtrDList</TT>,<TT> clear</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<H2 ID="WCPtrDListXTypeY____WCPtrDListLR"> ~WCPtrDList() [WCPtrDList&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>~WCPtrDList();</TT>
<DT>Semantics:
<DD>The<TT> ~WCPtrDList</TT> public member function destroys the<TT> WCPtrDList</TT> object.&nbsp; If the list is not empty and
the<TT> not_empty</TT> exception is enabled, the exception is thrown.&nbsp; If the<TT> not_empty</TT> exception is not enabled
and the list is not empty, the list is cleared using the<TT> clear</TT> member function.&nbsp; The call to the<TT> ~WCPtrDList</TT>
public member function is inserted implicitly by the compiler at the point where the<TT> WCPtrDList</TT> object goes out of
scope.
<DT>Results:
<DD>The<TT> WCPtrDList</TT> object is destroyed.
<DT>See Also:
<DD><TT> WCPtrDList</TT>,<TT> clear</TT>,<TT> clearAndDestroy</TT>,<TT> WCExcept::not_empty</TT>
</DL>
<H2 ID="WCPtrSListXTypeY__appendLR__WCPtrDListXTypeY__appendLR"> append() [WCPtrSList&lt;Type&gt;,WCPtrDList&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int append( Type * );</TT>
<DT>Semantics:
<DD>The<TT> append</TT> public member function is used to append the data to the end of the list.
<BR><BR>If the<TT> out_of_memory</TT> exception is enabled and the append fails, the exception is thrown.
<DT>Results:
<DD>The data element is appended to the end of the list.&nbsp; A TRUE value (non-zero) is returned if the append is successful.
&nbsp;A FALSE (zero) result is returned if the append fails.
<DT>See Also:
<DD><TT> insert</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<H2 ID="WCPtrSListXTypeY__clearLR__WCPtrDListXTypeY__clearLR"> clear() [WCPtrSList&lt;Type&gt;,WCPtrDList&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void clear();</TT>
<DT>Semantics:
<DD>The<TT> clear</TT> public member function is used to clear the list object and set it to the state of the object just after
the initial construction.&nbsp; The list object is not destroyed and re-created by this operator, so the object destructor
is not invoked.
<DT>Results:
<DD>The<TT> clear</TT> public member function resets the list object to the state of the object immediately after the initial
construction.
<DT>See Also:
<DD><TT> ~WCPtrSList</TT>,<TT> ~WCPtrDList</TT>,<TT> clearAndDestroy</TT>,<TT> get</TT>,<TT> operator =</TT>
</DL>
<H2 ID="WCPtrSListXTypeY_WCPtrDListXTypeY__clearAndDestroyLR"> clearAndDestroy() [WCPtrSList&lt;Type&gt;,WCPtrDList&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void clearAndDestroy();</TT>
<DT>Semantics:
<DD>The<TT> clearAndDestroy</TT> public member function is used to clear the list object and set it to the state of the object
just after the initial construction.&nbsp; The list object is not destroyed and re-created by this operator, so the object
destructor is not invoked.&nbsp; Before the list object is re-initialized, the the values pointed to by the list elements
are deleted.
<DT>Results:
<DD>The<TT> clearAndDestroy</TT> public member function resets the list object to the initial state of the object immediately
after the initial construction and deletes the list elements.
<DT>See Also:
<DD><TT> clear</TT>,<TT> get</TT>
</DL>
<H2 ID="WCPtrSListXTypeY__containsLR__WCPtrDListXTypeY__containsLR"> contains() [WCPtrSList&lt;Type&gt;,WCPtrDList&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int contains( const Type * ) const;</TT>
<DT>Semantics:
<DD>The<TT> contains</TT> public member function is used to determine if a list element object is already contained in the list.
&nbsp;Each list element is compared to the passed element using<TT> Type's operator ==</TT> to determine if the passed element
is contained in the list.&nbsp; Note that the comparison is of the objects pointed to.
<DT>Results:
<DD>Zero(0) is returned if the passed list element object is not found in the list.&nbsp; A non-zero result is returned if the
element is found in the list.
<DT>See Also:
<DD><TT> find</TT>,<TT> index</TT>
</DL>
<H2 ID="WCPtrSListXTypeY__entriesLR__WCPtrDListXTypeY__entriesLR"> entries() [WCPtrSList&lt;Type&gt;,WCPtrDList&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int entries() const;</TT>
<DT>Semantics:
<DD>The<TT> entries</TT> public member function is used to determine the number of list elements contained in the list object.
<DT>Results:
<DD>The number of entries stored in the list is returned, zero(0) is returned if there are no list elements.
<DT>See Also:
<DD><TT> isEmpty</TT>
</DL>
<H2 ID="WCPtrSListXTypeY__findLR__WCPtrDListXTypeY__findLR"> find() [WCPtrSList&lt;Type&gt;,WCPtrDList&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Type * find( int = 0 ) const;</TT>
<DT>Semantics:
<DD>The<TT> find</TT> public member function returns the value of a list element in the list object.&nbsp; The optional parameter
specifies which element to locate, and defaults to the first element.&nbsp; Since the first element of the list is the zero'th
element, the last element will be the number of list entries minus one.
<BR><BR>If the list is empty and the<TT> empty_container</TT> exception is enabled, the exception is thrown.&nbsp; If the<TT>
index_range</TT> exception is enabled, the exception is thrown if the index value is negative or is greater than the number
of list entries minus one.
<DT>Results:
<DD>The value of the selected list element or the closest element is returned.&nbsp; If the index value is negative, the closest
list element is the first element.&nbsp; The last element is the closest element if the index value is greater than the number
of list entries minus one.&nbsp; An uninitialized pointer is returned if there are no elements in the list.
<DT>See Also:
<DD><TT> findLast</TT>,<TT> get</TT>,<TT> index</TT>,<TT> isEmpty</TT>,<TT> WCExcept::empty_container</TT>,<TT> WCExcept::index_range</TT>
</DL>
<H2 ID="WCPtrSListXTypeY__findLastLR__WCPtrDListXTypeY__findLastLR"> findLast() [WCPtrSList&lt;Type&gt;,WCPtrDList&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Type * findLast() const;</TT>
<DT>Semantics:
<DD>The<TT> findLast</TT> public member function returns the value of the last list element in the list object.
<BR><BR>If the list is empty, one of two exceptions can be thrown.&nbsp; If the<TT> empty_container</TT> exception is enabled,
it is thrown.&nbsp; The<TT> index_range</TT> exception is thrown if it is enabled and the<TT> empty_container</TT> exception
is not enabled.
<DT>Results:
<DD>The value of the last list element is returned.&nbsp; An uninitialized pointer is returned if there are no elements in the
list.
<DT>See Also:
<DD><TT> find</TT>,<TT> get</TT>,<TT> isEmpty</TT>,<TT> WCExcept::empty_container</TT>,<TT> WCExcept::index_range</TT>
</DL>
<H2 ID="WCPtrSListXTypeY__forAllLR__WCPtrDListXTypeY__forAllLR"> forAll() [WCPtrSList&lt;Type&gt;,WCPtrDList&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void forAll( void (*)( Type *, void * ), void *) const;</TT>
<DT>Semantics:
<DD>The<TT> forAll</TT> public member function is used to cause the function<B> fn</B> to be invoked for each list element.&nbsp;
The<B> fn</B> function should have the prototype
<BR><BR><TT>void (*fn)( Type *, void * )</TT>
<BR><BR>The first parameter of<B> fn</B> shall accept the value of the list element currently active.&nbsp; The second argument
passed to<B> fn</B> is the second argument of the<TT> forAll</TT> function.&nbsp; This allows a callback function to be defined
which can accept data appropriate for the point at which the<TT> forAll</TT> function is invoked.
<DT>See Also:
<DD><TT> WCPtrConstSListIter</TT>,<TT> WCPtrConstDListIter</TT>,<TT> WCPtrSListIter</TT>,<TT> WCPtrDListIter</TT>
</DL>
<H2 ID="WCPtrSListXTypeY__getLR__WCPtrDListXTypeY__getLR"> get() [WCPtrSList&lt;Type&gt;,WCPtrDList&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Type * get( int = 0 );</TT>
<DT>Semantics:
<DD>The<TT> get</TT> public member function returns the value of the list element in the list object.&nbsp; The list element is
also removed from the list.&nbsp; The optional parameter specifies which element to remove, and defaults to the first element.
&nbsp;Since the first element of the list is the zero'th element, the last element will be the number of list entries minus
one.
<BR><BR>If the list is empty and the<TT> empty_container</TT> exception is enabled, the exception is thrown.&nbsp; If the<TT>
index_range</TT> exception trap is enabled, the exception is thrown if the index value is negative or is greater than the
number of list entries minus one.
<DT>Results:
<DD>The value of the selected list element or the closest element is removed and returned.&nbsp; If the index value is negative,
the closest list element is the first element.&nbsp; The last element is the closest element if the index value is greater
than the number of list entries minus one.&nbsp; An uninitialized pointer is returned if there are no elements in the list.
<DT>See Also:
<DD><TT> clear</TT>,<TT> clearAndDestroy</TT>,<TT> find</TT>,<TT> index</TT>,<TT> WCExcept::empty_container</TT>,<TT> WCExcept::index_range</TT>
</DL>
<H2 ID="WCPtrSListXTypeY__indexLR__WCPtrDListXTypeY__indexLR"> index() [WCPtrSList&lt;Type&gt;,WCPtrDList&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int index( const Type * ) const;</TT>
<DT>Semantics:
<DD>The<TT> index</TT> public member function is used to determine the index of the first list element equivalent to the passed
element.&nbsp; Each list element is compared to the passed element using<TT> Type's operator ==</TT> until the passed element
is found, or all list elements have been checked.&nbsp; Note that the comparison is of the objects pointed to.
<DT>Results:
<DD>The index of the first element equivalent to the passed element is returned.&nbsp; If the passed element is not in the list,
negative one (-1) is returned.
<DT>See Also:
<DD><TT> contains</TT>,<TT> find</TT>,<TT> get</TT>
</DL>
<H2 ID="WCPtrSListXTypeY__insertLR__WCPtrDListXTypeY__insertLR"> insert() [WCPtrSList&lt;Type&gt;,WCPtrDList&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int insert( Type * );</TT>
<DT>Semantics:
<DD>The<TT> insert</TT> public member function is used to insert the data as the first element of the list.
<BR><BR>If the<TT> out_of_memory</TT> exception is enabled and the insert fails, the exception is thrown.
<DT>Results:
<DD>The data element is inserted into the beginning of the list.&nbsp; A TRUE value (non-zero) is returned if the insert is successful.
&nbsp;A FALSE (zero) result is returned if the insert fails.
<DT>See Also:
<DD><TT> append</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<H2 ID="WCPtrSListXTypeY__isEmptyLR__WCPtrDListXTypeY__isEmptyLR"> isEmpty() [WCPtrSList&lt;Type&gt;,WCPtrDList&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int isEmpty() const;</TT>
<DT>Semantics:
<DD>The<TT> isEmpty</TT> public member function is used to determine if a list object has any list elements contained in it.
<DT>Results:
<DD>A TRUE value (non-zero) is returned if the list object does not have any list elements contained within it.&nbsp; A FALSE
(zero) result is returned if the list contains at least one element.
<DT>See Also:
<DD><TT> entries</TT>
</DL>
<H2 ID="WCPtrSListXTypeY__operator_ELR__WCPtrDListXTypeY__operator_ELR"> operator =() [WCPtrSList&lt;Type&gt;,WCPtrDList&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCPtrSList &amp; WCPtrSList::operator =( const WCPtrSList &amp; );</TT>
<BR><TT> WCPtrDList &amp; WCPtrDList::operator =( const WCPtrDList &amp; );</TT>
<DT>Semantics:
<DD>The<TT> operator =</TT> public member function is the assignment operator for the class.&nbsp; The left hand side of the assignment
is first cleared with the<TT> clear</TT> member function.&nbsp; All elements in the right hand side list are then copied,
as well as the exception trap states, and any registered<B> allocator</B> and<B> deallocator</B> functions.
<BR><BR>If all of the elements cannot be copied and the<TT> out_of_memory</TT> is enabled in the right hand side list, the
exception is thrown.&nbsp; The new list is created in a valid state, even if all of the list elements could not be copied.
<DT>Results:
<DD>The<TT> operator =</TT> public member function assigns the right hand side to the left hand side and returns a reference to
the left hand side.
<DT>See Also:
<DD><TT> WCPtrSList</TT>,<TT> WCPtrDList</TT>,<TT> clear</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<H2 ID="WCPtrSListXTypeY__operator_EELR__WCPtrDListXTypeY__operator_EELR"> operator ==() [WCPtrSList&lt;Type&gt;,WCPtrDList&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int WCPtrSList::operator ==( const WCPtrSList &amp; ) const;</TT>
<BR><TT> int WCPtrDList::operator ==( const WCPtrDList &amp; ) const;</TT>
<DT>Semantics:
<DD>The<TT> operator ==</TT> public member function is the equivalence operator for the<TT> WCPtrSList&lt;Type&gt;</TT> and<TT>
WCPtrDList&lt;Type&gt;</TT> classes.&nbsp; Two list objects are equivalent if they are the same object and share the same
address.
<DT>Results:
<DD>A TRUE (non-zero) value is returned if the left hand side object and the right hand side objects are the same object.&nbsp;
A FALSE (zero) value is returned otherwise.
</DL>
<H2 ID="WCSLink_Class_Description"> WCSLink Class Description </H2>
<DL>
<DT>Declared:
<DD><TT> wclcom.h</TT>
<DT>Derived by:
<DD><TT> WCDLink</TT>
<BR><BR>The<TT> WCSLink</TT> class is the building block for all of the list classes.&nbsp; It provides the link that is used
to traverse the list elements.&nbsp; The double link classes use the<TT> WCSLink</TT> class to implement both links.&nbsp;
Since no user data is stored directly with it, the<TT> WCSLink</TT> class should only be used as a base class to derive a
user defined class.
<BR>When creating a single linked intrusive list, the<TT> WCSLink</TT> class is used to derive the user defined class that
holds the data to be inserted into the list.
<BR><BR>The<TT> wclcom.h</TT> header file is included by the<TT> wclist.h</TT> header file.&nbsp; There is no need to explicitly
include the<TT> wclcom.h</TT> header file unless the<TT> wclist.h</TT> header file is not included.&nbsp; No errors will result
if it is included unnecessarily.
<BR><BR>Note that the destructor is non-virtual so that list elements are of minimum size.&nbsp; Objects created as a class
derived from the<TT> WCSLink</TT> class, but destroyed while typed as a<TT> WCSLink</TT> object will not invoke the destructor
of the derived class.
<BR><BR><B>Public Member Functions</B>
<BR><BR>The following public member functions are declared:
<BR><BR><TT>WCSLink();</TT>
<BR><TT> ~WCSLink();</TT>
<DT>See Also:
<DD><TT> WCDLink</TT>
</DL>
<H2 ID="WCSLink__WCSLinkLR"> WCSLink() [WCSLink] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclcom.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCSLink();</TT>
<DT>Semantics:
<DD>The public<TT> WCSLink</TT> constructor creates an<TT> WCSLink</TT> object.&nbsp; The public<TT> WCSLink</TT> constructor
is used implicitly by the compiler when it generates a constructor for a derived class.
<DT>Results:
<DD>The public<TT> WCSLink</TT> constructor produces an initialized<TT> WCSLink</TT> object.
<DT>See Also:
<DD><TT> ~WCSLink</TT>
</DL>
<H2 ID="WCSLink____WCSLinkLR"> ~WCSLink() [WCSLink] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclcom.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>~WCSLink();</TT>
<DT>Semantics:
<DD>The public<TT> ~WCSLink</TT> destructor does not do anything explicit.&nbsp; The call to the public<TT> ~WCSLink</TT> destructor
is inserted implicitly by the compiler at the point where the object derived from WCSLink goes out of scope.
<DT>Results:
<DD>The object derived from WCSLink is destroyed.
<DT>See Also:
<DD><TT> WCSLink</TT>
</DL>
<H2 ID="WCValSListXTypeY__WCValDListXTypeY_Class_Description"> WCValSList&lt;Type&gt;, WCValDList&lt;Type&gt; Class Description </H2>
<DL>
<DT>Declared:
<DD><TT> wclist.h</TT>
<BR><BR>The<TT> WCValSList&lt;Type&gt;</TT> and<TT> WCValDList&lt;Type&gt;</TT> classes are the templated classes used to
create objects which are single or double linked lists.&nbsp; Values are copied into the list, which could be undesirable
if the stored objects are complicated and copying is expensive.&nbsp; Value lists should not be used to store objects of a
base class if any derived types of different sizes would be stored in the list, or if the destructor for a derived class must
be called.
<BR>In the description of each member function, the text<TT> Type</TT> is used to indicate the type value specified as the
template parameter.<TT>&nbsp; Type</TT> is the type of the values stored in the list.
<BR><BR>The<TT> WCExcept</TT> class is a base class of the<TT> WCValSList&lt;Type&gt;</TT> and<TT> WCValDList&lt;Type&gt;</TT>
classes and provides the<TT> exceptions</TT> member function.&nbsp; This member function controls the exceptions which can
be thrown by the<TT> WCValSList&lt;Type&gt;</TT> and<TT> WCValDList&lt;Type&gt;</TT> objects.&nbsp; No exceptions are enabled
unless they are set by the<TT> exceptions</TT> member function.
<BR><BR><B>Requirements of Type</B>
<BR><BR>The<TT> WCValSList&lt;Type&gt;</TT> and<TT> WCValDList&lt;Type&gt;</TT> classes requires<TT> Type</TT> to have:
<BR>(1) a default constructor (<TT> Type::Type()</TT> ).
<BR><BR>(2) a well defined copy constructor (<TT> Type::Type( const Type &amp; )</TT> ).
<BR><BR>(3) an equivalence operator with constant parameters
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Type::operator ==( const Type &amp; ) const</TT>
<BR><BR><B>Public Member Functions</B>
<BR><BR>The following member functions are declared in the public interface:
<BR><BR><TT>WCValSList();</TT>
<BR><TT> WCValSList( void * (*)( size_t ), void (*)( void *, size_t ));</TT>
<BR><TT> WCValSList( const WCValSList &amp; );</TT>
<BR><TT> ~WCValSList();</TT>
<BR><TT> WCValDList();</TT>
<BR><TT> WCValDList( void * (*)( size_t ), void (*)( void *, size_t ));</TT>
<BR><TT> WCValDList( const WCValDList &amp; );</TT>
<BR><TT> ~WCValDList();</TT>
<BR><TT> int append( const Type &amp; );</TT>
<BR><TT> void clear();</TT>
<BR><TT> void clearAndDestroy();</TT>
<BR><TT> int contains( const Type &amp; ) const;</TT>
<BR><TT> int entries() const;</TT>
<BR><TT> Type find( int = 0 ) const;</TT>
<BR><TT> Type findLast() const;</TT>
<BR><TT> void forAll( void (*)( Type, void * ), void *) const;</TT>
<BR><TT> Type get( int = 0 );</TT>
<BR><TT> int index( const Type &amp; ) const;</TT>
<BR><TT> int insert( const Type &amp; );</TT>
<BR><TT> int isEmpty() const;</TT>
<BR><BR><B>Public Member Operators</B>
<BR><BR>The following member operators are declared in the public interface:
<BR><BR><TT>WCValSList &amp; WCValSList::operator =( const WCValSList &amp; );</TT>
<BR><TT> WCValDList &amp; WCValDList::operator =( const WCValDList &amp; );</TT>
<BR><TT> int WCValSList::operator ==( const WCValSList &amp; ) const;</TT>
<BR><TT> int WCValDList::operator ==( const WCValDList &amp; ) const;</TT>
<BR><BR><B>Sample Program Using a Value List</B>
<BR><BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><BR><TT>static void test1( void );</TT>
<BR><BR><TT>void data_val_prt( int data, void * str ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; cout &lt;&lt; (char *)str &lt;&lt; &quot;[&quot; &lt;&lt; data &lt;&lt; &quot;]\n&quot;;</TT>
<BR><TT>}</TT>
<BR><BR><TT>void main() {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; try {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; test1();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; } catch( ... ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; &quot;we caught an unexpected exception\n&quot;;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; cout.flush();</TT>
<BR><TT>}</TT>
<BR><BR><TT>void test1 ( void ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; WCValDList&lt;int&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; list;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; list.append( 2 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; list.append( 3 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; list.append( 4 );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; list.insert( 1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; list.append( 5 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; cout &lt;&lt; &quot;&lt;value double list for int&gt;\n&quot;;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; list.forAll( data_val_prt, &quot;&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; data_val_prt( list.find( 3 ), &quot;&lt;the fourth element&gt;&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; data_val_prt( list.get( 2 ), &quot;&lt;the third element&gt;&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; data_val_prt( list.get(), &quot;&lt;the first element&gt;&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; list.clear();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; cout.flush();</TT>
<BR><TT>}</TT>
</DL>
<H2 ID="WCValSListXTypeY__WCValSListLR"> WCValSList() [WCValSList&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCValSList();</TT>
<DT>Semantics:
<DD>The<TT> WCValSList</TT> public member function creates an empty<TT> WCValSList</TT> object.
<DT>Results:
<DD>The<TT> WCValSList</TT> public member function produces an initialized<TT> WCValSList</TT> object.
<DT>See Also:
<DD><TT> WCValSList</TT>,<TT> ~WCValSList</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCValSList( void *(*allocator)( size_t ),</TT>
<BR><TT> void (*deallocator)( void *, size_t ) );</TT>
<DT>Semantics:
<DD>The<TT> WCValSList</TT> public member function creates an empty<TT> WCValSList&lt;Type&gt;</TT> object.&nbsp; The<B> allocator</B>
function is registered to perform all memory allocations of the list elements, and the<B> deallocator</B> function to perform
all freeing of the list elements' memory.&nbsp; These functions provide the ability to control how the allocation and freeing
of memory is performed, allowing for more efficient memory handling than the general purpose global<TT> operator new()</TT>
and<TT> operator delete()</TT> can provide.&nbsp; Memory management optimizations may potentially be made through the<B> allocator</B>
and<B> deallocator</B> functions, but are not recommended before managing memory is understood and determined to be worth
while.
<BR><BR>The<B> allocator</B> function shall return a pointer to allocated memory of size at least the argument, or zero(0)
if the allocation cannot be performed.&nbsp; Initialization of the memory returned is performed by the<TT> WCValSList&lt;Type&gt;</TT>
class.
<BR><BR>The<TT> WCValSList&lt;Type&gt;</TT> class calls the<B> deallocator</B> function only on memory allocated by the<B>
allocator</B> function.&nbsp; The<B> deallocator</B> shall free the memory pointed to by the first argument which is of size
the second argument.&nbsp; The size passed to the<B> deallocator</B> function is guaranteed to be the same size passed to
the<B> allocator</B> function when the memory was allocated.
<BR><BR>The<B> allocator</B> and<B> deallocator</B> functions may assume that for a list object instance, the<B> allocator</B>
is always called with the same first argument (the size of the memory to be allocated).&nbsp; The<TT> WCValSListItemSize(Type)</TT>
macro returns the size of the elements which are allocated by the<B> allocator</B> function.
<DT>Results:
<DD>The<TT> WCValSList</TT> public member function creates an initialized<TT> WCValSList&lt;Type&gt;</TT> object and registers
the<B> allocator</B> and<B> deallocator</B> functions.
<DT>See Also:
<DD><TT> WCValSList</TT>,<TT> ~WCValSList</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void WCValSList( const WCValSList &amp; );</TT>
<DT>Semantics:
<DD>The<TT> WCValSList</TT> public member function is the copy constructor for the single linked list class.&nbsp; All of the
list elements are copied to the new list, as well as the exception trap states, and any registered<B> allocator</B> and<B>
deallocator</B> functions.<TT>&nbsp; Type's</TT> copy constructor is invoked to copy the values contained by the list elements.
<BR><BR>If all of the elements cannot be copied and the<TT> out_of_memory</TT> is enabled in the list being copied, the exception
is thrown.&nbsp; The new list is created in a valid state, even if all of the list elements could not be copied.
<DT>Results:
<DD>The<TT> WCValSList</TT> public member function produces a copy of the list.
<DT>See Also:
<DD><TT> WCValSList</TT>,<TT> ~WCValSList</TT>,<TT> clear</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<H2 ID="WCValSListXTypeY____WCValSListLR"> ~WCValSList() [WCValSList&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>~WCValSList();</TT>
<DT>Semantics:
<DD>The<TT> ~WCValSList</TT> public member function destroys the<TT> WCValSList</TT> object.&nbsp; If the list is not empty and
the<TT> not_empty</TT> exception is enabled, the exception is thrown.&nbsp; If the<TT> not_empty</TT> exception is not enabled
and the list is not empty, the list is cleared using the<TT> clear</TT> member function.&nbsp; The call to the<TT> ~WCValSList</TT>
public member function is inserted implicitly by the compiler at the point where the<TT> WCValSList</TT> object goes out of
scope.
<DT>Results:
<DD>The<TT> WCValSList</TT> object is destroyed.
<DT>See Also:
<DD><TT> WCValSList</TT>,<TT> clear</TT>,<TT> clearAndDestroy</TT>,<TT> WCExcept::not_empty</TT>
</DL>
<H2 ID="WCValDListXTypeY__WCValDListLR"> WCValDList() [WCValDList&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCValDList();</TT>
<DT>Semantics:
<DD>The<TT> WCValDList</TT> public member function creates an empty<TT> WCValDList</TT> object.
<DT>Results:
<DD>The<TT> WCValDList</TT> public member function produces an initialized<TT> WCValDList</TT> object.
<DT>See Also:
<DD><TT> WCValDList</TT>,<TT> ~WCValDList</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCValDList( void *(*allocator)( size_t ),</TT>
<BR><TT> void (*deallocator)( void *, size_t ) );</TT>
<DT>Semantics:
<DD>The<TT> WCValDList</TT> public member function creates an empty<TT> WCValDList&lt;Type&gt;</TT> object.&nbsp; The<B> allocator</B>
function is registered to perform all memory allocations of the list elements, and the<B> deallocator</B> function to perform
all freeing of the list elements' memory.&nbsp; These functions provide the ability to control how the allocation and freeing
of memory is performed, allowing for more efficient memory handling than the general purpose global<TT> operator new()</TT>
and<TT> operator delete()</TT> can provide.&nbsp; Memory management optimizations may potentially be made through the<B> allocator</B>
and<B> deallocator</B> functions, but are not recommended before managing memory is understood and determined to be worth
while.
<BR><BR>The<B> allocator</B> function shall return a pointer to allocated memory of size at least the argument, or zero(0)
if the allocation cannot be performed.&nbsp; Initialization of the memory returned is performed by the<TT> WCValDList&lt;Type&gt;</TT>
class.
<BR><BR>The<TT> WCValDList&lt;Type&gt;</TT> class calls the<B> deallocator</B> function only on memory allocated by the<B>
allocator</B> function.&nbsp; The<B> deallocator</B> shall free the memory pointed to by the first argument which is of size
the second argument.&nbsp; The size passed to the<B> deallocator</B> function is guaranteed to be the same size passed to
the<B> allocator</B> function when the memory was allocated.
<BR><BR>The<B> allocator</B> and<B> deallocator</B> functions may assume that for a list object instance, the<B> allocator</B>
is always called with the same first argument (the size of the memory to be allocated).&nbsp; The<TT> WCValDListItemSize(Type)</TT>
macro returns the size of the elements which are allocated by the<B> allocator</B> function.
<DT>Results:
<DD>The<TT> WCValDList</TT> public member function creates an initialized<TT> WCValDList&lt;Type&gt;</TT> object and registers
the<B> allocator</B> and<B> deallocator</B> functions.
<DT>See Also:
<DD><TT> WCValDList</TT>,<TT> ~WCValDList</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCValDList( const WCValDList &amp; );</TT>
<DT>Semantics:
<DD>The<TT> WCValDList</TT> public member function is the copy constructor for the double linked list class.&nbsp; All of the
list elements are copied to the new list, as well as the exception trap states, and any registered<B> allocator</B> and<B>
deallocator</B> functions.<TT>&nbsp; Type's</TT> copy constructor is invoked to copy the values contained by the list elements.
<BR><BR>If all of the elements cannot be copied and the<TT> out_of_memory</TT> is enabled in the list being copied, the exception
is thrown.&nbsp; The new list is created in a valid state, even if all of the list elements could not be copied.
<DT>Results:
<DD>The<TT> WCValDList</TT> public member function produces a copy of the list.
<DT>See Also:
<DD><TT> WCValDList</TT>,<TT> ~WCValDList</TT>,<TT> clear</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<H2 ID="WCValDListXTypeY____WCValDListLR"> ~WCValDList() [WCValDList&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>~WCValDList();</TT>
<DT>Semantics:
<DD>The<TT> ~WCValDList</TT> public member function destroys the<TT> WCValDList</TT> object.&nbsp; If the list is not empty and
the<TT> not_empty</TT> exception is enabled, the exception is thrown.&nbsp; If the<TT> not_empty</TT> exception is not enabled
and the list is not empty, the list is cleared using the<TT> clear</TT> member function.&nbsp; The call to the<TT> ~WCValDList</TT>
public member function is inserted implicitly by the compiler at the point where the<TT> WCValDList</TT> object goes out of
scope.
<DT>Results:
<DD>The<TT> WCValDList</TT> object is destroyed.
<DT>See Also:
<DD><TT> WCValDList</TT>,<TT> clear</TT>,<TT> clearAndDestroy</TT>,<TT> WCExcept::not_empty</TT>
</DL>
<H2 ID="WCValSListXTypeY__appendLR__WCValDListXTypeY__appendLR"> append() [WCValSList&lt;Type&gt;,WCValDList&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int append( const Type &amp; );</TT>
<DT>Semantics:
<DD>The<TT> append</TT> public member function is used to append the data to the end of the list.&nbsp; The data stored in the
list is a copy of the data passed as a parameter.
<BR><BR>If the<TT> out_of_memory</TT> exception is enabled and the append fails, the exception is thrown.
<DT>Results:
<DD>The data element is appended to the end of the list.&nbsp; A TRUE value (non-zero) is returned if the append is successful.
&nbsp;A FALSE (zero) result is returned if the append fails.
<DT>See Also:
<DD><TT> insert</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<H2 ID="WCValSListXTypeY__clearLR__WCValDListXTypeY__clearLR"> clear() [WCValSList&lt;Type&gt;,WCValDList&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void clear();</TT>
<DT>Semantics:
<DD>The<TT> clear</TT> public member function is used to clear the list object and set it to the state of the object just after
the initial construction.&nbsp; The list object is not destroyed and re-created by this operator, so the object destructor
is not invoked.
<BR><BR>The<TT> clear</TT> public member function has the same sematics as the<TT> clearAndDestroy</TT> member function.
<DT>Results:
<DD>The<TT> clear</TT> public member function resets the list object to the state of the object immediately after the initial
construction.
<DT>See Also:
<DD><TT> ~WCValSList</TT>,<TT> ~WCValDList</TT>,<TT> clearAndDestroy</TT>,<TT> get</TT>,<TT> operator =</TT>
</DL>
<H2 ID="WCValSListXTypeY_WCValDListXTypeY__clearAndDestroyLR"> clearAndDestroy() [WCValSList&lt;Type&gt;,WCValDList&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void clearAndDestroy();</TT>
<DT>Semantics:
<DD>The<TT> clearAndDestroy</TT> public member function is used to clear the list object and set it to the state of the object
just after the initial construction.&nbsp; The list object is not destroyed and re-created by this operator, so the object
destructor is not invoked.
<BR><BR>Before the list object is re-initialized, the delete operator is called for each list element.
<DT>Results:
<DD>The<TT> clearAndDestroy</TT> public member function resets the list object to the initial state of the object immediately
after the initial construction.
<DT>See Also:
<DD><TT> clear</TT>,<TT> get</TT>
</DL>
<H2 ID="WCValSListXTypeY__containsLR__WCValDListXTypeY__containsLR"> contains() [WCValSList&lt;Type&gt;,WCValDList&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int contains( const Type &amp; ) const;</TT>
<DT>Semantics:
<DD>The<TT> contains</TT> public member function is used to determine if a list element object is already contained in the list.
&nbsp;Each list element is compared to the passed element using<TT> Type's operator ==</TT> to determine if the passed element
is contained in the list.
<DT>Results:
<DD>Zero(0) is returned if the passed list element object is not found in the list.&nbsp; A non-zero result is returned if the
element is found in the list.
<DT>See Also:
<DD><TT> find</TT>,<TT> index</TT>
</DL>
<H2 ID="WCValSListXTypeY__entriesLR__WCValDListXTypeY__entriesLR"> entries() [WCValSList&lt;Type&gt;,WCValDList&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int entries() const;</TT>
<DT>Semantics:
<DD>The<TT> entries</TT> public member function is used to determine the number of list elements contained in the list object.
<DT>Results:
<DD>The number of entries stored in the list is returned, zero(0) is returned if there are no list elements.
<DT>See Also:
<DD><TT> isEmpty</TT>
</DL>
<H2 ID="WCValSListXTypeY__findLR__WCValDListXTypeY__findLR"> find() [WCValSList&lt;Type&gt;,WCValDList&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Type find( int = 0 ) const;</TT>
<DT>Semantics:
<DD>The<TT> find</TT> public member function returns the value of a list element in the list object.&nbsp; The optional parameter
specifies which element to locate, and defaults to the first element.&nbsp; Since the first element of the list is the zero'th
element, the last element will be the number of list entries minus one.
<BR><BR>If the list is empty and the<TT> empty_container</TT> exception is enabled, the exception is thrown.&nbsp; If the<TT>
index_range</TT> exception is enabled, the exception is thrown if the index value is negative or is greater than the number
of list entries minus one.
<DT>Results:
<DD>The value of the selected list element or the closest element is returned.&nbsp; If the index value is negative, the closest
list element is the first element.&nbsp; The last element is the closest element if the index value is greater than the number
of list entries minus one.&nbsp; A default initialized value is returned if there are no elements in the list.
<DT>See Also:
<DD><TT> findLast</TT>,<TT> get</TT>,<TT> index</TT>,<TT> isEmpty</TT>,<TT> WCExcept::empty_container</TT>,<TT> WCExcept::index_range</TT>
</DL>
<H2 ID="WCValSListXTypeY__findLastLR__WCValDListXTypeY__findLastLR"> findLast() [WCValSList&lt;Type&gt;,WCValDList&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Type findLast() const;</TT>
<DT>Semantics:
<DD>The<TT> findLast</TT> public member function returns the value of the last list element in the list object.
<BR><BR>If the list is empty, one of two exceptions can be thrown.&nbsp; If the<TT> empty_container</TT> exception is enabled,
it is thrown.&nbsp; The<TT> index_range</TT> exception is thrown if it is enabled and the<TT> empty_container</TT> exception
is not enabled.
<DT>Results:
<DD>The value of the last list element is returned.&nbsp; A default initialized value is returned if there are no elements in
the list.
<DT>See Also:
<DD><TT> find</TT>,<TT> get</TT>,<TT> isEmpty</TT>,<TT> WCExcept::empty_container</TT>,<TT> WCExcept::index_range</TT>
</DL>
<H2 ID="WCValSListXTypeY__forAllLR__WCValDListXTypeY__forAllLR"> forAll() [WCValSList&lt;Type&gt;,WCValDList&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void forAll( void (*)( Type, void * ), void *) const;</TT>
<DT>Semantics:
<DD>The<TT> forAll</TT> public member function is used to cause the function<B> fn</B> to be invoked for each list element.&nbsp;
The<B> fn</B> function should have the prototype
<BR><BR><TT>void (*fn)( Type, void * )</TT>
<BR><BR>The first parameter of<B> fn</B> shall accept the value of the list element currently active.&nbsp; The second argument
passed to<B> fn</B> is the second argument of the<TT> forAll</TT> function.&nbsp; This allows a callback function to be defined
which can accept data appropriate for the point at which the<TT> forAll</TT> function is invoked.
<DT>See Also:
<DD><TT> WCValConstSListIter</TT>,<TT> WCValConstDListIter</TT>,<TT> WCValSListIter</TT>,<TT> WCValDListIter</TT>
</DL>
<H2 ID="WCValSListXTypeY__getLR__WCValDListXTypeY__getLR"> get() [WCValSList&lt;Type&gt;,WCValDList&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Type get( int = 0 );</TT>
<DT>Semantics:
<DD>The<TT> get</TT> public member function returns the value of the list element in the list object.&nbsp; The list element is
also removed from the list.&nbsp; The optional parameter specifies which element to remove, and defaults to the first element.
&nbsp;Since the first element of the list is the zero'th element, the last element will be the number of list entries minus
one.
<BR><BR>If the list is empty and the<TT> empty_container</TT> exception is enabled, the exception is thrown.&nbsp; If the<TT>
index_range</TT> exception trap is enabled, the exception is thrown if the index value is negative or is greater than the
number of list entries minus one.
<DT>Results:
<DD>The value of the selected list element or the closest element is removed and returned.&nbsp; If the index value is negative,
the closest list element is the first element.&nbsp; The last element is the closest element if the index value is greater
than the number of list entries minus one.&nbsp; A default initialized value is returned if there are no elements in the list.
<DT>See Also:
<DD><TT> clear</TT>,<TT> clearAndDestroy</TT>,<TT> find</TT>,<TT> index</TT>,<TT> WCExcept::empty_container</TT>,<TT> WCExcept::index_range</TT>
</DL>
<H2 ID="WCValSListXTypeY__indexLR__WCValDListXTypeY__indexLR"> index() [WCValSList&lt;Type&gt;,WCValDList&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int index( const Type &amp; ) const;</TT>
<DT>Semantics:
<DD>The<TT> index</TT> public member function is used to determine the index of the first list element equivalent to the passed
element.&nbsp; Each list element is compared to the passed element using<TT> Type's operator ==</TT> until the passed element
is found, or all list elements have been checked.
<DT>Results:
<DD>The index of the first element equivalent to the passed element is returned.&nbsp; If the passed element is not in the list,
negative one (-1) is returned.
<DT>See Also:
<DD><TT> contains</TT>,<TT> find</TT>,<TT> get</TT>
</DL>
<H2 ID="WCValSListXTypeY__insertLR__WCValDListXTypeY__insertLR"> insert() [WCValSList&lt;Type&gt;,WCValDList&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int insert( const Type &amp; );</TT>
<DT>Semantics:
<DD>The<TT> insert</TT> public member function is used to insert the data as the first element of the list.&nbsp; The data stored
in the list is a copy of the data passed as a parameter.
<BR><BR>If the<TT> out_of_memory</TT> exception is enabled and the insert fails, the exception is thrown.
<DT>Results:
<DD>The data element is inserted into the beginning of the list.&nbsp; A TRUE value (non-zero) is returned if the insert is successful.
&nbsp;A FALSE (zero) result is returned if the insert fails.
<DT>See Also:
<DD><TT> append</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<H2 ID="WCValSListXTypeY__isEmptyLR__WCValDListXTypeY__isEmptyLR"> isEmpty() [WCValSList&lt;Type&gt;,WCValDList&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int isEmpty() const;</TT>
<DT>Semantics:
<DD>The<TT> isEmpty</TT> public member function is used to determine if a list object has any list elements contained in it.
<DT>Results:
<DD>A TRUE value (non-zero) is returned if the list object does not have any list elements contained within it.&nbsp; A FALSE
(zero) result is returned if the list contains at least one element.
<DT>See Also:
<DD><TT> entries</TT>
</DL>
<H2 ID="WCValSListXTypeY__operator_ELR__WCValDListXTypeY__operator_ELR"> operator =() [WCValSList&lt;Type&gt;,WCValDList&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCValSList &amp; WCValSList::operator =( const WCValSList &amp; );</TT>
<BR><TT> WCValDList &amp; WCValDList::operator =( const WCValDList &amp; );</TT>
<DT>Semantics:
<DD>The<TT> operator =</TT> public member function is the assignment operator for the class.&nbsp; The left hand side of the assignment
is first cleared with the<TT> clear</TT> member function.&nbsp; All elements in the right hand side list are then copied,
as well as the exception trap states, and any registered<B> allocator</B> and<B> deallocator</B> functions.<TT>&nbsp; Type's</TT>
copy constructor is invoked to copy the values contained by the list elements.
<BR><BR>If all of the elements cannot be copied and the<TT> out_of_memory</TT> is enabled in the right hand side list, the
exception is thrown.&nbsp; The new list is created in a valid state, even if all of the list elements could not be copied.
<DT>Results:
<DD>The<TT> operator =</TT> public member function assigns the right hand side to the left hand side and returns a reference to
the left hand side.
<DT>See Also:
<DD><TT> WCValSList</TT>,<TT> WCValDList</TT>,<TT> clear</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<H2 ID="WCValSListXTypeY__operator_EELR__WCValDListXTypeY__operator_EELR"> operator ==() [WCValSList&lt;Type&gt;,WCValDList&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclist.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int WCValSList::operator ==( const WCValSList &amp; ) const;</TT>
<BR><TT> int WCValDList::operator ==( const WCValDList &amp; ) const;</TT>
<DT>Semantics:
<DD>The<TT> operator ==</TT> public member function is the equivalence operator for the<TT> WCValSList&lt;Type&gt;</TT> and<TT>
WCValDList&lt;Type&gt;</TT> classes.&nbsp; Two list objects are equivalent if they are the same object and share the same
address.
<DT>Results:
<DD>A TRUE (non-zero) value is returned if the left hand side object and the right hand side objects are the same object.&nbsp;
A FALSE (zero) value is returned otherwise.
</DL>
<H1 ID="List_Iterators"> List Iterators </H1>
<BR>List iterators operate on single or double linked lists.&nbsp; They are used to step through a list one or more elements
at a time.&nbsp; The choice of which type of iterator to use is determined by the list you wish to iterate over.&nbsp; For
example, to iterate over a non-constant<TT> WCIsvDList&lt;Type&gt;</TT> object, use the<TT> WCIsvDListIter&lt;Type&gt;</TT>
class.&nbsp; A constant<TT> WCValSList&lt;Type&gt;</TT> object can be iterated using the<TT> WCValConstSListIter&lt;Type&gt;</TT>
class.&nbsp; The iterators which correspond to the single link list containers have some functionality inhibited.&nbsp; If
backward traversal is required, the double linked containers and corresponding iterators must be used.
<BR><BR>Like all WATCOM iterators, newly constructed and reset iterators are positioned before the first element in the list.
&nbsp;The list may be traversed one element at a time using the pre-increment or call operator.&nbsp; An increment operation
causing the iterator to be positioned after the end of the list returns zero.&nbsp; Further increments will cause the<TT>
undef_iter</TT> exception to be thrown, if it is enabled.&nbsp; This behaviour allows lists to be traversed simply using a
while loop, and is demonstrated in the examples for the iterator classes.
<BR><BR>The classes are presented in alphabetical order.&nbsp; The<TT> WCIterExcept</TT> class provides the common exception
handling control interface for all of the iterators.
<BR><BR>Since the iterator classes are all template classes, deriving most of the functionality from common base classes was
used.&nbsp; In the listing of class member functions, those public member functions which appear to be in the iterator class
but are actually defined in the common base class are identified as if they were explicitly specified in the iterator class.
<H2 ID="WCIsvConstSListIterXTypeY__WCIsvConstDListIterXTypeY_Class_Description"> WCIsvConstSListIter&lt;Type&gt;, WCIsvConstDListIter&lt;Type&gt; Class Description </H2>
<DL>
<DT>Declared:
<DD><TT> wclistit.h</TT>
<BR><BR>The<TT> WCIsvConstSListIter&lt;Type&gt;</TT> and<TT> WCIsvConstDListIter&lt;Type&gt;</TT> classes are the templated
classes used to create iterator objects for constant single and double linked list objects.&nbsp; These classes may be used
to iterate over non-constant lists, but the<TT> WCIsvDListIter&lt;Type&gt;</TT> and<TT> WCIsvSListIter&lt;Type&gt;</TT> classes
provide additional functionality for only non-constant lists.
<BR>In the description of each member function, the text<TT> Type</TT> is used to indicate the list element type specified
as the template parameter.
<BR><BR>The<TT> WCIterExcept</TT> class is a base class of the<TT> WCIsvConstSListIter&lt;Type&gt;</TT> and<TT> WCIsvConstDListIter&lt;Type&gt;</TT>
classes and provides the<TT> exceptions</TT> member function.&nbsp; This member function controls the exceptions which can
be thrown by the<TT> WCIsvConstSListIter&lt;Type&gt;</TT> and<TT> WCIsvConstDListIter&lt;Type&gt;</TT> objects.&nbsp; No exceptions
are enabled unless they are set by the<TT> exceptions</TT> member function.
<BR><BR><B>Private Member Functions</B>
<BR><BR>Some functionality supported by base classes of the iterator are not appropriate for the constant list iterator classes.
&nbsp;Setting those functions as private members in the derived class is the standard mechanism to prevent them from being
invoked.
<BR><BR><TT>int append( Type * );</TT>
<BR><TT> int insert( Type * );</TT>
<BR><BR><B>Public Member Functions</B>
<BR><BR>The following member functions are declared in the public interface:
<BR><BR><TT>WCIsvConstSListIter();</TT>
<BR><TT> WCIsvConstSListIter( const WCIsvSList&lt;Type&gt; &amp; );</TT>
<BR><TT> ~WCIsvConstSListIter();</TT>
<BR><TT> WCIsvConstDListIter();</TT>
<BR><TT> WCIsvConstDListIter( const WCIsvDList&lt;Type&gt; &amp; );</TT>
<BR><TT> ~WCIsvConstDListIter();</TT>
<BR><TT> const WCIsvSList&lt;Type&gt; *WCIsvConstSListIter&lt;Type&gt;::container() const;</TT>
<BR><TT> const WCIsvDList&lt;Type&gt; *WCIsvConstDListIter&lt;Type&gt;::container() const;</TT>
<BR><TT> Type * current() const;</TT>
<BR><TT> void reset();</TT>
<BR><TT> void WCIsvConstSListIter&lt;Type&gt;::reset( const WCIsvSList&lt;Type&gt; &amp; );</TT>
<BR><TT> void WCIsvConstDListIter&lt;Type&gt;::reset( const WCIsvDList&lt;Type&gt; &amp; );</TT>
<BR><BR><B>Public Member Operators</B>
<BR><BR>The following member operators are declared in the public interface:
<BR><BR><TT>Type * operator ()();</TT>
<BR><TT> Type * operator ++();</TT>
<BR><TT> Type * operator +=( int );</TT>
<BR><BR>In the iterators for double linked lists only:
<BR><BR><TT>Type * operator --();</TT>
<BR><TT> Type * operator -=( int );</TT>
<DT>See Also:
<DD><TT> WCIsvSList::forAll</TT>,<TT> WCIsvDList::forAll</TT>
</DL>
<H2 ID="WCIsvConstSListIterXTypeY__WCIsvConstSListIterLR"> WCIsvConstSListIter() [WCIsvConstSListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCIsvConstSListIter();</TT>
<DT>Semantics:
<DD>The<TT> WCIsvConstSListIter</TT> public member function is the default constructor for the class and initializes the iterator
with no list to operate on.&nbsp; The<TT> reset</TT> member function must be called to provide the iterator with a list to
iterate over.
<DT>Results:
<DD>The<TT> WCIsvConstSListIter</TT> public member function creates an initialized<TT> WCIsvConstSListIter</TT> object.
<DT>See Also:
<DD><TT> WCIsvConstSListIter</TT>,<TT> ~WCIsvConstSListIter</TT>,<TT> reset</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCIsvConstSListIter( const WCIsvSList&lt;Type&gt; &amp; );</TT>
<DT>Semantics:
<DD>The<TT> WCIsvConstSListIter</TT> public member function is a constructor for the class.&nbsp; The value passed as a parameter
is a<TT> WCIsvSList</TT> list object.&nbsp; The iterator will be initialized for that list object and positioned before the
first list element.&nbsp; To position the iterator to a valid element within the list, increment it using any of the<TT> operator
++, operator (),</TT> or<TT> operator +=</TT> operators.
<DT>Results:
<DD>The<TT> WCIsvConstSListIter</TT> public member function creates an initialized<TT> WCIsvConstSListIter</TT> object positioned
before the first element in the list.
<DT>See Also:
<DD><TT> ~WCIsvConstSListIter</TT>,<TT> operator ()</TT>,<TT> operator ++</TT>,<TT> operator +=</TT>,<TT> reset</TT>
</DL>
<H2 ID="WCIsvConstSListIterXTypeY____WCIsvConstSListIterLR"> ~WCIsvConstSListIter() [WCIsvConstSListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>~WCIsvConstSListIter();</TT>
<DT>Semantics:
<DD>The<TT> ~WCIsvConstSListIter</TT> public member function is the destructor for the class.&nbsp; The call to the<TT> ~WCIsvConstSListIter</TT>
public member function is inserted implicitly by the compiler at the point where the<TT> WCIsvConstSListIter</TT> object goes
out of scope.
<DT>Results:
<DD>The<TT> WCIsvConstSListIter</TT> object is destroyed.
<DT>See Also:
<DD><TT> WCIsvConstSListIter</TT>
</DL>
<H2 ID="WCIsvConstDListIterXTypeY__WCIsvConstDListIterLR"> WCIsvConstDListIter() [WCIsvConstDListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCIsvConstDListIter();</TT>
<DT>Semantics:
<DD>The<TT> WCIsvConstDListIter</TT> public member function is the default constructor for the class and initializes the iterator
with no list to operate on.&nbsp; The<TT> reset</TT> member function must be called to provide the iterator with a list to
iterate over.
<DT>Results:
<DD>The<TT> WCIsvConstDListIter</TT> public member function creates an initialized<TT> WCIsvConstDListIter</TT> object.
<DT>See Also:
<DD><TT> WCIsvConstDListIter</TT>,<TT> ~WCIsvConstDListIter</TT>,<TT> reset</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCIsvConstDListIter( const WCIsvDList&lt;Type&gt; &amp; );</TT>
<DT>Semantics:
<DD>The<TT> WCIsvConstDListIter</TT> public member function is a constructor for the class.&nbsp; The value passed as a parameter
is the<TT> WCIsvDList</TT> list object.&nbsp; The iterator will be initialized for that list object and positioned before
the first list element.&nbsp; To position the iterator to a valid element within the list, increment it using any of the<TT>
operator ++, operator (),</TT> or<TT> operator +=</TT> operators.
<DT>Results:
<DD>The<TT> WCIsvConstDListIter</TT> public member function creates an initialized<TT> WCIsvConstDListIter</TT> object positioned
before the first list element.
<DT>See Also:
<DD><TT> WCIsvConstDListIter</TT>,<TT> ~WCIsvConstDListIter</TT>,<TT> operator ()</TT>,<TT> operator ++</TT>,<TT> operator +=</TT>,<TT>
reset</TT>
</DL>
<H2 ID="WCIsvConstDListIterXTypeY____WCIsvConstDListIterLR"> ~WCIsvConstDListIter() [WCIsvConstDListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>~WCIsvConstDListIter();</TT>
<DT>Semantics:
<DD>The<TT> ~WCIsvConstDListIter</TT> public member function is the destructor for the class.&nbsp; The call to the<TT> ~WCIsvConstDListIter</TT>
public member function is inserted implicitly by the compiler at the point where the<TT> WCIsvConstDListIter</TT> object goes
out of scope.
<DT>Results:
<DD>The<TT> WCIsvConstDListIter</TT> object is destroyed.
<DT>See Also:
<DD><TT> WCIsvConstDListIter</TT>
</DL>
<H2 ID="WCIsvConstSListIterXTypeY_WCIsvConstDListIterXTypeY__containerLR"> container() [WCIsvConstSListIter&lt;Type&gt;,WCIsvConstDListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>const WCIsvSList&lt;Type&gt; *WCIsvConstSListIter&lt;Type&gt;::container() const;</TT>
<BR><TT> const WCIsvDList&lt;Type&gt; *WCIsvConstDListIter&lt;Type&gt;::container() const;</TT>
<DT>Semantics:
<DD>The<TT> container</TT> public member function returns a pointer to the list container object.&nbsp; If the iterator has not
been initialized with a list object, and the<TT> undef_iter</TT> exception is enabled, the exception is thrown.
<DT>Results:
<DD>A pointer to the list object associated with the iterator is returned, or NULL(0) if the iterator has not been initialized
with a list.
<DT>See Also:
<DD><TT> WCIsvConstSListIter</TT>,<TT> WCIsvConstDListIter</TT>,<TT> reset</TT>,<TT> WCIterExcept::undef_iter</TT>
</DL>
<H2 ID="WCIsvConstSListIterXTypeY__currentLR__WCIsvConstDListIterXTypeY__currentLR"> current() [WCIsvConstSListIter&lt;Type&gt;,WCIsvConstDListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Type * current();</TT>
<DT>Semantics:
<DD>The<TT> current</TT> public member function returns a pointer to the list item at the current iterator position.
<BR><BR>If the iterator is not associated with a list, or the iterator position is either before the first element or past
the last element in the list, the current iterator position is undefined.&nbsp; In this case the<TT> undef_item</TT> exception
is thrown, if enabled.
<DT>Results:
<DD>A pointer to the current list element is returned.&nbsp; If the current element is undefined, NULL(0) is returned.
<DT>See Also:
<DD><TT> operator ()</TT>,<TT> operator ++</TT>,<TT> operator +=</TT>,<TT> operator --</TT>,<TT> operator -=</TT>,<TT> reset</TT>,<TT>
WCIterExcept::undef_item</TT>
</DL>
<H2 ID="WCIsvConstSListIterXTypeY_WCIsvConstDListIterXTypeY__operator_LRLR"> operator ()() [WCIsvConstSListIter&lt;Type&gt;,WCIsvConstDListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Type * operator ()();</TT>
<DT>Semantics:
<DD>The<TT> operator ()</TT> public member function is the call operator for the class.&nbsp; The list element which follows the
current item is set to be the new current item.&nbsp; If the previous current item was the last element in the list, the iterator
is positioned after the end of the list.
<BR><BR>The<TT> operator ()</TT> public member function has the same semantics as the pre-increment operator,<TT> operator
++.</TT>
<BR><BR>If the iterator was positioned before the first element in the list, the current item will be set to the first element
in the list.&nbsp; If the list is empty, the iterator will be positioned after the end of the list.
<BR><BR>If the iterator is not associated with a list or the iterator position before the increment was past the last element
the list, the<TT> undef_iter</TT> exception is thrown, if enabled.
<DT>Results:
<DD>The<TT> operator ()</TT> public member function returns a pointer to the new current item.&nbsp; NULL(0) is returned when
the iterator is incremented past the end of the list.
<DT>See Also:
<DD><TT> operator ++</TT>,<TT> operator +=</TT>,<TT> operator --</TT>,<TT> operator -=</TT>,<TT> reset</TT>,<TT> WCIterExcept::undef_iter</TT>
</DL>
<H2 ID="WCIsvConstSListIterXTypeY_WCIsvConstDListIterXTypeY__operator_PPLR"> operator ++() [WCIsvConstSListIter&lt;Type&gt;,WCIsvConstDListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Type * operator ++();</TT>
<DT>Semantics:
<DD>The<TT> operator ++</TT> public member function is the pre-increment operator for the class.&nbsp; The list element which
follows the current item is set to be the new current item.&nbsp; If the previous current item was the last element in the
list, the iterator is positioned after the end of the list.
<BR><BR>The<TT> operator ++</TT> public member function has the same semantics as the call operator,<TT> operator ().</TT>
<BR><BR>If the iterator was positioned before the first element in the list, the current item will be set to the first element
in the list.&nbsp; If the list is empty, the iterator will be positioned after the end of the list.
<BR><BR>If the iterator is not associated with a list or the iterator position before the increment was past the last element
the list, the<TT> undef_iter</TT> exception is thrown, if enabled.
<DT>Results:
<DD>The<TT> operator ++</TT> public member function returns a pointer to the new current item.&nbsp; NULL(0) is returned when
the iterator is incremented past the end of the list.
<DT>See Also:
<DD><TT> current</TT>,<TT> operator ()</TT>,<TT> operator +=</TT>,<TT> operator --</TT>,<TT> operator -=</TT>,<TT> reset</TT>,<TT>
WCIterExcept::undef_iter</TT>
</DL>
<H2 ID="WCIsvConstSListIterXTypeY_WCIsvConstDListIterXTypeY__operator_PELR"> operator +=() [WCIsvConstSListIter&lt;Type&gt;,WCIsvConstDListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Type * operator +=( int );</TT>
<DT>Semantics:
<DD>The<TT> operator +=</TT> public member function accepts an integer value that causes the iterator to move that many elements
after the current item.&nbsp; If the iterator was positioned before the first element in the list, the operation will set
the current item to be the given element in the list.
<BR><BR>If the current item was after the last element in the list previous to the iteration, and the<TT> undef_iter</TT>
exception is enabled, the exception will be thrown.&nbsp; Attempting to increment the iterator position more than element
after the end of the list, or by less than one element causes the<TT> iter_range</TT> exception to be thrown, if enabled.
<DT>Results:
<DD>The<TT> operator +=</TT> public member function returns a pointer to the new current item.&nbsp; NULL(0) is returned when
the iterator is incremented past the end of the list.
<DT>See Also:
<DD><TT> current</TT>,<TT> operator ()</TT>,<TT> operator ++</TT>,<TT> operator --</TT>,<TT> operator -=</TT>,<TT> reset</TT>,<TT>
WCIterExcept::iter_range</TT>,<TT> WCIterExcept::undef_iter</TT>
</DL>
<H2 ID="WCIsvConstDListIterXTypeY__operator_MMLR"> operator --() [WCIsvConstDListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Type * operator --();</TT>
<DT>Semantics:
<DD>The<TT> operator --</TT> public member function is the pre-decrement operator for the class.&nbsp; The list element previous
to the current item is set to be the new current item.&nbsp; If the current item was the first element in the list, the iterator
is positioned before the first element in the list.&nbsp; If the list is empty, the iterator will be positioned before the
start of the list.
<BR><BR>If the iterator was positioned after the last element in the list, the current item will be set to the last element.
<BR><BR>If the iterator is not associated with a list or the iterator position previous to the decrement was before the first
element the list, the<TT> undef_iter</TT> exception is thrown, if enabled.
<DT>Results:
<DD>The<TT> operator --</TT> public member function returns a pointer to the new current item.&nbsp; NULL(0) is returned when
the iterator is decremented past the first element of the list.
<DT>See Also:
<DD><TT> current</TT>,<TT> operator ()</TT>,<TT> operator ++</TT>,<TT> operator +=</TT>,<TT> operator -=</TT>,<TT> reset</TT>,<TT>
WCIterExcept::undef_iter</TT>
</DL>
<H2 ID="WCIsvConstDListIterXTypeY__operator_MELR"> operator -=() [WCIsvConstDListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Type * operator -=( int );</TT>
<DT>Semantics:
<DD>The<TT> operator -=</TT> public member function accepts an integer value that causes the iterator to move that many elements
before the current item.&nbsp; If the iterator was positioned after the last element in the list, the operation will set the
current item to be the given number of elements from the end of the list.
<BR><BR>If the current item was before the first element in the list previous to the iteration, and the<TT> undef_iter</TT>
exception is enabled, the exception will be thrown.&nbsp; Attempting to decrement the iterator position more than one element
before the beginning of the list, or by less than one element causes the<TT> iter_range</TT> exception to be thrown, if enabled.
<DT>Results:
<DD>The<TT> operator -=</TT> public member function returns a pointer to the new current item.&nbsp; NULL(0) is returned when
the iterator is decremented past the first element in the list.
<DT>See Also:
<DD><TT> current</TT>,<TT> operator ()</TT>,<TT> operator ++</TT>,<TT> operator +=</TT>,<TT> operator --</TT>,<TT> reset</TT>,<TT>
WCIterExcept::iter_range</TT>,<TT> WCIterExcept::undef_iter</TT>
</DL>
<H2 ID="WCIsvConstSListIterXTypeY__resetLR__WCIsvConstDListIterXTypeY__resetLR"> reset() [WCIsvConstSListIter&lt;Type&gt;,WCIsvConstDListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void reset();</TT>
<DT>Semantics:
<DD>The<TT> reset</TT> public member function resets the iterator to the initial state, positioning the iterator before the first
element in the associated list.
<DT>Results:
<DD>The iterator is positioned before the first list element.
<DT>See Also:
<DD><TT> WCIsvConstSListIter</TT>,<TT> WCIsvConstDListIter</TT>,<TT> container</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void WCIsvConstSListIter&lt;Type&gt;::reset( const WCIsvSList&lt;Type&gt; &amp; );</TT>
<BR><TT> void WCIsvConstDListIter&lt;Type&gt;::reset( const WCIsvDList&lt;Type&gt; &amp; );</TT>
<DT>Semantics:
<DD>The<TT> reset</TT> public member function resets the iterator to operate on the specified list.&nbsp; The iterator is positioned
before the first element in the list.
<DT>Results:
<DD>The iterator is positioned before the first element of the specified list.
<DT>See Also:
<DD><TT> WCIsvConstSListIter</TT>,<TT> WCIsvConstDListIter</TT>,<TT> container</TT>
</DL>
<H2 ID="WCIsvSListIterXTypeY__WCIsvDListIterXTypeY_Class_Description"> WCIsvSListIter&lt;Type&gt;, WCIsvDListIter&lt;Type&gt; Class Description </H2>
<DL>
<DT>Declared:
<DD><TT> wclistit.h</TT>
<BR><BR>The<TT> WCIsvSListIter&lt;Type&gt;</TT> and<TT> WCIsvDListIter&lt;Type&gt;</TT> classes are the templated classes
used to create iterator objects for single and double linked list objects.&nbsp; These classes can be used only for non-constant
lists.&nbsp; The<TT> WCIsvDConstListIter&lt;Type&gt;</TT> and<TT> WCIsvSConstListIter&lt;Type&gt;</TT> classes are provided
to iterate over constant lists.
<BR>In the description of each member function, the text<TT> Type</TT> is used to indicate the list element type specified
as the template parameter.
<BR><BR>The<TT> WCIterExcept</TT> class is a base class of the<TT> WCIsvSListIter&lt;Type&gt;</TT> and<TT> WCIsvDListIter&lt;Type&gt;</TT>
classes and provides the<TT> exceptions</TT> member function.&nbsp; This member function controls the exceptions which can
be thrown by the<TT> WCIsvSListIter&lt;Type&gt;</TT> and<TT> WCIsvDListIter&lt;Type&gt;</TT> objects.&nbsp; No exceptions
are enabled unless they are set by the<TT> exceptions</TT> member function.
<BR><BR><B>Private Member Functions</B>
<BR><BR>Some functionality supported by base classes of the iterator are not appropriate in the single linked list iterator
classes.&nbsp; Setting those functions as private members in the derived class is the standard mechanism to prevent them from
being invoked.&nbsp; The following member functions are declared in the single linked list iterator private interface:
<BR><BR><TT>Type * operator --();</TT>
<BR><TT> Type * operator -=( int );</TT>
<BR><TT> int insert( Type * );</TT>
<BR><BR><B>Public Member Functions</B>
<BR><BR>The following member functions are declared in the public interface:
<BR><BR><TT>WCIsvSListIter();</TT>
<BR><TT> WCIsvSListIter( WCIsvSList&lt;Type&gt; &amp; );</TT>
<BR><TT> ~WCIsvSListIter();</TT>
<BR><TT> WCIsvDListIter();</TT>
<BR><TT> WCIsvDListIter( WCIsvDList&lt;Type&gt; &amp; );</TT>
<BR><TT> ~WCIsvDListIter();</TT>
<BR><TT> int append( Type * );</TT>
<BR><TT> WCIsvSList&lt;Type&gt; *WCIsvSListIter&lt;Type&gt;::container() const;</TT>
<BR><TT> WCIsvDList&lt;Type&gt; *WCIsvDListIter&lt;Type&gt;::container() const;</TT>
<BR><TT> Type * current() const;</TT>
<BR><TT> void reset();</TT>
<BR><TT> void WCIsvSListIter&lt;Type&gt;::reset( WCIsvSList&lt;Type&gt; &amp; );</TT>
<BR><TT> void WCIsvDListIter&lt;Type&gt;::reset( WCIsvDList&lt;Type&gt; &amp; );</TT>
<BR><BR>In the iterators for double linked lists only:
<BR><BR><TT>int insert( Type * );</TT>
<BR><BR><B>Public Member Operators</B>
<BR><BR>The following member operators are declared in the public interface:
<BR><BR><TT>Type * operator ()();</TT>
<BR><TT> Type * operator ++();</TT>
<BR><TT> Type * operator +=( int );</TT>
<BR><BR>In the iterators for double linked lists only:
<BR><BR><TT>Type * operator --();</TT>
<BR><TT> Type * operator -=( int );</TT>
<DT>See Also:
<DD><TT> WCIsvSList::forAll</TT>,<TT> WCIsvDList::forAll</TT>
</DL>
<H2 ID="WCIsvSListIterXTypeY__WCIsvSListIterLR"> WCIsvSListIter() [WCIsvSListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCIsvSListIter();</TT>
<DT>Semantics:
<DD>The<TT> WCIsvSListIter</TT> public member function is the default constructor for the class and initializes the iterator with
no list to operate on.&nbsp; The<TT> reset</TT> member function must be called to provide the iterator with a list to iterate
over.
<DT>Results:
<DD>The<TT> WCIsvSListIter</TT> public member function creates an initialized<TT> WCIsvSListIter</TT> object.
<DT>See Also:
<DD><TT> WCIsvSListIter</TT>,<TT> ~WCIsvSListIter</TT>,<TT> reset</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCIsvSListIter( WCIsvSList&lt;Type&gt; &amp; );</TT>
<DT>Semantics:
<DD>The<TT> WCIsvSListIter</TT> public member function is a constructor for the class.&nbsp; The value passed as a parameter is
a<TT> WCIsvSList</TT> list object.&nbsp; The iterator will be initialized for that list object and positioned before the first
list element.&nbsp; To position the iterator to a valid element within the list, increment it using any of the<TT> operator
++, operator (),</TT> or<TT> operator +=</TT> operators.
<DT>Results:
<DD>The<TT> WCIsvSListIter</TT> public member function creates an initialized<TT> WCIsvSListIter</TT> object positioned before
the first element in the list.
<DT>See Also:
<DD><TT> ~WCIsvSListIter</TT>,<TT> operator ()</TT>,<TT> operator ++</TT>,<TT> operator +=</TT>,<TT> reset</TT>
</DL>
<H2 ID="WCIsvSListIterXTypeY____WCIsvSListIterLR"> ~WCIsvSListIter() [WCIsvSListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>~WCIsvSListIter();</TT>
<DT>Semantics:
<DD>The<TT> ~WCIsvSListIter</TT> public member function is the destructor for the class.&nbsp; The call to the<TT> ~WCIsvSListIter</TT>
public member function is inserted implicitly by the compiler at the point where the<TT> WCIsvSListIter</TT> object goes out
of scope.
<DT>Results:
<DD>The<TT> WCIsvSListIter</TT> object is destroyed.
<DT>See Also:
<DD><TT> WCIsvSListIter</TT>
</DL>
<H2 ID="WCIsvDListIterXTypeY__WCIsvDListIterLR"> WCIsvDListIter() [WCIsvDListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCIsvDListIter();</TT>
<DT>Semantics:
<DD>The<TT> WCIsvDListIter</TT> public member function is the default constructor for the class and initializes the iterator with
no list to operate on.&nbsp; The<TT> reset</TT> member function must be called to provide the iterator with a list to iterate
over.
<DT>Results:
<DD>The<TT> WCIsvDListIter</TT> public member function creates an initialized<TT> WCIsvDListIter</TT> object.
<DT>See Also:
<DD><TT> WCIsvDListIter</TT>,<TT> ~WCIsvDListIter</TT>,<TT> reset</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCIsvDListIter( WCIsvDList&lt;Type&gt; &amp; );</TT>
<DT>Semantics:
<DD>The<TT> WCIsvDListIter</TT> public member function is a constructor for the class.&nbsp; The value passed as a parameter is
the<TT> WCIsvDList</TT> list object.&nbsp; The iterator will be initialized for that list object and positioned before the
first list element.&nbsp; To position the iterator to a valid element within the list, increment it using any of the<TT> operator
++, operator (),</TT> or<TT> operator +=</TT> operators.
<DT>Results:
<DD>The<TT> WCIsvDListIter</TT> public member function creates an initialized<TT> WCIsvDListIter</TT> object positioned before
the first list element.
<DT>See Also:
<DD><TT> WCIsvDListIter</TT>,<TT> ~WCIsvDListIter</TT>,<TT> operator ()</TT>,<TT> operator ++</TT>,<TT> operator +=</TT>,<TT>
reset</TT>
</DL>
<H2 ID="WCIsvDListIterXTypeY____WCIsvDListIterLR"> ~WCIsvDListIter() [WCIsvDListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>~WCIsvDListIter();</TT>
<DT>Semantics:
<DD>The<TT> ~WCIsvDListIter</TT> public member function is the destructor for the class.&nbsp; The call to the<TT> ~WCIsvDListIter</TT>
public member function is inserted implicitly by the compiler at the point where the<TT> WCIsvDListIter</TT> object goes out
of scope.
<DT>Results:
<DD>The<TT> WCIsvDListIter</TT> object is destroyed.
<DT>See Also:
<DD><TT> WCIsvDListIter</TT>
</DL>
<H2 ID="WCIsvSListIterXTypeY__appendLR__WCIsvDListIterXTypeY__appendLR"> append() [WCIsvSListIter&lt;Type&gt;,WCIsvDListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int append( Type * );</TT>
<DT>Semantics:
<DD>The<TT> append</TT> public member function inserts a new element into the list container object.&nbsp; The new element is
inserted after the current iterator item.
<BR><BR>If the iterator is not associated with a list, or the iterator position is either before the first element or past
the last element in the list, the current iterator position is undefined.&nbsp; The element is not appended.&nbsp; If the<TT>
undef_iter</TT> exception is enabled, it is thrown.
<DT>Results:
<DD>The new element is inserted after the current iterator item.&nbsp; A TRUE value (non-zero) is returned if the append is successful.
&nbsp;A FALSE (zero) result is returned if the append fails.
<DT>See Also:
<DD><TT> insert</TT>,<TT> WCExcept::out_of_memory</TT>,<TT> WCIterExcept::undef_iter</TT>
</DL>
<H2 ID="WCIsvSListIterXTypeY_WCIsvDListIterXTypeY__containerLR"> container() [WCIsvSListIter&lt;Type&gt;,WCIsvDListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCIsvSList&lt;Type&gt; *WCIsvSListIter&lt;Type&gt;::container() const;</TT>
<BR><TT> WCIsvDList&lt;Type&gt; *WCIsvDListIter&lt;Type&gt;::container() const;</TT>
<DT>Semantics:
<DD>The<TT> container</TT> public member function returns a pointer to the list container object.&nbsp; If the iterator has not
been initialized with a list object, and the<TT> undef_iter</TT> exception is enabled, the exception is thrown.
<DT>Results:
<DD>A pointer to the list object associated with the iterator is returned, or NULL(0) if the iterator has not been initialized
with a list.
<DT>See Also:
<DD><TT> WCIsvSListIter</TT>,<TT> WCIsvDListIter</TT>,<TT> reset</TT>,<TT> WCIterExcept::undef_iter</TT>
</DL>
<H2 ID="WCIsvSListIterXTypeY__currentLR__WCIsvDListIterXTypeY__currentLR"> current() [WCIsvSListIter&lt;Type&gt;,WCIsvDListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Type * current();</TT>
<DT>Semantics:
<DD>The<TT> current</TT> public member function returns a pointer to the list item at the current iterator position.
<BR><BR>If the iterator is not associated with a list, or the iterator position is either before the first element or past
the last element in the list, the current iterator position is undefined.&nbsp; In this case the<TT> undef_item</TT> exception
is thrown, if enabled.
<DT>Results:
<DD>A pointer to the current list element is returned.&nbsp; If the current element is undefined, NULL(0) is returned.
<DT>See Also:
<DD><TT> operator ()</TT>,<TT> operator ++</TT>,<TT> operator +=</TT>,<TT> operator --</TT>,<TT> operator -=</TT>,<TT> reset</TT>,<TT>
WCIterExcept::undef_item</TT>
</DL>
<H2 ID="WCIsvDListIterXTypeY__insertLR"> insert() [WCIsvDListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int insert( Type * );</TT>
<DT>Semantics:
<DD>The<TT> insert</TT> public member function inserts a new element into the list container object.&nbsp; The new element is
inserted before the current iterator item.&nbsp; This process uses the previous link in the double linked list, so the<TT>
insert</TT> public member function is not allowed with single linked lists.
<BR><BR>If the iterator is not associated with a list, or the iterator position is either before the first element or past
the last element in the list, the current iterator position is undefined.&nbsp; The element is not inserted.&nbsp; If the<TT>
undef_iter</TT> exception is enabled, the exception is thrown.
<DT>Results:
<DD>The new element is inserted before the current iterator item.&nbsp; A TRUE value (non-zero) is returned if the insert is successful.
&nbsp;A FALSE (zero) result is returned if the insert fails.
<DT>See Also:
<DD><TT> append</TT>,<TT> WCExcept::out_of_memory</TT>,<TT> WCIterExcept::undef_iter</TT>
</DL>
<H2 ID="WCIsvSListIterXTypeY_WCIsvDListIterXTypeY__operator_LRLR"> operator ()() [WCIsvSListIter&lt;Type&gt;,WCIsvDListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Type * operator ()();</TT>
<DT>Semantics:
<DD>The<TT> operator ()</TT> public member function is the call operator for the class.&nbsp; The list element which follows the
current item is set to be the new current item.&nbsp; If the previous current item was the last element in the list, the iterator
is positioned after the end of the list.
<BR><BR>The<TT> operator ()</TT> public member function has the same semantics as the pre-increment operator,<TT> operator
++.</TT>
<BR><BR>If the iterator was positioned before the first element in the list, the current item will be set to the first element
in the list.&nbsp; If the list is empty, the iterator will be positioned after the end of the list.
<BR><BR>If the iterator is not associated with a list or the iterator position before the increment was past the last element
the list, the<TT> undef_iter</TT> exception is thrown, if enabled.
<DT>Results:
<DD>The<TT> operator ()</TT> public member function returns a pointer to the new current item.&nbsp; NULL(0) is returned when
the iterator is incremented past the end of the list.
<DT>See Also:
<DD><TT> operator ++</TT>,<TT> operator +=</TT>,<TT> operator --</TT>,<TT> operator -=</TT>,<TT> reset</TT>,<TT> WCIterExcept::undef_iter</TT>
</DL>
<H2 ID="WCIsvSListIterXTypeY_WCIsvDListIterXTypeY__operator_PPLR"> operator ++() [WCIsvSListIter&lt;Type&gt;,WCIsvDListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Type * operator ++();</TT>
<DT>Semantics:
<DD>The<TT> operator ++</TT> public member function is the pre-increment operator for the class.&nbsp; The list element which
follows the current item is set to be the new current item.&nbsp; If the previous current item was the last element in the
list, the iterator is positioned after the end of the list.
<BR><BR>The<TT> operator ++</TT> public member function has the same semantics as the call operator,<TT> operator ().</TT>
<BR><BR>If the iterator was positioned before the first element in the list, the current item will be set to the first element
in the list.&nbsp; If the list is empty, the iterator will be positioned after the end of the list.
<BR><BR>If the iterator is not associated with a list or the iterator position before the increment was past the last element
the list, the<TT> undef_iter</TT> exception is thrown, if enabled.
<DT>Results:
<DD>The<TT> operator ++</TT> public member function returns a pointer to the new current item.&nbsp; NULL(0) is returned when
the iterator is incremented past the end of the list.
<DT>See Also:
<DD><TT> current</TT>,<TT> operator ()</TT>,<TT> operator +=</TT>,<TT> operator --</TT>,<TT> operator -=</TT>,<TT> reset</TT>,<TT>
WCIterExcept::undef_iter</TT>
</DL>
<H2 ID="WCIsvSListIterXTypeY_WCIsvDListIterXTypeY__operator_PELR"> operator +=() [WCIsvSListIter&lt;Type&gt;,WCIsvDListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Type * operator +=( int );</TT>
<DT>Semantics:
<DD>The<TT> operator +=</TT> public member function accepts an integer value that causes the iterator to move that many elements
after the current item.&nbsp; If the iterator was positioned before the first element in the list, the operation will set
the current item to be the given element in the list.
<BR><BR>If the current item was after the last element in the list previous to the iteration, and the<TT> undef_iter</TT>
exception is enabled, the exception will be thrown.&nbsp; Attempting to increment the iterator position more than element
after the end of the list, or by less than one element causes the<TT> iter_range</TT> exception to be thrown, if enabled.
<DT>Results:
<DD>The<TT> operator +=</TT> public member function returns a pointer to the new current item.&nbsp; NULL(0) is returned when
the iterator is incremented past the end of the list.
<DT>See Also:
<DD><TT> current</TT>,<TT> operator ()</TT>,<TT> operator ++</TT>,<TT> operator --</TT>,<TT> operator -=</TT>,<TT> reset</TT>,<TT>
WCIterExcept::iter_range</TT>,<TT> WCIterExcept::undef_iter</TT>
</DL>
<H2 ID="WCIsvDListIterXTypeY__operator_MMLR"> operator --() [WCIsvDListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Type * operator --();</TT>
<DT>Semantics:
<DD>The<TT> operator --</TT> public member function is the pre-decrement operator for the class.&nbsp; The list element previous
to the current item is set to be the new current item.&nbsp; If the current item was the first element in the list, the iterator
is positioned before the first element in the list.&nbsp; If the list is empty, the iterator will be positioned before the
start of the list.
<BR><BR>If the iterator was positioned after the last element in the list, the current item will be set to the last element.
<BR><BR>If the iterator is not associated with a list or the iterator position previous to the decrement was before the first
element the list, the<TT> undef_iter</TT> exception is thrown, if enabled.
<DT>Results:
<DD>The<TT> operator --</TT> public member function returns a pointer to the new current item.&nbsp; NULL(0) is returned when
the iterator is decremented past the first element of the list.
<DT>See Also:
<DD><TT> current</TT>,<TT> operator ()</TT>,<TT> operator ++</TT>,<TT> operator +=</TT>,<TT> operator -=</TT>,<TT> reset</TT>,<TT>
WCIterExcept::undef_iter</TT>
</DL>
<H2 ID="WCIsvDListIterXTypeY__operator_MELR"> operator -=() [WCIsvDListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Type * operator -=( int );</TT>
<DT>Semantics:
<DD>The<TT> operator -=</TT> public member function accepts an integer value that causes the iterator to move that many elements
before the current item.&nbsp; If the iterator was positioned after the last element in the list, the operation will set the
current item to be the given number of elements from the end of the list.
<BR><BR>If the current item was before the first element in the list previous to the iteration, and the<TT> undef_iter</TT>
exception is enabled, the exception will be thrown.&nbsp; Attempting to decrement the iterator position more than one element
before the beginning of the list, or by less than one element causes the<TT> iter_range</TT> exception to be thrown, if enabled.
<DT>Results:
<DD>The<TT> operator -=</TT> public member function returns a pointer to the new current item.&nbsp; NULL(0) is returned when
the iterator is decremented past the first element in the list.
<DT>See Also:
<DD><TT> current</TT>,<TT> operator ()</TT>,<TT> operator ++</TT>,<TT> operator +=</TT>,<TT> operator --</TT>,<TT> reset</TT>,<TT>
WCIterExcept::iter_range</TT>,<TT> WCIterExcept::undef_iter</TT>
</DL>
<H2 ID="WCIsvSListIterXTypeY__resetLR__WCIsvDListIterXTypeY__resetLR"> reset() [WCIsvSListIter&lt;Type&gt;,WCIsvDListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void reset();</TT>
<DT>Semantics:
<DD>The<TT> reset</TT> public member function resets the iterator to the initial state, positioning the iterator before the first
element in the associated list.
<DT>Results:
<DD>The iterator is positioned before the first list element.
<DT>See Also:
<DD><TT> WCIsvSListIter</TT>,<TT> WCIsvDListIter</TT>,<TT> container</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void WCIsvSListIter&lt;Type&gt;::reset( WCIsvSList&lt;Type&gt; &amp; );</TT>
<BR><TT> void WCIsvDListIter&lt;Type&gt;::reset( WCIsvDList&lt;Type&gt; &amp; );</TT>
<DT>Semantics:
<DD>The<TT> reset</TT> public member function resets the iterator to operate on the specified list.&nbsp; The iterator is positioned
before the first element in the list.
<DT>Results:
<DD>The iterator is positioned before the first element of the specified list.
<DT>See Also:
<DD><TT> WCIsvSListIter</TT>,<TT> WCIsvDListIter</TT>,<TT> container</TT>
</DL>
<H2 ID="WCPtrConstSListIterXTypeY__WCPtrConstDListIterXTypeY_Class_Description"> WCPtrConstSListIter&lt;Type&gt;, WCPtrConstDListIter&lt;Type&gt; Class Description </H2>
<DL>
<DT>Declared:
<DD><TT> wclistit.h</TT>
<BR><BR>The<TT> WCPtrConstSListIter&lt;Type&gt;</TT> and<TT> WCPtrConstDListIter&lt;Type&gt;</TT> classes are the templated
classes used to create iterator objects for constant single and double linked list objects.&nbsp; These classes may be used
to iterate over non-constant lists, but the<TT> WCPtrDListIter&lt;Type&gt;</TT> and<TT> WCPtrSListIter&lt;Type&gt;</TT> classes
provide additional functionality for only non-constant lists.
<BR>In the description of each member function, the text<TT> Type</TT> is used to indicate the list element type specified
as the template parameter.
<BR><BR>The<TT> WCIterExcept</TT> class is a base class of the<TT> WCPtrConstSListIter&lt;Type&gt;</TT> and<TT> WCPtrConstDListIter&lt;Type&gt;</TT>
classes and provides the<TT> exceptions</TT> member function.&nbsp; This member function controls the exceptions which can
be thrown by the<TT> WCPtrConstSListIter&lt;Type&gt;</TT> and<TT> WCPtrConstDListIter&lt;Type&gt;</TT> objects.&nbsp; No exceptions
are enabled unless they are set by the<TT> exceptions</TT> member function.
<BR><BR><B>Private Member Functions</B>
<BR><BR>Some functionality supported by base classes of the iterator are not appropriate for the constant list iterator classes.
&nbsp;Setting those functions as private members in the derived class is the standard mechanism to prevent them from being
invoked.
<BR><BR><TT>int append( Type * );</TT>
<BR><TT> int insert( Type * );</TT>
<BR><BR><B>Public Member Functions</B>
<BR><BR>The following member functions are declared in the public interface:
<BR><BR><TT>WCPtrConstSListIter();</TT>
<BR><TT> WCPtrConstSListIter( const WCPtrSList&lt;Type&gt; &amp; );</TT>
<BR><TT> ~WCPtrConstSListIter();</TT>
<BR><TT> WCPtrConstDListIter();</TT>
<BR><TT> WCPtrConstDListIter( const WCPtrDList&lt;Type&gt; &amp; );</TT>
<BR><TT> ~WCPtrConstDListIter();</TT>
<BR><TT> const WCPtrSList&lt;Type&gt; *WCPtrConstSListIter&lt;Type&gt;::container() const;</TT>
<BR><TT> const WCPtrDList&lt;Type&gt; *WCPtrConstDListIter&lt;Type&gt;::container() const;</TT>
<BR><TT> Type * current() const;</TT>
<BR><TT> void reset();</TT>
<BR><TT> void WCPtrConstSListIter&lt;Type&gt;::reset( const WCPtrSList&lt;Type&gt; &amp; );</TT>
<BR><TT> void WCPtrConstDListIter&lt;Type&gt;::reset( const WCPtrDList&lt;Type&gt; &amp; );</TT>
<BR><BR><B>Public Member Operators</B>
<BR><BR>The following member operators are declared in the public interface:
<BR><BR><TT>int operator ()();</TT>
<BR><TT> int operator ++();</TT>
<BR><TT> int operator +=( int );</TT>
<BR><BR>In the iterators for double linked lists only:
<BR><BR><TT>int operator --();</TT>
<BR><TT> int operator -=( int );</TT>
<DT>See Also:
<DD><TT> WCPtrSList::forAll</TT>,<TT> WCPtrDList::forAll</TT>
</DL>
<H2 ID="WCPtrConstSListIterXTypeY__WCPtrConstSListIterLR"> WCPtrConstSListIter() [WCPtrConstSListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCPtrConstSListIter();</TT>
<DT>Semantics:
<DD>The<TT> WCPtrConstSListIter</TT> public member function is the default constructor for the class and initializes the iterator
with no list to operate on.&nbsp; The<TT> reset</TT> member function must be called to provide the iterator with a list to
iterate over.
<DT>Results:
<DD>The<TT> WCPtrConstSListIter</TT> public member function creates an initialized<TT> WCPtrConstSListIter</TT> object.
<DT>See Also:
<DD><TT> WCPtrConstSListIter</TT>,<TT> ~WCPtrConstSListIter</TT>,<TT> reset</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCPtrConstSListIter( const WCPtrSList&lt;Type&gt; &amp; );</TT>
<DT>Semantics:
<DD>The<TT> WCPtrConstSListIter</TT> public member function is a constructor for the class.&nbsp; The value passed as a parameter
is a<TT> WCPtrSList</TT> list object.&nbsp; The iterator will be initialized for that list object and positioned before the
first list element.&nbsp; To position the iterator to a valid element within the list, increment it using any of the<TT> operator
++, operator (),</TT> or<TT> operator +=</TT> operators.
<DT>Results:
<DD>The<TT> WCPtrConstSListIter</TT> public member function creates an initialized<TT> WCPtrConstSListIter</TT> object positioned
before the first element in the list.
<DT>See Also:
<DD><TT> ~WCPtrConstSListIter</TT>,<TT> operator ()</TT>,<TT> operator ++</TT>,<TT> operator +=</TT>,<TT> reset</TT>
</DL>
<H2 ID="WCPtrConstSListIterXTypeY____WCPtrConstSListIterLR"> ~WCPtrConstSListIter() [WCPtrConstSListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>~WCPtrConstSListIter();</TT>
<DT>Semantics:
<DD>The<TT> ~WCPtrConstSListIter</TT> public member function is the destructor for the class.&nbsp; The call to the<TT> ~WCPtrConstSListIter</TT>
public member function is inserted implicitly by the compiler at the point where the<TT> WCPtrConstSListIter</TT> object goes
out of scope.
<DT>Results:
<DD>The<TT> WCPtrConstSListIter</TT> object is destroyed.
<DT>See Also:
<DD><TT> WCPtrConstSListIter</TT>
</DL>
<H2 ID="WCPtrConstDListIterXTypeY__WCPtrConstDListIterLR"> WCPtrConstDListIter() [WCPtrConstDListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCPtrConstDListIter();</TT>
<DT>Semantics:
<DD>The<TT> WCPtrConstDListIter</TT> public member function is the default constructor for the class and initializes the iterator
with no list to operate on.&nbsp; The<TT> reset</TT> member function must be called to provide the iterator with a list to
iterate over.
<DT>Results:
<DD>The<TT> WCPtrConstDListIter</TT> public member function creates an initialized<TT> WCPtrConstDListIter</TT> object.
<DT>See Also:
<DD><TT> WCPtrConstDListIter</TT>,<TT> ~WCPtrConstDListIter</TT>,<TT> reset</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCPtrConstDListIter( const WCPtrDList&lt;Type&gt; &amp; );</TT>
<DT>Semantics:
<DD>The<TT> WCPtrConstDListIter</TT> public member function is a constructor for the class.&nbsp; The value passed as a parameter
is the<TT> WCPtrDList</TT> list object.&nbsp; The iterator will be initialized for that list object and positioned before
the first list element.&nbsp; To position the iterator to a valid element within the list, increment it using any of the<TT>
operator ++, operator (),</TT> or<TT> operator +=</TT> operators.
<DT>Results:
<DD>The<TT> WCPtrConstDListIter</TT> public member function creates an initialized<TT> WCPtrConstDListIter</TT> object positioned
before the first list element.
<DT>See Also:
<DD><TT> WCPtrConstDListIter</TT>,<TT> ~WCPtrConstDListIter</TT>,<TT> operator ()</TT>,<TT> operator ++</TT>,<TT> operator +=</TT>,<TT>
reset</TT>
</DL>
<H2 ID="WCPtrConstDListIterXTypeY____WCPtrConstDListIterLR"> ~WCPtrConstDListIter() [WCPtrConstDListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>~WCPtrConstDListIter();</TT>
<DT>Semantics:
<DD>The<TT> ~WCPtrConstDListIter</TT> public member function is the destructor for the class.&nbsp; The call to the<TT> ~WCPtrConstDListIter</TT>
public member function is inserted implicitly by the compiler at the point where the<TT> WCPtrConstDListIter</TT> object goes
out of scope.
<DT>Results:
<DD>The<TT> WCPtrConstDListIter</TT> object is destroyed.
<DT>See Also:
<DD><TT> WCPtrConstDListIter</TT>
</DL>
<H2 ID="WCPtrConstSListIterXTypeY_WCPtrConstDListIterXTypeY__containerLR"> container() [WCPtrConstSListIter&lt;Type&gt;,WCPtrConstDListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>const WCPtrSList&lt;Type&gt; *WCPtrConstSListIter&lt;Type&gt;::container() const;</TT>
<BR><TT> const WCPtrDList&lt;Type&gt; *WCPtrConstDListIter&lt;Type&gt;::container() const;</TT>
<DT>Semantics:
<DD>The<TT> container</TT> public member function returns a pointer to the list container object.&nbsp; If the iterator has not
been initialized with a list object, and the<TT> undef_iter</TT> exception is enabled, the exception is thrown.
<DT>Results:
<DD>A pointer to the list object associated with the iterator is returned, or NULL(0) if the iterator has not been initialized
with a list.
<DT>See Also:
<DD><TT> WCPtrConstSListIter</TT>,<TT> WCPtrConstDListIter</TT>,<TT> reset</TT>,<TT> WCIterExcept::undef_iter</TT>
</DL>
<H2 ID="WCPtrConstSListIterXTypeY__currentLR__WCPtrConstDListIterXTypeY__currentLR"> current() [WCPtrConstSListIter&lt;Type&gt;,WCPtrConstDListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Type * current();</TT>
<DT>Semantics:
<DD>The<TT> current</TT> public member function returns a pointer to the list item at the current iterator position.
<BR><BR>If the iterator is not associated with a list, or the iterator position is either before the first element or past
the last element in the list, the current iterator position is undefined.&nbsp; In this case the<TT> undef_item</TT> exception
is thrown, if enabled.
<DT>Results:
<DD>A pointer to the current list element is returned.&nbsp; If the current element is undefined, an uninitialized pointer is
returned.
<DT>See Also:
<DD><TT> operator ()</TT>,<TT> operator ++</TT>,<TT> operator +=</TT>,<TT> operator --</TT>,<TT> operator -=</TT>,<TT> reset</TT>,<TT>
WCIterExcept::undef_item</TT>
</DL>
<H2 ID="WCPtrConstSListIterXTypeY_WCPtrConstDListIterXTypeY__operator_LRLR"> operator ()() [WCPtrConstSListIter&lt;Type&gt;,WCPtrConstDListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int operator ()();</TT>
<DT>Semantics:
<DD>The<TT> operator ()</TT> public member function is the call operator for the class.&nbsp; The list element which follows the
current item is set to be the new current item.&nbsp; If the previous current item was the last element in the list, the iterator
is positioned after the end of the list.
<BR><BR>The<TT> operator ()</TT> public member function has the same semantics as the pre-increment operator,<TT> operator
++.</TT>
<BR><BR>If the iterator was positioned before the first element in the list, the current item will be set to the first element
in the list.&nbsp; If the list is empty, the iterator will be positioned after the end of the list.
<BR><BR>If the iterator is not associated with a list or the iterator position before the increment was past the last element
the list, the<TT> undef_iter</TT> exception is thrown, if enabled.
<DT>Results:
<DD>The<TT> operator ()</TT> public member function returns a non-zero value if the iterator is positioned on a list item.&nbsp;
Zero(0) is returned when the iterator is incremented past the end of the list.
<DT>See Also:
<DD><TT> operator ++</TT>,<TT> operator +=</TT>,<TT> operator --</TT>,<TT> operator -=</TT>,<TT> reset</TT>,<TT> WCIterExcept::undef_iter</TT>
</DL>
<H2 ID="WCPtrConstSListIterXTypeY_WCPtrConstDListIterXTypeY__operator_PPLR"> operator ++() [WCPtrConstSListIter&lt;Type&gt;,WCPtrConstDListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int operator ++();</TT>
<DT>Semantics:
<DD>The<TT> operator ++</TT> public member function is the pre-increment operator for the class.&nbsp; The list element which
follows the current item is set to be the new current item.&nbsp; If the previous current item was the last element in the
list, the iterator is positioned after the end of the list.
<BR><BR>The<TT> operator ++</TT> public member function has the same semantics as the call operator,<TT> operator ().</TT>
<BR><BR>If the iterator was positioned before the first element in the list, the current item will be set to the first element
in the list.&nbsp; If the list is empty, the iterator will be positioned after the end of the list.
<BR><BR>If the iterator is not associated with a list or the iterator position before the increment was past the last element
the list, the<TT> undef_iter</TT> exception is thrown, if enabled.
<DT>Results:
<DD>The<TT> operator ++</TT> public member function returns a non-zero value if the iterator is positioned on a list item.&nbsp;
Zero(0) is returned when the iterator is incremented past the end of the list.
<DT>See Also:
<DD><TT> current</TT>,<TT> operator ()</TT>,<TT> operator +=</TT>,<TT> operator --</TT>,<TT> operator -=</TT>,<TT> reset</TT>,<TT>
WCIterExcept::undef_iter</TT>
</DL>
<H2 ID="WCPtrConstSListIterXTypeY_WCPtrConstDListIterXTypeY__operator_PELR"> operator +=() [WCPtrConstSListIter&lt;Type&gt;,WCPtrConstDListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int operator +=( int );</TT>
<DT>Semantics:
<DD>The<TT> operator +=</TT> public member function accepts an integer value that causes the iterator to move that many elements
after the current item.&nbsp; If the iterator was positioned before the first element in the list, the operation will set
the current item to be the given element in the list.
<BR><BR>If the current item was after the last element in the list previous to the iteration, and the<TT> undef_iter</TT>
exception is enabled, the exception will be thrown.&nbsp; Attempting to increment the iterator position more than element
after the end of the list, or by less than one element causes the<TT> iter_range</TT> exception to be thrown, if enabled.
<DT>Results:
<DD>The<TT> operator +=</TT> public member function returns a non-zero value if the iterator is positioned on a list item.&nbsp;
Zero(0) is returned when the iterator is incremented past the end of the list.
<DT>See Also:
<DD><TT> current</TT>,<TT> operator ()</TT>,<TT> operator ++</TT>,<TT> operator --</TT>,<TT> operator -=</TT>,<TT> reset</TT>,<TT>
WCIterExcept::iter_range</TT>,<TT> WCIterExcept::undef_iter</TT>
</DL>
<H2 ID="WCPtrConstDListIterXTypeY__operator_MMLR"> operator --() [WCPtrConstDListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int operator --();</TT>
<DT>Semantics:
<DD>The<TT> operator --</TT> public member function is the pre-decrement operator for the class.&nbsp; The list element previous
to the current item is set to be the new current item.&nbsp; If the current item was the first element in the list, the iterator
is positioned before the first element in the list.&nbsp; If the list is empty, the iterator will be positioned before the
start of the list.
<BR><BR>If the iterator was positioned after the last element in the list, the current item will be set to the last element.
<BR><BR>If the iterator is not associated with a list or the iterator position previous to the decrement was before the first
element the list, the<TT> undef_iter</TT> exception is thrown, if enabled.
<DT>Results:
<DD>The<TT> operator --</TT> public member function returns a non-zero value if the iterator is positioned on a list item.&nbsp;
Zero(0) is returned when the iterator is decremented past the first element of the list.
<DT>See Also:
<DD><TT> current</TT>,<TT> operator ()</TT>,<TT> operator ++</TT>,<TT> operator +=</TT>,<TT> operator -=</TT>,<TT> reset</TT>,<TT>
WCIterExcept::undef_iter</TT>
</DL>
<H2 ID="WCPtrConstDListIterXTypeY__operator_MELR"> operator -=() [WCPtrConstDListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int operator -=( int );</TT>
<DT>Semantics:
<DD>The<TT> operator -=</TT> public member function accepts an integer value that causes the iterator to move that many elements
before the current item.&nbsp; If the iterator was positioned after the last element in the list, the operation will set the
current item to be the given number of elements from the end of the list.
<BR><BR>If the current item was before the first element in the list previous to the iteration, and the<TT> undef_iter</TT>
exception is enabled, the exception will be thrown.&nbsp; Attempting to decrement the iterator position more than one element
before the beginning of the list, or by less than one element causes the<TT> iter_range</TT> exception to be thrown, if enabled.
<DT>Results:
<DD>The<TT> operator -=</TT> public member function returns a non-zero value if the iterator is positioned on a list item.&nbsp;
Zero(0) is returned when the iterator is decremented past the first element in the list.
<DT>See Also:
<DD><TT> current</TT>,<TT> operator ()</TT>,<TT> operator ++</TT>,<TT> operator +=</TT>,<TT> operator --</TT>,<TT> reset</TT>,<TT>
WCIterExcept::iter_range</TT>,<TT> WCIterExcept::undef_iter</TT>
</DL>
<H2 ID="WCPtrConstSListIterXTypeY__resetLR__WCPtrConstDListIterXTypeY__resetLR"> reset() [WCPtrConstSListIter&lt;Type&gt;,WCPtrConstDListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void reset();</TT>
<DT>Semantics:
<DD>The<TT> reset</TT> public member function resets the iterator to the initial state, positioning the iterator before the first
element in the associated list.
<DT>Results:
<DD>The iterator is positioned before the first list element.
<DT>See Also:
<DD><TT> WCPtrConstSListIter</TT>,<TT> WCPtrConstDListIter</TT>,<TT> container</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void WCPtrConstSListIter&lt;Type&gt;::reset( const WCPtrSList&lt;Type&gt; &amp; );</TT>
<BR><TT> void WCPtrConstDListIter&lt;Type&gt;::reset( const WCPtrDList&lt;Type&gt; &amp; );</TT>
<DT>Semantics:
<DD>The<TT> reset</TT> public member function resets the iterator to operate on the specified list.&nbsp; The iterator is positioned
before the first element in the list.
<DT>Results:
<DD>The iterator is positioned before the first element of the specified list.
<DT>See Also:
<DD><TT> WCPtrConstSListIter</TT>,<TT> WCPtrConstDListIter</TT>,<TT> container</TT>
</DL>
<H2 ID="WCPtrSListIterXTypeY__WCPtrDListIterXTypeY_Class_Description"> WCPtrSListIter&lt;Type&gt;, WCPtrDListIter&lt;Type&gt; Class Description </H2>
<DL>
<DT>Declared:
<DD><TT> wclistit.h</TT>
<BR><BR>The<TT> WCPtrSListIter&lt;Type&gt;</TT> and<TT> WCPtrDListIter&lt;Type&gt;</TT> classes are the templated classes
used to create iterator objects for single and double linked list objects.&nbsp; These classes can be used only for non-constant
lists.&nbsp; The<TT> WCPtrDConstListIter&lt;Type&gt;</TT> and<TT> WCPtrSConstListIter&lt;Type&gt;</TT> classes are provided
to iterate over constant lists.
<BR>In the description of each member function, the text<TT> Type</TT> is used to indicate the list element type specified
as the template parameter.
<BR><BR>The<TT> WCIterExcept</TT> class is a base class of the<TT> WCPtrSListIter&lt;Type&gt;</TT> and<TT> WCPtrDListIter&lt;Type&gt;</TT>
classes and provides the<TT> exceptions</TT> member function.&nbsp; This member function controls the exceptions which can
be thrown by the<TT> WCPtrSListIter&lt;Type&gt;</TT> and<TT> WCPtrDListIter&lt;Type&gt;</TT> objects.&nbsp; No exceptions
are enabled unless they are set by the<TT> exceptions</TT> member function.
<BR><BR><B>Private Member Functions</B>
<BR><BR>Some functionality supported by base classes of the iterator are not appropriate in the single linked list iterator
classes.&nbsp; Setting those functions as private members in the derived class is the standard mechanism to prevent them from
being invoked.&nbsp; The following member functions are declared in the single linked list iterator private interface:
<BR><BR><TT>int operator --();</TT>
<BR><TT> int operator -=( int );</TT>
<BR><TT> int insert( Type * );</TT>
<BR><BR><B>Public Member Functions</B>
<BR><BR>The following member functions are declared in the public interface:
<BR><BR><TT>WCPtrSListIter();</TT>
<BR><TT> WCPtrSListIter( WCPtrSList&lt;Type&gt; &amp; );</TT>
<BR><TT> ~WCPtrSListIter();</TT>
<BR><TT> WCPtrDListIter();</TT>
<BR><TT> WCPtrDListIter( WCPtrDList&lt;Type&gt; &amp; );</TT>
<BR><TT> ~WCPtrDListIter();</TT>
<BR><TT> int append( Type * );</TT>
<BR><TT> WCPtrSList&lt;Type&gt; *WCPtrSListIter&lt;Type&gt;::container() const;</TT>
<BR><TT> WCPtrDList&lt;Type&gt; *WCPtrDListIter&lt;Type&gt;::container() const;</TT>
<BR><TT> Type * current() const;</TT>
<BR><TT> void reset();</TT>
<BR><TT> void WCPtrSListIter&lt;Type&gt;::reset( WCPtrSList&lt;Type&gt; &amp; );</TT>
<BR><TT> void WCPtrDListIter&lt;Type&gt;::reset( WCPtrDList&lt;Type&gt; &amp; );</TT>
<BR><BR>In the iterators for double linked lists only:
<BR><BR><TT>int insert( Type * );</TT>
<BR><BR><B>Public Member Operators</B>
<BR><BR>The following member operators are declared in the public interface:
<BR><BR><TT>int operator ()();</TT>
<BR><TT> int operator ++();</TT>
<BR><TT> int operator +=( int );</TT>
<BR><BR>In the iterators for double linked lists only:
<BR><BR><TT>int operator --();</TT>
<BR><TT> int operator -=( int );</TT>
<DT>See Also:
<DD><TT> WCPtrSList::forAll</TT>,<TT> WCPtrDList::forAll</TT>
</DL>
<H2 ID="WCPtrSListIterXTypeY__WCPtrSListIterLR"> WCPtrSListIter() [WCPtrSListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCPtrSListIter();</TT>
<DT>Semantics:
<DD>The<TT> WCPtrSListIter</TT> public member function is the default constructor for the class and initializes the iterator with
no list to operate on.&nbsp; The<TT> reset</TT> member function must be called to provide the iterator with a list to iterate
over.
<DT>Results:
<DD>The<TT> WCPtrSListIter</TT> public member function creates an initialized<TT> WCPtrSListIter</TT> object.
<DT>See Also:
<DD><TT> WCPtrSListIter</TT>,<TT> ~WCPtrSListIter</TT>,<TT> reset</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCPtrSListIter( WCPtrSList&lt;Type&gt; &amp; );</TT>
<DT>Semantics:
<DD>The<TT> WCPtrSListIter</TT> public member function is a constructor for the class.&nbsp; The value passed as a parameter is
a<TT> WCPtrSList</TT> list object.&nbsp; The iterator will be initialized for that list object and positioned before the first
list element.&nbsp; To position the iterator to a valid element within the list, increment it using any of the<TT> operator
++, operator (),</TT> or<TT> operator +=</TT> operators.
<DT>Results:
<DD>The<TT> WCPtrSListIter</TT> public member function creates an initialized<TT> WCPtrSListIter</TT> object positioned before
the first element in the list.
<DT>See Also:
<DD><TT> ~WCPtrSListIter</TT>,<TT> operator ()</TT>,<TT> operator ++</TT>,<TT> operator +=</TT>,<TT> reset</TT>
</DL>
<H2 ID="WCPtrSListIterXTypeY____WCPtrSListIterLR"> ~WCPtrSListIter() [WCPtrSListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>~WCPtrSListIter();</TT>
<DT>Semantics:
<DD>The<TT> ~WCPtrSListIter</TT> public member function is the destructor for the class.&nbsp; The call to the<TT> ~WCPtrSListIter</TT>
public member function is inserted implicitly by the compiler at the point where the<TT> WCPtrSListIter</TT> object goes out
of scope.
<DT>Results:
<DD>The<TT> WCPtrSListIter</TT> object is destroyed.
<DT>See Also:
<DD><TT> WCPtrSListIter</TT>
</DL>
<H2 ID="WCPtrDListIterXTypeY__WCPtrDListIterLR"> WCPtrDListIter() [WCPtrDListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCPtrDListIter();</TT>
<DT>Semantics:
<DD>The<TT> WCPtrDListIter</TT> public member function is the default constructor for the class and initializes the iterator with
no list to operate on.&nbsp; The<TT> reset</TT> member function must be called to provide the iterator with a list to iterate
over.
<DT>Results:
<DD>The<TT> WCPtrDListIter</TT> public member function creates an initialized<TT> WCPtrDListIter</TT> object.
<DT>See Also:
<DD><TT> WCPtrDListIter</TT>,<TT> ~WCPtrDListIter</TT>,<TT> reset</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCPtrDListIter( WCPtrDList&lt;Type&gt; &amp; );</TT>
<DT>Semantics:
<DD>The<TT> WCPtrDListIter</TT> public member function is a constructor for the class.&nbsp; The value passed as a parameter is
the<TT> WCPtrDList</TT> list object.&nbsp; The iterator will be initialized for that list object and positioned before the
first list element.&nbsp; To position the iterator to a valid element within the list, increment it using any of the<TT> operator
++, operator (),</TT> or<TT> operator +=</TT> operators.
<DT>Results:
<DD>The<TT> WCPtrDListIter</TT> public member function creates an initialized<TT> WCPtrDListIter</TT> object positioned before
the first list element.
<DT>See Also:
<DD><TT> WCPtrDListIter</TT>,<TT> ~WCPtrDListIter</TT>,<TT> operator ()</TT>,<TT> operator ++</TT>,<TT> operator +=</TT>,<TT>
reset</TT>
</DL>
<H2 ID="WCPtrDListIterXTypeY____WCPtrDListIterLR"> ~WCPtrDListIter() [WCPtrDListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>~WCPtrDListIter();</TT>
<DT>Semantics:
<DD>The<TT> ~WCPtrDListIter</TT> public member function is the destructor for the class.&nbsp; The call to the<TT> ~WCPtrDListIter</TT>
public member function is inserted implicitly by the compiler at the point where the<TT> WCPtrDListIter</TT> object goes out
of scope.
<DT>Results:
<DD>The<TT> WCPtrDListIter</TT> object is destroyed.
<DT>See Also:
<DD><TT> WCPtrDListIter</TT>
</DL>
<H2 ID="WCPtrSListIterXTypeY__appendLR__WCPtrDListIterXTypeY__appendLR"> append() [WCPtrSListIter&lt;Type&gt;,WCPtrDListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int append( Type * );</TT>
<DT>Semantics:
<DD>The<TT> append</TT> public member function inserts a new element into the list container object.&nbsp; The new element is
inserted after the current iterator item.
<BR><BR>If the iterator is not associated with a list, or the iterator position is either before the first element or past
the last element in the list, the current iterator position is undefined.&nbsp; The element is not appended.&nbsp; If the<TT>
undef_iter</TT> exception is enabled, it is thrown.
<BR><BR>If the append fails, the<TT> out_of_memory</TT> exception is thrown, if enabled in the list being iterated over.&nbsp;
The list remains unchanged.
<DT>Results:
<DD>The new element is inserted after the current iterator item.&nbsp; A TRUE value (non-zero) is returned if the append is successful.
&nbsp;A FALSE (zero) result is returned if the append fails.
<DT>See Also:
<DD><TT> insert</TT>,<TT> WCExcept::out_of_memory</TT>,<TT> WCIterExcept::undef_iter</TT>
</DL>
<H2 ID="WCPtrSListIterXTypeY_WCPtrDListIterXTypeY__containerLR"> container() [WCPtrSListIter&lt;Type&gt;,WCPtrDListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCPtrSList&lt;Type&gt; *WCPtrSListIter&lt;Type&gt;::container() const;</TT>
<BR><TT> WCPtrDList&lt;Type&gt; *WCPtrDListIter&lt;Type&gt;::container() const;</TT>
<DT>Semantics:
<DD>The<TT> container</TT> public member function returns a pointer to the list container object.&nbsp; If the iterator has not
been initialized with a list object, and the<TT> undef_iter</TT> exception is enabled, the exception is thrown.
<DT>Results:
<DD>A pointer to the list object associated with the iterator is returned, or NULL(0) if the iterator has not been initialized
with a list.
<DT>See Also:
<DD><TT> WCPtrSListIter</TT>,<TT> WCPtrDListIter</TT>,<TT> reset</TT>,<TT> WCIterExcept::undef_iter</TT>
</DL>
<H2 ID="WCPtrSListIterXTypeY__currentLR__WCPtrDListIterXTypeY__currentLR"> current() [WCPtrSListIter&lt;Type&gt;,WCPtrDListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Type * current();</TT>
<DT>Semantics:
<DD>The<TT> current</TT> public member function returns a pointer to the list item at the current iterator position.
<BR><BR>If the iterator is not associated with a list, or the iterator position is either before the first element or past
the last element in the list, the current iterator position is undefined.&nbsp; In this case the<TT> undef_item</TT> exception
is thrown, if enabled.
<DT>Results:
<DD>A pointer to the current list element is returned.&nbsp; If the current element is undefined, an uninitialized pointer is
returned.
<DT>See Also:
<DD><TT> operator ()</TT>,<TT> operator ++</TT>,<TT> operator +=</TT>,<TT> operator --</TT>,<TT> operator -=</TT>,<TT> reset</TT>,<TT>
WCIterExcept::undef_item</TT>
</DL>
<H2 ID="WCPtrDListIterXTypeY__insertLR"> insert() [WCPtrDListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int insert( Type * );</TT>
<DT>Semantics:
<DD>The<TT> insert</TT> public member function inserts a new element into the list container object.&nbsp; The new element is
inserted before the current iterator item.&nbsp; This process uses the previous link in the double linked list, so the<TT>
insert</TT> public member function is not allowed with single linked lists.
<BR><BR>If the iterator is not associated with a list, or the iterator position is either before the first element or past
the last element in the list, the current iterator position is undefined.&nbsp; The element is not inserted.&nbsp; If the<TT>
undef_iter</TT> exception is enabled, the exception is thrown.
<BR><BR>If the insert fails and the<TT> out_of_memory</TT> exception is enabled in the list being iterated over, the exception
is thrown.&nbsp; The list remains unchanged.
<DT>Results:
<DD>The new element is inserted before the current iterator item.&nbsp; A TRUE value (non-zero) is returned if the insert is successful.
&nbsp;A FALSE (zero) result is returned if the insert fails.
<DT>See Also:
<DD><TT> append</TT>,<TT> WCExcept::out_of_memory</TT>,<TT> WCIterExcept::undef_iter</TT>
</DL>
<H2 ID="WCPtrSListIterXTypeY_WCPtrDListIterXTypeY__operator_LRLR"> operator ()() [WCPtrSListIter&lt;Type&gt;,WCPtrDListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int operator ()();</TT>
<DT>Semantics:
<DD>The<TT> operator ()</TT> public member function is the call operator for the class.&nbsp; The list element which follows the
current item is set to be the new current item.&nbsp; If the previous current item was the last element in the list, the iterator
is positioned after the end of the list.
<BR><BR>The<TT> operator ()</TT> public member function has the same semantics as the pre-increment operator,<TT> operator
++.</TT>
<BR><BR>If the iterator was positioned before the first element in the list, the current item will be set to the first element
in the list.&nbsp; If the list is empty, the iterator will be positioned after the end of the list.
<BR><BR>If the iterator is not associated with a list or the iterator position before the increment was past the last element
the list, the<TT> undef_iter</TT> exception is thrown, if enabled.
<DT>Results:
<DD>The<TT> operator ()</TT> public member function returns a non-zero value if the iterator is positioned on a list item.&nbsp;
Zero(0) is returned when the iterator is incremented past the end of the list.
<DT>See Also:
<DD><TT> operator ++</TT>,<TT> operator +=</TT>,<TT> operator --</TT>,<TT> operator -=</TT>,<TT> reset</TT>,<TT> WCIterExcept::undef_iter</TT>
</DL>
<H2 ID="WCPtrSListIterXTypeY_WCPtrDListIterXTypeY__operator_PPLR"> operator ++() [WCPtrSListIter&lt;Type&gt;,WCPtrDListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int operator ++();</TT>
<DT>Semantics:
<DD>The<TT> operator ++</TT> public member function is the pre-increment operator for the class.&nbsp; The list element which
follows the current item is set to be the new current item.&nbsp; If the previous current item was the last element in the
list, the iterator is positioned after the end of the list.
<BR><BR>The<TT> operator ++</TT> public member function has the same semantics as the call operator,<TT> operator ().</TT>
<BR><BR>If the iterator was positioned before the first element in the list, the current item will be set to the first element
in the list.&nbsp; If the list is empty, the iterator will be positioned after the end of the list.
<BR><BR>If the iterator is not associated with a list or the iterator position before the increment was past the last element
the list, the<TT> undef_iter</TT> exception is thrown, if enabled.
<DT>Results:
<DD>The<TT> operator ++</TT> public member function returns a non-zero value if the iterator is positioned on a list item.&nbsp;
Zero(0) is returned when the iterator is incremented past the end of the list.
<DT>See Also:
<DD><TT> current</TT>,<TT> operator ()</TT>,<TT> operator +=</TT>,<TT> operator --</TT>,<TT> operator -=</TT>,<TT> reset</TT>,<TT>
WCIterExcept::undef_iter</TT>
</DL>
<H2 ID="WCPtrSListIterXTypeY_WCPtrDListIterXTypeY__operator_PELR"> operator +=() [WCPtrSListIter&lt;Type&gt;,WCPtrDListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int operator +=( int );</TT>
<DT>Semantics:
<DD>The<TT> operator +=</TT> public member function accepts an integer value that causes the iterator to move that many elements
after the current item.&nbsp; If the iterator was positioned before the first element in the list, the operation will set
the current item to be the given element in the list.
<BR><BR>If the current item was after the last element in the list previous to the iteration, and the<TT> undef_iter</TT>
exception is enabled, the exception will be thrown.&nbsp; Attempting to increment the iterator position more than element
after the end of the list, or by less than one element causes the<TT> iter_range</TT> exception to be thrown, if enabled.
<DT>Results:
<DD>The<TT> operator +=</TT> public member function returns a non-zero value if the iterator is positioned on a list item.&nbsp;
Zero(0) is returned when the iterator is incremented past the end of the list.
<DT>See Also:
<DD><TT> current</TT>,<TT> operator ()</TT>,<TT> operator ++</TT>,<TT> operator --</TT>,<TT> operator -=</TT>,<TT> reset</TT>,<TT>
WCIterExcept::iter_range</TT>,<TT> WCIterExcept::undef_iter</TT>
</DL>
<H2 ID="WCPtrDListIterXTypeY__operator_MMLR"> operator --() [WCPtrDListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int operator --();</TT>
<DT>Semantics:
<DD>The<TT> operator --</TT> public member function is the pre-decrement operator for the class.&nbsp; The list element previous
to the current item is set to be the new current item.&nbsp; If the current item was the first element in the list, the iterator
is positioned before the first element in the list.&nbsp; If the list is empty, the iterator will be positioned before the
start of the list.
<BR><BR>If the iterator was positioned after the last element in the list, the current item will be set to the last element.
<BR><BR>If the iterator is not associated with a list or the iterator position previous to the decrement was before the first
element the list, the<TT> undef_iter</TT> exception is thrown, if enabled.
<DT>Results:
<DD>The<TT> operator --</TT> public member function returns a non-zero value if the iterator is positioned on a list item.&nbsp;
Zero(0) is returned when the iterator is decremented past the first element of the list.
<DT>See Also:
<DD><TT> current</TT>,<TT> operator ()</TT>,<TT> operator ++</TT>,<TT> operator +=</TT>,<TT> operator -=</TT>,<TT> reset</TT>,<TT>
WCIterExcept::undef_iter</TT>
</DL>
<H2 ID="WCPtrDListIterXTypeY__operator_MELR"> operator -=() [WCPtrDListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int operator -=( int );</TT>
<DT>Semantics:
<DD>The<TT> operator -=</TT> public member function accepts an integer value that causes the iterator to move that many elements
before the current item.&nbsp; If the iterator was positioned after the last element in the list, the operation will set the
current item to be the given number of elements from the end of the list.
<BR><BR>If the current item was before the first element in the list previous to the iteration, and the<TT> undef_iter</TT>
exception is enabled, the exception will be thrown.&nbsp; Attempting to decrement the iterator position more than one element
before the beginning of the list, or by less than one element causes the<TT> iter_range</TT> exception to be thrown, if enabled.
<DT>Results:
<DD>The<TT> operator -=</TT> public member function returns a non-zero value if the iterator is positioned on a list item.&nbsp;
Zero(0) is returned when the iterator is decremented past the first element in the list.
<DT>See Also:
<DD><TT> current</TT>,<TT> operator ()</TT>,<TT> operator ++</TT>,<TT> operator +=</TT>,<TT> operator --</TT>,<TT> reset</TT>,<TT>
WCIterExcept::iter_range</TT>,<TT> WCIterExcept::undef_iter</TT>
</DL>
<H2 ID="WCPtrSListIterXTypeY__resetLR__WCPtrDListIterXTypeY__resetLR"> reset() [WCPtrSListIter&lt;Type&gt;,WCPtrDListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void reset();</TT>
<DT>Semantics:
<DD>The<TT> reset</TT> public member function resets the iterator to the initial state, positioning the iterator before the first
element in the associated list.
<DT>Results:
<DD>The iterator is positioned before the first list element.
<DT>See Also:
<DD><TT> WCPtrSListIter</TT>,<TT> WCPtrDListIter</TT>,<TT> container</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void WCPtrSListIter&lt;Type&gt;::reset( WCPtrSList&lt;Type&gt; &amp; );</TT>
<BR><TT> void WCPtrDListIter&lt;Type&gt;::reset( WCPtrDList&lt;Type&gt; &amp; );</TT>
<DT>Semantics:
<DD>The<TT> reset</TT> public member function resets the iterator to operate on the specified list.&nbsp; The iterator is positioned
before the first element in the list.
<DT>Results:
<DD>The iterator is positioned before the first element of the specified list.
<DT>See Also:
<DD><TT> WCPtrSListIter</TT>,<TT> WCPtrDListIter</TT>,<TT> container</TT>
</DL>
<H2 ID="WCValConstSListIterXTypeY__WCValConstDListIterXTypeY_Class_Description"> WCValConstSListIter&lt;Type&gt;, WCValConstDListIter&lt;Type&gt; Class Description </H2>
<DL>
<DT>Declared:
<DD><TT> wclistit.h</TT>
<BR><BR>The<TT> WCValConstSListIter&lt;Type&gt;</TT> and<TT> WCValConstDListIter&lt;Type&gt;</TT> classes are the templated
classes used to create iterator objects for constant single and double linked list objects.&nbsp; These classes may be used
to iterate over non-constant lists, but the<TT> WCValDListIter&lt;Type&gt;</TT> and<TT> WCValSListIter&lt;Type&gt;</TT> classes
provide additional functionality for only non-constant lists.
<BR>In the description of each member function, the text<TT> Type</TT> is used to indicate the list element type specified
as the template parameter.
<BR><BR>The<TT> WCIterExcept</TT> class is a base class of the<TT> WCValConstSListIter&lt;Type&gt;</TT> and<TT> WCValConstDListIter&lt;Type&gt;</TT>
classes and provides the<TT> exceptions</TT> member function.&nbsp; This member function controls the exceptions which can
be thrown by the<TT> WCValConstSListIter&lt;Type&gt;</TT> and<TT> WCValConstDListIter&lt;Type&gt;</TT> objects.&nbsp; No exceptions
are enabled unless they are set by the<TT> exceptions</TT> member function.
<BR><BR><B>Private Member Functions</B>
<BR><BR>Some functionality supported by base classes of the iterator are not appropriate for the constant list iterator classes.
&nbsp;Setting those functions as private members in the derived class is the standard mechanism to prevent them from being
invoked.
<BR><BR><TT>int append( Type &amp; );</TT>
<BR><TT> int insert( Type &amp; );</TT>
<BR><BR><B>Public Member Functions</B>
<BR><BR>The following member functions are declared in the public interface:
<BR><BR><TT>WCValConstSListIter();</TT>
<BR><TT> WCValConstSListIter( const WCValSList&lt;Type&gt; &amp; );</TT>
<BR><TT> ~WCValConstSListIter();</TT>
<BR><TT> WCValConstDListIter();</TT>
<BR><TT> WCValConstDListIter( const WCValDList&lt;Type&gt; &amp; );</TT>
<BR><TT> ~WCValConstDListIter();</TT>
<BR><TT> const WCValSList&lt;Type&gt; *WCValConstSListIter&lt;Type&gt;::container() const;</TT>
<BR><TT> const WCValDList&lt;Type&gt; *WCValConstDListIter&lt;Type&gt;::container() const;</TT>
<BR><TT> Type current() const;</TT>
<BR><TT> void reset();</TT>
<BR><TT> void WCValConstSListIter&lt;Type&gt;::reset( const WCValSList&lt;Type&gt; &amp; );</TT>
<BR><TT> void WCValConstDListIter&lt;Type&gt;::reset( const WCValDList&lt;Type&gt; &amp; );</TT>
<BR><BR><B>Public Member Operators</B>
<BR><BR>The following member operators are declared in the public interface:
<BR><BR><TT>int operator ()();</TT>
<BR><TT> int operator ++();</TT>
<BR><TT> int operator +=( int );</TT>
<BR><BR>In the iterators for double linked lists only:
<BR><BR><TT>int operator --();</TT>
<BR><TT> int operator -=( int );</TT>
<DT>See Also:
<DD><TT> WCValSList::forAll</TT>,<TT> WCValDList::forAll</TT>
</DL>
<H2 ID="WCValConstSListIterXTypeY__WCValConstSListIterLR"> WCValConstSListIter() [WCValConstSListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCValConstSListIter();</TT>
<DT>Semantics:
<DD>The<TT> WCValConstSListIter</TT> public member function is the default constructor for the class and initializes the iterator
with no list to operate on.&nbsp; The<TT> reset</TT> member function must be called to provide the iterator with a list to
iterate over.
<DT>Results:
<DD>The<TT> WCValConstSListIter</TT> public member function creates an initialized<TT> WCValConstSListIter</TT> object.
<DT>See Also:
<DD><TT> WCValConstSListIter</TT>,<TT> ~WCValConstSListIter</TT>,<TT> reset</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCValConstSListIter( const WCValSList&lt;Type&gt; &amp; );</TT>
<DT>Semantics:
<DD>The<TT> WCValConstSListIter</TT> public member function is a constructor for the class.&nbsp; The value passed as a parameter
is a<TT> WCValSList</TT> list object.&nbsp; The iterator will be initialized for that list object and positioned before the
first list element.&nbsp; To position the iterator to a valid element within the list, increment it using any of the<TT> operator
++, operator (),</TT> or<TT> operator +=</TT> operators.
<DT>Results:
<DD>The<TT> WCValConstSListIter</TT> public member function creates an initialized<TT> WCValConstSListIter</TT> object positioned
before the first element in the list.
<DT>See Also:
<DD><TT> ~WCValConstSListIter</TT>,<TT> operator ()</TT>,<TT> operator ++</TT>,<TT> operator +=</TT>,<TT> reset</TT>
</DL>
<H2 ID="WCValConstSListIterXTypeY____WCValConstSListIterLR"> ~WCValConstSListIter() [WCValConstSListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>~WCValConstSListIter();</TT>
<DT>Semantics:
<DD>The<TT> ~WCValConstSListIter</TT> public member function is the destructor for the class.&nbsp; The call to the<TT> ~WCValConstSListIter</TT>
public member function is inserted implicitly by the compiler at the point where the<TT> WCValConstSListIter</TT> object goes
out of scope.
<DT>Results:
<DD>The<TT> WCValConstSListIter</TT> object is destroyed.
<DT>See Also:
<DD><TT> WCValConstSListIter</TT>
</DL>
<H2 ID="WCValConstDListIterXTypeY__WCValConstDListIterLR"> WCValConstDListIter() [WCValConstDListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCValConstDListIter();</TT>
<DT>Semantics:
<DD>The<TT> WCValConstDListIter</TT> public member function is the default constructor for the class and initializes the iterator
with no list to operate on.&nbsp; The<TT> reset</TT> member function must be called to provide the iterator with a list to
iterate over.
<DT>Results:
<DD>The<TT> WCValConstDListIter</TT> public member function creates an initialized<TT> WCValConstDListIter</TT> object.
<DT>See Also:
<DD><TT> WCValConstDListIter</TT>,<TT> ~WCValConstDListIter</TT>,<TT> reset</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCValConstDListIter( const WCValDList&lt;Type&gt; &amp; );</TT>
<DT>Semantics:
<DD>The<TT> WCValConstDListIter</TT> public member function is a constructor for the class.&nbsp; The value passed as a parameter
is the<TT> WCValDList</TT> list object.&nbsp; The iterator will be initialized for that list object and positioned before
the first list element.&nbsp; To position the iterator to a valid element within the list, increment it using any of the<TT>
operator ++, operator (),</TT> or<TT> operator +=</TT> operators.
<DT>Results:
<DD>The<TT> WCValConstDListIter</TT> public member function creates an initialized<TT> WCValConstDListIter</TT> object positioned
before the first list element.
<DT>See Also:
<DD><TT> WCValConstDListIter</TT>,<TT> ~WCValConstDListIter</TT>,<TT> operator ()</TT>,<TT> operator ++</TT>,<TT> operator +=</TT>,<TT>
reset</TT>
</DL>
<H2 ID="WCValConstDListIterXTypeY____WCValConstDListIterLR"> ~WCValConstDListIter() [WCValConstDListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>~WCValConstDListIter();</TT>
<DT>Semantics:
<DD>The<TT> ~WCValConstDListIter</TT> public member function is the destructor for the class.&nbsp; The call to the<TT> ~WCValConstDListIter</TT>
public member function is inserted implicitly by the compiler at the point where the<TT> WCValConstDListIter</TT> object goes
out of scope.
<DT>Results:
<DD>The<TT> WCValConstDListIter</TT> object is destroyed.
<DT>See Also:
<DD><TT> WCValConstDListIter</TT>
</DL>
<H2 ID="WCValConstSListIterXTypeY_WCValConstDListIterXTypeY__containerLR"> container() [WCValConstSListIter&lt;Type&gt;,WCValConstDListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>const WCValSList&lt;Type&gt; *WCValConstSListIter&lt;Type&gt;::container() const;</TT>
<BR><TT> const WCValDList&lt;Type&gt; *WCValConstDListIter&lt;Type&gt;::container() const;</TT>
<DT>Semantics:
<DD>The<TT> container</TT> public member function returns a pointer to the list container object.&nbsp; If the iterator has not
been initialized with a list object, and the<TT> undef_iter</TT> exception is enabled, the exception is thrown.
<DT>Results:
<DD>A pointer to the list object associated with the iterator is returned, or NULL(0) if the iterator has not been initialized
with a list.
<DT>See Also:
<DD><TT> WCValConstSListIter</TT>,<TT> WCValConstDListIter</TT>,<TT> reset</TT>,<TT> WCIterExcept::undef_iter</TT>
</DL>
<H2 ID="WCValConstSListIterXTypeY__currentLR__WCValConstDListIterXTypeY__currentLR"> current() [WCValConstSListIter&lt;Type&gt;,WCValConstDListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Type current();</TT>
<DT>Semantics:
<DD>The<TT> current</TT> public member function returns the value of the list element at the current iterator position.
<BR><BR>If the iterator is not associated with a list, or the iterator position is either before the first element or past
the last element in the list, the current iterator position is undefined.&nbsp; In this case the<TT> undef_item</TT> exception
is thrown, if enabled.
<DT>Results:
<DD>The value at the current iterator element is returned.&nbsp; If the current element is undefined, a default initialized object
is returned.
<DT>See Also:
<DD><TT> operator ()</TT>,<TT> operator ++</TT>,<TT> operator +=</TT>,<TT> operator --</TT>,<TT> operator -=</TT>,<TT> reset</TT>,<TT>
WCIterExcept::undef_item</TT>
</DL>
<H2 ID="WCValConstSListIterXTypeY_WCValConstDListIterXTypeY__operator_LRLR"> operator ()() [WCValConstSListIter&lt;Type&gt;,WCValConstDListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int operator ()();</TT>
<DT>Semantics:
<DD>The<TT> operator ()</TT> public member function is the call operator for the class.&nbsp; The list element which follows the
current item is set to be the new current item.&nbsp; If the previous current item was the last element in the list, the iterator
is positioned after the end of the list.
<BR><BR>The<TT> operator ()</TT> public member function has the same semantics as the pre-increment operator,<TT> operator
++.</TT>
<BR><BR>If the iterator was positioned before the first element in the list, the current item will be set to the first element
in the list.&nbsp; If the list is empty, the iterator will be positioned after the end of the list.
<BR><BR>If the iterator is not associated with a list or the iterator position before the increment was past the last element
the list, the<TT> undef_iter</TT> exception is thrown, if enabled.
<DT>Results:
<DD>The<TT> operator ()</TT> public member function returns a non-zero value if the iterator is positioned on a list item.&nbsp;
Zero(0) is returned when the iterator is incremented past the end of the list.
<DT>See Also:
<DD><TT> operator ++</TT>,<TT> operator +=</TT>,<TT> operator --</TT>,<TT> operator -=</TT>,<TT> reset</TT>,<TT> WCIterExcept::undef_iter</TT>
</DL>
<H2 ID="WCValConstSListIterXTypeY_WCValConstDListIterXTypeY__operator_PPLR"> operator ++() [WCValConstSListIter&lt;Type&gt;,WCValConstDListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int operator ++();</TT>
<DT>Semantics:
<DD>The<TT> operator ++</TT> public member function is the pre-increment operator for the class.&nbsp; The list element which
follows the current item is set to be the new current item.&nbsp; If the previous current item was the last element in the
list, the iterator is positioned after the end of the list.
<BR><BR>The<TT> operator ++</TT> public member function has the same semantics as the call operator,<TT> operator ().</TT>
<BR><BR>If the iterator was positioned before the first element in the list, the current item will be set to the first element
in the list.&nbsp; If the list is empty, the iterator will be positioned after the end of the list.
<BR><BR>If the iterator is not associated with a list or the iterator position before the increment was past the last element
the list, the<TT> undef_iter</TT> exception is thrown, if enabled.
<DT>Results:
<DD>The<TT> operator ++</TT> public member function returns a non-zero value if the iterator is positioned on a list item.&nbsp;
Zero(0) is returned when the iterator is incremented past the end of the list.
<DT>See Also:
<DD><TT> current</TT>,<TT> operator ()</TT>,<TT> operator +=</TT>,<TT> operator --</TT>,<TT> operator -=</TT>,<TT> reset</TT>,<TT>
WCIterExcept::undef_iter</TT>
</DL>
<H2 ID="WCValConstSListIterXTypeY_WCValConstDListIterXTypeY__operator_PELR"> operator +=() [WCValConstSListIter&lt;Type&gt;,WCValConstDListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int operator +=( int );</TT>
<DT>Semantics:
<DD>The<TT> operator +=</TT> public member function accepts an integer value that causes the iterator to move that many elements
after the current item.&nbsp; If the iterator was positioned before the first element in the list, the operation will set
the current item to be the given element in the list.
<BR><BR>If the current item was after the last element in the list previous to the iteration, and the<TT> undef_iter</TT>
exception is enabled, the exception will be thrown.&nbsp; Attempting to increment the iterator position more than element
after the end of the list, or by less than one element causes the<TT> iter_range</TT> exception to be thrown, if enabled.
<DT>Results:
<DD>The<TT> operator +=</TT> public member function returns a non-zero value if the iterator is positioned on a list item.&nbsp;
Zero(0) is returned when the iterator is incremented past the end of the list.
<DT>See Also:
<DD><TT> current</TT>,<TT> operator ()</TT>,<TT> operator ++</TT>,<TT> operator --</TT>,<TT> operator -=</TT>,<TT> reset</TT>,<TT>
WCIterExcept::iter_range</TT>,<TT> WCIterExcept::undef_iter</TT>
</DL>
<H2 ID="WCValConstDListIterXTypeY__operator_MMLR"> operator --() [WCValConstDListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int operator --();</TT>
<DT>Semantics:
<DD>The<TT> operator --</TT> public member function is the pre-decrement operator for the class.&nbsp; The list element previous
to the current item is set to be the new current item.&nbsp; If the current item was the first element in the list, the iterator
is positioned before the first element in the list.&nbsp; If the list is empty, the iterator will be positioned before the
start of the list.
<BR><BR>If the iterator was positioned after the last element in the list, the current item will be set to the last element.
<BR><BR>If the iterator is not associated with a list or the iterator position previous to the decrement was before the first
element the list, the<TT> undef_iter</TT> exception is thrown, if enabled.
<DT>Results:
<DD>The<TT> operator --</TT> public member function returns a non-zero value if the iterator is positioned on a list item.&nbsp;
Zero(0) is returned when the iterator is decremented past the first element of the list.
<DT>See Also:
<DD><TT> current</TT>,<TT> operator ()</TT>,<TT> operator ++</TT>,<TT> operator +=</TT>,<TT> operator -=</TT>,<TT> reset</TT>,<TT>
WCIterExcept::undef_iter</TT>
</DL>
<H2 ID="WCValConstDListIterXTypeY__operator_MELR"> operator -=() [WCValConstDListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int operator -=( int );</TT>
<DT>Semantics:
<DD>The<TT> operator -=</TT> public member function accepts an integer value that causes the iterator to move that many elements
before the current item.&nbsp; If the iterator was positioned after the last element in the list, the operation will set the
current item to be the given number of elements from the end of the list.
<BR><BR>If the current item was before the first element in the list previous to the iteration, and the<TT> undef_iter</TT>
exception is enabled, the exception will be thrown.&nbsp; Attempting to decrement the iterator position more than one element
before the beginning of the list, or by less than one element causes the<TT> iter_range</TT> exception to be thrown, if enabled.
<DT>Results:
<DD>The<TT> operator -=</TT> public member function returns a non-zero value if the iterator is positioned on a list item.&nbsp;
Zero(0) is returned when the iterator is decremented past the first element in the list.
<DT>See Also:
<DD><TT> current</TT>,<TT> operator ()</TT>,<TT> operator ++</TT>,<TT> operator +=</TT>,<TT> operator --</TT>,<TT> reset</TT>,<TT>
WCIterExcept::iter_range</TT>,<TT> WCIterExcept::undef_iter</TT>
</DL>
<H2 ID="WCValConstSListIterXTypeY__resetLR__WCValConstDListIterXTypeY__resetLR"> reset() [WCValConstSListIter&lt;Type&gt;,WCValConstDListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void reset();</TT>
<DT>Semantics:
<DD>The<TT> reset</TT> public member function resets the iterator to the initial state, positioning the iterator before the first
element in the associated list.
<DT>Results:
<DD>The iterator is positioned before the first list element.
<DT>See Also:
<DD><TT> WCValConstSListIter</TT>,<TT> WCValConstDListIter</TT>,<TT> container</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void WCValConstSListIter&lt;Type&gt;::reset( const WCValSList&lt;Type&gt; &amp; );</TT>
<BR><TT> void WCValConstDListIter&lt;Type&gt;::reset( const WCValDList&lt;Type&gt; &amp; );</TT>
<DT>Semantics:
<DD>The<TT> reset</TT> public member function resets the iterator to operate on the specified list.&nbsp; The iterator is positioned
before the first element in the list.
<DT>Results:
<DD>The iterator is positioned before the first element of the specified list.
<DT>See Also:
<DD><TT> WCValConstSListIter</TT>,<TT> WCValConstDListIter</TT>,<TT> container</TT>
</DL>
<H2 ID="WCValSListIterXTypeY__WCValDListIterXTypeY_Class_Description"> WCValSListIter&lt;Type&gt;, WCValDListIter&lt;Type&gt; Class Description </H2>
<DL>
<DT>Declared:
<DD><TT> wclistit.h</TT>
<BR><BR>The<TT> WCValSListIter&lt;Type&gt;</TT> and<TT> WCValDListIter&lt;Type&gt;</TT> classes are the templated classes
used to create iterator objects for single and double linked list objects.&nbsp; These classes can be used only for non-constant
lists.&nbsp; The<TT> WCValDConstListIter&lt;Type&gt;</TT> and<TT> WCValSConstListIter&lt;Type&gt;</TT> classes are provided
to iterate over constant lists.
<BR>In the description of each member function, the text<TT> Type</TT> is used to indicate the list element type specified
as the template parameter.
<BR><BR>The<TT> WCIterExcept</TT> class is a base class of the<TT> WCValSListIter&lt;Type&gt;</TT> and<TT> WCValDListIter&lt;Type&gt;</TT>
classes and provides the<TT> exceptions</TT> member function.&nbsp; This member function controls the exceptions which can
be thrown by the<TT> WCValSListIter&lt;Type&gt;</TT> and<TT> WCValDListIter&lt;Type&gt;</TT> objects.&nbsp; No exceptions
are enabled unless they are set by the<TT> exceptions</TT> member function.
<BR><BR><B>Private Member Functions</B>
<BR><BR>Some functionality supported by base classes of the iterator are not appropriate in the single linked list iterator
classes.&nbsp; Setting those functions as private members in the derived class is the standard mechanism to prevent them from
being invoked.&nbsp; The following member functions are declared in the single linked list iterator private interface:
<BR><BR><TT>int operator --();</TT>
<BR><TT> int operator -=( int );</TT>
<BR><TT> int insert( Type &amp; );</TT>
<BR><BR><B>Public Member Functions</B>
<BR><BR>The following member functions are declared in the public interface:
<BR><BR><TT>WCValSListIter();</TT>
<BR><TT> WCValSListIter( WCValSList&lt;Type&gt; &amp; );</TT>
<BR><TT> ~WCValSListIter();</TT>
<BR><TT> WCValDListIter();</TT>
<BR><TT> WCValDListIter( WCValDList&lt;Type&gt; &amp; );</TT>
<BR><TT> ~WCValDListIter();</TT>
<BR><TT> int append( Type &amp; );</TT>
<BR><TT> WCValSList&lt;Type&gt; *WCValSListIter&lt;Type&gt;::container() const;</TT>
<BR><TT> WCValDList&lt;Type&gt; *WCValDListIter&lt;Type&gt;::container() const;</TT>
<BR><TT> Type current() const;</TT>
<BR><TT> void reset();</TT>
<BR><TT> void WCValSListIter&lt;Type&gt;::reset( WCValSList&lt;Type&gt; &amp; );</TT>
<BR><TT> void WCValDListIter&lt;Type&gt;::reset( WCValDList&lt;Type&gt; &amp; );</TT>
<BR><BR>In the iterators for double linked lists only:
<BR><BR><TT>int insert( Type &amp; );</TT>
<BR><BR><B>Public Member Operators</B>
<BR><BR>The following member operators are declared in the public interface:
<BR><BR><TT>int operator ()();</TT>
<BR><TT> int operator ++();</TT>
<BR><TT> int operator +=( int );</TT>
<BR><BR>In the iterators for double linked lists only:
<BR><BR><TT>int operator --();</TT>
<BR><TT> int operator -=( int );</TT>
<DT>See Also:
<DD><TT> WCValSList::forAll</TT>,<TT> WCValDList::forAll</TT>
<BR><BR><B>Sample Program Using Value List Iterators</B>
<BR><BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><BR><TT>//</TT>
<BR><TT>// insert elem after all elements in the list less than or equal to</TT>
<BR><TT>// elem</TT>
<BR><TT>//</TT>
<BR><BR><TT>void insert_in_order( WCValDList&lt;int&gt; &amp;list, int elem ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( list.entries() == 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // cannot insert in an empty list using a iterator</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; list.insert( elem );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WCValDListIter&lt;int&gt; iter( list );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( ++iter ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( iter.current() &gt; elem ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // insert elem before first
element in list greater</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // than elem</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iter.insert( elem );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // iterated past the end of the list</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // append elem to the end of the list</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; list.append( elem );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
<BR><BR><TT>void main() {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; WCValDList&lt;int&gt; list;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; insert_in_order( list, 5 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; insert_in_order( list, 20 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; insert_in_order( list, 1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; insert_in_order( list, 25 );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; cout &lt;&lt; &quot;List elements in ascending order:\n&quot;;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; WCValDListIter&lt;int&gt; iter( list );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; while( ++iter ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; iter.current() &lt;&lt; &quot;\n&quot;;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; cout &lt;&lt; &quot;List elements in descending order\n&quot;;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; // iterator is past the end of the list</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; while( --iter ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; iter.current() &lt;&lt; &quot;\n&quot;;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
</DL>
<H2 ID="WCValSListIterXTypeY__WCValSListIterLR"> WCValSListIter() [WCValSListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCValSListIter();</TT>
<DT>Semantics:
<DD>The<TT> WCValSListIter</TT> public member function is the default constructor for the class and initializes the iterator with
no list to operate on.&nbsp; The<TT> reset</TT> member function must be called to provide the iterator with a list to iterate
over.
<DT>Results:
<DD>The<TT> WCValSListIter</TT> public member function creates an initialized<TT> WCValSListIter</TT> object.
<DT>See Also:
<DD><TT> WCValSListIter</TT>,<TT> ~WCValSListIter</TT>,<TT> reset</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCValSListIter( WCValSList&lt;Type&gt; &amp; );</TT>
<DT>Semantics:
<DD>The<TT> WCValSListIter</TT> public member function is a constructor for the class.&nbsp; The value passed as a parameter is
a<TT> WCValSList</TT> list object.&nbsp; The iterator will be initialized for that list object and positioned before the first
list element.&nbsp; To position the iterator to a valid element within the list, increment it using any of the<TT> operator
++, operator (),</TT> or<TT> operator +=</TT> operators.
<DT>Results:
<DD>The<TT> WCValSListIter</TT> public member function creates an initialized<TT> WCValSListIter</TT> object positioned before
the first element in the list.
<DT>See Also:
<DD><TT> ~WCValSListIter</TT>,<TT> operator ()</TT>,<TT> operator ++</TT>,<TT> operator +=</TT>,<TT> reset</TT>
</DL>
<H2 ID="WCValSListIterXTypeY____WCValSListIterLR"> ~WCValSListIter() [WCValSListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>~WCValSListIter();</TT>
<DT>Semantics:
<DD>The<TT> ~WCValSListIter</TT> public member function is the destructor for the class.&nbsp; The call to the<TT> ~WCValSListIter</TT>
public member function is inserted implicitly by the compiler at the point where the<TT> WCValSListIter</TT> object goes out
of scope.
<DT>Results:
<DD>The<TT> WCValSListIter</TT> object is destroyed.
<DT>See Also:
<DD><TT> WCValSListIter</TT>
</DL>
<H2 ID="WCValDListIterXTypeY__WCValDListIterLR"> WCValDListIter() [WCValDListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCValDListIter();</TT>
<DT>Semantics:
<DD>The<TT> WCValDListIter</TT> public member function is the default constructor for the class and initializes the iterator with
no list to operate on.&nbsp; The<TT> reset</TT> member function must be called to provide the iterator with a list to iterate
over.
<DT>Results:
<DD>The<TT> WCValDListIter</TT> public member function creates an initialized<TT> WCValDListIter</TT> object.
<DT>See Also:
<DD><TT> WCValDListIter</TT>,<TT> ~WCValDListIter</TT>,<TT> reset</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCValDListIter( WCValDList&lt;Type&gt; &amp; );</TT>
<DT>Semantics:
<DD>The<TT> WCValDListIter</TT> public member function is a constructor for the class.&nbsp; The value passed as a parameter is
the<TT> WCValDList</TT> list object.&nbsp; The iterator will be initialized for that list object and positioned before the
first list element.&nbsp; To position the iterator to a valid element within the list, increment it using any of the<TT> operator
++, operator (),</TT> or<TT> operator +=</TT> operators.
<DT>Results:
<DD>The<TT> WCValDListIter</TT> public member function creates an initialized<TT> WCValDListIter</TT> object positioned before
the first list element.
<DT>See Also:
<DD><TT> WCValDListIter</TT>,<TT> ~WCValDListIter</TT>,<TT> operator ()</TT>,<TT> operator ++</TT>,<TT> operator +=</TT>,<TT>
reset</TT>
</DL>
<H2 ID="WCValDListIterXTypeY____WCValDListIterLR"> ~WCValDListIter() [WCValDListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>~WCValDListIter();</TT>
<DT>Semantics:
<DD>The<TT> ~WCValDListIter</TT> public member function is the destructor for the class.&nbsp; The call to the<TT> ~WCValDListIter</TT>
public member function is inserted implicitly by the compiler at the point where the<TT> WCValDListIter</TT> object goes out
of scope.
<DT>Results:
<DD>The<TT> WCValDListIter</TT> object is destroyed.
<DT>See Also:
<DD><TT> WCValDListIter</TT>
</DL>
<H2 ID="WCValSListIterXTypeY__appendLR__WCValDListIterXTypeY__appendLR"> append() [WCValSListIter&lt;Type&gt;,WCValDListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int append( Type &amp; );</TT>
<DT>Semantics:
<DD>The<TT> append</TT> public member function inserts a new element into the list container object.&nbsp; The new element is
inserted after the current iterator item.
<BR><BR>If the iterator is not associated with a list, or the iterator position is either before the first element or past
the last element in the list, the current iterator position is undefined.&nbsp; The element is not appended.&nbsp; If the<TT>
undef_iter</TT> exception is enabled, it is thrown.
<BR><BR>If the append fails, the<TT> out_of_memory</TT> exception is thrown, if enabled in the list being iterated over.&nbsp;
The list remains unchanged.
<DT>Results:
<DD>The new element is inserted after the current iterator item.&nbsp; A TRUE value (non-zero) is returned if the append is successful.
&nbsp;A FALSE (zero) result is returned if the append fails.
<DT>See Also:
<DD><TT> insert</TT>,<TT> WCExcept::out_of_memory</TT>,<TT> WCIterExcept::undef_iter</TT>
</DL>
<H2 ID="WCValSListIterXTypeY_WCValDListIterXTypeY__containerLR"> container() [WCValSListIter&lt;Type&gt;,WCValDListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCValSList&lt;Type&gt; *WCValSListIter&lt;Type&gt;::container() const;</TT>
<BR><TT> WCValDList&lt;Type&gt; *WCValDListIter&lt;Type&gt;::container() const;</TT>
<DT>Semantics:
<DD>The<TT> container</TT> public member function returns a pointer to the list container object.&nbsp; If the iterator has not
been initialized with a list object, and the<TT> undef_iter</TT> exception is enabled, the exception is thrown.
<DT>Results:
<DD>A pointer to the list object associated with the iterator is returned, or NULL(0) if the iterator has not been initialized
with a list.
<DT>See Also:
<DD><TT> WCValSListIter</TT>,<TT> WCValDListIter</TT>,<TT> reset</TT>,<TT> WCIterExcept::undef_iter</TT>
</DL>
<H2 ID="WCValSListIterXTypeY__currentLR__WCValDListIterXTypeY__currentLR"> current() [WCValSListIter&lt;Type&gt;,WCValDListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Type current();</TT>
<DT>Semantics:
<DD>The<TT> current</TT> public member function returns the value of the list element at the current iterator position.
<BR><BR>If the iterator is not associated with a list, or the iterator position is either before the first element or past
the last element in the list, the current iterator position is undefined.&nbsp; In this case the<TT> undef_item</TT> exception
is thrown, if enabled.
<DT>Results:
<DD>The value at the current iterator element is returned.&nbsp; If the current element is undefined, a default initialized object
is returned.
<DT>See Also:
<DD><TT> operator ()</TT>,<TT> operator ++</TT>,<TT> operator +=</TT>,<TT> operator --</TT>,<TT> operator -=</TT>,<TT> reset</TT>,<TT>
WCIterExcept::undef_item</TT>
</DL>
<H2 ID="WCValDListIterXTypeY__insertLR"> insert() [WCValDListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int insert( Type &amp; );</TT>
<DT>Semantics:
<DD>The<TT> insert</TT> public member function inserts a new element into the list container object.&nbsp; The new element is
inserted before the current iterator item.&nbsp; This process uses the previous link in the double linked list, so the<TT>
insert</TT> public member function is not allowed with single linked lists.
<BR><BR>If the iterator is not associated with a list, or the iterator position is either before the first element or past
the last element in the list, the current iterator position is undefined.&nbsp; The element is not inserted.&nbsp; If the<TT>
undef_iter</TT> exception is enabled, the exception is thrown.
<BR><BR>If the insert fails and the<TT> out_of_memory</TT> exception is enabled in the list being iterated over, the exception
is thrown.&nbsp; The list remains unchanged.
<DT>Results:
<DD>The new element is inserted before the current iterator item.&nbsp; A TRUE value (non-zero) is returned if the insert is successful.
&nbsp;A FALSE (zero) result is returned if the insert fails.
<DT>See Also:
<DD><TT> append</TT>,<TT> WCExcept::out_of_memory</TT>,<TT> WCIterExcept::undef_iter</TT>
</DL>
<H2 ID="WCValSListIterXTypeY_WCValDListIterXTypeY__operator_LRLR"> operator ()() [WCValSListIter&lt;Type&gt;,WCValDListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int operator ()();</TT>
<DT>Semantics:
<DD>The<TT> operator ()</TT> public member function is the call operator for the class.&nbsp; The list element which follows the
current item is set to be the new current item.&nbsp; If the previous current item was the last element in the list, the iterator
is positioned after the end of the list.
<BR><BR>The<TT> operator ()</TT> public member function has the same semantics as the pre-increment operator,<TT> operator
++.</TT>
<BR><BR>If the iterator was positioned before the first element in the list, the current item will be set to the first element
in the list.&nbsp; If the list is empty, the iterator will be positioned after the end of the list.
<BR><BR>If the iterator is not associated with a list or the iterator position before the increment was past the last element
the list, the<TT> undef_iter</TT> exception is thrown, if enabled.
<DT>Results:
<DD>The<TT> operator ()</TT> public member function returns a non-zero value if the iterator is positioned on a list item.&nbsp;
Zero(0) is returned when the iterator is incremented past the end of the list.
<DT>See Also:
<DD><TT> operator ++</TT>,<TT> operator +=</TT>,<TT> operator --</TT>,<TT> operator -=</TT>,<TT> reset</TT>,<TT> WCIterExcept::undef_iter</TT>
</DL>
<H2 ID="WCValSListIterXTypeY_WCValDListIterXTypeY__operator_PPLR"> operator ++() [WCValSListIter&lt;Type&gt;,WCValDListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int operator ++();</TT>
<DT>Semantics:
<DD>The<TT> operator ++</TT> public member function is the pre-increment operator for the class.&nbsp; The list element which
follows the current item is set to be the new current item.&nbsp; If the previous current item was the last element in the
list, the iterator is positioned after the end of the list.
<BR><BR>The<TT> operator ++</TT> public member function has the same semantics as the call operator,<TT> operator ().</TT>
<BR><BR>If the iterator was positioned before the first element in the list, the current item will be set to the first element
in the list.&nbsp; If the list is empty, the iterator will be positioned after the end of the list.
<BR><BR>If the iterator is not associated with a list or the iterator position before the increment was past the last element
the list, the<TT> undef_iter</TT> exception is thrown, if enabled.
<DT>Results:
<DD>The<TT> operator ++</TT> public member function returns a non-zero value if the iterator is positioned on a list item.&nbsp;
Zero(0) is returned when the iterator is incremented past the end of the list.
<DT>See Also:
<DD><TT> current</TT>,<TT> operator ()</TT>,<TT> operator +=</TT>,<TT> operator --</TT>,<TT> operator -=</TT>,<TT> reset</TT>,<TT>
WCIterExcept::undef_iter</TT>
</DL>
<H2 ID="WCValSListIterXTypeY_WCValDListIterXTypeY__operator_PELR"> operator +=() [WCValSListIter&lt;Type&gt;,WCValDListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int operator +=( int );</TT>
<DT>Semantics:
<DD>The<TT> operator +=</TT> public member function accepts an integer value that causes the iterator to move that many elements
after the current item.&nbsp; If the iterator was positioned before the first element in the list, the operation will set
the current item to be the given element in the list.
<BR><BR>If the current item was after the last element in the list previous to the iteration, and the<TT> undef_iter</TT>
exception is enabled, the exception will be thrown.&nbsp; Attempting to increment the iterator position more than element
after the end of the list, or by less than one element causes the<TT> iter_range</TT> exception to be thrown, if enabled.
<DT>Results:
<DD>The<TT> operator +=</TT> public member function returns a non-zero value if the iterator is positioned on a list item.&nbsp;
Zero(0) is returned when the iterator is incremented past the end of the list.
<DT>See Also:
<DD><TT> current</TT>,<TT> operator ()</TT>,<TT> operator ++</TT>,<TT> operator --</TT>,<TT> operator -=</TT>,<TT> reset</TT>,<TT>
WCIterExcept::iter_range</TT>,<TT> WCIterExcept::undef_iter</TT>
</DL>
<H2 ID="WCValDListIterXTypeY__operator_MMLR"> operator --() [WCValDListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int operator --();</TT>
<DT>Semantics:
<DD>The<TT> operator --</TT> public member function is the pre-decrement operator for the class.&nbsp; The list element previous
to the current item is set to be the new current item.&nbsp; If the current item was the first element in the list, the iterator
is positioned before the first element in the list.&nbsp; If the list is empty, the iterator will be positioned before the
start of the list.
<BR><BR>If the iterator was positioned after the last element in the list, the current item will be set to the last element.
<BR><BR>If the iterator is not associated with a list or the iterator position previous to the decrement was before the first
element the list, the<TT> undef_iter</TT> exception is thrown, if enabled.
<DT>Results:
<DD>The<TT> operator --</TT> public member function returns a non-zero value if the iterator is positioned on a list item.&nbsp;
Zero(0) is returned when the iterator is decremented past the first element of the list.
<DT>See Also:
<DD><TT> current</TT>,<TT> operator ()</TT>,<TT> operator ++</TT>,<TT> operator +=</TT>,<TT> operator -=</TT>,<TT> reset</TT>,<TT>
WCIterExcept::undef_iter</TT>
</DL>
<H2 ID="WCValDListIterXTypeY__operator_MELR"> operator -=() [WCValDListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int operator -=( int );</TT>
<DT>Semantics:
<DD>The<TT> operator -=</TT> public member function accepts an integer value that causes the iterator to move that many elements
before the current item.&nbsp; If the iterator was positioned after the last element in the list, the operation will set the
current item to be the given number of elements from the end of the list.
<BR><BR>If the current item was before the first element in the list previous to the iteration, and the<TT> undef_iter</TT>
exception is enabled, the exception will be thrown.&nbsp; Attempting to decrement the iterator position more than one element
before the beginning of the list, or by less than one element causes the<TT> iter_range</TT> exception to be thrown, if enabled.
<DT>Results:
<DD>The<TT> operator -=</TT> public member function returns a non-zero value if the iterator is positioned on a list item.&nbsp;
Zero(0) is returned when the iterator is decremented past the first element in the list.
<DT>See Also:
<DD><TT> current</TT>,<TT> operator ()</TT>,<TT> operator ++</TT>,<TT> operator +=</TT>,<TT> operator --</TT>,<TT> reset</TT>,<TT>
WCIterExcept::iter_range</TT>,<TT> WCIterExcept::undef_iter</TT>
</DL>
<H2 ID="WCValSListIterXTypeY__resetLR__WCValDListIterXTypeY__resetLR"> reset() [WCValSListIter&lt;Type&gt;,WCValDListIter&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void reset();</TT>
<DT>Semantics:
<DD>The<TT> reset</TT> public member function resets the iterator to the initial state, positioning the iterator before the first
element in the associated list.
<DT>Results:
<DD>The iterator is positioned before the first list element.
<DT>See Also:
<DD><TT> WCValSListIter</TT>,<TT> WCValDListIter</TT>,<TT> container</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wclistit.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void WCValSListIter&lt;Type&gt;::reset( WCValSList&lt;Type&gt; &amp; );</TT>
<BR><TT> void WCValDListIter&lt;Type&gt;::reset( WCValDList&lt;Type&gt; &amp; );</TT>
<DT>Semantics:
<DD>The<TT> reset</TT> public member function resets the iterator to operate on the specified list.&nbsp; The iterator is positioned
before the first element in the list.
<DT>Results:
<DD>The iterator is positioned before the first element of the specified list.
<DT>See Also:
<DD><TT> WCValSListIter</TT>,<TT> WCValDListIter</TT>,<TT> container</TT>
</DL>
<H1 ID="Queue_Container"> Queue Container </H1>
<BR>Queue containers maintain an ordered collection of data which is retrieved in the order in which the data was entered
into the queue.&nbsp; The queue class is implemented as a templated class, allowing the use of any data type as the queue
data.
<BR><BR>A second template parameter specifies the storage class used to implement the queue.&nbsp; The<TT> WCValSList, WCIsvSList</TT>
and<TT> WCPtrSList</TT> classes are appropriate storage classes.
<H2 ID="WCQueueXType_FTypeY_Class_Description"> WCQueue&lt;Type,FType&gt; Class Description </H2>
<DL>
<DT>Declared:
<DD><TT> wcqueue.h</TT>
<BR><BR>The<TT> WCQueue&lt;Type,FType&gt;</TT> class is a templated class used to create objects which maintain data in a
queue.
<BR>In the description of each member function, the text<TT> Type</TT> is used to indicate the template parameter defining
the type of the elements stored in the queue.&nbsp; The text<TT> FType</TT> is used to indicate the template parameter defining
the storage class used to maintain the queue.
<BR><BR>For example, to create a queue of integers, the<TT> WCQueue&lt;int,WCValSList&lt;int&gt; &gt;</TT> class can be used.
&nbsp;The<TT> WCQueue&lt;int *,WCPtrSList&lt;int&gt; &gt;</TT> class will create a queue of pointers to integers.&nbsp; To
create an intrusive queue of objects of type<B> isv_link</B> (derived from the<TT> WCSLink</TT> class), the<TT> WCQueue&lt;</TT><B>
isv_link</B><TT> *,WCIsvSList&lt;</TT><B> isv_link</B><TT> &gt; &gt;</TT> class can be used.
<BR><BR>The<TT> WCExcept</TT> class is a base class of the<TT> WCQueue&lt;Type,FType&gt;</TT> class and provides the<TT> exceptions</TT>
member function.&nbsp; This member function controls the exceptions which can be thrown by the<TT> WCQueue&lt;Type,FType&gt;</TT>
object.&nbsp; No exceptions are enabled unless they are set by the<TT> exceptions</TT> member function.
<BR><BR><B>Requirements of Type</B>
<BR><BR><TT>Type</TT> must provide any constructors and/or operators required by the<TT> FType</TT> class.
<BR><BR><B>Public Member Functions</B>
<BR><BR>The following member functions are declared in the public interface:
<BR><BR><TT>WCQueue();</TT>
<BR><TT> WCQueue( void *(*)( size_t ), void (*)( void *, size_t ) );</TT>
<BR><TT> ~WCQueue();</TT>
<BR><TT> void clear();</TT>
<BR><TT> int entries() const;</TT>
<BR><TT> Type first() const;</TT>
<BR><TT> Type get();</TT>
<BR><TT> int insert( const Type &amp; );</TT>
<BR><TT> int isEmpty() const;</TT>
<BR><TT> Type last() const;</TT>
<BR><BR><B>Sample Program Using a Queue</B>
<BR><BR><TT>#include &lt;wcqueue.h&gt;</TT>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><BR><TT>main() {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; WCQueue&lt;int,WCValSList&lt;int&gt; &gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; queue;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; queue.insert( 7 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; queue.insert( 8 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; queue.insert( 9 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; queue.insert( 10 );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; cout &lt;&lt; &quot;\nNumber of queue entries: &quot; &lt;&lt; queue.entries() &lt;&lt; &quot;\n&quot;;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; cout &lt;&lt; &quot;First entry = [&quot; &lt;&lt; queue.first() &lt;&lt; &quot;]\n&quot;;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; cout &lt;&lt; &quot;Last entry = [&quot; &lt;&lt; queue.last() &lt;&lt; &quot;]\n&quot;;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; while( !queue.isEmpty() ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; queue.get() &lt;&lt; &quot;\n&quot;;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; cout.flush();</TT>
<BR><TT>}</TT>
</DL>
<H2 ID="WCQueueXType_FTypeY__WCQueueLR"> WCQueue() [WCQueue&lt;Type,FType&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcqueue.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCQueue();</TT>
<DT>Semantics:
<DD>The public<TT> WCQueue&lt;Type,FType&gt;</TT> constructor creates an empty<TT> WCQueue&lt;Type,FType&gt;</TT> object.&nbsp;
The<TT> FType</TT> storage class constructor performs the initialization.
<DT>Results:
<DD>The public<TT> WCQueue&lt;Type,FType&gt;</TT> constructor creates an initialized<TT> WCQueue&lt;Type,FType&gt;</TT> object.
<DT>See Also:
<DD><TT> ~WCQueue&lt;Type,FType&gt;</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcqueue.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCQueue( void *(*allocator)( size_t ),</TT>
<BR><TT> void (*deallocator)( void *, size_t ) );</TT>
<DT>Semantics:
<DD>The public<TT> WCQueue&lt;Type,FType&gt;</TT> constructor creates an empty<TT> WCQueue&lt;Type,FType&gt;</TT> object.&nbsp;
If<TT> FType</TT> is either the<TT> WCValSList</TT> or<TT> WCPtrSList</TT> class, then the<B> allocator</B> function is registered
to perform all memory allocations of the queue elements, and the<B> deallocator</B> function to perform all freeing of the
queue elements' memory.&nbsp; The<B> allocator</B> and<B> deallocator</B> functions are ignored if<TT> FType</TT> is the<TT>
WCIsvSList</TT> class.&nbsp; These functions provide the ability to control how the allocation and freeing of memory is performed,
allowing for more efficient memory handling than the general purpose global<TT> operator new()</TT> and<TT> operator delete()</TT>
can provide.&nbsp; Memory management optimizations may potentially be made through the<B> allocator</B> and<B> deallocator</B>
functions, but are not recommended before managing memory is understood and determined to be worth while.
<BR><BR>The<B> allocator</B> function shall return a pointer to allocated memory of size at least the argument, or zero(0)
if the allocation cannot be performed.&nbsp; Initialization of the memory returned is performed by the<TT> WCQueue&lt;Type,FType&gt;</TT>
class.
<BR><BR>The<TT> WCQueue&lt;Type,FType&gt;</TT> class calls the<B> deallocator</B> function only on memory allocated by the<B>
allocator</B> function.&nbsp; The<B> deallocator</B> shall free the memory pointed to by the first argument which is of size
the second argument.&nbsp; The size passed to the<B> deallocator</B> function is guaranteed to be the same size passed to
the<B> allocator</B> function when the memory was allocated.
<BR><BR>The<B> allocator</B> and<B> deallocator</B> functions may assume that for a list object instance, the<B> allocator</B>
is always called with the same first argument (the size of the memory to be allocated).&nbsp; If<TT> FType</TT> is the<TT>
WCValSList&lt;Type&gt;</TT> class, then the<TT> WCValSListItemSize( Type )</TT> macro returns the size of the elements which
are allocated by the<B> allocator</B> function.&nbsp; Similarly, the<TT> WCPtrSListItemSize( Type )</TT> macro returns the
size of<TT> WCPtrSList&lt;Type&gt;</TT> elements.
<BR><BR>The<TT> FType</TT> storage class constructor performs the initialization of the queue.
<DT>Results:
<DD>The public<TT> WCQueue&lt;Type,FType&gt;</TT> constructor creates an initialized<TT> WCQueue&lt;Type,FType&gt;</TT> object
and registers the<B> allocator</B> and<B> deallocator</B> functions.
<DT>See Also:
<DD><TT> WCQueue&lt;Type,FType&gt;</TT>,<TT> ~WCQueue&lt;Type,FType&gt;</TT>
</DL>
<H2 ID="WCQueueXType_FTypeY____WCQueueLR"> ~WCQueue() [WCQueue&lt;Type,FType&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcqueue.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>virtual ~WCQueue();</TT>
<DT>Semantics:
<DD>The public<TT> ~WCQueue&lt;Type,FType&gt;</TT> destructor destroys the<TT> WCQueue&lt;Type,FType&gt;</TT> object.&nbsp; The<TT>
FType</TT> storage class destructor performs the destruction.&nbsp; The call to the public<TT> ~WCQueue&lt;Type,FType&gt;</TT>
destructor is inserted implicitly by the compiler at the point where the<TT> WCQueue&lt;Type,FType&gt;</TT> object goes out
of scope.
<BR><BR>If the<TT> not_empty</TT> exception is enabled, the exception is thrown if the queue is not empty of queue elements.
<DT>Results:
<DD>The<TT> WCQueue&lt;Type,FType&gt;</TT> object is destroyed.
<DT>See Also:
<DD><TT> WCQueue&lt;Type,FType&gt;</TT>,<TT> clear</TT>,<TT> WCExcept::not_empty</TT>
</DL>
<H2 ID="WCQueueXType_FTypeY__clearLR"> clear() [WCQueue&lt;Type,FType&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcqueue.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void clear();</TT>
<DT>Semantics:
<DD>The<TT> clear</TT> public member function is used to clear the queue object and set it to the state of the object just after
the initial construction.&nbsp; The queue object is not destroyed and re-created by this operator, so the object destructor
is not invoked.&nbsp; The queue elements are not cleared by the queue class.&nbsp; However, the class used to maintain the
queue,<TT> FType,</TT> may clear the items as part of the clear function for that class.&nbsp; If it does not clear the items,
any queue items still in the list are lost unless pointed to by some pointer object in the program code.
<DT>Results:
<DD>The<TT> clear</TT> public member function resets the queue object to the state of the object immediately after the initial
construction.
<DT>See Also:
<DD><TT> ~WCQueue&lt;Type,FType&gt;</TT>,<TT> isEmpty</TT>
</DL>
<H2 ID="WCQueueXType_FTypeY__entriesLR"> entries() [WCQueue&lt;Type,FType&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcqueue.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int entries() const;</TT>
<DT>Semantics:
<DD>The<TT> entries</TT> public member function is used to determine the number of queue elements contained in the list object.
<DT>Results:
<DD>The number of elements in the queue is returned.&nbsp; Zero(0) is returned if there are no queue elements.
<DT>See Also:
<DD><TT> isEmpty</TT>
</DL>
<H2 ID="WCQueueXType_FTypeY__firstLR"> first() [WCQueue&lt;Type,FType&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcqueue.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Type first() const;</TT>
<DT>Semantics:
<DD>The<TT> first</TT> public member function returns a queue element from the beginning of the queue object.&nbsp; The queue
element is not removed from the queue.
<BR><BR>If the queue is empty, one of two exceptions can be thrown.&nbsp; If the<TT> empty_container</TT> exception is enabled,
then it will be thrown.&nbsp; Otherwise, the<TT> index_range</TT> exception will be thrown, if enabled.
<DT>Results:
<DD>The first queue element is returned.&nbsp; If there are no elements in the queue, the return value is determined by the<TT>
find</TT> member function of the<TT> FType</TT> class.
<DT>See Also:
<DD><TT> get</TT>,<TT> isEmpty</TT>,<TT> last</TT>,<TT> WCExcept::empty_container</TT>,<TT> WCExcept::index_range</TT>,<TT> FType::find</TT>
</DL>
<H2 ID="WCQueueXType_FTypeY__getLR"> get() [WCQueue&lt;Type,FType&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcqueue.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Type get();</TT>
<DT>Semantics:
<DD>The<TT> get</TT> public member function returns the queue element which was first inserted into the queue object.&nbsp; The
queue element is also removed from the queue.
<BR><BR>If the queue is empty, one of two exceptions can be thrown.&nbsp; If the<TT> empty_container</TT> exception is enabled,
then it will be thrown.&nbsp; Otherwise, the<TT> index_range</TT> exception will be thrown, if enabled.
<DT>Results:
<DD>The first element in the queue is removed and returned.&nbsp; If there are no elements in the queue, the return value is determined
by the<TT> get</TT> member function of the<TT> FType</TT> class.
<DT>See Also:
<DD><TT> first</TT>,<TT> insert</TT>,<TT> isEmpty</TT>,<TT> WCExcept::empty_container</TT>,<TT> WCExcept::index_range</TT>,<TT>
FType::get</TT>
</DL>
<H2 ID="WCQueueXType_FTypeY__insertLR"> insert() [WCQueue&lt;Type,FType&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcqueue.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int insert( const Type &amp; );</TT>
<DT>Semantics:
<DD>The<TT> insert</TT> public member function is used to insert the data into the queue.&nbsp; It will be the last element in
the queue, and the last to be retrieved.
<BR><BR>If the insert fails, the<TT> out_of_memory</TT> exception will be thrown, if enabled.&nbsp; The queue will remain
unchanged.
<DT>Results:
<DD>The queue element is inserted at the end of the queue.&nbsp; A TRUE value (non-zero) is returned if the insert is successful.
&nbsp;A FALSE (zero) result is returned if the insert fails.
<DT>See Also:
<DD><TT> get</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<H2 ID="WCQueueXType_FTypeY__isEmptyLR"> isEmpty() [WCQueue&lt;Type,FType&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcqueue.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int isEmpty() const;</TT>
<DT>Semantics:
<DD>The<TT> isEmpty</TT> public member function is used to determine if a queue object has any queue elements contained in it.
<DT>Results:
<DD>A TRUE value (non-zero) is returned if the queue object does not have any queue elements contained within it.&nbsp; A FALSE
(zero) result is returned if the queue contains at least one element.
<DT>See Also:
<DD><TT> entries</TT>
</DL>
<H2 ID="WCQueueXType_FTypeY__lastLR"> last() [WCQueue&lt;Type,FType&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcqueue.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Type last() const;</TT>
<DT>Semantics:
<DD>The<TT> last</TT> public member function returns a queue element from the end of the queue object.&nbsp; The queue element
is not removed from the queue.
<BR><BR>If the queue is empty, one of two exceptions can be thrown.&nbsp; If the<TT> empty_container</TT> exception is enabled,
then it will be thrown.&nbsp; Otherwise, the<TT> index_range</TT> exception will be thrown, if enabled.
<DT>Results:
<DD>The last queue element is returned.&nbsp; If there are no elements in the queue, the return value is determined by the<TT>
find</TT> member function of the<TT> FType</TT> class.
<DT>See Also:
<DD><TT> first</TT>,<TT> get</TT>,<TT> isEmpty</TT>,<TT> WCExcept::empty_container</TT>,<TT> WCExcept::index_range</TT>,<TT> FType::find</TT>
</DL>
<H1 ID="Skip_List_Containers"> Skip List Containers </H1>
<BR>This chapter describes skip list containers.
<H2 ID="WCPtrSkipListDictXKey_ValueY_Class_Description"> WCPtrSkipListDict&lt;Key,Value&gt; Class Description </H2>
<DL>
<DT>Declared:
<DD><TT> wcskip.h</TT>
<BR><BR>The<TT> WCPtrSkipListDict&lt;Key,Value&gt;</TT> class is a templated class used to store objects in a dictionary.
&nbsp;Dictionaries store values with an associated key, which may be of any type.&nbsp; One example of a dictionary used in
everyday life is the phone book.&nbsp; The phone numbers are the data values, and the customer name is the key.&nbsp; The
equality operator of the key's type is used to locate the key-value pairs.
<BR>In the description of each member function, the text<TT> Key</TT> is used to indicate the template parameter defining
the type of the indices pointed to by the pointers stored in the dictionary.&nbsp; The text<TT> Value</TT> is used to indicate
the template parameter defining the type of the data pointed to by the pointers stored in the dictionary.
<BR><BR>Note that pointers to the key values are stored in the dictionary.&nbsp; Destructors are not called on the keys pointed
to.&nbsp; The key values pointed to in the dictionary should not be changed such that the equivalence to the old value is
modified.
<BR><BR>The iterator classes for skip lists have the same function and operator interface as the hash iterators classes.&nbsp;
See the chapter on hash iterators for more information.
<BR><BR>The<TT> WCExcept</TT> class is a base class of the<TT> WCPtrSkipListDict&lt;Key,Value&gt;</TT> class and provides
the<TT> exceptions</TT> member function.&nbsp; This member function controls the exceptions which can be thrown by the<TT>
WCPtrSkipListDict&lt;Key,Value&gt;</TT> object.&nbsp; No exceptions are enabled unless they are set by the<TT> exceptions</TT>
member function.
<BR><BR><B>Requirements of Key</B>
<BR><BR>The<TT> WCPtrSkipListDict&lt;Key,Value&gt;</TT> class requires<TT> Key</TT> to have:
<BR>A well defined equivalence operator with constant parameters
<BR><BR>(<TT> int operator ==( const Key &amp; ) const</TT> ).
<BR>A well defined operator less than with constant parameters
<BR><BR>(<TT> int operator &lt;( const Key &amp; ) const</TT> ).
<BR><BR><B>Public Member Functions</B>
<BR><BR>The following member functions are declared in the public interface:
<BR><BR><TT>WCPtrSkipListDict( unsigned = WCSkipListDict_PROB_QUARTER, unsigned = WCDEFAULT_SKIPLIST_MAX_PTRS );</TT>
<BR><TT> WCPtrSkipListDict( unsigned = WCSkipListDict_PROB_QUARTER, unsigned = WCDEFAULT_SKIPLIST_MAX_PTRS, void * (*user_alloc)(
size_t size ), void (*user_dealloc)( void *old, size_t size ) );</TT>
<BR><TT> WCPtrSkipListDict( const WCPtrSkipListDict &amp; );</TT>
<BR><TT> virtual ~WCPtrSkipListDict();</TT>
<BR><TT> void clear();</TT>
<BR><TT> void clearAndDestroy();</TT>
<BR><TT> int contains( const Key * ) const;</TT>
<BR><TT> unsigned entries() const;</TT>
<BR><TT> Value * find( const Key * ) const;</TT>
<BR><TT> Value * findKeyAndValue( const Key *, Key * &amp; ) const;</TT>
<BR><TT> void forAll( void (*user_fn)( Key *, Value *, void * ), void * );</TT>
<BR><TT> int insert( Key *, Value * );</TT>
<BR><TT> int isEmpty() const;</TT>
<BR><TT> Value * remove( const Key * );</TT>
<BR><BR><B>Public Member Operators</B>
<BR><BR>The following member operators are declared in the public interface:
<BR><BR><TT>Value * &amp; operator []( const Key * );</TT>
<BR><TT> Value * const &amp; operator []( const Key * ) const;</TT>
<BR><TT> WCPtrSkipListDict &amp; operator =( const WCPtrSkipListDict &amp; );</TT>
<BR><TT> int operator ==( const WCPtrSkipListDict &amp; ) const;</TT>
</DL>
<H2 ID="WCPtrSkipListDictXKey_ValueY__WCPtrSkipListDictLR"> WCPtrSkipListDict() [WCPtrSkipListDict&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCPtrSkipListDict( unsigned = WCSKIPLIST_PROB_QUARTER,</TT>
<BR><TT> unsigned = WCDEFAULT_SKIPLIST_MAX_PTRS );</TT>
<DT>Semantics:
<DD>The public<TT> WCPtrSkipListDict&lt;Key,Value&gt;</TT> constructor creates an<TT> WCPtrSkipListDict&lt;Key,Value&gt;</TT>
object with no entries.&nbsp; The first optional parameter, which defaults to the constant<TT> WCSKIPLIST_PROB_QUARTER,</TT>
determines the probability of having a certain number of pointers in each skip list node.&nbsp; The second optional parameter,
which defaults to the constant<TT> WCDEFAULT_SKIPLIST_MAX_PTRS,</TT> determines the maximum number of pointers that are allowed
in any skip list node.<TT>&nbsp; WCDEFAULT_SKIPLIST_MAX_PTRS</TT> is the maximum effective value of the second parameter.
&nbsp;If an allocation failure occurs while creating the skip list, the<TT> out_of_memory</TT> exception is thrown if the<TT>
out_of_memory</TT> exception is enabled.
<DT>Results:
<DD>The public<TT> WCPtrSkipListDict&lt;Key,Value&gt;</TT> constructor creates an initialized<TT> WCPtrSkipListDict&lt;Key,Value&gt;</TT>
object.
<DT>See Also:
<DD><TT> ~WCPtrSkipListDict&lt;Key,Value&gt;</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCPtrSkipListDict( unsigned = WCSKIPLIST_PROB_QUARTER,</TT>
<BR><TT> unsigned = WCDEFAULT_SKIPLIST_MAX_PTRS,</TT>
<BR><TT>void * (*user_alloc)( size_t ),</TT>
<BR><TT>void (*user_dealloc)( void *, size_t ) );</TT>
<DT>Semantics:
<DD>Allocator and deallocator functions are specified for use when entries are inserted and removed from the list dictionary.
&nbsp;The semantics of this constructor are the same as the constructor without the memory management functions.
<BR><BR>The allocation function must return a zero if it cannot perform the allocation.&nbsp; The deallocation function is
passed the size as well as the pointer to the data.&nbsp; Your allocation system may take advantage of the characteristic
that the allocation function will always be called with the same size value for any particular instantiation of a list dictionary.
&nbsp;To determine the size of the objects that the memory management functions will be required to allocate and free, the
following macro may be used:
<BR><BR><TT>WCPtrSkipListDictItemSize( Key, Value, num_of_pointers )</TT>
<DT>Results:
<DD>The public<TT> WCPtrSkipListDict&lt;Key,Value&gt;</TT> constructor creates an initialized<TT> WCPtrSkipListDict&lt;Key,Value&gt;</TT>
object.
<DT>See Also:
<DD><TT> ~WCPtrSkipListDict&lt;Key,Value&gt;</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCPtrSkipListDict( const WCPtrSkipListDict &amp; );</TT>
<DT>Semantics:
<DD>The public<TT> WCPtrSkipListDict&lt;Key,Value&gt;</TT> constructor is the copy constructor for the<TT> WCPtrSkipListDict&lt;Key,Value&gt;</TT>
class.&nbsp; The new skip list is created with the same probability and maximum pointers, all values or pointers stored in
the list, and the exception trap states.&nbsp; If there is not enough memory to copy all of the values, then only some will
be copied, and the number of entries will correctly reflect the number copied.&nbsp; If all of the elements cannot be copied,
then the<TT> out_of_memory</TT> exception is thrown if it is enabled.
<DT>Results:
<DD>The public<TT> WCPtrSkipListDict&lt;Key,Value&gt;</TT> constructor creates an<TT> WCPtrSkipListDict&lt;Key,Value&gt;</TT>
object which is a copy of the passed dictionary.
<DT>See Also:
<DD><TT> operator =</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<H2 ID="WCPtrSkipListDictXKey_ValueY____WCPtrSkipListDictLR"> ~WCPtrSkipListDict() [WCPtrSkipListDict&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>virtual ~WCPtrSkipListDict();</TT>
<DT>Semantics:
<DD>The public<TT> ~WCPtrSkipListDict&lt;Key,Value&gt;</TT> destructor is the destructor for the<TT> WCPtrSkipListDict&lt;Key,Value&gt;</TT>
class.&nbsp; If the number of dictionary elements is not zero and the<TT> not_empty</TT> exception is enabled, the exception
is thrown.&nbsp; Otherwise, the dictionary elements are cleared using the<TT> clear</TT> member function.&nbsp; The objects
which the dictionary elements point to are not deleted unless the<TT> clearAndDestroy</TT> member function is explicitly called
before the destructor is called.&nbsp; The call to the public<TT> ~WCPtrSkipListDict&lt;Key,Value&gt;</TT> destructor is inserted
implicitly by the compiler at the point where the<TT> WCPtrSkipListDict&lt;Key,Value&gt;</TT> object goes out of scope.
<DT>Results:
<DD>The public<TT> ~WCPtrSkipListDict&lt;Key,Value&gt;</TT> destructor destroys an<TT> WCPtrSkipListDict&lt;Key,Value&gt;</TT>
object.
<DT>See Also:
<DD><TT> clear</TT>,<TT> clearAndDestroy</TT>,<TT> WCExcept::not_empty</TT>
</DL>
<H2 ID="WCPtrSkipListDictXKey_ValueY__clearLR"> clear() [WCPtrSkipListDict&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void clear();</TT>
<DT>Semantics:
<DD>The<TT> clear</TT> public member function is used to clear the dictionary so that it has no entries.&nbsp; Objects pointed
to by the dictionary elements are not deleted.&nbsp; The dictionary object is not destroyed and re-created by this function,
so the object destructor is not invoked.
<DT>Results:
<DD>The<TT> clear</TT> public member function clears the dictionary to have no elements.
<DT>See Also:
<DD><TT> ~WCPtrSkipListDict&lt;Key,Value&gt;</TT>,<TT> clearAndDestroy</TT>,<TT> operator =</TT>
</DL>
<H2 ID="WCPtrSkipListDictXKey_ValueY__clearAndDestroyLR"> clearAndDestroy() [WCPtrSkipListDict&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void clearAndDestroy();</TT>
<DT>Semantics:
<DD>The<TT> clearAndDestroy</TT> public member function is used to clear the dictionary and delete the objects pointed to by the
dictionary elements.&nbsp; The dictionary object is not destroyed and re-created by this function, so the dictionary object
destructor is not invoked.
<DT>Results:
<DD>The<TT> clearAndDestroy</TT> public member function clears the dictionary by deleting the objects pointed to by the dictionary
elements.
<DT>See Also:
<DD><TT> clear</TT>
</DL>
<H2 ID="WCPtrSkipListDictXKey_ValueY__containsLR"> contains() [WCPtrSkipListDict&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int contains( const Key * ) const;</TT>
<DT>Semantics:
<DD>The<TT> contains</TT> public member function returns non-zero if an element with the specified key is stored in the dictionary,
or zero if there is no equivalent element.&nbsp; Note that equivalence is based on the equivalence operator of the<TT> Key</TT>
type.
<DT>Results:
<DD>The<TT> contains</TT> public member function returns a non-zero value if the<TT> Key</TT> is found in the dictionary.
<DT>See Also:
<DD><TT> find</TT>,<TT> findKeyAndValue</TT>
</DL>
<H2 ID="WCPtrSkipListDictXKey_ValueY__entriesLR"> entries() [WCPtrSkipListDict&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>unsigned entries() const;</TT>
<DT>Semantics:
<DD>The<TT> entries</TT> public member function is used to return the current number of elements stored in the dictionary.
<DT>Results:
<DD>The<TT> entries</TT> public member function returns the number of elements in the dictionary.
<DT>See Also:
<DD><TT> isEmpty</TT>
</DL>
<H2 ID="WCPtrSkipListDictXKey_ValueY__findLR"> find() [WCPtrSkipListDict&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Value * find( const Key * ) const;</TT>
<DT>Semantics:
<DD>The<TT> find</TT> public member function is used to find an element with an equivalent key in the dictionary.&nbsp; If an
equivalent element is found, a pointer to the element<TT> Value</TT> is returned.&nbsp; Zero is returned if the element is
not found.&nbsp; Note that equivalence is based on the equivalence operator of the<TT> Key</TT> type.
<DT>Results:
<DD>The element equivalent to the passed key is located in the dictionary.
<DT>See Also:
<DD><TT> findKeyAndValue</TT>
</DL>
<H2 ID="WCPtrSkipListDictXKey_ValueY__findKeyAndValueLR"> findKeyAndValue() [WCPtrSkipListDict&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Value * findKeyAndValue( const Key *, Key * &amp; ) const;</TT>
<DT>Semantics:
<DD>The<TT> findKeyAndValue</TT> public member function is used to find an element in the dictionary with an key equivalent to
the first parameter.&nbsp; If an equivalent element is found, a pointer to the element<TT> Value</TT> is returned.&nbsp; The
reference to a<TT> Key</TT> passed as the second parameter is assigned the found element's key.&nbsp; Zero is returned if
the element is not found.&nbsp; Note that equivalence is based on the equivalence operator of the<TT> Key</TT> type.
<DT>Results:
<DD>The element equivalent to the passed key is located in the dictionary.
<DT>See Also:
<DD><TT> findKeyAndValue</TT>
</DL>
<H2 ID="WCPtrSkipListDictXKey_ValueY__forAllLR"> forAll() [WCPtrSkipListDict&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void forAll(</TT>
<BR><TT> void (*user_fn)( Key *, Value *, void * ),</TT>
<BR><TT>void * );</TT>
<DT>Semantics:
<DD>The<TT> forAll</TT> public member function causes the user supplied function to be invoked for every key-value pair in the
dictionary.&nbsp; The user function has the prototype
<BR><BR><TT>void user_func( Key * key, Value * value, void * data );</TT>
<BR><BR>As the elements are visited, the user function is invoked with the<TT> Key</TT> and<TT> Value</TT> components of the
element passed as the first two parameters.&nbsp; The second parameter of the<TT> forAll</TT> function is passed as the third
parameter to the user function.&nbsp; This value can be used to pass any appropriate data from the main code to the user function.
<DT>Results:
<DD>The elements in the dictionary are all visited, with the user function being invoked for each one.
<DT>See Also:
<DD><TT> find</TT>,<TT> findKeyAndValue</TT>
</DL>
<H2 ID="WCPtrSkipListDictXKey_ValueY__insertLR"> insert() [WCPtrSkipListDict&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int insert( Key *, Value * );</TT>
<DT>Semantics:
<DD>The<TT> insert</TT> public member function inserts a key and value into the dictionary.&nbsp; If allocation of the node to
store the key-value pair fails, then the<TT> out_of_memory</TT> exception is thrown if it is enabled.&nbsp; If the exception
is not enabled, the insert will not be completed.
<DT>Results:
<DD>The<TT> insert</TT> public member function inserts a key and value into the dictionary.&nbsp; If the insert is successful,
a non-zero will returned.&nbsp; A zero will be returned if the insert fails.
<DT>See Also:
<DD><TT> operator =</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<H2 ID="WCPtrSkipListDictXKey_ValueY__isEmptyLR"> isEmpty() [WCPtrSkipListDict&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int isEmpty() const;</TT>
<DT>Semantics:
<DD>The<TT> isEmpty</TT> public member function is used to determine if the dictionary is empty.
<DT>Results:
<DD>The<TT> isEmpty</TT> public member function returns zero if it contains at least one entry, non-zero if the dictionary is
empty.
<DT>See Also:
<DD><TT> entries</TT>
</DL>
<H2 ID="WCPtrSkipListDictXKey_ValueY__operator_UVLR"> operator []() [WCPtrSkipListDict&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Value * &amp; operator[]( const Key * );</TT>
<DT>Semantics:
<DD><TT> operator []</TT> is the dictionary index operator.&nbsp; A reference to the object stored in the dictionary with the
given<TT> Key</TT> is returned.&nbsp; If no equivalent element is found, then a new key-value pair is created with the specified<TT>
Key</TT> value, and initialized with the default constructor.&nbsp; The returned reference can then be assigned to, so that
insertions can be made with the operator.&nbsp; If an allocation error occurs while inserting a new key-value pair, then the<TT>
out_of_memory</TT> exception is thrown if it is enabled.&nbsp; If the exception is not enabled, then a reference to address
zero will be returned.&nbsp; This will result in a run-time error on systems which trap address zero references.
<DT>Results:
<DD>The<TT> operator []</TT> public member function returns a reference to the element at the given key value.&nbsp; If the key
does not exist, a reference to a created element is returned.&nbsp; The result of the operator may be assigned to.
<DT>See Also:
<DD><TT> WCExcept::out_of_memory</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Value * const &amp; operator[]( const Key * ) const;</TT>
<DT>Semantics:
<DD><TT> operator []</TT> is the dictionary index operator.&nbsp; A constant reference to the object stored in the dictionary
with the given<TT> Key</TT> is returned.&nbsp; If no equivalent element is found, then the<TT> index_range</TT> exception
is thrown if it is enabled.&nbsp; If the exception is not enabled, then a reference to address zero will be returned.&nbsp;
This will result in a run-time error on systems which trap address zero references.
<DT>Results:
<DD>The<TT> operator []</TT> public member function returns a constant reference to the element at the given key value.&nbsp;
The result of the operator may not be assigned to.
<DT>See Also:
<DD><TT> WCExcept::index_range</TT>
</DL>
<H2 ID="WCPtrSkipListDictXKey_ValueY__operator_ELR"> operator =() [WCPtrSkipListDict&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCPtrSkipListDict &amp; operator =( const WCPtrSkipListDict &amp; );</TT>
<DT>Semantics:
<DD>The<TT> operator =</TT> public member function is the assignment operator for the<TT> WCPtrSkipListDict&lt;Key,Value&gt;</TT>
class.&nbsp; The left hand side dictionary is first cleared using the<TT> clear</TT> member function, and then the right hand
side dictionary is copied.&nbsp; The new skip list is created with the same probability and maximum pointers, all values or
pointers stored in the list, and the exception trap states.&nbsp; If there is not enough memory to copy all of the values
or pointers in the dictionary, then only some will be copied, and the<TT> out_of_memory</TT> exception is thrown if it is
enabled.&nbsp; The number of entries will correctly reflect the number copied.
<DT>Results:
<DD>The<TT> operator =</TT> public member function assigns the left hand side dictionary to be a copy of the right hand side.
<DT>See Also:
<DD><TT> clear</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<H2 ID="WCPtrSkipListDictXKey_ValueY__operator_EELR"> operator ==() [WCPtrSkipListDict&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int operator ==( const WCPtrSkipListDict &amp; ) const;</TT>
<DT>Semantics:
<DD>The<TT> operator ==</TT> public member function is the equivalence operator for the<TT> WCPtrSkipListDict&lt;Key,Value&gt;</TT>
class.&nbsp; Two dictionary objects are equivalent if they are the same object and share the same address.
<DT>Results:
<DD>A TRUE (non-zero) value is returned if the left hand side and right hand side dictionary are the same object.&nbsp; A FALSE
(zero) value is returned otherwise.
</DL>
<H2 ID="WCPtrSkipListDictXKey_ValueY__removeLR"> remove() [WCPtrSkipListDict&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Value * remove( const Key * );</TT>
<DT>Semantics:
<DD>The<TT> remove</TT> public member function is used to remove the specified element from the dictionary.&nbsp; If an equivalent
element is found, the pointer value is returned.&nbsp; Zero is returned if the element is not found.&nbsp; Note that equivalence
is based on the equivalence operator of the<TT> Key</TT> type.
<DT>Results:
<DD>The element is removed from the dictionary if it found.
</DL>
<H2 ID="WCPtrSkipListXTypeY__WCPtrSkipListSetXTypeY_Class_Description"> WCPtrSkipList&lt;Type&gt;, WCPtrSkipListSet&lt;Type&gt; Class Description </H2>
<DL>
<DT>Declared:
<DD><TT> wcskip.h</TT>
<BR><BR><TT>WCPtrSkipList&lt;Type&gt;</TT> and<TT> WCPtrSkipListSet&lt;Type&gt;</TT> classes are templated classes used to
store objects in a skip list.&nbsp; A skip list is a probabilistic alternative to balanced trees, and provides a reasonable
performance balance to insertion, search, and deletion.&nbsp; A skip list allows more than one copy of an element that is
equivalent, while the skip list set allows only one copy.&nbsp; The equality operator of the element's type is used to locate
the value.
<BR>In the description of each member function, the text<TT> Type</TT> is used to indicate the template parameter defining
the type of the data pointed to by the pointers stored in the list.
<BR><BR>Note that pointers to the elements are stored in the list.&nbsp; Destructors are not called on the elements pointed
to.&nbsp; The data values pointed to in the list should not be changed such that the equivalence to the old value is modified.
<BR><BR>The iterator classes for skip lists have the same function and operator interface as the hash iterators classes.&nbsp;
See the chapter on hash iterators for more information.
<BR><BR>The<TT> WCExcept</TT> class is a base class of the<TT> WCPtrSkipList&lt;Type&gt;</TT> and<TT> WCPtrSkipListSet&lt;Type&gt;</TT>
classes and provides the<TT> exceptions</TT> member function.&nbsp; This member function controls the exceptions which can
be thrown by the<TT> WCPtrSkipList&lt;Type&gt;</TT> and<TT> WCPtrSkipListSet&lt;Type&gt;</TT> objects.&nbsp; No exceptions
are enabled unless they are set by the<TT> exceptions</TT> member function.
<BR><BR><B>Requirements of Type</B>
<BR><BR>The<TT> WCPtrSkipList&lt;Type&gt;</TT> and<TT> WCPtrSkipListSet&lt;Type&gt;</TT> classes requires<TT> Type</TT> to
have:
<BR>A well defined equivalence operator
<BR><BR>(<TT> int operator ==( const Type &amp; ) const</TT> ).
<BR>A well defined less than operator
<BR><BR>(<TT> int operator &lt;( const Type &amp; ) const</TT> ).
<BR><BR><B>Public Member Functions</B>
<BR><BR>The following member functions are declared in the public interface:
<BR><BR><TT>WCPtrSkipList( unsigned = WCSKIPLIST_PROB_QUARTER, unsigned = WCDEFAULT_SKIPLIST_MAX_PTRS );</TT>
<BR><TT> WCPtrSkipList( unsigned = WCSKIPLIST_PROB_QUARTER, unsigned = WCDEFAULT_SKIPLIST_MAX_PTRS, void * (*user_alloc)(
size_t size ), void (*user_dealloc)( void *old, size_t size ) );</TT>
<BR><TT> WCPtrSkipList( const WCPtrSkipList &amp; );</TT>
<BR><TT> virtual ~WCPtrSkipList();</TT>
<BR><TT> WCPtrSkipListSet( unsigned = WCSKIPLIST_PROB_QUARTER, unsigned = WCDEFAULT_SKIPLIST_MAX_PTRS );</TT>
<BR><TT> WCPtrSkipListSet( unsigned = WCSKIPLIST_PROB_QUARTER, unsigned = WCDEFAULT_SKIPLIST_MAX_PTRS, void * (*user_alloc)(
size_t size ), void (*user_dealloc)( void *old, size_t size ) );</TT>
<BR><TT> WCPtrSkipListSet( const WCPtrSkipListSet &amp; );</TT>
<BR><TT> virtual ~WCPtrSkipListSet();</TT>
<BR><TT> void clear();</TT>
<BR><TT> void clearAndDestroy();</TT>
<BR><TT> int contains( const Type * ) const;</TT>
<BR><TT> unsigned entries() const;</TT>
<BR><TT> Type * find( const Type * ) const;</TT>
<BR><TT> void forAll( void (*user_fn)( Type *, void * ) , void * );</TT>
<BR><TT> int insert( Type * );</TT>
<BR><TT> int isEmpty() const;</TT>
<BR><TT> Type * remove( const Type * );</TT>
<BR><BR>The following public member functions are available for the<TT> WCPtrSkipList</TT> class only:
<BR><BR><TT>unsigned occurrencesOf( const Type * ) const;</TT>
<BR><TT> unsigned removeAll( const Type * );</TT>
<BR><BR><B>Public Member Operators</B>
<BR><BR>The following member operators are declared in the public interface:
<BR><BR><TT>WCPtrSkipList &amp; operator =( const WCPtrSkipList &amp; );</TT>
<BR><TT> int operator ==( const WCPtrSkipList &amp; ) const;</TT>
<BR><TT> WCPtrSkipListSet &amp; operator =( const WCPtrSkipListSet &amp; );</TT>
<BR><TT> int operator ==( const WCPtrSkipListSet &amp; ) const;</TT>
</DL>
<H2 ID="WCPtrSkipListSetXTypeY__WCPtrSkipListSetLR"> WCPtrSkipListSet() [WCPtrSkipListSet&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCPtrSkipListSet( unsigned = WCSKIPLIST_PROB_QUARTER,</TT>
<BR><TT> unsigned = WCDEFAULT_SKIPLIST_MAX_PTRS );</TT>
<DT>Semantics:
<DD>The<TT> WCPtrSkipListSet&lt;Type&gt;</TT> constructor creates a<TT> WCPtrSkipListSet</TT> object with no entries.&nbsp; The
first optional parameter, which defaults to the constant<TT> WCSKIPLIST_PROB_QUARTER,</TT> determines the probability of having
a certain number of pointers in each skip list node.&nbsp; The second optional parameter, which defaults to the constant<TT>
WCDEFAULT_SKIPLIST_MAX_PTRS,</TT> determines the maximum number of pointers that are allowed in any skip list node.<TT>&nbsp;
WCDEFAULT_SKIPLIST_MAX_PTRS</TT> is the maximum effective value of the second parameter.&nbsp; If an allocation failure occurs
while creating the skip list, the<TT> out_of_memory</TT> exception is thrown if the<TT> out_of_memory</TT> exception is enabled.
<DT>Results:
<DD>The<TT> WCPtrSkipListSet&lt;Type&gt;</TT> constructor creates an initialized<TT> WCPtrSkipListSet</TT> object.
<DT>See Also:
<DD><TT> ~WCPtrSkipList&lt;Type&gt;</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCPtrSkipListSet( unsigned = WCSKIPLIST_PROB_QUARTER,</TT>
<BR><TT> unsigned = WCDEFAULT_SKIPLIST_MAX_PTRS,</TT>
<BR><TT>void * (*user_alloc)( size_t ),</TT>
<BR><TT>void (*user_dealloc)( void *, size_t ) );</TT>
<DT>Semantics:
<DD>Allocator and deallocator functions are specified for use when entries are inserted and removed from the list.&nbsp; The semantics
of this constructor are the same as the constructor without the memory management functions.
<BR><BR>The allocation function must return a zero if it cannot perform the allocation.&nbsp; The deallocation function is
passed the size as well as the pointer to the data.&nbsp; Your allocation system may take advantage of the characteristic
that the allocation function will always be called with the same size value for any particular instantiation of a skip list.
&nbsp;To determine the size of the objects that the memory management functions will be required to allocate and free, the
following macro may be used:
<BR><BR><TT>WCPtrSkipListSetItemSize( Type, num_of_pointers )</TT>
<DT>Results:
<DD>The<TT> WCPtrSkipListSet&lt;Type&gt;</TT> constructor creates an initialized<TT> WCPtrSkipListSet</TT> object.
<DT>See Also:
<DD><TT> ~WCPtrSkipList&lt;Type&gt;</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCPtrSkipListSet( const WCPtrSkipListSet &amp; );</TT>
<DT>Semantics:
<DD>The<TT> WCPtrSkipListSet&lt;Type&gt;</TT> constructor is the copy constructor for the<TT> WCPtrSkipListSet</TT> class.&nbsp;
The new skip list is created with the same probability and maximum pointers, all values or pointers stored in the list, and
the exception trap states.&nbsp; If there is not enough memory to copy all of the values, then only some will be copied, and
the number of entries will correctly reflect the number copied.&nbsp; If all of the elements cannot be copied, then the<TT>
out_of_memory</TT> exception is thrown if it is enabled.
<DT>Results:
<DD>The<TT> WCPtrSkipListSet&lt;Type&gt;</TT> constructor creates a<TT> WCPtrSkipListSet</TT> object which is a copy of the passed
list.
<DT>See Also:
<DD><TT> operator =</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<H2 ID="WCPtrSkipListSetXTypeY____WCPtrSkipListSetLR"> ~WCPtrSkipListSet() [WCPtrSkipListSet&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>virtual ~WCPtrSkipListSet();</TT>
<DT>Semantics:
<DD>The<TT> WCPtrSkipListSet&lt;Type&gt;</TT> destructor is the destructor for the<TT> WCPtrSkipListSet</TT> class.&nbsp; If the
number of elements is not zero and the<TT> not_empty</TT> exception is enabled, the exception is thrown.&nbsp; Otherwise,
the list elements are cleared using the<TT> clear</TT> member function.&nbsp; The objects which the list elements point to
are not deleted unless the<TT> clearAndDestroy</TT> member function is explicitly called before the destructor is called.
&nbsp;The call to the<TT> WCPtrSkipListSet&lt;Type&gt;</TT> destructor is inserted implicitly by the compiler at the point
where the<TT> WCPtrSkipListSet</TT> object goes out of scope.
<DT>Results:
<DD>The call to the<TT> WCPtrSkipListSet&lt;Type&gt;</TT> destructor destroys a<TT> WCPtrSkipListSet</TT> object.
<DT>See Also:
<DD><TT> clear</TT>,<TT> clearAndDestroy</TT>,<TT> WCExcept::not_empty</TT>
</DL>
<H2 ID="WCPtrSkipListXTypeY__WCPtrSkipListLR"> WCPtrSkipList() [WCPtrSkipList&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCPtrSkipList( unsigned = WCSKIPLIST_PROB_QUARTER,</TT>
<BR><TT> unsigned = WCDEFAULT_SKIPLIST_MAX_PTRS );</TT>
<DT>Semantics:
<DD>The<TT> WCPtrSkipList&lt;Type&gt;</TT> constructor creates a<TT> WCPtrSkipList</TT> object with no entries.&nbsp; The first
optional parameter, which defaults to the constant<TT> WCSKIPLIST_PROB_QUARTER,</TT> determines the probability of having
a certain number of pointers in each skip list node.&nbsp; The second optional parameter, which defaults to the constant<TT>
WCDEFAULT_SKIPLIST_MAX_PTRS,</TT> determines the maximum number of pointers that are allowed in any skip list node.<TT>&nbsp;
WCDEFAULT_SKIPLIST_MAX_PTRS</TT> is the maximum effective value of the second parameter.&nbsp; If an allocation failure occurs
while creating the skip list, the<TT> out_of_memory</TT> exception is thrown if the<TT> out_of_memory</TT> exception is enabled.
<DT>Results:
<DD>The<TT> WCPtrSkipList&lt;Type&gt;</TT> constructor creates an initialized<TT> WCPtrSkipList</TT> object.
<DT>See Also:
<DD><TT> ~WCPtrSkipList&lt;Type&gt;</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCPtrSkipList( unsigned = WCSKIPLIST_PROB_QUARTER,</TT>
<BR><TT> unsigned = WCDEFAULT_SKIPLIST_MAX_PTRS,</TT>
<BR><TT>void * (*user_alloc)( size_t ),</TT>
<BR><TT>void (*user_dealloc)( void *, size_t ) );</TT>
<DT>Semantics:
<DD>Allocator and deallocator functions are specified for use when entries are inserted and removed from the list.&nbsp; The semantics
of this constructor are the same as the constructor without the memory management functions.
<BR><BR>The allocation function must return a zero if it cannot perform the allocation.&nbsp; The deallocation function is
passed the size as well as the pointer to the data.&nbsp; Your allocation system may take advantage of the characteristic
that the allocation function will always be called with the same size value for any particular instantiation of a skip list.
&nbsp;To determine the size of the objects that the memory management functions will be required to allocate and free, the
following macro may be used:
<BR><BR><TT>WCPtrSkipListItemSize( Type, num_of_pointers )</TT>
<DT>Results:
<DD>The<TT> WCPtrSkipList&lt;Type&gt;</TT> constructor creates an initialized<TT> WCPtrSkipList</TT> object.
<DT>See Also:
<DD><TT> ~WCPtrSkipList&lt;Type&gt;</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCPtrSkipList( const WCPtrSkipList &amp; );</TT>
<DT>Semantics:
<DD>The<TT> WCPtrSkipList&lt;Type&gt;</TT> constructor is the copy constructor for the<TT> WCPtrSkipList</TT> class.&nbsp; The
new skip list is created with the same probability and maximum pointers, all values or pointers stored in the list, and the
exception trap states.&nbsp; If there is not enough memory to copy all of the values, then only some will be copied, and the
number of entries will correctly reflect the number copied.&nbsp; If all of the elements cannot be copied, then the<TT> out_of_memory</TT>
exception is thrown if it is enabled.
<DT>Results:
<DD>The<TT> WCPtrSkipList&lt;Type&gt;</TT> constructor creates a<TT> WCPtrSkipList</TT> object which is a copy of the passed list.
<DT>See Also:
<DD><TT> operator =</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<H2 ID="WCPtrSkipListXTypeY____WCPtrSkipListLR"> ~WCPtrSkipList() [WCPtrSkipList&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>virtual ~WCPtrSkipList();</TT>
<DT>Semantics:
<DD>The<TT> WCPtrSkipList&lt;Type&gt;</TT> destructor is the destructor for the<TT> WCPtrSkipList</TT> class.&nbsp; If the number
of elements is not zero and the<TT> not_empty</TT> exception is enabled, the exception is thrown.&nbsp; Otherwise, the list
elements are cleared using the<TT> clear</TT> member function.&nbsp; The objects which the list elements point to are not
deleted unless the<TT> clearAndDestroy</TT> member function is explicitly called before the destructor is called.&nbsp; The
call to the<TT> WCPtrSkipList&lt;Type&gt;</TT> destructor is inserted implicitly by the compiler at the point where the<TT>
WCPtrSkipList</TT> object goes out of scope.
<DT>Results:
<DD>The call to the<TT> WCPtrSkipList&lt;Type&gt;</TT> destructor destroys a<TT> WCPtrSkipList</TT> object.
<DT>See Also:
<DD><TT> clear</TT>,<TT> clearAndDestroy</TT>,<TT> WCExcept::not_empty</TT>
</DL>
<H2 ID="WCPtrSkipListXTypeY__clearLR__WCPtrSkipListSetXTypeY__clearLR"> clear() [WCPtrSkipList&lt;Type&gt;,WCPtrSkipListSet&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void clear();</TT>
<DT>Semantics:
<DD>The<TT> clear</TT> public member function is used to clear the list so that it has no entries.&nbsp; Objects pointed to by
the list elements are not deleted.&nbsp; The list object is not destroyed and re-created by this function, so the object destructor
is not invoked.
<DT>Results:
<DD>The<TT> clear</TT> public member function clears the list to have no elements.
<DT>See Also:
<DD><TT> ~WCPtrSkipList&lt;Type&gt;</TT>,<TT> clearAndDestroy</TT>,<TT> operator =</TT>
</DL>
<H2 ID="WCPtrSkipListXTypeY_WCPtrSkipListSetXTypeY__clearAndDestroyLR"> clearAndDestroy() [WCPtrSkipList&lt;Type&gt;,WCPtrSkipListSet&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void clearAndDestroy();</TT>
<DT>Semantics:
<DD>The<TT> clearAndDestroy</TT> public member function is used to clear the list and delete the objects pointed to by the list
elements.&nbsp; The list object is not destroyed and re-created by this function, so the list object destructor is not invoked.
<DT>Results:
<DD>The<TT> clearAndDestroy</TT> public member function clears the list by deleting the objects pointed to by the list elements,
and then removing the list elements from the list.
<DT>See Also:
<DD><TT> clear</TT>
</DL>
<H2 ID="WCPtrSkipListXTypeY__containsLR__WCPtrSkipListSetXTypeY__containsLR"> contains() [WCPtrSkipList&lt;Type&gt;,WCPtrSkipListSet&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int contains( const Type * ) const;</TT>
<DT>Semantics:
<DD>The<TT> contains</TT> public member function returns non-zero if the element is stored in the list, or zero if there is no
equivalent element.&nbsp; Note that equivalence is based on the equivalence operator of the element type.
<DT>Results:
<DD>The<TT> contains</TT> public member function returns a non-zero value if the element is found in the list.
<DT>See Also:
<DD><TT> find</TT>
</DL>
<H2 ID="WCPtrSkipListXTypeY__entriesLR__WCPtrSkipListSetXTypeY__entriesLR"> entries() [WCPtrSkipList&lt;Type&gt;,WCPtrSkipListSet&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>unsigned entries() const;</TT>
<DT>Semantics:
<DD>The<TT> entries</TT> public member function is used to return the current number of elements stored in the list.
<DT>Results:
<DD>The<TT> entries</TT> public member function returns the number of elements in the list.
<DT>See Also:
<DD><TT> isEmpty</TT>
</DL>
<H2 ID="WCPtrSkipListXTypeY__findLR__WCPtrSkipListSetXTypeY__findLR"> find() [WCPtrSkipList&lt;Type&gt;,WCPtrSkipListSet&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Type * find( const Type * ) const;</TT>
<DT>Semantics:
<DD>The<TT> find</TT> public member function is used to find an element with an equivalent value in the list.&nbsp; If an equivalent
element is found, a pointer to the element is returned.&nbsp; Zero is returned if the element is not found.&nbsp; Note that
equivalence is based on the equivalence operator of the element type.
<DT>Results:
<DD>The element equivalent to the passed value is located in the list.
</DL>
<H2 ID="WCPtrSkipListXTypeY__forAllLR__WCPtrSkipListSetXTypeY__forAllLR"> forAll() [WCPtrSkipList&lt;Type&gt;,WCPtrSkipListSet&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void forAll(</TT>
<BR><TT> void (*user_fn)( Type *, void * ),</TT>
<BR><TT>void * );</TT>
<DT>Semantics:
<DD>The<TT> forAll</TT> public member function causes the user supplied function to be invoked for every value in the list.&nbsp;
The user function has the prototype
<BR><BR><TT>void user_func( Type * value, void * data );</TT>
<BR><BR>As the elements are visited, the user function is invoked with the element passed as the first.&nbsp; The second parameter
of the<TT> forAll</TT> function is passed as the second parameter to the user function.&nbsp; This value can be used to pass
any appropriate data from the main code to the user function.
<DT>Results:
<DD>The elements in the list are all visited, with the user function being invoked for each one.
<DT>See Also:
<DD><TT> find</TT>
</DL>
<H2 ID="WCPtrSkipListXTypeY__insertLR__WCPtrSkipListSetXTypeY__insertLR"> insert() [WCPtrSkipList&lt;Type&gt;,WCPtrSkipListSet&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int insert( Type * );</TT>
<DT>Semantics:
<DD>The<TT> insert</TT> public member function inserts a value into the list.&nbsp; If allocation of the node to store the value
fails, then the<TT> out_of_memory</TT> exception is thrown if it is enabled.&nbsp; If the exception is not enabled, the insert
will not be completed.
<BR><BR>With a<TT> WCPtrSkipListSet,</TT> there must be only one equivalent element in the set.&nbsp; If an element equivalent
to the inserted element is already in the list set, the list set will remain unchanged, and the<TT> not_unique</TT> exception
is thrown if it is enabled.&nbsp; If the exception is not enabled, the insert will not be completed.
<DT>Results:
<DD>The<TT> insert</TT> public member function inserts a value into the list.&nbsp; If the insert is successful, a non-zero will
returned.&nbsp; A zero will be returned if the insert fails.
<DT>See Also:
<DD><TT> operator =</TT>,<TT> WCExcept::out_of_memory</TT>,<TT> WCExcept::not_unique</TT>
</DL>
<H2 ID="WCPtrSkipListXTypeY__isEmptyLR__WCPtrSkipListSetXTypeY__isEmptyLR"> isEmpty() [WCPtrSkipList&lt;Type&gt;,WCPtrSkipListSet&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int isEmpty() const;</TT>
<DT>Semantics:
<DD>The<TT> isEmpty</TT> public member function is used to determine if the list is empty.
<DT>Results:
<DD>The<TT> isEmpty</TT> public member function returns zero if it contains at least one entry, non-zero if the list is empty.
<DT>See Also:
<DD><TT> entries</TT>
</DL>
<H2 ID="WCPtrSkipListXTypeY__occurrencesOfLR"> occurrencesOf() [WCPtrSkipList&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>unsigned occurrencesOf( const Type * ) const;</TT>
<DT>Semantics:
<DD>The<TT> occurrencesOf</TT> public member function is used to return the current number of elements stored in the list which
are equivalent to the passed value.&nbsp; Note that equivalence is based on the equivalence operator of the element type.
<DT>Results:
<DD>The<TT> occurrencesOf</TT> public member function returns the number of elements in the list which are equivalent to the passed
value.
<DT>See Also:
<DD><TT> entries</TT>,<TT> find</TT>,<TT> isEmpty</TT>
</DL>
<H2 ID="WCPtrSkipListXTypeY__operator_ELR__WCPtrSkipListSetXTypeY__operator_ELR"> operator =() [WCPtrSkipList&lt;Type&gt;,WCPtrSkipListSet&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCPtrSkipList &amp; operator =( const WCPtrSkipList &amp; );</TT>
<BR><TT> WCPtrSkipListSet &amp; operator =( const WCPtrSkipListSet &amp; );</TT>
<DT>Semantics:
<DD>The<TT> operator =</TT> public member function is the assignment operator for the<TT> WCPtrSkipList&lt;Type&gt;</TT> and<TT>
WCPtrSkipListSet&lt;Type&gt;</TT> classes.&nbsp; The left hand side list is first cleared using the<TT> clear</TT> member
function, and then the right hand side list is copied.&nbsp; The list function, exception trap states, and all of the list
elements are copied.&nbsp; If there is not enough memory to copy all of the values or pointers in the list, then only some
will be copied, and the<TT> out_of_memory</TT> exception is thrown if it is enabled.&nbsp; The number of entries will correctly
reflect the number copied.
<DT>Results:
<DD>The<TT> operator =</TT> public member function assigns the left hand side list to be a copy of the right hand side.
<DT>See Also:
<DD><TT> clear</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<H2 ID="WCPtrSkipListXTypeY__operator_EELR__WCPtrSkipListSetXTypeY__operator_EELR"> operator ==() [WCPtrSkipList&lt;Type&gt;,WCPtrSkipListSet&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int operator ==( const WCPtrSkipList &amp; ) const;</TT>
<BR><TT> int operator ==( const WCPtrSkipListSet &amp; ) const;</TT>
<DT>Semantics:
<DD>The<TT> operator ==</TT> public member function is the equivalence operator for the<TT> WCPtrSkipList&lt;Type&gt;</TT> and<TT>
WCPtrSkipListSet&lt;Type&gt;</TT> classes.&nbsp; Two list objects are equivalent if they are the same object and share the
same address.
<DT>Results:
<DD>A TRUE (non-zero) value is returned if the left hand side and right hand side list are the same object.&nbsp; A FALSE (zero)
value is returned otherwise.
</DL>
<H2 ID="WCPtrSkipListXTypeY__removeLR__WCPtrSkipListSetXTypeY__removeLR"> remove() [WCPtrSkipList&lt;Type&gt;,WCPtrSkipListSet&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Type * remove( const Type * );</TT>
<DT>Semantics:
<DD>The<TT> remove</TT> public member function is used to remove the specified element from the list.&nbsp; If an equivalent element
is found, the pointer value is returned.&nbsp; Zero is returned if the element is not found.&nbsp; If the list is a<TT> WCPtrSkipList</TT>
and there is more than one element equivalent to the specified element, then the last equivalent element added to the<TT>
WCPtrSkipList</TT> is removed.&nbsp; Note that equivalence is based on the equivalence operator of the element type.
<DT>Results:
<DD>The element is removed from the list.
</DL>
<H2 ID="WCPtrSkipListXTypeY__removeAllLR"> removeAll() [WCPtrSkipList&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>unsigned removeAll( const Type * );</TT>
<DT>Semantics:
<DD>The<TT> removeAll</TT> public member function is used to remove all elements equivalent to the specified element from the
list.&nbsp; Zero is returned if no equivalent elements are found.&nbsp; Note that equivalence is based on the equivalence
operator of the element type.
<DT>Results:
<DD>All equivalent elements are removed from the list.
</DL>
<H2 ID="WCValSkipListDictXKey_ValueY_Class_Description"> WCValSkipListDict&lt;Key,Value&gt; Class Description </H2>
<DL>
<DT>Declared:
<DD><TT> wcskip.h</TT>
<BR><BR>The<TT> WCValSkipListDict&lt;Key,Value&gt;</TT> class is a templated class used to store objects in a dictionary.
&nbsp;Dictionaries store values with an associated key, which may be of any type.&nbsp; One example of a dictionary used in
everyday life is the phone book.&nbsp; The phone numbers are the data values, and the customer name is the key.&nbsp; The
equality operator of the key's type is used to locate the key-value pairs.
<BR>In the description of each member function, the text<TT> Key</TT> is used to indicate the template parameter defining
the type of the indices used to store data in the dictionary.&nbsp; The text<TT> Value</TT> is used to indicate the template
parameter defining the type of the data stored in the dictionary.
<BR><BR>Values are copied into the dictionary, which could be undesirable if the stored objects are complicated and copying
is expensive.&nbsp; Value dictionaries should not be used to store objects of a base class if any derived types of different
sizes would be stored in the dictionary, or if the destructor for a derived class must be called.
<BR><BR>The iterator classes for skip lists have the same function and operator interface as the hash iterators classes.&nbsp;
See the chapter on hash iterators for more information.
<BR><BR>The<TT> WCExcept</TT> class is a base class of the<TT> WCValSkipListDict&lt;Key,Value&gt;</TT> class and provides
the<TT> exceptions</TT> member function.&nbsp; This member function controls the exceptions which can be thrown by the<TT>
WCValSkipListDict&lt;Key,Value&gt;</TT> object.&nbsp; No exceptions are enabled unless they are set by the<TT> exceptions</TT>
member function.
<BR><BR><B>Requirements of Key and Value</B>
<BR><BR>The<TT> WCValSkipListDict&lt;Key,Value&gt;</TT> class requires<TT> Key</TT> to have:
<BR>A default constructor (<TT> Key::Key()</TT> ).
<BR><BR>A well defined copy constructor (<TT> Key::Key( const Key &amp; )</TT> ).
<BR><BR>A well defined assignment operator (<TT> Key &amp; operator =( const Key &amp; )</TT> ).
<BR><BR>A well defined equivalence operator with constant parameters
<BR><BR>(<TT> int operator ==( const Key &amp; ) const</TT> ).
<BR>A well defined operator less than with constant parameters
<BR><BR>(<TT> int operator &lt;( const Key &amp; ) const</TT> ).
<BR>The<TT> WCValSkipListDict&lt;Key,Value&gt;</TT> class requires<TT> Value</TT> to have:
<BR><BR>A default constructor (<TT> Value::Value()</TT> ).
<BR><BR>A well defined copy constructor (<TT> Value::Value( const Value &amp; )</TT> ).
<BR><BR>A well defined assignment operator (<TT> Value &amp; operator =( const Value &amp; )</TT> ).
<BR><BR><B>Public Member Functions</B>
<BR><BR>The following member functions are declared in the public interface:
<BR><BR><TT>WCValSkipListDict( unsigned = WCSkipListDict_PROB_QUARTER, unsigned = WCDEFAULT_SKIPLIST_MAX_PTRS );</TT>
<BR><TT> WCValSkipListDict( unsigned = WCSkipListDict_PROB_QUARTER, unsigned = WCDEFAULT_SKIPLIST_MAX_PTRS, void * (*user_alloc)(
size_t size ), void (*user_dealloc)( void *old, size_t size ) );</TT>
<BR><TT> WCValSkipListDict( const WCValSkipListDict &amp; );</TT>
<BR><TT> virtual ~WCValSkipListDict();</TT>
<BR><TT> void clear();</TT>
<BR><TT> int contains( const Key &amp; ) const;</TT>
<BR><TT> unsigned entries() const;</TT>
<BR><TT> int find( const Key &amp;, Value &amp; ) const;</TT>
<BR><TT> int findKeyAndValue( const Key &amp;, Key &amp;, Value &amp; ) const;</TT>
<BR><TT> void forAll( void (*user_fn)( Key, Value, void * ), void * );</TT>
<BR><TT> int insert( const Key &amp;, const Value &amp; );</TT>
<BR><TT> int isEmpty() const;</TT>
<BR><TT> int remove( const Key &amp; );</TT>
<BR><BR><B>Public Member Operators</B>
<BR><BR>The following member operators are declared in the public interface:
<BR><BR><TT>Value &amp; operator []( const Key &amp; );</TT>
<BR><TT> const Value &amp; operator []( const Key &amp; ) const;</TT>
<BR><TT> WCValSkipListDict &amp; operator =( const WCValSkipListDict &amp; );</TT>
<BR><TT> int operator ==( const WCValSkipListDict &amp; ) const;</TT>
</DL>
<H2 ID="WCValSkipListDictXKey_ValueY__WCValSkipListDictLR"> WCValSkipListDict() [WCValSkipListDict&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCValSkipListDict( unsigned = WCSKIPLIST_PROB_QUARTER,</TT>
<BR><TT> unsigned = WCDEFAULT_SKIPLIST_MAX_PTRS );</TT>
<DT>Semantics:
<DD>The public<TT> WCValSkipListDict&lt;Key,Value&gt;</TT> constructor creates an<TT> WCValSkipListDict&lt;Key,Value&gt;</TT>
object with no entries.&nbsp; The first optional parameter, which defaults to the constant<TT> WCSKIPLIST_PROB_QUARTER,</TT>
determines the probability of having a certain number of pointers in each skip list node.&nbsp; The second optional parameter,
which defaults to the constant<TT> WCDEFAULT_SKIPLIST_MAX_PTRS,</TT> determines the maximum number of pointers that are allowed
in any skip list node.<TT>&nbsp; WCDEFAULT_SKIPLIST_MAX_PTRS</TT> is the maximum effective value of the second parameter.
&nbsp;If an allocation failure occurs while creating the skip list, the<TT> out_of_memory</TT> exception is thrown if the<TT>
out_of_memory</TT> exception is enabled.
<DT>Results:
<DD>The public<TT> WCValSkipListDict&lt;Key,Value&gt;</TT> constructor creates an initialized<TT> WCValSkipListDict&lt;Key,Value&gt;</TT>
object.
<DT>See Also:
<DD><TT> ~WCValSkipListDict&lt;Key,Value&gt;</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCValSkipListDict( unsigned = WCSKIPLIST_PROB_QUARTER,</TT>
<BR><TT> unsigned = WCDEFAULT_SKIPLIST_MAX_PTRS,</TT>
<BR><TT>void * (*user_alloc)( size_t ),</TT>
<BR><TT>void (*user_dealloc)( void *, size_t ) );</TT>
<DT>Semantics:
<DD>Allocator and deallocator functions are specified for use when entries are inserted and removed from the list dictionary.
&nbsp;The semantics of this constructor are the same as the constructor without the memory management functions.
<BR><BR>The allocation function must return a zero if it cannot perform the allocation.&nbsp; The deallocation function is
passed the size as well as the pointer to the data.&nbsp; Your allocation system may take advantage of the characteristic
that the allocation function will always be called with the same size value for any particular instantiation of a list dictionary.
&nbsp;To determine the size of the objects that the memory management functions will be required to allocate and free, the
following macro may be used:
<BR><BR><TT>WCValSkipListDictItemSize( Key, Value, num_of_pointers )</TT>
<DT>Results:
<DD>The public<TT> WCValSkipListDict&lt;Key,Value&gt;</TT> constructor creates an initialized<TT> WCValSkipListDict&lt;Key,Value&gt;</TT>
object.
<DT>See Also:
<DD><TT> ~WCValSkipListDict&lt;Key,Value&gt;</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCValSkipListDict( const WCValSkipListDict &amp; );</TT>
<DT>Semantics:
<DD>The public<TT> WCValSkipListDict&lt;Key,Value&gt;</TT> constructor is the copy constructor for the<TT> WCValSkipListDict&lt;Key,Value&gt;</TT>
class.&nbsp; The new skip list is created with the same probability and maximum pointers, all values or pointers stored in
the list, and the exception trap states.&nbsp; If there is not enough memory to copy all of the values, then only some will
be copied, and the number of entries will correctly reflect the number copied.&nbsp; If all of the elements cannot be copied,
then the<TT> out_of_memory</TT> exception is thrown if it is enabled.
<DT>Results:
<DD>The public<TT> WCValSkipListDict&lt;Key,Value&gt;</TT> constructor creates an<TT> WCValSkipListDict&lt;Key,Value&gt;</TT>
object which is a copy of the passed dictionary.
<DT>See Also:
<DD><TT> operator =</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<H2 ID="WCValSkipListDictXKey_ValueY____WCValSkipListDictLR"> ~WCValSkipListDict() [WCValSkipListDict&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>virtual ~WCValSkipListDict();</TT>
<DT>Semantics:
<DD>The public<TT> ~WCValSkipListDict&lt;Key,Value&gt;</TT> destructor is the destructor for the<TT> WCValSkipListDict&lt;Key,Value&gt;</TT>
class.&nbsp; If the number of dictionary elements is not zero and the<TT> not_empty</TT> exception is enabled, the exception
is thrown.&nbsp; Otherwise, the dictionary elements are cleared using the<TT> clear</TT> member function.&nbsp; The call to
the public<TT> ~WCValSkipListDict&lt;Key,Value&gt;</TT> destructor is inserted implicitly by the compiler at the point where
the<TT> WCValSkipListDict&lt;Key,Value&gt;</TT> object goes out of scope.
<DT>Results:
<DD>The public<TT> ~WCValSkipListDict&lt;Key,Value&gt;</TT> destructor destroys an<TT> WCValSkipListDict&lt;Key,Value&gt;</TT>
object.
<DT>See Also:
<DD><TT> clear</TT>,<TT> WCExcept::not_empty</TT>
</DL>
<H2 ID="WCValSkipListDictXKey_ValueY__clearLR"> clear() [WCValSkipListDict&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void clear();</TT>
<DT>Semantics:
<DD>The<TT> clear</TT> public member function is used to clear the dictionary so that it has no entries.&nbsp; Elements stored
in the dictionary are destroyed using the destructors of<TT> Key</TT> and of<TT> Value.</TT>&nbsp; The dictionary object is
not destroyed and re-created by this function, so the object destructor is not invoked.
<DT>Results:
<DD>The<TT> clear</TT> public member function clears the dictionary to have no elements.
<DT>See Also:
<DD><TT> ~WCValSkipListDict&lt;Key,Value&gt;</TT>,<TT> operator =</TT>
</DL>
<H2 ID="WCValSkipListDictXKey_ValueY__containsLR"> contains() [WCValSkipListDict&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int contains( const Key &amp; ) const;</TT>
<DT>Semantics:
<DD>The<TT> contains</TT> public member function returns non-zero if an element with the specified key is stored in the dictionary,
or zero if there is no equivalent element.&nbsp; Note that equivalence is based on the equivalence operator of the<TT> Key</TT>
type.
<DT>Results:
<DD>The<TT> contains</TT> public member function returns a non-zero value if the<TT> Key</TT> is found in the dictionary.
<DT>See Also:
<DD><TT> find</TT>,<TT> findKeyAndValue</TT>
</DL>
<H2 ID="WCValSkipListDictXKey_ValueY__entriesLR"> entries() [WCValSkipListDict&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>unsigned entries() const;</TT>
<DT>Semantics:
<DD>The<TT> entries</TT> public member function is used to return the current number of elements stored in the dictionary.
<DT>Results:
<DD>The<TT> entries</TT> public member function returns the number of elements in the dictionary.
<DT>See Also:
<DD><TT> isEmpty</TT>
</DL>
<H2 ID="WCValSkipListDictXKey_ValueY__findLR"> find() [WCValSkipListDict&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int find( const Key &amp;, Value &amp; ) const;</TT>
<DT>Semantics:
<DD>The<TT> find</TT> public member function is used to find an element with an equivalent key in the dictionary.&nbsp; If an
equivalent element is found, a non-zero value is returned.&nbsp; The reference to a<TT> Value</TT> passed as the second argument
is assigned the found element's<TT> Value.</TT>&nbsp; Zero is returned if the element is not found.&nbsp; Note that equivalence
is based on the equivalence operator of the<TT> Key</TT> type.
<DT>Results:
<DD>The element equivalent to the passed key is located in the dictionary.
<DT>See Also:
<DD><TT> findKeyAndValue</TT>
</DL>
<H2 ID="WCValSkipListDictXKey_ValueY__findKeyAndValueLR"> findKeyAndValue() [WCValSkipListDict&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int findKeyAndValue( const Key &amp;,</TT>
<BR><TT> Key &amp;, Value &amp; ) const;</TT>
<DT>Semantics:
<DD>The<TT> findKeyAndValue</TT> public member function is used to find an element in the dictionary with an key equivalent to
the first parameter.&nbsp; If an equivalent element is found, a non-zero value is returned.&nbsp; The reference to a<TT> Key</TT>
passed as the second parameter is assigned the found element's key.&nbsp; The reference to a<TT> Value</TT> passed as the
third argument is assigned the found element's<TT> Value.</TT>&nbsp; Zero is returned if the element is not found.&nbsp; Note
that equivalence is based on the equivalence operator of the<TT> Key</TT> type.
<DT>Results:
<DD>The element equivalent to the passed key is located in the dictionary.
<DT>See Also:
<DD><TT> findKeyAndValue</TT>
</DL>
<H2 ID="WCValSkipListDictXKey_ValueY__forAllLR"> forAll() [WCValSkipListDict&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void forAll(</TT>
<BR><TT> void (*user_fn)( Key, Value, void * ),</TT>
<BR><TT>void * );</TT>
<DT>Semantics:
<DD>The<TT> forAll</TT> public member function causes the user supplied function to be invoked for every key-value pair in the
dictionary.&nbsp; The user function has the prototype
<BR><BR><TT>void user_func( Key key, Value value, void * data );</TT>
<BR><BR>As the elements are visited, the user function is invoked with the<TT> Key</TT> and<TT> Value</TT> components of the
element passed as the first two parameters.&nbsp; The second parameter of the<TT> forAll</TT> function is passed as the third
parameter to the user function.&nbsp; This value can be used to pass any appropriate data from the main code to the user function.
<DT>Results:
<DD>The elements in the dictionary are all visited, with the user function being invoked for each one.
<DT>See Also:
<DD><TT> find</TT>,<TT> findKeyAndValue</TT>
</DL>
<H2 ID="WCValSkipListDictXKey_ValueY__insertLR"> insert() [WCValSkipListDict&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int insert( const Key &amp;, const Value &amp; );</TT>
<DT>Semantics:
<DD>The<TT> insert</TT> public member function inserts a key and value into the dictionary.&nbsp; If allocation of the node to
store the key-value pair fails, then the<TT> out_of_memory</TT> exception is thrown if it is enabled.&nbsp; If the exception
is not enabled, the insert will not be completed.
<DT>Results:
<DD>The<TT> insert</TT> public member function inserts a key and value into the dictionary.&nbsp; If the insert is successful,
a non-zero will returned.&nbsp; A zero will be returned if the insert fails.
<DT>See Also:
<DD><TT> operator =</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<H2 ID="WCValSkipListDictXKey_ValueY__isEmptyLR"> isEmpty() [WCValSkipListDict&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int isEmpty() const;</TT>
<DT>Semantics:
<DD>The<TT> isEmpty</TT> public member function is used to determine if the dictionary is empty.
<DT>Results:
<DD>The<TT> isEmpty</TT> public member function returns zero if it contains at least one entry, non-zero if the dictionary is
empty.
<DT>See Also:
<DD><TT> entries</TT>
</DL>
<H2 ID="WCValSkipListDictXKey_ValueY__operator_UVLR"> operator []() [WCValSkipListDict&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Value &amp; operator[]( const Key &amp; );</TT>
<DT>Semantics:
<DD><TT> operator []</TT> is the dictionary index operator.&nbsp; A reference to the object stored in the dictionary with the
given<TT> Key</TT> is returned.&nbsp; If no equivalent element is found, then a new key-value pair is created with the specified<TT>
Key</TT> value, and initialized with the default constructor.&nbsp; The returned reference can then be assigned to, so that
insertions can be made with the operator.&nbsp; If an allocation error occurs while inserting a new key-value pair, then the<TT>
out_of_memory</TT> exception is thrown if it is enabled.&nbsp; If the exception is not enabled, then a reference to address
zero will be returned.&nbsp; This will result in a run-time error on systems which trap address zero references.
<DT>Results:
<DD>The<TT> operator []</TT> public member function returns a reference to the element at the given key value.&nbsp; If the key
does not exist, a reference to a created element is returned.&nbsp; The result of the operator may be assigned to.
<DT>See Also:
<DD><TT> WCExcept::out_of_memory</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>const Value &amp; operator[]( const Key &amp; ) const;</TT>
<DT>Semantics:
<DD><TT> operator []</TT> is the dictionary index operator.&nbsp; A constant reference to the object stored in the dictionary
with the given<TT> Key</TT> is returned.&nbsp; If no equivalent element is found, then the<TT> index_range</TT> exception
is thrown if it is enabled.&nbsp; If the exception is not enabled, then a reference to address zero will be returned.&nbsp;
This will result in a run-time error on systems which trap address zero references.
<DT>Results:
<DD>The<TT> operator []</TT> public member function returns a constant reference to the element at the given key value.&nbsp;
The result of the operator may not be assigned to.
<DT>See Also:
<DD><TT> WCExcept::index_range</TT>
</DL>
<H2 ID="WCValSkipListDictXKey_ValueY__operator_ELR"> operator =() [WCValSkipListDict&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCValSkipListDict &amp; operator =( const WCValSkipListDict &amp; );</TT>
<DT>Semantics:
<DD>The<TT> operator =</TT> public member function is the assignment operator for the<TT> WCValSkipListDict&lt;Key,Value&gt;</TT>
class.&nbsp; The left hand side dictionary is first cleared using the<TT> clear</TT> member function, and then the right hand
side dictionary is copied.&nbsp; The new skip list is created with the same probability and maximum pointers, all values or
pointers stored in the list, and the exception trap states.&nbsp; If there is not enough memory to copy all of the values
or pointers in the dictionary, then only some will be copied, and the<TT> out_of_memory</TT> exception is thrown if it is
enabled.&nbsp; The number of entries will correctly reflect the number copied.
<DT>Results:
<DD>The<TT> operator =</TT> public member function assigns the left hand side dictionary to be a copy of the right hand side.
<DT>See Also:
<DD><TT> clear</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<H2 ID="WCValSkipListDictXKey_ValueY__operator_EELR"> operator ==() [WCValSkipListDict&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int operator ==( const WCValSkipListDict &amp; ) const;</TT>
<DT>Semantics:
<DD>The<TT> operator ==</TT> public member function is the equivalence operator for the<TT> WCValSkipListDict&lt;Key,Value&gt;</TT>
class.&nbsp; Two dictionary objects are equivalent if they are the same object and share the same address.
<DT>Results:
<DD>A TRUE (non-zero) value is returned if the left hand side and right hand side dictionary are the same object.&nbsp; A FALSE
(zero) value is returned otherwise.
</DL>
<H2 ID="WCValSkipListDictXKey_ValueY__removeLR"> remove() [WCValSkipListDict&lt;Key,Value&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int remove( const Key &amp; );</TT>
<DT>Semantics:
<DD>The<TT> remove</TT> public member function is used to remove the specified element from the dictionary.&nbsp; If an equivalent
element is found, a non-zero value is returned.&nbsp; Zero is returned if the element is not found.&nbsp; Note that equivalence
is based on the equivalence operator of the<TT> Key</TT> type.
<DT>Results:
<DD>The element is removed from the dictionary if it found.
</DL>
<H2 ID="WCValSkipListXTypeY__WCValSkipListSetXTypeY_Class_Description"> WCValSkipList&lt;Type&gt;, WCValSkipListSet&lt;Type&gt; Class Description </H2>
<DL>
<DT>Declared:
<DD><TT> wcskip.h</TT>
<BR><BR><TT>WCValSkipList&lt;Type&gt;</TT> and<TT> WCValSkipListSet&lt;Type&gt;</TT> classes are templated classes used to
store objects in a skip list.&nbsp; A skip list is a probabilistic alternative to balanced trees, and provides a reasonable
performance balance to insertion, search, and deletion.&nbsp; A skip list allows more than one copy of an element that is
equivalent, while the skip list set allows only one copy.&nbsp; The equality operator of the element's type is used to locate
the value.
<BR>In the description of each member function, the text<TT> Type</TT> is used to indicate the template parameter defining
the type of the data to be stored in the list.
<BR><BR>Values are copied into the list, which could be undesirable if the stored objects are complicated and copying is expensive.
&nbsp;Value skip lists should not be used to store objects of a base class if any derived types of different sizes would be
stored in the list, or if the destructor for a derived class must be called.
<BR><BR>The iterator classes for skip lists have the same function and operator interface as the hash iterators classes.&nbsp;
See the chapter on hash iterators for more information.
<BR><BR>The<TT> WCExcept</TT> class is a base class of the<TT> WCValSkipList&lt;Type&gt;</TT> and<TT> WCValSkipListSet&lt;Type&gt;</TT>
classes and provides the<TT> exceptions</TT> member function.&nbsp; This member function controls the exceptions which can
be thrown by the<TT> WCValSkipList&lt;Type&gt;</TT> and<TT> WCValSkipListSet&lt;Type&gt;</TT> objects.&nbsp; No exceptions
are enabled unless they are set by the<TT> exceptions</TT> member function.
<BR><BR><B>Requirements of Type</B>
<BR><BR>The<TT> WCValSkipList&lt;Type&gt;</TT> and<TT> WCValSkipListSet&lt;Type&gt;</TT> classes requires<TT> Type</TT> to
have:
<BR>A default constructor (<TT> Type::Type()</TT> ).
<BR><BR>A well defined copy constructor (<TT> Type::Type( const Type &amp; )</TT> ).
<BR><BR>A well defined equivalence operator
<BR><BR>(<TT> int operator ==( const Type &amp; ) const</TT> ).
<BR>A well defined less than operator
<BR><BR>(<TT> int operator &lt;( const Type &amp; ) const</TT> ).
<BR><BR><B>Public Member Functions</B>
<BR><BR>The following member functions are declared in the public interface:
<BR><BR><TT>WCValSkipList( unsigned = WCSKIPLIST_PROB_QUARTER, unsigned = WCDEFAULT_SKIPLIST_MAX_PTRS );</TT>
<BR><TT> WCValSkipList( unsigned = WCSKIPLIST_PROB_QUARTER, unsigned = WCDEFAULT_SKIPLIST_MAX_PTRS, void * (*user_alloc)(
size_t size ), void (*user_dealloc)( void *old, size_t size ) );</TT>
<BR><TT> WCValSkipList( const WCValSkipList &amp; );</TT>
<BR><TT> virtual ~WCValSkipList();</TT>
<BR><TT> WCValSkipListSet( unsigned = WCSKIPLIST_PROB_QUARTER, unsigned = WCDEFAULT_SKIPLIST_MAX_PTRS );</TT>
<BR><TT> WCValSkipListSet( unsigned = WCSKIPLIST_PROB_QUARTER, unsigned = WCDEFAULT_SKIPLIST_MAX_PTRS, void * (*user_alloc)(
size_t size ), void (*user_dealloc)( void *old, size_t size ) );</TT>
<BR><TT> WCValSkipListSet( const WCValSkipListSet &amp; );</TT>
<BR><TT> virtual ~WCValSkipListSet();</TT>
<BR><TT> void clear();</TT>
<BR><TT> int contains( const Type &amp; ) const;</TT>
<BR><TT> unsigned entries() const;</TT>
<BR><TT> int find( const Type &amp;, Type &amp; ) const;</TT>
<BR><TT> void forAll( void (*user_fn)( Type, void * ), void * );</TT>
<BR><TT> int insert( const Type &amp; );</TT>
<BR><TT> int isEmpty() const;</TT>
<BR><TT> int remove( const Type &amp; );</TT>
<BR><BR>The following public member functions are available for the<TT> WCValSkipList</TT> class only:
<BR><BR><TT>unsigned occurrencesOf( const Type &amp; ) const;</TT>
<BR><TT> unsigned removeAll( const Type &amp; );</TT>
<BR><BR><B>Public Member Operators</B>
<BR><BR>The following member operators are declared in the public interface:
<BR><BR><TT>WCValSkipList &amp; operator =( const WCValSkipList &amp; );</TT>
<BR><TT> int operator ==( const WCValSkipList &amp; ) const;</TT>
<BR><TT> WCValSkipListSet &amp; operator =( const WCValSkipListSet &amp; );</TT>
<BR><TT> int operator ==( const WCValSkipListSet &amp; ) const;</TT>
</DL>
<H2 ID="WCValSkipListSetXTypeY__WCValSkipListSetLR"> WCValSkipListSet() [WCValSkipListSet&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCValSkipListSet( unsigned = WCSKIPLIST_PROB_QUARTER,</TT>
<BR><TT> unsigned = WCDEFAULT_SKIPLIST_MAX_PTRS );</TT>
<DT>Semantics:
<DD>The<TT> WCValSkipListSet&lt;Type&gt;</TT> constructor creates a<TT> WCValSkipListSet</TT> object with no entries.&nbsp; The
first optional parameter, which defaults to the constant<TT> WCSKIPLIST_PROB_QUARTER,</TT> determines the probability of having
a certain number of pointers in each skip list node.&nbsp; The second optional parameter, which defaults to the constant<TT>
WCDEFAULT_SKIPLIST_MAX_PTRS,</TT> determines the maximum number of pointers that are allowed in any skip list node.<TT>&nbsp;
WCDEFAULT_SKIPLIST_MAX_PTRS</TT> is the maximum effective value of the second parameter.&nbsp; If an allocation failure occurs
while creating the skip list, the<TT> out_of_memory</TT> exception is thrown if the<TT> out_of_memory</TT> exception is enabled.
<DT>Results:
<DD>The<TT> WCValSkipListSet&lt;Type&gt;</TT> constructor creates an initialized<TT> WCValSkipListSet</TT> object.
<DT>See Also:
<DD><TT> ~WCValSkipList&lt;Type&gt;</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCValSkipListSet( unsigned = WCSKIPLIST_PROB_QUARTER,</TT>
<BR><TT> unsigned = WCDEFAULT_SKIPLIST_MAX_PTRS,</TT>
<BR><TT>void * (*user_alloc)( size_t ),</TT>
<BR><TT>void (*user_dealloc)( void *, size_t ) );</TT>
<DT>Semantics:
<DD>Allocator and deallocator functions are specified for use when entries are inserted and removed from the list.&nbsp; The semantics
of this constructor are the same as the constructor without the memory management functions.
<BR><BR>The allocation function must return a zero if it cannot perform the allocation.&nbsp; The deallocation function is
passed the size as well as the pointer to the data.&nbsp; Your allocation system may take advantage of the characteristic
that the allocation function will always be called with the same size value for any particular instantiation of a skip list.
&nbsp;To determine the size of the objects that the memory management functions will be required to allocate and free, the
following macro may be used:
<BR><BR><TT>WCValSkipListSetItemSize( Type, num_of_pointers )</TT>
<DT>Results:
<DD>The<TT> WCValSkipListSet&lt;Type&gt;</TT> constructor creates an initialized<TT> WCValSkipListSet</TT> object.
<DT>See Also:
<DD><TT> ~WCValSkipList&lt;Type&gt;</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCValSkipListSet( const WCValSkipListSet &amp; );</TT>
<DT>Semantics:
<DD>The<TT> WCValSkipListSet&lt;Type&gt;</TT> constructor is the copy constructor for the<TT> WCValSkipListSet</TT> class.&nbsp;
The new skip list is created with the same probability and maximum pointers, all values or pointers stored in the list, and
the exception trap states.&nbsp; If there is not enough memory to copy all of the values, then only some will be copied, and
the number of entries will correctly reflect the number copied.&nbsp; If all of the elements cannot be copied, then the<TT>
out_of_memory</TT> exception is thrown if it is enabled.
<DT>Results:
<DD>The<TT> WCValSkipListSet&lt;Type&gt;</TT> constructor creates a<TT> WCValSkipListSet</TT> object which is a copy of the passed
list.
<DT>See Also:
<DD><TT> operator =</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<H2 ID="WCValSkipListSetXTypeY____WCValSkipListSetLR"> ~WCValSkipListSet() [WCValSkipListSet&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>virtual ~WCValSkipListSet();</TT>
<DT>Semantics:
<DD>The<TT> WCValSkipListSet&lt;Type&gt;</TT> destructor is the destructor for the<TT> WCValSkipListSet</TT> class.&nbsp; If the
number of elements is not zero and the<TT> not_empty</TT> exception is enabled, the exception is thrown.&nbsp; Otherwise,
the list elements are cleared using the<TT> clear</TT> member function.&nbsp; The call to the<TT> WCValSkipListSet&lt;Type&gt;</TT>
destructor is inserted implicitly by the compiler at the point where the<TT> WCValSkipListSet</TT> object goes out of scope.
<DT>Results:
<DD>The call to the<TT> WCValSkipListSet&lt;Type&gt;</TT> destructor destroys a<TT> WCValSkipListSet</TT> object.
<DT>See Also:
<DD><TT> clear</TT>,<TT> WCExcept::not_empty</TT>
</DL>
<H2 ID="WCValSkipListXTypeY__WCValSkipListLR"> WCValSkipList() [WCValSkipList&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCValSkipList( unsigned = WCSKIPLIST_PROB_QUARTER,</TT>
<BR><TT> unsigned = WCDEFAULT_SKIPLIST_MAX_PTRS );</TT>
<DT>Semantics:
<DD>The<TT> WCValSkipList&lt;Type&gt;</TT> constructor creates a<TT> WCValSkipList</TT> object with no entries.&nbsp; The first
optional parameter, which defaults to the constant<TT> WCSKIPLIST_PROB_QUARTER,</TT> determines the probability of having
a certain number of pointers in each skip list node.&nbsp; The second optional parameter, which defaults to the constant<TT>
WCDEFAULT_SKIPLIST_MAX_PTRS,</TT> determines the maximum number of pointers that are allowed in any skip list node.<TT>&nbsp;
WCDEFAULT_SKIPLIST_MAX_PTRS</TT> is the maximum effective value of the second parameter.&nbsp; If an allocation failure occurs
while creating the skip list, the<TT> out_of_memory</TT> exception is thrown if the<TT> out_of_memory</TT> exception is enabled.
<DT>Results:
<DD>The<TT> WCValSkipList&lt;Type&gt;</TT> constructor creates an initialized<TT> WCValSkipList</TT> object.
<DT>See Also:
<DD><TT> ~WCValSkipList&lt;Type&gt;</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCValSkipList( unsigned = WCSKIPLIST_PROB_QUARTER,</TT>
<BR><TT> unsigned = WCDEFAULT_SKIPLIST_MAX_PTRS,</TT>
<BR><TT>void * (*user_alloc)( size_t ),</TT>
<BR><TT>void (*user_dealloc)( void *, size_t ) );</TT>
<DT>Semantics:
<DD>Allocator and deallocator functions are specified for use when entries are inserted and removed from the list.&nbsp; The semantics
of this constructor are the same as the constructor without the memory management functions.
<BR><BR>The allocation function must return a zero if it cannot perform the allocation.&nbsp; The deallocation function is
passed the size as well as the pointer to the data.&nbsp; Your allocation system may take advantage of the characteristic
that the allocation function will always be called with the same size value for any particular instantiation of a skip list.
&nbsp;To determine the size of the objects that the memory management functions will be required to allocate and free, the
following macro may be used:
<BR><BR><TT>WCValSkipListItemSize( Type, num_of_pointers )</TT>
<DT>Results:
<DD>The<TT> WCValSkipList&lt;Type&gt;</TT> constructor creates an initialized<TT> WCValSkipList</TT> object.
<DT>See Also:
<DD><TT> ~WCValSkipList&lt;Type&gt;</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCValSkipList( const WCValSkipList &amp; );</TT>
<DT>Semantics:
<DD>The<TT> WCValSkipList&lt;Type&gt;</TT> constructor is the copy constructor for the<TT> WCValSkipList</TT> class.&nbsp; The
new skip list is created with the same probability and maximum pointers, all values or pointers stored in the list, and the
exception trap states.&nbsp; If there is not enough memory to copy all of the values, then only some will be copied, and the
number of entries will correctly reflect the number copied.&nbsp; If all of the elements cannot be copied, then the<TT> out_of_memory</TT>
exception is thrown if it is enabled.
<DT>Results:
<DD>The<TT> WCValSkipList&lt;Type&gt;</TT> constructor creates a<TT> WCValSkipList</TT> object which is a copy of the passed list.
<DT>See Also:
<DD><TT> operator =</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<H2 ID="WCValSkipListXTypeY____WCValSkipListLR"> ~WCValSkipList() [WCValSkipList&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>virtual ~WCValSkipList();</TT>
<DT>Semantics:
<DD>The<TT> WCValSkipList&lt;Type&gt;</TT> destructor is the destructor for the<TT> WCValSkipList</TT> class.&nbsp; If the number
of elements is not zero and the<TT> not_empty</TT> exception is enabled, the exception is thrown.&nbsp; Otherwise, the list
elements are cleared using the<TT> clear</TT> member function.&nbsp; The call to the<TT> WCValSkipList&lt;Type&gt;</TT> destructor
is inserted implicitly by the compiler at the point where the<TT> WCValSkipList</TT> object goes out of scope.
<DT>Results:
<DD>The call to the<TT> WCValSkipList&lt;Type&gt;</TT> destructor destroys a<TT> WCValSkipList</TT> object.
<DT>See Also:
<DD><TT> clear</TT>,<TT> WCExcept::not_empty</TT>
</DL>
<H2 ID="WCValSkipListXTypeY__clearLR__WCValSkipListSetXTypeY__clearLR"> clear() [WCValSkipList&lt;Type&gt;,WCValSkipListSet&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void clear();</TT>
<DT>Semantics:
<DD>The<TT> clear</TT> public member function is used to clear the list so that it has no entries.&nbsp; Elements stored in the
list are destroyed using the destructors of<TT> Type.</TT>&nbsp; The list object is not destroyed and re-created by this function,
so the object destructor is not invoked.
<DT>Results:
<DD>The<TT> clear</TT> public member function clears the list to have no elements.
<DT>See Also:
<DD><TT> ~WCValSkipList&lt;Type&gt;</TT>,<TT> operator =</TT>
</DL>
<H2 ID="WCValSkipListXTypeY__containsLR__WCValSkipListSetXTypeY__containsLR"> contains() [WCValSkipList&lt;Type&gt;,WCValSkipListSet&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int contains( const Type &amp; ) const;</TT>
<DT>Semantics:
<DD>The<TT> contains</TT> public member function returns non-zero if the element is stored in the list, or zero if there is no
equivalent element.&nbsp; Note that equivalence is based on the equivalence operator of the element type.
<DT>Results:
<DD>The<TT> contains</TT> public member function returns a non-zero value if the element is found in the list.
<DT>See Also:
<DD><TT> find</TT>
</DL>
<H2 ID="WCValSkipListXTypeY__entriesLR__WCValSkipListSetXTypeY__entriesLR"> entries() [WCValSkipList&lt;Type&gt;,WCValSkipListSet&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>unsigned entries() const;</TT>
<DT>Semantics:
<DD>The<TT> entries</TT> public member function is used to return the current number of elements stored in the list.
<DT>Results:
<DD>The<TT> entries</TT> public member function returns the number of elements in the list.
<DT>See Also:
<DD><TT> isEmpty</TT>
</DL>
<H2 ID="WCValSkipListXTypeY__findLR__WCValSkipListSetXTypeY__findLR"> find() [WCValSkipList&lt;Type&gt;,WCValSkipListSet&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int find( const Type &amp;, Type &amp; ) const;</TT>
<DT>Semantics:
<DD>The<TT> find</TT> public member function is used to find an element with an equivalent value in the list.&nbsp; If an equivalent
element is found, a non-zero value is returned.&nbsp; The reference to the element passed as the second argument is assigned
the found element's value.&nbsp; Zero is returned if the element is not found.&nbsp; Note that equivalence is based on the
equivalence operator of the element type.
<DT>Results:
<DD>The element equivalent to the passed value is located in the list.
</DL>
<H2 ID="WCValSkipListXTypeY__forAllLR__WCValSkipListSetXTypeY__forAllLR"> forAll() [WCValSkipList&lt;Type&gt;,WCValSkipListSet&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void forAll(</TT>
<BR><TT> void (*user_fn)( Type, void * ),</TT>
<BR><TT>void * );</TT>
<DT>Semantics:
<DD>The<TT> forAll</TT> public member function causes the user supplied function to be invoked for every value in the list.&nbsp;
The user function has the prototype
<BR><BR><TT>void user_func( Type &amp; value, void * data );</TT>
<BR><BR>As the elements are visited, the user function is invoked with the element passed as the first.&nbsp; The second parameter
of the<TT> forAll</TT> function is passed as the second parameter to the user function.&nbsp; This value can be used to pass
any appropriate data from the main code to the user function.
<DT>Results:
<DD>The elements in the list are all visited, with the user function being invoked for each one.
<DT>See Also:
<DD><TT> find</TT>
</DL>
<H2 ID="WCValSkipListXTypeY__insertLR__WCValSkipListSetXTypeY__insertLR"> insert() [WCValSkipList&lt;Type&gt;,WCValSkipListSet&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int insert( const Type &amp; );</TT>
<DT>Semantics:
<DD>The<TT> insert</TT> public member function inserts a value into the list.&nbsp; If allocation of the node to store the value
fails, then the<TT> out_of_memory</TT> exception is thrown if it is enabled.&nbsp; If the exception is not enabled, the insert
will not be completed.
<BR><BR>With a<TT> WCValSkipListSet,</TT> there must be only one equivalent element in the set.&nbsp; If an element equivalent
to the inserted element is already in the list set, the list set will remain unchanged, and the<TT> not_unique</TT> exception
is thrown if it is enabled.&nbsp; If the exception is not enabled, the insert will not be completed.
<DT>Results:
<DD>The<TT> insert</TT> public member function inserts a value into the list.&nbsp; If the insert is successful, a non-zero will
returned.&nbsp; A zero will be returned if the insert fails.
<DT>See Also:
<DD><TT> operator =</TT>,<TT> WCExcept::out_of_memory</TT>,<TT> WCExcept::not_unique</TT>
</DL>
<H2 ID="WCValSkipListXTypeY__isEmptyLR__WCValSkipListSetXTypeY__isEmptyLR"> isEmpty() [WCValSkipList&lt;Type&gt;,WCValSkipListSet&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int isEmpty() const;</TT>
<DT>Semantics:
<DD>The<TT> isEmpty</TT> public member function is used to determine if the list is empty.
<DT>Results:
<DD>The<TT> isEmpty</TT> public member function returns zero if it contains at least one entry, non-zero if the list is empty.
<DT>See Also:
<DD><TT> entries</TT>
</DL>
<H2 ID="WCValSkipListXTypeY__occurrencesOfLR"> occurrencesOf() [WCValSkipList&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>unsigned occurrencesOf( const Type &amp; ) const;</TT>
<DT>Semantics:
<DD>The<TT> occurrencesOf</TT> public member function is used to return the current number of elements stored in the list which
are equivalent to the passed value.&nbsp; Note that equivalence is based on the equivalence operator of the element type.
<DT>Results:
<DD>The<TT> occurrencesOf</TT> public member function returns the number of elements in the list which are equivalent to the passed
value.
<DT>See Also:
<DD><TT> entries</TT>,<TT> find</TT>,<TT> isEmpty</TT>
</DL>
<H2 ID="WCValSkipListXTypeY__operator_ELR__WCValSkipListSetXTypeY__operator_ELR"> operator =() [WCValSkipList&lt;Type&gt;,WCValSkipListSet&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCValSkipList &amp; operator =( const WCValSkipList &amp; );</TT>
<BR><TT> WCValSkipListSet &amp; operator =( const WCValSkipListSet &amp; );</TT>
<DT>Semantics:
<DD>The<TT> operator =</TT> public member function is the assignment operator for the<TT> WCValSkipList&lt;Type&gt;</TT> and<TT>
WCValSkipListSet&lt;Type&gt;</TT> classes.&nbsp; The left hand side list is first cleared using the<TT> clear</TT> member
function, and then the right hand side list is copied.&nbsp; The list function, exception trap states, and all of the list
elements are copied.&nbsp; If there is not enough memory to copy all of the values or pointers in the list, then only some
will be copied, and the<TT> out_of_memory</TT> exception is thrown if it is enabled.&nbsp; The number of entries will correctly
reflect the number copied.
<DT>Results:
<DD>The<TT> operator =</TT> public member function assigns the left hand side list to be a copy of the right hand side.
<DT>See Also:
<DD><TT> clear</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<H2 ID="WCValSkipListXTypeY__operator_EELR__WCValSkipListSetXTypeY__operator_EELR"> operator ==() [WCValSkipList&lt;Type&gt;,WCValSkipListSet&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int operator ==( const WCValSkipList &amp; ) const;</TT>
<BR><TT> int operator ==( const WCValSkipListSet &amp; ) const;</TT>
<DT>Semantics:
<DD>The<TT> operator ==</TT> public member function is the equivalence operator for the<TT> WCValSkipList&lt;Type&gt;</TT> and<TT>
WCValSkipListSet&lt;Type&gt;</TT> classes.&nbsp; Two list objects are equivalent if they are the same object and share the
same address.
<DT>Results:
<DD>A TRUE (non-zero) value is returned if the left hand side and right hand side list are the same object.&nbsp; A FALSE (zero)
value is returned otherwise.
</DL>
<H2 ID="WCValSkipListXTypeY__removeLR__WCValSkipListSetXTypeY__removeLR"> remove() [WCValSkipList&lt;Type&gt;,WCValSkipListSet&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int remove( const Type &amp; );</TT>
<DT>Semantics:
<DD>The<TT> remove</TT> public member function is used to remove the specified element from the list.&nbsp; If an equivalent element
is found, a non-zero value is returned.&nbsp; Zero is returned if the element is not found.&nbsp; If the list is a<TT> WCValSkipList</TT>
and there is more than one element equivalent to the specified element, then the last equivalent element added to the<TT>
WCValSkipList</TT> is removed.&nbsp; Note that equivalence is based on the equivalence operator of the element type.
<DT>Results:
<DD>The element is removed from the list.
</DL>
<H2 ID="WCValSkipListXTypeY__removeAllLR"> removeAll() [WCValSkipList&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcskip.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>unsigned removeAll( const Type &amp; );</TT>
<DT>Semantics:
<DD>The<TT> removeAll</TT> public member function is used to remove all elements equivalent to the specified element from the
list.&nbsp; Zero is returned if no equivalent elements are found.&nbsp; Note that equivalence is based on the equivalence
operator of the element type.
<DT>Results:
<DD>All equivalent elements are removed from the list.
</DL>
<H1 ID="Stack_Container"> Stack Container </H1>
<BR>Stack containers maintain an ordered collection of data which is retrieved in the reverse order to which the data was
entered into the stack.&nbsp; The stack class is implemented as a templated class, allowing the stacking of any data type.
<BR><BR>A second template parameter specifies the storage class used to implement the stack.&nbsp; The<TT> WCValSList, WCIsvSList</TT>
and<TT> WCPtrSList</TT> classes are appropriate storage classes.
<H2 ID="WCStackXType_FTypeY_Class_Description"> WCStack&lt;Type,FType&gt; Class Description </H2>
<DL>
<DT>Declared:
<DD><TT> wcstack.h</TT>
<BR><BR>The<TT> WCStack&lt;Type,FType&gt;</TT> class is a templated class used to create objects which maintain data in a
stack.
<BR>In the description of each member function, the text<TT> Type</TT> is used to indicate the template parameter defining
the type of the elements stored in the stack.&nbsp; The text<TT> FType</TT> is used to indicate the template parameter defining
the storage class used to maintain the stack.
<BR><BR>For example, to create a stack of integers, the<TT> WCStack&lt;int,WCValSList&lt;int&gt; &gt;</TT> class can be used.
&nbsp;The<TT> WCStack&lt;int *,WCPtrSList&lt;int&gt; &gt;</TT> class will create a stack of pointers to integers.&nbsp; To
create an intrusive stack of objects of type<B> isv_link</B> (derived from the<TT> WCSLink</TT> class), the<TT> WCStack&lt;</TT><B>
isv_link</B><TT> *,WCIsvSList&lt;</TT><B> isv_link</B><TT> &gt; &gt;</TT> class can be used.
<BR><BR>The<TT> WCExcept</TT> class is a base class of the<TT> WCStack&lt;Type,FType&gt;</TT> class and provides the<TT> exceptions</TT>
member function.&nbsp; This member function controls the exceptions which can be thrown by the<TT> WCStack&lt;Type,FType&gt;</TT>
object.&nbsp; No exceptions are enabled unless they are set by the<TT> exceptions</TT> member function.
<BR><BR><B>Requirements of Type</B>
<BR><BR><TT>Type</TT> must provide any constructors and/or operators required by the<TT> FType</TT> class.
<BR><BR><B>Public Member Functions</B>
<BR><BR>The following member functions are declared in the public interface:
<BR><BR><TT>WCStack();</TT>
<BR><TT> WCStack( void *(*)( size_t ), void (*)( void *, size_t ) );</TT>
<BR><TT> ~WCStack();</TT>
<BR><TT> void clear();</TT>
<BR><TT> int entries() const;</TT>
<BR><TT> int isEmpty() const;</TT>
<BR><TT> Type pop();</TT>
<BR><TT> int push( const Type &amp; );</TT>
<BR><TT> Type top() const;</TT>
<BR><BR><B>Sample Program Using a Stack</B>
<BR><BR><TT>#include &lt;wcstack.h&gt;</TT>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><BR><TT>void main() {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; WCStack&lt;int,WCValSList&lt;int&gt; &gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stack;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; stack.push( 7 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; stack.push( 8 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; stack.push( 9 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; stack.push( 10 );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; cout &lt;&lt; &quot;\nNumber of stack entries: &quot; &lt;&lt; stack.entries() &lt;&lt; &quot;\n&quot;;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; cout &lt;&lt; &quot;Top entry = [&quot; &lt;&lt; stack.top() &lt;&lt; &quot;]\n&quot;;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; while( !stack.isEmpty() ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; stack.pop() &lt;&lt; &quot;\n&quot;;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; cout.flush();</TT>
<BR><TT>}</TT>
</DL>
<H2 ID="WCStackXType_FTypeY__WCStackLR"> WCStack() [WCStack&lt;Type,FType&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcstack.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCStack();</TT>
<DT>Semantics:
<DD>The public<TT> WCStack&lt;Type,FType&gt;</TT> constructor creates an empty<TT> WCStack&lt;Type,FType&gt;</TT> object.&nbsp;
The<TT> FType</TT> storage class constructor performs the initialization.
<DT>Results:
<DD>The public<TT> WCStack&lt;Type,FType&gt;</TT> constructor creates an initialized<TT> WCStack&lt;Type,FType&gt;</TT> object.
<DT>See Also:
<DD><TT> ~WCStack&lt;Type,FType&gt;</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcstack.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCStack( void *(*allocator)( size_t ),</TT>
<BR><TT> void (*deallocator)( void *, size_t ) );</TT>
<DT>Semantics:
<DD>The public<TT> WCStack&lt;Type,FType&gt;</TT> constructor creates an empty<TT> WCStack&lt;Type,FType&gt;</TT> object.&nbsp;
If<TT> FType</TT> is either the<TT> WCValSList</TT> or<TT> WCPtrSList</TT> class, then the<B> allocator</B> function is registered
to perform all memory allocations of the stack elements, and the<B> deallocator</B> function to perform all freeing of the
stack elements' memory.&nbsp; The<B> allocator</B> and<B> deallocator</B> functions are ignored if<TT> FType</TT> is the<TT>
WCIsvSList</TT> class.&nbsp; These functions provide the ability to control how the allocation and freeing of memory is performed,
allowing for more efficient memory handling than the general purpose global<TT> operator new()</TT> and<TT> operator delete()</TT>
can provide.&nbsp; Memory management optimizations may potentially be made through the<B> allocator</B> and<B> deallocator</B>
functions, but are not recommended before managing memory is understood and determined to be worth while.
<BR><BR>The<B> allocator</B> function shall return a pointer to allocated memory of size at least the argument, or zero(0)
if the allocation cannot be performed.&nbsp; Initialization of the memory returned is performed by the<TT> WCStack&lt;Type,FType&gt;</TT>
class.
<BR><BR>The<TT> WCStack&lt;Type,FType&gt;</TT> class calls the<B> deallocator</B> function only on memory allocated by the<B>
allocator</B> function.&nbsp; The<B> deallocator</B> shall free the memory pointed to by the first argument which is of size
the second argument.&nbsp; The size passed to the<B> deallocator</B> function is guaranteed to be the same size passed to
the<B> allocator</B> function when the memory was allocated.
<BR><BR>The<B> allocator</B> and<B> deallocator</B> functions may assume that for a list object instance, the<B> allocator</B>
is always called with the same first argument (the size of the memory to be allocated).&nbsp; If<TT> FType</TT> is the<TT>
WCValSList&lt;Type&gt;</TT> class, then the<TT> WCValSListItemSize(Type)</TT> macro returns the size of the elements which
are allocated by the<B> allocator</B> function.&nbsp; Similarly, the<TT> WCPtrSListItemSize( Type )</TT> macro returns the
size of<TT> WCPtrSList&lt;Type&gt;</TT> elements.
<BR><BR>The<TT> FType</TT> storage class constructor performs the initialization of the stack.
<DT>Results:
<DD>The public<TT> WCStack&lt;Type,FType&gt;</TT> constructor creates an initialized<TT> WCStack&lt;Type,FType&gt;</TT> object
and registers the<B> allocator</B> and<B> deallocator</B> functions.
<DT>See Also:
<DD><TT> WCStack&lt;Type,FType&gt;</TT>,<TT> ~WCStack&lt;Type,FType&gt;</TT>
</DL>
<H2 ID="WCStackXType_FTypeY____WCStackLR"> ~WCStack() [WCStack&lt;Type,FType&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcstack.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>virtual ~WCStack();</TT>
<DT>Semantics:
<DD>The public<TT> ~WCStack&lt;Type,FType&gt;</TT> destructor destroys the<TT> WCStack&lt;Type,FType&gt;</TT> object.&nbsp; The<TT>
FType</TT> storage class destructor performs the destruction.&nbsp; The call to the public<TT> ~WCStack&lt;Type,FType&gt;</TT>
destructor is inserted implicitly by the compiler at the point where the<TT> WCStack&lt;Type,FType&gt;</TT> object goes out
of scope.
<BR><BR>If the<TT> not_empty</TT> exception is enabled, the exception is thrown if the stack is not empty of stack elements.
<DT>Results:
<DD>The<TT> WCStack&lt;Type,FType&gt;</TT> object is destroyed.
<DT>See Also:
<DD><TT> WCStack&lt;Type,FType&gt;</TT>,<TT> clear</TT>,<TT> WCExcept::not_empty</TT>
</DL>
<H2 ID="WCStackXType_FTypeY__clearLR"> clear() [WCStack&lt;Type,FType&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcstack.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void clear();</TT>
<DT>Semantics:
<DD>The<TT> clear</TT> public member function is used to clear the stack object and set it to the state of the object just after
the initial construction.&nbsp; The stack object is not destroyed and re-created by this operator, so the object destructor
is not invoked.&nbsp; The stack elements are not cleared by the stack class.&nbsp; However, the class used to maintain the
stack,<TT> FType,</TT> may clear the items as part of the<TT> clear</TT> member function for that class.&nbsp; If it does
not clear the items, any stack items still in the list are lost unless pointed to by some pointer object in the program code.
<DT>Results:
<DD>The<TT> clear</TT> public member function resets the stack object to the state of the object immediately after the initial
construction.
<DT>See Also:
<DD><TT> ~WCStack&lt;Type,FType&gt;</TT>,<TT> isEmpty</TT>
</DL>
<H2 ID="WCStackXType_FTypeY__entriesLR"> entries() [WCStack&lt;Type,FType&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcstack.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int entries() const;</TT>
<DT>Semantics:
<DD>The<TT> entries</TT> public member function is used to determine the number of stack elements contained in the list object.
<DT>Results:
<DD>The number of elements on the stack is returned.&nbsp; Zero(0) is returned if there are no stack elements.
<DT>See Also:
<DD><TT> isEmpty</TT>
</DL>
<H2 ID="WCStackXType_FTypeY__isEmptyLR"> isEmpty() [WCStack&lt;Type,FType&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcstack.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int isEmpty() const;</TT>
<DT>Semantics:
<DD>The<TT> isEmpty</TT> public member function is used to determine if a stack object has any stack elements contained in it.
<DT>Results:
<DD>A TRUE value (non-zero) is returned if the stack object does not have any stack elements contained within it.&nbsp; A FALSE
(zero) result is returned if the stack contains at least one element.
<DT>See Also:
<DD><TT> entries</TT>
</DL>
<H2 ID="WCStackXType_FTypeY__popLR"> pop() [WCStack&lt;Type,FType&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcstack.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Type pop();</TT>
<DT>Semantics:
<DD>The<TT> pop</TT> public member function returns the top stack element from the stack object.&nbsp; The top stack element is
the last element pushed onto the stack.&nbsp; The stack element is also removed from the stack.
<BR><BR>If the stack is empty, one of two exceptions can be thrown.&nbsp; If the<TT> empty_container</TT> exception is enabled,
then it will be thrown.&nbsp; Otherwise, the<TT> index_range</TT> exception will be thrown, if enabled.
<DT>Results:
<DD>The top stack element is removed and returned.&nbsp; The return value is determined by the<TT> get</TT> member function of
the<TT> FType</TT> class if there are no elements on the stack.
<DT>See Also:
<DD><TT> isEmpty</TT>,<TT> push</TT>,<TT> top</TT>,<TT> WCExcept::empty_container</TT>,<TT> WCExcept::index_range</TT>,<TT> FType::get</TT>
</DL>
<H2 ID="WCStackXType_FTypeY__pushLR"> push() [WCStack&lt;Type,FType&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcstack.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int push( const Type &amp; );</TT>
<DT>Semantics:
<DD>The<TT> push</TT> public member function is used to push the data onto the top of the stack.&nbsp; It will be the first element
on the stack to be popped.
<BR><BR>If the push fails, the<TT> out_of_memory</TT> exception will be thrown, if enabled, and the stack will remain unchanged.
<DT>Results:
<DD>The stack element is pushed onto the top of the stack.&nbsp; A TRUE value (non-zero) is returned if the push is successful.
&nbsp;A FALSE (zero) result is returned if the push fails.
<DT>See Also:
<DD><TT> pop</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<H2 ID="WCStackXType_FTypeY__topLR"> top() [WCStack&lt;Type,FType&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcstack.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Type top() const;</TT>
<DT>Semantics:
<DD>The<TT> top</TT> public member function returns the top stack element from the stack object.&nbsp; The top stack element is
the last element pushed onto the stack.&nbsp; The stack element is not removed from the stack.
<BR><BR>If the stack is empty, one of two exceptions can be thrown.&nbsp; If the<TT> empty_container</TT> exception is enabled,
then it will be thrown.&nbsp; Otherwise, the<TT> index_range</TT> exception will be thrown, if enabled.
<DT>Results:
<DD>The top stack element is returned.&nbsp; The return value is determined by the<TT> find</TT> member function of the<TT> FType</TT>
class if there are no elements on the stack.
<DT>See Also:
<DD><TT> isEmpty</TT>,<TT> pop</TT>,<TT> WCExcept::empty_container</TT>,<TT> WCExcept::index_range</TT>,<TT> FType::find</TT>
</DL>
<H1 ID="Vector_Containers"> Vector Containers </H1>
<BR>This chapter describes vector containers.
<H2 ID="WCPtrSortedVectorXTypeY__WCPtrOrderedVectorXTypeY_Class_Description"> WCPtrSortedVector&lt;Type&gt;, WCPtrOrderedVector&lt;Type&gt; Class Description </H2>
<DL>
<DT>Declared:
<DD><TT> wcvector.h</TT>
<BR><BR>The<TT> WCPtrSortedVector&lt;Type&gt;</TT> and<TT> WCPtrOrderedVector&lt;Type&gt;</TT> classes are templated classes
used to store objects in a vector.&nbsp; Ordered and Sorted vectors are powerful arrays which can be resized and provide an
abstract interface to insert, find and remove elements.&nbsp; An ordered vector maintains the order in which elements are
added, and allows more than one copy of an element that is equivalent.&nbsp; The sorted vector allow only one copy of an equivalent
element, and inserts them in a sorted order.&nbsp; The sorted vector is less efficient when inserting elements, but can provide
a faster retrieval time.
<BR>Elements cannot be inserted into these vectors by assigning to a vector index.&nbsp; Vectors automatically grow when necessary
to insert an element if the<TT> resize_required</TT> exception is not enabled.
<BR><BR>In the description of each member function, the text<TT> Type</TT> is used to indicate the template parameter defining
the type pointed to by the pointers stored in the vector.
<BR><BR>Note that lookups are performed on the types pointed to, not just by comparing pointers.&nbsp; Two pointer elements
are equivalent if the values they point to are equivalent.&nbsp; The values pointed to do not need to be the same object.
<BR><BR>The<TT> WCPtrOrderedVector</TT> class stores elements in the order which they are inserted using the<TT> insert, append,
prepend</TT> and<TT> insertAt</TT> member functions.&nbsp; Linear searches are performed to locate entries, and the less than
operator is not required.
<BR><BR>The<TT> WCPtrSortedVector</TT> class stores elements in ascending order.&nbsp; This requires that<TT> Type</TT> provides
a less than operator.&nbsp; Insertions are more expensive than inserting or appending into an ordered vector, since entries
must be moved to make room for the new element.&nbsp; A binary search is used to locate elements in a sorted vector, making
searches quicker than in the ordered vector.
<BR><BR>Care must be taken when using the<TT> WCPtrSortedVector</TT> class not to change the ordering of the vector elements.
&nbsp;An object pointed to by a vector element must not be changed so that it is not equivalent to the value when the pointer
was inserted into the vector.&nbsp; The index operator and the member functions<TT> find, first,</TT> and<TT> last</TT> all
return pointers the elements pointed to by the vector elements.&nbsp; Lookups assume elements are in sorted order, so you
should not use the returned pointers to change the ordering of the value pointed to.
<BR><BR>The<TT> WCPtrVector</TT> class is also available.&nbsp; It provides a resizable and boundary safe vector similar to
standard arrays.
<BR><BR>The<TT> WCExcept</TT> class is a base class of the<TT> WCPtrSortedVector&lt;Type&gt;</TT> and<TT> WCPtrOrderedVector&lt;Type&gt;</TT>
classes and provides the<TT> exceptions</TT> member function.&nbsp; This member function controls the exceptions which can
be thrown by the<TT> WCPtrSortedVector&lt;Type&gt;</TT> and<TT> WCPtrOrderedVector&lt;Type&gt;</TT> objects.&nbsp; No exceptions
are enabled unless they are set by the<TT> exceptions</TT> member function.
<BR><BR><B>Requirements of Type</B>
<BR><BR>Both the<TT> WCPtrSortedVector&lt;Type&gt;</TT> and<TT> WCPtrOrderedVector&lt;Type&gt;</TT> classes require<TT> Type</TT>
to have:
<BR>A well defined equivalence operator with constant parameters
<BR><BR>(<TT> int operator ==( const Type &amp; ) const</TT> ).
<BR>Additionally the<TT> WCPtrSortedVector</TT> class requires<TT> Type</TT> to have:
<BR><BR>A well defined less than operator with constant parameters
<BR><BR>(<TT> int operator &lt;( const Type &amp; ) const</TT> ).
<BR><BR><B>Public Member Functions</B>
<BR><BR>The following member functions are declared in the public interface:
<BR><BR><TT>WCPtrOrderedVector( size_t = WCDEFAULT_VECTOR_LENGTH, unsigned = WCDEFAULT_VECTOR_RESIZE_GROW );</TT>
<BR><TT> WCPtrOrderedVector( const WCPtrOrderedVector &amp; );</TT>
<BR><TT> virtual ~WCPtrOrderedVector();</TT>
<BR><TT> WCPtrSortedVector( size_t = WCDEFAULT_VECTOR_LENGTH, unsigned = WCDEFAULT_VECTOR_RESIZE_GROW );</TT>
<BR><TT> WCPtrSortedVector( const WCPtrSortedVector &amp; );</TT>
<BR><TT> virtual ~WCPtrSortedVector();</TT>
<BR><TT> void clear();</TT>
<BR><TT> void clearAndDestroy();</TT>
<BR><TT> int contains( const Type * ) const;</TT>
<BR><TT> unsigned entries() const;</TT>
<BR><TT> Type * find( const Type * ) const;</TT>
<BR><TT> Type * first() const;</TT>
<BR><TT> int index( const Type * ) const;</TT>
<BR><TT> int insert( Type * );</TT>
<BR><TT> int isEmpty() const;</TT>
<BR><TT> Type * last() const;</TT>
<BR><TT> int occurrencesOf( const Type * ) const;</TT>
<BR><TT> Type * remove( const Type * );</TT>
<BR><TT> unsigned removeAll( const Type * );</TT>
<BR><TT> Type * removeAt( int );</TT>
<BR><TT> Type * removeFirst();</TT>
<BR><TT> Type * removeLast();</TT>
<BR><TT> int resize( size_t );</TT>
<BR><BR>The following public member functions are available for the<TT> WCPtrOrderedVector</TT> class only:
<BR><BR><TT>int append( Type * );</TT>
<BR><TT> int insertAt( int, Type * );</TT>
<BR><TT> int prepend( Type * );</TT>
<BR><BR><B>Public Member Operators</B>
<BR><BR>The following member operators are declared in the public interface:
<BR><BR><TT>Type * &amp; operator []( int );</TT>
<BR><TT> Type * const &amp; operator []( int ) const;</TT>
<BR><TT> WCPtrOrderedVector &amp; WCPtrOrderedVector::operator =( const WCPtrOrderedVector &amp; );</TT>
<BR><TT> WCPtrSortedVector &amp; WCPtrSortedVector::operator =( const WCPtrSortedVector &amp; );</TT>
<BR><TT> int WCPtrOrderedVector::operator ==( const WCPtrOrderedVector &amp; ) const;</TT>
<BR><TT> int WCPtrSortedVector::operator ==( const WCPtrSortedVector &amp; ) const;</TT>
</DL>
<H2 ID="WCPtrOrderedVectorXTypeY__WCPtrOrderedVectorLR"> WCPtrOrderedVector() [WCPtrOrderedVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCPtrOrderedVector( size_t = WCDEFAULT_VECTOR_LENGTH,</TT>
<BR><TT> unsigned = WCDEFAULT_VECTOR_RESIZE_GROW );</TT>
<DT>Semantics:
<DD>The<TT> WCPtrOrderedVector&lt;Type&gt;</TT> constructor creates an empty<TT> WCPtrOrderedVector</TT> object able to store
the number of elements specified in the first optional parameter, which defaults to the constant<TT> WCDEFAULT_VECTOR_LENGTH</TT>
(currently defined as 10).&nbsp; If the<TT> resize_required</TT> exception is not enabled, then the second optional parameter
is used to specify the value to increase the vector size when an element is inserted into a full vector.&nbsp; If zero(0)
is specified as the second parameter, any attempt to insert into a full vector fails.&nbsp; This parameter defaults to the
constant<TT> WCDEFAULT_VECTOR_RESIZE_GROW</TT> (currently defined as 5).
<BR><BR>If the vector object cannot be fully initialized, the vector is created with length zero.
<DT>Results:
<DD>The<TT> WCPtrOrderedVector&lt;Type&gt;</TT> constructor creates an empty initialized<TT> WCPtrOrderedVector</TT> object.
<DT>See Also:
<DD><TT> WCExcept::resize_required</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCPtrOrderedVector( const WCPtrOrderedVector &amp; );</TT>
<DT>Semantics:
<DD>The<TT> WCPtrOrderedVector&lt;Type&gt;</TT> constructor is the copy constructor for the<TT> WCPtrOrderedVector</TT> class.
&nbsp;The new vector is created with the same length and resize value as the passed vector.&nbsp; All of the vector elements
and exception trap states are copied.
<BR><BR>If the new vector cannot be fully created, it will have length zero.&nbsp; The<TT> out_of_memory</TT> exception is
thrown if enabled in the vector being copied.
<DT>Results:
<DD>The<TT> WCPtrOrderedVector&lt;Type&gt;</TT> creates a<TT> WCPtrOrderedVector</TT> object which is a copy of the passed vector.
<DT>See Also:
<DD><TT> operator =</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<H2 ID="WCPtrOrderedVectorXTypeY____WCPtrOrderedVectorLR"> ~WCPtrOrderedVector() [WCPtrOrderedVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>virtual ~WCPtrOrderedVector();</TT>
<DT>Semantics:
<DD>The<TT> WCPtrOrderedVector&lt;Type&gt;</TT> destructor is the destructor for the<TT> WCPtrOrderedVector</TT> class.&nbsp;
If the vector is not length zero and the<TT> not_empty</TT> exception is enabled, the exception is thrown.&nbsp; Otherwise,
the vector entries are cleared using the<TT> clear</TT> member function.&nbsp; The objects which the vector entries point
to are not deleted unless the<TT> clearAndDestroy</TT> member function is explicitly called before the destructor is called.
&nbsp;The call to the<TT> WCPtrOrderedVector&lt;Type&gt;</TT> destructor is inserted implicitly by the compiler at the point
where the<TT> WCPtrOrderedVector</TT> object goes out of scope.
<DT>Results:
<DD>The<TT> WCPtrOrderedVector&lt;Type&gt;</TT> destructor destroys an<TT> WCPtrOrderedVector</TT> object.
<DT>See Also:
<DD><TT> clear</TT>,<TT> clearAndDestroy</TT>,<TT> WCExcept::not_empty</TT>
</DL>
<H2 ID="WCPtrSortedVectorXTypeY__WCPtrSortedVectorLR"> WCPtrSortedVector() [WCPtrSortedVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCPtrSortedVector( size_t = WCDEFAULT_VECTOR_LENGTH,</TT>
<BR><TT> unsigned = WCDEFAULT_VECTOR_RESIZE_GROW );</TT>
<DT>Semantics:
<DD>The<TT> WCPtrSortedVector&lt;Type&gt;</TT> constructor creates an empty<TT> WCPtrSortedVector</TT> object able to store the
number of elements specified in the first optional parameter, which defaults to the constant<TT> WCDEFAULT_VECTOR_LENGTH</TT>
(currently defined as 10).&nbsp; If the<TT> resize_required</TT> exception is not enabled, then the second optional parameter
is used to specify the value to increase the vector size when an element is inserted into a full vector.&nbsp; If zero(0)
is specified as the second parameter, any attempt to insert into a full vector fails.&nbsp; This parameter defaults to the
constant<TT> WCDEFAULT_VECTOR_RESIZE_GROW</TT> (currently defined as 5).
<BR><BR>If the vector object cannot be fully initialized, the vector is created with length zero.
<DT>Results:
<DD>The<TT> WCPtrSortedVector&lt;Type&gt;</TT> constructor creates an empty initialized<TT> WCPtrSortedVector</TT> object.
<DT>See Also:
<DD><TT> WCExcept::resize_required</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCPtrSortedVector( const WCPtrSortedVector &amp; );</TT>
<DT>Semantics:
<DD>The<TT> WCPtrSortedVector&lt;Type&gt;</TT> constructor is the copy constructor for the<TT> WCPtrSortedVector</TT> class.&nbsp;
The new vector is created with the same length and resize value as the passed vector.&nbsp; All of the vector elements and
exception trap states are copied.
<BR><BR>If the new vector cannot be fully created, it will have length zero.&nbsp; The<TT> out_of_memory</TT> exception is
thrown if enabled in the vector being copied.
<DT>Results:
<DD>The<TT> WCPtrSortedVector&lt;Type&gt;</TT> constructor creates a<TT> WCPtrSortedVector</TT> object which is a copy of the
passed vector.
<DT>See Also:
<DD><TT> operator =</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<H2 ID="WCPtrSortedVectorXTypeY____WCPtrSortedVectorLR"> ~WCPtrSortedVector() [WCPtrSortedVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>virtual ~WCPtrSortedVector();</TT>
<DT>Semantics:
<DD>The<TT> WCPtrSortedVector&lt;Type&gt;</TT> destructor is the destructor for the<TT> WCPtrSortedVector</TT> class.&nbsp; If
the vector is not length zero and the<TT> not_empty</TT> exception is enabled, the exception is thrown.&nbsp; Otherwise, the
vector entries are cleared using the<TT> clear</TT> member function.&nbsp; The objects which the vector entries point to are
not deleted unless the<TT> clearAndDestroy</TT> member function is explicitly called before the destructor is called.&nbsp;
The call to the<TT> WCPtrSortedVector&lt;Type&gt;</TT> destructor is inserted implicitly by the compiler at the point where
the<TT> WCPtrSortedVector</TT> object goes out of scope.
<DT>Results:
<DD>The<TT> WCPtrSortedVector&lt;Type&gt;</TT> destructor destroys an<TT> WCPtrSortedVector</TT> object.
<DT>See Also:
<DD><TT> clear</TT>,<TT> clearAndDestroy</TT>,<TT> WCExcept::not_empty</TT>
</DL>
<H2 ID="WCPtrOrderedVectorXTypeY__appendLR"> append() [WCPtrOrderedVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int append( Type * );</TT>
<DT>Semantics:
<DD>The<TT> append</TT> public member function appends the passed element to be the last element in the vector.&nbsp; This member
function has the same semantics as the<TT> WCPtrOrderedVector::insert</TT> member function.
<BR><BR>This function is not provided by the<TT> WCPtrSortedVector</TT> class, since all elements must be inserted in sorted
order by the<TT> insert</TT> member function.
<BR><BR>Several different results can occur if the vector is not large enough for the new element.&nbsp; If the<TT> resize_required</TT>
exception is enabled, the exception is thrown.&nbsp; If the exception is not enabled, the append fails if the amount the vector
is to be grown (the second parameter to the constructor) is zero(0).&nbsp; Otherwise, the vector is automatically grown by
the number of elements specified to the constructor, using the<TT> resize</TT> member function.&nbsp; If<TT> resize</TT> fails,
the element is not appended to the vector and the<TT> out_of_memory</TT> exception is thrown, if enabled.
<DT>Results:
<DD>The<TT> append</TT> public member function appends an element to the<TT> WCPtrOrderedVector</TT> object.&nbsp; A TRUE (non-zero)
value is returned if the append is successful.&nbsp; If the append fails, a FALSE (zero) value is returned.
<DT>See Also:
<DD><TT> insert</TT>,<TT> insertAt</TT>,<TT> prepend</TT>,<TT> WCExcept::out_of_memory</TT>,<TT> WCExcept::resize_required</TT>
</DL>
<H2 ID="WCPtrSortedVectorXTypeY__clearLR__WCPtrOrderedVectorXTypeY__clearLR"> clear() [WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void clear();</TT>
<DT>Semantics:
<DD>The<TT> clear</TT> public member function is used to clear the vector so that it contains no entries, and is zero size.&nbsp;
Objects pointed to by the vector elements are not deleted.&nbsp; The vector object is not destroyed and re-created by this
function, so the object destructor is not invoked.
<DT>Results:
<DD>The<TT> clear</TT> public member function clears the vector to have zero length and no entries.
<DT>See Also:
<DD><TT> ~WCPtrOrderedVector</TT>,<TT> clearAndDestroy</TT>,<TT> operator =</TT>
</DL>
<H2 ID="WCPtrSortedVectorXTypeY_WCPtrOrderedVectorXTypeY__clearAndDestroyLR"> clearAndDestroy() [WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void clearAndDestroy();</TT>
<DT>Semantics:
<DD>The<TT> clearAndDestroy</TT> public member function is used to clear the vector to have zero length and delete the objects
pointed to by the vector elements.&nbsp; The vector object is not destroyed and re-created by this function, so the vector
object destructor is not invoked.
<DT>Results:
<DD>The<TT> clearAndDestroy</TT> public member function clears the vector by deleting the objects pointed to by the vector elements
and makes the vector zero length.
<DT>See Also:
<DD><TT> clear</TT>
</DL>
<H2 ID="WCPtrSortedVectorXTypeY_WCPtrOrderedVectorXTypeY__containsLR"> contains() [WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int contains( const Type * ) const;</TT>
<DT>Semantics:
<DD>The<TT> contains</TT> public member function is used to determine if a value is contained by a vector.&nbsp; Note that comparisons
are done on the objects pointed to, not the pointers themselves.&nbsp; A linear search is used by the<TT> WCPtrOrderedVector</TT>
class to find the value.&nbsp; The<TT> WCPtrSortedVector</TT> class uses a binary search.
<DT>Results:
<DD>The<TT> contains</TT> public member function returns a TRUE (non-zero) value if the element is found in the vector.&nbsp;
A FALSE (zero) value is returned if the vector does not contain the element.
<DT>See Also:
<DD><TT> index</TT>,<TT> find</TT>
</DL>
<H2 ID="WCPtrSortedVectorXTypeY__entriesLR__WCPtrOrderedVectorXTypeY__entriesLR"> entries() [WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>unsigned entries() const;</TT>
<DT>Semantics:
<DD>The<TT> entries</TT> public member function is used to find the number of elements which are stored in the vector.
<DT>Results:
<DD>The<TT> entries</TT> public member function returns the number of elements in the vector.
<DT>See Also:
<DD><TT> isEmpty</TT>
</DL>
<H2 ID="WCPtrSortedVectorXTypeY__findLR__WCPtrOrderedVectorXTypeY__findLR"> find() [WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Type * find( const Type * ) const;</TT>
<DT>Semantics:
<DD>The<TT> find</TT> public member function is used to find an element equivalent to the element passed.&nbsp; Note that comparisons
are done on the objects pointed to, not the pointers themselves.&nbsp; The<TT> WCPtrOrderedVector</TT> class uses a linear
search to find the element, and the<TT> WCPtrSortedVector</TT> class uses a binary search.
<DT>Results:
<DD>A pointer to the first equivalent element is returned.&nbsp; NULL(0) is returned if the element is not in the vector.
<DT>See Also:
<DD><TT> contains</TT>,<TT> first</TT>,<TT> index</TT>,<TT> last</TT>,<TT> occurrencesOf</TT>,<TT> remove</TT>
</DL>
<H2 ID="WCPtrSortedVectorXTypeY__firstLR__WCPtrOrderedVectorXTypeY__firstLR"> first() [WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Type * first() const;</TT>
<DT>Semantics:
<DD>The<TT> first</TT> public member function returns the first element in the vector.&nbsp; The element is not removed from the
vector.
<BR><BR>If the vector is empty, one of two exceptions can be thrown.&nbsp; The<TT> empty_container</TT> exception is thrown
if it is enabled.&nbsp; Otherwise, if the<TT> index_range</TT> exception is enabled, it is thrown.&nbsp; If neither exception
is enabled, a first element of the vector is added with a NULL value.
<DT>Results:
<DD>The<TT> first</TT> public member function returns the value of the first element in the vector.
<DT>See Also:
<DD><TT> last</TT>,<TT> removeFirst</TT>,<TT> WCExcept::index_range</TT>,<TT> WCExcept::resize_required</TT>
</DL>
<H2 ID="WCPtrSortedVectorXTypeY__indexLR__WCPtrOrderedVectorXTypeY__indexLR"> index() [WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int index( const Type * ) const;</TT>
<DT>Semantics:
<DD>The<TT> index</TT> public member function is used find the index of the first element equivalent to the passed element.&nbsp;
Note that comparisons are done on the objects pointed to, not the pointers themselves.&nbsp; A linear search is used by the<TT>
WCPtrOrderedVector</TT> class to find the element.&nbsp; The<TT> WCPtrSortedVector</TT> class uses a binary search.
<DT>Results:
<DD>The<TT> index</TT> public member function returns the index of the first element equivalent to the parameter.&nbsp; If the
passed value is not contained in the vector, negative one (-1) is returned.
<DT>See Also:
<DD><TT> contains</TT>,<TT> find</TT>,<TT> insertAt</TT>,<TT> operator []</TT>,<TT> removeAt</TT>
</DL>
<H2 ID="WCPtrSortedVectorXTypeY__insertLR__WCPtrOrderedVectorXTypeY__insertLR"> insert() [WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int insert( Type * );</TT>
<DT>Semantics:
<DD>The<TT> insert</TT> public member function inserts the value into the vector.
<BR><BR>The<TT> WCPtrOrderedVector::insert</TT> function inserts the value as the last element of the vector, and has the
same semantics as the<TT> WCPtrOrderedVector::append</TT> member function.
<BR><BR>A binary search is performed to determine where the value should be inserted for the<TT> WCPtrSortedVector::insert</TT>
function.&nbsp; Note that comparisons are done on the objects pointed to, not the pointers themselves.&nbsp; Any elements
greater than the inserted value are copied up one index so that the new element is after all elements with value less than
or equal to it.
<BR><BR>Several different results can occur if the vector is not large enough for the new element.&nbsp; If the<TT> resize_required</TT>
exception is enabled, the exception is thrown.&nbsp; If the exception is not enabled, the insert fails if the amount the vector
is to be grown (the second parameter to the constructor) is zero(0).&nbsp; Otherwise, the vector is automatically grown by
the number of elements specified to the constructor, using the<TT> resize</TT> member function.&nbsp; If<TT> resize</TT> fails,
the element is not inserted to the vector and the<TT> out_of_memory</TT> exception is thrown, if enabled.
<DT>Results:
<DD>The<TT> insert</TT> public member function inserts an element in to the vector.&nbsp; A TRUE (non-zero) value is returned
if the insert is successful.&nbsp; If the insert fails, a FALSE (zero) value is returned.
<DT>See Also:
<DD><TT> append</TT>,<TT> insertAt</TT>,<TT> prepend</TT>,<TT> WCExcept::out_of_memory</TT>,<TT> WCExcept::resize_required</TT>
</DL>
<H2 ID="WCPtrOrderedVectorXTypeY__insertAtLR"> insertAt() [WCPtrOrderedVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int insertAt( int, Type * );</TT>
<DT>Semantics:
<DD>The<TT> insertAt</TT> public member function inserts the second argument into the vector before the element at index given
by the first argument.&nbsp; If the passed index is equal to the number of entries in the vector, the new value is appended
to the vector as the last element.&nbsp; All vector elements with indexes greater than or equal to the first parameter are
copied up one index.
<BR><BR>This function is not provided by the<TT> WCPtrSortedVector</TT> class, since all elements must be inserted in sorted
order by the<TT> insert</TT> member function.
<BR><BR>If the passed index is negative or greater than the number of entries in the vector and the<TT> index_range</TT> exception
is enabled, the exception is thrown.&nbsp; If the exception is not enabled, the new element is inserted as the first element
when the index is negative, or as the last element when the index is too large.
<BR><BR>Several different results can occur if the vector is not large enough for the new element.&nbsp; If the<TT> resize_required</TT>
exception is enabled, the exception is thrown.&nbsp; If the exception is not enabled, the insert fails if the amount the vector
is to be grown (the second parameter to the constructor) is zero(0).&nbsp; Otherwise, the vector is automatically grown by
the number of elements specified to the constructor, using the<TT> resize</TT> member function.&nbsp; If<TT> resize</TT> fails,
the element is not inserted into the vector and the<TT> out_of_memory</TT> exception is thrown, if enabled.
<DT>Results:
<DD>The<TT> insertAt</TT> public member function inserts an element into the<TT> WCPtrOrderedVector</TT> object before the element
at the given index.&nbsp; A TRUE (non-zero) value is returned if the insert is successful.&nbsp; If the insert fails, a FALSE
(zero) value is returned.
<DT>See Also:
<DD><TT> append</TT>,<TT> insert</TT>,<TT> prepend</TT>,<TT> operator []</TT>,<TT> removeAt</TT>,<TT> WCExcept::index_range</TT>,<TT>
WCExcept::out_of_memory</TT>,<TT> WCExcept::resize_required</TT>
</DL>
<H2 ID="WCPtrSortedVectorXTypeY_WCPtrOrderedVectorXTypeY__isEmptyLR"> isEmpty() [WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int isEmpty() const;</TT>
<DT>Semantics:
<DD>The<TT> isEmpty</TT> public member function is used to determine if a vector object has any entries contained in it.
<DT>Results:
<DD>A TRUE value (non-zero) is returned if the vector object does not have any vector elements contained within it.&nbsp; A FALSE
(zero) result is returned if the vector contains at least one element.
<DT>See Also:
<DD><TT> entries</TT>
</DL>
<H2 ID="WCPtrSortedVectorXTypeY__lastLR__WCPtrOrderedVectorXTypeY__lastLR"> last() [WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Type * last() const;</TT>
<DT>Semantics:
<DD>The<TT> last</TT> public member function returns the last element in the vector.&nbsp; The element is not removed from the
vector.
<BR><BR>If the vector is empty, one of two exceptions can be thrown.&nbsp; The<TT> empty_container</TT> exception is thrown
if it is enabled.&nbsp; Otherwise, if the<TT> index_range</TT> exception is enabled, it is thrown.&nbsp; If neither exception
is enabled, a first element of the vector is added with a NULL value.
<DT>Results:
<DD>The<TT> last</TT> public member function returns the value of the last element in the vector.
<DT>See Also:
<DD><TT> first</TT>,<TT> removeLast</TT>,<TT> WCExcept::index_range</TT>,<TT> WCExcept::resize_required</TT>
</DL>
<H2 ID="WCPtrSortedVectorXTypeY_WCPtrOrderedVectorXTypeY__occurrencesOfLR"> occurrencesOf() [WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int occurrencesOf( const Type * ) const;</TT>
<DT>Semantics:
<DD>The<TT> occurrencesOf</TT> public member function returns the number of elements contained in the vector that are equivalent
to the passed value.&nbsp; Note that comparisons are done on the objects pointed to, not the pointers themselves.&nbsp; A
linear search is used by the<TT> WCPtrOrderedVector</TT> class to find the value.&nbsp; The<TT> WCPtrSortedVector</TT> class
uses a binary search.
<DT>Results:
<DD>The<TT> occurrencesOf</TT> public member function returns the number of elements equivalent to the passed value.
<DT>See Also:
<DD><TT> contains</TT>,<TT> find</TT>,<TT> index</TT>,<TT> operator []</TT>,<TT> removeAll</TT>
</DL>
<H2 ID="WCPtrSortedVectorXTypeY_WCPtrOrderedVectorXTypeY__operator_UVLR"> operator []() [WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Type * &amp; operator []( int );</TT>
<BR><TT> Type * const &amp; operator []( int ) const;</TT>
<DT>Semantics:
<DD><TT> operator []</TT> is the vector index operator.&nbsp; A reference to the object stored in the vector at the given index
is returned.&nbsp; If a constant vector is indexed, a reference to a constant element is returned.
<BR><BR>The<TT> append, insert, insertAt</TT> and<TT> prepend</TT> member functions are used to insert a new element into
a vector, and the<TT> remove, removeAll, removeAt, removeFirst</TT> and<TT> removeLast</TT> member functions remove elements.
&nbsp;The index operator cannot be used to change the number of entries in the vector.&nbsp; Searches may be performed using
the<TT> find</TT> and<TT> index</TT> member functions.
<BR><BR>If the vector is empty, one of two exceptions can be thrown.&nbsp; The<TT> empty_container</TT> exception is thrown
if it is enabled.&nbsp; Otherwise, if the<TT> index_range</TT> exception is enabled, it is thrown.&nbsp; If neither exception
is enabled, a first element of the vector is added with a NULL value.&nbsp; This element is added so that a reference to a
valid vector element can be returned.
<BR><BR>If the index value is negative and the<TT> index_range</TT> exception is enabled, the exception is thrown.&nbsp; An
attempt to index an element with index greater than or equal to the number of entries in the vector will also cause the<TT>
index_range</TT> exception to be thrown if enabled.&nbsp; If the exception is not enabled, attempting to index a negative
element will index the first element in the vector, and attempting to index an element after the last entry will index the
last element.
<BR><BR>Care must be taken when using the<TT> WCPtrSortedVector</TT> class not to change the ordering of the vector elements.
&nbsp;The result returned by the index operator must not be assigned to or modified in such a way that it is no longer equivalent
(by<TT> Type's</TT> equivalence operator) to the value inserted into the vector.&nbsp; Failure to comply may cause lookups
to work incorrectly, since the binary search algorithm assumes elements are in sorted order.
<DT>Results:
<DD>The<TT> operator []</TT> public member function returns a reference to the element at the given index.&nbsp; If the index
is invalid, a reference to the closest valid element is returned.&nbsp; The result of the non-constant index operator may
be assigned to.
<DT>See Also:
<DD><TT> append</TT>,<TT> find</TT>,<TT> first</TT>,<TT> index</TT>,<TT> insert</TT>,<TT> insertAt</TT>,<TT> isEmpty</TT>,<TT>
last</TT>,<TT> prepend</TT>,<TT> remove</TT>,<TT> removeAt</TT>,<TT> removeAll</TT>,<TT> removeFirst</TT>,<TT> removeLast</TT>,<TT>
WCExcept::empty_container</TT>,<TT> WCExcept::index_range</TT>
</DL>
<H2 ID="WCPtrSortedVectorXTypeY_WCPtrOrderedVectorXTypeY__operator_ELR"> operator =() [WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCPtrOrderedVector &amp; WCPtrOrderedVector::operator =( const WCPtrOrderedVector &amp; );</TT>
<BR><TT> WCPtrSortedVector &amp; WCPtrSortedVector::operator =( const WCPtrSortedVector &amp; );</TT>
<DT>Semantics:
<DD>The<TT> operator =</TT> public member function is the assignment operator for the class.&nbsp; The left hand side vector is
first cleared using the<TT> clear</TT> member function, and then the right hand side vector is copied.&nbsp; The left hand
side vector is made to have the same length and growth amount as the right hand side (the growth amount is the second argument
passed to the right hand side vector constructor).&nbsp; All of the vector elements and exception trap states are copied.
<BR><BR>If the left hand side vector cannot be fully created, it will have zero length.&nbsp; The<TT> out_of_memory</TT> exception
is thrown if enabled in the right hand side vector.
<DT>Results:
<DD>The<TT> operator =</TT> public member function assigns the left hand side vector to be a copy of the right hand side.
<DT>See Also:
<DD><TT> clear</TT>,<TT> clearAndDestroy</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<H2 ID="WCPtrSortedVectorXTypeY_WCPtrOrderedVectorXTypeY__operator_EELR"> operator ==() [WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int WCPtrOrderedVector::operator ==( const WCPtrOrderedVector &amp; ) const;</TT>
<BR><TT> int WCPtrSortedVector::operator ==( const WCPtrSortedVector &amp; ) const;</TT>
<DT>Semantics:
<DD>The<TT> operator ==</TT> public member function is the equivalence operator for the class.&nbsp; Two vector objects are equivalent
if they are the same object and share the same address.
<DT>Results:
<DD>A TRUE (non-zero) value is returned if the left hand side and right hand side vectors are the same object.&nbsp; A FALSE (zero)
value is returned otherwise.
</DL>
<H2 ID="WCPtrOrderedVectorXTypeY__prependLR"> prepend() [WCPtrOrderedVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int prepend( Type * );</TT>
<DT>Semantics:
<DD>The<TT> prepend</TT> public member function inserts the passed element to be the first element in the vector.&nbsp; All vector
elements contained in the vector are copied up one index.
<BR><BR>This function is not provided by the<TT> WCPtrSortedVector</TT> class, since all elements must be inserted in sorted
order by the<TT> insert</TT> member function.
<BR><BR>Several different results can occur if the vector is not large enough for the new element.&nbsp; If the<TT> resize_required</TT>
exception is enabled, the exception is thrown.&nbsp; If the exception is not enabled, the prepend fails if the amount the
vector is to be grown (the second parameter to the constructor) is zero(0).&nbsp; Otherwise, the vector is automatically grown
by the number of elements specified to the constructor, using the<TT> resize</TT> member function.&nbsp; If<TT> resize</TT>
fails, the element is not inserted to the vector and the<TT> out_of_memory</TT> exception is thrown, if enabled.
<DT>Results:
<DD>The<TT> prepend</TT> public member function prepends an element to the<TT> WCPtrOrderedVector</TT> object.&nbsp; A TRUE (non-zero)
value is returned if the insert is successful.&nbsp; If the insert fails, a FALSE (zero) value is returned.
<DT>See Also:
<DD><TT> append</TT>,<TT> insert</TT>,<TT> insertAt</TT>,<TT> WCExcept::out_of_memory</TT>,<TT> WCExcept::resize_required</TT>
</DL>
<H2 ID="WCPtrSortedVectorXTypeY__removeLR__WCPtrOrderedVectorXTypeY__removeLR"> remove() [WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Type * remove( const Type * );</TT>
<DT>Semantics:
<DD>The<TT> remove</TT> public member function removes the first element in the vector which is equivalent to the passed value.
&nbsp;Note that comparisons are done on the objects pointed to, not the pointers themselves.&nbsp; All vector elements stored
after the removed elements are copied down one index.
<BR><BR>A linear search is used by the<TT> WCPtrOrderedVector</TT> class to find the element being removed.&nbsp; The<TT>
WCPtrSortedVector</TT> class uses a binary search.
<DT>Results:
<DD>The<TT> remove</TT> public member function removes the first element in the vector which is equivalent to the passed value.
&nbsp;The removed pointer is returned.&nbsp; If the vector did not contain an equivalent value, NULL(0) is returned.
<DT>See Also:
<DD><TT> clear</TT>,<TT> clearAndDestroy</TT>,<TT> find</TT>,<TT> removeAll</TT>,<TT> removeAt</TT>,<TT> removeFirst</TT>,<TT>
removeLast</TT>
</DL>
<H2 ID="WCPtrSortedVectorXTypeY_WCPtrOrderedVectorXTypeY__removeAllLR"> removeAll() [WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>unsigned removeAll( const Type * );</TT>
<DT>Semantics:
<DD>The<TT> removeAll</TT> public member function removes all elements in the vector which are equivalent to the passed value.
&nbsp;Note that comparisons are done on the objects pointed to, not the pointers themselves.&nbsp; All vector elements stored
after the removed elements are copied down one or more indexes to take the place of the removed elements.
<BR><BR>A linear search is used by the<TT> WCPtrOrderedVector</TT> class to find the elements being removed.&nbsp; The<TT>
WCPtrSortedVector</TT> class uses a binary search.
<DT>Results:
<DD>The<TT> removeAll</TT> public member function removes all elements in the vector which are equivalent to the passed value.
&nbsp;The number of elements removed is returned.
<DT>See Also:
<DD><TT> clear</TT>,<TT> clearAndDestroy</TT>,<TT> find</TT>,<TT> occurrencesOf</TT>,<TT> remove</TT>,<TT> removeAt</TT>,<TT>
removeFirst</TT>,<TT> removeLast</TT>
</DL>
<H2 ID="WCPtrSortedVectorXTypeY_WCPtrOrderedVectorXTypeY__removeAtLR"> removeAt() [WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Type * removeAt( int );</TT>
<DT>Semantics:
<DD>The<TT> removeAt</TT> public member function removes the element at the given index.&nbsp; All vector elements stored after
the removed elements are copied down one index.
<BR><BR>If the vector is empty and the<TT> empty_container</TT> exception is enabled, the exception is thrown.
<BR><BR>If an attempt to remove an element with a negative index is made and the<TT> index_range</TT> exception is enabled,
the exception is thrown.&nbsp; If the exception is not enabled, the first element is removed from the vector.&nbsp; Attempting
to remove an element with index greater or equal to the number of entries in the vector also causes the<TT> index_range</TT>
exception to be thrown if enabled.&nbsp; The last element in the vector is removed if the exception is not enabled.
<DT>Results:
<DD>The<TT> removeAt</TT> public member function removes the element with the given index.&nbsp; If the index is invalid, the
closest element to the given index is removed.&nbsp; The removed pointer is returned.&nbsp; If the vector was empty, NULL(0)
is returned.
<DT>See Also:
<DD><TT> clear</TT>,<TT> clearAndDestroy</TT>,<TT> insertAt</TT>,<TT> operator []</TT>,<TT> remove</TT>,<TT> removeAll</TT>,<TT>
removeFirst</TT>,<TT> removeLast</TT>
</DL>
<H2 ID="WCPtrSortedVectorXTypeY_WCPtrOrderedVectorXTypeY__removeFirstLR"> removeFirst() [WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Type * removeFirst();</TT>
<DT>Semantics:
<DD>The<TT> removeFirst</TT> public member function removes the first element from a vector.&nbsp; All other vector elements are
copied down one index.
<BR><BR>If the vector is empty and the<TT> empty_container</TT> exception is enabled, the exception is thrown.
<DT>Results:
<DD>The<TT> removeFirst</TT> public member function removes the first element from the vector.&nbsp; The removed pointer is returned.
&nbsp;If the vector was empty, NULL(0) is returned.
<DT>See Also:
<DD><TT> clear</TT>,<TT> clearAndDestroy</TT>,<TT> first</TT>,<TT> remove</TT>,<TT> removeAt</TT>,<TT> removeAll</TT>,<TT> removeLast</TT>
</DL>
<H2 ID="WCPtrSortedVectorXTypeY_WCPtrOrderedVectorXTypeY__removeLastLR"> removeLast() [WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Type * removeLast();</TT>
<DT>Semantics:
<DD>The<TT> removeLast</TT> public member function removes the last element from a vector.&nbsp; If the vector is empty and the<TT>
empty_container</TT> exception is enabled, the exception is thrown.
<DT>Results:
<DD>The<TT> removeLast</TT> public member function removes the last element from the vector.&nbsp; The removed pointer is returned.
&nbsp;If the vector was empty, NULL(0) is returned.
<DT>See Also:
<DD><TT> clear</TT>,<TT> clearAndDestroy</TT>,<TT> last</TT>,<TT> remove</TT>,<TT> removeAt</TT>,<TT> removeAll</TT>,<TT> removeFirst</TT>
</DL>
<H2 ID="WCPtrSortedVectorXTypeY__resizeLR__WCPtrOrderedVectorXTypeY__resizeLR"> resize() [WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int resize( size_t new_size );</TT>
<DT>Semantics:
<DD>The<TT> resize</TT> public member function is used to change the vector size to be able to store<B> new_size</B> elements.
&nbsp;If<B> new_size</B> is larger than the previous vector size, all elements are copied into the newly sized vector, and
new elements can be added using the<TT> append, insert, insertAt,</TT> and<TT> prepend</TT> member functions.&nbsp; If the
vector is resized to a smaller size, the first<B> new_size</B> elements are copied (all vector elements if the vector contained<B>
new_size</B> or fewer elements).&nbsp; The objects pointed to by the remaining elements are not deleted.
<BR><BR>If the resize cannot be performed and the<TT> out_of_memory</TT> exception is enabled, the exception is thrown.
<DT>Results:
<DD>The vector is resized to<B> new_size</B>.&nbsp; A TRUE value (non-zero) is returned if the resize is successful.&nbsp; A FALSE
(zero) result is returned if the resize fails.
<DT>See Also:
<DD><TT> WCExcept::out_of_memory</TT>
</DL>
<H2 ID="WCPtrVectorXTypeY_Class_Description"> WCPtrVector&lt;Type&gt; Class Description </H2>
<DL>
<DT>Declared:
<DD><TT> wcvector.h</TT>
<BR><BR>The<TT> WCPtrVector&lt;Type&gt;</TT> class is a templated class used to store objects in a vector.&nbsp; Vectors are
similar to arrays, but vectors perform bounds checking and can be resized.&nbsp; Elements are inserted into the vector by
assigning to a vector index.
<BR>The<TT> WCPtrOrderedVector</TT> and<TT> WCPtrSortedVector</TT> classes are also available.&nbsp; They provide a more abstract
view of the vector and additional functionality, including finding and removing elements.
<BR><BR>In the description of each member function, the text<TT> Type</TT> is used to indicate the template parameter defining
the type pointed to by the pointers stored in the vector.
<BR><BR>The<TT> WCExcept</TT> class is a base class of the<TT> WCPtrVector&lt;Type&gt;</TT> class and provides the<TT> exceptions</TT>
member function.&nbsp; This member function controls the exceptions which can be thrown by the<TT> WCPtrVector&lt;Type&gt;</TT>
object.&nbsp; No exceptions are enabled unless they are set by the<TT> exceptions</TT> member function.
<BR><BR><B>Requirements of Type</B>
<BR><BR>The<TT> WCPtrVector&lt;Type&gt;</TT> class requires nothing from<TT> Type.</TT>
<BR><BR><B>Public Member Functions</B>
<BR><BR>The following member functions are declared in the public interface:
<BR><BR><TT>WCPtrVector( size_t = 0 );</TT>
<BR><TT> WCPtrVector( size_t, const Type * );</TT>
<BR><TT> WCPtrVector( const WCPtrVector &amp; );</TT>
<BR><TT> virtual ~WCPtrVector();</TT>
<BR><TT> void clear();</TT>
<BR><TT> void clearAndDestroy();</TT>
<BR><TT> size_t length() const;</TT>
<BR><TT> int resize( size_t );</TT>
<BR><BR><B>Public Member Operators</B>
<BR><BR>The following member operators are declared in the public interface:
<BR><BR><TT>Type * &amp; operator []( int );</TT>
<BR><TT> Type * const &amp; operator []( int ) const;</TT>
<BR><TT> WCPtrVector &amp; operator =( const WCPtrVector &amp; );</TT>
<BR><TT> int operator ==( const WCPtrVector &amp; ) const;</TT>
</DL>
<H2 ID="WCPtrVectorXTypeY__WCPtrVectorLR"> WCPtrVector() [WCPtrVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCPtrVector( size_t = 0 );</TT>
<DT>Semantics:
<DD>The public<TT> WCPtrVector&lt;Type&gt;</TT> constructor creates a<TT> WCPtrVector&lt;Type&gt;</TT> object able to store the
number of elements specified in the optional parameter, which defaults to zero.&nbsp; All vector elements are initialized
to NULL(0).
<BR><BR>If the vector object cannot be fully initialized, the vector is created with length zero.
<DT>Results:
<DD>The public<TT> WCPtrVector&lt;Type&gt;</TT> constructor creates an initialized<TT> WCPtrVector&lt;Type&gt;</TT> object with
the specified length.
<DT>See Also:
<DD><TT> WCPtrVector&lt;Type&gt;</TT>,<TT> ~WCPtrVector&lt;Type&gt;</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCPtrVector( size_t, const Type * );</TT>
<DT>Semantics:
<DD>The public<TT> WCPtrVector&lt;Type&gt;</TT> constructor creates a<TT> WCPtrVector&lt;Type&gt;</TT> object able to store the
number of elements specified by the first parameter.&nbsp; All vector elements are initialized to the pointer value given
by the second parameter.
<BR><BR>If the vector object cannot be fully initialized, the vector is created with length zero.
<DT>Results:
<DD>The public<TT> WCPtrVector&lt;Type&gt;</TT> constructor creates an initialized<TT> WCPtrVector&lt;Type&gt;</TT> object with
the specified length and elements set to the given value.
<DT>See Also:
<DD><TT> WCPtrVector&lt;Type&gt;</TT>,<TT> ~WCPtrVector&lt;Type&gt;</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCPtrVector( const WCPtrVector &amp; );</TT>
<DT>Semantics:
<DD>The public<TT> WCPtrVector&lt;Type&gt;</TT> constructor is the copy constructor for the<TT> WCPtrVector&lt;Type&gt;</TT> class.
&nbsp;The new vector is created with the same length as the given vector.&nbsp; All of the vector elements and exception trap
states are copied.
<BR><BR>If the new vector cannot be fully created, it will have length zero.&nbsp; The<TT> out_of_memory</TT> exception is
thrown if enabled in the vector being copied.
<DT>Results:
<DD>The public<TT> WCPtrVector&lt;Type&gt;</TT> constructor creates a<TT> WCPtrVector&lt;Type&gt;</TT> object which is a copy
of the passed vector.
<DT>See Also:
<DD><TT> operator =</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<H2 ID="WCPtrVectorXTypeY____WCPtrVectorLR"> ~WCPtrVector() [WCPtrVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>virtual ~WCPtrVector();</TT>
<DT>Semantics:
<DD>The public<TT> ~WCPtrVector&lt;Type&gt;</TT> destructor is the destructor for the<TT> WCPtrVector&lt;Type&gt;</TT> class.
&nbsp;If the vector is not length zero and the<TT> not_empty</TT> exception is enabled, the exception is thrown.&nbsp; Otherwise,
the vector elements are cleared using the<TT> clear</TT> member function.&nbsp; The objects which the vector elements point
to are not deleted unless the<TT> clearAndDestroy</TT> member function is explicitly called before the destructor is called.
&nbsp;The call to the public<TT> ~WCPtrVector&lt;Type&gt;</TT> destructor is inserted implicitly by the compiler at the point
where the<TT> WCPtrVector&lt;Type&gt;</TT> object goes out of scope.
<DT>Results:
<DD>The public<TT> ~WCPtrVector&lt;Type&gt;</TT> destructor destroys an<TT> WCPtrVector&lt;Type&gt;</TT> object.
<DT>See Also:
<DD><TT> clear</TT>,<TT> clearAndDestroy</TT>,<TT> WCExcept::not_empty</TT>
</DL>
<H2 ID="WCPtrVectorXTypeY__clearLR"> clear() [WCPtrVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void clear();</TT>
<DT>Semantics:
<DD>The<TT> clear</TT> public member function is used to clear the vector so that it is of zero length.&nbsp; Objects pointed
to by the vector elements are not deleted.&nbsp; The vector object is not destroyed and re-created by this function, so the
object destructor is not invoked.
<DT>Results:
<DD>The<TT> clear</TT> public member function clears the vector to have zero length and no vector elements.
<DT>See Also:
<DD><TT> ~WCPtrVector&lt;Type&gt;</TT>,<TT> clearAndDestroy</TT>,<TT> operator =</TT>
</DL>
<H2 ID="WCPtrVectorXTypeY__clearAndDestroyLR"> clearAndDestroy() [WCPtrVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void clearAndDestroy();</TT>
<DT>Semantics:
<DD>The<TT> clearAndDestroy</TT> public member function is used to clear the vector to have zero length and delete the objects
pointed to by the vector elements.&nbsp; The vector object is not destroyed and re-created by this function, so the vector
object destructor is not invoked.
<DT>Results:
<DD>The<TT> clearAndDestroy</TT> public member function clears the vector by deleting the objects pointed to by the vector elements
and makes the vector zero length.
<DT>See Also:
<DD><TT> clear</TT>
</DL>
<H2 ID="WCPtrVectorXTypeY__lengthLR"> length() [WCPtrVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>size_t length() const;</TT>
<DT>Semantics:
<DD>The<TT> length</TT> public member function is used to find the number of elements which can be stored in the<TT> WCPtrVector&lt;Type&gt;</TT>
object.
<DT>Results:
<DD>The<TT> length</TT> public member function returns the length of the vector.
<DT>See Also:
<DD><TT> resize</TT>
</DL>
<H2 ID="WCPtrVectorXTypeY__operator_UVLR"> operator []() [WCPtrVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Type * &amp; operator []( int );</TT>
<BR><TT> Type * const &amp; operator []( int ) const;</TT>
<DT>Semantics:
<DD><TT> operator []</TT> is the vector index operator.&nbsp; A reference to the object stored in the vector at the given index
is returned.&nbsp; If a constant vector is indexed, a reference to a constant element is returned.&nbsp; The index operator
of a non-constant vector is the only way to insert an element into the vector.
<BR><BR>If an attempt to access an element with index greater than or equal to the length of a non-constant vector is made
and the<TT> resize_required</TT> exception is enabled, the exception is thrown.&nbsp; If the exception is not enabled, the
vector is automatically resized using the<TT> resize</TT> member function to have length the index value plus one.&nbsp; New
vector elements are initialized to NULL(0).&nbsp; If the resize failed, and the<TT> out_of_memory</TT> exception is enabled,
the exception is thrown.&nbsp; If the exception is not enabled and the resize failed, the last element is indexed (a new element
if the vector was zero length).&nbsp; If a negative value is used to index the non-constant vector and the<TT> index_range</TT>
exception is enabled, the exception is thrown.&nbsp; If the exception is not enabled and the vector is empty, the<TT> resize_required</TT>
exception may be thrown.
<BR><BR>An attempt to index an empty constant vector may cause one of two exceptions to be thrown.&nbsp; If the<TT> empty_container</TT>
exception is enabled, it is thrown.&nbsp; Otherwise, the<TT> index_range</TT> exception is thrown, if enabled.&nbsp; If neither
exception is enabled, a first vector element is added and indexed (so that a reference to a valid element can be returned).
<BR><BR>Indexing with a negative value or a value greater than or equal to the length of a constant vector causes the<TT>
index_range</TT> exception to be thrown, if enabled.
<DT>Results:
<DD>The<TT> operator []</TT> public member function returns a reference to the element at the given index.&nbsp; If the index
is invalid, a reference to the closest valid element is returned.&nbsp; The result of the non-constant index operator may
be assigned to.
<DT>See Also:
<DD><TT> resize</TT>,<TT> WCExcept::empty_container</TT>,<TT> WCExcept::index_range</TT>,<TT> WCExcept::out_of_memory</TT>,<TT>
WCExcept::resize_required</TT>
</DL>
<H2 ID="WCPtrVectorXTypeY__operator_ELR"> operator =() [WCPtrVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCPtrVector &amp; operator =( const WCPtrVector &amp; );</TT>
<DT>Semantics:
<DD>The<TT> operator =</TT> public member function is the assignment operator for the<TT> WCPtrVector&lt;Type&gt;</TT> class.
&nbsp;The left hand side vector is first cleared using the<TT> clear</TT> member function, and then the right hand side vector
is copied.&nbsp; The left hand side vector is made to have the same length as the right hand side.&nbsp; All of the vector
elements and exception trap states are copied.
<BR><BR>If the left hand side vector cannot be fully created, it will have zero length.&nbsp; The<TT> out_of_memory</TT> exception
is thrown if enabled in the right hand side vector.
<DT>Results:
<DD>The<TT> operator =</TT> public member function assigns the left hand side vector to be a copy of the right hand side.
<DT>See Also:
<DD><TT> clear</TT>,<TT> clearAndDestroy</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<H2 ID="WCPtrVectorXTypeY__operator_EELR"> operator ==() [WCPtrVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int operator ==( const WCPtrVector &amp; ) const;</TT>
<DT>Semantics:
<DD>The<TT> operator ==</TT> public member function is the equivalence operator for the<TT> WCPtrVector&lt;Type&gt;</TT> class.
&nbsp;Two vector objects are equivalent if they are the same object and share the same address.
<DT>Results:
<DD>A TRUE (non-zero) value is returned if the left hand side and right hand side vectors are the same object.&nbsp; A FALSE (zero)
value is returned otherwise.
</DL>
<H2 ID="WCPtrVectorXTypeY__resizeLR"> resize() [WCPtrVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int resize( size_t new_size );</TT>
<DT>Semantics:
<DD>The<TT> resize</TT> public member function is used to change the vector size to be able to store<B> new_size</B> elements.
&nbsp;If<B> new_size</B> is larger than the previous vector size, all elements will be copied into the newly sized vector,
and new elements are initialized to NULL(0).&nbsp; If the vector is resized to a smaller size, the first<B> new_size</B> elements
are copied.&nbsp; The objects pointed to by the remaining elements are not deleted.
<BR><BR>If the resize cannot be performed and the<TT> out_of_memory</TT> exception is enabled, the exception is thrown.
<DT>Results:
<DD>The vector is resized to<B> new_size</B>.&nbsp; A TRUE value (non-zero) is returned if the resize is successful.&nbsp; A FALSE
(zero) result is returned if the resize fails.
<DT>See Also:
<DD><TT> WCExcept::out_of_memory</TT>
</DL>
<H2 ID="WCValSortedVectorXTypeY__WCValOrderedVectorXTypeY_Class_Description"> WCValSortedVector&lt;Type&gt;, WCValOrderedVector&lt;Type&gt; Class Description </H2>
<DL>
<DT>Declared:
<DD><TT> wcvector.h</TT>
<BR><BR>The<TT> WCValSortedVector&lt;Type&gt;</TT> and<TT> WCValOrderedVector&lt;Type&gt;</TT> classes are templated classes
used to store objects in a vector.&nbsp; Ordered and Sorted vectors are powerful arrays which can be resized and provide an
abstract interface to insert, find and remove elements.&nbsp; An ordered vector maintains the order in which elements are
added, and allows more than one copy of an element that is equivalent.&nbsp; The sorted vector allow only one copy of an equivalent
element, and inserts them in a sorted order.&nbsp; The sorted vector is less efficient when inserting elements, but can provide
a faster retrieval time.
<BR>Elements cannot be inserted into these vectors by assigning to a vector index.&nbsp; Vectors automatically grow when necessary
to insert an element if the<TT> resize_required</TT> exception is not enabled.
<BR><BR>In the description of each member function, the text<TT> Type</TT> is used to indicate the template parameter defining
the type of the elements stored in the vector.
<BR><BR>Values are copied into the vector, which could be undesirable if the stored objects are complicated and copying is
expensive.&nbsp; Value vectors should not be used to store objects of a base class if any derived types of different sizes
would be stored in the vector, or if the destructor for a derived class must be called.
<BR><BR>The<TT> WCValOrderedVector</TT> class stores elements in the order which they are inserted using the<TT> insert, append,
prepend</TT> and<TT> insertAt</TT> member functions.&nbsp; Linear searches are performed to locate entries, and the less than
operator is not required.
<BR><BR>The<TT> WCValSortedVector</TT> class stores elements in ascending order.&nbsp; This requires that<TT> Type</TT> provides
a less than operator.&nbsp; Insertions are more expensive than inserting or appending into an ordered vector, since entries
must be moved to make room for the new element.&nbsp; A binary search is used to locate elements in a sorted vector, making
searches quicker than in the ordered vector.
<BR><BR>Care must be taken when using the<TT> WCValSortedVector</TT> class not to change the ordering of the vector elements.
&nbsp;The result returned by the index operator must not be assigned to or modified in such a way that it is no longer equivalent
to the value inserted into the vector.&nbsp; Lookups assume elements are in sorted order.
<BR><BR>The<TT> WCValVector</TT> class is also available.&nbsp; It provides a resizable and boundary safe vector similar to
standard arrays.
<BR><BR>The<TT> WCExcept</TT> class is a base class of the<TT> WCValSortedVector&lt;Type&gt;</TT> and<TT> WCValOrderedVector&lt;Type&gt;</TT>
classes and provides the<TT> exceptions</TT> member function.&nbsp; This member function controls the exceptions which can
be thrown by the<TT> WCValSortedVector&lt;Type&gt;</TT> and<TT> WCValOrderedVector&lt;Type&gt;</TT> objects.&nbsp; No exceptions
are enabled unless they are set by the<TT> exceptions</TT> member function.
<BR><BR><B>Requirements of Type</B>
<BR><BR>Both the<TT> WCValSortedVector&lt;Type&gt;</TT> and<TT> WCValOrderedVector&lt;Type&gt;</TT> classes require<TT> Type</TT>
to have:
<BR>A default constructor (<TT> Type::Type()</TT> ).
<BR><BR>A well defined copy constructor (<TT> Type::Type( const Type &amp; )</TT> ).
<BR><BR>A well defined assignment operator
<BR><BR>(<TT> Type &amp; operator =( const Type &amp; )</TT> ).
<BR>The following override of<TT> operator new()</TT> if<TT> Type</TT> overrides the global<TT> operator new():</TT>
<BR><BR><TT>void * operator new( size_t, void *ptr ) { return( ptr ); }</TT>
<BR><BR>A well defined equivalence operator with constant parameters
<BR><BR>(<TT> int operator ==( const Type &amp; ) const</TT> ).
<BR>Additionally the<TT> WCValSortedVector</TT> class requires<TT> Type</TT> to have:
<BR><BR>A well defined less than operator with constant parameters
<BR><BR>(<TT> int operator &lt;( const Type &amp; ) const</TT> ).
<BR><BR><B>Public Member Functions</B>
<BR><BR>The following member functions are declared in the public interface:
<BR><BR><TT>WCValOrderedVector( size_t = WCDEFAULT_VECTOR_LENGTH, unsigned = WCDEFAULT_VECTOR_RESIZE_GROW );</TT>
<BR><TT> WCValOrderedVector( const WCValOrderedVector &amp; );</TT>
<BR><TT> virtual ~WCValOrderedVector();</TT>
<BR><TT> WCValSortedVector( size_t = WCDEFAULT_VECTOR_LENGTH, unsigned = WCDEFAULT_VECTOR_RESIZE_GROW );</TT>
<BR><TT> WCValSortedVector( const WCValSortedVector &amp; );</TT>
<BR><TT> virtual ~WCValSortedVector();</TT>
<BR><TT> void clear();</TT>
<BR><TT> int contains( const Type &amp; ) const;</TT>
<BR><TT> unsigned entries() const;</TT>
<BR><TT> int find( const Type &amp;, Type &amp; ) const;</TT>
<BR><TT> Type first() const;</TT>
<BR><TT> int index( const Type &amp; ) const;</TT>
<BR><TT> int insert( const Type &amp; );</TT>
<BR><TT> int isEmpty() const;</TT>
<BR><TT> Type last() const;</TT>
<BR><TT> int occurrencesOf( const Type &amp; ) const;</TT>
<BR><TT> int remove( const Type &amp; );</TT>
<BR><TT> unsigned removeAll( const Type &amp; );</TT>
<BR><TT> int removeAt( int );</TT>
<BR><TT> int removeFirst();</TT>
<BR><TT> int removeLast();</TT>
<BR><TT> int resize( size_t );</TT>
<BR><BR>The following public member functions are available for the<TT> WCValOrderedVector</TT> class only:
<BR><BR><TT>int append( const Type &amp; );</TT>
<BR><TT> int insertAt( int, const Type &amp; );</TT>
<BR><TT> int prepend( const Type &amp; );</TT>
<BR><BR><B>Public Member Operators</B>
<BR><BR>The following member operators are declared in the public interface:
<BR><BR><TT>Type &amp; operator []( int );</TT>
<BR><TT> const Type &amp; operator []( int ) const;</TT>
<BR><TT> WCValOrderedVector &amp; WCValOrderedVector::operator =( const WCValOrderedVector &amp; );</TT>
<BR><TT> WCValSortedVector &amp; WCValSortedVector::operator =( const WCValSortedVector &amp; );</TT>
<BR><TT> int WCValOrderedVector::operator ==( const WCValOrderedVector &amp; ) const;</TT>
<BR><TT> int WCValSortedVector::operator ==( const WCValSortedVector &amp; ) const;</TT>
</DL>
<H2 ID="WCValOrderedVectorXTypeY__WCValOrderedVectorLR"> WCValOrderedVector() [WCValOrderedVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCValOrderedVector( size_t = WCDEFAULT_VECTOR_LENGTH,</TT>
<BR><TT> unsigned = WCDEFAULT_VECTOR_RESIZE_GROW );</TT>
<DT>Semantics:
<DD>The<TT> WCValOrderedVector&lt;Type&gt;</TT> constructor creates an empty<TT> WCValOrderedVector</TT> object able to store
the number of elements specified in the first optional parameter, which defaults to the constant<TT> WCDEFAULT_VECTOR_LENGTH</TT>
(currently defined as 10).&nbsp; If the<TT> resize_required</TT> exception is not enabled, then the second optional parameter
is used to specify the value to increase the vector size when an element is inserted into a full vector.&nbsp; If zero(0)
is specified as the second parameter, any attempt to insert into a full vector fails.&nbsp; This parameter defaults to the
constant<TT> WCDEFAULT_VECTOR_RESIZE_GROW</TT> (currently defined as 5).
<BR><BR>If the vector object cannot be fully initialized, the vector is created with length zero.
<DT>Results:
<DD>The<TT> WCValOrderedVector&lt;Type&gt;</TT> constructor creates an empty initialized<TT> WCValOrderedVector</TT> object.
<DT>See Also:
<DD><TT> WCExcept::resize_required</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCValOrderedVector( const WCValOrderedVector &amp; );</TT>
<DT>Semantics:
<DD>The<TT> WCValOrderedVector&lt;Type&gt;</TT> constructor is the copy constructor for the<TT> WCValOrderedVector</TT> class.
&nbsp;The new vector is created with the same length and resize value as the passed vector.&nbsp; All of the vector elements
and exception trap states are copied.
<BR><BR>If the new vector cannot be fully created, it will have length zero.&nbsp; The<TT> out_of_memory</TT> exception is
thrown if enabled in the vector being copied.
<DT>Results:
<DD>The<TT> WCValOrderedVector&lt;Type&gt;</TT> creates a<TT> WCValOrderedVector</TT> object which is a copy of the passed vector.
<DT>See Also:
<DD><TT> operator =</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<H2 ID="WCValOrderedVectorXTypeY____WCValOrderedVectorLR"> ~WCValOrderedVector() [WCValOrderedVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>virtual ~WCValOrderedVector();</TT>
<DT>Semantics:
<DD>The<TT> WCValOrderedVector&lt;Type&gt;</TT> destructor is the destructor for the<TT> WCValOrderedVector</TT> class.&nbsp;
If the vector is not length zero and the<TT> not_empty</TT> exception is enabled, the exception is thrown.&nbsp; Otherwise,
the vector entries are cleared using the<TT> clear</TT> member function.&nbsp; The call to the<TT> WCValOrderedVector&lt;Type&gt;</TT>
destructor is inserted implicitly by the compiler at the point where the<TT> WCValOrderedVector</TT> object goes out of scope.
<DT>Results:
<DD>The<TT> WCValOrderedVector&lt;Type&gt;</TT> destructor destroys an<TT> WCValOrderedVector</TT> object.
<DT>See Also:
<DD><TT> clear</TT>,<TT> WCExcept::not_empty</TT>
</DL>
<H2 ID="WCValSortedVectorXTypeY__WCValSortedVectorLR"> WCValSortedVector() [WCValSortedVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCValSortedVector( size_t = WCDEFAULT_VECTOR_LENGTH,</TT>
<BR><TT> unsigned = WCDEFAULT_VECTOR_RESIZE_GROW );</TT>
<DT>Semantics:
<DD>The<TT> WCValSortedVector&lt;Type&gt;</TT> constructor creates an empty<TT> WCValSortedVector</TT> object able to store the
number of elements specified in the first optional parameter, which defaults to the constant<TT> WCDEFAULT_VECTOR_LENGTH</TT>
(currently defined as 10).&nbsp; If the<TT> resize_required</TT> exception is not enabled, then the second optional parameter
is used to specify the value to increase the vector size when an element is inserted into a full vector.&nbsp; If zero(0)
is specified as the second parameter, any attempt to insert into a full vector fails.&nbsp; This parameter defaults to the
constant<TT> WCDEFAULT_VECTOR_RESIZE_GROW</TT> (currently defined as 5).
<BR><BR>If the vector object cannot be fully initialized, the vector is created with length zero.
<DT>Results:
<DD>The<TT> WCValSortedVector&lt;Type&gt;</TT> constructor creates an empty initialized<TT> WCValSortedVector</TT> object.
<DT>See Also:
<DD><TT> WCExcept::resize_required</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCValSortedVector( const WCValSortedVector &amp; );</TT>
<DT>Semantics:
<DD>The<TT> WCValSortedVector&lt;Type&gt;</TT> constructor is the copy constructor for the<TT> WCValSortedVector</TT> class.&nbsp;
The new vector is created with the same length and resize value as the passed vector.&nbsp; All of the vector elements and
exception trap states are copied.
<BR><BR>If the new vector cannot be fully created, it will have length zero.&nbsp; The<TT> out_of_memory</TT> exception is
thrown if enabled in the vector being copied.
<DT>Results:
<DD>The<TT> WCValSortedVector&lt;Type&gt;</TT> constructor creates a<TT> WCValSortedVector</TT> object which is a copy of the
passed vector.
<DT>See Also:
<DD><TT> operator =</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<H2 ID="WCValSortedVectorXTypeY____WCValSortedVectorLR"> ~WCValSortedVector() [WCValSortedVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>virtual ~WCValSortedVector();</TT>
<DT>Semantics:
<DD>The<TT> WCValSortedVector&lt;Type&gt;</TT> destructor is the destructor for the<TT> WCValSortedVector</TT> class.&nbsp; If
the vector is not length zero and the<TT> not_empty</TT> exception is enabled, the exception is thrown.&nbsp; Otherwise, the
vector entries are cleared using the<TT> clear</TT> member function.&nbsp; The call to the<TT> WCValSortedVector&lt;Type&gt;</TT>
destructor is inserted implicitly by the compiler at the point where the<TT> WCValSortedVector</TT> object goes out of scope.
<DT>Results:
<DD>The<TT> WCValSortedVector&lt;Type&gt;</TT> destructor destroys an<TT> WCValSortedVector</TT> object.
<DT>See Also:
<DD><TT> clear</TT>,<TT> WCExcept::not_empty</TT>
</DL>
<H2 ID="WCValOrderedVectorXTypeY__appendLR"> append() [WCValOrderedVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int append( const Type &amp; );</TT>
<DT>Semantics:
<DD>The<TT> append</TT> public member function appends the passed element to be the last element in the vector.&nbsp; The data
stored in the vector is a copy of the data passed as a parameter.&nbsp; This member function has the same semantics as the<TT>
WCValOrderedVector::insert</TT> member function.
<BR><BR>This function is not provided by the<TT> WCValSortedVector</TT> class, since all elements must be inserted in sorted
order by the<TT> insert</TT> member function.
<BR><BR>Several different results can occur if the vector is not large enough for the new element.&nbsp; If the<TT> resize_required</TT>
exception is enabled, the exception is thrown.&nbsp; If the exception is not enabled, the append fails if the amount the vector
is to be grown (the second parameter to the constructor) is zero(0).&nbsp; Otherwise, the vector is automatically grown by
the number of elements specified to the constructor, using the<TT> resize</TT> member function.&nbsp; If<TT> resize</TT> fails,
the element is not appended to the vector and the<TT> out_of_memory</TT> exception is thrown, if enabled.
<DT>Results:
<DD>The<TT> append</TT> public member function appends an element to the<TT> WCValOrderedVector</TT> object.&nbsp; A TRUE (non-zero)
value is returned if the append is successful.&nbsp; If the append fails, a FALSE (zero) value is returned.
<DT>See Also:
<DD><TT> insert</TT>,<TT> insertAt</TT>,<TT> prepend</TT>,<TT> WCExcept::out_of_memory</TT>,<TT> WCExcept::resize_required</TT>
</DL>
<H2 ID="WCValSortedVectorXTypeY__clearLR__WCValOrderedVectorXTypeY__clearLR"> clear() [WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void clear();</TT>
<DT>Semantics:
<DD>The<TT> clear</TT> public member function is used to clear the vector so that it contains no entries, and is zero size.&nbsp;
Elements stored in the vector are destroyed using<TT> Type's</TT> destructor.&nbsp; The vector object is not destroyed and
re-created by this function, so the object destructor is not invoked.
<DT>Results:
<DD>The<TT> clear</TT> public member function clears the vector to have zero length and no entries.
<DT>See Also:
<DD><TT> ~WCValOrderedVector</TT>,<TT> operator =</TT>
</DL>
<H2 ID="WCValSortedVectorXTypeY_WCValOrderedVectorXTypeY__containsLR"> contains() [WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int contains( const Type &amp; ) const;</TT>
<DT>Semantics:
<DD>The<TT> contains</TT> public member function is used to determine if a value is contained by a vector.&nbsp; A linear search
is used by the<TT> WCValOrderedVector</TT> class to find the value.&nbsp; The<TT> WCValSortedVector</TT> class uses a binary
search.
<DT>Results:
<DD>The<TT> contains</TT> public member function returns a TRUE (non-zero) value if the element is found in the vector.&nbsp;
A FALSE (zero) value is returned if the vector does not contain the element.
<DT>See Also:
<DD><TT> index</TT>,<TT> find</TT>
</DL>
<H2 ID="WCValSortedVectorXTypeY__entriesLR__WCValOrderedVectorXTypeY__entriesLR"> entries() [WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>unsigned entries() const;</TT>
<DT>Semantics:
<DD>The<TT> entries</TT> public member function is used to find the number of elements which are stored in the vector.
<DT>Results:
<DD>The<TT> entries</TT> public member function returns the number of elements in the vector.
<DT>See Also:
<DD><TT> isEmpty</TT>
</DL>
<H2 ID="WCValSortedVectorXTypeY__findLR__WCValOrderedVectorXTypeY__findLR"> find() [WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int find( const Type &amp;, Type &amp; ) const;</TT>
<DT>Semantics:
<DD>The<TT> find</TT> public member function is used to find an element equivalent to the first argument.&nbsp; The<TT> WCValOrderedVector</TT>
class uses a linear search to find the element, and the<TT> WCValSortedVector</TT> class uses a binary search.
<DT>Results:
<DD>If an equivalent element is found, a TRUE (non-zero) value is returned, and the second parameter is assigned the first equivalent
value.&nbsp; A FALSE (zero) value is returned and the second parameter is unchanged if the element is not in the vector.
<DT>See Also:
<DD><TT> contains</TT>,<TT> first</TT>,<TT> index</TT>,<TT> last</TT>,<TT> occurrencesOf</TT>,<TT> remove</TT>
</DL>
<H2 ID="WCValSortedVectorXTypeY__firstLR__WCValOrderedVectorXTypeY__firstLR"> first() [WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Type first() const;</TT>
<DT>Semantics:
<DD>The<TT> first</TT> public member function returns the first element in the vector.&nbsp; The element is not removed from the
vector.
<BR><BR>If the vector is empty, one of two exceptions can be thrown.&nbsp; The<TT> empty_container</TT> exception is thrown
if it is enabled.&nbsp; Otherwise, if the<TT> index_range</TT> exception is enabled, it is thrown.&nbsp; If neither exception
is enabled, a first element of the vector is added with a default value.
<DT>Results:
<DD>The<TT> first</TT> public member function returns the value of the first element in the vector.
<DT>See Also:
<DD><TT> last</TT>,<TT> removeFirst</TT>,<TT> WCExcept::index_range</TT>,<TT> WCExcept::resize_required</TT>
</DL>
<H2 ID="WCValSortedVectorXTypeY__indexLR__WCValOrderedVectorXTypeY__indexLR"> index() [WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int index( const Type &amp; ) const;</TT>
<DT>Semantics:
<DD>The<TT> index</TT> public member function is used find the index of the first element equivalent to the passed element.&nbsp;
A linear search is used by the<TT> WCValOrderedVector</TT> class to find the element.&nbsp; The<TT> WCValSortedVector</TT>
class uses a binary search.
<DT>Results:
<DD>The<TT> index</TT> public member function returns the index of the first element equivalent to the parameter.&nbsp; If the
passed value is not contained in the vector, negative one (-1) is returned.
<DT>See Also:
<DD><TT> contains</TT>,<TT> find</TT>,<TT> insertAt</TT>,<TT> operator []</TT>,<TT> removeAt</TT>
</DL>
<H2 ID="WCValSortedVectorXTypeY__insertLR__WCValOrderedVectorXTypeY__insertLR"> insert() [WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int insert( const Type &amp; );</TT>
<DT>Semantics:
<DD>The<TT> insert</TT> public member function inserts the value into the vector.&nbsp; The data stored in the vector is a copy
of the data passed as a parameter.
<BR><BR>The<TT> WCValOrderedVector::insert</TT> function inserts the value as the last element of the vector, and has the
same semantics as the<TT> WCValOrderedVector::append</TT> member function.
<BR><BR>A binary search is performed to determine where the value should be inserted for the<TT> WCValSortedVector::insert</TT>
function.&nbsp; Any elements greater than the inserted value are copied up one index (using<TT> Type's</TT> assignment operator),
so that the new element is after all elements with value less than or equal to it.
<BR><BR>Several different results can occur if the vector is not large enough for the new element.&nbsp; If the<TT> resize_required</TT>
exception is enabled, the exception is thrown.&nbsp; If the exception is not enabled, the insert fails if the amount the vector
is to be grown (the second parameter to the constructor) is zero(0).&nbsp; Otherwise, the vector is automatically grown by
the number of elements specified to the constructor, using the<TT> resize</TT> member function.&nbsp; If<TT> resize</TT> fails,
the element is not inserted to the vector and the<TT> out_of_memory</TT> exception is thrown, if enabled.
<DT>Results:
<DD>The<TT> insert</TT> public member function inserts an element in to the vector.&nbsp; A TRUE (non-zero) value is returned
if the insert is successful.&nbsp; If the insert fails, a FALSE (zero) value is returned.
<DT>See Also:
<DD><TT> append</TT>,<TT> insertAt</TT>,<TT> prepend</TT>,<TT> WCExcept::out_of_memory</TT>,<TT> WCExcept::resize_required</TT>
</DL>
<H2 ID="WCValOrderedVectorXTypeY__insertAtLR"> insertAt() [WCValOrderedVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int insertAt( int, const Type &amp; );</TT>
<DT>Semantics:
<DD>The<TT> insertAt</TT> public member function inserts the second argument into the vector before the element at index given
by the first argument.&nbsp; If the passed index is equal to the number of entries in the vector, the new value is appended
to the vector as the last element.&nbsp; The data stored in the vector is a copy of the data passed as a parameter.&nbsp;
All vector elements with indexes greater than or equal to the first parameter are copied (using<TT> Type's</TT> assignment
operator) up one index.
<BR><BR>This function is not provided by the<TT> WCValSortedVector</TT> class, since all elements must be inserted in sorted
order by the<TT> insert</TT> member function.
<BR><BR>If the passed index is negative or greater than the number of entries in the vector and the<TT> index_range</TT> exception
is enabled, the exception is thrown.&nbsp; If the exception is not enabled, the new element is inserted as the first element
when the index is negative, or as the last element when the index is too large.
<BR><BR>Several different results can occur if the vector is not large enough for the new element.&nbsp; If the<TT> resize_required</TT>
exception is enabled, the exception is thrown.&nbsp; If the exception is not enabled, the insert fails if the amount the vector
is to be grown (the second parameter to the constructor) is zero(0).&nbsp; Otherwise, the vector is automatically grown by
the number of elements specified to the constructor, using the<TT> resize</TT> member function.&nbsp; If<TT> resize</TT> fails,
the element is not inserted into the vector and the<TT> out_of_memory</TT> exception is thrown, if enabled.
<DT>Results:
<DD>The<TT> insertAt</TT> public member function inserts an element into the<TT> WCValOrderedVector</TT> object before the element
at the given index.&nbsp; A TRUE (non-zero) value is returned if the insert is successful.&nbsp; If the insert fails, a FALSE
(zero) value is returned.
<DT>See Also:
<DD><TT> append</TT>,<TT> insert</TT>,<TT> prepend</TT>,<TT> operator []</TT>,<TT> removeAt</TT>,<TT> WCExcept::index_range</TT>,<TT>
WCExcept::out_of_memory</TT>,<TT> WCExcept::resize_required</TT>
</DL>
<H2 ID="WCValSortedVectorXTypeY_WCValOrderedVectorXTypeY__isEmptyLR"> isEmpty() [WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int isEmpty() const;</TT>
<DT>Semantics:
<DD>The<TT> isEmpty</TT> public member function is used to determine if a vector object has any entries contained in it.
<DT>Results:
<DD>A TRUE value (non-zero) is returned if the vector object does not have any vector elements contained within it.&nbsp; A FALSE
(zero) result is returned if the vector contains at least one element.
<DT>See Also:
<DD><TT> entries</TT>
</DL>
<H2 ID="WCValSortedVectorXTypeY__lastLR__WCValOrderedVectorXTypeY__lastLR"> last() [WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Type last() const;</TT>
<DT>Semantics:
<DD>The<TT> last</TT> public member function returns the last element in the vector.&nbsp; The element is not removed from the
vector.
<BR><BR>If the vector is empty, one of two exceptions can be thrown.&nbsp; The<TT> empty_container</TT> exception is thrown
if it is enabled.&nbsp; Otherwise, if the<TT> index_range</TT> exception is enabled, it is thrown.&nbsp; If neither exception
is enabled, a first element of the vector is added with a default value.
<DT>Results:
<DD>The<TT> last</TT> public member function returns the value of the last element in the vector.
<DT>See Also:
<DD><TT> first</TT>,<TT> removeLast</TT>,<TT> WCExcept::index_range</TT>,<TT> WCExcept::resize_required</TT>
</DL>
<H2 ID="WCValSortedVectorXTypeY_WCValOrderedVectorXTypeY__occurrencesOfLR"> occurrencesOf() [WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int occurrencesOf( const Type &amp; ) const;</TT>
<DT>Semantics:
<DD>The<TT> occurrencesOf</TT> public member function returns the number of elements contained in the vector that are equivalent
to the passed value.&nbsp; A linear search is used by the<TT> WCValOrderedVector</TT> class to find the value.&nbsp; The<TT>
WCValSortedVector</TT> class uses a binary search.
<DT>Results:
<DD>The<TT> occurrencesOf</TT> public member function returns the number of elements equivalent to the passed value.
<DT>See Also:
<DD><TT> contains</TT>,<TT> find</TT>,<TT> index</TT>,<TT> operator []</TT>,<TT> removeAll</TT>
</DL>
<H2 ID="WCValSortedVectorXTypeY_WCValOrderedVectorXTypeY__operator_UVLR"> operator []() [WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Type &amp; operator []( int );</TT>
<BR><TT> const Type &amp; operator []( int ) const;</TT>
<DT>Semantics:
<DD><TT> operator []</TT> is the vector index operator.&nbsp; A reference to the object stored in the vector at the given index
is returned.&nbsp; If a constant vector is indexed, a reference to a constant element is returned.
<BR><BR>The<TT> append, insert, insertAt</TT> and<TT> prepend</TT> member functions are used to insert a new element into
a vector, and the<TT> remove, removeAll, removeAt, removeFirst</TT> and<TT> removeLast</TT> member functions remove elements.
&nbsp;The index operator cannot be used to change the number of entries in the vector.&nbsp; Searches may be performed using
the<TT> find</TT> and<TT> index</TT> member functions.
<BR><BR>If the vector is empty, one of two exceptions can be thrown.&nbsp; The<TT> empty_container</TT> exception is thrown
if it is enabled.&nbsp; Otherwise, if the<TT> index_range</TT> exception is enabled, it is thrown.&nbsp; If neither exception
is enabled, a first element of the vector is added with a default value.&nbsp; This element is added so that a reference to
a valid vector element can be returned.
<BR><BR>If the index value is negative and the<TT> index_range</TT> exception is enabled, the exception is thrown.&nbsp; An
attempt to index an element with index greater than or equal to the number of entries in the vector will also cause the<TT>
index_range</TT> exception to be thrown if enabled.&nbsp; If the exception is not enabled, attempting to index a negative
element will index the first element in the vector, and attempting to index an element after the last entry will index the
last element.
<BR><BR>Care must be taken when using the<TT> WCValSortedVector</TT> class not to change the ordering of the vector elements.
&nbsp;The result returned by the index operator must not be assigned to or modified in such a way that it is no longer equivalent
(by<TT> Type's</TT> equivalence operator) to the value inserted into the vector.&nbsp; Failure to comply may cause lookups
to work incorrectly, since the binary search algorithm assumes elements are in sorted order.
<DT>Results:
<DD>The<TT> operator []</TT> public member function returns a reference to the element at the given index.&nbsp; If the index
is invalid, a reference to the closest valid element is returned.&nbsp; The result of the non-constant index operator may
be assigned to.
<DT>See Also:
<DD><TT> append</TT>,<TT> find</TT>,<TT> first</TT>,<TT> index</TT>,<TT> insert</TT>,<TT> insertAt</TT>,<TT> isEmpty</TT>,<TT>
last</TT>,<TT> prepend</TT>,<TT> remove</TT>,<TT> removeAt</TT>,<TT> removeAll</TT>,<TT> removeFirst</TT>,<TT> removeLast</TT>,<TT>
WCExcept::empty_container</TT>,<TT> WCExcept::index_range</TT>
</DL>
<H2 ID="WCValSortedVectorXTypeY_WCValOrderedVectorXTypeY__operator_ELR"> operator =() [WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCValOrderedVector &amp; WCValOrderedVector::operator =( const WCValOrderedVector &amp; );</TT>
<BR><TT> WCValSortedVector &amp; WCValSortedVector::operator =( const WCValSortedVector &amp; );</TT>
<DT>Semantics:
<DD>The<TT> operator =</TT> public member function is the assignment operator for the class.&nbsp; The left hand side vector is
first cleared using the<TT> clear</TT> member function, and then the right hand side vector is copied.&nbsp; The left hand
side vector is made to have the same length and growth amount as the right hand side (the growth amount is the second argument
passed to the right hand side vector constructor).&nbsp; All of the vector elements and exception trap states are copied.
<BR><BR>If the left hand side vector cannot be fully created, it will have zero length.&nbsp; The<TT> out_of_memory</TT> exception
is thrown if enabled in the right hand side vector.
<DT>Results:
<DD>The<TT> operator =</TT> public member function assigns the left hand side vector to be a copy of the right hand side.
<DT>See Also:
<DD><TT> clear</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<H2 ID="WCValSortedVectorXTypeY_WCValOrderedVectorXTypeY__operator_EELR"> operator ==() [WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int WCValOrderedVector::operator ==( const WCValOrderedVector &amp; ) const;</TT>
<BR><TT> int WCValSortedVector::operator ==( const WCValSortedVector &amp; ) const;</TT>
<DT>Semantics:
<DD>The<TT> operator ==</TT> public member function is the equivalence operator for the class.&nbsp; Two vector objects are equivalent
if they are the same object and share the same address.
<DT>Results:
<DD>A TRUE (non-zero) value is returned if the left hand side and right hand side vectors are the same object.&nbsp; A FALSE (zero)
value is returned otherwise.
</DL>
<H2 ID="WCValOrderedVectorXTypeY__prependLR"> prepend() [WCValOrderedVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int prepend( const Type &amp; );</TT>
<DT>Semantics:
<DD>The<TT> prepend</TT> public member function inserts the passed element to be the first element in the vector.&nbsp; The data
stored in the vector is a copy of the data passed as a parameter.&nbsp; All vector elements contained in the vector are copied
(using<TT> Type's</TT> assignment operator) up one index.
<BR><BR>This function is not provided by the<TT> WCValSortedVector</TT> class, since all elements must be inserted in sorted
order by the<TT> insert</TT> member function.
<BR><BR>Several different results can occur if the vector is not large enough for the new element.&nbsp; If the<TT> resize_required</TT>
exception is enabled, the exception is thrown.&nbsp; If the exception is not enabled, the prepend fails if the amount the
vector is to be grown (the second parameter to the constructor) is zero(0).&nbsp; Otherwise, the vector is automatically grown
by the number of elements specified to the constructor, using the<TT> resize</TT> member function.&nbsp; If<TT> resize</TT>
fails, the element is not inserted to the vector and the<TT> out_of_memory</TT> exception is thrown, if enabled.
<DT>Results:
<DD>The<TT> prepend</TT> public member function prepends an element to the<TT> WCValOrderedVector</TT> object.&nbsp; A TRUE (non-zero)
value is returned if the insert is successful.&nbsp; If the insert fails, a FALSE (zero) value is returned.
<DT>See Also:
<DD><TT> append</TT>,<TT> insert</TT>,<TT> insertAt</TT>,<TT> WCExcept::out_of_memory</TT>,<TT> WCExcept::resize_required</TT>
</DL>
<H2 ID="WCValSortedVectorXTypeY__removeLR__WCValOrderedVectorXTypeY__removeLR"> remove() [WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int remove( const Type &amp; );</TT>
<DT>Semantics:
<DD>The<TT> remove</TT> public member function removes the first element in the vector which is equivalent to the passed value.
&nbsp;All vector elements stored after the removed elements are copied (using<TT> Type's</TT> assignment operator) down one
index.
<BR><BR>A linear search is used by the<TT> WCValOrderedVector</TT> class to find the element being removed.&nbsp; The<TT>
WCValSortedVector</TT> class uses a binary search.
<DT>Results:
<DD>The<TT> remove</TT> public member function removes the first element in the vector which is equivalent to the passed value.
&nbsp;A TRUE (non-zero) value is returned if an equivalent element was contained in the vector and removed.&nbsp; If the vector
did not contain an equivalent value, a FALSE (zero) value is returned.
<DT>See Also:
<DD><TT> clear</TT>,<TT> find</TT>,<TT> removeAll</TT>,<TT> removeAt</TT>,<TT> removeFirst</TT>,<TT> removeLast</TT>
</DL>
<H2 ID="WCValSortedVectorXTypeY_WCValOrderedVectorXTypeY__removeAllLR"> removeAll() [WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>unsigned removeAll( const Type &amp; );</TT>
<DT>Semantics:
<DD>The<TT> removeAll</TT> public member function removes all elements in the vector which are equivalent to the passed value.
&nbsp;All vector elements stored after the removed elements are copied (using<TT> Type's</TT> assignment operator) down one
or more indexes to take the place of the removed elements.
<BR><BR>A linear search is used by the<TT> WCValOrderedVector</TT> class to find the elements being removed.&nbsp; The<TT>
WCValSortedVector</TT> class uses a binary search.
<DT>Results:
<DD>The<TT> removeAll</TT> public member function removes all elements in the vector which are equivalent to the passed value.
&nbsp;The number of elements removed is returned.
<DT>See Also:
<DD><TT> clear</TT>,<TT> find</TT>,<TT> occurrencesOf</TT>,<TT> remove</TT>,<TT> removeAt</TT>,<TT> removeFirst</TT>,<TT> removeLast</TT>
</DL>
<H2 ID="WCValSortedVectorXTypeY_WCValOrderedVectorXTypeY__removeAtLR"> removeAt() [WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int removeAt( int );</TT>
<DT>Semantics:
<DD>The<TT> removeAt</TT> public member function removes the element at the given index.&nbsp; All vector elements stored after
the removed elements are copied (using<TT> Type's</TT> assignment operator) down one index.
<BR><BR>If the vector is empty and the<TT> empty_container</TT> exception is enabled, the exception is thrown.
<BR><BR>If an attempt to remove an element with a negative index is made and the<TT> index_range</TT> exception is enabled,
the exception is thrown.&nbsp; If the exception is not enabled, the first element is removed from the vector.&nbsp; Attempting
to remove an element with index greater or equal to the number of entries in the vector also causes the<TT> index_range</TT>
exception to be thrown if enabled.&nbsp; The last element in the vector is removed if the exception is not enabled.
<DT>Results:
<DD>The<TT> removeAt</TT> public member function removes the element with the given index.&nbsp; If the index is invalid, the
closest element to the given index is removed.&nbsp; A TRUE (non-zero) value is returned if an element was removed.&nbsp;
If the vector was empty, FALSE (zero) value is returned.
<DT>See Also:
<DD><TT> clear</TT>,<TT> insertAt</TT>,<TT> operator []</TT>,<TT> remove</TT>,<TT> removeAll</TT>,<TT> removeFirst</TT>,<TT> removeLast</TT>
</DL>
<H2 ID="WCValSortedVectorXTypeY_WCValOrderedVectorXTypeY__removeFirstLR"> removeFirst() [WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int removeFirst();</TT>
<DT>Semantics:
<DD>The<TT> removeFirst</TT> public member function removes the first element from a vector.&nbsp; All other vector elements are
copied (using<TT> Type's</TT> assignment operator) down one index.
<BR><BR>If the vector is empty and the<TT> empty_container</TT> exception is enabled, the exception is thrown.
<DT>Results:
<DD>The<TT> removeFirst</TT> public member function removes the first element from the vector.&nbsp; A TRUE (non-zero) value is
returned if an element was removed.&nbsp; If the vector was empty, FALSE (zero) value is returned.
<DT>See Also:
<DD><TT> clear</TT>,<TT> first</TT>,<TT> remove</TT>,<TT> removeAt</TT>,<TT> removeAll</TT>,<TT> removeLast</TT>
</DL>
<H2 ID="WCValSortedVectorXTypeY_WCValOrderedVectorXTypeY__removeLastLR"> removeLast() [WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int removeLast();</TT>
<DT>Semantics:
<DD>The<TT> removeLast</TT> public member function removes the last element from a vector.&nbsp; If the vector is empty and the<TT>
empty_container</TT> exception is enabled, the exception is thrown.
<DT>Results:
<DD>The<TT> removeLast</TT> public member function removes the last element from the vector.&nbsp; A TRUE (non-zero) value is
returned if an element was removed.&nbsp; If the vector was empty, FALSE (zero) value is returned.
<DT>See Also:
<DD><TT> clear</TT>,<TT> last</TT>,<TT> remove</TT>,<TT> removeAt</TT>,<TT> removeAll</TT>,<TT> removeFirst</TT>
</DL>
<H2 ID="WCValSortedVectorXTypeY__resizeLR__WCValOrderedVectorXTypeY__resizeLR"> resize() [WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int resize( size_t new_size );</TT>
<DT>Semantics:
<DD>The<TT> resize</TT> public member function is used to change the vector size to be able to store<B> new_size</B> elements.
&nbsp;If<B> new_size</B> is larger than the previous vector size, all elements are copied (using<TT> Type's</TT> copy constructor)
into the newly sized vector, and new elements can be added using the<TT> append, insert, insertAt,</TT> and<TT> prepend</TT>
member functions.&nbsp; If the vector is resized to a smaller size, the first<B> new_size</B> elements are copied (all vector
elements if the vector contained<B> new_size</B> or fewer elements).&nbsp; The remaining elements are destroyed using<TT>
Type's</TT> destructor.
<BR><BR>If the resize cannot be performed and the<TT> out_of_memory</TT> exception is enabled, the exception is thrown.
<DT>Results:
<DD>The vector is resized to<B> new_size</B>.&nbsp; A TRUE value (non-zero) is returned if the resize is successful.&nbsp; A FALSE
(zero) result is returned if the resize fails.
<DT>See Also:
<DD><TT> WCExcept::out_of_memory</TT>
</DL>
<H2 ID="WCValVectorXTypeY_Class_Description"> WCValVector&lt;Type&gt; Class Description </H2>
<DL>
<DT>Declared:
<DD><TT> wcvector.h</TT>
<BR><BR>The<TT> WCValVector&lt;Type&gt;</TT> class is a templated class used to store objects in a vector.&nbsp; Vectors are
similar to arrays, but vectors perform bounds checking and can be resized.&nbsp; Elements are inserted into the vector by
assigning to a vector index.
<BR>The<TT> WCValOrderedVector</TT> and<TT> WCValSortedVector</TT> classes are also available.&nbsp; They provide a more abstract
view of the vector and additional functionality, including finding and removing elements.
<BR><BR>Values are copied into the vector, which could be undesirable if the stored objects are complicated and copying is
expensive.&nbsp; Value vectors should not be used to store objects of a base class if any derived types of different sizes
would be stored in the vector, or if the destructor for a derived class must be called.
<BR><BR>In the description of each member function, the text<TT> Type</TT> is used to indicate the template parameter defining
the type of the elements stored in the vector.
<BR><BR>The<TT> WCExcept</TT> class is a base class of the<TT> WCValVector&lt;Type&gt;</TT> class and provides the<TT> exceptions</TT>
member function.&nbsp; This member function controls the exceptions which can be thrown by the<TT> WCValVector&lt;Type&gt;</TT>
object.&nbsp; No exceptions are enabled unless they are set by the<TT> exceptions</TT> member function.
<BR><BR><B>Requirements of Type</B>
<BR><BR>The<TT> WCValVector&lt;Type&gt;</TT> class requires<TT> Type</TT> to have:
<BR>A default constructor (<TT> Type::Type()</TT> ).
<BR><BR>A well defined copy constructor (<TT> Type::Type( const Type &amp; )</TT> ).
<BR><BR>The following override of<TT> operator new()</TT> only if<TT> Type</TT> overrides the global<TT> operator new():</TT>
<BR><BR><TT>void * operator new( size_t, void *ptr ) { return( ptr ); }</TT>
<BR><BR><B>Public Member Functions</B>
<BR><BR>The following member functions are declared in the public interface:
<BR><BR><TT>WCValVector( size_t = 0 );</TT>
<BR><TT> WCValVector( size_t, const Type &amp; );</TT>
<BR><TT> WCValVector( const WCValVector &amp; );</TT>
<BR><TT> virtual ~WCValVector();</TT>
<BR><TT> void clear();</TT>
<BR><TT> size_t length() const;</TT>
<BR><TT> int resize( size_t );</TT>
<BR><BR><B>Public Member Operators</B>
<BR><BR>The following member operators are declared in the public interface:
<BR><BR><TT>Type &amp; operator []( int );</TT>
<BR><TT> const Type &amp; operator []( int ) const;</TT>
<BR><TT> WCValVector &amp; operator =( const WCValVector &amp; );</TT>
<BR><TT> int operator ==( const WCValVector &amp; ) const;</TT>
</DL>
<H2 ID="WCValVectorXTypeY__WCValVectorLR"> WCValVector() [WCValVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCValVector( size_t = 0 );</TT>
<DT>Semantics:
<DD>The public<TT> WCValVector&lt;Type&gt;</TT> constructor creates a<TT> WCValVector&lt;Type&gt;</TT> object able to store the
number of elements specified in the optional parameter, which defaults to zero.&nbsp; All vector elements are initialized
with<TT> Type's</TT> default constructor.
<BR><BR>If the vector object cannot be fully initialized, the vector is created with length zero.
<DT>Results:
<DD>The public<TT> WCValVector&lt;Type&gt;</TT> constructor creates an initialized<TT> WCValVector&lt;Type&gt;</TT> object with
the specified length.
<DT>See Also:
<DD><TT> WCValVector&lt;Type&gt;</TT>,<TT> ~WCValVector&lt;Type&gt;</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCValVector( size_t, const Type &amp; );</TT>
<DT>Semantics:
<DD>The public<TT> WCValVector&lt;Type&gt;</TT> constructor creates a<TT> WCValVector&lt;Type&gt;</TT> object able to store the
number of elements specified by the first parameter.&nbsp; All vector elements are initialized to the value of the second
parameter using<TT> Type's</TT> copy constructor.
<BR><BR>If the vector object cannot be fully initialized, the vector is created with length zero.
<DT>Results:
<DD>The public<TT> WCValVector&lt;Type&gt;</TT> constructor creates an initialized<TT> WCValVector&lt;Type&gt;</TT> object with
the specified length and elements set to the given value.
<DT>See Also:
<DD><TT> WCValVector&lt;Type&gt;</TT>,<TT> ~WCValVector&lt;Type&gt;</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCValVector( const WCValVector &amp; );</TT>
<DT>Semantics:
<DD>The public<TT> WCValVector&lt;Type&gt;</TT> constructor is the copy constructor for the<TT> WCValVector&lt;Type&gt;</TT> class.
&nbsp;The new vector is created with the same length as the given vector.&nbsp; All of the vector elements and exception trap
states are copied.
<BR><BR>If the new vector cannot be fully created, it will have length zero.&nbsp; The<TT> out_of_memory</TT> exception is
thrown if enabled in the vector being copied.
<DT>Results:
<DD>The public<TT> WCValVector&lt;Type&gt;</TT> constructor creates a<TT> WCValVector&lt;Type&gt;</TT> object which is a copy
of the passed vector.
<DT>See Also:
<DD><TT> operator =</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<H2 ID="WCValVectorXTypeY____WCValVectorLR"> ~WCValVector() [WCValVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>virtual ~WCValVector();</TT>
<DT>Semantics:
<DD>The public<TT> ~WCValVector&lt;Type&gt;</TT> destructor is the destructor for the<TT> WCValVector&lt;Type&gt;</TT> class.
&nbsp;If the vector is not length zero and the<TT> not_empty</TT> exception is enabled, the exception is thrown.&nbsp; Otherwise,
the vector elements are cleared using the<TT> clear</TT> member function.&nbsp; The call to the public<TT> ~WCValVector&lt;Type&gt;</TT>
destructor is inserted implicitly by the compiler at the point where the<TT> WCValVector&lt;Type&gt;</TT> object goes out
of scope.
<DT>Results:
<DD>The public<TT> ~WCValVector&lt;Type&gt;</TT> destructor destroys an<TT> WCValVector&lt;Type&gt;</TT> object.
<DT>See Also:
<DD><TT> clear</TT>,<TT> WCExcept::not_empty</TT>
</DL>
<H2 ID="WCValVectorXTypeY__clearLR"> clear() [WCValVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void clear();</TT>
<DT>Semantics:
<DD>The<TT> clear</TT> public member function is used to clear the vector so that it is of zero length.&nbsp; Elements stored
in the vector are destroyed using<TT> Type's</TT> destructor.&nbsp; The vector object is not destroyed and re-created by this
function, so the object destructor is not invoked.
<DT>Results:
<DD>The<TT> clear</TT> public member function clears the vector to have zero length and no vector elements.
<DT>See Also:
<DD><TT> ~WCValVector&lt;Type&gt;</TT>,<TT> operator =</TT>
</DL>
<H2 ID="WCValVectorXTypeY__lengthLR"> length() [WCValVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>size_t length() const;</TT>
<DT>Semantics:
<DD>The<TT> length</TT> public member function is used to find the number of elements which can be stored in the<TT> WCValVector&lt;Type&gt;</TT>
object.
<DT>Results:
<DD>The<TT> length</TT> public member function returns the length of the vector.
<DT>See Also:
<DD><TT> resize</TT>
</DL>
<H2 ID="WCValVectorXTypeY__operator_UVLR"> operator []() [WCValVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>Type &amp; operator []( int );</TT>
<BR><TT> const Type &amp; operator []( int ) const;</TT>
<DT>Semantics:
<DD><TT> operator []</TT> is the vector index operator.&nbsp; A reference to the object stored in the vector at the given index
is returned.&nbsp; If a constant vector is indexed, a reference to a constant element is returned.&nbsp; The index operator
of a non-constant vector is the only way to insert an element into the vector.
<BR><BR>If an attempt to access an element with index greater than or equal to the length of a non-constant vector is made
and the<TT> resize_required</TT> exception is enabled, the exception is thrown.&nbsp; If the exception is not enabled, the
vector is automatically resized using the<TT> resize</TT> member function to have length the index value plus one.&nbsp; New
vector elements are initialized using<TT> Type's</TT> default constructor.&nbsp; If the resize failed, and the<TT> out_of_memory</TT>
exception is enabled, the exception is thrown.&nbsp; If the exception is not enabled and the resize failed, the last element
is indexed (a new element if the vector was zero length).&nbsp; If a negative value is used to index the non-constant vector
and the<TT> index_range</TT> exception is enabled, the exception is thrown.&nbsp; If the exception is not enabled and the
vector is empty, the<TT> resize_required</TT> exception may be thrown.
<BR><BR>An attempt to index an empty constant vector may cause one of two exceptions to be thrown.&nbsp; If the<TT> empty_container</TT>
exception is enabled, it is thrown.&nbsp; Otherwise, the<TT> index_range</TT> exception is thrown, if enabled.&nbsp; If neither
exception is enabled, a first vector element is added and indexed (so that a reference to a valid element can be returned).
<BR><BR>Indexing with a negative value or a value greater than or equal to the length of a constant vector causes the<TT>
index_range</TT> exception to be thrown, if enabled.
<DT>Results:
<DD>The<TT> operator []</TT> public member function returns a reference to the element at the given index.&nbsp; If the index
is invalid, a reference to the closest valid element is returned.&nbsp; The result of the non-constant index operator may
be assigned to.
<DT>See Also:
<DD><TT> resize</TT>,<TT> WCExcept::empty_container</TT>,<TT> WCExcept::index_range</TT>,<TT> WCExcept::out_of_memory</TT>,<TT>
WCExcept::resize_required</TT>
</DL>
<H2 ID="WCValVectorXTypeY__operator_ELR"> operator =() [WCValVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>WCValVector &amp; operator =( const WCValVector &amp; );</TT>
<DT>Semantics:
<DD>The<TT> operator =</TT> public member function is the assignment operator for the<TT> WCValVector&lt;Type&gt;</TT> class.
&nbsp;The left hand side vector is first cleared using the<TT> clear</TT> member function, and then the right hand side vector
is copied.&nbsp; The left hand side vector is made to have the same length as the right hand side.&nbsp; All of the vector
elements and exception trap states are copied.
<BR><BR>If the left hand side vector cannot be fully created, it will have zero length.&nbsp; The<TT> out_of_memory</TT> exception
is thrown if enabled in the right hand side vector.
<DT>Results:
<DD>The<TT> operator =</TT> public member function assigns the left hand side vector to be a copy of the right hand side.
<DT>See Also:
<DD><TT> clear</TT>,<TT> WCExcept::out_of_memory</TT>
</DL>
<H2 ID="WCValVectorXTypeY__operator_EELR"> operator ==() [WCValVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int operator ==( const WCValVector &amp; ) const;</TT>
<DT>Semantics:
<DD>The<TT> operator ==</TT> public member function is the equivalence operator for the<TT> WCValVector&lt;Type&gt;</TT> class.
&nbsp;Two vector objects are equivalent if they are the same object and share the same address.
<DT>Results:
<DD>A TRUE (non-zero) value is returned if the left hand side and right hand side vectors are the same object.&nbsp; A FALSE (zero)
value is returned otherwise.
</DL>
<H2 ID="WCValVectorXTypeY__resizeLR"> resize() [WCValVector&lt;Type&gt;] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wcvector.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int resize( size_t new_size );</TT>
<DT>Semantics:
<DD>The<TT> resize</TT> public member function is used to change the vector size to be able to store<B> new_size</B> elements.
&nbsp;If<B> new_size</B> is larger than the previous vector size, all elements will be copied (using<TT> Type's</TT> copy
constructor) into the newly sized vector, and new elements are initialized with<TT> Type's</TT> default constructor.&nbsp;
If the vector is resized to a smaller size, the first<B> new_size</B> elements are copied.&nbsp; The remaining elements are
destroyed using<TT> Type's</TT> destructor.
<BR><BR>If the resize cannot be performed and the<TT> out_of_memory</TT> exception is enabled, the exception is thrown.
<DT>Results:
<DD>The vector is resized to<B> new_size</B>.&nbsp; A TRUE value (non-zero) is returned if the resize is successful.&nbsp; A FALSE
(zero) result is returned if the resize fails.
<DT>See Also:
<DD><TT> WCExcept::out_of_memory</TT>
</DL>
<H1 ID="InputDOutput_Classes"> Input/Output Classes </H1>
<BR>The input/output stream classes provide program access to the file system.&nbsp; In addition, various options for formatting
of output and reading of input are provided.
<H2 ID="filebuf_Class_Description"> filebuf Class Description </H2>
<DL>
<DT>Declared:
<DD><TT> fstream.h</TT>
<DT>Derived from:
<DD><TT> streambuf</TT>
<BR><BR>The<TT> filebuf</TT> class is derived from the<TT> streambuf</TT> class, and provides additional functionality required
to communicate with external files.&nbsp; Seek operations are supported when the underlying file supports seeking.&nbsp; Both
input and output operations may be performed using a<TT> filebuf</TT> object, again when the underlying file supports read/write
access.
<BR><TT>filebuf</TT> objects are buffered by default, so the<B> reserve area</B> is allocated automatically unless one is
specified when the<TT> filebuf</TT> object is created.&nbsp; The<B> get area</B> and<B> put area</B> pointers operate as if
they were tied together.&nbsp; There is only one current position in a<TT> filebuf</TT> object.
<BR><BR>The<TT> filebuf</TT> class allows only the<B> get area</B> or the<B> put area</B>, but not both, to be active at a
time.&nbsp; This follows from the capability of files opened for both reading and writing to have operations of each type
performed at arbitrary locations in the file.&nbsp; When writing is occurring, the characters are buffered in the<B> put area</B>.
&nbsp;If a seek or read operation is done, the<B> put area</B> must be flushed before the next operation in order to ensure
that the characters are written to the proper location in the file.&nbsp; Similarly, if reading is occurring, characters are
buffered in the<B> get area</B>.&nbsp; If a write operation is done, the<B> get area</B> must be flushed and synchronized
before the write operation in order to ensure the write occurs at the proper location in the file.&nbsp; If a seek operation
is done, the<B> get area</B> does not have to be synchronized, but is discarded.&nbsp; When the<B> get area</B> is empty and
a read is done, the<TT> underflow</TT> virtual member function reads more characters and fills the<B> get area</B> again.
&nbsp;When the<B> put area</B> is full and a write is done, the<TT> overflow</TT> virtual member function writes the characters
and makes the<B> put area</B> empty again.
<BR><BR>C++ programmers who wish to use files without deriving new objects do not need to explicitly create or use a<TT> filebuf</TT>
object.
<BR><BR><B>Public Data Members</B>
<BR><BR>The following data member is declared in the public interface.&nbsp; Its value is the default file protection that
is used when creating new files.&nbsp; It is primarily referenced as a default argument in member functions.
<BR><BR><TT>static int const openprot;</TT>
<BR><BR><B>Public Member Functions</B>
<BR><BR>The following member functions are declared in the public interface:
<BR><BR><TT>filebuf();</TT>
<BR><TT> filebuf( filedesc );</TT>
<BR><TT> filebuf( filedesc, char *, int );</TT>
<BR><TT> ~filebuf();</TT>
<BR><TT> int is_open() const;</TT>
<BR><TT> filedesc fd() const;</TT>
<BR><TT> filebuf *attach( filedesc );</TT>
<BR><TT> filebuf *open( char const *,</TT>
<BR><TT> ios::openmode,</TT>
<BR><TT>int = filebuf::openprot );</TT>
<BR><TT>filebuf *close();</TT>
<BR><TT> virtual int pbackfail( int );</TT>
<BR><TT> virtual int overflow( int = EOF );</TT>
<BR><TT> virtual int underflow();</TT>
<BR><TT> virtual streambuf *setbuf( char *, int );</TT>
<BR><TT> virtual streampos seekoff( streamoff,</TT>
<BR><TT> ios::seekdir,</TT>
<BR><TT>ios::openmode );</TT>
<BR><TT>virtual int sync();</TT>
<DT>See Also:
<DD><TT> fstreambase</TT>,<TT> streambuf</TT>
</DL>
<H2 ID="filebuf__attachLR"> attach() [filebuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;fstream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>filebuf *filebuf::attach( filedesc hdl );</TT>
<DT>Semantics:
<DD>The<TT> attach</TT> public member function connects an existing<TT> filebuf</TT> object to an open file via the file's descriptor
or handle specified by<B> hdl</B>.&nbsp; If the<TT> filebuf</TT> object is already connected to a file, the<TT> attach</TT>
public member function fails.&nbsp; Otherwise, the<TT> attach</TT> public member function extracts information from the file
system to determine the capabilities of the file and hence the<TT> filebuf</TT> object.
<DT>Results:
<DD>The<TT> attach</TT> public member function returns a pointer to the<TT> filebuf</TT> object on success, otherwise<TT> NULL</TT>
is returned.
<DT>See Also:
<DD><TT> filebuf</TT>,<TT> fd</TT>,<TT> open</TT>
</DL>
<H2 ID="filebuf__closeLR"> close() [filebuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;fstream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>filebuf *filebuf::close();</TT>
<DT>Semantics:
<DD>The<TT> close</TT> public member function disconnects the<TT> filebuf</TT> object from a connected file and closes the file.
&nbsp;Any buffered output is flushed before the file is closed.
<DT>Results:
<DD>The<TT> close</TT> public member function returns a pointer to the<TT> filebuf</TT> object on success, otherwise<TT> NULL</TT>
is returned.
<DT>See Also:
<DD><TT> filebuf</TT>,<TT> fd</TT>,<TT> is_open</TT>
</DL>
<H2 ID="filebuf__fdLR"> fd() [filebuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;fstream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>filedesc filebuf::fd() const;</TT>
<DT>Semantics:
<DD>The<TT> fd</TT> public member function queries the state of the<TT> filebuf</TT> object file handle.
<DT>Results:
<DD>The<TT> fd</TT> public member function returns the file descriptor or handle of the file to which the<TT> filebuf</TT> object
is currently connected.&nbsp; If the<TT> filebuf</TT> object is not currently connected to a file,<TT> EOF</TT> is returned.
<DT>See Also:
<DD><TT> filebuf::attach</TT>,<TT> is_open</TT>
</DL>
<H2 ID="filebuf__filebufLR"> filebuf() [filebuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;fstream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>filebuf::filebuf();</TT>
<DT>Semantics:
<DD>This form of the public<TT> filebuf</TT> constructor creates a<TT> filebuf</TT> object that is not currently connected to
any file.&nbsp; A call to the<TT> fd</TT> member function for this created<TT> filebuf</TT> object returns<TT> EOF</TT>, unless
a file is connected using the<TT> attach</TT> member function.
<DT>Results:
<DD>The public<TT> filebuf</TT> constructor produces a<TT> filebuf</TT> object that is not currently connected to any file.
<DT>See Also:
<DD><TT> ~filebuf</TT>,<TT> attach</TT>,<TT> open</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;fstream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>filebuf::filebuf( filedesc hdl );</TT>
<DT>Semantics:
<DD>This form of the public<TT> filebuf</TT> constructor creates a<TT> filebuf</TT> object that is connected to an open file.
&nbsp;The file is specified via the<B> hdl</B> parameter, which is a file descriptor or handle.
<BR><BR>This form of the public<TT> filebuf</TT> constructor is similar to using the default constructor, and calling the<TT>
attach</TT> member function.&nbsp; A call to the<TT> fd</TT> member function for this created<TT> filebuf</TT> object returns<B>
hdl</B>.
<DT>Results:
<DD>The public<TT> filebuf</TT> constructor produces a<TT> filebuf</TT> object that is connected to<B> hdl</B>.
<DT>See Also:
<DD><TT> ~filebuf</TT>,<TT> attach</TT>,<TT> open</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;fstream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>filebuf::filebuf( filedesc hdl, char *buf, int len );</TT>
<DT>Semantics:
<DD>This form of the public<TT> filebuf</TT> constructor creates a<TT> filebuf</TT> object that is connected to an open file and
that uses the buffer specified by<B> buf</B> and<B> len</B>.&nbsp; The file is specified via the<B> hdl</B> parameter, which
is a file descriptor or handle.&nbsp; If<B> buf</B> is<TT> NULL</TT> and/or<B> len</B> is less than or equal to zero, the<TT>
filebuf</TT> object is unbuffered, so that reading and/or writing take place one character at a time.
<BR><BR>This form of the public<TT> filebuf</TT> constructor is similar to using the default constructor, and calling the<TT>
attach</TT> and<TT> setbuf</TT> member functions.
<DT>Results:
<DD>The public<TT> filebuf</TT> constructor constructor produces a<TT> filebuf</TT> object that is connected to<B> hdl</B>.
<DT>See Also:
<DD><TT> ~filebuf</TT>,<TT> attach</TT>,<TT> open</TT>,<TT> setbuf</TT>
</DL>
<H2 ID="filebuf____filebufLR"> ~filebuf() [filebuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;fstream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>filebuf::~filebuf();</TT>
<DT>Semantics:
<DD>The public<TT> ~filebuf</TT> destructor closes the file if it was explicitly opened using the<TT> open</TT> member function.
&nbsp;Otherwise, the destructor takes no explicit action.&nbsp; The<TT> streambuf</TT> destructor is called to destroy that
portion of the<TT> filebuf</TT> object.&nbsp; The call to the public<TT> ~filebuf</TT> destructor is inserted implicitly by
the compiler at the point where the<TT> filebuf</TT> object goes out of scope.
<DT>Results:
<DD>The<TT> filebuf</TT> object is destroyed.
<DT>See Also:
<DD><TT> ~filebuf</TT>,<TT> close</TT>
</DL>
<H2 ID="filebuf__is_openLR"> is_open() [filebuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;fstream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int filebuf::is_open();</TT>
<DT>Semantics:
<DD>The<TT> is_open</TT> public member function queries the<TT> filebuf</TT> object state.
<DT>Results:
<DD>The<TT> is_open</TT> public member function returns a non-zero value if the<TT> filebuf</TT> object is currently connected
to a file.&nbsp; Otherwise, zero is returned.
<DT>See Also:
<DD><TT> filebuf::attach</TT>,<TT> close</TT>,<TT> fd</TT>,<TT> open</TT>
</DL>
<H2 ID="filebuf__openLR"> open() [filebuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;fstream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>filebuf *filebuf::open( const char *name,</TT>
<BR><TT> ios::openmode mode,</TT>
<BR><TT>int prot = filebuf::openprot );</TT>
<DT>Semantics:
<DD>The<TT> open</TT> public member function is used to connect the<TT> filebuf</TT> object to a file specified by the<B> name</B>
parameter.&nbsp; The file is opened using the specified<B> mode</B>.&nbsp; For details about the<B> mode</B> parameter, see
the description of<TT> ios::openmode</TT>.&nbsp; The<B> prot</B> parameter specifies the file protection attributes to use
when creating a file.
<DT>Results:
<DD>The<TT> open</TT> public member function returns a pointer to the<TT> filebuf</TT> object on success, otherwise<TT> NULL</TT>
is returned.
<DT>See Also:
<DD><TT> filebuf</TT>,<TT> close</TT>,<TT> is_open</TT>,<TT> openprot</TT>
</DL>
<H2 ID="filebuf__openprot"> openprot [filebuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;fstream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>static int const filebuf::openprot;</TT>
<DT>Semantics:
<DD>The<TT> openprot</TT> public member data is used to specify the default file protection to be used when creating new files.
&nbsp;This value is used as the default if no user specified value is provided.
<BR><BR>The default value is octal 0644.&nbsp; This is generally interpreted as follows:
<UL>
<LI>Owner:&nbsp; read/write
<LI>Group:&nbsp; read
<LI>World:&nbsp; read
</UL>
<BR>Note that not all operating systems support all bits.
<DT>See Also:
<DD><TT> filebuf</TT>,<TT> open</TT>
</DL>
<H2 ID="filebuf__overflowLR"> overflow() [filebuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;fstream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>virtual int filebuf::overflow( int ch = EOF );</TT>
<DT>Semantics:
<DD>The<TT> overflow</TT> public virtual member function provides the output communication to the file to which the<TT> filebuf</TT>
object is connected.&nbsp; Member functions in the<TT> streambuf</TT> class call the<TT> overflow</TT> public virtual member
function for the derived class when the<B> put area</B> is full.
<BR><BR>The<TT> overflow</TT> public virtual member function performs the following steps:
<OL>
<LI>If no buffer is present, a buffer is allocated with the<TT> streambuf::allocate</TT> member function, which may call the<TT>
doallocate</TT> virtual member function.&nbsp; The<B> put area</B> is then set up.&nbsp; If, after calling<TT> streambuf::allocate</TT>,
no buffer is present, the<TT> filebuf</TT> object is unbuffered and<B> ch</B> (if not<TT> EOF</TT>) is written directly to
the file without buffering, and no further action is taken.
<LI>If the<B> get area</B> is present, it is flushed with a call to the<TT> sync</TT> virtual member function.&nbsp; Note
that the<B> get area</B> won't be present if a buffer was set up in step 1.
<LI>If<B> ch</B> is not<TT> EOF</TT>, it is added to the<B> put area</B>, if possible.
<LI>Any characters in the<B> put area</B> are written to the file.
<LI>The<B> put area</B> pointers are updated to reflect the new state of the<B> put area</B>.&nbsp; If the write did not complete,
the unwritten portion of the<B> put area</B> is still present.&nbsp; If the<B> put area</B> was full before the write,<B>
ch</B> (if not<TT> EOF</TT>) is placed at the start of the<B> put area</B>.&nbsp; Otherwise, the<B> put area</B> is empty.
</OL>
<DT>Results:
<DD>The<TT> overflow</TT> public virtual member function returns<TT> __NOT_EOF</TT> on success, otherwise<TT> EOF</TT> is returned.
<DT>See Also:
<DD><TT> streambuf::overflow</TT>
<BR><BR><TT>filebuf::underflow</TT>
</DL>
<H2 ID="filebuf__pbackfailLR"> pbackfail() [filebuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;fstream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>virtual int filebuf::pbackfail( int ch );</TT>
<DT>Semantics:
<DD>The<TT> pbackfail</TT> public virtual member function handles an attempt to put back a character when there is no room at
the beginning of the<B> get area</B>.&nbsp; The<TT> pbackfail</TT> public virtual member function first calls the<TT> sync</TT>
virtual member function to flush the<B> put area</B> and then it attempts to seek backwards over<B> ch</B> in the associated
file.
<DT>Results:
<DD>The<TT> pbackfail</TT> public virtual member function returns<B> ch</B> on success, otherwise<TT> EOF</TT> is returned.
<DT>See Also:
<DD><TT> streambuf::pbackfail</TT>
</DL>
<H2 ID="filebuf__seekoffLR"> seekoff() [filebuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;fstream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>virtual streampos filebuf::seekoff( streamoff offset,</TT>
<BR><TT> ios::seekdir dir,</TT>
<BR><TT>ios::openmode mode );</TT>
<DT>Semantics:
<DD>The<TT> seekoff</TT> public virtual member function is used to position the<TT> filebuf</TT> object (and hence the file) to
a particular offset so that subsequent input or output operations commence from that point.&nbsp; The offset is specified
by the<B> offset</B> and<B> dir</B> parameters.
<BR><BR>Since the<B> get area</B> and<B> put area</B> pointers are tied together for the<TT> filebuf</TT> object, the<B> mode</B>
parameter is ignored.
<BR><BR>Before the actual seek occurs, the<B> get area</B> and<B> put area</B> of the<TT> filebuf</TT> object are flushed
via the<TT> sync</TT> virtual member function.&nbsp; Then, the new position in the file is calculated and the seek takes place.
<BR><BR>The<B> dir</B> parameter may be<TT> ios::beg</TT>,<TT> ios::cur</TT>, or<TT> ios::end</TT> and is interpreted in conjunction
with the<B> offset</B> parameter as follows:
<BR><BR><TT>ios::beg</TT>&nbsp; the <B>offset</B> is relative to the start and should be a positive value.
<BR><TT>ios::cur</TT>&nbsp; the <B>offset</B> is relative to the current position and may be positive
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (seek towards end) or negative (seek towards start).
<BR><TT>ios::end</TT>&nbsp; the <B>offset</B> is relative to the end and should be a negative value.
<BR><BR>If the<B> dir</B> parameter has any other value, or the<B> offset</B> parameter does not have an appropriate sign,
the<TT> seekoff</TT> public virtual member function fails.
<DT>Results:
<DD>The<TT> seekoff</TT> public virtual member function returns the new position in the file on success, otherwise<TT> EOF</TT>
is returned.
<DT>See Also:
<DD><TT> streambuf::seekoff</TT>
</DL>
<H2 ID="filebuf__setbufLR"> setbuf() [filebuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;fstream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>virtual streambuf *filebuf::setbuf( char *buf, int len );</TT>
<DT>Semantics:
<DD>The<TT> setbuf</TT> public virtual member function is used to offer a buffer, specified by<B> buf</B> and<B> len</B> to the<TT>
filebuf</TT> object.&nbsp; If the<B> buf</B> parameter is<TT> NULL</TT> or the<B> len</B> is less than or equal to zero, the
request is to make the<TT> filebuf</TT> object unbuffered.
<BR><BR>If the<TT> filebuf</TT> object is already connected to a file and has a buffer, the offer is rejected.&nbsp; In other
words, a call to the<TT> setbuf</TT> public virtual member function after the<TT> filebuf</TT> object has started to be used
usually fails because the<TT> filebuf</TT> object has set up a buffer.
<BR><BR>If the request is to make the<TT> filebuf</TT> object unbuffered, the offer succeeds.
<BR><BR>If the<B> buf</B> is too small (less than five characters), the offer is rejected.&nbsp; Five characters are required
to support the default putback area.
<BR><BR>Otherwise, the<B> buf</B> is acceptable and the offer succeeds.
<BR><BR>If the offer succeeds, the<TT> streambuf::setb</TT> member function is called to set up the pointers to the buffer.
&nbsp;The<TT> streambuf::setb</TT> member function releases the old buffer (if present), depending on how that buffer was
allocated.
<BR><BR>Calls to the<TT> setbuf</TT> public virtual member function are usually made by a class derived from the<TT> fstream</TT>
class, not directly by a user program.
<DT>Results:
<DD>The<TT> setbuf</TT> public virtual member function returns a pointer to the<TT> filebuf</TT> object on success, otherwise<TT>
NULL</TT> is returned.
<DT>See Also:
<DD><TT> streambuf::setbuf</TT>
</DL>
<H2 ID="filebuf__syncLR"> sync() [filebuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;fstream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>virtual int filebuf::sync();</TT>
<DT>Semantics:
<DD>The<TT> sync</TT> public virtual member function synchronizes the<TT> filebuf</TT> object with the external file or device.
&nbsp;If the<B> put area</B> contains characters it is flushed.&nbsp; This leaves the file positioned after the last written
character.&nbsp; If the<B> get area</B> contains buffered (unread) characters, file is backed up to be positioned after the
last read character.
<BR><BR>Note that the<B> get area</B> and<B> put area</B> never both contain characters.
<DT>Results:
<DD>The<TT> sync</TT> public virtual member function returns<TT> __NOT_EOF</TT> on success, otherwise<TT> EOF</TT> is returned.
<DT>See Also:
<DD><TT> streambuf::sync</TT>
</DL>
<H2 ID="filebuf__underflowLR"> underflow() [filebuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;fstream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>virtual int filebuf::underflow();</TT>
<DT>Semantics:
<DD>The<TT> underflow</TT> public virtual member function provides the input communication from the file to which the<TT> filebuf</TT>
object is connected.&nbsp; Member functions in the<TT> streambuf</TT> class call the<TT> underflow</TT> public virtual member
function for the derived class when the<B> get area</B> is empty.
<BR><BR>The<TT> underflow</TT> public virtual member function performs the following steps:
<OL>
<LI>If no<B> reserve area</B> is present, a buffer is allocated with the<TT> streambuf::allocate</TT> member function, which
may call the<TT> doallocate</TT> virtual member function.&nbsp; If, after calling<TT> allocate</TT>, no<B> reserve area</B>
is present, the<TT> filebuf</TT> object is unbuffered and a one-character<B> reserve area</B> (plus putback area) is set up
to do unbuffered input.&nbsp; This buffer is embedded in the<TT> filebuf</TT> object.&nbsp; The<B> get area</B> is set up
as empty.
<LI>If the<B> put area</B> is present, it is flushed using the<TT> sync</TT> virtual member function.
<LI>The unused part of the<B> get area</B> is used to read characters from the file connected to the<TT> filebuf</TT> object.
&nbsp;The<B> get area</B> pointers are then set up to reflect the new<B> get area</B>.
</OL>
<DT>Results:
<DD>The<TT> underflow</TT> public virtual member function returns the first unread character of the<B> get area</B>, on success,
otherwise<TT> EOF</TT> is returned.&nbsp; Note that the<B> get pointer</B> is not advanced on success.
<DT>See Also:
<DD><TT> streambuf::underflow</TT>
<BR><BR><TT>filebuf::overflow</TT>
</DL>
<H2 ID="fstream_Class_Description"> fstream Class Description </H2>
<DL>
<DT>Declared:
<DD><TT> fstream.h</TT>
<DT>Derived from:
<DD><TT> fstreambase</TT>,<TT> iostream</TT>
<BR><BR>The<TT> fstream</TT> class is used to access files for reading and writing.&nbsp; The file can be opened and closed,
and read, write and seek operations can be performed.
<BR>The<TT> fstream</TT> class provides very little of its own functionality.&nbsp; It is derived from both the<TT> fstreambase</TT>
and<TT> iostream</TT> classes.&nbsp; The<TT> fstream</TT> constructors, destructor and member function provide simplified
access to the appropriate equivalents in the base classes.
<BR><BR>Of the available I/O stream classes, creating an<TT> fstream</TT> object is the preferred method of accessing a file
for both input and output.
<BR><BR><B>Public Member Functions</B>
<BR><BR>The following public member functions are declared:
<BR><BR><TT>fstream();</TT>
<BR><TT> fstream( char const *,</TT>
<BR><TT> ios::openmode = ios::in|ios::out,</TT>
<BR><TT>int = filebuf::openprot );</TT>
<BR><TT>fstream( filedesc );</TT>
<BR><TT> fstream( filedesc, char *, int );</TT>
<BR><TT> ~fstream();</TT>
<BR><TT> void open( char const *,</TT>
<BR><TT> ios::openmode = ios::in|ios::out,</TT>
<BR><TT>int = filebuf::openprot );</TT>
<DT>See Also:
<DD><TT> fstreambase</TT>,<TT> ifstream</TT>,<TT> iostream</TT>,<TT> ofstream</TT>
</DL>
<H2 ID="fstream__fstreamLR"> fstream() [fstream] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;fstream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>fstream::fstream();</TT>
<DT>Semantics:
<DD>This form of the public<TT> fstream</TT> constructor creates an<TT> fstream</TT> object that is not connected to a file.&nbsp;
The<TT> open</TT> or<TT> attach</TT> member functions should be used to connect the<TT> fstream</TT> object to a file.
<DT>Results:
<DD>The public<TT> fstream</TT> constructor produces an<TT> fstream</TT> object that is not connected to a file.
<DT>See Also:
<DD><TT> ~fstream</TT>,<TT> open</TT>,<TT> fstreambase::attach</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;fstream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>fstream::fstream( const char *name,</TT>
<BR><TT> ios::openmode mode = ios::in|ios::out,</TT>
<BR><TT>int prot = filebuf::openprot );</TT>
<DT>Semantics:
<DD>This form of the public<TT> fstream</TT> constructor creates an<TT> fstream</TT> object that is connected to the file specified
by the<B> name</B> parameter, using the specified<B> mode</B> and<B> prot</B> parameters.&nbsp; The connection is made via
the C library<TT> open</TT> function.
<DT>Results:
<DD>The public<TT> fstream</TT> constructor produces an<TT> fstream</TT> object that is connected to the file specified by<B>
name</B>.&nbsp; If the<TT> open</TT> fails,<TT> ios::failbit</TT> and<TT> ios::badbit</TT> are set in the error state in the
inherited<TT> ios</TT> object.
<DT>See Also:
<DD><TT> ~fstream</TT>,<TT> open</TT>,<TT> openmode</TT>,<TT> openprot</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;fstream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>fstream::fstream( filedesc hdl );</TT>
<DT>Semantics:
<DD>This form of the public<TT> fstream</TT> constructor creates an<TT> fstream</TT> object that is attached to the file specified
by the<B> hdl</B> parameter.
<DT>Results:
<DD>The public<TT> fstream</TT> constructor produces an<TT> fstream</TT> object that is attached to<B> hdl</B>.&nbsp; If the attach
fails,<TT> ios::failbit</TT> and<TT> ios::badbit</TT> are set in the error state in the inherited<TT> ios</TT> object.
<DT>See Also:
<DD><TT> ~fstream</TT>,<TT> fstreambase::attach</TT>,<TT> fstreambase::fd</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;fstream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>fstream::fstream( filedesc hdl, char *buf, int len );</TT>
<DT>Semantics:
<DD>This form of the public<TT> fstream</TT> constructor creates an<TT> fstream</TT> object that is connected to the file specified
by the<B> hdl</B> parameter.&nbsp; The buffer specified by the<B> buf</B> and<B> len</B> parameters is offered to the associated<TT>
filebuf</TT> object via the<TT> setbuf</TT> member function.&nbsp; If the<B> buf</B> parameter is<TT> NULL</TT> or the<B>
len</B> is less than or equal to zero, the<TT> filebuf</TT> is unbuffered, so that each read or write operation reads or writes
a single character at a time.
<DT>Results:
<DD>The public<TT> fstream</TT> constructor produces an<TT> fstream</TT> object that is attached to<B> hdl</B>.&nbsp; If the connection
to<B> hdl</B> fails,<TT> ios::failbit</TT> and<TT> ios::badbit</TT> are set in the error state in the inherited<TT> ios</TT>
object.&nbsp; If the<TT> setbuf</TT> fails,<TT> ios::failbit</TT> is set in the error state in the inherited<TT> ios</TT>
object.
<DT>See Also:
<DD><TT> ~fstream</TT>,<TT> filebuf::setbuf</TT>,<TT> fstreambase::attach</TT>
</DL>
<H2 ID="fstream____fstreamLR"> ~fstream() [fstream] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;fstream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>fstream::~fstream();</TT>
<DT>Semantics:
<DD>The public<TT> ~fstream</TT> destructor does not do anything explicit.&nbsp; The call to the public<TT> ~fstream</TT> destructor
is inserted implicitly by the compiler at the point where the<TT> fstream</TT> object goes out of scope.
<DT>Results:
<DD>The public<TT> ~fstream</TT> destructor destroys the<TT> fstream</TT> object.
<DT>See Also:
<DD><TT> fstream</TT>
</DL>
<H2 ID="fstream__openLR"> open() [fstream] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;fstream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void fstream::open( const char *name,</TT>
<BR><TT> ios::openmode mode = ios::in|ios::out,</TT>
<BR><TT>int prot = filebuf::openprot );</TT>
<DT>Semantics:
<DD>The<TT> open</TT> public member function connects the<TT> fstream</TT> object to the file specified by the<B> name</B> parameter,
using the specified<B> mode</B> and<B> prot</B> parameters.&nbsp; The<TT> mode</TT> parameter is optional and usually is not
specified unless additional bits (such as<TT> ios::binary</TT> or<TT> ios::text</TT>) are to be specified.&nbsp; The connection
is made via the C library<TT> open</TT> function.
<DT>Results:
<DD>If the open fails,<TT> ios::failbit</TT> is set in the error state in the inherited<TT> ios</TT> object.
<DT>See Also:
<DD><TT> fstreambase::attach</TT>,<TT> fstreambase::close</TT>,<TT> fstreambase::fd</TT>,<TT> fstreambase::is_open</TT>
<BR><BR><TT>fstream::openmode</TT>,<TT> openprot</TT>
</DL>
<H2 ID="fstreambase_Class_Description"> fstreambase Class Description </H2>
<DL>
<DT>Declared:
<DD><TT> fstream.h</TT>
<DT>Derived from:
<DD><TT> ios</TT>
<DT>Derived by:
<DD><TT> ifstream</TT>,<TT> ofstream</TT>,<TT> fstream</TT>
<BR><BR>The<TT> fstreambase</TT> class is a base class that provides common functionality for the three file-based classes,<TT>
ifstream</TT>,<TT> ofstream</TT> and<TT> fstream</TT>.&nbsp; The<TT> fstreambase</TT> class is derived from the<TT> ios</TT>
class, providing the stream state information, plus it provides member functions for opening and closing files.&nbsp; The
actual file manipulation work is performed by the<TT> filebuf</TT> class.
<BR>It is not intended that<TT> fstreambase</TT> objects be created.&nbsp; Instead, the user should create an<TT> ifstream</TT>,<TT>
ofstream</TT> or<TT> fstream</TT> object.
<BR><BR><B>Protected Member Functions</B>
<BR><BR>The following member functions are declared in the protected interface:
<BR><BR><TT>fstreambase();</TT>
<BR><TT> fstreambase( char const *,</TT>
<BR><TT> ios::openmode,</TT>
<BR><TT>int = filebuf::openprot );</TT>
<BR><TT>fstreambase( filedesc );</TT>
<BR><TT> fstreambase( filedesc, char *, int );</TT>
<BR><TT> ~fstreambase();</TT>
<BR><BR><B>Public Member Functions</B>
<BR><BR>The following member functions are declared in the public interface:
<BR><BR><TT>void attach( filedesc );</TT>
<BR><TT> void close();</TT>
<BR><TT> filedesc fd() const;</TT>
<BR><TT> int is_open() const;</TT>
<BR><TT> void open( char const *,</TT>
<BR><TT> ios::openmode,</TT>
<BR><TT>int = filebuf::openprot );</TT>
<BR><TT>filebuf *rdbuf() const;</TT>
<BR><TT> void setbuf( char *, int );</TT>
<DT>See Also:
<DD><TT> filebuf</TT>,<TT> fstream</TT>,<TT> ifstream</TT>,<TT> ofstream</TT>
</DL>
<H2 ID="fstreambase__attachLR"> attach() [fstreambase] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;fstream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void fstreambase::attach( filedesc hdl );</TT>
<DT>Semantics:
<DD>The<TT> attach</TT> public member function connects the<TT> fstreambase</TT> object to the file specified by the<B> hdl</B>
parameter.
<DT>Results:
<DD>If the<TT> attach</TT> public member function fails,<TT> ios::failbit</TT> bit is set in the error state in the inherited<TT>
ios</TT> object.&nbsp; The error state in the inherited<TT> ios</TT> object is cleared on success.
<DT>See Also:
<DD><TT> fstreambase::fd</TT>,<TT> is_open</TT>,<TT> open</TT>
</DL>
<H2 ID="fstreambase__closeLR"> close() [fstreambase] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;fstream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void fstreambase::close();</TT>
<DT>Semantics:
<DD>The<TT> close</TT> public member function disconnects the<TT> fstreambase</TT> object from the file with which it is associated.
&nbsp;If the<TT> fstreambase</TT> object is not associated with a file, the<TT> close</TT> public member function fails.
<DT>Results:
<DD>If the<TT> close</TT> public member function fails,<TT> ios::failbit</TT> is set in the error state in the inherited<TT> ios</TT>
object.
<DT>See Also:
<DD><TT> fstreambase::fd</TT>,<TT> is_open</TT>,<TT> open</TT>
</DL>
<H2 ID="fstreambase__fstreambaseLR"> fstreambase() [fstreambase] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;fstream.h&gt;</TT>
<BR><TT>protected:</TT>
<BR><TT>fstreambase::fstreambase();</TT>
<DT>Semantics:
<DD>The protected<TT> fstreambase</TT> constructor creates an<TT> fstreambase</TT> object that is initialized, but not connected
to anything.&nbsp; The<TT> open</TT> or<TT> attach</TT> member function should be used to connect the<TT> fstreambase</TT>
object to a file.
<DT>Results:
<DD>The protected<TT> fstreambase</TT> constructor produces an<TT> fstreambase</TT> object.
<DT>See Also:
<DD><TT> ~fstreambase</TT>,<TT> attach</TT>,<TT> open</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;fstream.h&gt;</TT>
<BR><TT>protected:</TT>
<BR><TT>fstreambase::fstreambase( char const *name,</TT>
<BR><TT> ios::openmode mode,</TT>
<BR><TT>int prot = filebuf::openprot );</TT>
<DT>Semantics:
<DD>This protected<TT> fstreambase</TT> constructor creates an<TT> fstreambase</TT> object that is initialized and connected to
the file indicated by<B> name</B> using the specified<B> mode</B> and<B> prot</B>.&nbsp; The<TT> fstreambase</TT> object is
connected to the specified file via the<TT> open</TT> C library function.
<DT>Results:
<DD>The protected<TT> fstreambase</TT> constructor produces an<TT> fstreambase</TT> object.&nbsp; If the call to<TT> open</TT>
for the file fails,<TT> ios::failbit</TT> and<TT> ios::badbit</TT> are set in the error state in the inherited<TT> ios</TT>
object.
<DT>See Also:
<DD><TT> ~fstreambase</TT>,<TT> open</TT>,<TT> openmode</TT>,<TT> openprot</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;fstream.h&gt;</TT>
<BR><TT>protected:</TT>
<BR><TT>fstreambase::fstreambase( filedesc hdl );</TT>
<DT>Semantics:
<DD>This protected<TT> fstreambase</TT> constructor creates an<TT> fstreambase</TT> object that is initialized and connected to
the open file specified by the<B> hdl</B> parameter.
<DT>Results:
<DD>The protected<TT> fstreambase</TT> constructor produces an<TT> fstreambase</TT> object.&nbsp; If the attach to the file fails,<TT>
ios::failbit</TT> and<TT> ios::badbit</TT> are set in the error state in the inherited<TT> ios</TT> object.
<DT>See Also:
<DD><TT> ~fstreambase</TT>,<TT> attach</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;fstream.h&gt;</TT>
<BR><TT>protected:</TT>
<BR><TT>fstreambase::fstreambase( filedesc hdl, char *buf, int len );</TT>
<DT>Semantics:
<DD>This protected<TT> fstreambase</TT> constructor creates an<TT> fstreambase</TT> object that is initialized and connected to
the open file specified by the<B> hdl</B> parameter.&nbsp; The buffer, specified by the<B> buf</B> and<B> len</B> parameters,
is offered via the<TT> setbuf</TT> virtual member function to be used as the<B> reserve area</B> for the<TT> filebuf</TT>
associated with the<TT> fstreambase</TT> object.
<DT>Results:
<DD>The protected<TT> fstreambase</TT> constructor produces an<TT> fstreambase</TT> object.&nbsp; If the attach to the file fails,<TT>
ios::failbit</TT> and<TT> ios::badbit</TT> are set in the error state in the inherited<TT> ios</TT> object.
<DT>See Also:
<DD><TT> ~fstreambase</TT>,<TT> attach</TT>,<TT> setbuf</TT>
</DL>
<H2 ID="fstreambase____fstreambaseLR"> ~fstreambase() [fstreambase] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;fstream.h&gt;</TT>
<BR><TT>protected:</TT>
<BR><TT>fstreambase::~fstreambase();</TT>
<DT>Semantics:
<DD>The protected<TT> ~fstreambase</TT> destructor does not do anything explicit.&nbsp; The<TT> filebuf</TT> object associated
with the<TT> fstreambase</TT> object is embedded within the<TT> fstreambase</TT> object, so the<TT> filebuf</TT> destructor
is called.&nbsp; The<TT> ios</TT> destructor is called for that portion of the<TT> fstreambase</TT> object.&nbsp; The call
to the protected<TT> ~fstreambase</TT> destructor is inserted implicitly by the compiler at the point where the<TT> fstreambase</TT>
object goes out of scope.
<DT>Results:
<DD>The<TT> fstreambase</TT> object is destroyed.
<DT>See Also:
<DD><TT> fstreambase</TT>,<TT> close</TT>
</DL>
<H2 ID="fstreambase__is_openLR"> is_open() [fstreambase] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;fstream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int fstreambase::is_open() const;</TT>
<DT>Semantics:
<DD>The<TT> is_open</TT> public member function queries the current state of the file associated with the<TT> fstreambase</TT>
object.&nbsp; Calling the<TT> is_open</TT> public member function is equivalent to calling the<TT> fd</TT> member function
and testing for<TT> EOF</TT>.
<DT>Results:
<DD>The<TT> is_open</TT> public member function returns a non-zero value if the<TT> fstreambase</TT> object is currently connected
to a file, otherwise zero is returned.
<DT>See Also:
<DD><TT> fstreambase::attach</TT>,<TT> fd</TT>,<TT> open</TT>
</DL>
<H2 ID="fstreambase__fdLR"> fd() [fstreambase] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;fstream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>filedesc fstreambase::fd() const;</TT>
<DT>Semantics:
<DD>The<TT> fd</TT> public member function returns the file descriptor for the file to which the<TT> fstreambase</TT> object is
connected.
<DT>Results:
<DD>The<TT> fd</TT> public member function returns the file descriptor for the file to which the<TT> fstreambase</TT> object is
connected.&nbsp; If the<TT> fstreambase</TT> object is not currently connected to a file,<TT> EOF</TT> is returned.
<DT>See Also:
<DD><TT> fstreambase::attach</TT>,<TT> is_open</TT>,<TT> open</TT>
</DL>
<H2 ID="fstreambase__openLR"> open() [fstreambase] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;fstream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void fstreambase::open( const char *name,</TT>
<BR><TT> ios::openmode mode,</TT>
<BR><TT>int prot = filebuf::openprot );</TT>
<DT>Semantics:
<DD>The<TT> open</TT> public member function connects the<TT> fstreambase</TT> object to the file specified by<B> name</B>, using
the specified<B> mode</B> and<B> prot</B>.&nbsp; The connection is made via the C library<TT> open</TT> function.
<DT>Results:
<DD>If the open fails,<TT> ios::failbit</TT> is set in the error state in the inherited<TT> ios</TT> object.&nbsp; The error state
in the inherited<TT> ios</TT> object is cleared on success.
<DT>See Also:
<DD><TT> fstreambase::attach</TT>,<TT> close</TT>,<TT> fd</TT>,<TT> is_open</TT>,<TT> openmode</TT>,<TT> openprot</TT>
</DL>
<H2 ID="fstreambase__rdbufLR"> rdbuf() [fstreambase] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;fstream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>filebuf *fstreambase::rdbuf() const;</TT>
<DT>Semantics:
<DD>The<TT> rdbuf</TT> public member function returns the address of the<TT> filebuf</TT> object currently associated with the<TT>
fstreambase</TT> object.
<DT>Results:
<DD>The<TT> rdbuf</TT> public member function returns a pointer to the<TT> filebuf</TT> object currently associated with the<TT>
fstreambase</TT> object If there is no associated<TT> filebuf</TT>,<TT> NULL</TT> is returned.
<DT>See Also:
<DD><TT> ios::rdbuf</TT>
</DL>
<H2 ID="fstreambase__setbufLR"> setbuf() [fstreambase] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;fstream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void fstreambase::setbuf( char *buf, int len );</TT>
<DT>Semantics:
<DD>The<TT> setbuf</TT> public member function offers the specified buffer to the<TT> filebuf</TT> object associated with the<TT>
fstreambase</TT> object.&nbsp; The<TT> filebuf</TT> may or may not reject the offer, depending upon its state.
<DT>Results:
<DD>If the offer is rejected,<TT> ios::failbit</TT> is set in the error state in the inherited<TT> ios</TT> object.
<DT>See Also:
<DD><TT> filebuf::setbuf</TT>
</DL>
<H2 ID="ifstream_Class_Description"> ifstream Class Description </H2>
<DL>
<DT>Declared:
<DD><TT> fstream.h</TT>
<DT>Derived from:
<DD><TT> fstreambase</TT>,<TT> istream</TT>
<BR><BR>The<TT> ifstream</TT> class is used to access existing files for reading.&nbsp; Such files can be opened and closed,
and read and seek operations can be performed.
<BR>The<TT> ifstream</TT> class provides very little of its own functionality.&nbsp; Derived from both the<TT> fstreambase</TT>
and<TT> istream</TT> classes, its constructors, destructor and member functions provide simplified access to the appropriate
equivalents in those base classes.
<BR><BR>Of the available I/O stream classes, creating an<TT> ifstream</TT> object is the preferred method of accessing a file
for input only operations.
<BR><BR><B>Public Member Functions</B>
<BR><BR>The following public member functions are declared:
<BR><BR><TT>ifstream();</TT>
<BR><TT> ifstream( char const *,</TT>
<BR><TT> ios::openmode = ios::in,</TT>
<BR><TT>int = filebuf::openprot );</TT>
<BR><TT>ifstream( filedesc );</TT>
<BR><TT> ifstream( filedesc, char *, int );</TT>
<BR><TT> ~ifstream();</TT>
<BR><TT> void open( char const *,</TT>
<BR><TT> ios::openmode = ios::in,</TT>
<BR><TT>int = filebuf::openprot );</TT>
<DT>See Also:
<DD><TT> fstream</TT>,<TT> fstreambase</TT>,<TT> istream</TT>,<TT> ofstream</TT>
</DL>
<H2 ID="ifstream__ifstreamLR"> ifstream() [ifstream] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;fstream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>ifstream::ifstream();</TT>
<DT>Semantics:
<DD>This form of the public<TT> ifstream</TT> constructor creates an<TT> ifstream</TT> object that is not connected to a file.
&nbsp;The<TT> open</TT> or<TT> attach</TT> member functions should be used to connect the<TT> ifstream</TT> object to a file.
<DT>Results:
<DD>The public<TT> ifstream</TT> constructor produces an<TT> ifstream</TT> object that is not connected to a file.
<DT>See Also:
<DD><TT> ~ifstream</TT>,<TT> open</TT>,<TT> fstreambase::attach</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;fstream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>ifstream::ifstream( const char *name,</TT>
<BR><TT> ios::openmode mode = ios::in,</TT>
<BR><TT>int prot = filebuf::openprot );</TT>
<DT>Semantics:
<DD>This form of the public<TT> ifstream</TT> constructor creates an<TT> ifstream</TT> object that is connected to the file specified
by the<B> name</B> parameter, using the specified<B> mode</B> and<B> prot</B> parameters.&nbsp; The connection is made via
the C library<TT> open</TT> function.
<DT>Results:
<DD>The public<TT> ifstream</TT> constructor produces an<TT> ifstream</TT> object that is connected to the file specified by<B>
name</B>.&nbsp; If the<TT> open</TT> fails,<TT> ios::failbit</TT> and<TT> ios::badbit</TT> are set in the error state in the
inherited<TT> ios</TT> object.
<DT>See Also:
<DD><TT> ~ifstream</TT>,<TT> open</TT>,<TT> openmode</TT>,<TT> openprot</TT>,<TT> fstreambase::attach</TT>,<TT> fstreambase::fd</TT>,<TT>
fstreambase::is_open</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;fstream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>ifstream::ifstream( filedesc hdl );</TT>
<DT>Semantics:
<DD>This form of the public<TT> ifstream</TT> constructor creates an<TT> ifstream</TT> object that is attached to the file specified
by the<B> hdl</B> parameter.
<DT>Results:
<DD>The public<TT> ifstream</TT> constructor produces an<TT> ifstream</TT> object that is attached to<B> hdl</B>.&nbsp; If the
attach fails,<TT> ios::failbit</TT> and<TT> ios::badbit</TT> are set in the error state in the inherited<TT> ios</TT> object.
<DT>See Also:
<DD><TT> fstreambase::attach</TT>
<BR><BR><TT>~ifstream</TT>,<TT> open</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;fstream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>ifstream::ifstream( filedesc hdl, char *buf, int len );</TT>
<DT>Semantics:
<DD>This form of the public<TT> ifstream</TT> constructor creates an<TT> ifstream</TT> object that is connected to the file specified
by the<B> hdl</B> parameter.&nbsp; The buffer specified by the<B> buf</B> and<B> len</B> parameters is offered to the associated<TT>
filebuf</TT> object via the<TT> setbuf</TT> member function.&nbsp; If the<B> buf</B> parameter is<TT> NULL</TT> or the<B>
len</B> is less than or equal to zero, the<TT> filebuf</TT> is unbuffered, so that each read or write operation reads or writes
a single character at a time.
<DT>Results:
<DD>The public<TT> ifstream</TT> constructor produces an<TT> ifstream</TT> object that is attached to<B> hdl</B>.&nbsp; If the
connection to<B> hdl</B> fails,<TT> ios::failbit</TT> and<TT> ios::badbit</TT> are set in the error state in the inherited<TT>
ios</TT> object.&nbsp; If the<TT> setbuf</TT> fails,<TT> ios::failbit</TT> is set in the error state in the inherited<TT>
ios</TT> object.
<DT>See Also:
<DD><TT> fstreambase::attach</TT>,<TT> fstreambase::setbuf</TT>
<BR><BR><TT>~ifstream</TT>,<TT> open</TT>
</DL>
<H2 ID="ifstream____ifstreamLR"> ~ifstream() [ifstream] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;fstream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>ifstream::~ifstream();</TT>
<DT>Semantics:
<DD>The public<TT> ~ifstream</TT> destructor does not do anything explicit.&nbsp; The call to the public<TT> ~ifstream</TT> destructor
is inserted implicitly by the compiler at the point where the<TT> ifstream</TT> object goes out of scope.
<DT>Results:
<DD>The public<TT> ~ifstream</TT> destructor destroys the<TT> ifstream</TT> object.
<DT>See Also:
<DD><TT> ifstream</TT>
</DL>
<H2 ID="ifstream__openLR"> open() [ifstream] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;fstream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void ifstream::open( const char *name,</TT>
<BR><TT> ios::openmode mode = ios::in,</TT>
<BR><TT>int prot = filebuf::openprot );</TT>
<DT>Semantics:
<DD>The<TT> open</TT> public member function connects the<TT> ifstream</TT> object to the file specified by the<B> name</B> parameter,
using the specified<B> mode</B> and<B> prot</B> parameters.&nbsp; The<TT> mode</TT> parameter is optional and usually is not
specified unless additional bits (such as<TT> ios::binary</TT> or<TT> ios::text</TT>) are to be specified.&nbsp; The connection
is made via the C library<TT> open</TT> function.
<DT>Results:
<DD>If the open fails,<TT> ios::failbit</TT> is set in the error state in the inherited<TT> ios</TT> object.
<DT>See Also:
<DD><TT> fstreambase::attach</TT>,<TT> fstreambase::close</TT>,<TT> fstreambase::fd</TT>,<TT> fstreambase::is_open</TT>
<BR><BR><TT>ifstream::openmode</TT>,<TT> openprot</TT>
</DL>
<H2 ID="ios_Class_Description"> ios Class Description </H2>
<DL>
<DT>Declared:
<DD><TT> iostream.h</TT>
<DT>Derived by:
<DD><TT> istream</TT>,<TT> ostream</TT>
<BR><BR>The<TT> ios</TT> class is used to group together common functionality needed for other derived stream classes.&nbsp;
It is not intended that objects of type<TT> ios</TT> be created.
<BR>This class maintains state information about the stream.&nbsp; (the<TT> ios</TT> name can be thought of as a short-form
for I/O State).&nbsp; Error flags, formatting flags, and values and the connection to the buffers used for the input and output
are all maintained by the<TT> ios</TT> class.&nbsp; No information about the buffer itself is stored in an<TT> ios</TT> object,
merely the pointer to the buffer information.
<BR><BR><B>Protected Member Functions</B>
<BR><BR>The following member functions are declared in the protected interface:
<BR><BR><TT>ios();</TT>
<BR><TT> void init( streambuf * );</TT>
<BR><TT> void setstate( ios::iostate );</TT>
<BR><BR><B>Public Enumerations</B>
<BR><BR>The following enumeration typedefs are declared in the public interface:
<BR><BR><TT>typedef int&nbsp; iostate;</TT>
<BR><TT>typedef long fmtflags;</TT>
<BR><TT>typedef int&nbsp; openmode;</TT>
<BR><TT>typedef int&nbsp; seekdir;</TT>
<BR><BR><B>Public Member Functions</B>
<BR><BR>The following member functions are declared in the public interface:
<BR><BR><TT>ios( streambuf * );</TT>
<BR><TT> virtual ~ios();</TT>
<BR><TT> ostream *tie() const;</TT>
<BR><TT> ostream *tie( ostream * );</TT>
<BR><TT> streambuf *rdbuf() const;</TT>
<BR><TT> ios::iostate rdstate() const;</TT>
<BR><TT> ios::iostate clear( ios::iostate = 0 );</TT>
<BR><TT> int good() const;</TT>
<BR><TT> int bad() const;</TT>
<BR><TT> int fail() const;</TT>
<BR><TT> int eof() const;</TT>
<BR><TT> ios::iostate exceptions( ios::iostate );</TT>
<BR><TT> ios::iostate exceptions() const;</TT>
<BR><TT> ios::fmtflags setf( ios::fmtflags, ios::fmtflags );</TT>
<BR><TT> ios::fmtflags setf( ios::fmtflags );</TT>
<BR><TT> ios::fmtflags unsetf( ios::fmtflags );</TT>
<BR><TT> ios::fmtflags flags( ios::fmtflags );</TT>
<BR><TT> ios::fmtflags flags() const;</TT>
<BR><TT> char fill( char );</TT>
<BR><TT> char fill() const;</TT>
<BR><TT> int precision( int );</TT>
<BR><TT> int precision() const;</TT>
<BR><TT> int width( int );</TT>
<BR><TT> int width() const;</TT>
<BR><TT> long &amp;iword( int );</TT>
<BR><TT> void *&amp;pword( int );</TT>
<BR><TT> static void sync_with_stdio();</TT>
<BR><TT> static ios::fmtflags bitalloc();</TT>
<BR><TT> static int xalloc();</TT>
<BR><BR><B>Public Member Operators</B>
<BR><BR>The following member operators are declared in the public interface:
<BR><BR><TT>operator void *() const;</TT>
<BR><TT> int operator !() const;</TT>
<DT>See Also:
<DD><TT> iostream</TT>,<TT> istream</TT>,<TT> ostream</TT>,<TT> streambuf</TT>
</DL>
<H2 ID="ios__badLR"> bad() [ios] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int ios::bad() const;</TT>
<DT>Semantics:
<DD>The<TT> bad</TT> public member function queries the state of the<TT> ios</TT> object.
<DT>Results:
<DD>The<TT> bad</TT> public member function returns a non-zero value if<TT> ios::badbit</TT> is set in the error state in the
inherited<TT> ios</TT> object, otherwise zero is returned.
<DT>See Also:
<DD><TT> ios::clear</TT>,<TT> eof</TT>,<TT> fail</TT>,<TT> good</TT>,<TT> iostate</TT>,<TT> operator !</TT>,<TT> operator void
*</TT>,<TT> rdstate</TT>,<TT> setstate</TT>
</DL>
<H2 ID="ios__bitallocLR"> bitalloc() [ios] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>static ios::fmtflags ios::bitalloc();</TT>
<DT>Semantics:
<DD>The<TT> bitalloc</TT> public static member function is used to allocate a new<TT> ios::fmtflags</TT> bit for use by user derived
classes.
<BR><BR>Because the<TT> bitalloc</TT> public static member function manipulates<TT> static</TT> member data, its behavior
is not tied to any one object but affects the entire class of objects.&nbsp; The value that is returned by the<TT> bitalloc</TT>
public static member function is valid for all objects of all classes derived from the<TT> ios</TT> class.&nbsp; No subsequent
call to the<TT> bitalloc</TT> public static member function will return the same value as a previous call.
<BR><BR>The bit value allocated may be used with the member functions that query and affect<TT> ios::fmtflags</TT>.&nbsp;
In particular, the bit can be set with the<TT> setf</TT> or<TT> flags</TT> member functions or the<TT> setiosflags</TT> manipulator,
and reset with the<TT> unsetf</TT> or<TT> flags</TT> member functions or the<TT> resetiosflags</TT> manipulator.
<BR><BR>There are two constants defined in<TT> &lt;iostream.h&gt;</TT> which indicate the number of bits available when a
program starts.<TT>&nbsp; _LAST_FORMAT_FLAG</TT> indicates the last bit used by the built-in format flags described by<TT>
ios::fmtflags</TT>.<TT>&nbsp; _LAST_FLAG_BIT</TT> indicates the last bit that is available for the<TT> bitalloc</TT> public
static member function to allocate.&nbsp; The difference between the bit positions indicates how many bits are available.
<DT>Results:
<DD>The<TT> bitalloc</TT> public static member function returns the next available<TT> ios::fmtflags</TT> bit for use by user
derived classes.&nbsp; If no more bits are available, zero is returned.
<DT>See Also:
<DD><TT> ios::fmtflags</TT>
</DL>
<H2 ID="ios__clearLR"> clear() [ios] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>iostate ios::clear( ios::iostate flags = 0 );</TT>
<DT>Semantics:
<DD>The<TT> clear</TT> public member function is used to change the current value of<TT> ios::iostate</TT> in the<TT> ios</TT>
object.<TT>&nbsp; ios::iostate</TT> is cleared, all bits specified in<B> flags</B> are set.
<DT>Results:
<DD>The<TT> clear</TT> public member function returns the previous value of<TT> ios::iostate</TT>.
<DT>See Also:
<DD><TT> ios::bad</TT>,<TT> eof</TT>,<TT> fail</TT>,<TT> good</TT>,<TT> iostate</TT>,<TT> operator !</TT>,<TT> operator void *</TT>,<TT>
rdstate</TT>,<TT> setstate</TT>
</DL>
<H2 ID="ios__eofLR"> eof() [ios] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int ios::eof() const;</TT>
<DT>Semantics:
<DD>The<TT> eof</TT> public member function queries the state of the<TT> ios</TT> object.
<DT>Results:
<DD>The<TT> eof</TT> public member function returns a non-zero value if<TT> ios::eofbit</TT> is set in the error state in the
inherited<TT> ios</TT> object, otherwise zero is returned.
<DT>See Also:
<DD><TT> ios::bad</TT>,<TT> clear</TT>,<TT> fail</TT>,<TT> good</TT>,<TT> iostate</TT>,<TT> rdstate</TT>,<TT> setstate</TT>
</DL>
<H2 ID="ios__exceptionsLR"> exceptions() [ios] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>ios::iostate ios::exceptions() const;</TT>
<BR><TT> ios::iostate ios::exceptions( int enable );</TT>
<DT>Semantics:
<DD>The<TT> exceptions</TT> public member function queries and/or sets the bits that control which exceptions are enabled.<TT>
&nbsp;ios::iostate</TT> within the<TT> ios</TT> object is used to enable and disable exceptions.
<BR><BR>When a condition arises that sets a bit in<TT> ios::iostate</TT>, a check is made to see if the same bit is also set
in the exception bits.&nbsp; If so, an exception is thrown.&nbsp; Otherwise, no exception is thrown.
<BR><BR>The first form of the<TT> exceptions</TT> public member function looks up the current setting of the exception bits.
&nbsp;The bit values are those described by<TT> ios::iostate</TT>.
<BR><BR>The second form of the<TT> exceptions</TT> public member function sets the exceptions bits to those specified in the<B>
enable</B> parameter, and returns the current settings.
<DT>Results:
<DD>The<TT> exceptions</TT> public member function returns the previous setting of the exception bits.
<DT>See Also:
<DD><TT> ios::clear</TT>,<TT> iostate</TT>,<TT> rdstate</TT>,<TT> setstate</TT>
</DL>
<H2 ID="ios__failLR"> fail() [ios] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int ios::fail() const;</TT>
<DT>Semantics:
<DD>The<TT> fail</TT> public member function queries the state of the<TT> ios</TT> object.
<DT>Results:
<DD>The<TT> fail</TT> public member function returns a non-zero value if<TT> ios::failbit</TT> or<TT> ios::badbit</TT> is set
in the error state in the inherited<TT> ios</TT> object, otherwise zero is returned.
<DT>See Also:
<DD><TT> ios::bad</TT>,<TT> clear</TT>,<TT> eof</TT>,<TT> good</TT>,<TT> iostate</TT>,<TT> operator !</TT>,<TT> operator void
*</TT>,<TT> rdstate</TT>,<TT> setstate</TT>
</DL>
<H2 ID="ios__fillLR"> fill() [ios] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>char ios::fill() const;</TT>
<BR><TT> char ios::fill( char fillchar );</TT>
<DT>Semantics:
<DD>The<TT> fill</TT> public member function queries and/or sets the<B> fill character</B> used when the size of a formatted object
is smaller than the<B> format width</B> specified.
<BR><BR>The first form of the<TT> fill</TT> public member function looks up the current value of the<B> fill character</B>.
<BR><BR>The second form of the<TT> fill</TT> public member function sets the<B> fill character</B> to<B> fillchar</B>.
<BR><BR>By default, the<B> fill character</B> is a space.
<DT>Results:
<DD>The<TT> fill</TT> public member function returns the previous value of the<B> fill character</B>.
<DT>See Also:
<DD><TT> ios::fmtflags</TT>, manipulator<TT> setfill</TT>
</DL>
<H2 ID="ios__flagsLR"> flags() [ios] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>ios::fmtflags ios::flags() const;</TT>
<BR><TT> ios::fmtflags ios::flags( ios::fmtflags setbits );</TT>
<DT>Semantics:
<DD>The<TT> flags</TT> public member function is used to query and/or set the value of<TT> ios::fmtflags</TT> in the<TT> ios</TT>
object.
<BR><BR>The first form of the<TT> flags</TT> public member function looks up the current<TT> ios::fmtflags</TT> value.
<BR><BR>The second form of the<TT> flags</TT> public member function sets<TT> ios::fmtflags</TT> to the value specified in
the<B> setbits</B> parameter.
<BR><BR>Note that the<TT> setf</TT> public member function only turns bits on, while the<TT> flags</TT> public member function
turns some bits on and some bits off.
<DT>Results:
<DD>The<TT> flags</TT> public member function returns the previous<TT> ios::fmtflags</TT> value.
<DT>See Also:
<DD><TT> ios::fmtflags</TT>,<TT> setf</TT>,<TT> unsetf</TT>, manipulator<TT> dec</TT>, manipulator<TT> hex</TT>, manipulator<TT>
oct</TT>, manipulator<TT> resetiosflags</TT>, manipulator<TT> setbase</TT>, manipulator<TT> setiosflags</TT>
</DL>
<H2 ID="ios__fmtflags"> fmtflags [ios] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>enum fmt_flags {</TT>
<BR><TT>skipws = 0x0001, // skip whitespace</TT>
<BR><TT> left = 0x0002, // align field to left edge</TT>
<BR><TT> right = 0x0004, // align field to right edge</TT>
<BR><TT> internal = 0x0008, // sign at left, value at right</TT>
<BR><TT> dec = 0x0010, // decimal conversion for integers</TT>
<BR><TT> oct = 0x0020, // octal conversion for integers</TT>
<BR><TT> hex = 0x0040, // hexadecimal conversion for integers</TT>
<BR><TT> showbase = 0x0080, // show dec/octal/hex base on output</TT>
<BR><TT> showpoint = 0x0100, // show decimal and digits on output</TT>
<BR><TT> uppercase = 0x0200, // use uppercase for format characters</TT>
<BR><TT> showpos = 0x0400, // use + for output positive numbers</TT>
<BR><TT> scientific = 0x0800, // use scientific notation for output</TT>
<BR><TT> fixed = 0x1000, // use floating notation for output</TT>
<BR><TT> unitbuf = 0x2000, // flush stream after output</TT>
<BR><TT> stdio = 0x4000, // flush stdout/stderr after output</TT>
<BR><BR><TT>basefield = dec | oct | hex,</TT>
<BR><TT> adjustfield= left | right | internal,</TT>
<BR><TT> floatfield = scientific | fixed</TT>
<BR><TT> };</TT>
<BR><TT>typedef long fmtflags;</TT>
<DT>Semantics:
<DD>The type<TT> ios::fmt_flags</TT> is a set of bits representing methods of formatting objects written to the stream and interpreting
objects read from the stream.&nbsp; The<TT> ios::fmtflags</TT> member typedef represents the same set of bits, but uses a<TT>
long</TT> to represent the values, thereby avoiding problems made possible by the compiler's ability to use smaller types
for enumerations.&nbsp; All uses of these bits should use the<TT> ios::fmtflags</TT> member typedef.
<BR><BR>The bit values defined by the<TT> ios::fmtflags</TT> member typedef are set and read by the member functions<TT> setf</TT>,<TT>
unsetf</TT> and<TT> flags</TT>, as well as the manipulators<TT> setiosflags</TT> and<TT> resetiosflags</TT>.
<BR><BR>Because one field is used to store all of these bits, there are three special values used to mask various groups of
bits.&nbsp; These values are named<TT> ios::basefield</TT>,<TT> ios::adjustfield</TT> and<TT> ios::floatfield</TT>, and are
discussed with the bits that they are used to mask.
<BR><BR><TT>ios::skipws</TT> controls whether or not whitespace characters are automatically skipped when using an<TT> operator
&gt;&gt;</TT> extractor.&nbsp; If<TT> ios::skipws</TT> is on, any use of the<TT> operator &gt;&gt;</TT> extractor skips whitespace
characters before inputting the next item.&nbsp; Otherwise, skipping of whitespace characters must be handled by the program.
<BR><BR><TT>ios::left</TT>,<TT> ios::right</TT> and<TT> ios::internal</TT> control the alignment of items written using an<TT>
operator &lt;&lt;</TT> inserter.&nbsp; These bits are usually used in conjunction with the<B> format width</B> and<B> fill
character</B>.
<BR><BR><TT>ios::adjustfield</TT> can be used to mask the alignment bits returned by the<TT> setf</TT>,<TT> unsetf</TT> and<TT>
flags</TT> member functions, and for setting new values to ensure that no other bits are accidentally affected.
<BR><BR>When the item to be written is smaller than the<B> format width</B> specified,<B> fill character</B>s are written
to occupy the additional space.&nbsp; If<TT> ios::left</TT> is in effect, the item is written in the left portion of the available
space, and<B> fill character</B>s are written in the right portion.&nbsp; If<TT> ios::right</TT> is in effect, the item is
written in the right portion of the available space, and<B> fill character</B>s are written in the left portion.&nbsp; If<TT>
ios::internal</TT> is in effect, any sign character or base indicator is written in the left portion, the digits are written
in the right portion, and<B> fill character</B>s are written in between.
<BR><BR>If no alignment is specified,<TT> ios::right</TT> is assumed.
<BR><BR>If the item to be written is as big as or bigger than the<B> format width</B> specified, no<B> fill character</B>s
are written and the alignment is ignored.
<BR><BR><TT>ios::dec</TT>,<TT> ios::oct</TT> and<TT> ios::hex</TT> control the base used to format integers being written
to the stream, and also control the interpretation of integers being read from the stream.
<BR><BR><TT>ios::basefield</TT> can be used to mask the base bits returned by the member functions<TT> setf</TT>,<TT> unsetf</TT>
and<TT> flags</TT>, and for setting new values to ensure that no other bits are accidentally affected.
<BR><BR>When an integer is being read from the stream, these bits control the base used for the interpretation of the digits.
&nbsp;If none of these bits is set, a number that starts with<TT> 0x</TT> or<TT> 0X</TT> is interpreted as hexadecimal (digits<TT>
0123456789</TT>, plus the letters<TT> abcdef</TT> or<TT> ABCDEF</TT>), a number that starts with<TT> 0</TT> (zero) is interpreted
as octal (digits<TT> 01234567</TT>), otherwise the number is interpreted as decimal (digits<TT> 0123456789</TT>).&nbsp; If
one of the bits is set, then the prefix is not necessary and the number is interpreted according to the bit.
<BR><BR>When any one of the integer types is being written to the stream, it can be written in decimal, octal or hexadecimal.
&nbsp;If none of these bits is set,<TT> ios::dec</TT> is assumed.
<BR><BR>If<TT> ios::dec</TT> is set (or assumed), the integer is written in decimal (digits<TT> 0123456789</TT>).&nbsp; No
prefix is included.
<BR><BR>If<TT> ios::oct</TT> is set, the integer is written in octal (digits<TT> 01234567</TT>).&nbsp; No sign character is
written, as the number is treated as an unsigned quantity upon conversion to octal.
<BR><BR>If<TT> ios::hex</TT> is set, the integer is written in hexadecimal (digits<TT> 0123456789</TT>, plus the letters<TT>
abcdef</TT> or<TT> ABCDEF</TT>, depending on the setting of<TT> ios::uppercase</TT>).&nbsp; No sign character is written,
as the number is treated as an unsigned quantity upon conversion to hexadecimal.
<BR><BR><TT>ios::showbase</TT> controls whether or not integers written to the stream in octal or hexadecimal form have a
prefix that indicates the base of the number.&nbsp; If the bit is set, decimal numbers are written without a prefix, octal
numbers are written with the prefix<TT> 0</TT> (zero) and hexadecimal numbers are written with the prefix<TT> 0x</TT> or<TT>
0X</TT> depending on the setting of<TT> ios::uppercase</TT>.&nbsp; If the<TT> ios::showbase</TT> is not set, no prefixes are
written.
<BR><BR><TT>ios::showpoint</TT> is used to control whether or not the decimal point and trailing zeroes are trimmed when floating-point
numbers are written to the stream.&nbsp; If the bit is set, no trimming is done, causing the number to appear with the specified<B>
format precision</B>.&nbsp; If the bit is not set, any trailing zeroes after the decimal point are trimmed, and if not followed
by any digits, the decimal point is removed as well.
<BR><BR><TT>ios::uppercase</TT> is used to force to upper-case all letters used in formatting numbers, including the letter-digits<TT>
abcdef</TT>, the<TT> x</TT> hexadecimal prefix, and the<TT> e</TT> used for the exponents in floating-point numbers.
<BR><BR><TT>ios::showpos</TT> controls whether or not a<TT> +</TT> is added to the front of positive integers being written
to the stream.&nbsp; If the bit is set, the number is positive and the number is being written in decimal, a<TT> +</TT> is
written before the first digit.
<BR><BR><TT>ios::scientific</TT> and<TT> ios::fixed</TT> controls the form used for writing floating-point numbers to the
stream.&nbsp; Floating-point numbers can be written in scientific notation (also called exponential notation) or in fixed-point
notation.
<BR><BR><TT>ios::floatfield</TT> can be used to mask the floating-format bits returned by the member functions<TT> setf</TT>,<TT>
unsetf</TT> and<TT> flags</TT>, and for setting new values to ensure that no other bits are accidentally affected.
<BR><BR>If<TT> ios::scientific</TT> is set, the floating-point number is written with a leading<TT> -</TT> sign (for negative
numbers), a digit, a decimal point, more digits, an<TT> e</TT> (or<TT> E</TT> if<TT> ios::uppercase</TT> is set), a<TT> +</TT>
or<TT> -</TT> sign, and two or three digits representing the exponent.&nbsp; The digit before the decimal is not zero unless
the number is zero.&nbsp; The total number of digits before and after the decimal is equal to the specified<B> format precision</B>.
&nbsp;If<TT> ios::showpoint</TT> is not set, trimming of the decimal and digits following the decimal may occur.
<BR><BR>If<TT> ios::fixed</TT> is set, the floating-point number is written with a<TT> -</TT> sign (for negative numbers),
at least one digit, the decimal point, and as many digits following the decimal as specified by the<B> format precision</B>.
&nbsp;If<TT> ios::showpoint</TT> is not set, trimming of the decimal and digits following the decimal may occur.
<BR><BR>If neither<TT> ios::scientific</TT> nor<TT> ios::fixed</TT> is specified, the floating-point number is formatted using
scientific notation provided one or both of the following conditions are met:
<UL>
<LI>the exponent is less than -4, or,
<LI>the exponent is greater than the<B> format precision</B>.
</UL>
<BR>Otherwise, fixed-point notation is used.
<BR><BR><TT>ios::unitbuf</TT> controls whether or not the stream is flushed after each item is written.&nbsp; If the bit is
set, every item that is written to the stream is followed by a flush operation, which ensures that the I/O stream buffer associated
with the stream is kept empty, immediately transferring the data to its final destination.
<BR><BR><TT>ios::stdio</TT> controls whether or not the stream is synchronized after each item is written.&nbsp; If the bit
is set, every item that is written to the stream causes the stream to be synchronized, which means any input or output buffers
are flushed so that an I/O operation performed using C (not C++) I/O behaves in an understandable way.&nbsp; If the output
buffer was not flushed, writing using C++ and then C I/O functions could cause the output from the C functions to appear before
the output from the C++ functions, since the characters might be sitting in the C++ output buffer.&nbsp; Similarly, after
the C output operations are done, a call should be made to the C library<TT> fflush</TT> function on the appropriate stream
before resuming C++ output operations.
<DT>See Also:
<DD><TT> ios::flags</TT>,<TT> setf</TT>,<TT> unsetf</TT>, manipulator<TT> dec</TT>, manipulator<TT> hex</TT>, manipulator<TT>
oct</TT>, manipulator<TT> resetiosflags</TT>, manipulator<TT> setbase</TT>, manipulator<TT> setiosflags</TT>
</DL>
<H2 ID="ios__goodLR"> good() [ios] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int ios::good() const;</TT>
<DT>Semantics:
<DD>The<TT> good</TT> public member function queries the state of the<TT> ios</TT> object.
<DT>Results:
<DD>The<TT> good</TT> public member function returns a non-zero value if none of<TT> ios::iostate</TT> is clear, otherwise zero
is returned.
<DT>See Also:
<DD><TT> ios::bad</TT>,<TT> clear</TT>,<TT> eof</TT>,<TT> fail</TT>,<TT> iostate</TT>,<TT> rdstate</TT>,<TT> setstate</TT>
</DL>
<H2 ID="ios__initLR"> init() [ios] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>protected:</TT>
<BR><TT>void ios::init( streambuf *sb );</TT>
<DT>Semantics:
<DD>The<TT> init</TT> public protected member function is used by derived classes to explicitly initialize the<TT> ios</TT> portion
of the derived object, and to associate a<TT> streambuf</TT> with the<TT> ios</TT> object.&nbsp; The<TT> init</TT> public
protected member function performs the following steps:
<OL>
<LI>The default<B> fill character</B> is set to a space.
<LI>The<B> format precision</B> is set to six.
<LI>The<TT> streambuf</TT> pointer (returned by the<TT> rdbuf</TT> member function) is set to<B> sb</B>.
<LI>The remaining fields of the<TT> ios</TT> object are initialized to zero.
</OL>
<DT>Results:
<DD>If<B> sb</B> is<TT> NULL</TT> the<TT> ios::badbit</TT> is set in the error state in the inherited<TT> ios</TT> object.
<DT>See Also:
<DD><TT> ios</TT>,<TT> rdbuf</TT>
</DL>
<H2 ID="ios__iosLR"> ios() [ios] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>protected:</TT>
<BR><TT>ios::ios();</TT>
<DT>Semantics:
<DD>This form of the protected<TT> ios</TT> constructor creates a default<TT> ios</TT> object that is initialized, but does not
have an associated<TT> streambuf</TT>.&nbsp; Initialization of an<TT> ios</TT> object is handled by the<TT> init</TT> protected
member function.
<DT>Results:
<DD>This protected<TT> ios</TT> constructor creates an<TT> ios</TT> object and sets<TT> ios::badbit</TT> in the error state in
the inherited<TT> ios</TT> object.
<DT>See Also:
<DD><TT> ~ios</TT>,<TT> init</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>ios::ios( streambuf *sb );</TT>
<DT>Semantics:
<DD>This form of the public<TT> ios</TT> constructor creates an<TT> ios</TT> object that is initialized and has an associated<TT>
streambuf</TT>.&nbsp; Initialization of an<TT> ios</TT> object is handled by the<TT> init</TT> protected member function.
&nbsp;Once the<TT> init</TT> protected member function is completed, the<TT> ios</TT> object's<TT> streambuf</TT> pointer
is set to<B> sb</B>.&nbsp; If<B> sb</B> is not<TT> NULL</TT>,<TT> ios::badbit</TT> is cleared from the error state in the
inherited<TT> ios</TT> object.
<DT>Results:
<DD>This public<TT> ios</TT> constructor creates an<TT> ios</TT> object and, if<B> sb</B> is<TT> NULL</TT>, sets<TT> ios::badbit</TT>
in the error state in the inherited<TT> ios</TT> object.
<DT>See Also:
<DD><TT> ~ios</TT>,<TT> init</TT>
</DL>
<H2 ID="ios____iosLR"> ~ios() [ios] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>virtual ios::~ios();</TT>
<DT>Semantics:
<DD>The public virtual<TT> ~ios</TT> destructor destroys an<TT> ios</TT> object.&nbsp; The call to the public virtual<TT> ~ios</TT>
destructor is inserted implicitly by the compiler at the point where the<TT> ios</TT> object goes out of scope.
<DT>Results:
<DD>The<TT> ios</TT> object is destroyed.
<DT>See Also:
<DD><TT> ios</TT>
</DL>
<H2 ID="ios__iostate"> iostate [ios] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>enum io_state {</TT>
<BR><TT>goodbit = 0x00, // no errors</TT>
<BR><TT> badbit = 0x01, // operation failed, may not proceed</TT>
<BR><TT> failbit = 0x02, // operation failed, may proceed</TT>
<BR><TT> eofbit = 0x04 // end of file encountered</TT>
<BR><TT> };</TT>
<BR><TT>typedef int iostate;</TT>
<DT>Semantics:
<DD>The type<TT> ios::io_state</TT> is a set of bits representing the current state of the stream.&nbsp; The<TT> ios::iostate</TT>
member typedef represents the same set of bits, but uses an<TT> int</TT> to represent the values, thereby avoiding problems
made possible by the compiler's ability to use smaller types for enumerations.&nbsp; All uses of these bits should use the<TT>
ios::iostate</TT> member typedef.
<BR><BR>The bit values defined by the<TT> ios::iostate</TT> member typedef can be read and set by the member functions<TT>
rdstate</TT> and<TT> clear</TT>, and can be used to control exception handling with the member function<TT> exceptions</TT>.
<BR><BR><TT>ios::badbit</TT> represents the state where the stream is no longer usable because of some error condition.
<BR><BR><TT>ios::failbit</TT> represents the state where the previous operation on the stream failed, but the stream is still
usable.&nbsp; Subsequent operations on the stream are possible, but the state must be cleared using the<TT> clear</TT> member
function.
<BR><BR><TT>ios::eofbit</TT> represents the state where the end-of-file condition has been encountered.&nbsp; The stream may
still be used, but the state must be cleared using the<TT> clear</TT> member function.
<BR><BR>Even though<TT> ios::goodbit</TT> is not a bit value (because its value is zero, which has no bits on), it is provided
for completeness.
<DT>See Also:
<DD><TT> ios::bad</TT>,<TT> clear</TT>,<TT> eof</TT>,<TT> fail</TT>,<TT> good</TT>,<TT> operator !</TT>,<TT> operator void *</TT>,<TT>
rdstate</TT>,<TT> setstate</TT>
</DL>
<H2 ID="ios__iwordLR"> iword() [ios] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>long &amp;ios::iword( int index );</TT>
<DT>Semantics:
<DD>The<TT> iword</TT> public member function creates a reference to a<TT> long int</TT>, which may be used to store and retrieve
any suitable integer value.&nbsp; The<B> index</B> parameter specifies which<TT> long int</TT> is to be referenced and must
be obtained from a call to the<TT> xalloc</TT> static member function.
<BR><BR>Note that the<TT> iword</TT> and<TT> pword</TT> public member functions return references to the same storage with
a different type.&nbsp; Therefore, each<B> index</B> obtained from the<TT> xalloc</TT> static member function can be used
only for an integer or a pointer, not both.
<BR><BR>Since the<TT> iword</TT> public member function returns a reference and the<TT> ios</TT> class cannot predict how
many such items will be required by a program, it should be assumed that each call to the<TT> xalloc</TT> static member function
invalidates all previous references returned by the<TT> iword</TT> public member function.&nbsp; Therefore, the<TT> iword</TT>
public member function should be called each time the reference is needed.
<DT>Results:
<DD>The<TT> iword</TT> public member function returns a reference to a<TT> long int</TT>.
<DT>See Also:
<DD><TT> ios::pword</TT>,<TT> xalloc</TT>
</DL>
<H2 ID="ios__openmode"> openmode [ios] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>enum open_mode {</TT>
<BR><TT>in = 0x0001, // open for input</TT>
<BR><TT> out = 0x0002, // open for output</TT>
<BR><TT> atend = 0x0004, // seek to end after opening</TT>
<BR><TT> append = 0x0008, // open for output, append to the end</TT>
<BR><TT> truncate = 0x0010, // discard contents after opening</TT>
<BR><TT> nocreate = 0x0020, // open only an existing file</TT>
<BR><TT> noreplace = 0x0040, // open only a new file</TT>
<BR><TT> text = 0x0080, // open as text file</TT>
<BR><TT> binary = 0x0100, // open as binary file</TT>
<BR><BR><TT>app = append, // synonym</TT>
<BR><TT> ate = atend, // synonym</TT>
<BR><TT> trunc = truncate // synonym</TT>
<BR><TT> };</TT>
<BR><TT>typedef int openmode;</TT>
<DT>Semantics:
<DD>The type<TT> ios::open_mode</TT> is a set of bits representing ways of opening a stream.&nbsp; The<TT> ios::openmode</TT>
member typedef represents the same set of bits, but uses an<TT> int</TT> to represent the values, thereby avoiding problems
made possible by the compiler's ability to use smaller types for enumerations.&nbsp; All uses of these bits should use the<TT>
ios::openmode</TT> member typedef.
<BR><BR>The bit values defined by<TT> ios::openmode</TT> member typedef can be specified in the constructors for stream objects,
as well as in various member functions.
<BR><BR><TT>ios::in</TT> is specified in a stream for which input operations may be performed.<TT>&nbsp; ios::out</TT> is
specified in a stream for which output operations may be performed.&nbsp; A stream for which only<TT> ios::in</TT> is specified
is referred to as an<B> input</B> stream.&nbsp; A stream for which only<TT> ios::out</TT> is specified is referred to as an<B>
output</B> stream.&nbsp; A stream where both<TT> ios::in</TT> and<TT> ios::out</TT> are specified is referred to as an<B>
input/output</B> stream.
<BR><BR><TT>ios::atend</TT> and<TT> ios::ate</TT> are equivalent, and either one is specified for streams that are to be positioned
to the end before the first operation takes place.<TT>&nbsp; ios:ate</TT> is provided for historical purposes and compatibility
with other implementations of I/O streams.&nbsp; Note that this bit positions the stream to the end exactly once, when the
stream is opened.
<BR><BR><TT>ios::append</TT> and<TT> ios::app</TT> are equivalent, and either one is specified for streams that are to be
positioned to the end before any and all output operations take place.<TT>&nbsp; ios::app</TT> is provided for historical
purposes and compatibility with other implementations of I/O streams.&nbsp; Note that this bit causes the stream to be positioned
to the end before each output operation, while<TT> ios::atend</TT> causes the stream to be positioned to the end only when
first opened.
<BR><BR><TT>ios::truncate</TT> and<TT> ios::trunc</TT> are equivalent, and either one is specified for streams that are to
be truncated to zero length before the first operation takes place.<TT>&nbsp; ios::trunc</TT> is provided for historical purposes
and compatibility with other implementations of I/O streams.
<BR><BR><TT>ios::nocreate</TT> is specified if the file must exist before it is opened.&nbsp; If the file does not exist,
an error occurs.
<BR><BR><TT>ios::noreplace</TT> is specified if the file must not exist before it is opened.&nbsp; That is, the file must
be a new file.&nbsp; If the file exists, an error occurs.
<BR><BR><TT>ios::text</TT> is specified if the file is to be treated as a<B> text</B> file.&nbsp; A text file is divided into
records, and each record is terminated by a<B> new-line</B> character, usually represented as<TT> '\n'.</TT>&nbsp; The new-line
character is translated into a form that is compatible with the underlying file system's concept of text files.&nbsp; This
conversion happens automatically whenever the new-line is written to the file, and the inverse conversion (to the new-line
character) happens automatically whenever the end of a record is read from the file system.
<BR><BR><TT>ios::binary</TT> is specified if the file is to be treated as a<B> binary</B> file.&nbsp; Binary files are streams
of characters.&nbsp; No character has a special meaning.&nbsp; No grouping of characters into records is apparent to the program,
although the underlying file system may cause such a grouping to occur.
<BR><BR>The following default behaviors are defined:
<BR><BR>If<TT> ios::out</TT> is specified and none of<TT> ios::in</TT>,<TT> ios::append</TT> or<TT> ios::atend</TT> are specified,<TT>
ios::truncate</TT> is assumed.
<BR><BR>If<TT> ios::append</TT> is specified,<TT> ios::out</TT> is assumed.
<BR><BR>If<TT> ios::truncate</TT> is specified,<TT> ios::out</TT> is assumed.
<BR><BR>If neither<TT> ios::text</TT> nor<TT> ios::binary</TT> is specified,<TT> ios::text</TT> is assumed.
</DL>
<H2 ID="ios__operator__LR"> operator !() [ios] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int ios::operator !() const;</TT>
<DT>Semantics:
<DD>The<TT> operator !</TT>&nbsp; public member function tests the error state in the inherited<TT> ios</TT> object of the<TT>
ios</TT> object.
<DT>Results:
<DD>The<TT> operator !</TT>&nbsp; public member function returns a non-zero value if either of<TT> ios::failbit</TT> or<TT> ios::badbit</TT>
bits are set in the error state in the inherited<TT> ios</TT> object, otherwise zero is returned.
<DT>See Also:
<DD><TT> ios::bad</TT>,<TT> clear</TT>,<TT> fail</TT>,<TT> good</TT>,<TT> iostate</TT>,<TT> operator void *</TT>,<TT> rdstate</TT>,<TT>
setstate</TT>
</DL>
<H2 ID="ios__operator_void_TLR"> operator void *() [ios] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>ios::operator void *() const;</TT>
<DT>Semantics:
<DD>The<TT> operator void *</TT> public member function converts the<TT> ios</TT> object into a pointer to<TT> void</TT>.&nbsp;
The actual pointer value returned is meaningless and intended only for comparison with<TT> NULL</TT> to determine the error
state in the inherited<TT> ios</TT> object of the<TT> ios</TT> object.
<DT>Results:
<DD>The<TT> operator void *</TT> public member function returns a<TT> NULL</TT> pointer if either of<TT> ios::failbit</TT> or<TT>
ios::badbit</TT> bits are set in the error state in the inherited<TT> ios</TT> object, otherwise a non-<TT> NULL</TT> pointer
is returned.
<DT>See Also:
<DD><TT> ios::bad</TT>,<TT> clear</TT>,<TT> fail</TT>,<TT> good</TT>,<TT> iostate</TT>,<TT> operator !</TT>,<TT> rdstate</TT>,<TT>
setstate</TT>
</DL>
<H2 ID="ios__precisionLR"> precision() [ios] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int ios::precision() const;</TT>
<BR><TT> int ios::precision( int prec );</TT>
<DT>Semantics:
<DD>The<TT> precision</TT> public member function is used to query and/or set the<B> format precision</B>.&nbsp; The<B> format
precision</B> is used to control the number of digits of precision used when formatting floating-point numbers.&nbsp; For
scientific notation, the<B> format precision</B> describes the total number of digits before and after the decimal point,
but not including the exponent.&nbsp; For fixed-point notation, the<B> format precision</B> describes the number of digits
after the decimal point.
<BR><BR>The first form of the<TT> precision</TT> public member function looks up the current<B> format precision</B>.
<BR><BR>The second form of the<TT> precision</TT> public member function sets the<B> format precision</B> to<B> prec</B>.
<BR><BR>By default, the<B> format precision</B> is six.&nbsp; If<B> prec</B> is specified to be less than zero, the<B> format
precision</B> is set to six.&nbsp; Otherwise, the specified<B> format precision</B> is used.&nbsp; For scientific notation,
a<B> format precision</B> of zero is treated as a precision of one.
<DT>Results:
<DD>The<TT> precision</TT> public member function returns the previous<B> format precision</B> setting.
<DT>See Also:
<DD><TT> ios::fmtflags</TT>, manipulator<TT> setprec</TT>
</DL>
<H2 ID="ios__pwordLR"> pword() [ios] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void * &amp;ios::pword( int index );</TT>
<DT>Semantics:
<DD>The<TT> pword</TT> public member function creates a reference to a<TT> void</TT> pointer, which may be used to store and retrieve
any suitable pointer value.&nbsp; The<B> index</B> parameter specifies which<TT> void</TT> pointer is to be referenced and
must be obtained from a call to the<TT> xalloc</TT> static member function.
<BR><BR>Note that the<TT> iword</TT> and<TT> pword</TT> public member functions return references to the same storage with
a different type.&nbsp; Therefore, each<B> index</B> obtained from the<TT> xalloc</TT> static member function can be used
only for an integer or a pointer, not both.
<BR><BR>Since the<TT> pword</TT> public member function returns a reference and the<TT> ios</TT> class cannot predict how
many such items will be required by a program, it should be assumed that each call to the<TT> xalloc</TT> static member function
invalidates all previous references returned by the<TT> pword</TT> public member function.&nbsp; Therefore, the<TT> pword</TT>
public member function should be called each time the reference is needed.
<DT>Results:
<DD>The<TT> pword</TT> public member function returns a reference to a<TT> void</TT> pointer.
<DT>See Also:
<DD><TT> ios::iword</TT>,<TT> xalloc</TT>
</DL>
<H2 ID="ios__rdbufLR"> rdbuf() [ios] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>streambuf *ios::rdbuf() const;</TT>
<DT>Semantics:
<DD>The<TT> rdbuf</TT> public member function looks up the pointer to the<TT> streambuf</TT> object which maintains the buffer
associated with the<TT> ios</TT> object.
<DT>Results:
<DD>The<TT> rdbuf</TT> public member function returns the pointer to the<TT> streambuf</TT> object associated with the<TT> ios</TT>
object.&nbsp; If there is no associated<TT> streambuf</TT> object,<TT> NULL</TT> is returned.
</DL>
<H2 ID="ios__rdstateLR"> rdstate() [ios] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>iostate ios::rdstate() const;</TT>
<DT>Semantics:
<DD>The<TT> rdstate</TT> public member function is used to query the current value of<TT> ios::iostate</TT> in the<TT> ios</TT>
object without modifying it.
<DT>Results:
<DD>The<TT> rdstate</TT> public member function returns the current value of<TT> ios::iostate</TT>.
<DT>See Also:
<DD><TT> ios::bad</TT>,<TT> clear</TT>,<TT> eof</TT>,<TT> fail</TT>,<TT> good</TT>,<TT> iostate</TT>,<TT> operator !</TT>,<TT>
operator void *</TT>,<TT> setstate</TT>
</DL>
<H2 ID="ios__seekdir"> seekdir [ios] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>enum seek_dir {</TT>
<BR><TT>beg, // seek from beginning</TT>
<BR><TT> cur, // seek from current position</TT>
<BR><TT> end // seek from end</TT>
<BR><TT> };</TT>
<BR><TT>typedef int seekdir;</TT>
<DT>Semantics:
<DD>The type<TT> ios::seek_dir</TT> is a set of bits representing different methods of seeking within a stream.&nbsp; The<TT>
ios::seekdir</TT> member typedef represents the same set of bits, but uses an<TT> int</TT> to represent the values, thereby
avoiding problems made possible by the compiler's ability to use smaller types for enumerations.&nbsp; All uses of these bits
should use the<TT> ios::seekdir</TT> member typedef.
<BR><BR>The bit values defined by<TT> ios::seekdir</TT> member typedef are used by the member functions<TT> seekg</TT> and<TT>
seekp</TT>, as well the<TT> seekoff</TT> and<TT> seekpos</TT> member functions in classes derived from the<TT> streambuf</TT>
class.
<BR><BR><TT>ios::beg</TT> causes the seek offset to be interpreted as an offset from the beginning of the stream.&nbsp; The
offset is specified as a positive value.
<BR><BR><TT>ios::cur</TT> causes the seek offset to be interpreted as an offset from the current position of the stream.&nbsp;
If the offset is a negative value, the seek is towards the start of the stream.&nbsp; Otherwise, the seek is towards the end
of the stream.
<BR><BR><TT>ios::end</TT> causes the seek offset to be interpreted as an offset from the end of the stream.&nbsp; The offset
is specified as a negative value.
</DL>
<H2 ID="ios__setfLR"> setf() [ios] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>ios::fmtflags ios::setf( ios::fmtflags onbits );</TT>
<BR><TT> ios::fmtflags ios::setf( ios::fmtflags setbits,</TT>
<BR><TT> ios::fmtflags mask );</TT>
<DT>Semantics:
<DD>The<TT> setf</TT> public member function is used to set bits in<TT> ios::fmtflags</TT> in the<TT> ios</TT> object.
<BR><BR>The first form is used to turn on the bits that are on in the<B> onbits</B> parameter.&nbsp; (<B> onbits</B> is or'ed
into<TT> ios::fmtflags</TT>).
<BR><BR>The second form is used to turn off the bits specified in the<B> mask</B> parameter and turn on the bits specified
in the<B> setbits</B> parameter.&nbsp; This form is particularly useful for setting the bits described by the<TT> ios::basefield</TT>,<TT>
ios::adjustfield</TT> and<TT> ios::floatfield</TT> values, where only one bit should be on at a time.
<DT>Results:
<DD>Both forms of the<TT> setf</TT> public member function return the previous<TT> ios::fmtflags</TT> value.
<DT>See Also:
<DD><TT> ios::fmtflags</TT>,<TT> setf</TT>,<TT> unsetf</TT>, manipulator<TT> dec</TT>, manipulator<TT> hex</TT>, manipulator<TT>
oct</TT>, manipulator<TT> setbase</TT>, manipulator<TT> setiosflags</TT>, manipulator<TT> resetiosflags</TT>
</DL>
<H2 ID="ios__setstateLR"> setstate() [ios] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>protected:</TT>
<BR><TT>void ios::setstate( int or_bits );</TT>
<DT>Semantics:
<DD>The<TT> setstate</TT> protected member function is provided as a convenience for classes derived from the<TT> ios</TT> class.
&nbsp;It turns on the error state in the inherited<TT> ios</TT> object bits that are set in the<B> or_bits</B> parameter,
and leaves the other error state in the inherited<TT> ios</TT> object bits unchanged.
<DT>Results:
<DD>The<TT> setstate</TT> protected member function sets the bits specified by<B> or_bits</B> in the error state in the inherited<TT>
ios</TT> object.
<DT>See Also:
<DD><TT> ios::bad</TT>,<TT> clear</TT>,<TT> eof</TT>,<TT> fail</TT>,<TT> good</TT>,<TT> iostate</TT>,<TT> operator !</TT>,<TT>
operator void *</TT>,<TT> rdstate</TT>
</DL>
<H2 ID="ios__sync_with_stdioLR"> sync_with_stdio() [ios] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>static void ios::sync_with_stdio();</TT>
<DT>Semantics:
<DD>The<TT> sync_with_stdio</TT> public static member function is obsolete.&nbsp; It is provided for compatibility.
<DT>Results:
<DD>The<TT> sync_with_stdio</TT> public static member function has no return value.
</DL>
<H2 ID="ios__tieLR"> tie() [ios] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>ostream *ios::tie() const;</TT>
<BR><TT> ostream *ios::tie( ostream *ostrm );</TT>
<DT>Semantics:
<DD>The<TT> tie</TT> public member function is used to query and/or set up a connection between the<TT> ios</TT> object and another
stream.&nbsp; The connection causes the output stream specified by<B> ostrm</B> to be flushed whenever the<TT> ios</TT> object
is about to read characters from a device or is about to write characters to an output buffer or device.
<BR><BR>The first form of the<TT> tie</TT> public member function is used to query the current tie.
<BR><BR>The second form of the<TT> tie</TT> public member function is used to set the tied stream to<B> ostrm</B>.
<BR><BR>Normally, the predefined streams<TT> cin</TT> and<TT> cerr</TT> set up ties to<TT> cout</TT> so that any input from
the terminal flushes any buffered output, and any writes to<TT> cerr</TT> flush<TT> cout</TT> before the characters are written.<TT>
&nbsp;cout</TT> does not set up a tie to<TT> cerr</TT> because<TT> cerr</TT> has the flag<TT> ios::unitbuf</TT> set, so it
flushes itself after every write operation.
<DT>Results:
<DD>Both forms of the<TT> tie</TT> public member function return the previous tie value.
<DT>See Also:
<DD><TT> ios::fmtflags</TT>
</DL>
<H2 ID="ios__unsetfLR"> unsetf() [ios] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>ios::fmtflags ios::unsetf( ios::fmtflags offbits );</TT>
<DT>Semantics:
<DD>The<TT> unsetf</TT> public member function is used to turn off bits in<TT> ios::fmtflags</TT> that are set in the<B> offbits</B>
parameter.&nbsp; All other bits in<TT> ios::fmtflags</TT> are unchanged.
<DT>Results:
<DD>The<TT> unsetf</TT> public member function returns the old<TT> ios::fmtflags</TT> value.
<DT>See Also:
<DD><TT> ios::fmtflags</TT>,<TT> setf</TT>,<TT> unsetf</TT>, manipulator<TT> dec</TT>, manipulator<TT> hex</TT>, manipulator<TT>
oct</TT>, manipulator<TT> setbase</TT>, manipulator<TT> setiosflags</TT>, manipulator<TT> resetiosflags</TT>
</DL>
<H2 ID="ios__widthLR"> width() [ios] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int ios::width() const;</TT>
<BR><TT> int ios::width( int wid );</TT>
<DT>Semantics:
<DD>The<TT> width</TT> public member function is used to query and/or set the<B> format width</B> used to format the next item.
&nbsp;A<B> format width</B> of zero indicates that the item is to be written using exactly the number of positions required.
&nbsp;Other values indicate that the item must occupy at least that many positions.&nbsp; If the formatted item is larger
than the specified<B> format width</B>, the<B> format width</B> is ignored and the item is formatted using the required number
of positions.
<BR><BR>The first form of the<TT> width</TT> public member function is used to query the<B> format width</B> that is to be
used for the next item.
<BR><BR>The second form of the<TT> width</TT> public member function is used to set the<B> format width</B> to<B> wid</B>
for the next item to be formatted.
<BR><BR>After an item has been formatted, the<B> format width</B> is reset to zero.&nbsp; Therefore, any non-zero<B> format
width</B> must be set before each item that is to be formatted.
<DT>Results:
<DD>The<TT> width</TT> public member function returns the previous<B> format width</B>.
<DT>See Also:
<DD><TT> ios::fmtflags</TT>, manipulator<TT> setw</TT>, manipulator<TT> setwidth</TT>
</DL>
<H2 ID="ios__xallocLR"> xalloc() [ios] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>static int ios::xalloc();</TT>
<DT>Semantics:
<DD>The<TT> xalloc</TT> public static member function returns an index into an array of items that the program may use for any
purpose.&nbsp; Each item can be either a<TT> long int</TT> or a pointer to<TT> void</TT>.&nbsp; The index can be used with
the<TT> iword</TT> and<TT> pword</TT> member functions.
<BR><BR>Because the<TT> xalloc</TT> public static member function manipulates<TT> static</TT> member data, its behavior is
not tied to any one object but affects the entire class of objects.&nbsp; The value that is returned by the<TT> xalloc</TT>
public static member function is valid for all objects of all classes derived from the<TT> ios</TT> class.&nbsp; No subsequent
call to the<TT> xalloc</TT> public static member function will return the same value as a previous call.
<DT>Results:
<DD>The<TT> xalloc</TT> public static member function returns an index for use with the<TT> iword</TT> and<TT> pword</TT> member
functions.
<DT>See Also:
<DD><TT> ios::iword</TT>,<TT> pword</TT>
</DL>
<H2 ID="iostream_Class_Description"> iostream Class Description </H2>
<DL>
<DT>Declared:
<DD><TT> iostream.h</TT>
<DT>Derived from:
<DD><TT> istream</TT>,<TT> ostream</TT>
<DT>Derived by:
<DD><TT> fstream</TT>,<TT> strstream</TT>
<BR><BR>The<TT> iostream</TT> class supports reading and writing of characters from and to the standard input/output devices,
usually the keyboard and screen.&nbsp; The<TT> iostream</TT> class provides formatted conversion of characters to and from
other types (e.g.&nbsp; integers and floating-point numbers).&nbsp; The associated<TT> streambuf</TT> class provides the methods
for communicating with the actual device, while the<TT> iostream</TT> class provides the interpretation of the characters.
<BR>Generally, an<TT> iostream</TT> object won't be created by a program, since there is no mechanism at this level to &quot;open&quot;
a device.&nbsp; No instance of an<TT> iostream</TT> object is created by default, since it is usually not possible to perform
both input and output on the standard input/output devices.&nbsp; The<TT> iostream</TT> class is provided as a base class
for other derived classes that can provide both input and output capabilities through the same object.&nbsp; The<TT> fstream</TT>
and<TT> strstream</TT> classes are examples of classes derived from the<TT> iostream</TT> class.
<BR><BR><B>Protected Member Functions</B>
<BR><BR>The following protected member functions are declared:
<BR><BR><TT>iostream();</TT>
<BR><BR><B>Public Member Functions</B>
<BR><BR>The following public member functions are declared:
<BR><BR><TT>iostream( ios const &amp; );</TT>
<BR><TT> iostream( streambuf * );</TT>
<BR><TT> virtual ~iostream();</TT>
<BR><BR><B>Public Member Operators</B>
<BR><BR>The following public member operators are declared:
<BR><BR><TT>iostream &amp; operator =( streambuf * );</TT>
<BR><TT> iostream &amp; operator =( ios const &amp; );</TT>
<DT>See Also:
<DD><TT> ios</TT>,<TT> istream</TT>,<TT> ostream</TT>
</DL>
<H2 ID="iostream__iostreamLR"> iostream() [iostream] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>protected:</TT>
<BR><TT>iostream::iostream();</TT>
<DT>Semantics:
<DD>This form of the protected<TT> iostream</TT> constructor creates an<TT> iostream</TT> object without an attached<TT> streambuf</TT>
object.
<BR><BR>This form of the protected<TT> iostream</TT> constructor is only used implicitly by the compiler when it generates
a constructor for a derived class.
<DT>Results:
<DD>The protected<TT> iostream</TT> constructor produces an initialized<TT> iostream</TT> object.<TT>&nbsp; ios::badbit</TT> is
set in the error state in the inherited<TT> ios</TT> object.
<DT>See Also:
<DD><TT> ~iostream</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>iostream::iostream( ios const &amp;strm );</TT>
<DT>Semantics:
<DD>This form of the public<TT> iostream</TT> constructor creates an<TT> iostream</TT> object associated with the<TT> streambuf</TT>
object currently associated with the<B> strm</B> parameter.&nbsp; The<TT> iostream</TT> object is initialized and will use
the<B> strm</B><TT> streambuf</TT> object for subsequent operations.<B>&nbsp; strm</B> will continue to use the<TT> streambuf</TT>
object.
<DT>Results:
<DD>The public<TT> iostream</TT> constructor produces an initialized<TT> iostream</TT> object.&nbsp; If there is no<TT> streambuf</TT>
object currently associated with the<B> strm</B> parameter,<TT> ios::badbit</TT> is set in the error state in the inherited<TT>
ios</TT> object.
<DT>See Also:
<DD><TT> ~iostream</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>iostream::iostream( streambuf *sb );</TT>
<DT>Semantics:
<DD>This form of the public<TT> iostream</TT> constructor creates an<TT> iostream</TT> object with an attached<TT> streambuf</TT>
object.
<BR><BR>Since a user program usually will not create an<TT> iostream</TT> object, this form of the public<TT> iostream</TT>
constructor is unlikely to be explicitly used, except in the member initializer list for the constructor of a derived class.
&nbsp;The<B> sb</B> parameter is a pointer to a<TT> streambuf</TT> object, which should be connected to the source and sink
of characters for the stream.
<DT>Results:
<DD>The public<TT> iostream</TT> constructor produces an initialized<TT> iostream</TT> object.&nbsp; If the<B> sb</B> parameter
is<TT> NULL</TT>,<TT> ios::badbit</TT> is set in the error state in the inherited<TT> ios</TT> object.
<DT>See Also:
<DD><TT> ~iostream</TT>
</DL>
<H2 ID="iostream____iostreamLR"> ~iostream() [iostream] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>virtual iostream::~iostream();</TT>
<DT>Semantics:
<DD>The public<TT> ~iostream</TT> destructor does not do anything explicit.&nbsp; The<TT> ios</TT> destructor is called for that
portion of the<TT> iostream</TT> object.&nbsp; The call to the public<TT> ~iostream</TT> destructor is inserted implicitly
by the compiler at the point where the<TT> iostream</TT> object goes out of scope.
<DT>Results:
<DD>The<TT> iostream</TT> object is destroyed.
<DT>See Also:
<DD><TT> iostream</TT>
</DL>
<H2 ID="iostream__operator_ELR"> operator =() [iostream] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>iostream &amp;iostream::operator =( streambuf *sb );</TT>
<DT>Semantics:
<DD>This form of the<TT> operator =</TT> public member function initializes the target<TT> iostream</TT> object and sets up an
association between the<TT> iostream</TT> object and the<TT> streambuf</TT> object specified by the<B> sb</B> parameter.
<DT>Results:
<DD>The<TT> operator =</TT> public member function returns a reference to the<TT> iostream</TT> object that is the target of the
assignment.&nbsp; If the<B> sb</B> parameter is<TT> NULL</TT>,<TT> ios::badbit</TT> is set in the error state in the inherited<TT>
ios</TT> object.
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>iostream &amp;iostream::operator =( const ios &amp;strm );</TT>
<DT>Semantics:
<DD>This form of the<TT> operator =</TT> public member function initializes the<TT> iostream</TT> object and sets up an association
between the<TT> iostream</TT> object and the<TT> streambuf</TT> object currently associated with the<B> strm</B> parameter.
<DT>Results:
<DD>The<TT> operator =</TT> public member function returns a reference to the<TT> iostream</TT> object that is the target of the
assignment.&nbsp; If there is no<TT> streambuf</TT> object currently associated with the<B> strm</B> parameter,<TT> ios::badbit</TT>
is set in the error state in the inherited<TT> ios</TT> object.
</DL>
<H2 ID="istream_Class_Description"> istream Class Description </H2>
<DL>
<DT>Declared:
<DD><TT> iostream.h</TT>
<DT>Derived from:
<DD><TT> ios</TT>
<DT>Derived by:
<DD><TT> iostream</TT>,<TT> ifstream</TT>,<TT> istrstream</TT>
<BR><BR>The<TT> istream</TT> class supports reading characters from a class derived from<TT> streambuf</TT>, and provides
formatted conversion of characters into other types (such as integers and floating-point numbers).&nbsp; The<TT> streambuf</TT>
class provides the methods for communicating with the external device (keyboard, disk), while the<TT> istream</TT> class provides
the interpretation of the resulting characters.
<BR>Generally, an<TT> istream</TT> object won't be explicitly created by a program, since there is no mechanism at this level
to open a device.&nbsp; The only default<TT> istream</TT> object in a program is<TT> cin</TT>, which reads from standard input
(usually the keyboard).
<BR><BR>The<TT> istream</TT> class supports two basic concepts of input:&nbsp; formatted and unformatted.&nbsp; The overloaded<TT>
operator &gt;&gt;</TT> member functions are called<B> extractors</B> and they provide the support for formatted input.&nbsp;
The rest of the member functions deal with unformatted input, managing the state of the<TT> ios</TT> object and providing
a friendlier interface to the associated<TT> streambuf</TT> object.
<BR><BR><B>Protected Member Functions</B>
<BR><BR>The following protected member functions are declared:
<BR><BR><TT>istream();</TT>
<BR><TT> eatwhite();</TT>
<BR><BR><B>Public Member Functions</B>
<BR><BR>The following public member functions are declared:
<BR><BR><TT>istream( istream const &amp; );</TT>
<BR><TT> istream( streambuf * );</TT>
<BR><TT> virtual ~istream();</TT>
<BR><TT> int ipfx( int = 0 );</TT>
<BR><TT> void isfx();</TT>
<BR><TT> int get();</TT>
<BR><TT> istream &amp;get( char *, int, char = '\n' );</TT>
<BR><TT> istream &amp;get( signed char *, int, char = '\n' );</TT>
<BR><TT> istream &amp;get( unsigned char *, int, char = '\n' );</TT>
<BR><TT> istream &amp;get( char &amp; );</TT>
<BR><TT> istream &amp;get( signed char &amp; );</TT>
<BR><TT> istream &amp;get( unsigned char &amp; );</TT>
<BR><TT> istream &amp;get( streambuf &amp;, char = '\n' );</TT>
<BR><TT> istream &amp;getline( char *, int, char = '\n' );</TT>
<BR><TT> istream &amp;getline( signed char *, int, char = '\n' );</TT>
<BR><TT> istream &amp;getline( unsigned char *, int, char = '\n' );</TT>
<BR><TT> istream &amp;ignore( int = 1, int = EOF );</TT>
<BR><TT> istream &amp;read( char *, int );</TT>
<BR><TT> istream &amp;read( signed char *, int );</TT>
<BR><TT> istream &amp;read( unsigned char *, int );</TT>
<BR><TT> istream &amp;seekg( streampos );</TT>
<BR><TT> istream &amp;seekg( streamoff, ios::seekdir );</TT>
<BR><TT> istream &amp;putback( char );</TT>
<BR><TT> streampos tellg();</TT>
<BR><TT> int gcount() const;</TT>
<BR><TT> int peek();</TT>
<BR><TT> int sync();</TT>
<BR><BR><B>Public Member Operators</B>
<BR><BR>The following public member operators are declared:
<BR><BR><TT>istream &amp;operator =( streambuf * );</TT>
<BR><TT> istream &amp;operator =( istream const &amp; );</TT>
<BR><TT> istream &amp;operator &gt;&gt;( char * );</TT>
<BR><TT> istream &amp;operator &gt;&gt;( signed char * );</TT>
<BR><TT> istream &amp;operator &gt;&gt;( unsigned char * );</TT>
<BR><TT> istream &amp;operator &gt;&gt;( char &amp; );</TT>
<BR><TT> istream &amp;operator &gt;&gt;( signed char &amp; );</TT>
<BR><TT> istream &amp;operator &gt;&gt;( unsigned char &amp; );</TT>
<BR><TT> istream &amp;operator &gt;&gt;( signed short &amp; );</TT>
<BR><TT> istream &amp;operator &gt;&gt;( unsigned short &amp; );</TT>
<BR><TT> istream &amp;operator &gt;&gt;( signed int &amp; );</TT>
<BR><TT> istream &amp;operator &gt;&gt;( unsigned int &amp; );</TT>
<BR><TT> istream &amp;operator &gt;&gt;( signed long &amp; );</TT>
<BR><TT> istream &amp;operator &gt;&gt;( unsigned long &amp; );</TT>
<BR><TT> istream &amp;operator &gt;&gt;( float &amp; );</TT>
<BR><TT> istream &amp;operator &gt;&gt;( double &amp; );</TT>
<BR><TT> istream &amp;operator &gt;&gt;( long double &amp; );</TT>
<BR><TT> istream &amp;operator &gt;&gt;( streambuf &amp; );</TT>
<BR><TT> istream &amp;operator &gt;&gt;( istream &amp;(*)( istream &amp; ) );</TT>
<BR><TT> istream &amp;operator &gt;&gt;( ios &amp;(*)( ios &amp; ) );</TT>
<DT>See Also:
<DD><TT> ios</TT>,<TT> iostream</TT>,<TT> ostream</TT>
</DL>
<H2 ID="istream__eatwhiteLR"> eatwhite() [istream] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>protected:</TT>
<BR><TT>void istream::eatwhite();</TT>
<DT>Semantics:
<DD>The<TT> eatwhite</TT> protected member function extracts and discards whitespace characters from the<TT> istream</TT> object,
until a non-whitespace character is found.&nbsp; The non-whitespace character is not extracted.
<DT>Results:
<DD>The<TT> eatwhite</TT> protected member function sets<TT> ios::eofbit</TT> in the error state in the inherited<TT> ios</TT>
object if end-of-file is encountered as the first character while extracting whitespace characters.
<DT>See Also:
<DD><TT> istream::ignore</TT>,<TT> ios::fmtflags</TT>
</DL>
<H2 ID="istream__gcountLR"> gcount() [istream] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int istream::gcount() const;</TT>
<DT>Semantics:
<DD>The<TT> gcount</TT> public member function determines the number of characters extracted by the last unformatted input member
function.
<DT>Results:
<DD>The<TT> gcount</TT> public member function returns the number of characters extracted by the last unformatted input member
function.
<DT>See Also:
<DD><TT> istream::get</TT>,<TT> getline</TT>,<TT> read</TT>
</DL>
<H2 ID="istream__getLR"> get() [istream] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int istream::get();</TT>
<DT>Semantics:
<DD>This form of the<TT> get</TT> public member function performs an unformatted read of a single character from the<TT> istream</TT>
object.
<DT>Results:
<DD>This form of the<TT> get</TT> public member function returns the character read from the<TT> istream</TT> object.&nbsp; If
the<TT> istream</TT> object is positioned at end-of-file before the read,<TT> EOF</TT> is returned and<TT> ios::eofbit</TT>
bit is set in the error state in the inherited<TT> ios</TT> object.<TT>&nbsp; ios::failbit</TT> bit is not set by this form
of the<TT> get</TT> public member function.
<DT>See Also:
<DD><TT> istream::putback</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>istream &amp;istream::get( char &amp;ch );</TT>
<BR><TT> istream &amp;istream::get( signed char &amp;ch );</TT>
<BR><TT> istream &amp;istream::get( unsigned char &amp;ch );</TT>
<DT>Semantics:
<DD>These forms of the<TT> get</TT> public member function perform an unformatted read of a single character from the<TT> istream</TT>
object and store the character in the<B> ch</B> parameter.
<DT>Results:
<DD>These forms of the<TT> get</TT> public member function return a reference to the<TT> istream</TT> object.<TT>&nbsp; ios::eofbit</TT>
is set in the error state in the inherited<TT> ios</TT> object if the<TT> istream</TT> object is positioned at end-of-file
before the attempt to read the character.<TT>&nbsp; ios::failbit</TT> is set in the error state in the inherited<TT> ios</TT>
object if no character is read.
<DT>See Also:
<DD><TT> istream::read</TT>,<TT> operator &gt;&gt;</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>istream &amp;istream::get( char *buf, int len,</TT>
<BR><TT> char delim = '\n' );</TT>
<BR><TT>istream &amp;istream::get( signed char *buf, int len,</TT>
<BR><TT> char delim = '\n' );</TT>
<BR><TT>istream &amp;istream::get( unsigned char *buf, int len,</TT>
<BR><TT> char delim = '\n' );</TT>
<DT>Semantics:
<DD>These forms of the<TT> get</TT> public member function perform an unformatted read of at most<B> len</B> -1 characters from
the<TT> istream</TT> object and store them starting at the memory location specified by the<B> buf</B> parameter.&nbsp; If
the character specified by the<B> delim</B> parameter is encountered in the<TT> istream</TT> object before<B> len</B> -1 characters
have been read, the read terminates without extracting the delimiting character.
<BR><BR>After the read terminates, whether or not an error occurred, a null character is stored in<B> buf</B> following the
last character read from the<TT> istream</TT> object.
<BR><BR>If the<B> delim</B> parameter is not specified, the new-line character is assumed.
<DT>Results:
<DD>These forms of the<TT> get</TT> public member function return a reference to the<TT> istream</TT> object.&nbsp; If end-of-file
is encountered as the first character,<TT> ios::eofbit</TT> is set in the error state in the inherited<TT> ios</TT> object.
&nbsp;If no characters are stored into<B> buf,</B><TT> ios::failbit</TT> is set in the error state in the inherited<TT> ios</TT>
object.
<DT>See Also:
<DD><TT> istream::getline</TT>,<TT> read</TT>,<TT> operator &gt;&gt;</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>istream &amp;istream::get( streambuf &amp;sb, char delim = '\n' );</TT>
<DT>Semantics:
<DD>This form of the<TT> get</TT> public member function performs an unformatted read of characters from the<TT> istream</TT>
object and transfers them to the<TT> streambuf</TT> object specified in the<B> sb</B> parameter.&nbsp; The transfer stops
if end-of-file is encountered, the delimiting character specified in the<B> delim</B> parameter is found, or if the store
into the<B> sb</B> parameter fails.&nbsp; If the<B> delim</B> character is found, it is not extracted from the<TT> istream</TT>
object and is not transferred to the<B> sb</B> object.
<BR><BR>If the<B> delim</B> parameter is not specified, the new-line character is assumed.
<DT>Results:
<DD>The<TT> get</TT> public member function returns a reference to the<TT> istream</TT> object.<TT>&nbsp; ios::failbit</TT> is
set in the error state in the inherited<TT> ios</TT> object if the store into the<TT> streambuf</TT> object fails.
<DT>See Also:
<DD><TT> istream::getline</TT>,<TT> read</TT>,<TT> operator &gt;&gt;</TT>
</DL>
<H2 ID="istream__getlineLR"> getline() [istream] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>istream &amp;istream::getline( char *buf, int len,</TT>
<BR><TT> char delim = '\n' );</TT>
<BR><TT>istream &amp;istream::getline( signed char *buf, int len,</TT>
<BR><TT> char delim = '\n' );</TT>
<BR><TT>istream &amp;istream::getline( unsigned char *buf, int len,</TT>
<BR><TT> char delim = '\n' );</TT>
<DT>Semantics:
<DD>The<TT> getline</TT> public member function performs an unformatted read of at most<B> len</B> -1 characters from the<TT>
istream</TT> object and stores them starting at the memory location specified by the<B> buf</B> parameter.&nbsp; If the delimiting
character, specified by the<B> delim</B> parameter, is encountered in the<TT> istream</TT> object before<B> len</B> -1 characters
have been read, the read terminates after extracting the<B> delim</B> character.
<BR><BR>If<B> len</B> -1 characters have been read and the next character is the<B> delim</B> character, it is not extracted.
<BR><BR>After the read terminates, whether or not an error occurred, a null character is stored in the buffer following the
last character read from the<TT> istream</TT> object.
<BR><BR>If the<B> delim</B> parameter is not specified, the new-line character is assumed.
<DT>Results:
<DD>The<TT> getline</TT> public member function returns a reference to the<TT> istream</TT> object.&nbsp; If end-of-file is encountered
as the first character,<TT> ios::eofbit</TT> is set in the error state in the inherited<TT> ios</TT> object.&nbsp; If end-of-file
is encountered before<B> len</B> characters are transferred or the<B> delim</B> character is reached,<TT> ios::failbit</TT>
is set in the error state in the inherited<TT> ios</TT> object.
<DT>See Also:
<DD><TT> istream::get</TT>,<TT> read</TT>,<TT> operator &gt;&gt;</TT>
</DL>
<H2 ID="istream__ignoreLR"> ignore() [istream] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>istream &amp;istream::ignore( int num = 1, int delim = EOF );</TT>
<DT>Semantics:
<DD>The<TT> ignore</TT> public member function extracts and discards up to<B> num</B> characters from the<TT> istream</TT> object.
&nbsp;If the<B> num</B> parameter is not specified, the<TT> ignore</TT> public member function extracts and discards one character.
&nbsp;If the<B> delim</B> parameter is not<TT> EOF</TT> and it is encountered before<B> num</B> characters have been extracted,
the extraction ceases after discarding the delimiting character.&nbsp; The extraction stops if end-of-file is encountered.
<BR><BR>If the<B> num</B> parameter is specified as a negative number, no limit is imposed on the number of characters extracted
and discarded.&nbsp; The operation continues until the delimiting character is found and discarded, or until end-of-file.
&nbsp;This behavior is a WATCOM extension.
<DT>Results:
<DD>The<TT> ignore</TT> public member function returns a reference to the<TT> istream</TT> object.&nbsp; If end-of-file is encountered
as the first character,<TT> ios::eofbit</TT> is set in the error state in the inherited<TT> ios</TT> object.
<DT>See Also:
<DD><TT> istream::eatwhite</TT>
</DL>
<H2 ID="istream__ipfxLR"> ipfx() [istream] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int istream::ipfx( int noskipws = 0 );</TT>
<DT>Semantics:
<DD>The<TT> ipfx</TT> public member function is a prefix function executed before each of the formatted and unformatted read operations.
&nbsp;If any bits are set in<TT> ios::iostate</TT>, the<TT> ipfx</TT> public member function immediately returns 0, indicating
that the prefix function failed.&nbsp; Failure in the prefix function causes the input operation to fail.
<BR><BR>If the<B> noskipws</B> parameter is 0 or unspecified and the<TT> ios::skipws</TT> bit is on in<TT> ios::fmtflags</TT>,
whitespace characters are discarded and the<TT> istream</TT> object is positioned so that the next character read is the first
character after the discarded whitespace.&nbsp; Otherwise, no whitespace skipping takes place.
<BR><BR>The formatted input functions that read specific types of objects (such as integers and floating-point numbers) call
the<TT> ipfx</TT> public member function with the<B> noskipws</B> parameter set to zero, allowing leading whitespaces to be
discarded if the<TT> ios::skipws</TT> bit is on in<TT> ios::fmtflags</TT>.&nbsp; The unformatted input functions that read
characters without interpretation call the<TT> ipfx</TT> public member function with a the<B> noskipws</B> parameter set to
1 so that no whitespace characters are discarded.
<BR><BR>If the<TT> istream</TT> object is tied to an output stream, the output stream is flushed.
<DT>Results:
<DD>If the<TT> istream</TT> object is not in an error state in the inherited<TT> ios</TT> object when the above processing is
completed, the<TT> ipfx</TT> public member function returns a non-zero value to indicate success.&nbsp; Otherwise, zero is
returned to indicate failure.
<DT>See Also:
<DD><TT> istream::isfx</TT>
</DL>
<H2 ID="istream__isfxLR"> isfx() [istream] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void istream::isfx();</TT>
<DT>Semantics:
<DD>The<TT> isfx</TT> public member function is a suffix function executed just before the end of each of the formatted and unformatted
read operations.
<BR><BR>As currently implemented, the<TT> isfx</TT> public member function does not do anything.
<DT>See Also:
<DD><TT> istream::ipfx</TT>
</DL>
<H2 ID="istream__istreamLR"> istream() [istream] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>protected:</TT>
<BR><TT>istream::istream();</TT>
<DT>Semantics:
<DD>This form of the protected<TT> istream</TT> constructor creates an<TT> istream</TT> object without an associated<TT> streambuf</TT>
object.
<BR><BR>This form of the protected<TT> istream</TT> constructor is only used implicitly by the compiler when it generates
a constructor for a derived class.
<DT>Results:
<DD>This form of the protected<TT> istream</TT> constructor creates an initialized<TT> istream</TT> object.<TT>&nbsp; ios::badbit</TT>
is set in the error state in the inherited<TT> ios</TT> object.
<DT>See Also:
<DD><TT> ~istream</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>istream::istream( istream const &amp;istrm );</TT>
<DT>Semantics:
<DD>This form of the public<TT> istream</TT> constructor creates an<TT> istream</TT> object associated with the<TT> streambuf</TT>
object currently associated with the<B> istrm</B> parameter.&nbsp; The<TT> istream</TT> object is initialized and will use
the<B> istrm</B><TT> streambuf</TT> object for subsequent operations.<B>&nbsp; istrm</B> will continue to use the<TT> streambuf</TT>
object.
<DT>Results:
<DD>This form of the public<TT> istream</TT> constructor creates an initialized<TT> istream</TT> object.&nbsp; If there is no<TT>
streambuf</TT> object currently associated with the<B> istrm</B> parameter,<TT> ios::badbit</TT> is set in the error state
in the inherited<TT> ios</TT> object.
<DT>See Also:
<DD><TT> ~istream</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>istream::istream( streambuf *sb );</TT>
<DT>Semantics:
<DD>This form of the public<TT> istream</TT> constructor creates an<TT> istream</TT> object with an associated<TT> streambuf</TT>
object specified by the<B> sb</B> parameter.
<BR><BR>This function is likely to be used for the creation of an<TT> istream</TT> object that is associated with the same<TT>
streambuf</TT> object as another<TT> istream</TT> object.
<DT>Results:
<DD>This form of the public<TT> istream</TT> constructor creates an initialized<TT> istream</TT> object.&nbsp; If the<B> sb</B>
parameter is<TT> NULL</TT>,<TT> ios::badbit</TT> is set in the error state in the inherited<TT> ios</TT> object.
<DT>See Also:
<DD><TT> ~istream</TT>
</DL>
<H2 ID="istream____istreamLR"> ~istream() [istream] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>virtual istream::~istream();</TT>
<DT>Semantics:
<DD>The public virtual<TT> ~istream</TT> destructor does not do anything explicit.&nbsp; The<TT> ios</TT> destructor is called
for that portion of the<TT> istream</TT> object.&nbsp; The call to the public virtual<TT> ~istream</TT> destructor is inserted
implicitly by the compiler at the point where the<TT> istream</TT> object goes out of scope.
<DT>Results:
<DD>The<TT> istream</TT> object is destroyed.
<DT>See Also:
<DD><TT> istream</TT>
</DL>
<H2 ID="istream__operator_ELR"> operator =() [istream] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>istream &amp;istream::operator =( streambuf *sb );</TT>
<DT>Semantics:
<DD>This form of the<TT> operator =</TT> public member function is used to associate a<TT> streambuf</TT> object, specified by
the<B> sb</B> parameter, with an existing<TT> istream</TT> object.&nbsp; The<TT> istream</TT> object is initialized and will
use the specified<TT> streambuf</TT> object for subsequent operations.
<DT>Results:
<DD>This form of the<TT> operator =</TT> public member function returns a reference to the<TT> istream</TT> object that is the
target of the assignment.&nbsp; If the<B> sb</B> parameter is<TT> NULL</TT>,<TT> ios::badbit</TT> is set in the error state
in the inherited<TT> ios</TT> object.
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>istream &amp;istream::operator =( istream const &amp;istrm );</TT>
<DT>Semantics:
<DD>This form of the<TT> operator =</TT> public member function is used to associate the<TT> istream</TT> object with the<TT>
streambuf</TT> object currently associated with the<B> istrm</B> parameter.&nbsp; The<TT> istream</TT> object is initialized
and will use the<B> istrm</B>'s<TT> streambuf</TT> object for subsequent operations.&nbsp; The<B> istrm</B> object will continue
to use the<TT> streambuf</TT> object.
<DT>Results:
<DD>This form of the<TT> operator =</TT> public member function returns a reference to the<TT> istream</TT> object that is the
target of the assignment.&nbsp; If there is no<TT> streambuf</TT> object currently associated with the<B> istrm</B> parameter,<TT>
ios::badbit</TT> is set in the error state in the inherited<TT> ios</TT> object.
</DL>
<H2 ID="istream__operator_YYLR"> operator &gt;&gt;() [istream] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>istream &amp;istream::operator &gt;&gt;( char *buf );</TT>
<BR><TT> istream &amp;istream::operator &gt;&gt;( signed char *buf );</TT>
<BR><TT> istream &amp;istream::operator &gt;&gt;( unsigned char *buf );</TT>
<DT>Semantics:
<DD>These forms of the<TT> operator &gt;&gt;</TT> public member function perform a formatted read of characters from the<TT> istream</TT>
object and place them in the buffer specified by the<B> buf</B> parameter.&nbsp; Characters are read until a whitespace character
is found or the maximum size has been read.&nbsp; If a whitespace character is found, it is not transferred to the buffer
and remains in the<TT> istream</TT> object.
<BR><BR>If a non-zero<B> format width</B> has been specified, it is interpreted as the maximum number of characters that may
be placed in<B> buf</B>.&nbsp; No more than<B> format width</B>-1 characters are read from the<TT> istream</TT> object and
transferred to<B> buf</B>.&nbsp; If<B> format width</B> is zero, characters are transferred until a whitespace character is
found.
<BR><BR>Since these forms of the<TT> operator &gt;&gt;</TT> public member function use<B> format width</B>, it is reset to
zero after each use.&nbsp; It must be set before each input operation that requires a non-zero<B> format width</B>.
<BR><BR>A null character is added following the last transferred character, even if the transfer fails because of an error.
<DT>Results:
<DD>These forms of the<TT> operator &gt;&gt;</TT> public member function return a reference to the<TT> istream</TT> object so
that further extraction operations may be specified in the same statement.&nbsp; If no characters are transferred to<B> buf</B>,<TT>
ios::failbit</TT> is set in the error state in the inherited<TT> ios</TT> object.&nbsp; If the first character read yielded
end-of-file,<TT> ios::eofbit</TT> is set in the error state in the inherited<TT> ios</TT> object.
<DT>See Also:
<DD><TT> istream::get</TT>,<TT> getline</TT>,<TT> read</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>istream &amp;istream::operator &gt;&gt;( char &amp;ch );</TT>
<BR><TT> istream &amp;istream::operator &gt;&gt;( signed char &amp;ch );</TT>
<BR><TT> istream &amp;istream::operator &gt;&gt;( unsigned char &amp;ch );</TT>
<DT>Semantics:
<DD>These forms of the<TT> operator &gt;&gt;</TT> public member function perform a formatted read of a single character from the<TT>
istream</TT> object and place it in the<B> ch</B> parameter.
<DT>Results:
<DD>These forms of the<TT> operator &gt;&gt;</TT> public member function return a reference to the<TT> istream</TT> object so
that further extraction operations may be specified in the same statement.&nbsp; If the character read yielded end-of-file,<TT>
ios::eofbit</TT> is set in the error state in the inherited<TT> ios</TT> object.
<DT>See Also:
<DD><TT> istream::get</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>istream &amp;istream::operator &gt;&gt;( signed int &amp;num );</TT>
<BR><TT> istream &amp;istream::operator &gt;&gt;( unsigned int &amp;num );</TT>
<BR><TT> istream &amp;istream::operator &gt;&gt;( signed long &amp;num );</TT>
<BR><TT> istream &amp;istream::operator &gt;&gt;( unsigned long &amp;num );</TT>
<BR><TT> istream &amp;istream::operator &gt;&gt;( signed short &amp;num );</TT>
<BR><TT> istream &amp;istream::operator &gt;&gt;( unsigned short &amp;num );</TT>
<DT>Semantics:
<DD>These forms the<TT> operator &gt;&gt;</TT> public member function perform a formatted read of an integral value from the<TT>
istream</TT> object and place it in the<B> num</B> parameter.
<BR><BR>The number may be preceded by a<TT> +</TT> or<TT> -</TT> sign.
<BR><BR>If<TT> ios::dec</TT> is the only bit set in the<TT> ios::basefield</TT> bits of<TT> ios::fmtflags</TT>, the number
is interpreted as a decimal (base 10) integer, composed of the digits<TT> 0123456789</TT>.
<BR><BR>If<TT> ios::oct</TT> is the only bit set in the<TT> ios::basefield</TT> bits of<TT> ios::fmtflags</TT>, the number
is interpreted as an octal (base 8) integer, composed of the digits<TT> 01234567</TT>.
<BR><BR>If<TT> ios::hex</TT> is the only bit set in the<TT> ios::basefield</TT> bits of<TT> ios::fmtflags</TT>, the number
is interpreted as a hexadecimal (base 16) integer, composed of the digits<TT> 0123456789</TT> and the letters<TT> abcdef</TT>
or<TT> ABCDEF</TT>.
<BR><BR>If no bits are set in the<TT> ios::basefield</TT> bits of<TT> ios::fmtflags</TT>, the operator looks for a prefix
to determine the base of the number.&nbsp; If the first two characters are<TT> 0x</TT> or<TT> 0X</TT>, the number is interpreted
as a hexadecimal number.&nbsp; If the first character is a<TT> 0</TT> (and the second is not an<TT> x</TT> or<TT> X</TT>),
the number is interpreted as an octal integer.&nbsp; Otherwise, no prefix is expected and the number is interpreted as a decimal
integer.
<BR><BR>If more than one bit is set in the<TT> ios::basefield</TT> bits of<TT> ios::fmtflags</TT>, the number is interpreted
as a decimal integer.
<DT>Results:
<DD>These forms of the<TT> operator &gt;&gt;</TT> public member function return a reference to the<TT> istream</TT> object so
that further extraction operations may be specified in the same statement.&nbsp; If end-of-file is encountered as the first
character,<TT> ios::eofbit</TT> is set in the error state in the inherited<TT> ios</TT> object.&nbsp; If an overflow occurs
while converting to the required integer type, the<TT> ios::failbit</TT> is set in the error state in the inherited<TT> ios</TT>
object.
<DT>See Also:
<DD><TT> ios::fmtflags</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>istream &amp;istream::operator &gt;&gt;( float &amp;num );</TT>
<BR><TT> istream &amp;istream::operator &gt;&gt;( double &amp;num );</TT>
<BR><TT> istream &amp;istream::operator &gt;&gt;( long double &amp;num );</TT>
<DT>Semantics:
<DD>These forms of the<TT> operator &gt;&gt;</TT> public member function perform a formatted read of a floating-point value from
the<TT> istream</TT> object and place it in the<B> num</B> parameter.
<BR><BR>The floating-point value may be specified in any form that is acceptable to the C++ compiler.
<DT>Results:
<DD>These forms of the<TT> operator &gt;&gt;</TT> public member function return a reference to the<TT> istream</TT> object so
that further extraction operations may be specified in the same statement.&nbsp; If end-of-file is encountered as the first
character,<TT> ios::eofbit</TT> is set in the error state in the inherited<TT> ios</TT> object.&nbsp; If an overflow occurs
while converting to the required type, the<TT> ios::failbit</TT> is set in the error state in the inherited<TT> ios</TT> object.
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>istream &amp;istream::operator &gt;&gt;( streambuf &amp;sb );</TT>
<DT>Semantics:
<DD>This form of the<TT> operator &gt;&gt;</TT> public member function transfers all the characters from the<TT> istream</TT>
object into the<B> sb</B> parameter.&nbsp; Reading continues until end-of-file is encountered.
<DT>Results:
<DD>This form of the<TT> operator &gt;&gt;</TT> public member function return a reference to the<TT> istream</TT> object so that
further extraction operations may be specified in the same statement.
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>istream &amp;istream::operator &gt;&gt;( istream &amp;(*fn)( istream &amp; ) );</TT>
<BR><TT> istream &amp;istream::operator &gt;&gt;( ios &amp;(*fn)( ios &amp; ) );</TT>
<DT>Semantics:
<DD>These forms of the<TT> operator &gt;&gt;</TT> public member function are used to implement the non-parameterized manipulators
for the<TT> istream</TT> class.&nbsp; The function specified by the<B> fn</B> parameter is called with the<TT> istream</TT>
object as its parameter.
<DT>Results:
<DD>These forms of the<TT> operator &gt;&gt;</TT> public member function return a reference to the<TT> istream</TT> object so
that further extraction operations may be specified in the same statement.
</DL>
<H2 ID="istream__peekLR"> peek() [istream] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int istream::peek();</TT>
<DT>Semantics:
<DD>The<TT> peek</TT> public member function looks up the next character to be extracted from the<TT> istream</TT> object, without
extracting the character.
<DT>Results:
<DD>The<TT> peek</TT> public member function returns the next character to be extracted from the<TT> istream</TT> object.&nbsp;
If the<TT> istream</TT> object is positioned at end-of-file,<TT> EOF</TT> is returned.
<DT>See Also:
<DD><TT> istream::get</TT>
</DL>
<H2 ID="istream__putbackLR"> putback() [istream] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>istream &amp;istream::putback( char ch );</TT>
<DT>Semantics:
<DD>The<TT> putback</TT> public member function attempts to put the extracted character specified by the<B> ch</B> parameter back
into the<TT> istream</TT> object.&nbsp; The<B> ch</B> character must be the same as the character before the current position
of the<TT> istream</TT> object, usually the last character extracted from the stream.&nbsp; If it is not the same character,
the result of the next character extraction is undefined.
<BR><BR>The number of characters that can be put back is defined by the<TT> istream</TT> object, but is usually at least 4.
&nbsp;Depending on the status of the buffers used for input, it may be possible to put back more than 4 characters.
<DT>Results:
<DD>The<TT> putback</TT> public member function returns a reference to the<TT> istream</TT> object.&nbsp; If the<TT> putback</TT>
public member function is unable to put back the<B> ch</B> parameter,<TT> ios::failbit</TT> is set in the error state in the
inherited<TT> ios</TT> object.
<DT>See Also:
<DD><TT> istream::get</TT>
</DL>
<H2 ID="istream__readLR"> read() [istream] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>istream &amp;istream::read( char *buf, int len );</TT>
<BR><TT> istream &amp;istream::read( signed char *buf, int len );</TT>
<BR><TT> istream &amp;istream::read( unsigned char *buf, int len );</TT>
<DT>Semantics:
<DD>The<TT> read</TT> public member function performs an unformatted read of at most<B> len</B> characters from the<TT> istream</TT>
object and stores them in the memory locations starting at<B> buf</B>.&nbsp; If end-of-file is encountered before<B> len</B>
characters have been transferred, the transfer stops and<TT> ios::failbit</TT> is set in the error state in the inherited<TT>
ios</TT> object.
<BR><BR>The number of characters extracted can be determined with the<TT> gcount</TT> member function.
<DT>Results:
<DD>The<TT> read</TT> public member function returns a reference to the<TT> istream</TT> object.&nbsp; If end-of-file is encountered
as the first character,<TT> ios::eofbit</TT> is set in the error state in the inherited<TT> ios</TT> object.&nbsp; If end-of-file
is encountered before<B> len</B> characters are transferred,<TT> ios::failbit</TT> is set in the error state in the inherited<TT>
ios</TT> object.
<DT>See Also:
<DD><TT> istream::gcount</TT>,<TT> get</TT>,<TT> getline</TT>
</DL>
<H2 ID="istream__seekgLR"> seekg() [istream] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>istream &amp;istream::seekg( streampos pos );</TT>
<DT>Semantics:
<DD>The<TT> seekg</TT> public member function positions the<TT> istream</TT> object to the position specified by the<B> pos</B>
parameter so that the next input operation commences from that position.
<DT>Results:
<DD>The<TT> seekg</TT> public member function returns a reference to the<TT> istream</TT> object.&nbsp; If the seek operation
fails,<TT> ios::failbit</TT> is set in the error state in the inherited<TT> ios</TT> object.
<DT>See Also:
<DD><TT> istream::tellg</TT>,<TT> ostream::tellp</TT>,<TT> ostream::seekp</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>istream &amp;istream::seekg( streamoff offset, ios::seekdir dir );</TT>
<DT>Semantics:
<DD>The<TT> seekg</TT> public member function positions the<TT> istream</TT> object to the specified position so that the next
input operation commences from that position.
<BR><BR>The<B> dir</B> parameter may be<TT> ios::beg</TT>,<TT> ios::cur</TT>, or<TT> ios::end</TT> and is interpreted in conjunction
with the<B> offset</B> parameter as follows:
<BR><BR><TT>ios::beg</TT>&nbsp; the <B>offset</B> is relative to the start and should be a positive value.
<BR><TT>ios::cur</TT>&nbsp; the <B>offset</B> is relative to the current position and may be positive
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (seek towards end) or negative (seek towards start).
<BR><TT>ios::end</TT>&nbsp; the <B>offset</B> is relative to the end and should be a negative value.
<BR><BR>If the<B> dir</B> parameter has any other value, or the<B> offset</B> parameter does not have an appropriate sign,
the<TT> seekg</TT> public member function fails.
<DT>Results:
<DD>The<TT> seekg</TT> public member function returns a reference to the<TT> istream</TT> object.&nbsp; If the seek operation
fails,<TT> ios::failbit</TT> is set in the error state in the inherited<TT> ios</TT> object.
<DT>See Also:
<DD><TT> ostream::tellp</TT>,<TT> ostream::seekp</TT>
<BR><BR><TT>istream::tellg</TT>
</DL>
<H2 ID="istream__syncLR"> sync() [istream] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int istream::sync();</TT>
<DT>Semantics:
<DD>The<TT> sync</TT> public member function synchronizes the input buffer and the<TT> istream</TT> object with whatever source
of characters is being used.&nbsp; The<TT> sync</TT> public member function uses the<TT> streambuf</TT> class's<TT> sync</TT>
virtual member function to carry out the synchronization.&nbsp; The specific behavior is dependent on what type of<TT> streambuf</TT>
derived object is associated with the<TT> istream</TT> object.
<DT>Results:
<DD>The<TT> sync</TT> public member function returns<TT> __NOT_EOF</TT> on success, otherwise<TT> EOF</TT> is returned.
</DL>
<H2 ID="istream__tellgLR"> tellg() [istream] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>streampos istream::tellg();</TT>
<DT>Semantics:
<DD>The<TT> tellg</TT> public member function determines the position in the<TT> istream</TT> object of the next character available
for reading.&nbsp; The first character in an<TT> istream</TT> object is at offset zero.
<DT>Results:
<DD>The<TT> tellg</TT> public member function returns the position of the next character available for reading.
<DT>See Also:
<DD><TT> ostream::tellp</TT>,<TT> ostream::seekp</TT>
<BR><BR><TT>istream::seekg</TT>
</DL>
<H2 ID="istrstream_Class_Description"> istrstream Class Description </H2>
<DL>
<DT>Declared:
<DD><TT> strstrea.h</TT>
<DT>Derived from:
<DD><TT> strstreambase</TT>,<TT> istream</TT>
<BR><BR>The<TT> istrstream</TT> class is used to create and read from string stream objects.
<BR>The<TT> istrstream</TT> class provides little of its own functionality.&nbsp; Derived from the<TT> strstreambase</TT>
and<TT> istream</TT> classes, its constructors and destructor provide simplified access to the appropriate equivalents in
those base classes.
<BR><BR>Of the available I/O stream classes, creating an<TT> istrstream</TT> object is the preferred method of performing
read operations from a string stream.
<BR><BR><B>Public Member Functions</B>
<BR><BR>The following member functions are declared in the public interface:
<BR><BR><TT>istrstream( char * );</TT>
<BR><TT> istrstream( signed char * );</TT>
<BR><TT> istrstream( unsigned char * );</TT>
<BR><TT> istrstream( char *, int );</TT>
<BR><TT> istrstream( signed char *, int );</TT>
<BR><TT> istrstream( unsigned char *, int );</TT>
<BR><TT> ~istrstream();</TT>
<DT>See Also:
<DD><TT> istream</TT>,<TT> ostrstream</TT>,<TT> strstream</TT>,<TT> strstreambase</TT>
</DL>
<H2 ID="istrstream__istrstreamLR"> istrstream() [istrstream] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;strstrea.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>istrstream::istrstream( char *str );</TT>
<BR><TT> istrstream::istrstream( signed char *str );</TT>
<BR><TT> istrstream::istrstream( unsigned char *str );</TT>
<DT>Semantics:
<DD>This form of the public<TT> istrstream</TT> constructor creates an<TT> istrstream</TT> object consisting of the null terminated
C string specified by the<B> str</B> parameter.&nbsp; The inherited<TT> istream</TT> member functions can be used to read
from the<TT> istrstream</TT> object.
<DT>Results:
<DD>This form of the public<TT> istrstream</TT> constructor creates an initialized<TT> istrstream</TT> object.
<DT>See Also:
<DD><TT> ~istrstream</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;strstrea.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>istrstream::istrstream( char *str, int len );</TT>
<BR><TT> istrstream::istrstream( signed char *str, int len );</TT>
<BR><TT> istrstream::istrstream( unsigned char *str, int len );</TT>
<DT>Semantics:
<DD>This form of the public<TT> istrstream</TT> constructor creates an<TT> istrstream</TT> object consisting of the characters
starting at<B> str</B> and ending at<B> str</B> +<B> len</B> - 1.&nbsp; The inherited<TT> istream</TT> member functions can
be used to read from the<TT> istrstream</TT> object.
<DT>Results:
<DD>This form of the public<TT> istrstream</TT> constructor creates an initialized<TT> istrstream</TT> object.
<DT>See Also:
<DD><TT> ~istrstream</TT>
</DL>
<H2 ID="istrstream____istrstreamLR"> ~istrstream() [istrstream] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;strstrea.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>istrstream::~istrstream();</TT>
<DT>Semantics:
<DD>The public<TT> ~istrstream</TT> destructor does not do anything explicit.&nbsp; The call to the public<TT> ~istrstream</TT>
destructor is inserted implicitly by the compiler at the point where the<TT> istrstream</TT> object goes out of scope.
<DT>Results:
<DD>The<TT> istrstream</TT> object is destroyed.
<DT>See Also:
<DD><TT> istrstream</TT>
</DL>
<H2 ID="Manipulators"> Manipulators [manipulator] </H2>
<DL>
<DT>Declared:
<DD><TT> iostream.h and iomanip.h</TT>
<BR><BR>Manipulators are designed to be inserted into or extracted from a stream.&nbsp; Manipulators come in two forms, non-parameterized
and parameterized.&nbsp; The non-parameterized manipulators are simpler and are declared in<TT> &lt;iostream.h&gt;</TT>.&nbsp;
The parameterized manipulators require more complexity and are declared in<TT> &lt;iomanip.h&gt;</TT>.
<BR><TT>&lt;iomanip.h&gt;</TT> defines two macros<TT> SMANIP_define</TT> and<TT> SMANIP_make</TT> to implement parameterized
manipulators.&nbsp; The workings of the<TT> SMANIP_define</TT> and<TT> SMANIP_make</TT> macros are disclosed in the header
file and are not discussed here.
<BR><BR><B>Non-parameterized Manipulators</B>
<BR><BR>The following non-parameterized manipulators are declared in<TT> &lt;iostream.h&gt;</TT>:
<BR><BR><TT>ios &amp;dec( ios &amp; );</TT>
<BR><TT>ios &amp;hex( ios &amp; );</TT>
<BR><TT>ios &amp;oct( ios &amp; );</TT>
<BR><TT>istream &amp;ws( istream &amp; );</TT>
<BR><TT>ostream &amp;endl( ostream &amp; );</TT>
<BR><TT>ostream &amp;ends( ostream &amp; );</TT>
<BR><TT>ostream &amp;flush( ostream &amp; );</TT>
<BR><BR><B>Parameterized Manipulators</B>
<BR><BR>The following parameterized manipulators are declared in<TT> &lt;iomanip.h&gt;</TT>:
<BR><BR><TT>SMANIP_define( long ) resetiosflags( long );</TT>
<BR><TT>SMANIP_define( int )&nbsp; setbase( int );</TT>
<BR><TT>SMANIP_define( int )&nbsp; setfill( int );</TT>
<BR><TT>SMANIP_define( long ) setiosflags( long );</TT>
<BR><TT>SMANIP_define( int )&nbsp; setprecision( int );</TT>
<BR><TT>SMANIP_define( int )&nbsp; setw( int );</TT>
<BR><TT>SMANIP_define( int )&nbsp; setwidth( int );</TT>
</DL>
<H2 ID="manipulator_decLR"> manipulator dec() [manipulator] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>ios &amp;dec( ios &amp;strm );</TT>
<DT>Semantics:
<DD>The<TT> dec</TT> manipulator sets the<TT> ios::basefield</TT> bits for decimal formatting in<TT> ios::fmtflags</TT> in the<B>
strm</B><TT> ios</TT> object.
<DT>See Also:
<DD><TT> ios::fmtflags</TT>
</DL>
<H2 ID="manipulator_endlLR"> manipulator endl() [manipulator] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>ostream &amp;endl( ostream &amp;ostrm );</TT>
<DT>Semantics:
<DD>The<TT> endl</TT> manipulator writes a new-line character to the stream specified by the<B> ostrm</B> parameter and performs
a flush.
<DT>See Also:
<DD><TT> ostream::flush</TT>
</DL>
<H2 ID="manipulator_endsLR"> manipulator ends() [manipulator] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>ostream &amp;ends( ostream &amp;ostrm );</TT>
<DT>Semantics:
<DD>The<TT> ends</TT> manipulator writes a null character to the stream specified by the<B> ostrm</B> parameter.
</DL>
<H2 ID="manipulator_flushLR"> manipulator flush() [manipulator] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>ostream &amp;flush( ostream &amp;ostrm );</TT>
<DT>Semantics:
<DD>The<TT> flush</TT> manipulator flushes the stream specified by the<B> ostrm</B> parameter.&nbsp; The flush is performed in
the same manner as the<TT> flush</TT> member function.
<DT>See Also:
<DD><TT> ostream::flush</TT>
</DL>
<H2 ID="manipulator_hexLR"> manipulator hex() [manipulator] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>ios &amp;hex( ios &amp;strm );</TT>
<DT>Semantics:
<DD>The<TT> hex</TT> manipulator sets the<TT> ios::basefield</TT> bits for hexadecimal formatting in<TT> ios::fmtflags</TT> in
the<B> strm</B><TT> ios</TT> object.
<DT>See Also:
<DD><TT> ios::fmtflags</TT>
</DL>
<H2 ID="manipulator_octLR"> manipulator oct() [manipulator] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>ios &amp;oct( ios &amp;strm );</TT>
<DT>Semantics:
<DD>The<TT> oct</TT> manipulator sets the<TT> ios::basefield</TT> bits for octal formatting in<TT> ios::fmtflags</TT> in the<B>
strm</B><TT> ios</TT> object.
<DT>See Also:
<DD><TT> ios::fmtflags</TT>
</DL>
<H2 ID="manipulator_resetiosflagsLR"> manipulator resetiosflags() [manipulator] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iomanip.h&gt;</TT>
<BR><TT>SMANIP_define( long ) resetiosflags( long flags )</TT>
<DT>Semantics:
<DD>The<TT> resetiosflags</TT> manipulator turns off the bits in<TT> ios::fmtflags</TT> that correspond to the bits that are on
in the<B> flags</B> parameter.&nbsp; No other bits are affected.
<DT>See Also:
<DD><TT> ios::flags</TT>,<TT> ios::fmtflags</TT>,<TT> ios::setf</TT>,<TT> ios::unsetf</TT>
</DL>
<H2 ID="manipulator_setbaseLR"> manipulator setbase() [manipulator] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iomanip.h&gt;</TT>
<BR><TT>SMANIP_define( int ) setbase( int base );</TT>
<DT>Semantics:
<DD>The<TT> setbase</TT> manipulator sets the<TT> ios::basefield</TT> bits in<TT> ios::fmtflags</TT> to the value specified by
the<B> base</B> parameter within the stream that the<TT> setbase</TT> manipulator is operating upon.
<DT>See Also:
<DD><TT> ios::fmtflags</TT>
</DL>
<H2 ID="manipulator_setfillLR"> manipulator setfill() [manipulator] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iomanip.h&gt;</TT>
<BR><TT>SMANIP_define( int ) setfill( int fill )</TT>
<DT>Semantics:
<DD>The<TT> setfill</TT> manipulator sets the<B> fill character</B> to the value specified by the<B> fill</B> parameter within
the stream that the<TT> setfill</TT> manipulator is operating upon.
<DT>See Also:
<DD><TT> ios::fill</TT>
</DL>
<H2 ID="manipulator_setiosflagsLR"> manipulator setiosflags() [manipulator] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iomanip.h&gt;</TT>
<BR><TT>SMANIP_define( long ) setiosflags( long flags );</TT>
<DT>Semantics:
<DD>The<TT> setiosflags</TT> manipulator turns on the bits in<TT> ios::fmtflags</TT> that correspond to the bits that are on in
the<B> flags</B> parameter.&nbsp; No other bits are affected.
<DT>See Also:
<DD><TT> ios::flags</TT>,<TT> ios::fmtflags</TT>,<TT> ios::setf</TT>,<TT> ios::unsetf</TT>
</DL>
<H2 ID="manipulator_setprecisionLR"> manipulator setprecision() [manipulator] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iomanip.h&gt;</TT>
<BR><TT>SMANIP_define( int ) setprecision( int prec );</TT>
<DT>Semantics:
<DD>The<TT> setprecision</TT> manipulator sets the<B> format precision</B> to the value specified by the<B> prec</B> parameter
within the stream that the<TT> setprecision</TT> manipulator is operating upon.
<DT>See Also:
<DD><TT> ios::precision</TT>
</DL>
<H2 ID="manipulator_setwLR"> manipulator setw() [manipulator] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iomanip.h&gt;</TT>
<BR><TT>SMANIP_define( int ) setw( int wid );</TT>
<DT>Semantics:
<DD>The<TT> setw</TT> manipulator sets the<B> format width</B> to the value specified by the<B> wid</B> parameter within the stream
that the<TT> setw</TT> manipulator is operating upon.
<DT>See Also:
<DD><TT> ios::width</TT>, manipulator<TT> setwidth</TT>
</DL>
<H2 ID="manipulator_setwidthLR"> manipulator setwidth() [manipulator] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iomanip.h&gt;</TT>
<BR><TT>SMANIP_define( int ) setwidth( int wid );</TT>
<DT>Semantics:
<DD>The<TT> setwidth</TT> manipulator sets the<B> format width</B> to the value specified by the<B> wid</B> parameter within the
stream that the<TT> setwidth</TT> manipulator is operating upon.
<BR><BR>This function is a WATCOM extension.
<DT>See Also:
<DD><TT> ios::width</TT>, manipulator<TT> setw</TT>
</DL>
<H2 ID="manipulator_wsLR"> manipulator ws() [manipulator] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>istream &amp;ws( istream &amp;istrm );</TT>
<DT>Semantics:
<DD>The<TT> ws</TT> manipulator extracts and discards whitespace characters from the<B> istrm</B> parameter, leaving the stream
positioned at the next non-whitespace character.
<BR><BR>The<TT> ws</TT> manipulator is needed particularly when the<TT> ios::skipws</TT> bit is not set in<TT> ios::fmtflags</TT>
in the<B> istrm</B> object.&nbsp; In this case, whitespace characters must be explicitly removed from the stream, since the
formatted input operations will not automatically remove them.
<DT>See Also:
<DD><TT> istream::eatwhite</TT>,<TT> istream::ignore</TT>
</DL>
<H2 ID="ofstream_Class_Description"> ofstream Class Description </H2>
<DL>
<DT>Declared:
<DD><TT> fstream.h</TT>
<DT>Derived from:
<DD><TT> fstreambase</TT>,<TT> ostream</TT>
<BR><BR>The<TT> ofstream</TT> class is used to create new files or access existing files for writing.&nbsp; The file can be
opened and closed, and write and seek operations can be performed.
<BR>The<TT> ofstream</TT> class provides very little of its own functionality.&nbsp; Derived from both the<TT> fstreambase</TT>
and<TT> ostream</TT> classes, its constructors, destructor and member function provide simplified access to the appropriate
equivalents in those base classes.
<BR><BR>Of the available I/O stream classes, creating an<TT> ofstream</TT> object is the preferred method of accessing a file
for output operations.
<BR><BR><B>Public Member Functions</B>
<BR><BR>The following public member functions are declared:
<BR><BR><TT>ofstream();</TT>
<BR><TT> ofstream( char const *,</TT>
<BR><TT> ios::openmode = ios::out,</TT>
<BR><TT>int = filebuf::openprot );</TT>
<BR><TT>ofstream( filedesc );</TT>
<BR><TT> ofstream( filedesc, char *, int );</TT>
<BR><TT> ~ofstream();</TT>
<BR><TT> void open( char const *,</TT>
<BR><TT> ios::openmode = ios::out,</TT>
<BR><TT>int = filebuf::openprot );</TT>
<DT>See Also:
<DD><TT> fstream</TT>,<TT> fstreambase</TT>,<TT> ifstream</TT>,<TT> ostream</TT>
</DL>
<H2 ID="ofstream__ofstreamLR"> ofstream() [ofstream] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;fstream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>ofstream::ofstream();</TT>
<DT>Semantics:
<DD>This form of the public<TT> ofstream</TT> constructor creates an<TT> ofstream</TT> object that is not connected to a file.
&nbsp;The<TT> open</TT> or<TT> attach</TT> member functions should be used to connect the<TT> ofstream</TT> object to a file.
<DT>Results:
<DD>The public<TT> ofstream</TT> constructor produces an<TT> ofstream</TT> object that is not connected to a file.
<DT>See Also:
<DD><TT> ~ofstream</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;fstream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>ofstream::ofstream( const char *name,</TT>
<BR><TT> ios::openmode mode = ios::out,</TT>
<BR><TT>int prot = filebuf::openprot );</TT>
<DT>Semantics:
<DD>This form of the public<TT> ofstream</TT> constructor creates an<TT> ofstream</TT> object that is connected to the file specified
by the<B> name</B> parameter, using the specified<B> mode</B> and<B> prot</B> parameters.&nbsp; The connection is made via
the C library<TT> open</TT> function.
<DT>Results:
<DD>The public<TT> ofstream</TT> constructor produces an<TT> ofstream</TT> object that is connected to the file specified by<B>
name</B>.&nbsp; If the<TT> open</TT> fails,<TT> ios::failbit</TT> and<TT> ios::badbit</TT> are set in the error state in the
inherited<TT> ios</TT> object.
<DT>See Also:
<DD><TT> ~ofstream</TT>,<TT> open</TT>,<TT> fstreambase::close</TT>,<TT> openmode</TT>,<TT> openprot</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;fstream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>ofstream::ofstream( filedesc hdl );</TT>
<DT>Semantics:
<DD>This form of the public<TT> ofstream</TT> constructor creates an<TT> ofstream</TT> object that is attached to the file specified
by the<B> hdl</B> parameter.
<DT>Results:
<DD>The public<TT> ofstream</TT> constructor produces an<TT> ofstream</TT> object that is attached to<B> hdl</B>.&nbsp; If the
attach fails,<TT> ios::failbit</TT> and<TT> ios::badbit</TT> are set in the error state in the inherited<TT> ios</TT> object.
<DT>See Also:
<DD><TT> ~ofstream</TT>,<TT> fstreambase::attach</TT>,<TT> fstreambase::fd</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;fstream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>ofstream::ofstream( filedesc hdl, char *buf, int len );</TT>
<DT>Semantics:
<DD>This form of the public<TT> ofstream</TT> constructor creates an<TT> ofstream</TT> object that is connected to the file specified
by the<B> hdl</B> parameter.&nbsp; The buffer specified by the<B> buf</B> and<B> len</B> parameters is offered to the associated<TT>
filebuf</TT> object via the<TT> setbuf</TT> member function.&nbsp; If the<B> buf</B> parameter is<TT> NULL</TT> or the<B>
len</B> is less than or equal to zero, the<TT> filebuf</TT> is unbuffered, so that each read or write operation reads or writes
a single character at a time.
<DT>Results:
<DD>The public<TT> ofstream</TT> constructor produces an<TT> ofstream</TT> object that is attached to<B> hdl</B>.&nbsp; If the
connection to<B> hdl</B> fails,<TT> ios::failbit</TT> and<TT> ios::badbit</TT> are set in the error state in the inherited<TT>
ios</TT> object.&nbsp; If the<TT> setbuf</TT> fails,<TT> ios::failbit</TT> is set in the error state in the inherited<TT>
ios</TT> object.
<DT>See Also:
<DD><TT> ~ofstream</TT>,<TT> fstreambase::attach</TT>,<TT> fstreambase::fd</TT>,<TT> fstreambase::setbuf</TT>
</DL>
<H2 ID="ofstream____ofstreamLR"> ~ofstream() [ofstream] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;fstream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>ofstream::~ofstream();</TT>
<DT>Semantics:
<DD>The public<TT> ~ofstream</TT> destructor does not do anything explicit.&nbsp; The call to the public<TT> ~ofstream</TT> destructor
is inserted implicitly by the compiler at the point where the<TT> ofstream</TT> object goes out of scope.
<DT>Results:
<DD>The public<TT> ~ofstream</TT> destructor destroys the<TT> ofstream</TT> object.
<DT>See Also:
<DD><TT> ofstream</TT>
</DL>
<H2 ID="ofstream__openLR"> open() [ofstream] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;fstream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void ofstream::open( const char *name,</TT>
<BR><TT> ios::openmode mode = ios::out,</TT>
<BR><TT>int prot = filebuf::openprot );</TT>
<DT>Semantics:
<DD>The<TT> open</TT> public member function connects the<TT> ofstream</TT> object to the file specified by the<B> name</B> parameter,
using the specified<B> mode</B> and<B> prot</B> parameters.&nbsp; The<TT> mode</TT> parameter is optional and usually is not
specified unless additional bits (such as<TT> ios::binary</TT> or<TT> ios::text</TT>) are to be specified.&nbsp; The connection
is made via the C library<TT> open</TT> function.
<DT>Results:
<DD>If the open fails,<TT> ios::failbit</TT> is set in the error state in the inherited<TT> ios</TT> object.
<DT>See Also:
<DD><TT> ofstream</TT>,<TT> openmode</TT>,<TT> openprot</TT>,<TT> fstreambase::attach</TT>,<TT> fstreambase::close</TT>,<TT> fstreambase::fd</TT>,<TT>
fstreambase::is_open</TT>
</DL>
<H2 ID="ostream_Class_Description"> ostream Class Description </H2>
<DL>
<DT>Declared:
<DD><TT> iostream.h</TT>
<DT>Derived from:
<DD><TT> ios</TT>
<DT>Derived by:
<DD><TT> iostream</TT>,<TT> ofstream</TT>,<TT> ostrstream</TT>
<BR><BR>The<TT> ostream</TT> class supports writing characters to a class derived from the<TT> streambuf</TT> class, and provides
formatted conversion of types (such as integers and floating-point numbers) into characters.&nbsp; The class derived from
the<TT> streambuf</TT> class provides the methods for communicating with the external device (screen, disk), while the<TT>
ostream</TT> class provides the conversion of the types into characters.
<BR>Generally,<TT> ostream</TT> objects won't be explicitly created by a program, since there is no mechanism at this level
to open a device.&nbsp; The only default<TT> ostream</TT> objects in a program are<TT> cout</TT>,<TT> cerr</TT>, and<TT> clog</TT>
which write to the standard output and error devices (usually the screen).
<BR><BR>The<TT> ostream</TT> class supports two basic concepts of output:&nbsp; formatted and unformatted.&nbsp; The overloaded<TT>
operator &lt;&lt;</TT> member functions are called<B> inserters</B> and they provide the support for formatted output.&nbsp;
The rest of the member functions deal with unformatted output, managing the state of the<TT> ios</TT> object and providing
a friendlier interface to the associated<TT> streambuf</TT> object.
<BR><BR><B>Protected Member Functions</B>
<BR><BR>The following protected member functions are declared:
<BR><BR><TT>ostream();</TT>
<BR><BR><B>Public Member Functions</B>
<BR><BR>The following public member functions are declared:
<BR><BR><TT>ostream( ostream const &amp; );</TT>
<BR><TT> ostream( streambuf * );</TT>
<BR><TT> virtual ~ostream();</TT>
<BR><TT> ostream &amp;flush();</TT>
<BR><TT> int opfx();</TT>
<BR><TT> void osfx();</TT>
<BR><TT> ostream &amp;put( char );</TT>
<BR><TT> ostream &amp;put( signed char );</TT>
<BR><TT> ostream &amp;put( unsigned char );</TT>
<BR><TT> ostream &amp;seekp( streampos );</TT>
<BR><TT> ostream &amp;seekp( streamoff, ios::seekdir );</TT>
<BR><TT> streampos tellp();</TT>
<BR><TT> ostream &amp;write( char const *, int );</TT>
<BR><TT> ostream &amp;write( signed char const *, int );</TT>
<BR><TT> ostream &amp;write( unsigned char const *, int );</TT>
<BR><BR><B>Public Member Operators</B>
<BR><BR>The following public member operators are declared:
<BR><BR><TT>ostream &amp;operator =( streambuf * );</TT>
<BR><TT> ostream &amp;operator =( ostream const &amp; );</TT>
<BR><TT> ostream &amp;operator &lt;&lt;( char );</TT>
<BR><TT> ostream &amp;operator &lt;&lt;( signed char );</TT>
<BR><TT> ostream &amp;operator &lt;&lt;( unsigned char );</TT>
<BR><TT> ostream &amp;operator &lt;&lt;( signed short );</TT>
<BR><TT> ostream &amp;operator &lt;&lt;( unsigned short );</TT>
<BR><TT> ostream &amp;operator &lt;&lt;( signed int );</TT>
<BR><TT> ostream &amp;operator &lt;&lt;( unsigned int );</TT>
<BR><TT> ostream &amp;operator &lt;&lt;( signed long );</TT>
<BR><TT> ostream &amp;operator &lt;&lt;( unsigned long );</TT>
<BR><TT> ostream &amp;operator &lt;&lt;( float );</TT>
<BR><TT> ostream &amp;operator &lt;&lt;( double );</TT>
<BR><TT> ostream &amp;operator &lt;&lt;( long double );</TT>
<BR><TT> ostream &amp;operator &lt;&lt;( void * );</TT>
<BR><TT> ostream &amp;operator &lt;&lt;( streambuf &amp; );</TT>
<BR><TT> ostream &amp;operator &lt;&lt;( char const * );</TT>
<BR><TT> ostream &amp;operator &lt;&lt;( signed char const * );</TT>
<BR><TT> ostream &amp;operator &lt;&lt;( unsigned char const * );</TT>
<BR><TT> ostream &amp;operator &lt;&lt;( ostream &amp;(*)( ostream &amp; ) );</TT>
<BR><TT> ostream &amp;operator &lt;&lt;( ios &amp;(*)( ios &amp; ) );</TT>
<DT>See Also:
<DD><TT> ios</TT>,<TT> iostream</TT>,<TT> istream</TT>
</DL>
<H2 ID="ostream__flushLR"> flush() [ostream] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>ostream &amp;ostream::flush();</TT>
<DT>Semantics:
<DD>The<TT> flush</TT> public member function causes the<TT> ostream</TT> object's buffers to be flushed, forcing the contents
to be written to the actual device connected to the<TT> ostream</TT> object.
<DT>Results:
<DD>The<TT> flush</TT> public member function returns a reference to the<TT> ostream</TT> object.&nbsp; On failure,<TT> ios::failbit</TT>
is set in the error state in the inherited<TT> ios</TT> object.
<DT>See Also:
<DD><TT> ostream::osfx</TT>
</DL>
<H2 ID="ostream__operator_XXLR"> operator &lt;&lt;() [ostream] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>ostream &amp;ostream::operator &lt;&lt;( char ch );</TT>
<BR><TT> ostream &amp;ostream::operator &lt;&lt;( signed char ch );</TT>
<BR><TT> ostream &amp;ostream::operator &lt;&lt;( unsigned char ch );</TT>
<DT>Semantics:
<DD>These forms of the<TT> operator &lt;&lt;</TT> public member function write the<B> ch</B> character into the<TT> ostream</TT>
object.
<DT>Results:
<DD>These forms of the<TT> operator &lt;&lt;</TT> public member function return a reference to the<TT> ostream</TT> object so
that further insertion operations may be specified in the same statement.<TT>&nbsp; ios::failbit</TT> is set in the error
state in the inherited<TT> ios</TT> object if an error occurs.
<DT>See Also:
<DD><TT> ostream::put</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>ostream &amp;ostream::operator &lt;&lt;( char const *str );</TT>
<BR><TT> ostream &amp;ostream::operator &lt;&lt;( signed char const *str );</TT>
<BR><TT> ostream &amp;ostream::operator &lt;&lt;( unsigned char const *str );</TT>
<DT>Semantics:
<DD>These forms of the<TT> operator &lt;&lt;</TT> public member function perform a formatted write of the contents of the C string
specified by the<B> str</B> parameter to the<TT> ostream</TT> object.&nbsp; The characters from<B> str</B> are transferred
up to, but not including the terminating null character.
<DT>Results:
<DD>These forms of the<TT> operator &lt;&lt;</TT> public member function return a reference to the<TT> ostream</TT> object so
that further insertion operations may be specified in the same statement.<TT>&nbsp; ios::failbit</TT> is set in the error
state in the inherited<TT> ios</TT> object if an error occurs.
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>ostream &amp;ostream::operator &lt;&lt;( signed int num );</TT>
<BR><TT> ostream &amp;ostream::operator &lt;&lt;( unsigned int num );</TT>
<BR><TT> ostream &amp;ostream::operator &lt;&lt;( signed long num );</TT>
<BR><TT> ostream &amp;ostream::operator &lt;&lt;( unsigned long num );</TT>
<BR><TT> ostream &amp;ostream::operator &lt;&lt;( signed short num );</TT>
<BR><TT> ostream &amp;ostream::operator &lt;&lt;( unsigned short num );</TT>
<DT>Semantics:
<DD>These forms of the<TT> operator &lt;&lt;</TT> public member function perform a formatted write of the integral value specified
by the<B> num</B> parameter to the<TT> ostream</TT> object.&nbsp; The integer value is converted to a string of characters
which are written to the<TT> ostream</TT> object.<B>&nbsp; num</B> is converted to a base representation depending on the
setting of the<TT> ios::basefield</TT> bits in<TT> ios::fmtflags</TT>.&nbsp; If the<TT> ios::oct</TT> bit is the only bit
on, the conversion is to an octal (base 8) representation.&nbsp; If the<TT> ios::hex</TT> bit is the only bit on, the conversion
is to a hexadecimal (base 16) representation.&nbsp; Otherwise, the conversion is to a decimal (base 10) representation.
<BR><BR>For decimal conversions only, a sign may be written in front of the number.&nbsp; If the number is negative, a<TT>
-</TT> minus sign is written.&nbsp; If the number is positive and the<TT> ios::showpos</TT> bit is on in<TT> ios::fmtflags</TT>,
a<TT> +</TT> plus sign is written.&nbsp; No sign is written for a value of zero.
<BR><BR>If the<TT> ios::showbase</TT> bit is on in<TT> ios::fmtflags</TT>, and the conversion is to octal or hexadecimal,
the base indicator is written next.&nbsp; The base indicator for a conversion to octal is a zero.&nbsp; The base indicator
for a conversion to hexadecimal is<TT> 0x</TT> or<TT> 0X</TT>, depending on the setting of the<TT> ios::uppercase</TT> bit
in<TT> ios::fmtflags</TT>.
<BR><BR>If the value being written is zero, the conversion is to octal, and the<TT> ios::showbase</TT> bit is on, nothing
further is written since a single zero is sufficient.
<BR><BR>The value of<B> num</B> is then converted to characters.&nbsp; For conversions to decimal, the magnitude of the number
is converted to a string of decimal digits<TT> 0123456789</TT>.&nbsp; For conversions to octal, the number is treated as an
unsigned quantity and converted to a string of octal digits<TT> 01234567</TT>.&nbsp; For conversions to hexadecimal, the number
is treated as an unsigned quantity and converted to a string of hexadecimal digits<TT> 0123456789</TT> and the letters<TT>
abcdef</TT> or<TT> ABCDEF</TT>, depending on the setting of the<TT> ios::uppercase</TT> in<TT> ios::fmtflags</TT>.&nbsp; The
string resulting from the conversion is then written to the<TT> ostream</TT> object.
<BR><BR>If the<TT> ios::internal</TT> bit is set in<TT> ios::fmtflags</TT> and padding is required, the padding characters
are written after the sign and/or base indicator (if present) and before the digits.
<DT>Results:
<DD>These forms of the<TT> operator &lt;&lt;</TT> public member function return a reference to the<TT> ostream</TT> object so
that further insertion operations may be specified in the same statement.<TT>&nbsp; ios::failbit</TT> is set in the error
state in the inherited<TT> ios</TT> object if an error occurs.
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>ostream &amp;ostream::operator &lt;&lt;( float num );</TT>
<BR><TT> ostream &amp;ostream::operator &lt;&lt;( double num );</TT>
<BR><TT> ostream &amp;ostream::operator &lt;&lt;( long double num );</TT>
<DT>Semantics:
<DD>These forms of the<TT> operator &lt;&lt;</TT> public member function perform a formatted write of the floating-point value
specified by the<B> num</B> parameter to the<TT> ostream</TT> object.&nbsp; The number is converted to either scientific (exponential)
form or fixed-point form, depending on the setting of the<TT> ios::floatfield</TT> bits in<TT> ios::fmtflags</TT>.&nbsp; If<TT>
ios::scientific</TT> is the only bit set, the conversion is to scientific form.&nbsp; If<TT> ios::fixed</TT> is the only bit
set, the conversion is to fixed-point form.&nbsp; Otherwise (neither or both bits set), the value of the number determines
the conversion used.&nbsp; If the exponent is less than -4 or is greater than or equal to the<B> format precision</B>, the
scientific form is used.&nbsp; Otherwise, the fixed-point form is used.
<BR><BR>Scientific form consists of a minus sign (for negative numbers), one digit, a decimal point,<B> format precision</B>-1
digits, an<TT> e</TT> or<TT> E</TT> (depending on the setting of the<TT> ios::uppercase</TT> bit), a minus sign (for negative
exponents) or a plus sign (for zero or positive exponents), and two or three digits for the exponent.&nbsp; The digit before
the decimal is not zero, unless the number is zero.&nbsp; If the<B> format precision</B> is zero (or one), no digits are written
following the decimal point.
<BR><BR>Fixed-point form consists of a minus sign (for negative numbers), one or more digits, a decimal point, and<B> format
precision</B> digits.
<BR><BR>If the<TT> ios::showpoint</TT> bit is not set in<TT> ios::fmtflags</TT>, trailing zeroes are trimmed after the decimal
point (and before the exponent for scientific form), and if no digits remain after the decimal point, the decimal point is
discarded as well.
<BR><BR>If the<TT> ios::internal</TT> bit is set in<TT> ios::fmtflags</TT> and padding is required, the padding characters
are written after the sign (if present) and before the digits.
<DT>Results:
<DD>These forms of the<TT> operator &lt;&lt;</TT> public member function return a reference to the<TT> ostream</TT> object so
that further insertion operations may be specified in the same statement.<TT>&nbsp; ios::failbit</TT> is set in the error
state in the inherited<TT> ios</TT> object if an error occurs.
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>ostream &amp;ostream::operator &lt;&lt;( void *ptr );</TT>
<DT>Semantics:
<DD>This form of the<TT> operator &lt;&lt;</TT> public member function performs a formatted write of the pointer value specified
by the<B> ptr</B> parameter to the<TT> ostream</TT> object.&nbsp; The<B> ptr</B> parameter is converted to an implementation-defined
string of characters and written to the<TT> ostream</TT> object.&nbsp; With the Open Watcom C++ implementation, the string
starts with<TT> 0x</TT> or<TT> 0X</TT> (depending on the setting of the<TT> ios::uppercase</TT> bit), followed by 4 hexadecimal
digits for 16-bit pointers and 8 hexadecimal digits for 32-bit pointers.&nbsp; Leading zeroes are added to ensure the correct
number of digits are written.&nbsp; For far pointers, 4 additional hexadecimal digits and a colon are inserted immediately
after the<TT> 0x</TT> prefix.
<DT>Results:
<DD>This form of the<TT> operator &lt;&lt;</TT> public member function returns a reference to the<TT> ostream</TT> object so that
further insertion operations may be specified in the same statement.<TT>&nbsp; ios::failbit</TT> is set in the error state
in the inherited<TT> ios</TT> object if an error occurs during the write.
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>ostream &amp;ostream::operator &lt;&lt;( streambuf &amp;sb );</TT>
<DT>Semantics:
<DD>This form of the<TT> operator &lt;&lt;</TT> public member function transfers the contents of the<B> sb</B><TT> streambuf</TT>
object to the<TT> ostream</TT> object.&nbsp; Reading from the<TT> streambuf</TT> object stops when the read fails.&nbsp; No
padding with the<B> fill character</B> takes place on output to the<TT> ostream</TT> object.
<DT>Results:
<DD>This form of the<TT> operator &lt;&lt;</TT> public member function returns a reference to the<TT> ostream</TT> object so that
further insertion operations may be specified in the same statement.<TT>&nbsp; ios::failbit</TT> is set in the error state
in the inherited<TT> ios</TT> object if an error occurs.
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>ostream &amp;ostream::operator &lt;&lt;( ostream &amp;(*fn)( ostream &amp;) );</TT>
<BR><TT> ostream &amp;ostream::operator &lt;&lt;( ios &amp;(*fn)( ios &amp; ) );</TT>
<DT>Semantics:
<DD>These forms of the<TT> operator &lt;&lt;</TT> public member function are used to implement the non-parameterized manipulators
for the<TT> ostream</TT> class.&nbsp; The function specified by the<B> fn</B> parameter is called with the<TT> ostream</TT>
object as its parameter.
<DT>Results:
<DD>These forms of the<TT> operator &lt;&lt;</TT> public member function return a reference to the<TT> ostream</TT> object so
that further insertions operations may be specified in the same statement.
</DL>
<H2 ID="ostream__operator_ELR"> operator =() [ostream] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>ostream &amp;ostream::operator =( streambuf *sb );</TT>
<DT>Semantics:
<DD>This form of the<TT> operator =</TT> public member function is used to associate a<TT> streambuf</TT> object, specified by
the<B> sb</B> parameter, with an existing<TT> ostream</TT> object.&nbsp; The<TT> ostream</TT> object is initialized and will
use the specified<TT> streambuf</TT> object for subsequent operations.
<DT>Results:
<DD>This form of the<TT> operator =</TT> public member function returns a reference to the<TT> ostream</TT> object that is the
target of the assignment.&nbsp; If the<B> sb</B> parameter is<TT> NULL</TT>,<TT> ios::badbit</TT> is set in the error state
in the inherited<TT> ios</TT> object.
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>ostream &amp;ostream::operator =( const ostream &amp;ostrm );</TT>
<DT>Semantics:
<DD>This form of the<TT> operator =</TT> public member function is used to associate the<TT> ostream</TT> object with the<TT>
streambuf</TT> object currently associated with the<B> ostrm</B> parameter.&nbsp; The<TT> ostream</TT> object is initialized
and will use the<B> ostrm</B>'s<TT> streambuf</TT> object for subsequent operations.&nbsp; The<B> ostrm</B> object will continue
to use the<TT> streambuf</TT> object.
<DT>Results:
<DD>This form of the<TT> operator =</TT> public member function returns a reference to the<TT> ostream</TT> object that is the
target of the assignment.&nbsp; If there is no<TT> streambuf</TT> object currently associated with the<B> ostrm</B> parameter,<TT>
ios::badbit</TT> is set in the error state in the inherited<TT> ios</TT> object.
</DL>
<H2 ID="ostream__opfxLR"> opfx() [ostream] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int ostream::opfx();</TT>
<DT>Semantics:
<DD>If<TT> opfx</TT> public member function is a prefix function executed before each of the formatted and unformatted output
operations.&nbsp; If any bits are set in<TT> ios::iostate</TT>, the<TT> opfx</TT> public member function immediately returns
zero, indicating that the prefix function failed.&nbsp; Failure in the prefix function causes the output operation to fail.
<BR><BR>If the<TT> ostream</TT> object is tied to another<TT> ostream</TT> object, the other<TT> ostream</TT> object is flushed.
<DT>Results:
<DD>The<TT> opfx</TT> public member function returns a non-zero value on success, otherwise zero is returned.
<DT>See Also:
<DD><TT> ostream::osfx</TT>,<TT> flush</TT>,<TT> ios::tie</TT>
</DL>
<H2 ID="ostream__osfxLR"> osfx() [ostream] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void ostream::osfx();</TT>
<DT>Semantics:
<DD>The<TT> osfx</TT> public member function is a suffix function executed at the end of each of the formatted and unformatted
output operations.
<BR><BR>If the<TT> ios::unitbuf</TT> bit is set in<TT> ios::fmtflags</TT>, the<TT> flush</TT> member function is called.&nbsp;
If the<TT> ios::stdio</TT> bit is set in<TT> ios::fmtflags</TT>, the C library<TT> fflush</TT> function is invoked on the<TT>
stdout</TT> and<TT> stderr</TT> file streams.
<DT>See Also:
<DD><TT> ostream::osfx</TT>,<TT> flush</TT>
</DL>
<H2 ID="ostream__ostreamLR"> ostream() [ostream] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>protected:</TT>
<BR><TT>ostream::ostream();</TT>
<DT>Semantics:
<DD>This form of the protected<TT> ostream</TT> constructor creates an<TT> ostream</TT> object without an attached<TT> streambuf</TT>
object.
<BR><BR>This form of the protected<TT> ostream</TT> constructor is only used implicitly by the compiler when it generates
a constructor for a derived class.
<DT>Results:
<DD>This form of the protected<TT> ostream</TT> constructor creates an initialized<TT> ostream</TT> object.<TT>&nbsp; ios::badbit</TT>
is set in the error state in the inherited<TT> ios</TT> object.
<DT>See Also:
<DD><TT> ~ostream</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>ostream::ostream( ostream const &amp;ostrm );</TT>
<DT>Semantics:
<DD>This form of the public<TT> ostream</TT> constructor creates an<TT> ostream</TT> object associated with the<TT> streambuf</TT>
object currently associated with the<B> ostrm</B> parameter.&nbsp; The<TT> ostream</TT> object is initialized and will use
the<B> ostrm</B>'s<TT> streambuf</TT> object for subsequent operations.&nbsp; The<B> ostrm</B> object will continue to use
the<TT> streambuf</TT> object.
<DT>Results:
<DD>This form of the public<TT> ostream</TT> constructor creates an initialized<TT> ostream</TT> object.&nbsp; If there is no<TT>
streambuf</TT> object currently associated with the<B> ostrm</B> parameter,<TT> ios::badbit</TT> is set in the error state
in the inherited<TT> ios</TT> object.
<DT>See Also:
<DD><TT> ~ostream</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>ostream::ostream( streambuf *sb );</TT>
<DT>Semantics:
<DD>This form of the public<TT> ostream</TT> constructor creates an<TT> ostream</TT> object with an associated<TT> streambuf</TT>
object specified by the<B> sb</B> parameter.
<BR><BR>This function is likely to be used for the creation of an<TT> ostream</TT> object that is associated with the same<TT>
streambuf</TT> object as another<TT> ostream</TT> object.
<DT>Results:
<DD>This form of the public<TT> ostream</TT> constructor creates an initialized<TT> ostream</TT> object.&nbsp; If the<B> sb</B>
parameter is<TT> NULL</TT>,<TT> ios::badbit</TT> is set in the error state in the inherited<TT> ios</TT> object.
<DT>See Also:
<DD><TT> ~ostream</TT>
</DL>
<H2 ID="ostream____ostreamLR"> ~ostream() [ostream] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>virtual ostream::~ostream();</TT>
<DT>Semantics:
<DD>The public virtual<TT> ~ostream</TT> destructor does not do anything explicit.&nbsp; The<TT> ios</TT> destructor is called
for that portion of the<TT> ostream</TT> object.&nbsp; The call to the public virtual<TT> ~ostream</TT> destructor is inserted
implicitly by the compiler at the point where the<TT> ostream</TT> object goes out of scope.
<DT>Results:
<DD>The<TT> ostream</TT> object is destroyed.
<DT>See Also:
<DD><TT> ostream</TT>
</DL>
<H2 ID="ostream__putLR"> put() [ostream] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>ostream &amp;ostream::put( char ch );</TT>
<BR><TT> ostream &amp;ostream::put( signed char ch );</TT>
<BR><TT> ostream &amp;ostream::put( unsigned char ch );</TT>
<DT>Semantics:
<DD>These forms of the<TT> put</TT> public member function write the<B> ch</B> character to the<TT> ostream</TT> object.
<DT>Results:
<DD>These forms of the<TT> put</TT> public member function return a reference to the<TT> ostream</TT> object.&nbsp; If an error
occurs,<TT> ios::failbit</TT> is set in the error state in the inherited<TT> ios</TT> object.
<DT>See Also:
<DD><TT> ostream::operator &lt;&lt;</TT>,<TT> write</TT>
</DL>
<H2 ID="ostream__seekpLR"> seekp() [ostream] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>ostream &amp;ostream::seekp( streampos pos );</TT>
<DT>Semantics:
<DD>This from of the<TT> seekp</TT> public member function positions the<TT> ostream</TT> object to the position specified by
the<B> pos</B> parameter so that the next output operation commences from that position.
<BR><BR>The<B> pos</B> value is an absolute position within the stream.&nbsp; It may be obtained via a call to the<TT> tellp</TT>
member function.
<DT>Results:
<DD>This from of the<TT> seekp</TT> public member function returns a reference to the<TT> ostream</TT> object.&nbsp; If the seek
operation fails,<TT> ios::failbit</TT> is set in the error state in the inherited<TT> ios</TT> object.
<DT>See Also:
<DD><TT> ostream::tellp</TT>,<TT> istream::tellg</TT>,<TT> istream::seekg</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>ostream &amp;ostream::seekp( streamoff offset, ios::seekdir dir );</TT>
<DT>Semantics:
<DD>This from of the<TT> seekp</TT> public member function positions the<TT> ostream</TT> object to the specified position so
that the next output operation commences from that position.
<BR><BR>The<B> dir</B> parameter may be<TT> ios::beg</TT>,<TT> ios::cur</TT>, or<TT> ios::end</TT> and is interpreted in conjunction
with the<B> offset</B> parameter as follows:
<BR><BR><TT>ios::beg</TT>&nbsp; the <B>offset</B> is relative to the start and should be a positive value.
<BR><TT>ios::cur</TT>&nbsp; the <B>offset</B> is relative to the current position and may be positive
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (seek towards end) or negative (seek towards start).
<BR><TT>ios::end</TT>&nbsp; the <B>offset</B> is relative to the end and should be a negative value.
<BR><BR>If the<B> dir</B> parameter has any other value, or the<B> offset</B> parameter does not have an appropriate sign,
the<TT> seekp</TT> public member function fails.
<DT>Results:
<DD>This from of the<TT> seekp</TT> public member function returns a reference to the<TT> ostream</TT> object.&nbsp; If the seek
operation fails,<TT> ios::failbit</TT> is set in the error state in the inherited<TT> ios</TT> object.
<DT>See Also:
<DD><TT> ostream::tellp</TT>,<TT> istream::tellg</TT>,<TT> istream::seekg</TT>
</DL>
<H2 ID="ostream__tellpLR"> tellp() [ostream] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>streampos ostream::tellp();</TT>
<DT>Semantics:
<DD>The<TT> tellp</TT> public member function returns the position in the<TT> ostream</TT> object at which the next character
will be written.&nbsp; The first character in an<TT> ostream</TT> object is at offset zero.
<DT>Results:
<DD>The<TT> tellp</TT> public member function returns the position in the<TT> ostream</TT> object at which the next character
will be written.
<DT>See Also:
<DD><TT> ostream::seekp</TT>,<TT> istream::tellg</TT>,<TT> istream::seekg</TT>
</DL>
<H2 ID="ostream__writeLR"> write() [ostream] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;iostream.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>ostream &amp;ostream::write( char const *buf, int len );</TT>
<BR><TT> ostream &amp;ostream::write( signed char const *buf, int len );</TT>
<BR><TT> ostream &amp;ostream::write( unsigned char const *buf, int len );</TT>
<DT>Semantics:
<DD>The<TT> write</TT> public member function performs an unformatted write of the characters specified by the<B> buf</B> and<B>
len</B> parameters into the<TT> ostream</TT> object.
<DT>Results:
<DD>These member functions return a reference to the<TT> ostream</TT> object.&nbsp; If an error occurs,<TT> ios::failbit</TT>
is set in the error state in the inherited<TT> ios</TT> object.
</DL>
<H2 ID="ostrstream_Class_Description"> ostrstream Class Description </H2>
<DL>
<DT>Declared:
<DD><TT> strstrea.h</TT>
<DT>Derived from:
<DD><TT> strstreambase</TT>,<TT> ostream</TT>
<BR><BR>The<TT> ostrstream</TT> class is used to create and write to string stream objects.
<BR>The<TT> ostrstream</TT> class provides little of its own functionality.&nbsp; Derived from the<TT> strstreambase</TT>
and<TT> ostream</TT> classes, its constructors and destructor provide simplified access to the appropriate equivalents in
those base classes.&nbsp; The member functions provide specialized access to the string stream object.
<BR><BR>Of the available I/O stream classes, creating an<TT> ostrstream</TT> object is the preferred method of performing
write operations to a string stream.
<BR><BR><B>Public Member Functions</B>
<BR><BR>The following member functions are declared in the public interface:
<BR><BR><TT>ostrstream();</TT>
<BR><TT> ostrstream( char *, int, ios::openmode = ios::out );</TT>
<BR><TT> ostrstream( signed char *, int, ios::openmode = ios::out );</TT>
<BR><TT> ostrstream( unsigned char *, int, ios::openmode = ios::out );</TT>
<BR><TT> ~ostrstream();</TT>
<BR><TT> int pcount() const;</TT>
<BR><TT> char *str();</TT>
<DT>See Also:
<DD><TT> istrstream</TT>,<TT> ostream</TT>,<TT> ostrstream</TT>,<TT> strstreambase</TT>
</DL>
<H2 ID="ostrstream__ostrstreamLR"> ostrstream() [ostrstream] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;strstrea.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>ostrstream::ostrstream();</TT>
<DT>Semantics:
<DD>This form of the public<TT> ostrstream</TT> constructor creates an empty<TT> ostrstream</TT> object.&nbsp; Dynamic allocation
is used.&nbsp; The inherited stream member functions can be used to access the<TT> ostrstream</TT> object.
<DT>Results:
<DD>This form of the public<TT> ostrstream</TT> constructor creates an initialized, empty<TT> ostrstream</TT> object.
<DT>See Also:
<DD><TT> ~ostrstream</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;strstrea.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>ostrstream::ostrstream( char *str,</TT>
<BR><TT> int len,</TT>
<BR><TT>ios::openmode mode = ios::out );</TT>
<BR><TT>ostrstream::ostrstream( signed char *str,</TT>
<BR><TT> int len,</TT>
<BR><TT>ios::openmode mode = ios::out );</TT>
<BR><TT>ostrstream::ostrstream( unsigned char *str,</TT>
<BR><TT> int len,</TT>
<BR><TT>ios::openmode mode = ios::out );</TT>
<DT>Semantics:
<DD>These forms of the public<TT> ostrstream</TT> constructor create an initialized<TT> ostrstream</TT> object.&nbsp; Dynamic
allocation is not used.&nbsp; The buffer is specified by the<B> str</B> and<B> len</B> parameters.&nbsp; If the<TT> ios::append</TT>
or<TT> ios::atend</TT> bits are set in the<B> mode</B> parameter, the<B> str</B> parameter is assumed to contain a C string
terminated by a null character, and writing commences at the null character.&nbsp; Otherwise, writing commences at<B> str</B>.
<DT>Results:
<DD>This form of the public<TT> ostrstream</TT> constructor creates an initialized<TT> ostrstream</TT> object.
<DT>See Also:
<DD><TT> ~ostrstream</TT>
</DL>
<H2 ID="ostrstream____ostrstreamLR"> ~ostrstream() [ostrstream] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;strstrea.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>ostrstream::~ostrstream();</TT>
<DT>Semantics:
<DD>The public<TT> ~ostrstream</TT> destructor does not do anything explicit.&nbsp; The call to the public<TT> ~ostrstream</TT>
destructor is inserted implicitly by the compiler at the point where the<TT> ostrstream</TT> object goes out of scope.
<DT>Results:
<DD>The<TT> ostrstream</TT> object is destroyed.
<DT>See Also:
<DD><TT> ostrstream</TT>
</DL>
<H2 ID="ostrstream__pcountLR"> pcount() [ostrstream] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;strstrea.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int ostrstream::pcount() const;</TT>
<DT>Semantics:
<DD>The<TT> pcount</TT> public member function computes the number of characters that have been written to the<TT> ostrstream</TT>
object.&nbsp; This value is particularly useful if the<TT> ostrstream</TT> object does not contain a C string (terminated
by a null character), so that the number of characters cannot be determined with the C library<TT> strlen</TT> function.&nbsp;
If the<TT> ostrstream</TT> object was created by appending to a C string in a static buffer, the length of the original string
is included in the character count.
<DT>Results:
<DD>The<TT> pcount</TT> public member function returns the number of characters contained in the<TT> ostrstream</TT> object.
</DL>
<H2 ID="ostrstream__strLR"> str() [ostrstream] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;strstrea.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>char *ostrstream::str();</TT>
<DT>Semantics:
<DD>The<TT> str</TT> public member function creates a pointer to the buffer being used by the<TT> ostrstream</TT> object.&nbsp;
If the<TT> ostrstream</TT> object was created without dynamic allocation (static mode), the pointer is the same as the buffer
pointer passed in the constructor.
<BR><BR>For<TT> ostrstream</TT> objects using dynamic allocation, the<TT> str</TT> public member function makes an implicit
call to the<TT> strstreambuf::freeze</TT> member function.&nbsp; If nothing has been written to the<TT> ostrstream</TT> object,
the returned pointer will be<TT> NULL</TT>.
<BR><BR>Note that the buffer does not necessarily end with a null character.&nbsp; If the pointer returned by the<TT> str</TT>
public member function is to be interpreted as a C string, it is the program's responsibility to ensure that the null character
is present.
<DT>Results:
<DD>The<TT> str</TT> public member function returns a pointer to the buffer being used by the<TT> ostrstream</TT> object.
</DL>
<H2 ID="stdiobuf_Class_Description"> stdiobuf Class Description </H2>
<DL>
<DT>Declared:
<DD><TT> stdiobuf.h</TT>
<DT>Derived from:
<DD><TT> streambuf</TT>
<BR><BR>The<TT> stdiobuf</TT> class specializes the<TT> streambuf</TT> class and is used to implement the standard input/output
buffering required for the<TT> cin</TT>,<TT> cout</TT>,<TT> cerr</TT> and<TT> clog</TT> predefined objects.
<BR>The<TT> stdiobuf</TT> class behaves in a similar way to the<TT> filebuf</TT> class, but does not need to switch between
the<B> get area</B> and<B> put area</B>, since no<TT> stdiobuf</TT> object can be created for both reading and writing.&nbsp;
When the<B> get area</B> is empty and a read is done, the<TT> underflow</TT> virtual member function reads more characters
and fills the<B> get area</B> again.&nbsp; When the<B> put area</B> is full and a write is done, the<TT> overflow</TT> virtual
member function writes the characters and makes the<B> put area</B> empty again.
<BR><BR>C++ programmers who wish to use the standard input/output streams without deriving new objects do not need to explicitly
create or use a<TT> stdiobuf</TT> object.
<BR><BR><B>Public Member Functions</B>
<BR><BR>The following member functions are declared in the public interface:
<BR><BR><TT>stdiobuf();</TT>
<BR><TT> stdiobuf( FILE * );</TT>
<BR><TT> ~stdiobuf();</TT>
<BR><TT> virtual int overflow( int = EOF );</TT>
<BR><TT> virtual int underflow();</TT>
<BR><TT> virtual int sync();</TT>
<DT>See Also:
<DD><TT> streambuf</TT>,<TT> ios</TT>
</DL>
<H2 ID="stdiobuf__overflowLR"> overflow() [stdiobuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdiobuf.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>virtual int stdiobuf::overflow( int ch = EOF );</TT>
<DT>Semantics:
<DD>The<TT> overflow</TT> public virtual member function provides the output communication to the standard output and standard
error devices to which the<TT> stdiobuf</TT> object is connected.&nbsp; Member functions in the<TT> streambuf</TT> class call
the<TT> overflow</TT> public virtual member function for the derived class when the<B> put area</B> is full.
<BR><BR>The<TT> overflow</TT> public virtual member function performs the following steps:
<OL>
<LI>If no buffer is present, a buffer is allocated with the<TT> streambuf::allocate</TT> member function, which may call the<TT>
doallocate</TT> virtual member function.&nbsp; The<B> put area</B> is then set up.&nbsp; If, after calling<TT> streambuf::allocate</TT>,
no buffer is present, the<TT> stdiobuf</TT> object is unbuffered and<B> ch</B> (if not<TT> EOF</TT>) is written directly to
the file without buffering, and no further action is taken.
<LI>If the<B> get area</B> is present, it is flushed with a call to the<TT> sync</TT> virtual member function.&nbsp; Note
that the<B> get area</B> won't be present if a buffer was set up in step 1.
<LI>If<B> ch</B> is not<TT> EOF</TT>, it is added to the<B> put area</B>, if possible.
<LI>Any characters in the<B> put area</B> are written to the file.
<LI>The<B> put area</B> pointers are updated to reflect the new state of the<B> put area</B>.&nbsp; If the write did not complete,
the unwritten portion of the<B> put area</B> is still present.&nbsp; If the<B> put area</B> was full before the write,<B>
ch</B> (if not<TT> EOF</TT>) is placed at the start of the<B> put area</B>.&nbsp; Otherwise, the<B> put area</B> is empty.
</OL>
<DT>Results:
<DD>The<TT> overflow</TT> public virtual member function returns<TT> __NOT_EOF</TT> on success, otherwise<TT> EOF</TT> is returned.
<DT>See Also:
<DD><TT> stdiobuf::underflow</TT>,<TT> streambuf::overflow</TT>
</DL>
<H2 ID="stdiobuf__stdiobufLR"> stdiobuf() [stdiobuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdiobuf.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>stdiobuf::stdiobuf();</TT>
<DT>Semantics:
<DD>This form of the public<TT> stdiobuf</TT> constructor creates a<TT> stdiobuf</TT> object that is initialized but not yet connected
to a file.
<DT>Results:
<DD>This form of the public<TT> stdiobuf</TT> constructor creates a<TT> stdiobuf</TT> object.
<DT>See Also:
<DD><TT> ~stdiobuf</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdiobuf.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>stdiobuf::stdiobuf( FILE *fptr );</TT>
<DT>Semantics:
<DD>This form of the public<TT> stdiobuf</TT> constructor creates a<TT> stdiobuf</TT> object that is initialized and connected
to a C library FILE stream.&nbsp; Usually, one of<TT> stdin</TT>,<TT> stdout</TT> or<TT> stderr</TT> is specified for the<B>
fptr</B> parameter.
<DT>Results:
<DD>This form of the public<TT> stdiobuf</TT> constructor creates a<TT> stdiobuf</TT> object that is initialized and connected
to a C library FILE stream.
<DT>See Also:
<DD><TT> ~stdiobuf</TT>
</DL>
<H2 ID="stdiobuf____stdiobufLR"> ~stdiobuf() [stdiobuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdiobuf.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>stdiobuf::~stdiobuf();</TT>
<DT>Semantics:
<DD>The public<TT> ~stdiobuf</TT> destructor does not do anything explicit.&nbsp; The<TT> streambuf</TT> destructor is called
for that portion of the<TT> stdiobuf</TT> object.&nbsp; The call to the public<TT> ~stdiobuf</TT> destructor is inserted implicitly
by the compiler at the point where the<TT> stdiobuf</TT> object goes out of scope.
<DT>Results:
<DD>The<TT> stdiobuf</TT> object is destroyed.
<DT>See Also:
<DD><TT> stdiobuf</TT>
</DL>
<H2 ID="stdiobuf__syncLR"> sync() [stdiobuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdiobuf.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>virtual int stdiobuf::sync();</TT>
<DT>Semantics:
<DD>The<TT> sync</TT> public virtual member function synchronizes the<TT> stdiobuf</TT> object with the associated device.&nbsp;
If the<B> put area</B> contains characters, it is flushed.&nbsp; If the<B> get area</B> contains buffered characters, the<TT>
sync</TT> public virtual member function fails.
<DT>Results:
<DD>The<TT> sync</TT> public virtual member function returns<TT> __NOT_EOF</TT> on success, otherwise,<TT> EOF</TT> is returned.
<DT>See Also:
<DD><TT> streambuf::sync</TT>
</DL>
<H2 ID="stdiobuf__underflowLR"> underflow() [stdiobuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdiobuf.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>virtual int stdiobuf::underflow();</TT>
<DT>Semantics:
<DD>The<TT> underflow</TT> public virtual member function provides the input communication from the standard input device to which
the<TT> stdiobuf</TT> object is connected.&nbsp; Member functions in the<TT> streambuf</TT> class call the<TT> underflow</TT>
public virtual member function for the derived class when the<B> get area</B> is empty.
<BR><BR>The<TT> underflow</TT> public virtual member function performs the following steps:
<OL>
<LI>If no<B> reserve area</B> is present, a buffer is allocated with the<TT> streambuf::allocate</TT> member function, which
may call the<TT> doallocate</TT> virtual member function.&nbsp; If, after calling<TT> allocate</TT>, no<B> reserve area</B>
is present, the<TT> stdiobuf</TT> object is unbuffered and a one-character<B> reserve area</B> (plus putback area) is set
up to do unbuffered input.&nbsp; This buffer is embedded in the<TT> stdiobuf</TT> object.&nbsp; The<B> get area</B> is set
up as empty.
<LI>The unused part of the<B> get area</B> is used to read characters from the file connected to the<TT> stdiobuf</TT> object.
&nbsp;The<B> get area</B> pointers are then set up to reflect the new<B> get area</B>.
</OL>
<DT>Results:
<DD>The<TT> underflow</TT> public virtual member function returns the first unread character of the<B> get area</B>, on success,
otherwise<TT> EOF</TT> is returned.&nbsp; Note that the<B> get pointer</B> is not advanced on success.
<DT>See Also:
<DD><TT> stdiobuf::overflow</TT>,<TT> streambuf::underflow</TT>
</DL>
<H2 ID="streambuf_Class_Description"> streambuf Class Description </H2>
<DL>
<DT>Declared:
<DD><TT> streambu.h</TT>
<DT>Derived by:
<DD><TT> filebuf</TT>,<TT> stdiobuf</TT>,<TT> strstreambuf</TT>
<BR><BR>The<TT> streambuf</TT> class is responsible for maintaining the buffer used to create an efficient implementation
of the stream classes.&nbsp; Through its pure virtual functions, it is also responsible for the actual communication with
the device associated with the stream.
<BR>The<TT> streambuf</TT> class is abstract, due to the presence of pure virtual member functions.&nbsp; Abstract classes
may not be instantiated, only inherited.&nbsp; Hence,<TT> streambuf</TT> objects will not be created by user programs.
<BR><BR>Stream objects maintain a pointer to an associated<TT> streambuf</TT> object and present the interface that the user
deals with most often.&nbsp; Whenever a stream member function wishes to read or write characters, it uses the<TT> rdbuf</TT>
member function to access the associated<TT> streambuf</TT> object and its member functions.&nbsp; Through judicious use of
inline functions, most reads and writes of characters access the buffer directly without even doing a function call.&nbsp;
Whenever the buffer gets filled (writing) or exhausted (reading), these inline functions invoke the function required to rectify
the situation so that the proper action can take place.
<BR><BR>A<TT> streambuf</TT> object can be unbuffered, but most often has one buffer which can be used for both input and
output operations.&nbsp; The buffer (called the<B> reserve area</B>) is divided into two areas, called the<B> get area</B>
and the<B> put area</B>.&nbsp; For a<TT> streambuf</TT> object being used exclusively to write, the<B> get area</B> is empty
or not present.&nbsp; Likewise, a<TT> streambuf</TT> object being used exclusively for reading has an empty or non-existent<B>
put area</B>.
<BR><BR>The use of the<B> get area</B> and<B> put area</B> differs among the various classes derived from the<TT> streambuf</TT>
class.
<BR><BR>The<TT> filebuf</TT> class allows only the<B> get area</B> or the<B> put area</B>, but not both, to be active at a
time.&nbsp; This follows from the capability of files opened for both reading and writing to have operations of each type
performed at arbitrary locations in the file.&nbsp; When writing is occurring, the characters are buffered in the<B> put area</B>.
&nbsp;If a seek or read operation is done, the<B> put area</B> must be flushed before the next operation in order to ensure
that the characters are written to the proper location in the file.&nbsp; Similarly, if reading is occurring, characters are
buffered in the<B> get area</B>.&nbsp; If a write operation is done, the<B> get area</B> must be flushed and synchronized
before the write operation in order to ensure the write occurs at the proper location in the file.&nbsp; If a seek operation
is done, the<B> get area</B> does not have to be synchronized, but is discarded.&nbsp; When the<B> get area</B> is empty and
a read is done, the<TT> underflow</TT> virtual member function reads more characters and fills the<B> get area</B> again.
&nbsp;When the<B> put area</B> is full and a write is done, the<TT> overflow</TT> virtual member function writes the characters
and makes the<B> put area</B> empty again.
<BR><BR>The<TT> stdiobuf</TT> class behaves in a similar way to the<TT> filebuf</TT> class, but does not need to switch between
the<B> get area</B> and<B> put area</B>, since no<TT> stdiobuf</TT> object can be created for both reading and writing.&nbsp;
When the<B> get area</B> is empty and a read is done, the<TT> underflow</TT> virtual member function reads more characters
and fills the<B> get area</B> again.&nbsp; When the<B> put area</B> is full and a write is done, the<TT> overflow</TT> virtual
member function writes the characters and makes the<B> put area</B> empty again.
<BR><BR>The<TT> strstreambuf</TT> class differs quite markedly from the<TT> filebuf</TT> and<TT> stdiobuf</TT> classes.&nbsp;
Since there is no actual source or destination for the characters in<TT> strstream</TT> objects, the buffer itself takes on
that role.&nbsp; When writing is occurring and the<B> put area</B> is full, the<TT> overflow</TT> virtual member function
reallocates the buffer to a larger size (if possible), the<B> put area</B> is extended and the writing continues.&nbsp; If
reading is occurring and the<B> get area</B> is empty, the<TT> underflow</TT> virtual member function checks to see if the<B>
put area</B> is present and not empty.&nbsp; If so, the<B> get area</B> is extended to overlap the<B> put area</B>.
<BR><BR>The<B> reserve area</B> is marked by two pointer values.&nbsp; The<TT> base</TT> member function returns the pointer
to the start of the buffer.&nbsp; The<TT> ebuf</TT> member function returns the pointer to the end of the buffer (last character
+ 1).&nbsp; The<TT> setb</TT> protected member function is used to set both pointers.
<BR><BR>Within the<B> reserve area</B>, the<B> get area</B> is marked by three pointer values.&nbsp; The<TT> eback</TT> member
function returns a pointer to the start of the<B> get area</B>.&nbsp; The<TT> egptr</TT> member function returns a pointer
to the end of the<B> get area</B> (last character + 1).&nbsp; The<TT> gptr</TT> member function returns the<B> get pointer</B>.
&nbsp;The<B> get pointer</B> is a pointer to the next character to be extracted from the<B> get area</B>.&nbsp; Characters
before the<B> get pointer</B> have already been consumed by the program, while characters at and after the<B> get pointer</B>
have been read from their source and are buffered and waiting to be read by the program.&nbsp; The<TT> setg</TT> member function
is used to set all three pointer values.&nbsp; If any of these pointers are<TT> NULL</TT>, there is no<B> get area</B>.
<BR><BR>Also within the<B> reserve area</B>, the<B> put area</B> is marked by three pointer values.&nbsp; The<TT> pbase</TT>
member function returns a pointer to the start of the<B> put area</B>.&nbsp; The<TT> epptr</TT> member function returns a
pointer to the end of the<B> put area</B> (last character + 1 ).&nbsp; The<TT> pptr</TT> member function returns the<B> put
pointer</B>.&nbsp; The<B> put pointer</B> is a pointer to the next available position into which a character may be stored.
&nbsp;Characters before the<B> put pointer</B> are buffered and waiting to be written to their final destination, while character
positions at and after the<B> put pointer</B> have yet to be written by the program.&nbsp; The<TT> setp</TT> member function
is used to set all three pointer values.&nbsp; If any of these pointers are<TT> NULL</TT>, there is no<B> put area</B>.
<BR><BR>Unbuffered I/O is also possible.&nbsp; If unbuffered, the<TT> overflow</TT> virtual member function is used to write
single characters directly to their final destination without using the<B> put area</B>.&nbsp; Similarly, the<TT> underflow</TT>
virtual member function is used to read single characters directly from their source without using the<B> get area</B>.
<BR><BR><B>Protected Member Functions</B>
<BR><BR>The following member functions are declared in the protected interface:
<BR><BR><TT>streambuf();</TT>
<BR><TT> streambuf( char *, int );</TT>
<BR><TT> virtual ~streambuf();</TT>
<BR><TT> int allocate();</TT>
<BR><TT> char *base() const;</TT>
<BR><TT> char *ebuf() const;</TT>
<BR><TT> int blen() const;</TT>
<BR><TT> void setb( char *, char *, int );</TT>
<BR><TT> char *eback() const;</TT>
<BR><TT> char *gptr() const;</TT>
<BR><TT> char *egptr() const;</TT>
<BR><TT> void gbump( streamoff );</TT>
<BR><TT> void setg( char *, char *, char *);</TT>
<BR><TT> char *pbase() const;</TT>
<BR><TT> char *pptr() const;</TT>
<BR><TT> char *epptr() const;</TT>
<BR><TT> void pbump( streamoff );</TT>
<BR><TT> void setp( char *, char *);</TT>
<BR><TT> int unbuffered( int );</TT>
<BR><TT> int unbuffered() const;</TT>
<BR><TT> virtual int doallocate();</TT>
<BR><BR><B>Public Member Functions</B>
<BR><BR>The following member functions are declared in the public interface:
<BR><BR><TT>int in_avail() const;</TT>
<BR><TT> int out_waiting() const;</TT>
<BR><TT> int snextc();</TT>
<BR><TT> int sgetn( char *, int );</TT>
<BR><TT> int speekc();</TT>
<BR><TT> int sgetc();</TT>
<BR><TT> int sgetchar();</TT>
<BR><TT> int sbumpc();</TT>
<BR><TT> void stossc();</TT>
<BR><TT> int sputbackc( char );</TT>
<BR><TT> int sputc( int );</TT>
<BR><TT> int sputn( char const *, int );</TT>
<BR><TT> void dbp();</TT>
<BR><BR><TT>virtual int do_sgetn( char *, int );</TT>
<BR><TT> virtual int do_sputn( char const *, int );</TT>
<BR><TT> virtual int pbackfail( int );</TT>
<BR><TT> virtual int overflow( int = EOF ) = 0;</TT>
<BR><TT> virtual int underflow() = 0;</TT>
<BR><TT> virtual streambuf *setbuf( char *, int );</TT>
<BR><TT> virtual streampos seekoff( streamoff, ios::seekdir,</TT>
<BR><TT> ios::openmode = ios::in|ios::out );</TT>
<BR><TT>virtual streampos seekpos( streampos,</TT>
<BR><TT> ios::openmode = ios::in|ios::out );</TT>
<BR><TT>virtual int sync();</TT>
<DT>See Also:
<DD><TT> filebuf</TT>,<TT> stdiobuf</TT>,<TT> strstreambuf</TT>
</DL>
<H2 ID="streambuf__allocateLR"> allocate() [streambuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;streambu.h&gt;</TT>
<BR><TT>protected:</TT>
<BR><TT>int streambuf::allocate();</TT>
<DT>Semantics:
<DD>The<TT> allocate</TT> protected member function works in tandem with the<TT> doallocate</TT> protected virtual member function
to manage allocation of the<TT> streambuf</TT> object<B> reserve area</B>.&nbsp; Classes derived from the<TT> streambuf</TT>
class should call the<TT> allocate</TT> protected member function, rather than the<TT> doallocate</TT> protected virtual member
function.&nbsp; The<TT> allocate</TT> protected member function determines whether or not the<TT> streambuf</TT> object is
allowed to allocate a buffer for use as the<B> reserve area</B>.&nbsp; If a<B> reserve area</B> already exists or if the<TT>
streambuf</TT> object unbuffering state is non-zero, the<TT> allocate</TT> protected member function fails.&nbsp; Otherwise,
it calls the<TT> doallocate</TT> protected virtual member function.
<DT>Results:
<DD>The<TT> allocate</TT> protected member function returns<TT> __NOT_EOF</TT> on success, otherwise<TT> EOF</TT> is returned.
<DT>See Also:
<DD><TT> streambuf::doallocate</TT>,<TT> underflow</TT>,<TT> overflow</TT>
</DL>
<H2 ID="streambuf__baseLR"> base() [streambuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;streambu.h&gt;</TT>
<BR><TT>protected:</TT>
<BR><TT>char *streambuf::base() const;</TT>
<DT>Semantics:
<DD>The<TT> base</TT> protected member function returns a pointer to the start of the<B> reserve area</B> that the<TT> streambuf</TT>
object is using.
<BR><BR>The<B> reserve area</B>,<B> get area</B>, and<B> put area</B> pointer functions return the following values:
<BR><BR><TT>base()</TT>&nbsp;&nbsp;&nbsp; start of the <B>reserve area</B>.
<BR><TT>ebuf()</TT>&nbsp;&nbsp;&nbsp; end of the <B>reserve area</B>.
<BR><TT>blen()</TT>&nbsp;&nbsp;&nbsp; length of the <B>reserve area</B>.
<BR><BR><TT>eback()</TT>&nbsp;&nbsp; start of the <B>get area</B>.
<BR><TT>gptr()</TT>&nbsp;&nbsp;&nbsp; the <B>get pointer</B>.
<BR><TT>egptr()</TT>&nbsp;&nbsp; end of the <B>get area</B>.
<BR><BR><TT>pbase()</TT>&nbsp;&nbsp; start of the <B>put area</B>.
<BR><TT>pptr()</TT>&nbsp;&nbsp;&nbsp; the <B>put pointer</B>.
<BR><TT>epptr()</TT>&nbsp;&nbsp; end of the <B>put area</B>.
<BR><BR>From<TT> eback</TT> to<TT> gptr</TT> are characters buffered and read.&nbsp; From<TT> gptr</TT> to<TT> egptr</TT>
are characters buffered but not yet read.&nbsp; From<TT> pbase</TT> to<TT> pptr</TT> are characters buffered and not yet written.
&nbsp;From<TT> pptr</TT> to<TT> epptr</TT> is unused buffer area.
<DT>Results:
<DD>The<TT> base</TT> protected member function returns a pointer to the start of the<B> reserve area</B> that the<TT> streambuf</TT>
object is using.&nbsp; If the<TT> streambuf</TT> object currently does not have a<B> reserve area</B>,<TT> NULL</TT> is returned.
<DT>See Also:
<DD><TT> streambuf::blen</TT>,<TT> ebuf</TT>,<TT> setb</TT>
</DL>
<H2 ID="streambuf__blenLR"> blen() [streambuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;streambu.h&gt;</TT>
<BR><TT>protected:</TT>
<BR><TT>int streambuf::blen() const;</TT>
<DT>Semantics:
<DD>The<TT> blen</TT> protected member function reports the length of the<B> reserve area</B> that the<TT> streambuf</TT> object
is using.
<BR><BR>The<B> reserve area</B>,<B> get area</B>, and<B> put area</B> pointer functions return the following values:
<BR><BR><TT>base()</TT>&nbsp;&nbsp;&nbsp; start of the <B>reserve area</B>.
<BR><TT>ebuf()</TT>&nbsp;&nbsp;&nbsp; end of the <B>reserve area</B>.
<BR><TT>blen()</TT>&nbsp;&nbsp;&nbsp; length of the <B>reserve area</B>.
<BR><BR><TT>eback()</TT>&nbsp;&nbsp; start of the <B>get area</B>.
<BR><TT>gptr()</TT>&nbsp;&nbsp;&nbsp; the <B>get pointer</B>.
<BR><TT>egptr()</TT>&nbsp;&nbsp; end of the <B>get area</B>.
<BR><BR><TT>pbase()</TT>&nbsp;&nbsp; start of the <B>put area</B>.
<BR><TT>pptr()</TT>&nbsp;&nbsp;&nbsp; the <B>put pointer</B>.
<BR><TT>epptr()</TT>&nbsp;&nbsp; end of the <B>put area</B>.
<BR><BR>From<TT> eback</TT> to<TT> gptr</TT> are characters buffered and read.&nbsp; From<TT> gptr</TT> to<TT> egptr</TT>
are characters buffered but not yet read.&nbsp; From<TT> pbase</TT> to<TT> pptr</TT> are characters buffered and not yet written.
&nbsp;From<TT> pptr</TT> to<TT> epptr</TT> is unused buffer area.
<DT>Results:
<DD>The<TT> blen</TT> protected member function returns the length of the<B> reserve area</B> that the<TT> streambuf</TT> object
is using.&nbsp; If the<TT> streambuf</TT> object currently does not have a<B> reserve area</B>, zero is returned.
<DT>See Also:
<DD><TT> streambuf::base</TT>,<TT> ebuf</TT>,<TT> setb</TT>
</DL>
<H2 ID="streambuf__dbpLR"> dbp() [streambuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;streambu.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void streambuf::dbp();</TT>
<DT>Semantics:
<DD>The<TT> dbp</TT> public member function dumps information about the<TT> streambuf</TT> object directly to<TT> stdout</TT>,
and is used for debugging classes derived from the<TT> streambuf</TT> class.
<BR><BR>The following is an example of what the<TT> dbp</TT> public member function dumps:
</DL>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; STREAMBUF Debug Info:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; this&nbsp; = 00030679, unbuffered = 0, delete_reserve = 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; base&nbsp; = 00070010, ebuf = 00070094</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; eback = 00000000, gptr = 00000000, egptr = 00000000</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; pbase = 00070010, pptr = 00070010, epptr = 00070094</TT>
<H2 ID="streambuf__do_sgetnLR"> do_sgetn() [streambuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;streambu.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>virtual int do_sgetn( char *buf, int len );</TT>
<DT>Semantics:
<DD>The<TT> do_sgetn</TT> public virtual member function works in tandem with the<TT> sgetn</TT> member function to transfer<B>
len</B> characters from the<B> get area</B> into<B> buf</B>.
<BR><BR>Classes derived from the<TT> streambuf</TT> class should call the<TT> sgetn</TT> member function, rather than the<TT>
do_sgetn</TT> public virtual member function.
<DT>Derived Implementation Protocol:
<DD>Classes derived from the<TT> streambuf</TT> class that implement the<TT> do_sgetn</TT> public virtual member function should
support copying up to<B> len</B> characters from the source through the<B> get area</B> and into<B> buf</B>.
<DT>Default Implementation:
<DD>The default<TT> do_sgetn</TT> public virtual member function provided with the<TT> streambuf</TT> class calls the<TT> underflow</TT>
virtual member function to fetch more characters and then copies the characters from the<B> get area</B> into<B> buf</B>.
<DT>Results:
<DD>The<TT> do_sgetn</TT> public virtual member function returns the number of characters successfully transferred.
<DT>See Also:
<DD><TT> streambuf::sgetn</TT>
</DL>
<H2 ID="streambuf__do_sputnLR"> do_sputn() [streambuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;streambu.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>virtual int do_sputn( char const *buf, int len );</TT>
<DT>Semantics:
<DD>The<TT> do_sputn</TT> public virtual member function works in tandem with the<TT> sputn</TT> member function to transfer<B>
len</B> characters from<B> buf</B> to the end of the<B> put area</B> and advances the<B> put pointer</B>.
<BR><BR>Classes derived from the<TT> streambuf</TT> class should call the<TT> sputn</TT> member function, rather than the<TT>
do_sputn</TT> public virtual member function.
<DT>Derived Implementation Protocol:
<DD>Classes derived from the<TT> streambuf</TT> class that implement the<TT> do_sputn</TT> public virtual member function should
support copying up to<B> len</B> characters from<B> buf</B> through the<B> put area</B> and out to the destination device.
<DT>Default Implementation:
<DD>The default<TT> do_sputn</TT> public virtual member function provided with the<TT> streambuf</TT> class calls the<TT> overflow</TT>
virtual member function to flush the<B> put area</B> and then copies the rest of the characters from<B> buf</B> into the<B>
put area</B>.
<DT>Results:
<DD>The<TT> do_sputn</TT> public virtual member function returns the number of characters successfully written.&nbsp; If an error
occurs, this number may be less than<B> len</B>.
<DT>See Also:
<DD><TT> streambuf::sputn</TT>
</DL>
<H2 ID="streambuf__doallocateLR"> doallocate() [streambuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;streambu.h&gt;</TT>
<BR><TT>protected:</TT>
<BR><TT>virtual int streambuf::doallocate();</TT>
<DT>Semantics:
<DD>The<TT> doallocate</TT> protected virtual member function manages allocation of the<TT> streambuf</TT> object's<B> reserve
area</B> in tandem with the<TT> allocate</TT> protected member function.
<BR><BR>Classes derived from the<TT> streambuf</TT> class should call the<TT> allocate</TT> protected member function rather
than the<TT> doallocate</TT> protected virtual member function.
<BR><BR>The<TT> doallocate</TT> protected virtual member function does the actual memory allocation, and can be defined for
each class derived from the<TT> streambuf</TT> class.
<DT>Derived Implementation Protocol:
<DD>Classes derived from the<TT> streambuf</TT> class should implement the<TT> doallocate</TT> protected virtual member function
such that it does the following:
<OL>
<LI>attempts to allocate an area of memory,
<LI>calls the<TT> setb</TT> protected member function to initialize the<B> reserve area</B> pointers,
<LI>performs any class specific operations required.
</OL>
<DT>Default Implementation:
<DD>The default<TT> doallocate</TT> protected virtual member function provided with the<TT> streambuf</TT> class attempts to allocate
a buffer area with the<TT> operator new</TT> intrinsic function.&nbsp; It then calls the<TT> setb</TT> protected member function
to set up the pointers to the<B> reserve area</B>.
<DT>Results:
<DD>The<TT> doallocate</TT> protected virtual member function returns<TT> __NOT_EOF</TT> on success, otherwise<TT> EOF</TT> is
returned.
<DT>See Also:
<DD><TT> streambuf::allocate</TT>
</DL>
<H2 ID="streambuf__ebackLR"> eback() [streambuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;streambu.h&gt;</TT>
<BR><TT>protected:</TT>
<BR><TT>char *streambuf::eback() const;</TT>
<DT>Semantics:
<DD>The<TT> eback</TT> protected member function returns a pointer to the start of the<B> get area</B> within the<B> reserve area</B>
used by the<TT> streambuf</TT> object.
<BR><BR>The<B> reserve area</B>,<B> get area</B>, and<B> put area</B> pointer functions return the following values:
<BR><BR><TT>base()</TT>&nbsp;&nbsp;&nbsp; start of the <B>reserve area</B>.
<BR><TT>ebuf()</TT>&nbsp;&nbsp;&nbsp; end of the <B>reserve area</B>.
<BR><TT>blen()</TT>&nbsp;&nbsp;&nbsp; length of the <B>reserve area</B>.
<BR><BR><TT>eback()</TT>&nbsp;&nbsp; start of the <B>get area</B>.
<BR><TT>gptr()</TT>&nbsp;&nbsp;&nbsp; the <B>get pointer</B>.
<BR><TT>egptr()</TT>&nbsp;&nbsp; end of the <B>get area</B>.
<BR><BR><TT>pbase()</TT>&nbsp;&nbsp; start of the <B>put area</B>.
<BR><TT>pptr()</TT>&nbsp;&nbsp;&nbsp; the <B>put pointer</B>.
<BR><TT>epptr()</TT>&nbsp;&nbsp; end of the <B>put area</B>.
<BR><BR>From<TT> eback</TT> to<TT> gptr</TT> are characters buffered and read.&nbsp; From<TT> gptr</TT> to<TT> egptr</TT>
are characters buffered but not yet read.&nbsp; From<TT> pbase</TT> to<TT> pptr</TT> are characters buffered and not yet written.
&nbsp;From<TT> pptr</TT> to<TT> epptr</TT> is unused buffer area.
<DT>Results:
<DD>The<TT> eback</TT> protected member function returns a pointer to the start of the<B> get area</B>.&nbsp; If the<TT> streambuf</TT>
object currently does not have a<B> get area</B>,<TT> NULL</TT> is returned.
<DT>See Also:
<DD><TT> streambuf::egptr</TT>,<TT> gptr</TT>,<TT> setg</TT>
</DL>
<H2 ID="streambuf__ebufLR"> ebuf() [streambuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;streambu.h&gt;</TT>
<BR><TT>protected:</TT>
<BR><TT>char *streambuf::ebuf() const;</TT>
<DT>Semantics:
<DD>The<TT> ebuf</TT> protected member function returns a pointer to the end of the<B> reserve area</B> that the<TT> streambuf</TT>
object is using.&nbsp; The character pointed at is actually the first character past the end of the<B> reserve area</B>.
<BR><BR>The<B> reserve area</B>,<B> get area</B>, and<B> put area</B> pointer functions return the following values:
<BR><BR><TT>base()</TT>&nbsp;&nbsp;&nbsp; start of the <B>reserve area</B>.
<BR><TT>ebuf()</TT>&nbsp;&nbsp;&nbsp; end of the <B>reserve area</B>.
<BR><TT>blen()</TT>&nbsp;&nbsp;&nbsp; length of the <B>reserve area</B>.
<BR><BR><TT>eback()</TT>&nbsp;&nbsp; start of the <B>get area</B>.
<BR><TT>gptr()</TT>&nbsp;&nbsp;&nbsp; the <B>get pointer</B>.
<BR><TT>egptr()</TT>&nbsp;&nbsp; end of the <B>get area</B>.
<BR><BR><TT>pbase()</TT>&nbsp;&nbsp; start of the <B>put area</B>.
<BR><TT>pptr()</TT>&nbsp;&nbsp;&nbsp; the <B>put pointer</B>.
<BR><TT>epptr()</TT>&nbsp;&nbsp; end of the <B>put area</B>.
<BR><BR>From<TT> eback</TT> to<TT> gptr</TT> are characters buffered and read.&nbsp; From<TT> gptr</TT> to<TT> egptr</TT>
are characters buffered but not yet read.&nbsp; From<TT> pbase</TT> to<TT> pptr</TT> are characters buffered and not yet written.
&nbsp;From<TT> pptr</TT> to<TT> epptr</TT> is unused buffer area.
<DT>Results:
<DD>The<TT> ebuf</TT> protected member function returns a pointer to the end of the<B> reserve area</B>.&nbsp; If the<TT> streambuf</TT>
object currently does not have a<B> reserve area</B>,<TT> NULL</TT> is returned.
<DT>See Also:
<DD><TT> streambuf::base</TT>,<TT> blen</TT>,<TT> setb</TT>
</DL>
<H2 ID="streambuf__egptrLR"> egptr() [streambuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;streambu.h&gt;</TT>
<BR><TT>protected:</TT>
<BR><TT>char *streambuf::egptr() const;</TT>
<DT>Semantics:
<DD>The<TT> egptr</TT> protected member function returns a pointer to the end of the<B> get area</B> within the<B> reserve area</B>
used by the<TT> streambuf</TT> object.&nbsp; The character pointed at is actually the first character past the end of the<B>
get area</B>.
<BR><BR>The<B> reserve area</B>,<B> get area</B>, and<B> put area</B> pointer functions return the following values:
<BR><BR><TT>base()</TT>&nbsp;&nbsp;&nbsp; start of the <B>reserve area</B>.
<BR><TT>ebuf()</TT>&nbsp;&nbsp;&nbsp; end of the <B>reserve area</B>.
<BR><TT>blen()</TT>&nbsp;&nbsp;&nbsp; length of the <B>reserve area</B>.
<BR><BR><TT>eback()</TT>&nbsp;&nbsp; start of the <B>get area</B>.
<BR><TT>gptr()</TT>&nbsp;&nbsp;&nbsp; the <B>get pointer</B>.
<BR><TT>egptr()</TT>&nbsp;&nbsp; end of the <B>get area</B>.
<BR><BR><TT>pbase()</TT>&nbsp;&nbsp; start of the <B>put area</B>.
<BR><TT>pptr()</TT>&nbsp;&nbsp;&nbsp; the <B>put pointer</B>.
<BR><TT>epptr()</TT>&nbsp;&nbsp; end of the <B>put area</B>.
<BR><BR>From<TT> eback</TT> to<TT> gptr</TT> are characters buffered and read.&nbsp; From<TT> gptr</TT> to<TT> egptr</TT>
are characters buffered but not yet read.&nbsp; From<TT> pbase</TT> to<TT> pptr</TT> are characters buffered and not yet written.
&nbsp;From<TT> pptr</TT> to<TT> epptr</TT> is unused buffer area.
<DT>Results:
<DD>The<TT> egptr</TT> protected member function returns a pointer to the end of the<B> get area</B>.&nbsp; If the<TT> streambuf</TT>
object currently does not have a<B> get area</B>,<TT> NULL</TT> is returned.
<DT>See Also:
<DD><TT> streambuf::eback</TT>,<TT> gptr</TT>,<TT> setg</TT>
</DL>
<H2 ID="streambuf__epptrLR"> epptr() [streambuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;streambu.h&gt;</TT>
<BR><TT>protected:</TT>
<BR><TT>char *streambuf::epptr() const;</TT>
<DT>Semantics:
<DD>The<TT> epptr</TT> protected member function returns a pointer to the end of the<B> put area</B> within the<B> reserve area</B>
used by the<TT> streambuf</TT> object.&nbsp; The character pointed at is actually the first character past the end of the<B>
put area</B>.
<BR><BR>The<B> reserve area</B>,<B> get area</B>, and<B> put area</B> pointer functions return the following values:
<BR><BR><TT>base()</TT>&nbsp;&nbsp;&nbsp; start of the <B>reserve area</B>.
<BR><TT>ebuf()</TT>&nbsp;&nbsp;&nbsp; end of the <B>reserve area</B>.
<BR><TT>blen()</TT>&nbsp;&nbsp;&nbsp; length of the <B>reserve area</B>.
<BR><BR><TT>eback()</TT>&nbsp;&nbsp; start of the <B>get area</B>.
<BR><TT>gptr()</TT>&nbsp;&nbsp;&nbsp; the <B>get pointer</B>.
<BR><TT>egptr()</TT>&nbsp;&nbsp; end of the <B>get area</B>.
<BR><BR><TT>pbase()</TT>&nbsp;&nbsp; start of the <B>put area</B>.
<BR><TT>pptr()</TT>&nbsp;&nbsp;&nbsp; the <B>put pointer</B>.
<BR><TT>epptr()</TT>&nbsp;&nbsp; end of the <B>put area</B>.
<BR><BR>From<TT> eback</TT> to<TT> gptr</TT> are characters buffered and read.&nbsp; From<TT> gptr</TT> to<TT> egptr</TT>
are characters buffered but not yet read.&nbsp; From<TT> pbase</TT> to<TT> pptr</TT> are characters buffered and not yet written.
&nbsp;From<TT> pptr</TT> to<TT> epptr</TT> is unused buffer area.
<DT>Results:
<DD>The<TT> epptr</TT> protected member function returns a pointer to the end of the<B> put area</B>.&nbsp; If the<TT> streambuf</TT>
object currently does not have a<B> put area</B>,<TT> NULL</TT> is returned.
<DT>See Also:
<DD><TT> streambuf::pbase</TT>,<TT> pptr</TT>,<TT> setp</TT>
</DL>
<H2 ID="streambuf__gbumpLR"> gbump() [streambuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;streambu.h&gt;</TT>
<BR><TT>protected:</TT>
<BR><TT>void streambuf::gbump( streamoff offset );</TT>
<DT>Semantics:
<DD>The<TT> gbump</TT> protected member function increments the<B> get pointer</B> by the specified<B> offset</B>, without regard
for the boundaries of the<B> get area</B>.&nbsp; The<B> offset</B> parameter may be positive or negative.
<DT>Results:
<DD>The<TT> gbump</TT> protected member function returns nothing.
<DT>See Also:
<DD><TT> streambuf::gptr</TT>,<TT> pbump</TT>,<TT> sbumpc</TT>,<TT> sputbackc</TT>
</DL>
<H2 ID="streambuf__gptrLR"> gptr() [streambuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;streambu.h&gt;</TT>
<BR><TT>protected:</TT>
<BR><TT>char *streambuf::gptr() const;</TT>
<DT>Semantics:
<DD>The<TT> gptr</TT> protected member function returns a pointer to the next available character in the<B> get area</B> within
the<B> reserve area</B> used by the<TT> streambuf</TT> object.&nbsp; This pointer is called the<B> get pointer</B>.&nbsp;

<BR><BR>If the<B> get pointer</B> points beyond the end of the<B> get area</B>, all characters in the<B> get area</B> have
been read by the program and a subsequent read causes the<TT> underflow</TT> virtual member function to be called to fetch
more characters from the source to which the<TT> streambuf</TT> object is attached.
<BR><BR>The<B> reserve area</B>,<B> get area</B>, and<B> put area</B> pointer functions return the following values:
<BR><BR><TT>base()</TT>&nbsp;&nbsp;&nbsp; start of the <B>reserve area</B>.
<BR><TT>ebuf()</TT>&nbsp;&nbsp;&nbsp; end of the <B>reserve area</B>.
<BR><TT>blen()</TT>&nbsp;&nbsp;&nbsp; length of the <B>reserve area</B>.
<BR><BR><TT>eback()</TT>&nbsp;&nbsp; start of the <B>get area</B>.
<BR><TT>gptr()</TT>&nbsp;&nbsp;&nbsp; the <B>get pointer</B>.
<BR><TT>egptr()</TT>&nbsp;&nbsp; end of the <B>get area</B>.
<BR><BR><TT>pbase()</TT>&nbsp;&nbsp; start of the <B>put area</B>.
<BR><TT>pptr()</TT>&nbsp;&nbsp;&nbsp; the <B>put pointer</B>.
<BR><TT>epptr()</TT>&nbsp;&nbsp; end of the <B>put area</B>.
<BR><BR>From<TT> eback</TT> to<TT> gptr</TT> are characters buffered and read.&nbsp; From<TT> gptr</TT> to<TT> egptr</TT>
are characters buffered but not yet read.&nbsp; From<TT> pbase</TT> to<TT> pptr</TT> are characters buffered and not yet written.
&nbsp;From<TT> pptr</TT> to<TT> epptr</TT> is unused buffer area.
<DT>Results:
<DD>The<TT> gptr</TT> protected member function returns a pointer to the next available character in the<B> get area</B>.&nbsp;
If the<TT> streambuf</TT> object currently does not have a<B> get area</B>,<TT> NULL</TT> is returned.
<DT>See Also:
<DD><TT> streambuf::eback</TT>,<TT> egptr</TT>,<TT> setg</TT>
</DL>
<H2 ID="streambuf__in_availLR"> in_avail() [streambuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;streambu.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int streambuf::in_avail() const;</TT>
<DT>Semantics:
<DD>The<TT> in_avail</TT> public member function computes the number of input characters buffered in the<B> get area</B> that
have not yet been read by the program.&nbsp; These characters can be read with a guarantee that no errors will occur.
<DT>Results:
<DD>The<TT> in_avail</TT> public member function returns the number of buffered input characters.
<DT>See Also:
<DD><TT> streambuf::egptr</TT>,<TT> gptr</TT>
</DL>
<H2 ID="streambuf__out_waitingLR"> out_waiting() [streambuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;streambu.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int streambuf::out_waiting() const;</TT>
<DT>Semantics:
<DD>The<TT> out_waiting</TT> public member function computes the number of characters that have been buffered in the<B> put area</B>
and not yet been written to the output device.
<DT>Results:
<DD>The<TT> out_waiting</TT> public member function returns the number of buffered output characters.
<DT>See Also:
<DD><TT> streambuf::pbase</TT>,<TT> pptr</TT>
</DL>
<H2 ID="streambuf__overflowLR"> overflow() [streambuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;streambu.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>virtual int streambuf::overflow( int ch = EOF ) = 0;</TT>
<DT>Semantics:
<DD>The<TT> overflow</TT> public virtual member function is used to flush the<B> put area</B> when it is full.
<DT>Derived Implementation Protocol:
<DD>Classes derived from the<TT> streambuf</TT> class should implement the<TT> overflow</TT> public virtual member function so
that it performs the following:
<OL>
<LI>if no<B> reserve area</B> is present and the<TT> streambuf</TT> object is not unbuffered, allocate a<B> reserve area</B>
using the<TT> allocate</TT> member function and set up the<B> reserve area</B> pointers using the<TT> setb</TT> protected
member function,
<LI>flush any other uses of the<B> reserve area</B>,
<LI>write any characters in the<B> put area</B> to the<TT> streambuf</TT> object's destination,
<LI>set up the<B> put area</B> pointers to reflect the characters that were written,
<LI>return<TT> __NOT_EOF</TT> on success, otherwise return<TT> EOF</TT>.
</OL>
<DT>Default Implementation:
<DD>There is no default<TT> streambuf</TT> class implementation of the<TT> overflow</TT> public virtual member function.&nbsp;
The<TT> overflow</TT> public virtual member function must be defined for all classes derived from the<TT> streambuf</TT> class.
<DT>Results:
<DD>The<TT> overflow</TT> public virtual member function returns<TT> __NOT_EOF</TT> on success, otherwise<TT> EOF</TT> is returned.
<DT>See Also:
<DD><TT> filebuf::overflow</TT>,<TT> stdiobuf::overflow</TT>,<TT> strstreambuf::overflow</TT>
</DL>
<H2 ID="streambuf__pbackfailLR"> pbackfail() [streambuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;streambu.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>virtual int streambuf::pbackfail( int ch );</TT>
<DT>Semantics:
<DD>The<TT> pbackfail</TT> public virtual member function is called by the<TT> sputbackc</TT> member function when the<B> get
pointer</B> is at the beginning of the<B> get area</B>, and so there is no place to put the<B> ch</B> parameter.
<DT>Derived Implementation Protocol:
<DD>Classes derived from the<TT> streambuf</TT> class should implement the<TT> pbackfail</TT> public virtual member function such
that it attempts to put<B> ch</B> back into the source of the stream.
<DT>Default Implementation:
<DD>The default<TT> streambuf</TT> class implementation of the<TT> pbackfail</TT> public virtual member function is to return<TT>
EOF</TT>.
<DT>Results:
<DD>If the<TT> pbackfail</TT> public virtual member function succeeds, it returns<B> ch</B>.&nbsp; Otherwise,<TT> EOF</TT> is
returned.
</DL>
<H2 ID="streambuf__pbaseLR"> pbase() [streambuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;streambu.h&gt;</TT>
<BR><TT>protected:</TT>
<BR><TT>char *streambuf::pbase() const;</TT>
<DT>Semantics:
<DD>The<TT> pbase</TT> protected member function returns a pointer to the start of the<B> put area</B> within the<B> reserve area</B>
used by the<TT> streambuf</TT> object.
<BR><BR>The<B> reserve area</B>,<B> get area</B>, and<B> put area</B> pointer functions return the following values:
<BR><BR><TT>base()</TT>&nbsp;&nbsp;&nbsp; start of the <B>reserve area</B>.
<BR><TT>ebuf()</TT>&nbsp;&nbsp;&nbsp; end of the <B>reserve area</B>.
<BR><TT>blen()</TT>&nbsp;&nbsp;&nbsp; length of the <B>reserve area</B>.
<BR><BR><TT>eback()</TT>&nbsp;&nbsp; start of the <B>get area</B>.
<BR><TT>gptr()</TT>&nbsp;&nbsp;&nbsp; the <B>get pointer</B>.
<BR><TT>egptr()</TT>&nbsp;&nbsp; end of the <B>get area</B>.
<BR><BR><TT>pbase()</TT>&nbsp;&nbsp; start of the <B>put area</B>.
<BR><TT>pptr()</TT>&nbsp;&nbsp;&nbsp; the <B>put pointer</B>.
<BR><TT>epptr()</TT>&nbsp;&nbsp; end of the <B>put area</B>.
<BR><BR>From<TT> eback</TT> to<TT> gptr</TT> are characters buffered and read.&nbsp; From<TT> gptr</TT> to<TT> egptr</TT>
are characters buffered but not yet read.&nbsp; From<TT> pbase</TT> to<TT> pptr</TT> are characters buffered and not yet written.
&nbsp;From<TT> pptr</TT> to<TT> epptr</TT> is unused buffer area.
<DT>Results:
<DD>The<TT> pbase</TT> protected member function returns a pointer to the start of the<B> put area</B>.&nbsp; If the<TT> streambuf</TT>
object currently does not have a<B> put area</B>,<TT> NULL</TT> is returned.
<DT>See Also:
<DD><TT> streambuf::epptr</TT>,<TT> pptr</TT>,<TT> setp</TT>
</DL>
<H2 ID="streambuf__pbumpLR"> pbump() [streambuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;streambu.h&gt;</TT>
<BR><TT>protected:</TT>
<BR><TT>void streambuf::pbump( streamoff offset );</TT>
<DT>Semantics:
<DD>The<TT> pbump</TT> protected member function increments the<B> put pointer</B> by the specified<B> offset</B>, without regard
for the boundaries of the<B> put area</B>.&nbsp; The<B> offset</B> parameter may be positive or negative.
<DT>Results:
<DD>The<TT> pbump</TT> protected member function returns nothing.
<DT>See Also:
<DD><TT> streambuf::gbump</TT>,<TT> pbase</TT>,<TT> pptr</TT>
</DL>
<H2 ID="streambuf__pptrLR"> pptr() [streambuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;streambu.h&gt;</TT>
<BR><TT>protected:</TT>
<BR><TT>char *streambuf::pptr() const;</TT>
<DT>Semantics:
<DD>The<TT> pptr</TT> protected member function returns a pointer to the next available space in the<B> put area</B> within the<B>
reserve area</B> used by the<TT> streambuf</TT> object.&nbsp; This pointer is called the<B> put pointer</B>.&nbsp; 
<BR><BR>If the<B> put pointer</B> points beyond the end of the<B> put area</B>, the<B> put area</B> is full and a subsequent
write causes the<TT> overflow</TT> virtual member function to be called to empty the<B> put area</B> to the device to which
the<TT> streambuf</TT> object is attached.
<BR><BR>The<B> reserve area</B>,<B> get area</B>, and<B> put area</B> pointer functions return the following values:
<BR><BR><TT>base()</TT>&nbsp;&nbsp;&nbsp; start of the <B>reserve area</B>.
<BR><TT>ebuf()</TT>&nbsp;&nbsp;&nbsp; end of the <B>reserve area</B>.
<BR><TT>blen()</TT>&nbsp;&nbsp;&nbsp; length of the <B>reserve area</B>.
<BR><BR><TT>eback()</TT>&nbsp;&nbsp; start of the <B>get area</B>.
<BR><TT>gptr()</TT>&nbsp;&nbsp;&nbsp; the <B>get pointer</B>.
<BR><TT>egptr()</TT>&nbsp;&nbsp; end of the <B>get area</B>.
<BR><BR><TT>pbase()</TT>&nbsp;&nbsp; start of the <B>put area</B>.
<BR><TT>pptr()</TT>&nbsp;&nbsp;&nbsp; the <B>put pointer</B>.
<BR><TT>epptr()</TT>&nbsp;&nbsp; end of the <B>put area</B>.
<BR><BR>From<TT> eback</TT> to<TT> gptr</TT> are characters buffered and read.&nbsp; From<TT> gptr</TT> to<TT> egptr</TT>
are characters buffered but not yet read.&nbsp; From<TT> pbase</TT> to<TT> pptr</TT> are characters buffered and not yet written.
&nbsp;From<TT> pptr</TT> to<TT> epptr</TT> is unused buffer area.
<DT>Results:
<DD>The<TT> pptr</TT> protected member function returns a pointer to the next available space in the<B> put area</B>.&nbsp; If
the<TT> streambuf</TT> object currently does not have a<B> put area</B>,<TT> NULL</TT> is returned.
<DT>See Also:
<DD><TT> streambuf::epptr</TT>,<TT> pbase</TT>,<TT> setp</TT>
</DL>
<H2 ID="streambuf__sbumpcLR"> sbumpc() [streambuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;streambu.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int streambuf::sbumpc();</TT>
<DT>Semantics:
<DD>The<TT> sbumpc</TT> public member function extracts the next available character from the<B> get area</B> and advances the<B>
get pointer</B>.&nbsp; If no character is available, it calls the<TT> underflow</TT> virtual member function to fetch more
characters from the source into the<B> get area</B>.
<BR><BR>Due to the<TT> sbumpc</TT> member functions's awkward name, the<TT> sgetchar</TT> member function was added to take
its place in the WATCOM implementation.
<DT>Results:
<DD>The<TT> sbumpc</TT> public member function returns the next available character in the<B> get area</B>.&nbsp; If no character
is available,<TT> EOF</TT> is returned.
<DT>See Also:
<DD><TT> streambuf::gbump</TT>,<TT> sgetc</TT>,<TT> sgetchar</TT>,<TT> sgetn</TT>,<TT> snextc</TT>,<TT> sputbackc</TT>
</DL>
<H2 ID="streambuf__seekoffLR"> seekoff() [streambuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;streambu.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>virtual streampos streambuf::seekoff( streamoff offset,</TT>
<BR><TT> ios::seekdir dir,</TT>
<BR><TT>ios::openmode mode );</TT>
<DT>Semantics:
<DD>The<TT> seekoff</TT> public virtual member function is used for positioning to a relative location within the<TT> streambuf</TT>
object, and hence within the device that is connected to the<TT> streambuf</TT> object.&nbsp; The<B> offset</B> and<B> dir</B>
parameters specify the relative change in position.&nbsp; The<B> mode</B> parameter controls whether the<B> get pointer</B>
and/or the<B> put pointer</B> are repositioned.
<DT>Derived Implementation Protocol:
<DD>Classes derived from the<TT> streambuf</TT> class should implement the<TT> seekoff</TT> virtual member function so that it
uses its parameters in the following way.
<BR><BR>The<B> mode</B> parameter may be<TT> ios::in</TT>,<TT> ios::out</TT>, or<TT> ios::in|ios::out</TT> and should be interpreted
as follows, provided the interpretation is meaningful:
<BR><BR><TT>ios::in</TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the <B>get pointer</B> should
be moved.
<BR><TT>ios::out</TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the <B>put pointer</B> should be moved.
<BR><TT>ios::in|ios::out</TT>&nbsp;&nbsp;&nbsp; both the <B>get pointer</B> and the <B>put pointer</B> should be moved.
<BR><BR>If<B> mode</B> has any other value, the<TT> seekoff</TT> public virtual member function fails.
<BR>The<B> dir</B> parameter may be<TT> ios::beg</TT>,<TT> ios::cur</TT>, or<TT> ios::end</TT> and is interpreted in conjunction
with the<B> offset</B> parameter as follows:
<BR><BR><TT>ios::beg</TT>&nbsp; the <B>offset</B> is relative to the start and should be a positive value.
<BR><TT>ios::cur</TT>&nbsp; the <B>offset</B> is relative to the current position and may be positive
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (seek towards end) or negative (seek towards start).
<BR><TT>ios::end</TT>&nbsp; the <B>offset</B> is relative to the end and should be a negative value.
<BR><BR>If the<B> dir</B> parameter has any other value, or the<B> offset</B> parameter does not have an appropriate sign,
the<TT> seekoff</TT> public virtual member function fails.
<DT>Default Implementation:
<DD>The default implementation of the<TT> seekoff</TT> public virtual member function provided by the<TT> streambuf</TT> class
returns<TT> EOF</TT>.
<DT>Results:
<DD>The<TT> seekoff</TT> public virtual member function returns the new position in the stream on success, otherwise<TT> EOF</TT>
is returned.
<DT>See Also:
<DD><TT> streambuf::seekpos</TT>
</DL>
<H2 ID="streambuf__seekposLR"> seekpos() [streambuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;streambu.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>virtual streampos streambuf::seekpos( streampos pos,</TT>
<BR><TT> ios::openmode mode = ios::in|ios::out );</TT>
<DT>Semantics:
<DD>The<TT> seekpos</TT> public virtual member function is used for positioning to an absolute location within the<TT> streambuf</TT>
object, and hence within the device that is connected to the<TT> streambuf</TT> object.&nbsp; The<B> pos</B> parameter specifies
the absolute position.&nbsp; The<B> mode</B> parameter controls whether the<B> get pointer</B> and/or the<B> put pointer</B>
are repositioned.
<DT>Derived Implementation Protocol:
<DD>Classes derived from the<TT> streambuf</TT> class should implement the<TT> seekpos</TT> public virtual member function so
that it uses its parameters in the following way.
<BR><BR>The<B> mode</B> parameter may be<TT> ios::in</TT>,<TT> ios::out</TT>, or<TT> ios::in|ios::out</TT> and should be interpreted
as follows, provided the interpretation is meaningful:
<BR><BR><TT>ios::in</TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the <B>get pointer</B> should
be moved.
<BR><TT>ios::out</TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the <B>put pointer</B> should be moved.
<BR><TT>ios::in|ios::out</TT>&nbsp;&nbsp;&nbsp; both the <B>get pointer</B> and the <B>put pointer</B> should be moved.
<BR><BR>If<B> mode</B> has any other value, the<TT> seekpos</TT> public virtual member function fails.
<BR>In general the<TT> seekpos</TT> public virtual member function is equivalent to calling the<TT> seekoff</TT> virtual member
function with the offset set to<B> pos</B>, the direction set to<TT> ios::beg</TT> and the mode set to<B> mode</B>.
<DT>Default Implementation:
<DD>The default implementation of the<TT> seekpos</TT> public virtual member function provided by the<TT> streambuf</TT> class
calls the<TT> seekoff</TT> virtual member function with the offset set to<B> pos</B>, the direction set to<TT> ios::beg</TT>,
and the mode set to<B> mode</B>.
<DT>Results:
<DD>The<TT> seekpos</TT> public virtual member function returns the new position in the stream on success, otherwise<TT> EOF</TT>
is returned.
<DT>See Also:
<DD><TT> streambuf::seekoff</TT>
</DL>
<H2 ID="streambuf__setbLR"> setb() [streambuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;streambu.h&gt;</TT>
<BR><TT>protected:</TT>
<BR><TT>void streambuf::setb( char *base, char *ebuf, int autodel );</TT>
<DT>Semantics:
<DD>The<TT> setb</TT> protected member function is used to set the pointers to the<B> reserve area</B> that the<TT> streambuf</TT>
object is using.
<BR><BR>The<B> base</B> parameter is a pointer to the start of the<B> reserve area</B> and corresponds to the value that the<TT>
base</TT> member function returns.
<BR><BR>The<B> ebuf</B> parameter is a pointer to the end of the<B> reserve area</B> and corresponds to the value that the<TT>
ebuf</TT> member function returns.
<BR><BR>The<B> autodel</B> parameter indicates whether or not the<TT> streambuf</TT> object can free the<B> reserve area</B>
when the<TT> streambuf</TT> object is destroyed or when a new<B> reserve area</B> is set up in a subsequent call to the<TT>
setb</TT> protected member function.&nbsp; If the<B> autodel</B> parameter is non-zero, the<TT> streambuf</TT> object can
delete the<B> reserve area</B>, using the<TT> operator delete</TT> intrinsic function.&nbsp; Otherwise, a zero value indicates
that the buffer will be deleted elsewhere.
<BR><BR>If either of the<B> base</B> or<B> ebuf</B> parameters are<TT> NULL</TT> or if<B> ebuf</B> &lt;=<B> base</B>, the<TT>
streambuf</TT> object does not have a buffer and input/output operations are unbuffered, unless another buffer is set up.
<BR><BR>Note that the<TT> setb</TT> protected member function is used to set the<B> reserve area</B> pointers, while the<TT>
setbuf</TT> protected member function is used to offer a buffer to the<TT> streambuf</TT> object.
<DT>See Also:
<DD><TT> streambuf::base</TT>,<TT> blen</TT>,<TT> ebuf</TT>,<TT> setbuf</TT>
</DL>
<H2 ID="streambuf__setbufLR"> setbuf() [streambuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;streambu.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>virtual streambuf *streambuf::setbuf( char *buf, int len );</TT>
<DT>Semantics:
<DD>The<TT> setbuf</TT> public virtual member function is used to offer a buffer specified by the<B> buf</B> and<B> len</B> parameters
to the<TT> streambuf</TT> object for use as its<B> reserve area</B>.&nbsp; Note that the<TT> setbuf</TT> public virtual member
function is used to offer a buffer, while the<TT> setb</TT> protected member function is used to set the<B> reserve area</B>
pointers once a buffer has been accepted.
<DT>Derived Implementation Protocol:
<DD>Classes derived from the<TT> streambuf</TT> class may implement the<TT> setbuf</TT> public virtual member function if the
default behavior is not suitable.
<BR><BR>Derived classes that provide their own implementations of the<TT> setbuf</TT> public virtual member function may accept
or reject the offered buffer.&nbsp; Often, if a buffer is already allocated, the offered buffer is rejected, as it may be
difficult to transfer the information from the current buffer.
<DT>Default Implementation:
<DD>The default<TT> setbuf</TT> public virtual member function provided by the<TT> streambuf</TT> class rejects the buffer if
one is already present.
<BR><BR>If no buffer is present and either<B> buf</B> is<TT> NULL</TT> or<B> len</B> is zero, the offer is accepted and the<TT>
streambuf</TT> object is unbuffered.
<BR><BR>Otherwise, no buffer is present and one is specified.&nbsp; If<B> len</B> is less than five characters the buffer
is too small and it is rejected.&nbsp; Otherwise, the buffer is accepted.
<DT>Results:
<DD>The<TT> setbuf</TT> public virtual member function returns the address of the<TT> streambuf</TT> object if the offered buffer
is accepted, otherwise<TT> NULL</TT> is returned.
<DT>See Also:
<DD><TT> streambuf::setb</TT>
</DL>
<H2 ID="streambuf__setgLR"> setg() [streambuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;streambu.h&gt;</TT>
<BR><TT>protected:</TT>
<BR><TT>void streambuf::setg( char *eback, char *gptr, char *egptr );</TT>
<DT>Semantics:
<DD>The<TT> setg</TT> protected member function is used to set the three<B> get area</B> pointers.
<BR><BR>The<B> eback</B> parameter is a pointer to the start of the<B> get area</B> and corresponds to the value that the<TT>
eback</TT> member function returns.
<BR><BR>The<B> gptr</B> parameter is a pointer to the first available character in the<B> get area</B>, that is, the<B> get
pointer</B>, and usually is greater than the<TT> eback</TT> parameter in order to accommodate a putback area.&nbsp; The<B>
gptr</B> parameter corresponds to the value that the<TT> gptr</TT> member function returns.
<BR><BR>The<B> egptr</B> parameter is a pointer to the end of the<B> get area</B> and corresponds to the value that the<TT>
egptr</TT> member function returns.
<BR><BR>If any of the three parameters are<TT> NULL</TT>, there is no<B> get area</B>.
<DT>See Also:
<DD><TT> streambuf::eback</TT>,<TT> egptr</TT>,<TT> gptr</TT>
</DL>
<H2 ID="streambuf__setpLR"> setp() [streambuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;streambu.h&gt;</TT>
<BR><TT>protected:</TT>
<BR><TT>void streambuf::setp( char *pbase, char *epptr );</TT>
<DT>Semantics:
<DD>The<TT> setp</TT> protected member function is used to set the three<B> put area</B> pointers.
<BR><BR>The<B> pbase</B> parameter is a pointer to the start of the<B> put area</B> and corresponds to the value that the<TT>
pbase</TT> member function returns.
<BR><BR>The<B> epptr</B> parameter is a pointer to the end of the<B> put area</B> and corresponds to the value that the<TT>
epptr</TT> member function returns.
<BR><BR>The<B> put pointer</B> is set to the<B> pbase</B> parameter value and corresponds to the value that the<TT> pptr</TT>
member function returns.
<BR><BR>If either parameter is<TT> NULL</TT>, there is no<B> put area</B>.
<DT>See Also:
<DD><TT> streambuf::epptr</TT>,<TT> pbase</TT>,<TT> pptr</TT>
</DL>
<H2 ID="streambuf__sgetcLR"> sgetc() [streambuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;streambu.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int streambuf::sgetc();</TT>
<DT>Semantics:
<DD>The<TT> sgetc</TT> public member function returns the next available character in the<B> get area</B>.&nbsp; The<B> get pointer</B>
is not advanced.&nbsp; If the<B> get area</B> is empty, the<TT> underflow</TT> virtual member function is called to fetch
more characters from the source into the<B> get area</B>.
<BR><BR>Due to the<TT> sgetc</TT> member function's confusing name (the C library<TT> getc</TT> function does advance the
pointer), the<TT> speekc</TT> member function was added to take its place in the WATCOM implementation.
<DT>Results:
<DD>The<TT> sgetc</TT> public member function returns the next available character in the<B> get area</B>.&nbsp; If no character
is available,<TT> EOF</TT> is returned.
<DT>See Also:
<DD><TT> streambuf::sbumpc</TT>,<TT> sgetchar</TT>,<TT> sgetn</TT>,<TT> snextc</TT>,<TT> speekc</TT>
</DL>
<H2 ID="streambuf__sgetcharLR"> sgetchar() [streambuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;streambu.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int streambuf::sgetchar();</TT>
<DT>Semantics:
<DD>The<TT> sgetchar</TT> public member function extracts the next available character from the<B> get area</B> and advances the<B>
get pointer</B>.&nbsp; If no character is available, it calls the<TT> underflow</TT> virtual member function to fetch more
characters from the source into the<B> get area</B>.
<BR><BR>Due to the<TT> sbumpc</TT> member functions's awkward name, the<TT> sgetchar</TT> member function was added to take
its place in the WATCOM implementation.
<DT>Results:
<DD>The<TT> sgetchar</TT> public member function returns the next available character in the<B> get area</B>.&nbsp; If no character
is available,<TT> EOF</TT> is returned.
<DT>See Also:
<DD><TT> streambuf::gbump</TT>,<TT> sgetc</TT>,<TT> sgetchar</TT>,<TT> sgetn</TT>,<TT> snextc</TT>,<TT> speekc</TT>,<TT> sputbackc</TT>
</DL>
<H2 ID="streambuf__sgetnLR"> sgetn() [streambuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;streambu.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int streambuf::sgetn( char *buf, int len );</TT>
<DT>Semantics:
<DD>The<TT> sgetn</TT> public member function transfers up to<B> len</B> characters from the<B> get area</B> into<B> buf</B>.
&nbsp;If there are not enough characters in the<B> get area</B>, the<TT> do_sgetn</TT> virtual member function is called to
fetch more.
<BR><BR>Classes derived from the<TT> streambuf</TT> class should call the<TT> sgetn</TT> public member function, rather than
the<TT> do_sgetn</TT> virtual member function.
<DT>Results:
<DD>The<TT> sgetn</TT> public member function returns the number of characters transferred from the<B> get area</B> into<B> buf</B>.
<DT>See Also:
<DD><TT> streambuf::do_sgetn</TT>,<TT> sbumpc</TT>,<TT> sgetc</TT>,<TT> sgetchar</TT>,<TT> speekc</TT>
</DL>
<H2 ID="streambuf__snextcLR"> snextc() [streambuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;streambu.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int streambuf::snextc();</TT>
<DT>Semantics:
<DD>The<TT> snextc</TT> public member function advances the<B> get pointer</B> and then returns the character following the<B>
get pointer</B>.&nbsp; The<B> get pointer</B> is left pointing at the returned character.
<BR><BR>If the<B> get pointer</B> cannot be advanced, the<TT> underflow</TT> virtual member function is called to fetch more
characters from the source into the<B> get area</B>.
<DT>Results:
<DD>The<TT> snextc</TT> public member function advances the<B> get pointer</B> and returns the next available character in the<B>
get area</B>.&nbsp; If there is no next available character,<TT> EOF</TT> is returned.
<DT>See Also:
<DD><TT> streambuf::sbumpc</TT>,<TT> sgetc</TT>,<TT> sgetchar</TT>,<TT> sgetn</TT>,<TT> speekc</TT>
</DL>
<H2 ID="streambuf__speekcLR"> speekc() [streambuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;streambu.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int streambuf::speekc();</TT>
<DT>Semantics:
<DD>The<TT> speekc</TT> public member function returns the next available character in the<B> get area</B>.&nbsp; The<B> get pointer</B>
is not advanced.&nbsp; If the<B> get area</B> is empty, the<TT> underflow</TT> virtual member function is called to fetch
more characters from the source into the<B> get area</B>.
<BR><BR>Due to the<TT> sgetc</TT> member function's confusing name (the C library<TT> getc</TT> function does advance the
pointer), the<TT> speekc</TT> member function was added to take its place in the WATCOM implementation.
<DT>Results:
<DD>The<TT> speekc</TT> public member function returns the next available character in the<B> get area</B>.&nbsp; If no character
is available,<TT> EOF</TT> is returned.
<DT>See Also:
<DD><TT> streambuf::sbumpc</TT>,<TT> sgetc</TT>,<TT> sgetchar</TT>,<TT> sgetn</TT>,<TT> snextc</TT>
</DL>
<H2 ID="streambuf__sputbackcLR"> sputbackc() [streambuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;streambu.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int streambuf::sputbackc( char ch );</TT>
<DT>Semantics:
<DD>The<TT> sputbackc</TT> public member function is used to put a character back into the<B> get area</B>.&nbsp; The<B> ch</B>
character specified must be the same as the character before the<B> get pointer</B>, otherwise the behavior is undefined.
&nbsp;The<B> get pointer</B> is backed up by one position.&nbsp; At least four characters may be put back without any intervening
reads.
<DT>Results:
<DD>The<TT> sputbackc</TT> public member function returns<B> ch</B> on success, otherwise<TT> EOF</TT> is returned.
<DT>See Also:
<DD><TT> streambuf::gbump</TT>,<TT> sbumpc</TT>,<TT> sgetchar</TT>
</DL>
<H2 ID="streambuf__sputcLR"> sputc() [streambuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;streambu.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int streambuf::sputc( int ch );</TT>
<DT>Semantics:
<DD>The<TT> sputc</TT> public member function adds the character<B> ch</B> to the end of the<B> put area</B> and advances the<B>
put pointer</B>.&nbsp; If the<B> put area</B> is full before the character is added, the<TT> overflow</TT> virtual member
function is called to empty the<B> put area</B> and write the character.
<DT>Results:
<DD>The<TT> sputc</TT> public member function returns<B> ch</B> on success, otherwise<TT> EOF</TT> is returned.
<DT>See Also:
<DD><TT> streambuf::sgetc</TT>,<TT> sputn</TT>
</DL>
<H2 ID="streambuf__sputnLR"> sputn() [streambuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;streambu.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int streambuf::sputn( char const *buf, int len );</TT>
<DT>Semantics:
<DD>The<TT> sputn</TT> public member function transfers up to<B> len</B> characters from<B> buf</B> to the end of the<B> put area</B>
and advance the<B> put pointer</B>.&nbsp; If the<B> put area</B> is full or becomes full and more characters are to be written,
the<TT> do_sputn</TT> virtual member function is called to empty the<B> put area</B> and finish writing the characters.
<BR><BR>Classes derived from the<TT> streambuf</TT> class should call the<TT> sputn</TT> public member function, rather than
the<TT> do_sputn</TT> virtual member function.
<DT>Results:
<DD>The<TT> sputn</TT> public member function returns the number of characters successfully written.&nbsp; If an error occurs,
this number may be less than<B> len</B>.
<DT>See Also:
<DD><TT> streambuf::do_sputn</TT>,<TT> sputc</TT>
</DL>
<H2 ID="streambuf__stosscLR"> stossc() [streambuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;streambu.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void streambuf::stossc();</TT>
<DT>Semantics:
<DD>The<TT> stossc</TT> public member function advances the<B> get pointer</B> by one without returning a character.&nbsp; If
the<B> get area</B> is empty, the<TT> underflow</TT> virtual member function is called to fetch more characters and then the<B>
get pointer</B> is advanced.
<DT>See Also:
<DD><TT> streambuf::gbump</TT>,<TT> sbumpc</TT>,<TT> sgetchar</TT>,<TT> snextc</TT>
</DL>
<H2 ID="streambuf__streambufLR"> streambuf() [streambuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;streambu.h&gt;</TT>
<BR><TT>protected:</TT>
<BR><TT>streambuf::streambuf();</TT>
<DT>Semantics:
<DD>This form of the protected<TT> streambuf</TT> constructor creates an empty<TT> streambuf</TT> object with all fields initialized
to zero.&nbsp; No<B> reserve area</B> is yet allocated, but the<TT> streambuf</TT> object is buffered unless a subsequent
call to the<TT> setbuf</TT> or<TT> unbuffered</TT> member functions dictate otherwise.
<DT>Results:
<DD>This form of the protected<TT> streambuf</TT> constructor creates an initialized<TT> streambuf</TT> object with no associated<B>
reserve area</B>.
<DT>See Also:
<DD><TT> ~streambuf</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;streambu.h&gt;</TT>
<BR><TT>protected:</TT>
<BR><TT>streambuf::streambuf( char *buf, int len );</TT>
<DT>Semantics:
<DD>This form of the protected<TT> streambuf</TT> constructor creates an empty<TT> streambuf</TT> object with all fields initialized
to zero.&nbsp; The<B> buf</B> and<B> len</B> parameters are passed to the<TT> setbuf</TT> member function, which sets up the
buffer (if specified), or makes the<TT> streambuf</TT> object unbuffered (if the<B> buf</B> parameter is<TT> NULL</TT> or
the<B> len</B> parameter is not positive).
<DT>Results:
<DD>This form of the protected<TT> streambuf</TT> constructor creates an initialized<TT> streambuf</TT> object with an associated<B>
reserve area</B>.
<DT>See Also:
<DD><TT> ~streambuf</TT>,<TT> setbuf</TT>
</DL>
<H2 ID="streambuf____streambufLR"> ~streambuf() [streambuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;streambu.h&gt;</TT>
<BR><TT>protected:</TT>
<BR><TT>virtual streambuf::~streambuf();</TT>
<DT>Semantics:
<DD>The<TT> streambuf</TT> object is destroyed.&nbsp; If the buffer was allocated by the<TT> streambuf</TT> object, it is freed.
&nbsp;Otherwise, the buffer is not freed and must be freed by the user of the<TT> streambuf</TT> object.&nbsp; The call to
the protected<TT> ~streambuf</TT> destructor is inserted implicitly by the compiler at the point where the<TT> streambuf</TT>
object goes out of scope.
<DT>Results:
<DD>The<TT> streambuf</TT> object is destroyed.
<DT>See Also:
<DD><TT> streambuf</TT>
</DL>
<H2 ID="streambuf__syncLR"> sync() [streambuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;streambu.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>virtual int streambuf::sync();</TT>
<DT>Semantics:
<DD>The<TT> sync</TT> public virtual member function is used to synchronize the<TT> streambuf</TT> object's<B> get area</B> and<B>
put area</B> with the associated device.
<DT>Derived Implementation Protocol:
<DD>Classes derived from the<TT> streambuf</TT> class should implement the<TT> sync</TT> public virtual member function such that
it attempts to perform the following:
<OL>
<LI>flush the<B> put area</B>,
<LI>discard the contents of the<B> get area</B> and reposition the stream device so that the discarded characters may be read
again.
</OL>
<DT>Default Implementation:
<DD>The default implementation of the<TT> sync</TT> public virtual member function provided by the<TT> streambuf</TT> class takes
no action.&nbsp; It succeeds if the<B> get area</B> and the<B> put area</B> are empty, otherwise it fails.
<DT>Results:
<DD>The<TT> sync</TT> public virtual member function returns<TT> __NOT_EOF</TT> on success, otherwise<TT> EOF</TT> is returned.
</DL>
<H2 ID="streambuf__unbufferedLR"> unbuffered() [streambuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;streambu.h&gt;</TT>
<BR><TT>protected:</TT>
<BR><TT>int ios::unbuffered() const;</TT>
<BR><TT> int ios::unbuffered( int unbuf );</TT>
<DT>Semantics:
<DD>The<TT> unbuffered</TT> protected member function is used to query and/or set the unbuffering state of the<TT> streambuf</TT>
object.&nbsp; A non-zero unbuffered state indicates that the<TT> streambuf</TT> object is unbuffered.&nbsp; An unbuffered
state of zero indicates that the<TT> streambuf</TT> object is buffered.
<BR><BR>The first form of the<TT> unbuffered</TT> protected member function is used to query the current unbuffering state.
<BR><BR>The second form of the<TT> unbuffered</TT> protected member function is used to set the unbuffering state to<B> unbuf</B>.
<BR><BR>Note that the unbuffering state only affects the<TT> allocate</TT> protected member function, which does nothing if
the unbuffering state is non-zero.&nbsp; Setting the unbuffering state to a non-zero value does not mean that future I/O operations
will be unbuffered.
<BR><BR>To determine if current I/O operations are unbuffered, use the<TT> base</TT> protected member function.&nbsp; A return
value of<TT> NULL</TT> from the<TT> base</TT> protected member function indicates that unbuffered I/O operations will be used.
<DT>Results:
<DD>The<TT> unbuffered</TT> protected member function returns the previous unbuffered state.
<DT>See Also:
<DD><TT> streambuf::allocate</TT>,<TT> pbase</TT>,<TT> setbuf</TT>
</DL>
<H2 ID="streambuf__underflowLR"> underflow() [streambuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;streambu.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>virtual int streambuf::underflow() = 0;</TT>
<DT>Semantics:
<DD>The<TT> underflow</TT> public virtual member function is used to fill the<B> get area</B> when it is empty.
<DT>Derived Implementation Protocol:
<DD>Classes derived from the<TT> streambuf</TT> class should implement the<TT> underflow</TT> public virtual member function so
that it performs the following:
<OL>
<LI>if no<B> reserve area</B> is present and the<TT> streambuf</TT> object is buffered, allocate the<B> reserve area</B> using
the<TT> allocate</TT> member function and set up the<B> reserve area</B> pointers using the<TT> setb</TT> protected member
function,
<LI>flush any other uses of the<B> reserve area</B>,
<LI>read some characters from the<TT> streambuf</TT> object's source into the<B> get area</B>,
<LI>set up the<B> get area</B> pointers to reflect the characters that were read,
<LI>return the first character of the<B> get area</B>, or<TT> EOF</TT> if no characters could be read.
</OL>
<DT>Default Implementation:
<DD>There is no default<TT> streambuf</TT> class implementation of the<TT> underflow</TT> public virtual member function.&nbsp;
The<TT> underflow</TT> public virtual member function must be defined for all classes derived from the<TT> streambuf</TT>
class.
<DT>Results:
<DD>The<TT> underflow</TT> public virtual member function returns the first character read into the<B> get area</B>, or<TT> EOF</TT>
if no characters could be read.
<DT>See Also:
<DD><TT> filebuf::underflow</TT>,<TT> stdiobuf::underflow</TT>,<TT> strstreambuf::underflow</TT>
</DL>
<H2 ID="strstream_Class_Description"> strstream Class Description </H2>
<DL>
<DT>Declared:
<DD><TT> strstrea.h</TT>
<DT>Derived from:
<DD><TT> strstreambase</TT>,<TT> iostream</TT>
<BR><BR>The<TT> strstream</TT> class is used to create and write to string stream objects.
<BR>The<TT> strstream</TT> class provides little of its own functionality.&nbsp; Derived from the<TT> strstreambase</TT> and<TT>
iostream</TT> classes, its constructors and destructor provide simplified access to the appropriate equivalents in those base
classes.&nbsp; The member functions provide specialized access to the string stream object.
<BR><BR>Of the available I/O stream classes, creating a<TT> strstream</TT> object is the preferred method of performing read
and write operations on a string stream.
<BR><BR><B>Public Member Functions</B>
<BR><BR>The following member functions are declared in the public interface:
<BR><BR><TT>strstream();</TT>
<BR><TT> strstream( char *,</TT>
<BR><TT> int,</TT>
<BR><TT>ios::openmode = ios::in|ios::out );</TT>
<BR><TT>strstream( signed char *,</TT>
<BR><TT> int,</TT>
<BR><TT>ios::openmode = ios::in|ios::out );</TT>
<BR><TT>strstream( unsigned char *,</TT>
<BR><TT> int,</TT>
<BR><TT>ios::openmode = ios::in|ios::out );</TT>
<BR><TT>~strstream();</TT>
<BR><TT> char *str();</TT>
<DT>See Also:
<DD><TT> istrstream</TT>,<TT> ostrstream</TT>,<TT> strstreambase</TT>
</DL>
<H2 ID="strstream__strLR"> str() [strstream] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;strstrea.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>char *strstream::str();</TT>
<DT>Semantics:
<DD>The<TT> str</TT> public member function creates a pointer to the buffer being used by the<TT> strstream</TT> object.&nbsp;
If the<TT> strstream</TT> object was created without dynamic allocation (static mode), the pointer is the same as the buffer
pointer passed in the constructor.
<BR><BR>For<TT> strstream</TT> objects using dynamic allocation, the<TT> str</TT> public member function makes an implicit
call to the<TT> strstreambuf::freeze</TT> member function.&nbsp; If nothing has been written to the<TT> strstream</TT> object,
the returned pointer will be<TT> NULL</TT>.
<BR><BR>Note that the buffer does not necessarily end with a null character.&nbsp; If the pointer returned by the<TT> str</TT>
public member function is to be interpreted as a C string, it is the program's responsibility to ensure that the null character
is present.
<DT>Results:
<DD>The<TT> str</TT> public member function returns a pointer to the buffer being used by the<TT> strstream</TT> object.
<DT>See Also:
<DD><TT> strstreambuf::str</TT>,<TT> strstreambuf::freeze</TT>
</DL>
<H2 ID="strstream__strstreamLR"> strstream() [strstream] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;strstrea.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>strstream::strstream();</TT>
<DT>Semantics:
<DD>This form of the public<TT> strstream</TT> constructor creates an empty<TT> strstream</TT> object.&nbsp; Dynamic allocation
is used.&nbsp; The inherited stream member functions can be used to access the<TT> strstream</TT> object.&nbsp; Note that
the<B> get pointer</B> and<B> put pointer</B> are not necessarily pointing at the same location, so moving one pointer (e.g.
&nbsp;by doing a write) does not affect the location of the other pointer.
<DT>Results:
<DD>This form of the public<TT> strstream</TT> constructor creates an initialized, empty<TT> strstream</TT> object.
<DT>See Also:
<DD><TT> ~strstream</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;strstrea.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>strstream::strstream( char *str,</TT>
<BR><TT> int len,</TT>
<BR><TT>ios::openmode mode );</TT>
<BR><TT>strstream::strstream( signed char *str,</TT>
<BR><TT> int len,</TT>
<BR><TT>ios::openmode mode );</TT>
<BR><TT>strstream::strstream( unsigned char *str,</TT>
<BR><TT> int len,</TT>
<BR><TT>ios::openmode mode );</TT>
<DT>Semantics:
<DD>These forms of the public<TT> strstream</TT> constructor create an initialized<TT> strstream</TT> object.&nbsp; Dynamic allocation
is not used.&nbsp; The buffer is specified by the<B> str</B> and<B> len</B> parameters.&nbsp; If the<TT> ios::append</TT>
or<TT> ios::atend</TT> bits are set in the<B> mode</B> parameter, the<B> str</B> parameter is assumed to contain a C string
terminated by a null character, and writing commences at the null character.&nbsp; Otherwise, writing commences at<B> str</B>.
&nbsp;Reading commences at<B> str</B>.
<DT>Results:
<DD>This form of the public<TT> strstream</TT> constructor creates an initialized<TT> strstream</TT> object.
<DT>See Also:
<DD><TT> ~strstream</TT>
</DL>
<H2 ID="strstream____strstreamLR"> ~strstream() [strstream] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;strstrea.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>strstream::~strstream();</TT>
<DT>Semantics:
<DD>The public<TT> ~strstream</TT> destructor does not do anything explicit.&nbsp; The call to the public<TT> ~strstream</TT>
destructor is inserted implicitly by the compiler at the point where the<TT> strstream</TT> object goes out of scope.
<DT>Results:
<DD>The<TT> strstream</TT> object is destroyed.
<DT>See Also:
<DD><TT> strstream</TT>
</DL>
<H2 ID="strstreambase_Class_Description"> strstreambase Class Description </H2>
<DL>
<DT>Declared:
<DD><TT> strstrea.h</TT>
<DT>Derived from:
<DD><TT> ios</TT>
<DT>Derived by:
<DD><TT> istrstream</TT>,<TT> ostrstream</TT>,<TT> strstream</TT>
<BR><BR>The<TT> strstreambase</TT> class is a base class that provides common functionality for the three string stream-based
classes,<TT> istrstream</TT>,<TT> ostrstream</TT> and<TT> strstream</TT>.&nbsp; The<TT> strstreambase</TT> class is derived
from the<TT> ios</TT> class which provides the stream state information.&nbsp; The<TT> strstreambase</TT> class provides constructors
for string stream objects and one member function.
<BR><BR><B>Protected Member Functions</B>
<BR><BR>The following member functions are declared in the protected interface:
<BR><BR><TT>strstreambase();</TT>
<BR><TT> strstreambase( char *, int, char * = 0 );</TT>
<BR><TT> ~strstreambase();</TT>
<BR><BR><B>Public Member Functions</B>
<BR><BR>The following member function is declared in the public interface:
<BR><BR><TT>strstreambuf *rdbuf() const;</TT>
<DT>See Also:
<DD><TT> istrstream</TT>,<TT> ostrstream</TT>,<TT> strstream</TT>,<TT> strstreambuf</TT>
</DL>
<H2 ID="strstreambase__rdbufLR"> rdbuf() [strstreambase] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;strstrea.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>strstreambuf *strstreambase::rdbuf() const;</TT>
<DT>Semantics:
<DD>The<TT> rdbuf</TT> public member function creates a pointer to the<TT> strstreambuf</TT> associated with the<TT> strstreambase</TT>
object.&nbsp; Since the<TT> strstreambuf</TT> object is embedded within the<TT> strstreambase</TT> object, this function never
returns<TT> NULL</TT>.
<DT>Results:
<DD>The<TT> rdbuf</TT> public member function returns a pointer to the<TT> strstreambuf</TT> associated with the<TT> strstreambase</TT>
object.
</DL>
<H2 ID="strstreambase__strstreambaseLR"> strstreambase() [strstreambase] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;strstrea.h&gt;</TT>
<BR><TT>protected:</TT>
<BR><TT>strstreambase::strstreambase();</TT>
<DT>Semantics:
<DD>This form of the protected<TT> strstreambase</TT> constructor creates a<TT> strstreambase</TT> object that is initialized,
but empty.&nbsp; Dynamic allocation is used to store characters.&nbsp; No buffer is allocated.&nbsp; A buffer is be allocated
when data is first written to the<TT> strstreambase</TT> object.
<BR><BR>This form of the protected<TT> strstreambase</TT> constructor is only used implicitly by the compiler when it generates
a constructor for a derived class.
<DT>Results:
<DD>The protected<TT> strstreambase</TT> constructor creates an initialized<TT> strstreambase</TT> object.
<DT>See Also:
<DD><TT> ~strstreambase</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;strstrea.h&gt;</TT>
<BR><TT>protected:</TT>
<BR><TT>strstreambase::strstreambase( char *str,</TT>
<BR><TT> int len,</TT>
<BR><TT>char *pstart );</TT>
<DT>Semantics:
<DD>This form of the protected<TT> strstreambase</TT> constructor creates a<TT> strstreambase</TT> object that is initialized
and uses the buffer specified by the<B> str</B> and<B> len</B> parameters as its<B> reserve area</B> within the associated<TT>
strstreambuf</TT> object.&nbsp; Dynamic allocation is not used.
<BR><BR>This form of the protected<TT> strstreambase</TT> constructor is unlikely to be explicitly used, except in the member
initializer list for the constructor of a derived class.
<BR><BR>The<B> str</B>,<B> len</B> and<B> pstart</B> parameters are interpreted as follows:
<OL>
<LI>The buffer starts at<B> str</B>.
<LI>If<B> len</B> is positive, the buffer is<B> len</B> characters long.
<LI>If<B> len</B> is zero,<B> str</B> is a pointer to a C string which is terminated by a null character, and the length of
the buffer is the length of the string.
<LI>If<B> len</B> is negative, the buffer is unbounded.&nbsp; This last form should be used with extreme caution, since no
buffer is truly unlimited in size and it would be easy to write beyond the available space.
<LI>If the<B> pstart</B> parameter is<TT> NULL</TT>, the<TT> strstreambase</TT> object is read-only.
<LI>Otherwise,<B> pstart</B> divides the buffer into two regions.&nbsp; The<B> get area</B> starts at<B> str</B> and ends
at<B> pstart</B>-1.&nbsp; The<B> put area</B> starts at<B> pstart</B> and goes to the end of the buffer.
</OL>
<DT>Results:
<DD>The protected<TT> strstreambase</TT> constructor creates an initialized<TT> strstreambase</TT> object.
<DT>See Also:
<DD><TT> ~strstreambase</TT>
</DL>
<H2 ID="strstreambase____strstreambaseLR"> ~strstreambase() [strstreambase] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;strstrea.h&gt;</TT>
<BR><TT>protected:</TT>
<BR><TT>strstreambase::~strstreambase();</TT>
<DT>Semantics:
<DD>The protected<TT> ~strstreambase</TT> destructor does not do anything explicit.&nbsp; The call to the protected<TT> ~strstreambase</TT>
destructor is inserted implicitly by the compiler at the point where the<TT> strstreambase</TT> object goes out of scope.
<DT>Results:
<DD>The<TT> strstreambase</TT> object is destroyed.
<DT>See Also:
<DD><TT> strstreambase</TT>
</DL>
<H2 ID="strstreambuf_Class_Description"> strstreambuf Class Description </H2>
<DL>
<DT>Declared:
<DD><TT> strstrea.h</TT>
<DT>Derived from:
<DD><TT> streambuf</TT>
<BR><BR>The<TT> strstreambuf</TT> class is derived from the<TT> streambuf</TT> class and provides additional functionality
required to write characters to and read characters from a string buffer.&nbsp; Read and write operations can occur at different
positions in the string buffer, since the<B> get pointer</B> and<B> put pointer</B> are not necessarily connected.&nbsp; Seek
operations are also supported.
<BR>The<B> reserve area</B> used by the<TT> strstreambuf</TT> object may be either fixed in size or dynamic.&nbsp; Generally,
input strings are of a fixed size, while output streams are dynamic, since the final size may not be predictable.&nbsp; For
dynamic buffers, the<TT> strstreambuf</TT> object automatically grows the buffer when necessary.
<BR><BR>The<TT> strstreambuf</TT> class differs quite markedly from the<TT> filebuf</TT> and<TT> stdiobuf</TT> classes.&nbsp;
Since there is no actual source or destination for the characters in<TT> strstream</TT> objects, the buffer itself takes on
that role.&nbsp; When writing is occurring and the<B> put area</B> is full, the<TT> overflow</TT> virtual member function
reallocates the buffer to a larger size (if possible), the<B> put area</B> is extended and the writing continues.&nbsp; If
reading is occurring and the<B> get area</B> is empty, the<TT> underflow</TT> virtual member function checks to see if the<B>
put area</B> is present and not empty.&nbsp; If so, the<B> get area</B> is extended to overlap the<B> put area</B>.
<BR><BR>C++ programmers who wish to use string streams without deriving new objects will probably never explicitly create
or use a<TT> strstreambuf</TT> object.
<BR><BR><B>Protected Member Functions</B>
<BR><BR>The following member function is declared in the protected interface:
<BR><BR><TT>virtual int doallocate();</TT>
<BR><BR><B>Public Member Functions</B>
<BR><BR>The following member functions are declared in the public interface:
<BR><BR><TT>strstreambuf();</TT>
<BR><TT> strstreambuf( int );</TT>
<BR><TT> strstreambuf( void *(*)( long ), void (*)( void * ) );</TT>
<BR><TT> strstreambuf( char *, int, char * = 0 );</TT>
<BR><TT> ~strstreambuf();</TT>
<BR><TT> int alloc_size_increment( int );</TT>
<BR><TT> void freeze( int = 1 );</TT>
<BR><TT> char *str();</TT>
<BR><TT> virtual int overflow( int = EOF );</TT>
<BR><TT> virtual int underflow();</TT>
<BR><TT> virtual streambuf *setbuf( char *, int );</TT>
<BR><TT> virtual streampos seekoff( streamoff,</TT>
<BR><TT> ios::seekdir,</TT>
<BR><TT>ios::openmode );</TT>
<BR><TT>virtual int sync();</TT>
<DT>See Also:
<DD><TT> streambuf</TT>,<TT> strstreambase</TT>
</DL>
<H2 ID="strstreambuf__alloc_size_incrementLR"> alloc_size_increment() [strstreambuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;strstrea.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int strstreambuf::alloc_size_increment( int increment );</TT>
<DT>Semantics:
<DD>The<TT> alloc_size_increment</TT> public member function modifies the allocation size used when the buffer is first allocated
or reallocated by dynamic allocation.&nbsp; The<B> increment</B> parameter is added to the previous allocation size for future
use.
<BR><BR>This function is a WATCOM extension.
<DT>Results:
<DD>The<TT> alloc_size_increment</TT> public member function returns the previous value of the allocation size.
<DT>See Also:
<DD><TT> strstreambuf::doallocate</TT>,<TT> setbuf</TT>
</DL>
<H2 ID="strstreambuf__doallocateLR"> doallocate() [strstreambuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;strstrea.h&gt;</TT>
<BR><TT>protected:</TT>
<BR><TT>virtual int strstreambuf::doallocate();</TT>
<DT>Semantics:
<DD>The<TT> doallocate</TT> protected virtual member function is called by the<TT> allocate</TT> member function when it is determined
that the<B> put area</B> is full and needs to be extended.
<BR><BR>The<TT> doallocate</TT> protected virtual member function performs the following steps:
<OL>
<LI>If dynamic allocation is not being used, the<TT> doallocate</TT> protected virtual member function fails.
<LI>A new size for the buffer is determined.&nbsp; If the allocation size is bigger than the current size, the allocation
size is used.&nbsp; Otherwise, the buffer size is increased by<TT> DEFAULT_MAINBUF_SIZE</TT>, which is 512.
<LI>A new buffer is allocated.&nbsp; If an allocation function was specified in the constructor for the<TT> strstreambuf</TT>
object, that allocation function is used, otherwise the<TT> operator new</TT> intrinsic function is used.&nbsp; If the allocation
fails, the<TT> doallocate</TT> protected virtual member function fails.
<LI>If necessary, the contents of the<B> get area</B> are copied to the newly allocated buffer and the<B> get area</B> pointers
are adjusted accordingly.
<LI>The contents of the<B> put area</B> are copied to the newly allocated buffer and the<B> put area</B> pointers are adjusted
accordingly, extending the<B> put area</B> to the end of the new buffer.
<LI>The old buffer is freed.&nbsp; If a free function was specified in the constructor for the<TT> strstreambuf</TT> object,
that free function is used, otherwise the<TT> operator delete</TT> intrinsic function is used.
</OL>
<DT>Results:
<DD>The<TT> doallocate</TT> protected virtual member function returns<TT> __NOT_EOF</TT> on success, otherwise<TT> EOF</TT> is
returned.
<DT>See Also:
<DD><TT> strstreambuf::alloc_size_increment</TT>,<TT> setbuf</TT>
</DL>
<H2 ID="strstreambuf__freezeLR"> freeze() [strstreambuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;strstrea.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void strstreambuf::freeze( int frozen = 1 );</TT>
<DT>Semantics:
<DD>The<TT> freeze</TT> public member function enables and disables automatic deletion of the<B> reserve area</B>.&nbsp; If the<TT>
freeze</TT> public member function is called with no parameter or a non-zero parameter, the<TT> strstreambuf</TT> object is
frozen.&nbsp; If the<TT> freeze</TT> public member function is called with a zero parameter, the<TT> strstreambuf</TT> object
is unfrozen.
<BR><BR>A frozen<TT> strstreambuf</TT> object does not free the<B> reserve area</B> in the destructor.&nbsp; If the<TT> strstreambuf</TT>
object is destroyed while it is frozen, it is the program's responsibility to also free the<B> reserve area</B>.
<BR><BR>If characters are written to the<TT> strstreambuf</TT> object while it is frozen, the effect is undefined since the<B>
reserve area</B> may be reallocated and therefore may move.&nbsp; However, if the<TT> strstreambuf</TT> object is frozen and
then unfrozen, characters may be written to it.
<DT>Results:
<DD>The<TT> freeze</TT> public member function returns the previous frozen state.
<DT>See Also:
<DD><TT> strstreambuf::str</TT>,<TT> ~strstreambuf</TT>
</DL>
<H2 ID="strstreambuf__overflowLR"> overflow() [strstreambuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;strstrea.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>virtual int strstreambuf::overflow( int ch = EOF );</TT>
<DT>Semantics:
<DD>The<TT> overflow</TT> public virtual member function provides the output communication between the<TT> streambuf</TT> member
functions and the<TT> strstreambuf</TT> object.&nbsp; Member functions in the<TT> streambuf</TT> class call the<TT> overflow</TT>
public virtual member function when the<B> put area</B> is full.&nbsp; The<TT> overflow</TT> public virtual member function
attempts to grow the<B> put area</B> so that writing may continue.
<BR><BR>The<TT> overflow</TT> public virtual member function performs the following steps:
<OL>
<LI>If dynamic allocation is not being used, the<B> put area</B> cannot be extended, so the<TT> overflow</TT> public virtual
member function fails.
<LI>If dynamic allocation is being used, a new buffer is allocated using the<TT> doallocate</TT> member function.&nbsp; It
handles copying the contents of the old buffer to the new buffer and discarding the old buffer.
<LI>If the<B> ch</B> parameter is not<TT> EOF</TT>, it is added to the end of the extended<B> put area</B> and the<B> put
pointer</B> is advanced.
</OL>
<DT>Results:
<DD>The<TT> overflow</TT> public virtual member function returns<TT> __NOT_EOF</TT> when it successfully extends the<B> put area</B>,
otherwise<TT> EOF</TT> is returned.
<DT>See Also:
<DD><TT> streambuf::overflow</TT>
<BR><BR><TT>strstreambuf::underflow</TT>
</DL>
<H2 ID="strstreambuf__seekoffLR"> seekoff() [strstreambuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;strstrea.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>virtual streampos strstreambuf::seekoff( streamoff offset,</TT>
<BR><TT> ios::seekdir dir,</TT>
<BR><TT>ios::openmode mode );</TT>
<DT>Semantics:
<DD>The<TT> seekoff</TT> public virtual member function positions the<B> get pointer</B> and/or<B> put pointer</B> to the specified
position in the<B> reserve area</B>.&nbsp; If the<B> get pointer</B> is moved, it is moved to a position relative to the start
of the<B> reserve area</B> (which is also the start of the<B> get area</B>).&nbsp; If a position is specified that is beyond
the end of the<B> get area</B> but is in the<B> put area</B>, the<B> get area</B> is extended to include the<B> put area</B>.
&nbsp;If the<B> put pointer</B> is moved, it is moved to a position relative to the start of the<B> put area</B>,<B> not</B>
relative to the start of the<B> reserve area</B>.
<BR><BR>The<TT> seekoff</TT> public virtual member function seeks<B> offset</B> bytes from the position specified by the<B>
dir</B> parameter.
<BR><BR>The<B> mode</B> parameter may be<TT> ios::in</TT>,<TT> ios::out</TT>, or<TT> ios::in|ios::out</TT> and should be interpreted
as follows, provided the interpretation is meaningful:
<BR><BR><TT>ios::in</TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the <B>get pointer</B> should
be moved.
<BR><TT>ios::out</TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the <B>put pointer</B> should be moved.
<BR><TT>ios::in|ios::out</TT>&nbsp;&nbsp;&nbsp; both the <B>get pointer</B> and the <B>put pointer</B> should be moved.
<BR><BR>If<B> mode</B> has any other value, the<TT> seekoff</TT> public virtual member function fails.<TT>&nbsp; ios::in|ios::out</TT>
is not valid if the<B> dir</B> parameter is<TT> ios::cur</TT>.
<BR>The<B> dir</B> parameter may be<TT> ios::beg</TT>,<TT> ios::cur</TT>, or<TT> ios::end</TT> and is interpreted in conjunction
with the<B> offset</B> parameter as follows:
<BR><BR><TT>ios::beg</TT>&nbsp; the <B>offset</B> is relative to the start and should be a positive value.
<BR><TT>ios::cur</TT>&nbsp; the <B>offset</B> is relative to the current position and may be positive
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (seek towards end) or negative (seek towards start).
<BR><TT>ios::end</TT>&nbsp; the <B>offset</B> is relative to the end and should be a negative value.
<BR><BR>If the<B> dir</B> parameter has any other value, or the<B> offset</B> parameter does not have an appropriate sign,
the<TT> seekoff</TT> public virtual member function fails.
<DT>Results:
<DD>The<TT> seekoff</TT> public virtual member function returns the new position in the file on success, otherwise<TT> EOF</TT>
is returned.&nbsp; If both or<TT> ios::in|ios::out</TT> are specified and the<B> dir</B> parameter is<TT> ios::cur</TT> the
returned position refers to the<B> put pointer</B>.
</DL>
<H2 ID="strstreambuf__setbufLR"> setbuf() [strstreambuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;strstrea.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>virtual streambuf *strstreambuf::setbuf( char *, int size );</TT>
<DT>Semantics:
<DD>The<TT> setbuf</TT> public virtual member function is used to control the size of the allocations when the<TT> strstreambuf</TT>
object is using dynamic allocation.&nbsp; The first parameter is ignored.&nbsp; The next time an allocation is required, at
least the number of characters specified in the<B> size</B> parameter is allocated.&nbsp; If the specified size is not sufficient,
the allocation reverts to its default behavior, which is to extend the buffer by<TT> DEFAULT_MAINBUF_SIZE</TT>, which is 512
characters.
<BR><BR>If a program is going to write a large number of characters to the<TT> strstreambuf</TT> object, it should call the<TT>
setbuf</TT> public virtual member function to indicate the size of the next allocation, to prevent multiple allocations as
the buffer gets larger.
<DT>Results:
<DD>The<TT> setbuf</TT> public virtual member function returns a pointer to the<TT> strstreambuf</TT> object.
<DT>See Also:
<DD><TT> strstreambuf::alloc_size_increment</TT>,<TT> doallocate</TT>
</DL>
<H2 ID="strstreambuf__strLR"> str() [strstreambuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;strstrea.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>char *strstreambuf::str();</TT>
<DT>Semantics:
<DD>The<TT> str</TT> public member function freezes the<TT> strstreambuf</TT> object and returns a pointer to the<B> reserve area</B>.
&nbsp;This pointer remains valid after the<TT> strstreambuf</TT> object is destroyed provided the<TT> strstreambuf</TT> object
remains frozen, since the destructor does not free the<B> reserve area</B> if it is frozen.
<BR><BR>The returned pointer may be<TT> NULL</TT> if the<TT> strstreambuf</TT> object is using dynamic allocation but has
not yet had anything written to it.
<BR><BR>If the<TT> strstreambuf</TT> object is not using dynamic allocation, the pointer returned by the<TT> str</TT> public
member function is the same buffer pointer provided to the constructor.&nbsp; For a<TT> strstreambuf</TT> object using dynamic
allocation, the pointer points to a dynamically allocated area.
<BR><BR>Note that the<B> reserve area</B> does not necessarily end with a null character.&nbsp; If the pointer returned by
the<TT> str</TT> public member function is to be interpreted as a C string, it is the program's responsibility to ensure that
the null character is present.
<DT>Results:
<DD>The<TT> str</TT> public member function returns a pointer to the<B> reserve area</B> and freezes the<TT> strstreambuf</TT>
object.
<DT>See Also:
<DD><TT> strstreambuf::freeze</TT>
</DL>
<H2 ID="strstreambuf__strstreambufLR"> strstreambuf() [strstreambuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;strstrea.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>strstreambuf::strstreambuf();</TT>
<DT>Semantics:
<DD>This form of the public<TT> strstreambuf</TT> constructor creates an empty<TT> strstreambuf</TT> object that uses dynamic
allocation.&nbsp; No<B> reserve area</B> is allocated to start.&nbsp; Whenever characters are written to extend the<TT> strstreambuf</TT>
object, the<B> reserve area</B> is reallocated and copied as required.&nbsp; The size of allocation is determined by the<TT>
strstreambuf</TT> object unless the<TT> setbuf</TT> or<TT> alloc_size_increment</TT> member functions are called to change
the allocation size.&nbsp; The default allocation size is determined by the constant<TT> DEFAULT_MAINBUF_SIZE</TT>, which
is 512.
<DT>Results:
<DD>This form of the public<TT> strstreambuf</TT> constructor creates a<TT> strstreambuf</TT> object.
<DT>See Also:
<DD><TT> strstreambuf::doallocate</TT>,<TT> ~strstreambuf</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;strstrea.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>strstreambuf::strstreambuf( int alloc_size );</TT>
<DT>Semantics:
<DD>This form of the public<TT> strstreambuf</TT> constructor creates an empty<TT> strstreambuf</TT> object that uses dynamic
allocation.&nbsp; No buffer is allocated to start.&nbsp; Whenever characters are written to extend the<TT> strstreambuf</TT>
object, the<B> reserve area</B> is reallocated and copied as required.&nbsp; The size of the first allocation is determined
by the<B> alloc_size</B> parameter, unless changed by a call to the<TT> setbuf</TT> or<TT> alloc_size_increment</TT> member
functions.
<BR><BR>Note that the<B> alloc_size</B> parameter is the starting<B> reserve area</B> size.&nbsp; When the<B> reserve area</B>
is reallocated, the<TT> strstreambuf</TT> object uses<TT> DEFAULT_MAINBUF_SIZE</TT> to increase the<B> reserve area</B> size,
unless the<TT> setbuf</TT> or<TT> alloc_size_increment</TT> member functions have been called to specify a new allocation
size.
<DT>Results:
<DD>This form of the public<TT> strstreambuf</TT> constructor creates a<TT> strstreambuf</TT> object.
<DT>See Also:
<DD><TT> strstreambuf::alloc_size_increment</TT>,<TT> doallocate</TT>,<TT> setbuf</TT>,<TT> ~strstreambuf</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;strstrea.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>strstreambuf::strstreambuf( void * (*alloc_fn)( long ),</TT>
<BR><TT> void (*free_fn)( void * ) );</TT>
<DT>Semantics:
<DD>This form of the public<TT> strstreambuf</TT> constructor creates an empty<TT> strstreambuf</TT> object that uses dynamic
allocation.&nbsp; No buffer is allocated to start.&nbsp; Whenever characters are written to extend the<TT> strstreambuf</TT>
object, the<B> reserve area</B> is reallocated and copied as required, using the specified<B> alloc_fn</B> and<B> free_fn</B>
functions.&nbsp; The size of allocation is determined by the class unless the<TT> setbuf</TT> or<TT> alloc_size_increment</TT>
member functions are called to change the allocation size.&nbsp; The default allocation size is determined by the constant<TT>
DEFAULT_MAINBUF_SIZE</TT>, which is 512.
<BR><BR>When a new<B> reserve area</B> is allocated, the function specified by the<B> alloc_fn</B> parameter is called with
a<TT> long integer</TT> value indicating the number of bytes to allocate.&nbsp; If<B> alloc_fn</B> is<TT> NULL</TT>, the<TT>
operator new</TT> intrinsic function is used.&nbsp; Likewise, when the<B> reserve area</B> is freed, the function specified
by the<B> free_fn</B> parameter is called with the pointer returned by the<B> alloc_fn</B> function as the parameter.&nbsp;
If<B> free_fn</B> is<TT> NULL</TT>, the<TT> operator delete</TT> intrinsic function is used.
<DT>Results:
<DD>This form of the public<TT> strstreambuf</TT> constructor creates a<TT> strstreambuf</TT> object.
<DT>See Also:
<DD><TT> strstreambuf::alloc_size_increment</TT>,<TT> doallocate</TT>,<TT> setbuf</TT>,<TT> ~strstreambuf</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;strstrea.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>strstreambuf::strstreambuf( char *str,</TT>
<BR><TT> int len,</TT>
<BR><TT>char *pstart = NULL );</TT>
<BR><TT>strstreambuf::strstreambuf( signed char *str,</TT>
<BR><TT> int len,</TT>
<BR><TT>signed char *pstart = NULL );</TT>
<BR><TT>strstreambuf::strstreambuf( unsigned char *str,</TT>
<BR><TT> int len,</TT>
<BR><TT>unsigned char *pstart = NULL );</TT>
<DT>Semantics:
<DD>This form of the public<TT> strstreambuf</TT> constructor creates a<TT> strstreambuf</TT> object that does not use dynamic
allocation (unless<B> str</B> is<TT> NULL</TT>).&nbsp; The<TT> strstreambuf</TT> object is said to be using static allocation.
&nbsp;The<B> str</B> and<B> len</B> parameters specify the bounds of the<B> reserve area</B>.
<BR><BR>The<B> str</B>,<B> len</B> and<B> pstart</B> parameters are interpreted as follows:
<OL>
<LI>The buffer starts at<B> str</B>.
<LI>If<B> len</B> is positive, the buffer is<B> len</B> characters long.
<LI>If<B> len</B> is zero,<B> str</B> is a pointer to a C string which is terminated by a null character, and the length of
the buffer is the length of the string.
<LI>If<B> len</B> is negative, the buffer is unbounded.&nbsp; This last form should be used with extreme caution, since no
buffer is truly unlimited in size and it would be easy to write beyond the available space.
<LI>If the<B> pstart</B> parameter is<TT> NULL</TT>, the<TT> strstreambuf</TT> object is read-only.
<LI>Otherwise,<B> pstart</B> divides the buffer into two regions.&nbsp; The<B> get area</B> starts at<B> str</B> and ends
at<B> pstart</B>-1.&nbsp; The<B> put area</B> starts at<B> pstart</B> and goes to the end of the buffer.
</OL>
<BR>If the<B> get area</B> is exhausted and characters have been written to the<B> put area</B>, the<B> get area</B> is extended
to include the<B> put area</B>.
<BR><BR>The<B> get pointer</B> and<B> put pointer</B> do not necessarily point at the same position in the<B> reserve area</B>,
so a read followed by a write does not imply that the write stores following the last character read.&nbsp; The<B> get pointer</B>
is positioned following the last read operation, and the<B> put pointer</B> is positioned following the last write operation,
unless the<TT> seekoff</TT> member function has been used to reposition the pointer(s).
<BR><BR>Note that if<B> str</B> is<TT> NULL</TT> the effect is to create an empty dynamic<TT> strstreambuf</TT> object.
<DT>Results:
<DD>This form of the public<TT> strstreambuf</TT> constructor creates a<TT> strstreambuf</TT> object.
<DT>See Also:
<DD><TT> ~strstreambuf</TT>
</DL>
<H2 ID="strstreambuf____strstreambufLR"> ~strstreambuf() [strstreambuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;strstrea.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>strstreambuf::~strstreambuf();</TT>
<DT>Semantics:
<DD>The public<TT> ~strstreambuf</TT> destructor destroys the<TT> strstreambuf</TT> object after discarding the<B> reserve area</B>.
&nbsp;The<B> reserve area</B> is discarded only if the<TT> strstreambuf</TT> object is using dynamic allocation and is not
frozen.&nbsp; The<B> reserve area</B> is freed using the free function specified by the form of the constructor that allows
specification of the allocate and free functions, or using the<TT> operator delete</TT> intrinsic function.&nbsp; If the<TT>
strstreambuf</TT> object is frozen or using static allocation, the user of the<TT> strstreambuf</TT> object must have a pointer
to the<B> reserve area</B> and is responsible for freeing it.&nbsp; The call to the public<TT> ~strstreambuf</TT> destructor
is inserted implicitly by the compiler at the point where the<TT> strstreambuf</TT> object goes out of scope.
<DT>Results:
<DD>The<TT> strstreambuf</TT> object is destroyed.
<DT>See Also:
<DD><TT> strstreambuf</TT>
</DL>
<H2 ID="strstreambuf__syncLR"> sync() [strstreambuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;strstrea.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>virtual int strstreambuf::sync();</TT>
<DT>Semantics:
<DD>The<TT> sync</TT> public virtual member function does nothing because there is no external device with which to synchronize.
<DT>Results:
<DD>The<TT> sync</TT> public virtual member function returns<TT> __NOT_EOF</TT>.
</DL>
<H2 ID="strstreambuf__underflowLR"> underflow() [strstreambuf] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;strstrea.h&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>virtual int strstreambuf::underflow();</TT>
<DT>Semantics:
<DD>The<TT> underflow</TT> public virtual member function provides the input communication between the<TT> streambuf</TT> member
functions and the<TT> strstreambuf</TT> object.&nbsp; Member functions in the<TT> streambuf</TT> class call the<TT> underflow</TT>
public virtual member function when the<B> get area</B> is empty.
<BR><BR>If there is a non-empty<B> put area</B> present following the<B> get area</B>, the<B> get area</B> is extended to
include the<B> put area</B>, allowing the input operation to continue using the<B> put area</B>.&nbsp; Otherwise the<B> get
area</B> cannot be extended.
<DT>Results:
<DD>The<TT> underflow</TT> public virtual member function returns the first available character in the<B> get area</B> on successful
extension, otherwise<TT> EOF</TT> is returned.
<DT>See Also:
<DD><TT> streambuf::underflow</TT>
<BR><BR><TT>strstreambuf::overflow</TT>
</DL>
<H1 ID="String_Class"> String Class </H1>
<BR>This class is used to store arbitrarily long sequences of characters in memory.&nbsp; Objects of this type may be concatenated,
substringed, compared and searched without the need for memory management by the user.&nbsp; Unlike a C string, this object
has no delimiting character, so any character in the collating sequence, or character set, may be stored in an object.
<BR><BR>The class documented here is the Open Watcom legacy string class.&nbsp; It is not related to the<TT> std::basic_string</TT>
class template nor to its corresponding specialization<TT> std::string.</TT>
<H2 ID="String_Class_Description"> String Class Description </H2>
<DL>
<DT>Declared:
<DD><TT> string.hpp</TT>
<BR><BR>The<TT> String</TT> class is used to store arbitrarily long sequences of characters in memory.&nbsp; Objects of this
type may be concatenated, substringed, compared and searched without the need for memory management by the user.&nbsp; Unlike
a C string, a<TT> String</TT> object has no delimiting character, so any character in the collating sequence, or character
set, may be stored in a<TT> String</TT> object.
<BR><BR><B>Public Functions</B>
<BR><BR>The following constructors and destructors are declared:
<BR><BR><TT>String();</TT>
<BR><TT> String( size_t, capacity );</TT>
<BR><TT> String( String const &amp;, size_t = 0, size_t = NPOS );</TT>
<BR><TT> String( char const *, size_t = NPOS );</TT>
<BR><TT> String( char, size_t = 1 );</TT>
<BR><TT> ~String();</TT>
<BR><BR>The following member functions are declared:
<BR><BR><TT>operator char const *();</TT>
<BR><TT> operator char() const;</TT>
<BR><TT> String &amp;operator =( String const &amp; );</TT>
<BR><TT> String &amp;operator =( char const * );</TT>
<BR><TT> String &amp;operator +=( String const &amp; );</TT>
<BR><TT> String &amp;operator +=( char const * );</TT>
<BR><TT> String operator ()( size_t, size_t ) const;</TT>
<BR><TT> char &amp;operator ()( size_t );</TT>
<BR><TT> char const &amp;operator []( size_t ) const;</TT>
<BR><TT> char &amp;operator []( size_t );</TT>
<BR><TT> int operator !() const;</TT>
<BR><TT> size_t length() const;</TT>
<BR><TT> char const &amp;get_at( size_t ) const;</TT>
<BR><TT> void put_at( size_t, char );</TT>
<BR><TT> int match( String const &amp; ) const;</TT>
<BR><TT> int match( char const * ) const;</TT>
<BR><TT> int index( String const &amp;, size_t = 0 ) const;</TT>
<BR><TT> int index( char const *, size_t = 0 ) const;</TT>
<BR><TT> String upper() const;</TT>
<BR><TT> String lower() const;</TT>
<BR><TT> int valid() const;</TT>
<BR><TT> int alloc_mult_size() const;</TT>
<BR><TT> int alloc_mult_size( int );</TT>
<BR><BR>The following friend functions are declared:
<BR><BR><TT>friend int&nbsp;&nbsp;&nbsp; operator ==( String const &amp;, String const &amp; );</TT>
<BR><TT>friend int&nbsp;&nbsp;&nbsp; operator ==( String const &amp;,&nbsp;&nbsp; char const * );</TT>
<BR><TT>friend int&nbsp;&nbsp;&nbsp; operator ==(&nbsp;&nbsp; char const *, String const &amp; );</TT>
<BR><TT>friend int&nbsp;&nbsp;&nbsp; operator ==( String const &amp;,&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; );</TT>
<BR><TT>friend int&nbsp;&nbsp;&nbsp; operator ==(&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; , String const
&amp; );</TT>
<BR><TT>friend int&nbsp;&nbsp;&nbsp; operator !=( String const &amp;, String const &amp; );</TT>
<BR><TT>friend int&nbsp;&nbsp;&nbsp; operator !=( String const &amp;,&nbsp;&nbsp; char const * );</TT>
<BR><TT>friend int&nbsp;&nbsp;&nbsp; operator !=(&nbsp;&nbsp; char const *, String const &amp; );</TT>
<BR><TT>friend int&nbsp;&nbsp;&nbsp; operator !=( String const &amp;,&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; );</TT>
<BR><TT>friend int&nbsp;&nbsp;&nbsp; operator !=(&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; , String const
&amp; );</TT>
<BR><TT>friend int&nbsp;&nbsp;&nbsp; operator&nbsp; &lt;( String const &amp;, String const &amp; );</TT>
<BR><TT>friend int&nbsp;&nbsp;&nbsp; operator&nbsp; &lt;( String const &amp;,&nbsp;&nbsp; char const * );</TT>
<BR><TT>friend int&nbsp;&nbsp;&nbsp; operator&nbsp; &lt;(&nbsp;&nbsp; char const *, String const &amp; );</TT>
<BR><TT>friend int&nbsp;&nbsp;&nbsp; operator&nbsp; &lt;( String const &amp;,&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; );</TT>
<BR><TT>friend int&nbsp;&nbsp;&nbsp; operator&nbsp; &lt;(&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; , String
const &amp; );</TT>
<BR><TT>friend int&nbsp;&nbsp;&nbsp; operator &lt;=( String const &amp;, String const &amp; );</TT>
<BR><TT>friend int&nbsp;&nbsp;&nbsp; operator &lt;=( String const &amp;,&nbsp;&nbsp; char const * );</TT>
<BR><TT>friend int&nbsp;&nbsp;&nbsp; operator &lt;=(&nbsp;&nbsp; char const *, String const &amp; );</TT>
<BR><TT>friend int&nbsp;&nbsp;&nbsp; operator &lt;=( String const &amp;,&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; );</TT>
<BR><TT>friend int&nbsp;&nbsp;&nbsp; operator &lt;=(&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; , String const
&amp; );</TT>
<BR><TT>friend int&nbsp;&nbsp;&nbsp; operator&nbsp; &gt;( String const &amp;, String const &amp; );</TT>
<BR><TT>friend int&nbsp;&nbsp;&nbsp; operator&nbsp; &gt;( String const &amp;,&nbsp;&nbsp; char const * );</TT>
<BR><TT>friend int&nbsp;&nbsp;&nbsp; operator&nbsp; &gt;(&nbsp;&nbsp; char const *, String const &amp; );</TT>
<BR><TT>friend int&nbsp;&nbsp;&nbsp; operator&nbsp; &gt;( String const &amp;,&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; );</TT>
<BR><TT>friend int&nbsp;&nbsp;&nbsp; operator&nbsp; &gt;(&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; , String
const &amp; );</TT>
<BR><TT>friend int&nbsp;&nbsp;&nbsp; operator &gt;=( String const &amp;, String const &amp; );</TT>
<BR><TT>friend int&nbsp;&nbsp;&nbsp; operator &gt;=( String const &amp;,&nbsp;&nbsp; char const * );</TT>
<BR><TT>friend int&nbsp;&nbsp;&nbsp; operator &gt;=(&nbsp;&nbsp; char const *, String const &amp; );</TT>
<BR><TT>friend int&nbsp;&nbsp;&nbsp; operator &gt;=( String const &amp;,&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; );</TT>
<BR><TT>friend int&nbsp;&nbsp;&nbsp; operator &gt;=(&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; , String const
&amp; );</TT>
<BR><TT>friend String operator&nbsp; +(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String &amp;, String const &amp; );</TT>
<BR><TT>friend String operator&nbsp; +(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String &amp;,&nbsp;&nbsp; char const * );</TT>
<BR><TT>friend String operator&nbsp; +(&nbsp;&nbsp; char const *, String const &amp; );</TT>
<BR><TT>friend String operator&nbsp; +(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String &amp;,&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; );</TT>
<BR><TT>friend String operator&nbsp; +(&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; , String const &amp; );</TT>
<BR><TT>friend int valid( String const &amp; );</TT>
<BR><BR>The following I/O Stream inserter and extractor functions are declared:
<BR><BR><TT>friend istream &amp;operator &gt;&gt;( istream &amp;, String &amp; );</TT>
<BR><TT>friend ostream &amp;operator &lt;&lt;( ostream &amp;, String const &amp; );</TT>
</DL>
<H2 ID="String__alloc_mult_sizeLR"> alloc_mult_size() [String] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.hpp&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int String::alloc_mult_size() const;</TT>
<BR><TT> int String::alloc_mult_size( int mult );</TT>
<DT>Semantics:
<DD>The<TT> alloc_mult_size</TT> public member function is used to query and/or change the allocation multiple size.
<BR><BR>The first form of the<TT> alloc_mult_size</TT> public member function queries the current setting.
<BR><BR>The second form of the<TT> alloc_mult_size</TT> public member function sets the value to a multiple of 8 based on
the<B> mult</B> parameter.&nbsp; The value of<B> mult</B> is rounded down to a multiple of 8 characters.&nbsp; If<B> mult</B>
is less than 8, the new multiple size is 1 and allocation sizes are exact.
<BR><BR>The scheme used to store a<TT> String</TT> object allocates the memory for the characters in multiples of some size.
&nbsp;By default, this size is 8 characters.&nbsp; A<TT> String</TT> object with a length of 10 actually has 16 characters
of storage allocated for it.&nbsp; Concatenating more characters on the end of the<TT> String</TT> object only allocates a
new storage block if more than 6 (16-10) characters are appended.&nbsp; This scheme tries to find a balance between reallocating
frequently (multiples of a small value) and creating a large amount of unused space (multiples of a large value).
<DT>Results:
<DD>The<TT> alloc_mult_size</TT> public member function returns the previous allocation multiple size.
</DL>
<H2 ID="String__get_atLR"> get_at() [String] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.hpp&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>char const &amp;String::get_at( size_t pos );</TT>
<DT>Semantics:
<DD>The<TT> get_at</TT> public member function creates a const reference to the character at offset<B> pos</B> within the<TT>
String</TT> object.&nbsp; This reference may not be used to modify that character.&nbsp; The first character of a<TT> String</TT>
object is at position zero.
<BR><BR>If<B> pos</B> is greater than or equal to the length of the<TT> String</TT> object, and the resulting reference is
used, the behavior is undefined.
<BR><BR>The reference is associated with the<TT> String</TT> object, and therefore has meaning only as long as the<TT> String</TT>
object is not modified (or destroyed).&nbsp; If the<TT> String</TT> object has been modified and an old reference is used,
the behavior is undefined.
<DT>Results:
<DD>The<TT> get_at</TT> public member function returns a const reference to a character.
<DT>See Also:
<DD><TT> String::put_at</TT>,<TT> operator []</TT>,<TT> operator ()</TT>
</DL>
<H2 ID="String__indexLR"> index() [String] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.hpp&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int String::index( String const &amp;str, size_t pos = 0 ) const;</TT>
<BR><TT> int String::index( char const *pch, size_t pos = 0 ) const;</TT>
<DT>Semantics:
<DD>The<TT> index</TT> public member function computes the offset at which a sequence of characters in the<TT> String</TT> object
is found.
<BR><BR>The first form searches the<TT> String</TT> object for the contents of the<B> str</B><TT> String</TT> object.
<BR><BR>The second form searches the<TT> String</TT> object for the sequence of characters pointed at by<B> pch</B>.
<BR><BR>If<B> pos</B> is specified, the search begins at that offset from the start of the<TT> String</TT> object.&nbsp; Otherwise,
the search begins at offset zero (the first character).
<BR><BR>The<TT> index</TT> public member function treats upper and lower case letters as not equal.
<DT>Results:
<DD>The<TT> index</TT> public member function returns the offset at which the sequence of characters is found.&nbsp; If the substring
is not found, -1 is returned.
<DT>See Also:
<DD><TT> String::lower</TT>,<TT> operator !=</TT>,<TT> operator ==</TT>,<TT> match</TT>,<TT> upper</TT>
</DL>
<H2 ID="String__lengthLR"> length() [String] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.hpp&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>size_t String::length() const;</TT>
<DT>Semantics:
<DD>The<TT> length</TT> public member function computes the number of characters contained in the<TT> String</TT> object.
<DT>Results:
<DD>The<TT> length</TT> public member function returns the number of characters contained in the<TT> String</TT> object.
</DL>
<H2 ID="String__lowerLR"> lower() [String] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.hpp&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>String String::lower() const;</TT>
<DT>Semantics:
<DD>The<TT> lower</TT> public member function creates a<TT> String</TT> object whose value is the same as the original object's
value, except that all upper-case letters have been converted to lower-case.
<DT>Results:
<DD>The<TT> lower</TT> public member function returns a lower-case<TT> String</TT> object.
<DT>See Also:
<DD><TT> String::upper</TT>
</DL>
<H2 ID="String__matchLR"> match() [String] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.hpp&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int String::match( String const &amp;str ) const;</TT>
<BR><TT> int String::match( char const *pch ) const;</TT>
<DT>Semantics:
<DD>The<TT> match</TT> public member function compares two character sequences to find the offset where they differ.
<BR><BR>The first form compares the<TT> String</TT> object to the<B> str</B><TT> String</TT> object.
<BR><BR>The second form compares the<TT> String</TT> object to the<B> pch</B> C string.
<BR><BR>The first character is at offset zero.&nbsp; The<TT> match</TT> public member function treats upper and lower case
letters as not equal.
<DT>Results:
<DD>The<TT> match</TT> public member function returns the offset at which the two character sequences differ.&nbsp; If the character
sequences are equal, -1 is returned.
<DT>See Also:
<DD><TT> String::index</TT>,<TT> lower</TT>,<TT> operator !=</TT>,<TT> operator ==</TT>,<TT> upper</TT>
</DL>
<H2 ID="String__operator__LR"> operator !() [String] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.hpp&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int String::operator !() const;</TT>
<DT>Semantics:
<DD>The<TT> operator !</TT>&nbsp; public member function tests the validity of the<TT> String</TT> object.
<DT>Results:
<DD>The<TT> operator !</TT>&nbsp; public member function returns a non-zero value if the<TT> String</TT> object is invalid, otherwise
zero is returned.
<DT>See Also:
<DD><TT> String::valid</TT>,<TT> valid</TT>
</DL>
<H2 ID="String_operator__ELR"> String operator !=() [String] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.hpp&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>friend int operator !=( String const &amp;lft, String const &amp;rht );</TT>
<BR><TT>friend int operator !=( String const &amp;lft, char const *rht );</TT>
<BR><TT>friend int operator !=( char const *lft, String const &amp;rht );</TT>
<BR><TT>friend int operator !=( String const &amp;lft, char rht );</TT>
<BR><TT>friend int operator !=( char lft, String const &amp;rht );</TT>
<DT>Semantics:
<DD>The<TT> operator !=</TT> function compares two sequences of characters in terms of an<B> inequality</B> relationship.
<BR><BR>A<TT> String</TT> object is different from another<TT> String</TT> object if the lengths are different or they contain
different sequences of characters.&nbsp; A<TT> String</TT> object and a C string are different if their lengths are different
or they contain a different sequence of characters.&nbsp; A C string is terminated by a null character.&nbsp; A<TT> String</TT>
object and a character are different if the<TT> String</TT> object does not contain only the character.&nbsp; Upper-case and
lower-case characters are considered different.
<DT>Results:
<DD>The<TT> operator !=</TT> function returns a non-zero value if the lengths or sequences of characters in the<B> lft</B> and<B>
rht</B> parameter are different, otherwise zero is returned.
<DT>See Also:
<DD><TT> String::operator ==</TT>,<TT> operator &lt;</TT>,<TT> operator &lt;=</TT>,<TT> operator &gt;</TT>,<TT> operator &gt;=</TT>
</DL>
<H2 ID="String__operator_LRLR"> operator ()() [String] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.hpp&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>char &amp;String::operator ()( size_t pos );</TT>
<DT>Semantics:
<DD>The<TT> operator ()</TT> public member function creates a reference to the character at offset<B> pos</B> within the<TT> String</TT>
object.&nbsp; This reference may be used to modify that character.&nbsp; The first character of a<TT> String</TT> object is
at position zero.
<BR><BR>If<B> pos</B> is greater than or equal to the length of the<TT> String</TT> object, and the resulting reference is
used, the behavior is undefined.
<BR><BR>If the reference is used to modify other characters within the<TT> String</TT> object, the behavior is undefined.
<BR><BR>The reference is associated with the<TT> String</TT> object, and therefore has meaning only as long as the<TT> String</TT>
object is not modified (or destroyed).&nbsp; If the<TT> String</TT> object has been modified and an old reference is used,
the behavior is undefined.
<DT>Results:
<DD>The<TT> operator ()</TT> public member function returns a reference to a character.
<DT>See Also:
<DD><TT> String::operator []</TT>,<TT> operator char</TT>,<TT> operator char const *</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.hpp&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>String String::operator ()( size_t pos, size_t len ) const;</TT>
<DT>Semantics:
<DD>This form of the<TT> operator ()</TT> public member function extracts a sub-sequence of characters from the<TT> String</TT>
object.&nbsp; A new<TT> String</TT> object is created that contains the sub-sequence of characters.&nbsp; The sub-sequence
begins at offset<B> pos</B> within the<TT> String</TT> object and continues for<B> len</B> characters.&nbsp; The first character
of a<TT> String</TT> object is at position zero.
<BR><BR>If<B> pos</B> is greater than or equal to the length of the<TT> String</TT> object, the result is empty.
<BR><BR>If<B> len</B> is such that<B> pos</B> +<B> len</B> exceeds the length of the object, the result is the sub-sequence
of characters from the<TT> String</TT> object starting at offset<B> pos</B> and running to the end of the<TT> String</TT>
object.
<DT>Results:
<DD>The<TT> operator ()</TT> public member function returns a<TT> String</TT> object.
<DT>See Also:
<DD><TT> String::operator []</TT>,<TT> operator char</TT>,<TT> operator char const *</TT>
</DL>
<H2 ID="String_operator_PLR"> String operator +() [String] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.hpp&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>friend String operator +( String &amp;lft, String const &amp;rht );</TT>
<BR><TT>friend String operator +( String &amp;lft, char const *rht );</TT>
<BR><TT>friend String operator +( char const *lft, String const &amp;rht );</TT>
<BR><TT>friend String operator +( String &amp;lft, char rht );</TT>
<BR><TT>friend String operator +( char lft, String const &amp;rht );</TT>
<DT>Semantics:
<DD>The<TT> operator +</TT> function concatenates two sequences of characters into a new<TT> String</TT> object.&nbsp; The new<TT>
String</TT> object contains the sequence of characters from the<B> lft</B> parameter followed by the sequence of characters
from the<B> rht</B> parameter.
<BR><BR>A<TT> NULL</TT> pointer to a C string is treated as a pointer to an empty C string.
<DT>Results:
<DD>The<TT> operator +</TT> function returns a new<TT> String</TT> object that contains the characters from the<B> lft</B> parameter
followed by the characters from the<B> rht</B> parameter.
<DT>See Also:
<DD><TT> String::operator +=</TT>
</DL>
<H2 ID="String__operator_PELR"> operator +=() [String] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.hpp&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>String &amp;String::operator +=( String const &amp;str );</TT>
<BR><TT> String &amp;String::operator +=( char const *pch );</TT>
<DT>Semantics:
<DD>The<TT> operator +=</TT> public member function appends the contents of the parameter to the end of the<TT> String</TT> object.
<BR><BR>The first form of the<TT> operator +=</TT> public member function appends the contents of the<B> str</B><TT> String</TT>
object to the<TT> String</TT> object.
<BR><BR>The second form appends the null-terminated sequence of characters stored at<B> pch</B> to the<TT> String</TT> object.
&nbsp;If the<B> pch</B> parameter is<TT> NULL</TT>, nothing is appended.
<DT>Results:
<DD>The<TT> operator +=</TT> public member function returns a reference to the<TT> String</TT> object that was the target of the
assignment.
<DT>See Also:
<DD><TT> String::operator =</TT>
</DL>
<H2 ID="String_operator_XLR"> String operator &lt;() [String] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.hpp&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>friend int operator &lt;( String const &amp;lft, String const &amp;rht );</TT>
<BR><TT>friend int operator &lt;( String const &amp;lft, char const *rht );</TT>
<BR><TT>friend int operator &lt;( char const *lft, String const &amp;rht );</TT>
<BR><TT>friend int operator &lt;( String const &amp;lft, char rht );</TT>
<BR><TT>friend int operator &lt;( char lft, String const &amp;rht );</TT>
<DT>Semantics:
<DD>The<TT> operator &lt;</TT> function compares two sequences of characters in terms of a<B> less-than</B> relationship.
<BR><BR><B>lft</B> is less-than<B> rht</B> if<B> lft</B> if the characters of<B> lft</B> occur before the characters of<B>
rht</B> in the collating sequence.&nbsp; Upper-case and lower-case characters are considered different.
<DT>Results:
<DD>The<TT> operator &lt;</TT> function returns a non-zero value if the<B> lft</B> sequence of characters is less than the<B>
rht</B> sequence, otherwise zero is returned.
<DT>See Also:
<DD><TT> String::operator !=</TT>,<TT> operator ==</TT>,<TT> operator &lt;=</TT>,<TT> operator &gt;</TT>,<TT> operator &gt;=</TT>
</DL>
<H2 ID="String_operator_XXLR"> String operator &lt;&lt;() [String] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.hpp&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>friend ostream &amp;operator &lt;&lt;( ostream &amp;strm, String const &amp;str );</TT>
<DT>Semantics:
<DD>The<TT> operator &lt;&lt;</TT> function is used to write the sequence of characters in the<B> str</B><TT> String</TT> object
to the<B> strm</B><TT> ostream</TT> object.&nbsp; Like C strings, the value of the<B> str</B><TT> String</TT> object is written
to<B> strm</B> without the addition of any characters.&nbsp; No special processing occurs for any characters in the<TT> String</TT>
object that have special meaning for the<B> strm</B> object, such as carriage-returns.
<BR><BR>The underlying implementation of the<TT> operator &lt;&lt;</TT> function uses the ostream write method, which writes
unformatted characters to the output stream.&nbsp; If formatted output is required, then the programmer should make use of
the classes accessor methods, such as c_str(), and pass the resulting data item to the stream using the appropriate insert
operator.
<DT>Results:
<DD>The<TT> operator &lt;&lt;</TT> function returns a reference to the<B> strm</B> parameter.
<DT>See Also:
<DD><TT> ostream</TT>
</DL>
<H2 ID="String_operator_XELR"> String operator &lt;=() [String] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.hpp&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>friend int operator &lt;=( String const &amp;lft, String const &amp;rht );</TT>
<BR><TT>friend int operator &lt;=( String const &amp;lft, char const *rht );</TT>
<BR><TT>friend int operator &lt;=( char const *lft, String const &amp;rht );</TT>
<BR><TT>friend int operator &lt;=( String const &amp;lft, char rht );</TT>
<BR><TT>friend int operator &lt;=( char lft, String const &amp;rht );</TT>
<DT>Semantics:
<DD>The<TT> operator &lt;=</TT> function compares two sequences of characters in terms of a<B> less-than or equal</B> relationship.
<BR><BR><B>lft</B> is less-than or equal to<B> rht</B> if the characters of<B> lft</B> are equal to or occur before the characters
of<B> rht</B> in the collating sequence.&nbsp; Upper-case and lower-case characters are considered different.
<DT>Results:
<DD>The<TT> operator &lt;=</TT> function returns a non-zero value if the<B> lft</B> sequence of characters is less than or equal
to the<B> rht</B> sequence, otherwise zero is returned.
<DT>See Also:
<DD><TT> String::operator !=</TT>,<TT> operator ==</TT>,<TT> operator &lt;</TT>,<TT> operator &gt;</TT>,<TT> operator &gt;=</TT>
</DL>
<H2 ID="String__operator_ELR"> operator =() [String] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.hpp&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>String &amp;String::operator =( String const &amp;str );</TT>
<BR><TT> String &amp;String::operator =( char const *pch );</TT>
<DT>Semantics:
<DD>The<TT> operator =</TT> public member function sets the contents of the<TT> String</TT> object to be the same as the parameter.
<BR><BR>The first form of the<TT> operator =</TT> public member function sets the value of the<TT> String</TT> object to be
the same as the value of the<B> str</B><TT> String</TT> object.
<BR><BR>The second form sets the value of the<TT> String</TT> object to the null-terminated sequence of characters stored
at<B> pch</B>.&nbsp; If the<B> pch</B> parameter is<TT> NULL</TT>, the<TT> String</TT> object is empty.
<DT>Results:
<DD>The<TT> operator =</TT> public member function returns a reference to the<TT> String</TT> object that was the target of the
assignment.
<DT>See Also:
<DD><TT> String::operator +=</TT>,<TT> String</TT>
</DL>
<H2 ID="String_operator_EELR"> String operator ==() [String] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.hpp&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>friend int operator ==( String const &amp;lft, String const &amp;rht );</TT>
<BR><TT>friend int operator ==( String const &amp;lft, char const *rht );</TT>
<BR><TT>friend int operator ==( char const *lft, String const &amp;rht );</TT>
<BR><TT>friend int operator ==( String const &amp;lft, char rht );</TT>
<BR><TT>friend int operator ==( char lft, String const &amp;rht );</TT>
<DT>Semantics:
<DD>The<TT> operator ==</TT> function compares two sequences of characters in terms of an<B> equality</B> relationship.
<BR><BR>A<TT> String</TT> object is equal to another<TT> String</TT> object if they have the same length and they contain
the same sequence of characters.&nbsp; A<TT> String</TT> object and a C string are equal if their lengths are the same and
they contain the same sequence of characters.&nbsp; The C string is terminated by a null character.&nbsp; A<TT> String</TT>
object and a character are equal if the<TT> String</TT> object contains only that character.&nbsp; Upper-case and lower-case
characters are considered different.
<DT>Results:
<DD>The<TT> operator ==</TT> function returns a non-zero value if the lengths and sequences of characters in the<B> lft</B> and<B>
rht</B> parameter are identical, otherwise zero is returned.
<DT>See Also:
<DD><TT> String::operator !=</TT>,<TT> operator &lt;</TT>,<TT> operator &lt;=</TT>,<TT> operator &gt;</TT>,<TT> operator &gt;=</TT>
</DL>
<H2 ID="String_operator_YLR"> String operator &gt;() [String] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.hpp&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>friend int operator &gt;( String const &amp;lft, String const &amp;rht );</TT>
<BR><TT>friend int operator &gt;( String const &amp;lft, char const *rht );</TT>
<BR><TT>friend int operator &gt;( char const *lft, String const &amp;rht );</TT>
<BR><TT>friend int operator &gt;( String const &amp;lft, char rht );</TT>
<BR><TT>friend int operator &gt;( char lft, String const &amp;rht );</TT>
<DT>Semantics:
<DD>The<TT> operator &gt;</TT> function compares two sequences of characters in terms of a<B> greater-than</B> relationship.
<BR><BR><B>lft</B> is greater-than<B> rht</B> if the characters of<B> lft</B> occur after the characters of<B> rht</B> in
the collating sequence.&nbsp; Upper-case and lower-case characters are considered different.
<DT>Results:
<DD>The<TT> operator &gt;</TT> function returns a non-zero value if the<B> lft</B> sequence of characters is greater than the<B>
rht</B> sequence, otherwise zero is returned.
<DT>See Also:
<DD><TT> String::operator !=</TT>,<TT> operator ==</TT>,<TT> operator &lt;</TT>,<TT> operator &lt;=</TT>,<TT> operator &gt;=</TT>
</DL>
<H2 ID="String_operator_YELR"> String operator &gt;=() [String] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.hpp&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>friend int operator &gt;=( String const &amp;lft, String const &amp;rht );</TT>
<BR><TT>friend int operator &gt;=( String const &amp;lft, char const *rht );</TT>
<BR><TT>friend int operator &gt;=( char const *lft, String const &amp;rht );</TT>
<BR><TT>friend int operator &gt;=( String const &amp;lft, char rht );</TT>
<BR><TT>friend int operator &gt;=( char lft, String const &amp;rht );</TT>
<DT>Semantics:
<DD>The<TT> operator &gt;=</TT> function compares two sequences of characters in terms of a<B> greater-than or equal</B> relationship.
<BR><BR><B>lft</B> is greater-than or equal to<B> rht</B> if the characters of<B> lft</B> are equal to or occur after the
characters of<B> rht</B> in the collating sequence.&nbsp; Upper-case and lower-case characters are considered different.
<DT>Results:
<DD>The<TT> operator &gt;=</TT> function returns a non-zero value if the<B> lft</B> sequence of characters is greater than or
equal to the<B> rht</B> sequence, otherwise zero is returned.
<DT>See Also:
<DD><TT> String::operator !=</TT>,<TT> operator ==</TT>,<TT> operator &lt;</TT>,<TT> operator &lt;=</TT>,<TT> operator &gt;</TT>
</DL>
<H2 ID="String_operator_YYLR"> String operator &gt;&gt;() [String] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.hpp&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>friend istream &amp;operator &gt;&gt;( istream &amp;strm, String &amp;str );</TT>
<DT>Semantics:
<DD>The<TT> operator &gt;&gt;</TT> function is used to read a sequence of characters from the<B> strm</B><TT> istream</TT> object
into the<B> str</B><TT> String</TT> object.&nbsp; Like C strings, the gathering of characters for a<B> str</B><TT> String</TT>
object ends at the first whitespace encountered, so that the last character placed in<B> str</B> is the character before the
whitespace.
<DT>Results:
<DD>The<TT> operator &gt;&gt;</TT> function returns a reference to the<B> strm</B> parameter.
<DT>See Also:
<DD><TT> istream</TT>
</DL>
<H2 ID="String__operator_UVLR"> operator []() [String] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.hpp&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>char const &amp;String::operator []( size_t pos ) const;</TT>
<BR><TT> char &amp;String::operator []( size_t pos );</TT>
<DT>Semantics:
<DD>The<TT> operator []</TT> public member function creates either a const or a non-const reference to the character at offset<B>
pos</B> within the<TT> String</TT> object.&nbsp; The non-const reference may be used to modify that character.&nbsp; The first
character of a<TT> String</TT> object is at position zero.
<BR><BR>If<B> pos</B> is greater than or equal to the length of the<TT> String</TT> object, and the resulting reference is
used, the behavior is undefined.
<BR><BR>If the non-const reference is used to modify other characters within the<TT> String</TT> object, the behavior is undefined.
<BR><BR>The reference is associated with the<TT> String</TT> object, and therefore has meaning only as long as the<TT> String</TT>
object is not modified (or destroyed).&nbsp; If the<TT> String</TT> object has been modified and an old reference is used,
the behavior is undefined.
<DT>Results:
<DD>The<TT> operator []</TT> public member function returns either a const or a non-const reference to a character.
<DT>See Also:
<DD><TT> String::operator ()</TT>,<TT> operator char</TT>,<TT> operator char const *</TT>
</DL>
<H2 ID="String__operator_charLR"> operator char() [String] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.hpp&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>String::operator char();</TT>
<DT>Semantics:
<DD>The<TT> operator char</TT> public member function converts a<TT> String</TT> object into the first character it contains.
&nbsp;If the<TT> String</TT> object is empty, the result is the null character.
<DT>Results:
<DD>The<TT> operator char</TT> public member function returns the first character contained in the<TT> String</TT> object.&nbsp;
If the<TT> String</TT> object is empty, the null character is returned.
<DT>See Also:
<DD><TT> String::operator ()</TT>,<TT> operator []</TT>,<TT> operator char const *</TT>
</DL>
<H2 ID="String__operator_char_const_TLR"> operator char const *() [String] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.hpp&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>String::operator char const *();</TT>
<DT>Semantics:
<DD>The<TT> operator char const *</TT> public member function converts a<TT> String</TT> object into a C string containing the
same length and sequence of characters, terminated by a null character.&nbsp; If the<TT> String</TT> object contains a null
character the resulting C string is terminated by that null character.
<BR><BR>The returned pointer is associated with the<TT> String</TT> object, and therefore has meaning only as long as the<TT>
String</TT> object is not modified.&nbsp; If the intention is to be able to refer to the C string after the<TT> String</TT>
object has been modified, a copy of the string should be made, perhaps by using the C library<TT> strdup</TT> function.
<BR><BR>The returned pointer is a pointer to a constant C string.&nbsp; If the pointer is used in some way to modify the C
string, the behavior is undefined.
<DT>Results:
<DD>The<TT> operator char const *</TT> public member function returns a pointer to a null-terminated constant C string that contains
the same characters as the<TT> String</TT> object.
<DT>See Also:
<DD><TT> String::operator ()</TT>,<TT> operator []</TT>,<TT> operator char</TT>
</DL>
<H2 ID="String__put_atLR"> put_at() [String] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.hpp&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>void String::put_at( size_t pos, char chr );</TT>
<DT>Semantics:
<DD>The<TT> put_at</TT> public member function modifies the character at offset<B> pos</B> within the<TT> String</TT> object.
&nbsp;The character at the specified offset is set to the value of<B> chr</B>.&nbsp; If<B> pos</B> is greater than the number
of characters within the<TT> String</TT> object,<B> chr</B> is appended to the<TT> String</TT> object.
<DT>Results:
<DD>The<TT> put_at</TT> public member function has no return value.
<DT>See Also:
<DD><TT> String::get_at</TT>,<TT> operator []</TT>,<TT> operator ()</TT>,<TT> operator +=</TT>,<TT> operator +</TT>
</DL>
<H2 ID="String__StringLR"> String() [String] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.hpp&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>String::String();</TT>
<DT>Semantics:
<DD>This form of the public<TT> String</TT> constructor creates a default<TT> String</TT> object containing no characters.&nbsp;
The created<TT> String</TT> object has length zero.
<DT>Results:
<DD>This form of the public<TT> String</TT> constructor produces a<TT> String</TT> object.
<DT>See Also:
<DD><TT> String::operator =</TT>,<TT> operator +=</TT>,<TT> ~String</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.hpp&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>String::String( size_t size, String::capacity cap );</TT>
<DT>Semantics:
<DD>This form of the public<TT> String</TT> constructor creates a<TT> String</TT> object.&nbsp; The function constructs a<TT>
String</TT> object of length<B> size</B> if<B> cap</B> is equal to the enumerated<B> default_size</B>.&nbsp; The function
reserves<B> size</B> bytes of memory and sets the length of the<TT> String</TT> object to be zero if<B> cap</B> is equal to
the enumerated<B> reserve</B>.
<DT>Results:
<DD>This form of the public<TT> String</TT> constructor produces a<TT> String</TT> object of size<B> size</B>.
<DT>See Also:
<DD><TT> String::operator =</TT>,<TT> ~String</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.hpp&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>String::String( String const &amp;str, size_t pos = 0, size_t num = NPOS );</TT>
<DT>Semantics:
<DD>This form of the public<TT> String</TT> constructor creates a<TT> String</TT> object which contains a sub-string of the<B>
str</B> parameter.&nbsp; The sub-string starts at position<B> pos</B> within<B> str</B> and continues for<B> num</B> characters
or until the end of the<B> str</B> parameter, whichever comes first.
<DT>Results:
<DD>This form of the public<TT> String</TT> constructor produces a sub-string or duplicate of the<B> str</B> parameter.
<DT>See Also:
<DD><TT> String::operator =</TT>,<TT> operator ()</TT>,<TT> operator []</TT>,<TT> ~String</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.hpp&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>String::String( char const *pch, size_t num = NPOS );</TT>
<DT>Semantics:
<DD>This form of the public<TT> String</TT> constructor creates a<TT> String</TT> object from a C string.&nbsp; The<TT> String</TT>
object contains the sequence of characters located at the<B> pch</B> parameter.&nbsp; Characters are included up to<B> num</B>
or the end of the C string pointed at by<B> pch</B>.&nbsp; Note that C strings are terminated by a null character and that
the value of the created<TT> String</TT> object does not contain that character, nor any following it.
<DT>Results:
<DD>This form of the public<TT> String</TT> constructor produces a<TT> String</TT> object of at most length<B> n</B> containing
the characters in the C string starting at the<B> pch</B> parameter.
<DT>See Also:
<DD><TT> String::operator =</TT>,<TT> operator char const *</TT>,<TT> operator ()</TT>,<TT> operator []</TT>,<TT> ~String</TT>
</DL>
<BR><B>Member function</B>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.hpp&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>String::String( char ch, size_t rep = 1 );</TT>
<DT>Semantics:
<DD>This form of the public<TT> String</TT> constructor creates a<TT> String</TT> object containing<B> rep</B> copies of the<B>
ch</B> parameter.
<DT>Results:
<DD>This form of the public<TT> String</TT> constructor produces a<TT> String</TT> object of length<B> rep</B> containing only
the character specified by the<B> ch</B> parameter.
<DT>See Also:
<DD><TT> String::operator =</TT>,<TT> operator char</TT>,<TT> ~String</TT>
</DL>
<H2 ID="String____StringLR"> ~String() [String] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.hpp&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>String::~String();</TT>
<DT>Semantics:
<DD>The public<TT> ~String</TT> destructor destroys the<TT> String</TT> object.&nbsp; The call to the public<TT> ~String</TT>
destructor is inserted implicitly by the compiler at the point where the<TT> String</TT> object goes out of scope.
<DT>Results:
<DD>The<TT> String</TT> object is destroyed.
<DT>See Also:
<DD><TT> String</TT>
</DL>
<H2 ID="String__upperLR"> upper() [String] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.hpp&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>String String::upper() const;</TT>
<DT>Semantics:
<DD>The<TT> upper</TT> public member function creates a new<TT> String</TT> object whose value is the same as the original<TT>
String</TT> object, except that all lower-case letters have been converted to upper-case.
<DT>Results:
<DD>The<TT> upper</TT> public member function returns a new upper-case<TT> String</TT> object.
<DT>See Also:
<DD><TT> String::lower</TT>
</DL>
<H2 ID="String_validLR"> String valid() [String] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.hpp&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>friend int valid( String const &amp;str );</TT>
<DT>Semantics:
<DD>The<TT> valid</TT> function tests the validity of the<B> str</B><TT> String</TT> object.
<DT>Results:
<DD>The<TT> valid</TT> function returns a non-zero value if the<B> str</B><TT> String</TT> object is valid, otherwise zero is
returned.
<DT>See Also:
<DD><TT> String::operator !</TT>,<TT> valid</TT>
</DL>
<H2 ID="String__validLR"> valid() [String] </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.hpp&gt;</TT>
<BR><TT>public:</TT>
<BR><TT>int String::valid() const;</TT>
<DT>Semantics:
<DD>The<TT> valid</TT> public member function tests the validity of the<TT> String</TT> object.
<DT>Results:
<DD>The<TT> valid</TT> public member function returns a non-zero value if the<TT> String</TT> object is valid, otherwise zero
is returned.
<DT>See Also:
<DD><TT> String::operator !</TT>,<TT> valid</TT>
</DL>
</BODY>
