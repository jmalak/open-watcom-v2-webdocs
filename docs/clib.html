<HEAD>
<TITLE> Open Watcom 2.0 C Library Reference </TITLE>
</HEAD>
<BODY>
<H1 ID="Index_of_Topics"> Index of Topics </H1>
<DL>
<DT>- _ -
<DD><A HREF="#_arc">_arc, _arc_w, _arc_wxy</A>
<BR><A HREF="#_atouni">_atouni</A>
<BR><A HREF="#_beginthread">_beginthread, _beginthreadex</A>
<BR><A HREF="#_bfreeseg">_bfreeseg</A>
<BR><A HREF="#_bgetcmd">_bgetcmd</A>
<BR><A HREF="#_bheapseg">_bheapseg</A>
<BR><A HREF="#_bios_disk">_bios_disk</A>
<BR><A HREF="#_bios_equiplist">_bios_equiplist</A>
<BR><A HREF="#_bios_keybrd">_bios_keybrd</A>
<BR><A HREF="#_bios_memsize">_bios_memsize</A>
<BR><A HREF="#_bios_printer">_bios_printer</A>
<BR><A HREF="#_bios_serialcom">_bios_serialcom</A>
<BR><A HREF="#_bios_timeofday">_bios_timeofday</A>
<BR><A HREF="#_bprintf">_bprintf, _bwprintf</A>
<BR><A HREF="#_chain_intr">_chain_intr</A>
<BR><A HREF="#_chdrive">_chdrive</A>
<BR><A HREF="#_clear87">_clear87</A>
<BR><A HREF="#_clearscreen">_clearscreen</A>
<BR><A HREF="#_cmdname">_cmdname</A>
<BR><A HREF="#_commit">_commit</A>
<BR><A HREF="#_control87">_control87</A>
<BR><A HREF="#_controlfp">_controlfp</A>
<BR><A HREF="#_dieeetomsbin">_dieeetomsbin</A>
<BR><A HREF="#_disable">_disable</A>
<BR><A HREF="#_displaycursor">_displaycursor</A>
<BR><A HREF="#_dmsbintoieee">_dmsbintoieee</A>
<BR><A HREF="#_dos_allocmem">_dos_allocmem</A>
<BR><A HREF="#_dos_close">_dos_close</A>
<BR><A HREF="#_dos_commit">_dos_commit</A>
<BR><A HREF="#_dos_creat">_dos_creat</A>
<BR><A HREF="#_dos_creatnew">_dos_creatnew</A>
<BR><A HREF="#_dos_find___">_dos_find...&nbsp; Functions</A>
<BR><A HREF="#_dos_freemem">_dos_freemem</A>
<BR><A HREF="#_dos_getdate">_dos_getdate</A>
<BR><A HREF="#_dos_getdiskfree">_dos_getdiskfree</A>
<BR><A HREF="#_dos_getdrive">_dos_getdrive</A>
<BR><A HREF="#_dos_getfileattr">_dos_getfileattr</A>
<BR><A HREF="#_dos_getftime">_dos_getftime</A>
<BR><A HREF="#_dos_gettime">_dos_gettime</A>
<BR><A HREF="#_dos_getvect">_dos_getvect</A>
<BR><A HREF="#_dos_keep">_dos_keep</A>
<BR><A HREF="#_dos_open">_dos_open</A>
<BR><A HREF="#_dos_read">_dos_read</A>
<BR><A HREF="#_dos_setblock">_dos_setblock</A>
<BR><A HREF="#_dos_setdate">_dos_setdate</A>
<BR><A HREF="#_dos_setdrive">_dos_setdrive</A>
<BR><A HREF="#_dos_setfileattr">_dos_setfileattr</A>
<BR><A HREF="#_dos_setftime">_dos_setftime</A>
<BR><A HREF="#_dos_settime">_dos_settime</A>
<BR><A HREF="#_dos_setvect">_dos_setvect</A>
<BR><A HREF="#_dos_write">_dos_write</A>
<BR><A HREF="#_dwDeleteOnClose">_dwDeleteOnClose</A>
<BR><A HREF="#_dwSetAboutDlg">_dwSetAboutDlg</A>
<BR><A HREF="#_dwSetAppTitle">_dwSetAppTitle</A>
<BR><A HREF="#_dwSetConTitle">_dwSetConTitle</A>
<BR><A HREF="#_dwShutDown">_dwShutDown</A>
<BR><A HREF="#_dwYield">_dwYield</A>
<BR><A HREF="#_ellipse">_ellipse, _ellipse_w, _ellipse_wxy</A>
<BR><A HREF="#_enable">_enable</A>
<BR><A HREF="#_endthread">_endthread, _endthreadex</A>
<BR><A HREF="#_Exit">_Exit, _exit</A>
<BR><A HREF="#_expand">_expand Functions</A>
<BR><A HREF="#_fieeetomsbin">_fieeetomsbin</A>
<BR><A HREF="#_findclose">_findclose</A>
<BR><A HREF="#_findfirst">_findfirst, _findfirsti64, _wfindfirst, _wfindfirsti64</A>
<BR><A HREF="#_findnext">_findnext, _findnexti64, _wfindnext, _wfindnexti64</A>
<BR><A HREF="#_finite">_finite</A>
<BR><A HREF="#_floodfill">_floodfill, _floodfill_w</A>
<BR><A HREF="#_fmsbintoieee">_fmsbintoieee</A>
<BR><A HREF="#_fpreset">_fpreset</A>
<BR><A HREF="#_freect">_freect</A>
<BR><A HREF="#_fsopen">_fsopen, _wfsopen</A>
<BR><A HREF="#_fullpath">_fullpath, _wfullpath</A>
<BR><A HREF="#_get_osfhandle">_get_osfhandle</A>
<BR><A HREF="#_getactivepage">_getactivepage</A>
<BR><A HREF="#_getarcinfo">_getarcinfo</A>
<BR><A HREF="#_getbkcolor">_getbkcolor</A>
<BR><A HREF="#_getcliprgn">_getcliprgn</A>
<BR><A HREF="#_getcolor">_getcolor</A>
<BR><A HREF="#_getcurrentposition">_getcurrentposition, _getcurrentposition_w</A>
<BR><A HREF="#_getdcwd">_getdcwd, _wgetdcwd</A>
<BR><A HREF="#_getdiskfree">_getdiskfree</A>
<BR><A HREF="#_getdrive">_getdrive</A>
<BR><A HREF="#_getfillmask">_getfillmask</A>
<BR><A HREF="#_getfontinfo">_getfontinfo</A>
<BR><A HREF="#_getgtextextent">_getgtextextent</A>
<BR><A HREF="#_getgtextvector">_getgtextvector</A>
<BR><A HREF="#_getimage">_getimage, _getimage_w, _getimage_wxy</A>
<BR><A HREF="#_getlinestyle">_getlinestyle</A>
<BR><A HREF="#_getmbcp">_getmbcp</A>
<BR><A HREF="#_getphyscoord">_getphyscoord</A>
<BR><A HREF="#_getpixel">_getpixel, _getpixel_w</A>
<BR><A HREF="#_getplotaction">_getplotaction</A>
<BR><A HREF="#_gettextcolor">_gettextcolor</A>
<BR><A HREF="#_gettextcursor">_gettextcursor</A>
<BR><A HREF="#_gettextextent">_gettextextent</A>
<BR><A HREF="#_gettextposition">_gettextposition</A>
<BR><A HREF="#_gettextsettings">_gettextsettings</A>
<BR><A HREF="#_gettextwindow">_gettextwindow</A>
<BR><A HREF="#_getvideoconfig">_getvideoconfig</A>
<BR><A HREF="#_getviewcoord">_getviewcoord, _getviewcoord_w, _getviewcoord_wxy</A>
<BR><A HREF="#_getvisualpage">_getvisualpage</A>
<BR><A HREF="#_getw">_getw</A>
<BR><A HREF="#_getwindowcoord">_getwindowcoord</A>
<BR><A HREF="#_grow_handles">_grow_handles</A>
<BR><A HREF="#_grstatus">_grstatus</A>
<BR><A HREF="#_grtext">_grtext, _grtext_w</A>
<BR><A HREF="#_harderr">_harderr, _hardresume, _hardretn</A>
<BR><A HREF="#_hdopen">_hdopen</A>
<BR><A HREF="#_heapchk">_heapchk Functions</A>
<BR><A HREF="#_heapenable">_heapenable</A>
<BR><A HREF="#_heapgrow">_heapgrow Functions</A>
<BR><A HREF="#_heapmin">_heapmin Functions</A>
<BR><A HREF="#_heapset">_heapset Functions</A>
<BR><A HREF="#_heapshrink">_heapshrink Functions</A>
<BR><A HREF="#_heapwalk">_heapwalk Functions</A>
<BR><A HREF="#_imagesize">_imagesize, _imagesize_w, _imagesize_wxy</A>
<BR><A HREF="#_ismbbalnum">_ismbbalnum</A>
<BR><A HREF="#_ismbbalpha">_ismbbalpha</A>
<BR><A HREF="#_ismbbgraph">_ismbbgraph</A>
<BR><A HREF="#_ismbbkalnum">_ismbbkalnum</A>
<BR><A HREF="#_ismbbkalpha">_ismbbkalpha</A>
<BR><A HREF="#_ismbbkana">_ismbbkana</A>
<BR><A HREF="#_ismbbkprint">_ismbbkprint</A>
<BR><A HREF="#_ismbbkpunct">_ismbbkpunct</A>
<BR><A HREF="#_ismbblead">_ismbblead</A>
<BR><A HREF="#_ismbbprint">_ismbbprint</A>
<BR><A HREF="#_ismbbpunct">_ismbbpunct</A>
<BR><A HREF="#_ismbbtrail">_ismbbtrail</A>
<BR><A HREF="#_ismbcalnum">_ismbcalnum</A>
<BR><A HREF="#_ismbcalpha">_ismbcalpha</A>
<BR><A HREF="#_ismbccntrl">_ismbccntrl</A>
<BR><A HREF="#_ismbcdigit">_ismbcdigit</A>
<BR><A HREF="#_ismbcgraph">_ismbcgraph</A>
<BR><A HREF="#_ismbchira">_ismbchira</A>
<BR><A HREF="#_ismbckata">_ismbckata</A>
<BR><A HREF="#_ismbcl0">_ismbcl0</A>
<BR><A HREF="#_ismbcl1">_ismbcl1</A>
<BR><A HREF="#_ismbcl2">_ismbcl2</A>
<BR><A HREF="#_ismbclegal">_ismbclegal</A>
<BR><A HREF="#_ismbclower">_ismbclower</A>
<BR><A HREF="#_ismbcprint">_ismbcprint</A>
<BR><A HREF="#_ismbcpunct">_ismbcpunct</A>
<BR><A HREF="#_ismbcspace">_ismbcspace</A>
<BR><A HREF="#_ismbcsymbol">_ismbcsymbol</A>
<BR><A HREF="#_ismbcupper">_ismbcupper</A>
<BR><A HREF="#_ismbcxdigit">_ismbcxdigit</A>
<BR><A HREF="#_lineto">_lineto, _lineto_w</A>
<BR><A HREF="#_lrotl">_lrotl</A>
<BR><A HREF="#_lrotr">_lrotr</A>
<BR><A HREF="#_m_empty">_m_empty</A>
<BR><A HREF="#_m_from_int">_m_from_int</A>
<BR><A HREF="#_m_packssdw">_m_packssdw</A>
<BR><A HREF="#_m_packsswb">_m_packsswb</A>
<BR><A HREF="#_m_packuswb">_m_packuswb</A>
<BR><A HREF="#_m_paddb">_m_paddb</A>
<BR><A HREF="#_m_paddd">_m_paddd</A>
<BR><A HREF="#_m_paddsb">_m_paddsb</A>
<BR><A HREF="#_m_paddsw">_m_paddsw</A>
<BR><A HREF="#_m_paddusb">_m_paddusb</A>
<BR><A HREF="#_m_paddusw">_m_paddusw</A>
<BR><A HREF="#_m_paddw">_m_paddw</A>
<BR><A HREF="#_m_pand">_m_pand</A>
<BR><A HREF="#_m_pandn">_m_pandn</A>
<BR><A HREF="#_m_pcmpeqb">_m_pcmpeqb</A>
<BR><A HREF="#_m_pcmpeqd">_m_pcmpeqd</A>
<BR><A HREF="#_m_pcmpeqw">_m_pcmpeqw</A>
<BR><A HREF="#_m_pcmpgtb">_m_pcmpgtb</A>
<BR><A HREF="#_m_pcmpgtd">_m_pcmpgtd</A>
<BR><A HREF="#_m_pcmpgtw">_m_pcmpgtw</A>
<BR><A HREF="#_m_pmaddwd">_m_pmaddwd</A>
<BR><A HREF="#_m_pmulhw">_m_pmulhw</A>
<BR><A HREF="#_m_pmullw">_m_pmullw</A>
<BR><A HREF="#_m_por">_m_por</A>
<BR><A HREF="#_m_pslld">_m_pslld</A>
<BR><A HREF="#_m_pslldi">_m_pslldi</A>
<BR><A HREF="#_m_psllq">_m_psllq</A>
<BR><A HREF="#_m_psllqi">_m_psllqi</A>
<BR><A HREF="#_m_psllw">_m_psllw</A>
<BR><A HREF="#_m_psllwi">_m_psllwi</A>
<BR><A HREF="#_m_psrad">_m_psrad</A>
<BR><A HREF="#_m_psradi">_m_psradi</A>
<BR><A HREF="#_m_psraw">_m_psraw</A>
<BR><A HREF="#_m_psrawi">_m_psrawi</A>
<BR><A HREF="#_m_psrld">_m_psrld</A>
<BR><A HREF="#_m_psrldi">_m_psrldi</A>
<BR><A HREF="#_m_psrlq">_m_psrlq</A>
<BR><A HREF="#_m_psrlqi">_m_psrlqi</A>
<BR><A HREF="#_m_psrlw">_m_psrlw</A>
<BR><A HREF="#_m_psrlwi">_m_psrlwi</A>
<BR><A HREF="#_m_psubb">_m_psubb</A>
<BR><A HREF="#_m_psubd">_m_psubd</A>
<BR><A HREF="#_m_psubsb">_m_psubsb</A>
<BR><A HREF="#_m_psubsw">_m_psubsw</A>
<BR><A HREF="#_m_psubusb">_m_psubusb</A>
<BR><A HREF="#_m_psubusw">_m_psubusw</A>
<BR><A HREF="#_m_psubw">_m_psubw</A>
<BR><A HREF="#_m_punpckhbw">_m_punpckhbw</A>
<BR><A HREF="#_m_punpckhdq">_m_punpckhdq</A>
<BR><A HREF="#_m_punpckhwd">_m_punpckhwd</A>
<BR><A HREF="#_m_punpcklbw">_m_punpcklbw</A>
<BR><A HREF="#_m_punpckldq">_m_punpckldq</A>
<BR><A HREF="#_m_punpcklwd">_m_punpcklwd</A>
<BR><A HREF="#_m_pxor">_m_pxor</A>
<BR><A HREF="#_m_to_int">_m_to_int</A>
<BR><A HREF="#_makepath">_makepath, _wmakepath</A>
<BR><A HREF="#_mbbtombc">_mbbtombc</A>
<BR><A HREF="#_mbbtype">_mbbtype</A>
<BR><A HREF="#_mbccmp">_mbccmp, _fmbccmp</A>
<BR><A HREF="#_mbccpy">_mbccpy, _fmbccpy</A>
<BR><A HREF="#_mbcicmp">_mbcicmp, _fmbcicmp</A>
<BR><A HREF="#_mbcjistojms">_mbcjistojms</A>
<BR><A HREF="#_mbcjmstojis">_mbcjmstojis</A>
<BR><A HREF="#_mbclen">_mbclen, _fmbclen</A>
<BR><A HREF="#_mbctohira">_mbctohira</A>
<BR><A HREF="#_mbctokata">_mbctokata</A>
<BR><A HREF="#_mbctolower">_mbctolower</A>
<BR><A HREF="#_mbctombb">_mbctombb</A>
<BR><A HREF="#_mbctoupper">_mbctoupper</A>
<BR><A HREF="#_mbgetcode">_mbgetcode, _fmbgetcode</A>
<BR><A HREF="#_mbputchar">_mbputchar, _fmbputchar</A>
<BR><A HREF="#_mbsbtype">_mbsbtype, _fmbsbtype</A>
<BR><A HREF="#_mbsnbcat">_mbsnbcat, _fmbsnbcat</A>
<BR><A HREF="#_mbsnbcmp">_mbsnbcmp, _fmbsnbcmp</A>
<BR><A HREF="#_mbsnbcnt">_mbsnbcnt, _fmbsnbcnt, _strncnt, _wcsncnt</A>
<BR><A HREF="#_mbsnbcpy">_mbsnbcpy, _fmbsnbcpy</A>
<BR><A HREF="#_mbsnbicmp">_mbsnbicmp, _fmbsnbicmp</A>
<BR><A HREF="#_mbsnbset">_mbsnbset, _fmbsnbset</A>
<BR><A HREF="#_mbsnccnt">_mbsnccnt, _fmbsnccnt, _strncnt, _wcsncnt</A>
<BR><A HREF="#_mbsnextc">_mbsnextc, _fmbsnextc, _strnextc, _wcsnextc</A>
<BR><A HREF="#_mbterm">_mbterm, _fmbterm</A>
<BR><A HREF="#_mbvtop">_mbvtop, _fmbvtop</A>
<BR><A HREF="#_memavl">_memavl</A>
<BR><A HREF="#_memmax">_memmax</A>
<BR><A HREF="#_mktemp">_mktemp, _wmktemp</A>
<BR><A HREF="#_moveto">_moveto, _moveto_w</A>
<BR><A HREF="#_msize">_msize Functions</A>
<BR><A HREF="#_open_osfhandle">_open_osfhandle</A>
<BR><A HREF="#_os_handle">_os_handle</A>
<BR><A HREF="#_outgtext">_outgtext</A>
<BR><A HREF="#_outmem">_outmem</A>
<BR><A HREF="#_outtext">_outtext</A>
<BR><A HREF="#_pclose">_pclose</A>
<BR><A HREF="#_pg_analyzechart">_pg_analyzechart, _pg_analyzechartms</A>
<BR><A HREF="#_pg_analyzepie">_pg_analyzepie</A>
<BR><A HREF="#_pg_analyzescatter">_pg_analyzescatter, _pg_analyzescatterms</A>
<BR><A HREF="#_pg_chart">_pg_chart, _pg_chartms</A>
<BR><A HREF="#_pg_chartpie">_pg_chartpie</A>
<BR><A HREF="#_pg_chartscatter">_pg_chartscatter, _pg_chartscatterms</A>
<BR><A HREF="#_pg_defaultchart">_pg_defaultchart</A>
<BR><A HREF="#_pg_getchardef">_pg_getchardef</A>
<BR><A HREF="#_pg_getpalette">_pg_getpalette</A>
<BR><A HREF="#_pg_getstyleset">_pg_getstyleset</A>
<BR><A HREF="#_pg_hlabelchart">_pg_hlabelchart</A>
<BR><A HREF="#_pg_initchart">_pg_initchart</A>
<BR><A HREF="#_pg_resetpalette">_pg_resetpalette</A>
<BR><A HREF="#_pg_resetstyleset">_pg_resetstyleset</A>
<BR><A HREF="#_pg_setchardef">_pg_setchardef</A>
<BR><A HREF="#_pg_setpalette">_pg_setpalette</A>
<BR><A HREF="#_pg_setstyleset">_pg_setstyleset</A>
<BR><A HREF="#_pg_vlabelchart">_pg_vlabelchart</A>
<BR><A HREF="#_pie">_pie, _pie_w, _pie_wxy</A>
<BR><A HREF="#_pipe">_pipe</A>
<BR><A HREF="#_polygon">_polygon, _polygon_w, _polygon_wxy</A>
<BR><A HREF="#_popen">_popen, _wpopen</A>
<BR><A HREF="#_putimage">_putimage, _putimage_w</A>
<BR><A HREF="#_putw">_putw</A>
<BR><A HREF="#_rectangle">_rectangle, _rectangle_w, _rectangle_wxy</A>
<BR><A HREF="#_registerfonts">_registerfonts</A>
<BR><A HREF="#_remapallpalette">_remapallpalette</A>
<BR><A HREF="#_remappalette">_remappalette</A>
<BR><A HREF="#_rotl">_rotl</A>
<BR><A HREF="#_rotr">_rotr</A>
<BR><A HREF="#_scrolltextwindow">_scrolltextwindow</A>
<BR><A HREF="#_searchenv">_searchenv, _wsearchenv</A>
<BR><A HREF="#_selectpalette">_selectpalette</A>
<BR><A HREF="#_set_matherr">_set_matherr</A>
<BR><A HREF="#_setactivepage">_setactivepage</A>
<BR><A HREF="#_setbkcolor">_setbkcolor</A>
<BR><A HREF="#_setcharsize">_setcharsize, _setcharsize_w</A>
<BR><A HREF="#_setcharspacing">_setcharspacing, _setcharspacing_w</A>
<BR><A HREF="#_setcliprgn">_setcliprgn</A>
<BR><A HREF="#_setcolor">_setcolor</A>
<BR><A HREF="#_setfillmask">_setfillmask</A>
<BR><A HREF="#_setfont">_setfont</A>
<BR><A HREF="#_setgtextvector">_setgtextvector</A>
<BR><A HREF="#_setlinestyle">_setlinestyle</A>
<BR><A HREF="#_setmbcp">_setmbcp</A>
<BR><A HREF="#_setpixel">_setpixel, _setpixel_w</A>
<BR><A HREF="#_setplotaction">_setplotaction</A>
<BR><A HREF="#_settextalign">_settextalign</A>
<BR><A HREF="#_settextcolor">_settextcolor</A>
<BR><A HREF="#_settextcursor">_settextcursor</A>
<BR><A HREF="#_settextorient">_settextorient</A>
<BR><A HREF="#_settextpath">_settextpath</A>
<BR><A HREF="#_settextposition">_settextposition</A>
<BR><A HREF="#_settextrows">_settextrows</A>
<BR><A HREF="#_settextwindow">_settextwindow</A>
<BR><A HREF="#_setvideomode">_setvideomode</A>
<BR><A HREF="#_setvideomoderows">_setvideomoderows</A>
<BR><A HREF="#_setvieworg">_setvieworg</A>
<BR><A HREF="#_setviewport">_setviewport</A>
<BR><A HREF="#_setvisualpage">_setvisualpage</A>
<BR><A HREF="#_setwindow">_setwindow</A>
<BR><A HREF="#_snprintf">_snprintf, _snwprintf</A>
<BR><A HREF="#_splitpath">_splitpath, _wsplitpath</A>
<BR><A HREF="#_splitpath2">_splitpath2, _wsplitpath2</A>
<BR><A HREF="#_status87">_status87</A>
<BR><A HREF="#_strdate">_strdate, _wstrdate</A>
<BR><A HREF="#_strdec">_strdec, _wcsdec, _mbsdec, _fmbsdec</A>
<BR><A HREF="#_stricoll">_stricoll, _wcsicoll, _mbsicoll</A>
<BR><A HREF="#_strinc">_strinc, _wcsinc, _mbsinc, _fmbsinc</A>
<BR><A HREF="#_strncoll">_strncoll, _wcsncoll, _mbsncoll</A>
<BR><A HREF="#_strnicoll">_strnicoll, _wcsnicoll, _mbsnicoll</A>
<BR><A HREF="#_strninc">_strninc, _wcsninc, _mbsninc, _fmbsninc</A>
<BR><A HREF="#_strtime">_strtime, _wstrtime</A>
<BR><A HREF="#_tempnam">_tempnam, _wtempnam</A>
<BR><A HREF="#_unregisterfonts">_unregisterfonts</A>
<BR><A HREF="#_vbprintf">_vbprintf, _vbwprintf</A>
<BR><A HREF="#_vsnprintf">_vsnprintf, _vsnwprintf</A>
<BR><A HREF="#_wrapon">_wrapon</A>
<DT>- A -
<DD><A HREF="#abort">abort</A>
<BR><A HREF="#The_abort_Function">The abort Function</A>
<BR><A HREF="#abort_handler_s">abort_handler_s</A>
<BR><A HREF="#abs">abs</A>
<BR><A HREF="#access">access, _access, _waccess</A>
<BR><A HREF="#acos">acos</A>
<BR><A HREF="#acosh">acosh</A>
<BR><A HREF="#alloca">alloca</A>
<BR><A HREF="#Allocating_Zero_Memory">Allocating Zero Memory</A>
<BR><A HREF="#Analyze_Functions">Analyze Functions</A>
<BR><A HREF="#asctime">asctime Functions</A>
<BR><A HREF="#asctime_s">asctime_s, _wasctime_s</A>
<BR><A HREF="#asin">asin</A>
<BR><A HREF="#asinh">asinh</A>
<BR><A HREF="#assert">assert</A>
<BR><A HREF="#atan">atan</A>
<BR><A HREF="#atan2">atan2</A>
<BR><A HREF="#atanh">atanh</A>
<BR><A HREF="#atexit">atexit</A>
<BR><A HREF="#The_atexit_Function">The atexit Function</A>
<BR><A HREF="#atof">atof, _wtof</A>
<BR><A HREF="#atoi">atoi, _wtoi</A>
<BR><A HREF="#atol">atol, _wtol</A>
<BR><A HREF="#atoll">atoll, _wtoll</A>
<BR><A HREF="#Attribute_Functions">Attribute Functions</A>
<DT>- B -
<DD><A HREF="#basename">basename</A>
<BR><A HREF="#bcmp">bcmp</A>
<BR><A HREF="#bcopy">bcopy</A>
<BR><A HREF="#bdos">bdos</A>
<BR><A HREF="#bessel">bessel Functions</A>
<BR><A HREF="#BIOS_Functions">BIOS Functions</A>
<BR><A HREF="#break___">break...&nbsp; Functions</A>
<BR><A HREF="#bsearch">bsearch</A>
<BR><A HREF="#bsearch_s">bsearch_s</A>
<BR><A HREF="#btowc">btowc</A>
<BR><A HREF="#bzero">bzero</A>
<DT>- C -
<DD><A HREF="#C_Library_Overview">C Library Overview</A>
<BR><A HREF="#cabs">cabs</A>
<BR><A HREF="#calloc">calloc Functions</A>
<BR><A HREF="#cbrt">cbrt</A>
<BR><A HREF="#ceil">ceil</A>
<BR><A HREF="#cgets">cgets</A>
<BR><A HREF="#Character_Manipulation_Functions">Character Manipulation Functions</A>
<BR><A HREF="#Character_Testing">Character Testing</A>
<BR><A HREF="#chdir">chdir, _chdir, _wchdir</A>
<BR><A HREF="#chmod">chmod, _chmod, _wchmod</A>
<BR><A HREF="#chsize">chsize, _chsize</A>
<BR><A HREF="#Classes_of_Functions">Classes of Functions</A>
<BR><A HREF="#Classes_of_Graphics_Functions">Classes of Graphics Functions</A>
<BR><A HREF="#clearenv">clearenv</A>
<BR><A HREF="#clearerr">clearerr</A>
<BR><A HREF="#clock">clock</A>
<BR><A HREF="#The_clock_Function">The clock Function</A>
<BR><A HREF="#clock_getres">clock_getres</A>
<BR><A HREF="#clock_gettime">clock_gettime</A>
<BR><A HREF="#clock_nanosleep">clock_nanosleep</A>
<BR><A HREF="#clock_settime">clock_settime</A>
<BR><A HREF="#clone">clone</A>
<BR><A HREF="#close">close, _close</A>
<BR><A HREF="#closedir">closedir, _wclosedir</A>
<BR><A HREF="#Console_IDO_Functions">Console I/O Functions</A>
<BR><A HREF="#Conversion_Functions">Conversion Functions</A>
<BR><A HREF="#Coordinate_System_Functions">Coordinate System Functions</A>
<BR><A HREF="#copysign">copysign</A>
<BR><A HREF="#cos">cos</A>
<BR><A HREF="#cosh">cosh</A>
<BR><A HREF="#cprintf">cprintf</A>
<BR><A HREF="#cputs">cputs</A>
<BR><A HREF="#creat">creat, _creat, _wcreat</A>
<BR><A HREF="#cscanf">cscanf</A>
<BR><A HREF="#ctime">ctime Functions</A>
<BR><A HREF="#ctime_s">ctime_s, _wctime_s</A>
<BR><A HREF="#cwait">cwait, _cwait</A>
<DT>- D -
<DD><A HREF="#Default_Signals">Default Signals</A>
<BR><A HREF="#Default_Windowing_Functions">Default Windowing Functions</A>
<BR><A HREF="#delay">delay</A>
<BR><A HREF="#Deleting_Open_Files">Deleting Open Files</A>
<BR><A HREF="#Diagnostic_Printed_by_the_assert_Function">Diagnostic Printed by the assert Function</A>
<BR><A HREF="#difftime">difftime</A>
<BR><A HREF="#Directory_Functions">Directory Functions</A>
<BR><A HREF="#dirname">dirname</A>
<BR><A HREF="#Display_Functions">Display Functions</A>
<BR><A HREF="#div">div</A>
<BR><A HREF="#Domain_Errors">Domain Errors</A>
<BR><A HREF="#DOS_Commands">DOS Commands</A>
<BR><A HREF="#DOS_Considerations">DOS Considerations</A>
<BR><A HREF="#DOS_Devices">DOS Devices</A>
<BR><A HREF="#DOS_Directories">DOS Directories</A>
<BR><A HREF="#DOS_File_Names">DOS File Names</A>
<BR><A HREF="#DOS_Files">DOS Files</A>
<BR><A HREF="#DOS_Interrupts">DOS Interrupts</A>
<BR><A HREF="#DOS_LFN_aware_Functions">DOS LFN aware Functions</A>
<BR><A HREF="#DOS_Processes">DOS Processes</A>
<BR><A HREF="#DOSMSpecific_Functions">DOS-Specific Functions</A>
<BR><A HREF="#dosexterr">dosexterr</A>
<BR><A HREF="#Drawing_Functions">Drawing Functions</A>
<BR><A HREF="#dup">dup, _dup</A>
<BR><A HREF="#dup2">dup2, _dup2</A>
<DT>- E -
<DD><A HREF="#ecvt">ecvt, _ecvt, _wecvt</A>
<BR><A HREF="#endhostent">endhostent</A>
<BR><A HREF="#endnetent">endnetent</A>
<BR><A HREF="#endprotoent">endprotoent</A>
<BR><A HREF="#endpwent">endpwent</A>
<BR><A HREF="#endservent">endservent</A>
<BR><A HREF="#Environment_Functions">Environment Functions</A>
<BR><A HREF="#Environment_Names">Environment Names</A>
<BR><A HREF="#eof">eof, _eof</A>
<BR><A HREF="#erf">erf</A>
<BR><A HREF="#erfc">erfc</A>
<BR><A HREF="#exec___">exec...&nbsp; Functions</A>
<BR><A HREF="#exit">exit</A>
<BR><A HREF="#exp">exp</A>
<BR><A HREF="#exp2">exp2</A>
<BR><A HREF="#expm1">expm1</A>
<DT>- F -
<DD><A HREF="#fabs">fabs</A>
<BR><A HREF="#fclose">fclose</A>
<BR><A HREF="#fcloseall">fcloseall</A>
<BR><A HREF="#fcvt">fcvt, _fcvt, _wfcvt</A>
<BR><A HREF="#fdim">fdim</A>
<BR><A HREF="#fdopen">fdopen, _fdopen, _wfdopen</A>
<BR><A HREF="#feclearexcept">feclearexcept</A>
<BR><A HREF="#fedisableexcept">fedisableexcept, __fedisableexcept</A>
<BR><A HREF="#feenableexcept">feenableexcept, __feenableexcept</A>
<BR><A HREF="#fegetenv">fegetenv</A>
<BR><A HREF="#fegetexceptflag">fegetexceptflag</A>
<BR><A HREF="#fegetround">fegetround</A>
<BR><A HREF="#feholdexcept">feholdexcept</A>
<BR><A HREF="#feof">feof</A>
<BR><A HREF="#feraiseexcept">feraiseexcept</A>
<BR><A HREF="#ferror">ferror</A>
<BR><A HREF="#fesetenv">fesetenv</A>
<BR><A HREF="#fesetexceptflag">fesetexceptflag</A>
<BR><A HREF="#fesetround">fesetround</A>
<BR><A HREF="#fetestexcept">fetestexcept</A>
<BR><A HREF="#feupdateenv">feupdateenv</A>
<BR><A HREF="#fflush">fflush</A>
<BR><A HREF="#ffs">ffs</A>
<BR><A HREF="#fgetc">fgetc, fgetwc</A>
<BR><A HREF="#fgetchar">fgetchar, _fgetchar, _fgetwchar</A>
<BR><A HREF="#fgetpos">fgetpos</A>
<BR><A HREF="#fgets">fgets, fgetws</A>
<BR><A HREF="#File_Access_Limits">File Access Limits</A>
<BR><A HREF="#File_Buffering">File Buffering</A>
<BR><A HREF="#File_Manipulation_Functions">File Manipulation Functions</A>
<BR><A HREF="#File_Names">File Names</A>
<BR><A HREF="#File_Position_Errors">File Position Errors</A>
<BR><A HREF="#File_Position_in_Append_Mode">File Position in Append Mode</A>
<BR><A HREF="#filelength">filelength, _filelength, _filelengthi64</A>
<BR><A HREF="#FILENAME_MAX">FILENAME_MAX</A>
<BR><A HREF="#fileno">fileno</A>
<BR><A HREF="#floor">floor</A>
<BR><A HREF="#flushall">flushall</A>
<BR><A HREF="#fma">fma</A>
<BR><A HREF="#fmax">fmax</A>
<BR><A HREF="#fmin">fmin</A>
<BR><A HREF="#fmod">fmod</A>
<BR><A HREF="#The_fmod_Function">The fmod Function</A>
<BR><A HREF="#fnmatch">fnmatch</A>
<BR><A HREF="#Font_Manipulation_Functions">Font Manipulation Functions</A>
<BR><A HREF="#fopen">fopen, _wfopen</A>
<BR><A HREF="#fopen_s">fopen_s, _wfopen_s</A>
<BR><A HREF="#FP_OFF">FP_OFF</A>
<BR><A HREF="#FP_SEG">FP_SEG</A>
<BR><A HREF="#fpclassify">fpclassify</A>
<BR><A HREF="#fprintf">fprintf, fwprintf</A>
<BR><A HREF="#fprintf_s">fprintf_s, fwprintf_s</A>
<BR><A HREF="#fputc">fputc, fputwc</A>
<BR><A HREF="#fputchar">fputchar, _fputchar, _fputwchar</A>
<BR><A HREF="#fputs">fputs, fputws</A>
<BR><A HREF="#fread">fread</A>
<BR><A HREF="#free">free Functions</A>
<BR><A HREF="#freopen">freopen, _wfreopen</A>
<BR><A HREF="#freopen_s">freopen_s, _wfreopen_s</A>
<BR><A HREF="#frexp">frexp</A>
<BR><A HREF="#fscanf">fscanf, fwscanf</A>
<BR><A HREF="#fscanf_s">fscanf_s, fwscanf_s</A>
<BR><A HREF="#fseek">fseek</A>
<BR><A HREF="#fsetpos">fsetpos</A>
<BR><A HREF="#fstat">fstat, _fstat, _fstati64, _wfstat, _wfstati64</A>
<BR><A HREF="#fsync">fsync</A>
<BR><A HREF="#ftell">ftell</A>
<BR><A HREF="#ftime">ftime</A>
<BR><A HREF="#fwide">fwide</A>
<BR><A HREF="#fwrite">fwrite</A>
<DT>- G -
<DD><A HREF="#gcvt">gcvt, _gcvt, _wgcvt</A>
<BR><A HREF="#getc">getc, getwc</A>
<BR><A HREF="#getch">getch</A>
<BR><A HREF="#getchar">getchar, getwchar</A>
<BR><A HREF="#getche">getche</A>
<BR><A HREF="#getcmd">getcmd</A>
<BR><A HREF="#getcwd">getcwd, _wgetcwd</A>
<BR><A HREF="#getdelim">getdelim</A>
<BR><A HREF="#getegid">getegid</A>
<BR><A HREF="#getenv">getenv, _wgetenv</A>
<BR><A HREF="#getenv_s">getenv_s</A>
<BR><A HREF="#geteuid">geteuid</A>
<BR><A HREF="#getgid">getgid</A>
<BR><A HREF="#gethostbyname">gethostbyname</A>
<BR><A HREF="#gethostent">gethostent</A>
<BR><A HREF="#getline">getline</A>
<BR><A HREF="#getnetbyaddr">getnetbyaddr</A>
<BR><A HREF="#getnetbyname">getnetbyname</A>
<BR><A HREF="#getnetent">getnetent</A>
<BR><A HREF="#getopt">getopt</A>
<BR><A HREF="#getpgrp">getpgrp</A>
<BR><A HREF="#getpid">getpid, _getpid</A>
<BR><A HREF="#getppid">getppid</A>
<BR><A HREF="#getprotobyname">getprotobyname</A>
<BR><A HREF="#getprotobynumber">getprotobynumber</A>
<BR><A HREF="#getprotoent">getprotoent</A>
<BR><A HREF="#getpwent">getpwent</A>
<BR><A HREF="#getpwnam">getpwnam</A>
<BR><A HREF="#getpwuid">getpwuid</A>
<BR><A HREF="#gets">gets, _getws</A>
<BR><A HREF="#gets_s">gets_s</A>
<BR><A HREF="#getservbyname">getservbyname</A>
<BR><A HREF="#getservbyport">getservbyport</A>
<BR><A HREF="#getservent">getservent</A>
<BR><A HREF="#gettid">gettid</A>
<BR><A HREF="#getuid">getuid</A>
<BR><A HREF="#Global_Data">Global Data</A>
<BR><A HREF="#gmtime">gmtime Functions</A>
<BR><A HREF="#gmtime_s">gmtime_s</A>
<BR><A HREF="#Graphics_Adapters">Graphics Adapters</A>
<BR><A HREF="#Graphics_Functions">Graphics Functions</A>
<BR><A HREF="#Graphics_Header_Files">Graphics Header Files</A>
<BR><A HREF="#Graphics_Library">Graphics Library</A>
<BR><A HREF="#Graphics_Text_Functions">Graphics Text Functions</A>
<DT>- H -
<DD><A HREF="#halloc">halloc</A>
<BR><A HREF="#Header_Files">Header Files</A>
<BR><A HREF="#Header_Files_in_DwatcomDh">Header Files in /watcom/h</A>
<BR><A HREF="#Header_Files_in_DwatcomDhDsys">Header Files in /watcom/h/sys</A>
<BR><A HREF="#Heap_Functions">Heap Functions</A>
<BR><A HREF="#hfree">hfree</A>
<BR><A HREF="#hypot">hypot</A>
<DT>- I -
<DD><A HREF="#ignore_handler_s">ignore_handler_s</A>
<BR><A HREF="#ilogb">ilogb</A>
<BR><A HREF="#Image_Manipulation_Functions">Image Manipulation Functions</A>
<BR><A HREF="#imaxabs">imaxabs</A>
<BR><A HREF="#imaxdiv">imaxdiv</A>
<BR><A HREF="#ImplementationMDefined_Behavior_of_the_C_Library">Implementation-Defined Behavior of the C Library</A>
<BR><A HREF="#inp">inp</A>
<BR><A HREF="#inpd">inpd</A>
<BR><A HREF="#inpw">inpw</A>
<BR><A HREF="#int386">int386</A>
<BR><A HREF="#int386x">int386x</A>
<BR><A HREF="#int86">int86</A>
<BR><A HREF="#int86x">int86x</A>
<BR><A HREF="#intdos">intdos</A>
<BR><A HREF="#intdosx">intdosx</A>
<BR><A HREF="#Intel_80x86_ArchitectureMSpecific_Functions">Intel 80x86 Architecture-Specific Functions</A>
<BR><A HREF="#Intel_Pentium_Multimedia_Extension_Functions">Intel Pentium Multimedia Extension Functions</A>
<BR><A HREF="#intr">intr</A>
<BR><A HREF="#intrf">intrf</A>
<BR><A HREF="#isalnum">isalnum, iswalnum</A>
<BR><A HREF="#isalpha">isalpha, iswalpha</A>
<BR><A HREF="#isascii">isascii, __isascii, iswascii</A>
<BR><A HREF="#isatty">isatty, _isatty</A>
<BR><A HREF="#isblank">isblank, iswblank</A>
<BR><A HREF="#iscntrl">iscntrl, iswcntrl</A>
<BR><A HREF="#iscsym">iscsym, __iscsym, __iswcsym</A>
<BR><A HREF="#iscsymf">iscsymf, __iscsymf, __iswcsymf</A>
<BR><A HREF="#isdigit">isdigit, iswdigit</A>
<BR><A HREF="#isfinite">isfinite</A>
<BR><A HREF="#isgraph">isgraph, iswgraph</A>
<BR><A HREF="#isinf">isinf</A>
<BR><A HREF="#isleadbyte">isleadbyte</A>
<BR><A HREF="#islower">islower, iswlower</A>
<BR><A HREF="#isnan">isnan</A>
<BR><A HREF="#isnormal">isnormal</A>
<BR><A HREF="#isprint">isprint, iswprint</A>
<BR><A HREF="#ispunct">ispunct, iswpunct</A>
<BR><A HREF="#isspace">isspace, iswspace</A>
<BR><A HREF="#isupper">isupper, iswupper</A>
<BR><A HREF="#iswctype">iswctype</A>
<BR><A HREF="#isxdigit">isxdigit, iswxdigit</A>
<BR><A HREF="#itoa">itoa, _itoa, _itow</A>
<DT>- K -
<DD><A HREF="#kbhit">kbhit, _kbhit</A>
<DT>- L -
<DD><A HREF="#labs">labs</A>
<BR><A HREF="#ldexp">ldexp</A>
<BR><A HREF="#ldiv">ldiv</A>
<BR><A HREF="#lfind">lfind</A>
<BR><A HREF="#lgamma">lgamma</A>
<BR><A HREF="#lgamma_r">lgamma_r</A>
<BR><A HREF="#Library_Functions_and_Macros">Library Functions and Macros</A>
<BR><A HREF="#llabs">llabs</A>
<BR><A HREF="#lldiv">lldiv</A>
<BR><A HREF="#lltoa">lltoa, _lltoa, _lltow</A>
<BR><A HREF="#localeconv">localeconv</A>
<BR><A HREF="#localtime">localtime Functions</A>
<BR><A HREF="#localtime_s">localtime_s</A>
<BR><A HREF="#lock">lock</A>
<BR><A HREF="#locking">locking, _locking</A>
<BR><A HREF="#log">log</A>
<BR><A HREF="#log10">log10</A>
<BR><A HREF="#log1p">log1p</A>
<BR><A HREF="#log2">log2</A>
<BR><A HREF="#logb">logb</A>
<BR><A HREF="#longjmp">longjmp</A>
<BR><A HREF="#lsearch">lsearch</A>
<BR><A HREF="#lseek">lseek, _lseek, _lseeki64</A>
<BR><A HREF="#ltoa">ltoa, _ltoa, _ltow</A>
<DT>- M -
<DD><A HREF="#main">main, wmain, WinMain, wWinMain</A>
<BR><A HREF="#malloc">malloc Functions</A>
<BR><A HREF="#Math_Functions">Math Functions</A>
<BR><A HREF="#matherr">matherr</A>
<BR><A HREF="#max">max</A>
<BR><A HREF="#mblen">mblen, _fmblen</A>
<BR><A HREF="#mbrlen">mbrlen, _fmbrlen</A>
<BR><A HREF="#mbrtowc">mbrtowc, _fmbrtowc</A>
<BR><A HREF="#mbsinit">mbsinit, sisinit</A>
<BR><A HREF="#mbsrtowcs">mbsrtowcs, _fmbsrtowcs</A>
<BR><A HREF="#mbsrtowcs_s">mbsrtowcs_s, _fmbsrtowcs_s</A>
<BR><A HREF="#mbstowcs">mbstowcs, _fmbstowcs</A>
<BR><A HREF="#mbstowcs_s">mbstowcs_s, _fmbstowcs_s</A>
<BR><A HREF="#mbtowc">mbtowc, _fmbtowc</A>
<BR><A HREF="#memccpy">memccpy, _fmemccpy</A>
<BR><A HREF="#memchr">memchr, _fmemchr, wmemchr</A>
<BR><A HREF="#memcmp">memcmp, _fmemcmp, wmemcmp</A>
<BR><A HREF="#memcpy">memcpy, _fmemcpy, wmemcpy</A>
<BR><A HREF="#memcpy_s">memcpy_s, wmemcpy_s</A>
<BR><A HREF="#memicmp">memicmp, _memicmp, _fmemicmp</A>
<BR><A HREF="#memmove">memmove, _fmemmove, wmemmove</A>
<BR><A HREF="#memmove_s">memmove_s, wmemmove_s</A>
<BR><A HREF="#Memory_Allocation_Functions">Memory Allocation Functions</A>
<BR><A HREF="#Memory_Manipulation_Functions">Memory Manipulation Functions</A>
<BR><A HREF="#memset">memset, _fmemset, wmemset</A>
<BR><A HREF="#Messages_Generated_by_the_perror_Function">Messages Generated by the perror Function</A>
<BR><A HREF="#min">min</A>
<BR><A HREF="#Miscellaneous_Functions">Miscellaneous Functions</A>
<BR><A HREF="#MK_FP">MK_FP</A>
<BR><A HREF="#mkdir">mkdir, _mkdir, _wmkdir</A>
<BR><A HREF="#mkstemp">mkstemp</A>
<BR><A HREF="#mktime">mktime</A>
<BR><A HREF="#mlock">mlock</A>
<BR><A HREF="#mlockall">mlockall</A>
<BR><A HREF="#mmap">mmap</A>
<BR><A HREF="#modf">modf</A>
<BR><A HREF="#movedata">movedata</A>
<BR><A HREF="#mprotect">mprotect</A>
<BR><A HREF="#msync">msync</A>
<BR><A HREF="#Multibyte_Character_Manipulation_Functions">Multibyte Character Manipulation Functions</A>
<BR><A HREF="#Multibyte_String_Manipulation_Functions">Multibyte String Manipulation Functions</A>
<BR><A HREF="#munlock">munlock</A>
<BR><A HREF="#munlockall">munlockall</A>
<BR><A HREF="#munmap">munmap</A>
<DT>- N -
<DD><A HREF="#nan">nan</A>
<BR><A HREF="#nearbyint">nearbyint</A>
<BR><A HREF="#nextafter">nextafter</A>
<BR><A HREF="#nl_langinfo">nl_langinfo</A>
<BR><A HREF="#nosound">nosound</A>
<BR><A HREF="#Null_Characters">Null Characters</A>
<BR><A HREF="#NULL_Macro">NULL Macro</A>
<DT>- O -
<DD><A HREF="#offsetof">offsetof</A>
<BR><A HREF="#onexit">onexit</A>
<BR><A HREF="#open">open, _open, _wopen</A>
<BR><A HREF="#opendir">opendir, _wopendir</A>
<BR><A HREF="#Operating_System_IDO_Functions">Operating System I/O Functions</A>
<BR><A HREF="#The_OSD2_TZ_Environment_Variable">The OS/2 TZ Environment Variable</A>
<BR><A HREF="#outp">outp</A>
<BR><A HREF="#outpd">outpd</A>
<BR><A HREF="#outpw">outpw</A>
<DT>- P -
<DD><A HREF="#pclose">pclose</A>
<BR><A HREF="#perror">perror, _wperror</A>
<BR><A HREF="#popen">popen</A>
<BR><A HREF="#pow">pow</A>
<BR><A HREF="#Presentation_Graphics_Functions">Presentation Graphics Functions</A>
<BR><A HREF="#printf">printf, wprintf</A>
<BR><A HREF="#printf_s">printf_s, wprintf_s</A>
<BR><A HREF="#Printing_Pointer_Values">Printing Pointer Values</A>
<BR><A HREF="#Process_Environment">Process Environment</A>
<BR><A HREF="#Process_Primitive_Functions">Process Primitive Functions</A>
<BR><A HREF="#putc">putc, putwc</A>
<BR><A HREF="#putch">putch</A>
<BR><A HREF="#putchar">putchar, putwchar</A>
<BR><A HREF="#putenv">putenv, _putenv, _wputenv</A>
<BR><A HREF="#puts">puts, _putws</A>
<DT>- Q -
<DD><A HREF="#qsort">qsort</A>
<BR><A HREF="#qsort_s">qsort_s</A>
<DT>- R -
<DD><A HREF="#raise">raise</A>
<BR><A HREF="#rand">rand</A>
<BR><A HREF="#ReMentrant_Functions">Re-entrant Functions</A>
<BR><A HREF="#read">read, _read</A>
<BR><A HREF="#readdir">readdir, _wreaddir</A>
<BR><A HREF="#Reading_Pointer_Values">Reading Pointer Values</A>
<BR><A HREF="#Reading_Ranges">Reading Ranges</A>
<BR><A HREF="#realloc">realloc Functions</A>
<BR><A HREF="#remainder">remainder</A>
<BR><A HREF="#remove">remove, _wremove</A>
<BR><A HREF="#rename">rename, _wrename</A>
<BR><A HREF="#Renaming_with_a_Name_that_Exists">Renaming with a Name that Exists</A>
<BR><A HREF="#rewind">rewind</A>
<BR><A HREF="#rewinddir">rewinddir, _wrewinddir</A>
<BR><A HREF="#rint">rint</A>
<BR><A HREF="#rmdir">rmdir, _rmdir, _wrmdir</A>
<BR><A HREF="#round">round</A>
<DT>- S -
<DD><A HREF="#sbrk">sbrk</A>
<BR><A HREF="#scalbn">scalbn</A>
<BR><A HREF="#scanf">scanf, wscanf</A>
<BR><A HREF="#scanf_s">scanf_s, wscanf_s</A>
<BR><A HREF="#sched_get_priority_max">sched_get_priority_max</A>
<BR><A HREF="#sched_get_priority_min">sched_get_priority_min</A>
<BR><A HREF="#sched_getparam">sched_getparam</A>
<BR><A HREF="#sched_getscheduler">sched_getscheduler</A>
<BR><A HREF="#sched_rr_get_interval">sched_rr_get_interval</A>
<BR><A HREF="#sched_setparam">sched_setparam</A>
<BR><A HREF="#sched_setscheduler">sched_setscheduler</A>
<BR><A HREF="#sched_yield">sched_yield</A>
<BR><A HREF="#Searching_Functions">Searching Functions</A>
<BR><A HREF="#segread">segread</A>
<BR><A HREF="#sem_destroy">sem_destroy</A>
<BR><A HREF="#sem_getvalue">sem_getvalue</A>
<BR><A HREF="#sem_init">sem_init</A>
<BR><A HREF="#sem_post">sem_post</A>
<BR><A HREF="#sem_trywait">sem_trywait</A>
<BR><A HREF="#sem_wait">sem_wait</A>
<BR><A HREF="#set_constraint_handler_s">set_constraint_handler_s</A>
<BR><A HREF="#set_new_handler">set_new_handler, _set_new_handler</A>
<BR><A HREF="#setbuf">setbuf</A>
<BR><A HREF="#setenv">setenv, _setenv, _wsetenv</A>
<BR><A HREF="#sethostent">sethostent</A>
<BR><A HREF="#setjmp">setjmp</A>
<BR><A HREF="#setlocale">setlocale, _wsetlocale</A>
<BR><A HREF="#setmode">setmode, _setmode</A>
<BR><A HREF="#setnetent">setnetent</A>
<BR><A HREF="#setprotoent">setprotoent</A>
<BR><A HREF="#setpwent">setpwent</A>
<BR><A HREF="#setservent">setservent</A>
<BR><A HREF="#setvbuf">setvbuf</A>
<BR><A HREF="#The_SIGILL_Signal">The SIGILL Signal</A>
<BR><A HREF="#signal">signal</A>
<BR><A HREF="#The_signal_Function">The signal Function</A>
<BR><A HREF="#signbit">signbit</A>
<BR><A HREF="#sin">sin</A>
<BR><A HREF="#sinh">sinh</A>
<BR><A HREF="#sleep">sleep</A>
<BR><A HREF="#snprintf">snprintf, snwprintf</A>
<BR><A HREF="#snprintf_s">snprintf_s, snwprintf_s</A>
<BR><A HREF="#sopen">sopen, _sopen, _wsopen</A>
<BR><A HREF="#sound">sound</A>
<BR><A HREF="#Space_Characters">Space Characters</A>
<BR><A HREF="#spawn___">spawn...&nbsp; Functions</A>
<BR><A HREF="#sprintf">sprintf, swprintf</A>
<BR><A HREF="#sprintf_s">sprintf_s, swprintf_s</A>
<BR><A HREF="#sqrt">sqrt</A>
<BR><A HREF="#srand">srand</A>
<BR><A HREF="#sscanf">sscanf, swscanf</A>
<BR><A HREF="#sscanf_s">sscanf_s, swscanf_s</A>
<BR><A HREF="#stackavail">stackavail, _stackavail</A>
<BR><A HREF="#stat">stat, _stat, _stati64, _wstat, _wstati64, lstat</A>
<BR><A HREF="#strcasecmp">strcasecmp</A>
<BR><A HREF="#strcat">strcat, _fstrcat, wcscat, _mbscat, _fmbscat</A>
<BR><A HREF="#strcat_s">strcat_s, wcscat_s</A>
<BR><A HREF="#strchr">strchr, _fstrchr, wcschr, _mbschr, _fmbschr</A>
<BR><A HREF="#strcmp">strcmp, _fstrcmp, wcscmp, _mbscmp, _fmbscmp</A>
<BR><A HREF="#strcmpi">strcmpi, wcscmpi</A>
<BR><A HREF="#strcoll">strcoll, wcscoll, _mbscoll</A>
<BR><A HREF="#strcpy">strcpy, _fstrcpy, wcscpy, _mbscpy, _fmbscpy</A>
<BR><A HREF="#strcpy_s">strcpy_s, wcscpy_s</A>
<BR><A HREF="#strcspn">strcspn, _fstrcspn, wcscspn, _mbscspn, _fmbscspn</A>
<BR><A HREF="#strdup">strdup, _strdup, _fstrdup, _wcsdup, _mbsdup, _fmbsdup</A>
<BR><A HREF="#Stream_IDO_Functions">Stream I/O Functions</A>
<BR><A HREF="#The_strerror_Function">The strerror Function</A>
<BR><A HREF="#strerror">strerror, wcserror</A>
<BR><A HREF="#strerror_s">strerror_s, wcserror_s</A>
<BR><A HREF="#strerrorlen_s">strerrorlen_s, wcserrorlen_s</A>
<BR><A HREF="#strftime">strftime, wcsftime, _wstrftime_ms</A>
<BR><A HREF="#stricmp">stricmp, _stricmp, _fstricmp, _wcsicmp, _mbsicmp, _fmbsicmp</A>
<BR><A HREF="#String_Manipulation_Functions">String Manipulation Functions</A>
<BR><A HREF="#strlcat">strlcat, wcslcat</A>
<BR><A HREF="#strlcpy">strlcpy, wcslcpy</A>
<BR><A HREF="#strlen">strlen, _fstrlen, wcslen, _mbslen, _fmbslen</A>
<BR><A HREF="#strlwr">strlwr, _strlwr, _fstrlwr, _wcslwr, _mbslwr, _fmbslwr</A>
<BR><A HREF="#strncasecmp">strncasecmp</A>
<BR><A HREF="#strncat">strncat, _fstrncat, wcsncat, _mbsncat, _fmbsncat</A>
<BR><A HREF="#strncat_s">strncat_s, wcsncat_s</A>
<BR><A HREF="#strncmp">strncmp, _fstrncmp, wcsncmp, _mbsncmp, _fmbsncmp</A>
<BR><A HREF="#strncpy">strncpy, _fstrncpy, wcsncpy, _mbsncpy, _fmbsncpy</A>
<BR><A HREF="#strncpy_s">strncpy_s, wcsncpy_s</A>
<BR><A HREF="#strnicmp">strnicmp, _strnicmp, _fstrnicmp, _wcsnicmp, _mbsnicmp, _fmbsnicmp</A>
<BR><A HREF="#strnlen_s">strnlen_s, wcsnlen_s</A>
<BR><A HREF="#strnset">strnset, _strnset, _fstrnset, _wcsnset, _mbsnset, _fmbsnset</A>
<BR><A HREF="#strpbrk">strpbrk, _fstrpbrk, wcspbrk, _mbspbrk, _fmbspbrk</A>
<BR><A HREF="#strrchr">strrchr, _fstrrchr, wcsrchr, _mbsrchr, _fmbsrchr</A>
<BR><A HREF="#strrev">strrev, _strrev, _fstrrev, _wcsrev, _mbsrev, _fmbsrev</A>
<BR><A HREF="#strset">strset, _strset, _fstrset, _wcsset, _mbsset, _fmbsset</A>
<BR><A HREF="#strspn">strspn, _fstrspn, wcsspn, _mbsspn, _fmbsspn</A>
<BR><A HREF="#strspnp">strspnp, _strspnp, _fstrspnp, _wcsspnp, _mbsspnp, _fmbsspnp</A>
<BR><A HREF="#strstr">strstr, _fstrstr, wcsstr, _mbsstr, _fmbsstr</A>
<BR><A HREF="#strtod">strtod, wcstod</A>
<BR><A HREF="#strtoimax">strtoimax, wcstoimax</A>
<BR><A HREF="#strtok">strtok, strtok_r, _fstrtok, _fstrtok_r, wcstok, _mbstok, _mbstok_r, _fmbstok, _fmbstok_r</A>
<BR><A HREF="#strtok_s">strtok_s, wcstok_s</A>
<BR><A HREF="#strtol">strtol, wcstol</A>
<BR><A HREF="#strtoll">strtoll, wcstoll</A>
<BR><A HREF="#strtoul">strtoul, wcstoul</A>
<BR><A HREF="#strtoull">strtoull, wcstoull</A>
<BR><A HREF="#strtoumax">strtoumax, wcstoumax</A>
<BR><A HREF="#strupr">strupr, _strupr, _fstrupr, _wcsupr, _mbsupr, _fmbsupr</A>
<BR><A HREF="#strxfrm">strxfrm, wcsxfrm</A>
<BR><A HREF="#swab">swab</A>
<BR><A HREF="#sysconf">sysconf</A>
<BR><A HREF="#sysinfo">sysinfo</A>
<BR><A HREF="#The_system_Function">The system Function</A>
<BR><A HREF="#system">system, _wsystem</A>
<DT>- T -
<DD><A HREF="#tan">tan</A>
<BR><A HREF="#tanh">tanh</A>
<BR><A HREF="#tell">tell, _tell, _telli64</A>
<BR><A HREF="#Terminating_Newline_Characters">Terminating Newline Characters</A>
<BR><A HREF="#Text_Functions">Text Functions</A>
<BR><A HREF="#tgamma">tgamma</A>
<BR><A HREF="#time">time</A>
<BR><A HREF="#Time_Functions">Time Functions</A>
<BR><A HREF="#The_Time_Zone">The Time Zone</A>
<BR><A HREF="#timer_create">timer_create</A>
<BR><A HREF="#timer_delete">timer_delete</A>
<BR><A HREF="#timer_getoverrun">timer_getoverrun</A>
<BR><A HREF="#timer_gettime">timer_gettime</A>
<BR><A HREF="#timer_settime">timer_settime</A>
<BR><A HREF="#tmpfile">tmpfile</A>
<BR><A HREF="#tmpfile_s">tmpfile_s</A>
<BR><A HREF="#tmpnam">tmpnam, _wtmpnam</A>
<BR><A HREF="#tmpnam_s">tmpnam_s, _wtmpnam_s</A>
<BR><A HREF="#tolower">tolower, _tolower, towlower</A>
<BR><A HREF="#toupper">toupper, _toupper, towupper</A>
<BR><A HREF="#towctrans">towctrans</A>
<BR><A HREF="#trunc">trunc</A>
<BR><A HREF="#Truncation_of_Text_Files">Truncation of Text Files</A>
<BR><A HREF="#ttyname">ttyname, ttyname_r</A>
<BR><A HREF="#The_TZ_Environment_Variable">The TZ Environment Variable</A>
<BR><A HREF="#tzset">tzset</A>
<DT>- U -
<DD><A HREF="#ulltoa">ulltoa, _ulltoa, _ulltow</A>
<BR><A HREF="#ultoa">ultoa, _ultoa, _ultow</A>
<BR><A HREF="#umask">umask, _umask</A>
<BR><A HREF="#Underflow_of_FloatingMPoint_Values">Underflow of Floating-Point Values</A>
<BR><A HREF="#ungetc">ungetc, ungetwc</A>
<BR><A HREF="#ungetch">ungetch</A>
<BR><A HREF="#unlink">unlink, _unlink, _wunlink</A>
<BR><A HREF="#unlock">unlock</A>
<BR><A HREF="#Utility_Functions">Utility Functions</A>
<BR><A HREF="#utime">utime, _utime, _wutime</A>
<BR><A HREF="#utoa">utoa, _utoa, _utow</A>
<DT>- V -
<DD><A HREF="#va_arg">va_arg</A>
<BR><A HREF="#va_end">va_end</A>
<BR><A HREF="#va_start">va_start</A>
<BR><A HREF="#VariableMlength_Argument_Lists">Variable-length Argument Lists</A>
<BR><A HREF="#vcprintf">vcprintf</A>
<BR><A HREF="#vcscanf">vcscanf</A>
<BR><A HREF="#vfprintf">vfprintf, vfwprintf</A>
<BR><A HREF="#vfprintf_s">vfprintf_s, vfwprintf_s</A>
<BR><A HREF="#vfscanf">vfscanf, vfwscanf</A>
<BR><A HREF="#vfscanf_s">vfscanf_s, vfwscanf_s</A>
<BR><A HREF="#vprintf">vprintf, vwprintf</A>
<BR><A HREF="#vprintf_s">vprintf_s, vwprintf_s</A>
<BR><A HREF="#vscanf">vscanf, vwscanf</A>
<BR><A HREF="#vscanf_s">vscanf_s, vwscanf_s</A>
<BR><A HREF="#vsnprintf">vsnprintf, vsnwprintf</A>
<BR><A HREF="#vsnprintf_s">vsnprintf_s, vsnwprintf_s</A>
<BR><A HREF="#vsprintf">vsprintf, vswprintf</A>
<BR><A HREF="#vsprintf_s">vsprintf_s, vswprintf_s</A>
<BR><A HREF="#vsscanf">vsscanf, vswscanf</A>
<BR><A HREF="#vsscanf_s">vsscanf_s, vswscanf_s</A>
<DT>- W -
<DD><A HREF="#wait">wait</A>
<BR><A HREF="#wcrtomb">wcrtomb, _fwcrtomb</A>
<BR><A HREF="#wcrtomb_s">wcrtomb_s, _fwcrtomb_s</A>
<BR><A HREF="#wcsrtombs">wcsrtombs, _fwcsrtombs</A>
<BR><A HREF="#wcsrtombs_s">wcsrtombs_s, _fwcsrtombs_s</A>
<BR><A HREF="#wcstombs">wcstombs, _fwcstombs</A>
<BR><A HREF="#wcstombs_s">wcstombs_s, _fwcstombs_s</A>
<BR><A HREF="#wctob">wctob</A>
<BR><A HREF="#wctomb">wctomb, _fwctomb</A>
<BR><A HREF="#wctomb_s">wctomb_s, _fwctomb_s</A>
<BR><A HREF="#wctrans">wctrans</A>
<BR><A HREF="#wctype">wctype</A>
<BR><A HREF="#Wide_Character_Manipulation_Functions">Wide Character Manipulation Functions</A>
<BR><A HREF="#Wide_Character_Stream_IDO_Functions">Wide Character Stream I/O Functions</A>
<BR><A HREF="#Wide_String_Manipulation_Functions">Wide String Manipulation Functions</A>
<BR><A HREF="#write">write, _write</A>
<DT>- Z -
<DD><A HREF="#ZeroMLength_Files">Zero-Length Files</A>
</DL>
<H1 ID="C_Library_Overview"> C Library Overview </H1>
<BR>The C library provides much of the power usually associated with the C language.&nbsp; This chapter introduces the individual
functions (and macros) that comprise the Open Watcom C library.&nbsp; The chapter<B> Library Functions and Macros</B> describes
each function and macro in complete detail.
<BR><BR>Library functions are called as if they had been defined within the program.&nbsp; When the program is linked, the
code for these routines is incorporated into the program by the linker.
<BR><BR>Strictly speaking, it is not necessary to declare most library functions since they return<TT> int</TT> values for
the most part.&nbsp; It is preferred, however, to declare all functions by including the header files found in the synopsis
section with each function.&nbsp; Not only does this declare the return value, but also the type expected for each of the
arguments as well as the number of arguments.&nbsp; This enables the Open Watcom C and C++ compilers to check the arguments
coded with each function call.
<H2 ID="Classes_of_Functions"> Classes of Functions </H2>
<BR>The functions in the Open Watcom C library can be organized into a number of classes:
<DL>
<DT>Character Manipulation Functions
<DD>
<BR><BR>These functions deal with single characters.
<DT>Wide Character Manipulation Functions
<DD>
<BR><BR>These functions deal with wide characters.
<DT>Multibyte Character Manipulation Functions
<DD>
<BR><BR>These functions deal with multibyte characters.
<DT>Memory Manipulation Functions
<DD>
<BR><BR>These functions manipulate blocks of memory.
<DT>String Manipulation Functions
<DD>
<BR><BR>These functions manipulate strings of characters.&nbsp; A character string is an array of zero or more adjacent characters
followed by a null character<TT> ('\0')</TT> which marks the end of the string.
<DT>Wide String Manipulation Functions
<DD>
<BR><BR>These functions manipulate strings of wide characters.&nbsp; A wide character string is an array of zero or more adjacent
wide characters followed by a null wide character<TT> (L'\0')</TT> which marks the end of the wide string.
<DT>Multibyte String Manipulation Functions
<DD>
<BR><BR>These functions manipulate strings of multibyte characters.&nbsp; A multibyte character is either a single-byte or
double-byte character.&nbsp; The Chinese, Japanese and Korean character sets are examples of character sets containing both
single-byte and double-byte characters.
<BR>What determines whether a character is a single-byte or double-byte character is the value of the lead byte in the sequence.
&nbsp;For example, in the Japanese DBCS (double-byte character set), double-byte characters are those in which the first byte
falls in the range 0x81 - 0x9F or 0xE0 - 0xFC and the second byte falls in the range 0x40 - 0x7E or 0x80 - 0xFC.&nbsp; A string
of multibyte characters must be scanned from the first byte (index 0) to the last byte (index n) in sequence in order to determine
if a particular byte is part of a double-byte character.&nbsp; For example, suppose that a multibyte character string contains
the following byte values.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0x31 0x40 0x41 0x81 0x41 // &quot;1@A..&quot; where .. is a DB char</TT>
<BR><BR>Among other characters, it contains the letter &quot;A&quot; (the first 0x41) and a double-byte character (0x81 0x41).
&nbsp;The second 0x41 is not the letter &quot;A&quot; and that could only be determined by scanning from left to right starting
with the first byte (0x31).
<DT>Conversion Functions
<DD>
<BR><BR>These functions convert values from one representation to another.&nbsp; Numeric values, for example, can be converted
to strings.
<DT>Memory Allocation Functions
<DD>
<BR><BR>These functions are concerned with allocating and deallocating memory.
<DT>Heap Functions
<DD>
<BR><BR>These functions provide the ability to shrink and grow the heap, as well as, find heap related problems.
<DT>Math Functions
<DD>
<BR><BR>The mathematical functions perform mathematical computations such as the common trigonometric calculations.&nbsp;
These functions operate on<TT> double</TT> values, also known as floating-point values.
<DT>Searching Functions
<DD>
<BR><BR>These functions provide searching and sorting capabilities.
<DT>Time Functions
<DD>
<BR><BR>These functions provide facilities to obtain and manipulate times and dates.
<DT>Variable-length Argument Lists
<DD>
<BR><BR>These functions provide the capability to process a variable number of arguments to a function.
<DT>Stream I/O Functions
<DD>
<BR><BR>These functions provide the &quot;standard&quot; functions to read and write files.&nbsp; Data can be transmitted
as characters, strings, blocks of memory or under format control.
<DT>Wide Character Stream I/O Functions
<DD>
<BR><BR>These functions provide the &quot;standard&quot; functions to read and write files of wide characters.&nbsp; Data
can be transmitted as wide characters, wide character strings, blocks of memory or under format control.
<DT>Process Primitive Functions
<DD>
<BR><BR>These functions deal with process creation, execution and termination, signal handling, and timer operations.
<DT>Process Environment
<DD>
<BR><BR>These functions deal with process identification, user identification, process groups, system identification, system
time and process time, environment variables, terminal identification, and configurable system variables.
<DT>Directory Functions
<DD>
<BR><BR>These functions provide directory services.
<DT>Operating System I/O Functions
<DD>
<BR><BR>These &quot;non-standard&quot; file operations are more primitive than the &quot;standard&quot; functions in that
they are directly interfaced to the operating system.&nbsp; They are included to provide compatibility with other C implementations
and to provide the capability to directly use operating-system file operations.
<DT>File Manipulation Functions
<DD>
<BR><BR>These functions operate directly on files, providing facilities such as deletion of files.
<DT>Console I/O Functions
<DD>
<BR><BR>These functions provide the capability to directly read and write characters from the console.
<DT>Default Windowing Functions
<DD>
<BR><BR>These functions provide the capability to manipulate various dialog boxes in Open Watcom's default windowing system.
<DT>BIOS Functions
<DD>
<BR><BR>This set of functions allows access to services provided by the BIOS.
<DT>DOS-Specific Functions
<DD>
<BR><BR>This set of functions allows access to DOS-specific functions.
<DT>Intel 80x86 Architecture-Specific Functions
<DD>
<BR><BR>This set of functions allows access to Intel 80x86 processor-related functions.
<DT>Intel Pentium Multimedia Extension Functions
<DD>
<BR><BR>This set of functions allows access to Intel Architecture Multimedia Extensions (MMX).
<DT>Miscellaneous Functions
<DD>
<BR><BR>This collection consists of the remaining functions.
<DT>DOS LFN aware Functions
<DD>
<BR><BR>These functions are DOS LFN capable.
</DL>
<BR>The following subsections describe these function classes in more detail.&nbsp; Each function in the class is noted with
a brief description of its purpose.&nbsp; The chapter<B> Library Functions and Macros</B> provides a complete description
of each function and macro.
<H3 ID="Character_Manipulation_Functions"> Character Manipulation Functions </H3>
<BR>These functions operate upon single characters of type<TT> char.</TT>&nbsp; The functions test characters in various ways
and convert them between upper and lowercase.&nbsp; The following functions are defined:
<DL>
<DT><A HREF="#isalnum">isalnum</A>
<DD>test for letter or digit
<DT><A HREF="#isalpha">isalpha</A>
<DD>test for letter
<DT><A HREF="#isascii">isascii</A>
<DD>test for ASCII character
<DT><A HREF="#isblank">isblank</A>
<DD>test for blank character
<DT><A HREF="#iscntrl">iscntrl</A>
<DD>test for control character
<DT>__iscsym (see <A HREF="#iscsym">iscsym</A>)
<DD>test for letter, underscore or digit
<DT>__iscsymf (see <A HREF="#iscsymf">iscsymf</A>)
<DD>test for letter or underscore
<DT><A HREF="#isdigit">isdigit</A>
<DD>test for digit
<DT><A HREF="#isgraph">isgraph</A>
<DD>test for printable character, except space
<DT><A HREF="#islower">islower</A>
<DD>test for letter in lowercase
<DT><A HREF="#isprint">isprint</A>
<DD>test for printable character, including space
<DT><A HREF="#ispunct">ispunct</A>
<DD>test for punctuation characters
<DT><A HREF="#isspace">isspace</A>
<DD>test for &quot;white space&quot; characters
<DT><A HREF="#isupper">isupper</A>
<DD>test for letter in uppercase
<DT><A HREF="#isxdigit">isxdigit</A>
<DD>test for hexadecimal digit
<DT><A HREF="#tolower">tolower</A>
<DD>convert character to lowercase
<DT><A HREF="#toupper">toupper</A>
<DD>convert character to uppercase
</DL>
<H3 ID="Wide_Character_Manipulation_Functions"> Wide Character Manipulation Functions </H3>
<BR>These functions operate upon wide characters of type<TT> wchar_t.</TT>&nbsp; The functions test wide characters in various
ways and convert them between upper and lowercase.&nbsp; The following functions are defined:
<DL>
<DT>iswalnum (see <A HREF="#isalnum">isalnum</A>)
<DD>test for letter or digit
<DT>iswalpha (see <A HREF="#isalpha">isalpha</A>)
<DD>test for letter
<DT>iswascii (see <A HREF="#isascii">isascii</A>)
<DD>test for ASCII character
<DT>iswblank (see <A HREF="#isblank">isblank</A>)
<DD>test for blank character
<DT>iswcntrl (see <A HREF="#iscntrl">iscntrl</A>)
<DD>test for control character
<DT>__iswcsym (see <A HREF="#iscsym">iscsym</A>)
<DD>test for letter, underscore or digit
<DT>__iswcsymf (see <A HREF="#iscsymf">iscsymf</A>)
<DD>test for letter or underscore
<DT>iswdigit (see <A HREF="#isdigit">isdigit</A>)
<DD>test for digit
<DT>iswgraph (see <A HREF="#isgraph">isgraph</A>)
<DD>test for printable character, except space
<DT>iswlower (see <A HREF="#islower">islower</A>)
<DD>test for letter in lowercase
<DT>iswprint (see <A HREF="#isprint">isprint</A>)
<DD>test for printable character, including space
<DT>iswpunct (see <A HREF="#ispunct">ispunct</A>)
<DD>test for punctuation characters
<DT>iswspace (see <A HREF="#isspace">isspace</A>)
<DD>test for &quot;white space&quot; characters
<DT>iswupper (see <A HREF="#isupper">isupper</A>)
<DD>test for letter in uppercase
<DT>iswxdigit (see <A HREF="#isxdigit">isxdigit</A>)
<DD>test for hexadecimal digit
<DT><A HREF="#wctype">wctype</A>
<DD>construct a property value for a given &quot;property&quot;
<DT><A HREF="#iswctype">iswctype</A>
<DD>test a character for a specific property
<DT>towlower (see <A HREF="#tolower">tolower</A>)
<DD>convert character to lowercase
<DT>towupper (see <A HREF="#toupper">toupper</A>)
<DD>convert character to uppercase
<DT><A HREF="#wctrans">wctrans</A>
<DD>construct mapping value for a given &quot;property&quot;
<DT><A HREF="#towctrans">towctrans</A>
<DD>convert a character based on a specific property
</DL>
<H3 ID="Multibyte_Character_Manipulation_Functions"> Multibyte Character Manipulation Functions </H3>
<BR>These functions operate upon multibyte characters.&nbsp; The functions test wide characters in various ways and convert
them between upper and lowercase.&nbsp; The following functions are defined:
<DL>
<DT>_fmbccmp (see <A HREF="#_mbccmp">_mbccmp</A>)
<DD>compare one multibyte character with another
<DT>_fmbccpy (see <A HREF="#_mbccpy">_mbccpy</A>)
<DD>copy one multibyte character from one string to another
<DT>_fmbcicmp (see <A HREF="#_mbcicmp">_mbcicmp</A>)
<DD>compare one multibyte character with another (case insensitive)
<DT>_fmbclen (see <A HREF="#_mbclen">_mbclen</A>)
<DD>return number of bytes comprising multibyte character
<DT>_fmblen (see <A HREF="#mblen">mblen</A>)
<DD>determine length of next multibyte character
<DT>_fmbgetcode (see <A HREF="#_mbgetcode">_mbgetcode</A>)
<DD>get next single-byte or double-byte character from far string
<DT>_fmbputchar (see <A HREF="#_mbputchar">_mbputchar</A>)
<DD>store single-byte or double-byte character into far string
<DT>_fmbrlen (see <A HREF="#mbrlen">mbrlen</A>)
<DD>determine length of next multibyte character
<DT>_fmbrtowc (see <A HREF="#mbrtowc">mbrtowc</A>)
<DD>convert far multibyte character to wide character
<DT>_fmbsbtype (see <A HREF="#_mbsbtype">_mbsbtype</A>)
<DD>return type of byte in multibyte character string
<DT>_fmbtowc (see <A HREF="#mbtowc">mbtowc</A>)
<DD>convert far multibyte character to wide character
<DT><A HREF="#_ismbbalnum">_ismbbalnum</A>
<DD>test for isalnum or _ismbbkalnum
<DT><A HREF="#_ismbbalpha">_ismbbalpha</A>
<DD>test for isalpha or _ismbbkalpha
<DT><A HREF="#_ismbbgraph">_ismbbgraph</A>
<DD>test for isgraph or _ismbbkprint
<DT><A HREF="#_ismbbkalnum">_ismbbkalnum</A>
<DD>test for non-ASCII text symbol other than punctuation
<DT><A HREF="#_ismbbkana">_ismbbkana</A>
<DD>test for single-byte Katakana character
<DT><A HREF="#_ismbbkalpha">_ismbbkalpha</A>
<DD>test for non-ASCII text symbol other than digits or punctuation
<DT><A HREF="#_ismbbkprint">_ismbbkprint</A>
<DD>test for non-ASCII text or non-ASCII punctuation symbol
<DT><A HREF="#_ismbbkpunct">_ismbbkpunct</A>
<DD>test for non-ASCII punctuation character
<DT><A HREF="#_ismbblead">_ismbblead</A>
<DD>test for valid first byte of multibyte character
<DT><A HREF="#_ismbbprint">_ismbbprint</A>
<DD>test for isprint or _ismbbkprint
<DT><A HREF="#_ismbbpunct">_ismbbpunct</A>
<DD>test for ispunct or _ismbbkpunct
<DT><A HREF="#_ismbbtrail">_ismbbtrail</A>
<DD>test for valid second byte of multibyte character
<DT><A HREF="#_ismbcalnum">_ismbcalnum</A>
<DD>test for _ismbcalpha or _ismbcdigit
<DT><A HREF="#_ismbcalpha">_ismbcalpha</A>
<DD>test for a multibyte alphabetic character
<DT><A HREF="#_ismbccntrl">_ismbccntrl</A>
<DD>test for a multibyte control character
<DT><A HREF="#_ismbcdigit">_ismbcdigit</A>
<DD>test for a multibyte decimal-digit character '0' through '9'
<DT><A HREF="#_ismbcgraph">_ismbcgraph</A>
<DD>test for a printable multibyte character except space
<DT><A HREF="#_ismbchira">_ismbchira</A>
<DD>test for a double-byte Hiragana character
<DT><A HREF="#_ismbckata">_ismbckata</A>
<DD>test for a double-byte Katakana character
<DT><A HREF="#_ismbcl0">_ismbcl0</A>
<DD>test for a double-byte non-Kanji character
<DT><A HREF="#_ismbcl1">_ismbcl1</A>
<DD>test for a JIS level 1 double-byte character
<DT><A HREF="#_ismbcl2">_ismbcl2</A>
<DD>test for a JIS level 2 double-byte character
<DT><A HREF="#_ismbclegal">_ismbclegal</A>
<DD>test for a valid multibyte character
<DT><A HREF="#_ismbclower">_ismbclower</A>
<DD>test for a valid lowercase multibyte character
<DT><A HREF="#_ismbcprint">_ismbcprint</A>
<DD>test for a printable multibyte character including space
<DT><A HREF="#_ismbcpunct">_ismbcpunct</A>
<DD>test for any multibyte punctuation character
<DT><A HREF="#_ismbcspace">_ismbcspace</A>
<DD>test for any multibyte space character
<DT><A HREF="#_ismbcsymbol">_ismbcsymbol</A>
<DD>test for valid multibyte symbol (punctuation and other special graphics)
<DT><A HREF="#_ismbcupper">_ismbcupper</A>
<DD>test for valid uppercase multibyte character
<DT><A HREF="#_ismbcxdigit">_ismbcxdigit</A>
<DD>test for any multibyte hexadecimal-digit character
<DT><A HREF="#_mbbtombc">_mbbtombc</A>
<DD>return double-byte equivalent to single-byte character
<DT><A HREF="#_mbbtype">_mbbtype</A>
<DD>determine type of byte in multibyte character
<DT><A HREF="#_mbccmp">_mbccmp</A>
<DD>compare one multibyte character with another
<DT><A HREF="#_mbccpy">_mbccpy</A>
<DD>copy one multibyte character from one string to another
<DT><A HREF="#_mbcicmp">_mbcicmp</A>
<DD>compare one multibyte character with another (case insensitive)
<DT><A HREF="#_mbcjistojms">_mbcjistojms</A>
<DD>convert JIS code to shift-JIS code
<DT><A HREF="#_mbcjmstojis">_mbcjmstojis</A>
<DD>convert shift-JIS code to JIS code
<DT><A HREF="#_mbclen">_mbclen</A>
<DD>return number of bytes comprising multibyte character
<DT><A HREF="#_mbctolower">_mbctolower</A>
<DD>convert double-byte uppercase character to double-byte lowercase character
<DT><A HREF="#_mbctoupper">_mbctoupper</A>
<DD>convert double-byte lowercase character to double-byte uppercase character
<DT><A HREF="#_mbctohira">_mbctohira</A>
<DD>convert double-byte Katakana character to Hiragana character
<DT><A HREF="#_mbctokata">_mbctokata</A>
<DD>convert double-byte Hiragana character to Katakana character
<DT><A HREF="#_mbctombb">_mbctombb</A>
<DD>return single-byte equivalent to double-byte character
<DT><A HREF="#_mbgetcode">_mbgetcode</A>
<DD>get next single-byte or double-byte character from string
<DT><A HREF="#mblen">mblen</A>
<DD>determine length of next multibyte character
<DT><A HREF="#_mbputchar">_mbputchar</A>
<DD>store single-byte or double-byte character into string
<DT><A HREF="#mbrlen">mbrlen</A>
<DD>determine length of next multibyte character
<DT><A HREF="#mbrtowc">mbrtowc</A>
<DD>convert multibyte character to wide character
<DT><A HREF="#_mbsbtype">_mbsbtype</A>
<DD>return type of byte in multibyte character string
<DT><A HREF="#mbsinit">mbsinit</A>
<DD>determine if mbstate_t object describes an initial conversion state
<DT><A HREF="#mbtowc">mbtowc</A>
<DD>convert multibyte character to wide character
</DL>
<H3 ID="Memory_Manipulation_Functions"> Memory Manipulation Functions </H3>
<BR>These functions manipulate blocks of memory.&nbsp; In each case, the address of the memory block and its size is passed
to the function.&nbsp; The functions that begin with &quot;_f&quot; accept<TT> far</TT> pointers as their arguments allowing
manipulation of any memory location regardless of which memory model your program has been compiled for.&nbsp; The following
functions are defined:
<DL>
<DT>_fmemccpy (see <A HREF="#memccpy">memccpy</A>)
<DD>copy far memory block up to a certain character
<DT>_fmemchr (see <A HREF="#memchr">memchr</A>)
<DD>search far memory block for a character value
<DT>_fmemcmp (see <A HREF="#memcmp">memcmp</A>)
<DD>compare any two memory blocks (near or far)
<DT>_fmemcpy (see <A HREF="#memcpy">memcpy</A>)
<DD>copy far memory block, overlap not allowed
<DT>_fmemicmp (see <A HREF="#memicmp">memicmp</A>)
<DD>compare far memory, case insensitive
<DT>_fmemmove (see <A HREF="#memmove">memmove</A>)
<DD>copy far memory block, overlap allowed
<DT>_fmemset (see <A HREF="#memset">memset</A>)
<DD>set any memory block (near of far) to a character
<DT><A HREF="#memccpy">memccpy</A>
<DD>copy memory block up to a certain character
<DT><A HREF="#memchr">memchr</A>
<DD>search memory block for a character value
<DT><A HREF="#memcmp">memcmp</A>
<DD>compare memory blocks
<DT><A HREF="#memcpy">memcpy</A>
<DD>copy memory block, overlap not allowed
<DT><A HREF="#memicmp">memicmp</A>
<DD>compare memory, case insensitive
<DT><A HREF="#memmove">memmove</A>
<DD>copy memory block, overlap allowed
<DT><A HREF="#memset">memset</A>
<DD>set memory block to a character
<DT><A HREF="#movedata">movedata</A>
<DD>copy memory block, with segment information
<DT><A HREF="#swab">swab</A>
<DD>swap bytes of a memory block
<DT>wmemchr (see <A HREF="#memchr">memchr</A>)
<DD>search memory block for a wide character value
<DT>wmemcmp (see <A HREF="#memcmp">memcmp</A>)
<DD>compare memory blocks
<DT>wmemcpy (see <A HREF="#memcpy">memcpy</A>)
<DD>copy memory block, overlap not allowed
<DT>wmemmove (see <A HREF="#memmove">memmove</A>)
<DD>copy memory block, overlap allowed
<DT>wmemset (see <A HREF="#memset">memset</A>)
<DD>set memory block to a wide character
</DL>
<BR>See the section<B> &quot;String Manipulation Functions&quot;</B> for descriptions of functions that manipulate strings
of data.&nbsp; See the section<B> &quot;Wide String Manipulation Functions&quot;</B> for descriptions of functions that manipulate
wide strings of data.
<H3 ID="String_Manipulation_Functions"> String Manipulation Functions </H3>
<BR>A<B> string</B> is an array of characters (with type<TT> char</TT>) that is terminated with an extra null character<TT>
('\0').</TT>&nbsp; Functions are passed only the address of the string since the size can be determined by searching for the
terminating null character.&nbsp; The functions that begin with &quot;_f&quot; accept<TT> far</TT> pointers as their arguments
allowing manipulation of any memory location regardless of which memory model your program has been compiled for.&nbsp; The
following functions are defined:
<DL>
<DT><A HREF="#bcmp">bcmp</A>
<DD>compare two byte strings
<DT><A HREF="#bcopy">bcopy</A>
<DD>copy a byte string
<DT><A HREF="#_bprintf">_bprintf</A>
<DD>formatted transmission to fixed-length string
<DT><A HREF="#bzero">bzero</A>
<DD>zero a byte string
<DT>_fstrcat (see <A HREF="#strcat">strcat</A>)
<DD>concatenate two far strings
<DT>_fstrchr (see <A HREF="#strchr">strchr</A>)
<DD>locate character in far string
<DT>_fstrcmp (see <A HREF="#strcmp">strcmp</A>)
<DD>compare two far strings
<DT>_fstrcpy (see <A HREF="#strcpy">strcpy</A>)
<DD>copy far string
<DT>_fstrcspn (see <A HREF="#strcspn">strcspn</A>)
<DD>get number of string characters not from a set of characters
<DT>_fstricmp (see <A HREF="#stricmp">stricmp</A>)
<DD>compare two far strings with case insensitivity
<DT>_fstrlen (see <A HREF="#strlen">strlen</A>)
<DD>length of a far string
<DT>_fstrlwr (see <A HREF="#strlwr">strlwr</A>)
<DD>convert far string to lowercase
<DT>_fstrncat (see <A HREF="#strncat">strncat</A>)
<DD>concatenate two far strings, up to a maximum length
<DT>_fstrncmp (see <A HREF="#strncmp">strncmp</A>)
<DD>compare two far strings up to maximum length
<DT>_fstrncpy (see <A HREF="#strncpy">strncpy</A>)
<DD>copy a far string, up to a maximum length
<DT>_fstrnicmp (see <A HREF="#strnicmp">strnicmp</A>)
<DD>compare two far strings with case insensitivity up to a maximum length
<DT>_fstrnset (see <A HREF="#strnset">strnset</A>)
<DD>fill far string with character to a maximum length
<DT>_fstrpbrk (see <A HREF="#strpbrk">strpbrk</A>)
<DD>locate occurrence of a string within a second string
<DT>_fstrrchr (see <A HREF="#strrchr">strrchr</A>)
<DD>locate last occurrence of character from a character set
<DT>_fstrrev (see <A HREF="#strrev">strrev</A>)
<DD>reverse a far string in place
<DT>_fstrset (see <A HREF="#strset">strset</A>)
<DD>fill far string with a character
<DT>_fstrspn (see <A HREF="#strspn">strspn</A>)
<DD>find number of characters at start of string which are also in a second string
<DT>_fstrstr (see <A HREF="#strstr">strstr</A>)
<DD>find first occurrence of string in second string
<DT>_fstrtok (see <A HREF="#strtok">strtok</A>)
<DD>get next token from a far string
<DT>_fstrupr (see <A HREF="#strupr">strupr</A>)
<DD>convert far string to uppercase
<DT><A HREF="#sprintf">sprintf</A>
<DD>formatted transmission to string
<DT><A HREF="#sscanf">sscanf</A>
<DD>scan from string under format control
<DT><A HREF="#strcat">strcat</A>
<DD>concatenate string
<DT><A HREF="#strchr">strchr</A>
<DD>locate character in string
<DT><A HREF="#strcmp">strcmp</A>
<DD>compare two strings
<DT><A HREF="#strcmpi">strcmpi</A>
<DD>compare two strings with case insensitivity
<DT><A HREF="#strcoll">strcoll</A>
<DD>compare two strings using &quot;locale&quot; collating sequence
<DT><A HREF="#strcpy">strcpy</A>
<DD>copy a string
<DT><A HREF="#strcspn">strcspn</A>
<DD>get number of string characters not from a set of characters
<DT><A HREF="#_strdec">_strdec</A>
<DD>returns pointer to the previous character in string
<DT>_strdup (see <A HREF="#strdup">strdup</A>)
<DD>allocate and duplicate a string
<DT><A HREF="#strerror">strerror</A>
<DD>get error message as string
<DT>_stricmp (see <A HREF="#stricmp">stricmp</A>)
<DD>compare two strings with case insensitivity
<DT><A HREF="#_strinc">_strinc</A>
<DD>return pointer to next character in string
<DT><A HREF="#strlcat">strlcat</A>
<DD>concatenate string into a bounded buffer
<DT><A HREF="#strlcpy">strlcpy</A>
<DD>copy string into a bounded buffer
<DT><A HREF="#strlen">strlen</A>
<DD>string length
<DT>_strlwr (see <A HREF="#strlwr">strlwr</A>)
<DD>convert string to lowercase
<DT><A HREF="#strncat">strncat</A>
<DD>concatenate two strings, up to a maximum length
<DT><A HREF="#strncmp">strncmp</A>
<DD>compare two strings up to maximum length
<DT>_strncnt (see <A HREF="#_mbsnbcnt">_mbsnbcnt</A>)
<DD>count the number of characters in the first &quot;n&quot; bytes
<DT><A HREF="#strncpy">strncpy</A>
<DD>copy a string, up to a maximum length
<DT>_strnextc (see <A HREF="#_mbsnextc">_mbsnextc</A>)
<DD>return integer value of the next character in string
<DT>_strnicmp (see <A HREF="#strnicmp">strnicmp</A>)
<DD>compare two strings with case insensitivity up to a maximum length
<DT><A HREF="#_strninc">_strninc</A>
<DD>increment character pointer by &quot;n&quot; characters
<DT>_strnset (see <A HREF="#strnset">strnset</A>)
<DD>fill string with character to a maximum length
<DT><A HREF="#strpbrk">strpbrk</A>
<DD>locate occurrence of a string within a second string
<DT><A HREF="#strrchr">strrchr</A>
<DD>locate last occurrence of character from a character set
<DT>_strrev (see <A HREF="#strrev">strrev</A>)
<DD>reverse a string in place
<DT>_strset (see <A HREF="#strset">strset</A>)
<DD>fill string with a character
<DT><A HREF="#strspn">strspn</A>
<DD>find number of characters at start of string which are also in a second string
<DT>_strspnp (see <A HREF="#strspnp">strspnp</A>)
<DD>return pointer to first character of string not in set
<DT><A HREF="#strstr">strstr</A>
<DD>find first occurrence of string in second string
<DT><A HREF="#strtok">strtok</A>
<DD>get next token from string
<DT>_strupr (see <A HREF="#strupr">strupr</A>)
<DD>convert string to uppercase
<DT><A HREF="#strxfrm">strxfrm</A>
<DD>transform string to locale's collating sequence
<DT><A HREF="#_vbprintf">_vbprintf</A>
<DD>same as &quot;_bprintf&quot; but with variable arguments
<DT><A HREF="#vsscanf">vsscanf</A>
<DD>same as &quot;sscanf&quot; but with variable arguments
</DL>
<BR>For related functions see the sections<B> Conversion Functions</B> (conversions to and from strings),<B> Time Functions</B>
(formatting of dates and times), and<B> Memory Manipulation Functions</B> (operate on arrays without terminating null character).
<H3 ID="Wide_String_Manipulation_Functions"> Wide String Manipulation Functions </H3>
<BR>A<B> wide string</B> is an array of wide characters (with type<TT> wchar_t</TT>) that is terminated with an extra null
wide character<TT> (L'\0').</TT>&nbsp; Functions are passed only the address of the string since the size can be determined
by searching for the terminating null character.&nbsp; The functions that begin with &quot;_f&quot; accept<TT> far</TT> pointers
as their arguments allowing manipulation of any memory location regardless of which memory model your program has been compiled
for.&nbsp; The following functions are defined:
<DL>
<DT>_bwprintf (see <A HREF="#_bprintf">_bprintf</A>)
<DD>formatted wide character transmission to fixed-length wcsing
<DT>swprintf (see <A HREF="#sprintf">sprintf</A>)
<DD>formatted wide character transmission to string
<DT>swscanf (see <A HREF="#sscanf">sscanf</A>)
<DD>scan from wide character string under format control
<DT>_vbwprintf (see <A HREF="#_vbprintf">_vbprintf</A>)
<DD>same as &quot;_bwprintf&quot; but with variable arguments
<DT>vswscanf (see <A HREF="#vsscanf">vsscanf</A>)
<DD>same as &quot;swscanf&quot; but with variable arguments
<DT>wcscat (see <A HREF="#strcat">strcat</A>)
<DD>concatenate string
<DT>wcschr (see <A HREF="#strchr">strchr</A>)
<DD>locate character in string
<DT>wcscmp (see <A HREF="#strcmp">strcmp</A>)
<DD>compare two strings
<DT>wcscmpi (see <A HREF="#strcmpi">strcmpi</A>)
<DD>compare two strings with case insensitivity
<DT>wcscoll (see <A HREF="#strcoll">strcoll</A>)
<DD>compare two strings using &quot;locale&quot; collating sequence
<DT>wcscpy (see <A HREF="#strcpy">strcpy</A>)
<DD>copy a string
<DT>wcscspn (see <A HREF="#strcspn">strcspn</A>)
<DD>get number of string characters not from a set of characters
<DT>_wcsdec (see <A HREF="#_strdec">_strdec</A>)
<DD>returns pointer to the previous character in string
<DT>_wcsdup (see <A HREF="#strdup">strdup</A>)
<DD>allocate and duplicate a string
<DT>wcserror (see <A HREF="#strerror">strerror</A>)
<DD>get error message as string
<DT>_wcsicmp (see <A HREF="#stricmp">stricmp</A>)
<DD>compare two strings with case insensitivity
<DT>_wcsinc (see <A HREF="#_strinc">_strinc</A>)
<DD>return pointer to next character in string
<DT>wcslcat (see <A HREF="#strlcat">strlcat</A>)
<DD>concatenate string into a bounded buffer
<DT>wcslcpy (see <A HREF="#strlcpy">strlcpy</A>)
<DD>copy string into a bounded buffer
<DT>wcslen (see <A HREF="#strlen">strlen</A>)
<DD>string length
<DT>_wcslwr (see <A HREF="#strlwr">strlwr</A>)
<DD>convert string to lowercase
<DT>wcsncat (see <A HREF="#strncat">strncat</A>)
<DD>concatenate two strings, up to a maximum length
<DT>wcsncmp (see <A HREF="#strncmp">strncmp</A>)
<DD>compare two strings up to maximum length
<DT>_wcsncnt (see <A HREF="#_mbsnbcnt">_mbsnbcnt</A>)
<DD>count the number of characters in the first &quot;n&quot; bytes
<DT>wcsncpy (see <A HREF="#strncpy">strncpy</A>)
<DD>copy a string, up to a maximum length
<DT>_wcsnextc (see <A HREF="#_mbsnextc">_mbsnextc</A>)
<DD>return integer value of the next multibyte-character in string
<DT>_wcsnicmp (see <A HREF="#strnicmp">strnicmp</A>)
<DD>compare two strings with case insensitivity up to a maximum length
<DT>_wcsninc (see <A HREF="#_strninc">_strninc</A>)
<DD>increment wide character pointer by &quot;n&quot; characters
<DT>_wcsnset (see <A HREF="#strnset">strnset</A>)
<DD>fill string with character to a maximum length
<DT>wcspbrk (see <A HREF="#strpbrk">strpbrk</A>)
<DD>locate occurrence of a string within a second string
<DT>wcsrchr (see <A HREF="#strrchr">strrchr</A>)
<DD>locate last occurrence of character from a character set
<DT>_wcsrev (see <A HREF="#strrev">strrev</A>)
<DD>reverse a string in place
<DT>_wcsset (see <A HREF="#strset">strset</A>)
<DD>fill string with a character
<DT>wcsspn (see <A HREF="#strspn">strspn</A>)
<DD>find number of characters at start of string which are also in a second string
<DT>_wcsspnp (see <A HREF="#strspnp">strspnp</A>)
<DD>return pointer to first character of string not in set
<DT>wcsstr (see <A HREF="#strstr">strstr</A>)
<DD>find first occurrence of string in second string
<DT>wcstok (see <A HREF="#strtok">strtok</A>)
<DD>get next token from string
<DT>_wcsupr (see <A HREF="#strupr">strupr</A>)
<DD>convert string to uppercase
<DT>wcsxfrm (see <A HREF="#strxfrm">strxfrm</A>)
<DD>transform string to locale's collating sequence
</DL>
<BR>For related functions see the sections<B> Conversion Functions</B> (conversions to and from strings),<B> Time Functions</B>
(formatting of dates and times), and<B> Memory Manipulation Functions</B> (operate on arrays without terminating null character).
<H3 ID="Multibyte_String_Manipulation_Functions"> Multibyte String Manipulation Functions </H3>
<BR>A<B> wide string</B> is an array of wide characters (with type<TT> wchar_t</TT>) that is terminated with an extra null
wide character<TT> (L'\0').</TT>&nbsp; Functions are passed only the address of the wide string since the size can be determined
by searching for the terminating null character.&nbsp; The functions that begin with &quot;_f&quot; accept<TT> far</TT> pointers
as their arguments allowing manipulation of any memory location regardless of which memory model your program has been compiled
for.&nbsp; The following functions are defined:
<DL>
<DT><A HREF="#btowc">btowc</A>
<DD>return wide-character version of single-byte character
<DT>_fmbscat (see <A HREF="#strcat">strcat</A>)
<DD>concatenate two far strings
<DT>_fmbschr (see <A HREF="#strchr">strchr</A>)
<DD>locate character in far string
<DT>_fmbscmp (see <A HREF="#strcmp">strcmp</A>)
<DD>compare two far strings
<DT>_fmbscpy (see <A HREF="#strcpy">strcpy</A>)
<DD>copy far string
<DT>_fmbscspn (see <A HREF="#strcspn">strcspn</A>)
<DD>get number of string characters not from a set of characters
<DT>_fmbsdec (see <A HREF="#_strdec">_strdec</A>)
<DD>returns far pointer to the previous character in far string
<DT>_fmbsdup (see <A HREF="#strdup">strdup</A>)
<DD>allocate and duplicate a far string
<DT>_fmbsicmp (see <A HREF="#stricmp">stricmp</A>)
<DD>compare two far strings with case insensitivity
<DT>_fmbsinc (see <A HREF="#_strinc">_strinc</A>)
<DD>return far pointer to next character in far string
<DT>_fmbslen (see <A HREF="#strlen">strlen</A>)
<DD>length of a far string
<DT>_fmbslwr (see <A HREF="#strlwr">strlwr</A>)
<DD>convert far string to lowercase
<DT>_fmbsnbcat (see <A HREF="#_mbsnbcat">_mbsnbcat</A>)
<DD>append up to &quot;n&quot; bytes of string to another string
<DT>_fmbsnbcmp (see <A HREF="#_mbsnbcmp">_mbsnbcmp</A>)
<DD>compare up to &quot;n&quot; bytes in two strings
<DT>_fmbsnbcnt (see <A HREF="#_mbsnbcnt">_mbsnbcnt</A>)
<DD>count the number of characters in the first &quot;n&quot; bytes
<DT>_fmbsnbcpy (see <A HREF="#_mbsnbcpy">_mbsnbcpy</A>)
<DD>copy up to &quot;n&quot; bytes of a string
<DT>_fmbsnbicmp (see <A HREF="#_mbsnbicmp">_mbsnbicmp</A>)
<DD>compare up to &quot;n&quot; bytes in two strings with case insensitivity
<DT>_fmbsnbset (see <A HREF="#_mbsnbset">_mbsnbset</A>)
<DD>fill string with up to &quot;n&quot; bytes
<DT>_fmbsncat (see <A HREF="#strncat">strncat</A>)
<DD>concatenate two far strings, up to a maximum length
<DT>_fmbsnccnt (see <A HREF="#_mbsnccnt">_mbsnccnt</A>)
<DD>count the number of characters in the first &quot;n&quot; bytes
<DT>_fmbsncmp (see <A HREF="#strncmp">strncmp</A>)
<DD>compare two far strings up to maximum length
<DT>_fmbsncpy (see <A HREF="#strncpy">strncpy</A>)
<DD>copy a far string, up to a maximum length
<DT>_fmbsnextc (see <A HREF="#_mbsnextc">_mbsnextc</A>)
<DD>return integer value of the next multibyte-character in far string
<DT>_fmbsnicmp (see <A HREF="#strnicmp">strnicmp</A>)
<DD>compare two far strings with case insensitivity up to a maximum length
<DT>_fmbsninc (see <A HREF="#_strninc">_strninc</A>)
<DD>increment wide character far pointer by &quot;n&quot; characters
<DT>_fmbsnset (see <A HREF="#strnset">strnset</A>)
<DD>fill far string with character to a maximum length
<DT>_fmbspbrk (see <A HREF="#strpbrk">strpbrk</A>)
<DD>locate occurrence of a string within a second string
<DT>_fmbsrchr (see <A HREF="#strrchr">strrchr</A>)
<DD>locate last occurrence of character from a character set
<DT>_fmbsrev (see <A HREF="#strrev">strrev</A>)
<DD>reverse a far string in place
<DT>_fmbsrtowcs (see <A HREF="#mbsrtowcs">mbsrtowcs</A>)
<DD>convert multibyte character string to wide character string
<DT>_fmbsset (see <A HREF="#strset">strset</A>)
<DD>fill far string with a character
<DT>_fmbsspn (see <A HREF="#strspn">strspn</A>)
<DD>find number of characters at start of string which are also in a second string
<DT>_fmbsspnp (see <A HREF="#strspnp">strspnp</A>)
<DD>return far pointer to first character of far string not in set
<DT>_fmbsstr (see <A HREF="#strstr">strstr</A>)
<DD>find first occurrence of string in second string
<DT>_fmbstok (see <A HREF="#strtok">strtok</A>)
<DD>get next token from a far string
<DT>_fmbstowcs (see <A HREF="#mbstowcs">mbstowcs</A>)
<DD>convert multibyte character string to wide character string
<DT>_fmbsupr (see <A HREF="#strupr">strupr</A>)
<DD>convert far string to uppercase
<DT>_fmbterm (see <A HREF="#_mbterm">_mbterm</A>)
<DD>determine if next multibyte character in string is null
<DT>_fmbvtop (see <A HREF="#_mbvtop">_mbvtop</A>)
<DD>store multibyte character into far string
<DT>_fwcrtomb (see <A HREF="#wcrtomb">wcrtomb</A>)
<DD>convert wide character to multibyte character and store
<DT>_fwcsrtombs (see <A HREF="#wcsrtombs">wcsrtombs</A>)
<DD>convert far wide character string to far multibyte character string
<DT>_fwcstombs (see <A HREF="#wcstombs">wcstombs</A>)
<DD>convert far wide character string to far multibyte character string
<DT>_fwctomb (see <A HREF="#wctomb">wctomb</A>)
<DD>convert wide character to multibyte character
<DT>_mbscat (see <A HREF="#strcat">strcat</A>)
<DD>concatenate string
<DT>_mbschr (see <A HREF="#strchr">strchr</A>)
<DD>locate character in string
<DT>_mbscmp (see <A HREF="#strcmp">strcmp</A>)
<DD>compare two strings
<DT>_mbscoll (see <A HREF="#strcoll">strcoll</A>)
<DD>compare two strings using &quot;locale&quot; collating sequence
<DT>_mbscpy (see <A HREF="#strcpy">strcpy</A>)
<DD>copy a string
<DT>_mbscspn (see <A HREF="#strcspn">strcspn</A>)
<DD>get number of string characters not from a set of characters
<DT>_mbsdec (see <A HREF="#_strdec">_strdec</A>)
<DD>returns pointer to the previous character in string
<DT>_mbsdup (see <A HREF="#strdup">strdup</A>)
<DD>allocate and duplicate a string
<DT>_mbsicmp (see <A HREF="#stricmp">stricmp</A>)
<DD>compare two strings with case insensitivity
<DT>_mbsinc (see <A HREF="#_strinc">_strinc</A>)
<DD>return pointer to next character in string
<DT><A HREF="#mbsinit">mbsinit</A>
<DD>determine if mbstate_t object describes an initial conversion state
<DT>_mbslen (see <A HREF="#strlen">strlen</A>)
<DD>string length
<DT>_mbslwr (see <A HREF="#strlwr">strlwr</A>)
<DD>convert string to lowercase
<DT><A HREF="#_mbsnbcat">_mbsnbcat</A>
<DD>append up to &quot;n&quot; bytes of string to another string
<DT><A HREF="#_mbsnbcmp">_mbsnbcmp</A>
<DD>compare up to &quot;n&quot; bytes in two strings
<DT><A HREF="#_mbsnbcnt">_mbsnbcnt</A>
<DD>count the number of characters in the first &quot;n&quot; bytes
<DT><A HREF="#_mbsnbcpy">_mbsnbcpy</A>
<DD>copy up to &quot;n&quot; bytes of a string
<DT><A HREF="#_mbsnbicmp">_mbsnbicmp</A>
<DD>compare up to &quot;n&quot; bytes in two strings with case insensitivity
<DT><A HREF="#_mbsnbset">_mbsnbset</A>
<DD>fill string with up to &quot;n&quot; bytes
<DT>_mbsncat (see <A HREF="#strncat">strncat</A>)
<DD>concatenate two strings, up to a maximum length
<DT><A HREF="#_mbsnccnt">_mbsnccnt</A>
<DD>count the number of characters in the first &quot;n&quot; bytes
<DT>_mbsncmp (see <A HREF="#strncmp">strncmp</A>)
<DD>compare two strings up to maximum length
<DT>_mbsncpy (see <A HREF="#strncpy">strncpy</A>)
<DD>copy a string, up to a maximum length
<DT><A HREF="#_mbsnextc">_mbsnextc</A>
<DD>return integer value of the next multibyte-character in string
<DT>_mbsnicmp (see <A HREF="#strnicmp">strnicmp</A>)
<DD>compare two strings with case insensitivity up to a maximum length
<DT>_mbsninc (see <A HREF="#_strninc">_strninc</A>)
<DD>increment wide character pointer by &quot;n&quot; characters
<DT>_mbsnset (see <A HREF="#strnset">strnset</A>)
<DD>fill string with up to &quot;n&quot; multibyte characters
<DT>_mbspbrk (see <A HREF="#strpbrk">strpbrk</A>)
<DD>locate occurrence of a string within a second string
<DT>_mbsrchr (see <A HREF="#strrchr">strrchr</A>)
<DD>locate last occurrence of character from a character set
<DT>_mbsrev (see <A HREF="#strrev">strrev</A>)
<DD>reverse a string in place
<DT><A HREF="#mbsrtowcs">mbsrtowcs</A>
<DD>convert multibyte character string to wide character string
<DT>_mbsset (see <A HREF="#strset">strset</A>)
<DD>fill string with a character
<DT>_mbsspn (see <A HREF="#strspn">strspn</A>)
<DD>find number of characters at start of string which are also in a second string
<DT>_mbsspnp (see <A HREF="#strspnp">strspnp</A>)
<DD>return pointer to first character of string not in set
<DT>_mbsstr (see <A HREF="#strstr">strstr</A>)
<DD>find first occurrence of string in second string
<DT>_mbstok (see <A HREF="#strtok">strtok</A>)
<DD>get next token from string
<DT><A HREF="#mbstowcs">mbstowcs</A>
<DD>convert multibyte character string to wide character string
<DT>_mbsupr (see <A HREF="#strupr">strupr</A>)
<DD>convert string to uppercase
<DT><A HREF="#_mbterm">_mbterm</A>
<DD>determine if next multibyte character in string is null
<DT><A HREF="#_mbvtop">_mbvtop</A>
<DD>store multibyte character into string
<DT><A HREF="#wcrtomb">wcrtomb</A>
<DD>convert wide character to multibyte character and store
<DT><A HREF="#wcsrtombs">wcsrtombs</A>
<DD>convert wide character string to multibyte character string
<DT><A HREF="#wcstombs">wcstombs</A>
<DD>convert wide character string to multibyte character string
<DT><A HREF="#wctob">wctob</A>
<DD>return single-byte character version of wide character
<DT><A HREF="#wctomb">wctomb</A>
<DD>convert wide character to multibyte character
</DL>
<BR>For related functions see the sections<B> Conversion Functions</B> (conversions to and from strings),<B> Time Functions</B>
(formatting of dates and times), and<B> Memory Manipulation Functions</B> (operate on arrays without terminating null character).
<H3 ID="Conversion_Functions"> Conversion Functions </H3>
<BR>These functions perform conversions between objects of various types and strings.&nbsp; The following functions are defined:
<DL>
<DT><A HREF="#atof">atof</A>
<DD>string to &quot;double&quot;
<DT><A HREF="#atoi">atoi</A>
<DD>string to &quot;int&quot;
<DT><A HREF="#atol">atol</A>
<DD>string to &quot;long int&quot;
<DT><A HREF="#atoll">atoll</A>
<DD>string to &quot;long long int&quot;
<DT><A HREF="#ecvt">ecvt</A>
<DD>&quot;double&quot; to E-format string
<DT><A HREF="#fcvt">fcvt</A>
<DD>&quot;double&quot; to F-format string
<DT><A HREF="#gcvt">gcvt</A>
<DD>&quot;double&quot; to string
<DT><A HREF="#itoa">itoa</A>
<DD>&quot;int&quot; to string
<DT><A HREF="#lltoa">lltoa</A>
<DD>&quot;long long int&quot; to string
<DT><A HREF="#ltoa">ltoa</A>
<DD>&quot;long int&quot; to string
<DT><A HREF="#strtod">strtod</A>
<DD>string to &quot;double&quot;
<DT><A HREF="#strtol">strtol</A>
<DD>string to &quot;long int&quot;
<DT><A HREF="#strtoll">strtoll</A>
<DD>string to &quot;long long int&quot;
<DT><A HREF="#strtoul">strtoul</A>
<DD>string to &quot;unsigned long int&quot;
<DT><A HREF="#strtoull">strtoull</A>
<DD>string to &quot;unsigned long long int&quot;
<DT><A HREF="#ulltoa">ulltoa</A>
<DD>&quot;unsigned long long int&quot; to string
<DT><A HREF="#ultoa">ultoa</A>
<DD>&quot;unsigned long int&quot; to string
<DT><A HREF="#utoa">utoa</A>
<DD>&quot;unsigned int&quot; to string
</DL>
<BR>These functions perform conversions between objects of various types and wide character strings.&nbsp; The following functions
are defined:
<DL>
<DT>_itow (see <A HREF="#itoa">itoa</A>)
<DD>&quot;int&quot; to wide character string
<DT>_lltow (see <A HREF="#lltoa">lltoa</A>)
<DD>&quot;long long int&quot; to wide character string
<DT>_ltow (see <A HREF="#ltoa">ltoa</A>)
<DD>&quot;long int&quot; to wide character string
<DT>_ulltow (see <A HREF="#ulltoa">ulltoa</A>)
<DD>&quot;unsigned long long int&quot; to wide character string
<DT>_ultow (see <A HREF="#ultoa">ultoa</A>)
<DD>&quot;unsigned long int&quot; to wide character string
<DT>_utow (see <A HREF="#utoa">utoa</A>)
<DD>&quot;unsigned int&quot; to wide character string
<DT>wcstod (see <A HREF="#strtod">strtod</A>)
<DD>wide character string to &quot;double&quot;
<DT>wcstol (see <A HREF="#strtol">strtol</A>)
<DD>wide character string to &quot;long int&quot;
<DT>wcstoll (see <A HREF="#strtoll">strtoll</A>)
<DD>wide character string to &quot;long long int&quot;
<DT>wcstoul (see <A HREF="#strtoul">strtoul</A>)
<DD>wide character string to &quot;unsigned long int&quot;
<DT>wcstoull (see <A HREF="#strtoull">strtoull</A>)
<DD>wide character string to &quot;unsigned long long int&quot;
<DT>_wtof (see <A HREF="#atof">atof</A>)
<DD>wide character string to &quot;double&quot;
<DT>_wtoi (see <A HREF="#atoi">atoi</A>)
<DD>wide character string to &quot;int&quot;
<DT>_wtol (see <A HREF="#atol">atol</A>)
<DD>wide character string to &quot;long int&quot;
<DT>_wtoll (see <A HREF="#atoll">atoll</A>)
<DD>wide character string to &quot;long long int&quot;
</DL>
<BR>See also <TT> tolower</TT>, <TT> towlower</TT>, <TT> _mbctolower</TT>, <TT> toupper</TT>, <TT> towupper</TT>, <TT> _mbctoupper</TT>,
<TT> strlwr</TT>, <TT> _wcslwr</TT>, <TT> _mbslwr</TT>, <TT> strupr</TT>, <TT> _wcsupr</TT> and <TT> _mbsupr</TT> which convert
the cases of characters and strings.
<H3 ID="Memory_Allocation_Functions"> Memory Allocation Functions </H3>
<BR>These functions allocate and de-allocate blocks of memory.
<BR><BR>Unless you are running your program in 32-bit protect mode, where segments have a limit of 4 gigabytes, the default
data segment has a maximum size of 64K bytes.&nbsp; It may be less in a machine with insufficient memory or when other programs
in the computer already occupy some of the memory.&nbsp; The <TT> _nmalloc</TT> function allocates space within this area
while the <TT> _fmalloc</TT> function allocates space outside the area (if it is available).
<BR><BR>In a small data model, the <TT> malloc</TT>, <TT> calloc</TT> and <TT> realloc</TT> functions use the <TT> _nmalloc</TT>
function to acquire memory; in a large data model, the <TT> _fmalloc</TT> function is used.
<BR><BR>It is also possible to allocate memory from a based heap using <TT> _bmalloc</TT>.&nbsp; Based heaps are similar to
far heaps in that they are located outside the normal data segment.&nbsp; Based pointers only store the offset portion of
the full address, so they behave much like near pointers.&nbsp; The selector portion of the full address specifies which based
heap a based pointer belongs to, and must be passed to the various based heap functions.
<BR><BR>It is important to use the appropriate memory-deallocation function to free memory blocks.&nbsp; The <TT> _nfree</TT>
function should be used to free space acquired by the <TT> _ncalloc</TT>, <TT> _nmalloc</TT>, or <TT> _nrealloc</TT> functions.
&nbsp;The <TT> _ffree</TT> function should be used to free space acquired by the <TT> _fcalloc</TT>, <TT> _fmalloc</TT>, or
<TT> _frealloc</TT> functions.&nbsp; The <TT> _bfree</TT> function should be used to free space acquired by the <TT> _bcalloc</TT>,
<TT> _bmalloc</TT>, or <TT> _brealloc</TT> functions.
<BR><BR>The <TT> free</TT> function will use the <TT> _nfree</TT> function when the small data memory model is used; it will
use the <TT> _ffree</TT> function when the large data memory model is being used.
<BR><BR>It should be noted that the <TT> _fmalloc</TT> and <TT> _nmalloc</TT> functions can both be used in either data memory
model.&nbsp; The following functions are defined:
<DL>
<DT><A HREF="#alloca">alloca</A>
<DD>allocate auto storage from stack
<DT>_bcalloc (see <A HREF="#calloc">calloc</A>)
<DD>allocate and zero memory from a based heap
<DT>_bexpand (see <A HREF="#_expand">_expand</A>)
<DD>expand a block of memory in a based heap
<DT>_bfree (see <A HREF="#free">free</A>)
<DD>free a block of memory in a based heap
<DT><A HREF="#_bfreeseg">_bfreeseg</A>
<DD>free a based heap
<DT><A HREF="#_bheapseg">_bheapseg</A>
<DD>allocate a based heap
<DT>_bmalloc (see <A HREF="#malloc">malloc</A>)
<DD>allocate a memory block from a based heap
<DT>_bmsize (see <A HREF="#_msize">_msize</A>)
<DD>return the size of a memory block
<DT>_brealloc (see <A HREF="#realloc">realloc</A>)
<DD>re-allocate a memory block in a based heap
<DT><A HREF="#calloc">calloc</A>
<DD>allocate and zero memory
<DT><A HREF="#_expand">_expand</A>
<DD>expand a block of memory
<DT>_fcalloc (see <A HREF="#calloc">calloc</A>)
<DD>allocate and zero a memory block (outside default data segment)
<DT>_fexpand (see <A HREF="#_expand">_expand</A>)
<DD>expand a block of memory (outside default data segment)
<DT>_ffree (see <A HREF="#free">free</A>)
<DD>free a block allocated using &quot;_fmalloc&quot;
<DT>_fmalloc (see <A HREF="#malloc">malloc</A>)
<DD>allocate a memory block (outside default data segment)
<DT>_fmsize (see <A HREF="#_msize">_msize</A>)
<DD>return the size of a memory block
<DT>_frealloc (see <A HREF="#realloc">realloc</A>)
<DD>re-allocate a memory block (outside default data segment)
<DT><A HREF="#free">free</A>
<DD>free a block allocated using &quot;malloc&quot;, &quot;calloc&quot; or &quot;realloc&quot;
<DT><A HREF="#_freect">_freect</A>
<DD>return number of objects that can be allocated
<DT><A HREF="#halloc">halloc</A>
<DD>allocate huge array
<DT><A HREF="#hfree">hfree</A>
<DD>free huge array
<DT><A HREF="#malloc">malloc</A>
<DD>allocate a memory block (using current memory model)
<DT><A HREF="#_memavl">_memavl</A>
<DD>return amount of available memory
<DT><A HREF="#_memmax">_memmax</A>
<DD>return largest block of memory available
<DT><A HREF="#_msize">_msize</A>
<DD>return the size of a memory block
<DT>_ncalloc (see <A HREF="#calloc">calloc</A>)
<DD>allocate and zero a memory block (inside default data segment)
<DT>_nexpand (see <A HREF="#_expand">_expand</A>)
<DD>expand a block of memory (inside default data segment)
<DT>_nfree (see <A HREF="#free">free</A>)
<DD>free a block allocated using &quot;_nmalloc&quot;
<DT>_nmalloc (see <A HREF="#malloc">malloc</A>)
<DD>allocate a memory block (inside default data segment)
<DT>_nmsize (see <A HREF="#_msize">_msize</A>)
<DD>return the size of a memory block
<DT>_nrealloc (see <A HREF="#realloc">realloc</A>)
<DD>re-allocate a memory block (inside default data segment)
<DT><A HREF="#realloc">realloc</A>
<DD>re-allocate a block of memory
<DT><A HREF="#sbrk">sbrk</A>
<DD>set allocation &quot;break&quot; position
<DT><A HREF="#stackavail">stackavail</A>
<DD>determine available amount of stack space
</DL>
<H3 ID="Heap_Functions"> Heap Functions </H3>
<BR>These functions provide the ability to shrink and grow the heap, as well as, find heap related problems.&nbsp; The following
functions are defined:
<DL>
<DT><A HREF="#_heapchk">_heapchk</A>
<DD>perform consistency check on the heap
<DT>_bheapchk (see <A HREF="#_heapchk">_heapchk</A>)
<DD>perform consistency check on a based heap
<DT>_fheapchk (see <A HREF="#_heapchk">_heapchk</A>)
<DD>perform consistency check on the far heap
<DT>_nheapchk (see <A HREF="#_heapchk">_heapchk</A>)
<DD>perform consistency check on the near heap
<DT><A HREF="#_heapgrow">_heapgrow</A>
<DD>grow the heap
<DT>_fheapgrow (see <A HREF="#_heapgrow">_heapgrow</A>)
<DD>grow the far heap
<DT>_nheapgrow (see <A HREF="#_heapgrow">_heapgrow</A>)
<DD>grow the near heap up to its limit of 64K
<DT><A HREF="#_heapmin">_heapmin</A>
<DD>shrink the heap as small as possible
<DT>_bheapmin (see <A HREF="#_heapmin">_heapmin</A>)
<DD>shrink a based heap as small as possible
<DT>_fheapmin (see <A HREF="#_heapmin">_heapmin</A>)
<DD>shrink the far heap as small as possible
<DT>_nheapmin (see <A HREF="#_heapmin">_heapmin</A>)
<DD>shrink the near heap as small as possible
<DT><A HREF="#_heapset">_heapset</A>
<DD>fill unallocated sections of heap with pattern
<DT>_bheapset (see <A HREF="#_heapset">_heapset</A>)
<DD>fill unallocated sections of based heap with pattern
<DT>_fheapset (see <A HREF="#_heapset">_heapset</A>)
<DD>fill unallocated sections of far heap with pattern
<DT>_nheapset (see <A HREF="#_heapset">_heapset</A>)
<DD>fill unallocated sections of near heap with pattern
<DT><A HREF="#_heapshrink">_heapshrink</A>
<DD>shrink the heap as small as possible
<DT>_fheapshrink (see <A HREF="#_heapshrink">_heapshrink</A>)
<DD>shrink the far heap as small as possible
<DT>_bheapshrink (see <A HREF="#_heapshrink">_heapshrink</A>)
<DD>shrink a based heap as small as possible
<DT>_nheapshrink (see <A HREF="#_heapshrink">_heapshrink</A>)
<DD>shrink the near heap as small as possible
<DT><A HREF="#_heapwalk">_heapwalk</A>
<DD>walk through each entry in the heap
<DT>_bheapwalk (see <A HREF="#_heapwalk">_heapwalk</A>)
<DD>walk through each entry in a based heap
<DT>_fheapwalk (see <A HREF="#_heapwalk">_heapwalk</A>)
<DD>walk through each entry in the far heap
<DT>_nheapwalk (see <A HREF="#_heapwalk">_heapwalk</A>)
<DD>walk through each entry in the near heap
</DL>
<H3 ID="Math_Functions"> Math Functions </H3>
<BR>These functions operate with objects of type<TT> double,</TT> also known as floating-point numbers.&nbsp; The Intel 8087
processor (and its successor chips) is commonly used to implement floating-point operations on personal computers.&nbsp; Functions
ending in &quot;87&quot; pertain to this specific hardware and should be isolated in programs when portability is a consideration.
&nbsp;The following functions are defined:
<DL>
<DT><A HREF="#abs">abs</A>
<DD>absolute value of an object of type &quot;int&quot;
<DT><A HREF="#acos">acos</A>
<DD>arccosine
<DT><A HREF="#acosh">acosh</A>
<DD>inverse hyperbolic cosine
<DT><A HREF="#asin">asin</A>
<DD>arcsine
<DT><A HREF="#asinh">asinh</A>
<DD>inverse hyperbolic sine
<DT><A HREF="#atan">atan</A>
<DD>arctangent of one argument
<DT><A HREF="#atan2">atan2</A>
<DD>arctangent of two arguments
<DT><A HREF="#atanh">atanh</A>
<DD>inverse hyperbolic tangent
<DT><A HREF="#bessel">bessel</A>
<DD>bessel functions j0, j1, jn, y0, y1, and yn
<DT><A HREF="#cabs">cabs</A>
<DD>absolute value of complex number
<DT><A HREF="#cbrt">cbrt</A>
<DD>cubed root of a number
<DT><A HREF="#ceil">ceil</A>
<DD>ceiling function
<DT><A HREF="#_clear87">_clear87</A>
<DD>clears floating-point status
<DT><A HREF="#_control87">_control87</A>
<DD>sets new floating-point control word
<DT><A HREF="#copysign">copysign</A>
<DD>copies the sign of one number to another
<DT><A HREF="#cos">cos</A>
<DD>cosine
<DT><A HREF="#cosh">cosh</A>
<DD>hyperbolic cosine
<DT><A HREF="#div">div</A>
<DD>compute quotient, remainder from division of an &quot;int&quot; object
<DT><A HREF="#erf">erf</A>
<DD>computes the error function
<DT><A HREF="#erfc">erfc</A>
<DD>computes the complementary error function
<DT><A HREF="#exp">exp</A>
<DD>exponential function
<DT><A HREF="#exp2">exp2</A>
<DD>two raised to a value
<DT><A HREF="#expm1">expm1</A>
<DD>exponential of a number minus one
<DT><A HREF="#fabs">fabs</A>
<DD>absolute value of &quot;double&quot;
<DT><A HREF="#fdim">fdim</A>
<DD>positive difference of two numbers
<DT><A HREF="#_finite">_finite</A>
<DD>determines whether floating-point value is valid
<DT><A HREF="#floor">floor</A>
<DD>floor function
<DT><A HREF="#fma">fma</A>
<DD>fused multiply-add
<DT><A HREF="#fmax">fmax</A>
<DD>returns larger of two numbers
<DT><A HREF="#fmin">fmin</A>
<DD>returns smaller of two numbers
<DT><A HREF="#fmod">fmod</A>
<DD>modulus function
<DT><A HREF="#_fpreset">_fpreset</A>
<DD>initializes for floating-point operations
<DT><A HREF="#frexp">frexp</A>
<DD>fractional exponent
<DT><A HREF="#hypot">hypot</A>
<DD>compute hypotenuse
<DT><A HREF="#ilogb">ilogb</A>
<DD>retrieve the exponent of a &quot;double&quot;
<DT><A HREF="#imaxabs">imaxabs</A>
<DD>get quotient, remainder from division of object of maximum-size integer type
<DT><A HREF="#imaxdiv">imaxdiv</A>
<DD>absolute value of an object of maximum-size integer type
<DT>j0 (see <A HREF="#bessel">bessel</A>)
<DD>return Bessel functions of the first kind (described under &quot;bessel Functions&quot;)
<DT>j1 (see <A HREF="#bessel">bessel</A>)
<DD>return Bessel functions of the first kind (described under &quot;bessel Functions&quot;)
<DT>jn (see <A HREF="#bessel">bessel</A>)
<DD>return Bessel functions of the first kind (described under &quot;bessel Functions&quot;)
<DT><A HREF="#labs">labs</A>
<DD>absolute value of an object of type &quot;long int&quot;
<DT><A HREF="#ldexp">ldexp</A>
<DD>multiply by a power of two
<DT><A HREF="#ldiv">ldiv</A>
<DD>get quotient, remainder from division of object of type &quot;long int&quot;
<DT><A HREF="#lgamma">lgamma</A>
<DD>natural logarithm of the absolute value of the Gamma function
<DT><A HREF="#lgamma_r">lgamma_r</A>
<DD>natural logarithm of the absolute value of the Gamma function (thread-safe)
<DT><A HREF="#log">log</A>
<DD>natural logarithm
<DT><A HREF="#log10">log10</A>
<DD>logarithm, base 10
<DT><A HREF="#log1p">log1p</A>
<DD>natural logarithm of one plus the argument
<DT><A HREF="#log2">log2</A>
<DD>logarithm, base 2
<DT><A HREF="#logb">logb</A>
<DD>retrieve the exponent of a &quot;double&quot;
<DT><A HREF="#matherr">matherr</A>
<DD>handles error from math functions
<DT><A HREF="#max">max</A>
<DD>return maximum of two arguments
<DT><A HREF="#min">min</A>
<DD>return minimum of two arguments
<DT><A HREF="#modf">modf</A>
<DD>get integral, fractional parts of &quot;double&quot;
<DT><A HREF="#nearbyint">nearbyint</A>
<DD>returns nearest integer based on rounding mode
<DT><A HREF="#nextafter">nextafter</A>
<DD>returns next machine-representable floating point value
<DT><A HREF="#pow">pow</A>
<DD>raise to power
<DT><A HREF="#rand">rand</A>
<DD>random integer
<DT><A HREF="#remainder">remainder</A>
<DD>retrieves the remainder of a division operation
<DT><A HREF="#rint">rint</A>
<DD>returns nearest integer based on rounding mode
<DT><A HREF="#round">round</A>
<DD>rounds to the nearest integer
<DT><A HREF="#scalbn">scalbn</A>
<DD>compute a &quot;double&quot; times two raised to a power
<DT><A HREF="#_set_matherr">_set_matherr</A>
<DD>specify a math error handler
<DT><A HREF="#sin">sin</A>
<DD>sine
<DT><A HREF="#sinh">sinh</A>
<DD>hyperbolic sine
<DT><A HREF="#sqrt">sqrt</A>
<DD>square root
<DT><A HREF="#srand">srand</A>
<DD>set starting point for generation of random numbers using &quot;rand&quot; function
<DT><A HREF="#_status87">_status87</A>
<DD>gets floating-point status
<DT><A HREF="#tan">tan</A>
<DD>tangent
<DT><A HREF="#tanh">tanh</A>
<DD>hyperbolic tangent
<DT><A HREF="#tgamma">tgamma</A>
<DD>compute the Gamma function
<DT><A HREF="#trunc">trunc</A>
<DD>truncate a floating point value
<DT>y0 (see <A HREF="#bessel">bessel</A>)
<DD>return Bessel functions of the second kind (described under &quot;bessel&quot;)
<DT>y1 (see <A HREF="#bessel">bessel</A>)
<DD>return Bessel functions of the second kind (described under &quot;bessel&quot;)
<DT>yn (see <A HREF="#bessel">bessel</A>)
<DD>return Bessel functions of the second kind (described under &quot;bessel&quot;)
</DL>
<H3 ID="Searching_Functions"> Searching Functions </H3>
<BR>These functions provide searching and sorting capabilities.&nbsp; The following functions are defined:
<DL>
<DT><A HREF="#bsearch">bsearch</A>
<DD>find a data item in an array using binary search
<DT><A HREF="#lfind">lfind</A>
<DD>find a data item in an array using linear search
<DT><A HREF="#lsearch">lsearch</A>
<DD>linear search array, add item if not found
<DT><A HREF="#qsort">qsort</A>
<DD>sort an array
</DL>
<H3 ID="Time_Functions"> Time Functions </H3>
<BR>These functions are concerned with dates and times.&nbsp; The following functions are defined:
<DL>
<DT><A HREF="#asctime">asctime</A>
<DD>makes time string from time structure
<DT>_asctime (see <A HREF="#asctime">asctime</A>)
<DD>makes time string from time structure
<DT>_wasctime (see <A HREF="#asctime">asctime</A>)
<DD>makes time string from time structure
<DT>__wasctime (see <A HREF="#asctime">asctime</A>)
<DD>makes time string from time structure
<DT><A HREF="#clock">clock</A>
<DD>gets time since program start
<DT><A HREF="#ctime">ctime</A>
<DD>gets calendar time string
<DT>_ctime (see <A HREF="#ctime">ctime</A>)
<DD>gets calendar time string
<DT>_wctime (see <A HREF="#ctime">ctime</A>)
<DD>gets calendar time string
<DT>__wctime (see <A HREF="#ctime">ctime</A>)
<DD>gets calendar time string
<DT><A HREF="#difftime">difftime</A>
<DD>calculate difference between two times
<DT><A HREF="#ftime">ftime</A>
<DD>returns the current time in a &quot;timeb&quot; structure
<DT><A HREF="#gmtime">gmtime</A>
<DD>convert calendar time to Coordinated Universal Time (UTC)
<DT>_gmtime (see <A HREF="#gmtime">gmtime</A>)
<DD>convert calendar time to Coordinated Universal Time (UTC)
<DT><A HREF="#localtime">localtime</A>
<DD>convert calendar time to local time
<DT>_localtime (see <A HREF="#localtime">localtime</A>)
<DD>convert calendar time to local time
<DT><A HREF="#mktime">mktime</A>
<DD>make calendar time from local time
<DT><A HREF="#_strdate">_strdate</A>
<DD>return date in buffer
<DT><A HREF="#strftime">strftime</A>
<DD>format date and time
<DT>wcsftime (see <A HREF="#strftime">strftime</A>)
<DD>format date and time
<DT>_wstrftime_ms (see <A HREF="#strftime">strftime</A>)
<DD>format date and time
<DT><A HREF="#_strtime">_strtime</A>
<DD>return time in buffer
<DT>_wstrtime (see <A HREF="#_strtime">_strtime</A>)
<DD>return time in buffer
<DT><A HREF="#time">time</A>
<DD>get current calendar time
<DT><A HREF="#tzset">tzset</A>
<DD>set global variables to reflect the local time zone
<DT>_wstrdate (see <A HREF="#_strdate">_strdate</A>)
<DD>return date in buffer
</DL>
<H3 ID="VariableMlength_Argument_Lists"> Variable-length Argument Lists </H3>
<BR>Variable-length argument lists are used when a function does not have a fixed number of arguments.&nbsp; These macros
provide the capability to access these arguments.&nbsp; The following functions are defined:
<DL>
<DT><A HREF="#va_arg">va_arg</A>
<DD>get next variable argument
<DT><A HREF="#va_end">va_end</A>
<DD>complete access of variable arguments
<DT><A HREF="#va_start">va_start</A>
<DD>start access of variable arguments
</DL>
<H3 ID="Stream_IDO_Functions"> Stream I/O Functions </H3>
<BR>A<B> stream</B> is the name given to a file or device which has been opened for data transmission.&nbsp; When a stream
is opened, a pointer to a <TT> FILE</TT> structure is returned.&nbsp; This pointer is used to reference the stream when other
functions are subsequently invoked.
<BR><BR>There are two modes by which data can be transmitted:
<DL>
<DT>binary
<DD>Data is transmitted unchanged.
<DT>text
<DD>On input, carriage-return characters are removed before following linefeed characters.&nbsp; On output, carriage-return characters
are inserted before linefeed characters.
</DL>
<BR>These modes are required since text files are stored with the two characters delimiting a line of text, while the C convention
is for only the linefeed character to delimit a text line.
<BR><BR>When a program begins execution, there are a number of streams already open for use:
<DL>
<DT>stdin
<DD>Standard Input:&nbsp; input from the console
<DT>stdout
<DD>Standard Output:&nbsp; output to the console 
<DT>stderr
<DD>Standard Error:&nbsp; output to the console (used for error messages)
<DT>stdaux
<DD>Standard Auxiliary:&nbsp; auxiliary port, available for use by a program (not available in some Windows platforms)
<DT>stdprn
<DD>Standard Printer:&nbsp; available for use by a program (not available in some Windows platforms)
</DL>
<BR>These standard streams may be re-directed by use of the <TT> freopen</TT> function.
<BR><BR>See also the section<B> File Manipulation Functions</B> for other functions which operate upon files.
<BR><BR>The functions referenced in the section<B> Operating System I/O Functions</B> may also be invoked (use the <TT> fileno</TT>
function to obtain the file handle).&nbsp; Since the stream functions may buffer input and output, these functions should
be used with caution to avoid unexpected results.
<BR><BR>The following functions are defined:
<DL>
<DT><A HREF="#clearerr">clearerr</A>
<DD>clear end-of-file and error indicators for stream
<DT><A HREF="#fclose">fclose</A>
<DD>close stream
<DT><A HREF="#fcloseall">fcloseall</A>
<DD>close all open streams
<DT><A HREF="#fdopen">fdopen</A>
<DD>open stream, given handle
<DT><A HREF="#feof">feof</A>
<DD>test for end of file
<DT><A HREF="#ferror">ferror</A>
<DD>test for file error
<DT><A HREF="#fflush">fflush</A>
<DD>flush output buffer
<DT><A HREF="#fgetc">fgetc</A>
<DD>get next character from file
<DT>_fgetchar (see <A HREF="#fgetchar">fgetchar</A>)
<DD>equivalent to &quot;fgetc&quot; with the argument &quot;stdin&quot;
<DT><A HREF="#fgetpos">fgetpos</A>
<DD>get current file position
<DT><A HREF="#fgets">fgets</A>
<DD>get a string
<DT><A HREF="#flushall">flushall</A>
<DD>flush output buffers for all streams
<DT><A HREF="#fopen">fopen</A>
<DD>open a stream
<DT><A HREF="#fprintf">fprintf</A>
<DD>format output
<DT><A HREF="#fputc">fputc</A>
<DD>write a character
<DT>_fputchar (see <A HREF="#fputchar">fputchar</A>)
<DD>write a character to the &quot;stdout&quot; stream
<DT><A HREF="#fputs">fputs</A>
<DD>write a string
<DT><A HREF="#fread">fread</A>
<DD>read a number of objects
<DT><A HREF="#freopen">freopen</A>
<DD>re-opens a stream
<DT><A HREF="#fscanf">fscanf</A>
<DD>scan input according to format
<DT><A HREF="#fseek">fseek</A>
<DD>set current file position, relative
<DT><A HREF="#fsetpos">fsetpos</A>
<DD>set current file position, absolute
<DT><A HREF="#_fsopen">_fsopen</A>
<DD>open a shared stream
<DT><A HREF="#ftell">ftell</A>
<DD>get current file position
<DT><A HREF="#fwrite">fwrite</A>
<DD>write a number of objects
<DT><A HREF="#getc">getc</A>
<DD>read character
<DT><A HREF="#getchar">getchar</A>
<DD>get next character from &quot;stdin&quot;
<DT><A HREF="#gets">gets</A>
<DD>get string from &quot;stdin&quot;
<DT><A HREF="#_getw">_getw</A>
<DD>read int from stream file
<DT><A HREF="#perror">perror</A>
<DD>write error message to &quot;stderr&quot; stream
<DT><A HREF="#printf">printf</A>
<DD>format output to &quot;stdout&quot;
<DT><A HREF="#putc">putc</A>
<DD>write character to file
<DT><A HREF="#putchar">putchar</A>
<DD>write character to &quot;stdout&quot;
<DT><A HREF="#puts">puts</A>
<DD>write string to &quot;stdout&quot;
<DT><A HREF="#_putw">_putw</A>
<DD>write int to stream file
<DT><A HREF="#rewind">rewind</A>
<DD>position to start of file
<DT><A HREF="#scanf">scanf</A>
<DD>scan input from &quot;stdin&quot; under format control
<DT><A HREF="#setbuf">setbuf</A>
<DD>set buffer
<DT><A HREF="#setvbuf">setvbuf</A>
<DD>set buffering
<DT><A HREF="#tmpfile">tmpfile</A>
<DD>create temporary file
<DT><A HREF="#ungetc">ungetc</A>
<DD>push character back on input stream
<DT><A HREF="#vfprintf">vfprintf</A>
<DD>same as &quot;fprintf&quot; but with variable arguments
<DT><A HREF="#vfscanf">vfscanf</A>
<DD>same as &quot;fscanf&quot; but with variable arguments
<DT><A HREF="#vprintf">vprintf</A>
<DD>same as &quot;printf&quot; but with variable arguments
<DT><A HREF="#vscanf">vscanf</A>
<DD>same as &quot;scanf&quot; but with variable arguments
</DL>
<BR>See the section<B> Directory Functions</B> for functions which are related to directories.
<H3 ID="Wide_Character_Stream_IDO_Functions"> Wide Character Stream I/O Functions </H3>
<BR>The previous section describes some general aspects of stream input/output.&nbsp; The following describes functions dealing
with streams containing multibyte character sequences.
<BR><BR>After a stream is associated with an external file, but before any operations are performed on it, the stream is without
orientation.&nbsp; Once a wide character input/output function has been applied to a stream without orientation, the stream
becomes<B> wide-oriented.</B>&nbsp; Similarly, once a byte input/output function has been applied to a stream without orientation,
the stream becomes<B> byte-oriented.</B>&nbsp; Only a successful call to <TT> freopen</TT> can otherwise alter the orientation
of a stream (it removes any orientation).&nbsp; You cannot mix byte input/output functions and wide character input/output
functions on the same stream.
<BR><BR>A file positioning function can cause the next wide character output function to overwrite a partial multibyte character.
&nbsp;This can lead to the subsequent reading of a stream of multibyte characters containing an invalid character.
<BR><BR>When multibyte characters are read from a stream, they are converted to wide characters.&nbsp; Similarly, when wide
characters are written to a stream, they are converted to multibyte characters.
<BR><BR>The following functions are defined:
<DL>
<DT>fgetwc (see <A HREF="#fgetc">fgetc</A>)
<DD>get next wide character from file
<DT>_fgetwchar (see <A HREF="#fgetchar">fgetchar</A>)
<DD>equivalent to &quot;fgetwc&quot; with the argument &quot;stdin&quot;
<DT>fgetws (see <A HREF="#fgets">fgets</A>)
<DD>get a wide character string
<DT><A HREF="#fprintf">fprintf</A>
<DD>&quot;C&quot; and &quot;S&quot; extensions to the format specifier
<DT>fputwc (see <A HREF="#fputc">fputc</A>)
<DD>write a wide character
<DT>_fputwchar (see <A HREF="#fputchar">fputchar</A>)
<DD>write a character to the &quot;stdout&quot; stream
<DT>fputws (see <A HREF="#fputs">fputs</A>)
<DD>write a wide character string
<DT><A HREF="#fscanf">fscanf</A>
<DD>&quot;C&quot; and &quot;S&quot; extensions to the format specifier
<DT>fwprintf (see <A HREF="#fprintf">fprintf</A>)
<DD>formatted wide character output
<DT>fwscanf (see <A HREF="#fscanf">fscanf</A>)
<DD>scan wide character input according to format
<DT>getwc (see <A HREF="#getc">getc</A>)
<DD>read wide character
<DT>getwchar (see <A HREF="#getchar">getchar</A>)
<DD>get next wide character from &quot;stdin&quot;
<DT>_getws (see <A HREF="#gets">gets</A>)
<DD>get wide character string from &quot;stdin&quot;
<DT>putwc (see <A HREF="#putc">putc</A>)
<DD>write wide character to file
<DT>putwchar (see <A HREF="#putchar">putchar</A>)
<DD>write wide character to &quot;stdout&quot;
<DT>_putws (see <A HREF="#puts">puts</A>)
<DD>write wide character string to &quot;stdout&quot;
<DT>ungetwc (see <A HREF="#ungetc">ungetc</A>)
<DD>push wide character back on input stream
<DT>vfwprintf (see <A HREF="#vfprintf">vfprintf</A>)
<DD>same as &quot;fwprintf&quot; but with variable arguments
<DT>vfwscanf (see <A HREF="#vfscanf">vfscanf</A>)
<DD>same as &quot;fwscanf&quot; but with variable arguments
<DT>vswprintf (see <A HREF="#vsprintf">vsprintf</A>)
<DD>same as &quot;swprintf&quot; but with variable arguments
<DT>vwprintf (see <A HREF="#vprintf">vprintf</A>)
<DD>same as &quot;wprintf&quot; but with variable arguments
<DT>vwscanf (see <A HREF="#vscanf">vscanf</A>)
<DD>same as &quot;wscanf&quot; but with variable arguments
<DT>_wfdopen (see <A HREF="#fdopen">fdopen</A>)
<DD>open stream, given handle using a wide character &quot;mode&quot;
<DT>_wfopen (see <A HREF="#fopen">fopen</A>)
<DD>open a stream using wide character arguments
<DT>_wfreopen (see <A HREF="#freopen">freopen</A>)
<DD>re-opens a stream using wide character arguments
<DT>_wfsopen (see <A HREF="#_fsopen">_fsopen</A>)
<DD>open a shared stream using wide character arguments
<DT>_wperror (see <A HREF="#perror">perror</A>)
<DD>write error message to &quot;stderr&quot; stream
<DT>wprintf (see <A HREF="#printf">printf</A>)
<DD>format wide character output to &quot;stdout&quot;
<DT>wscanf (see <A HREF="#scanf">scanf</A>)
<DD>scan wide character input from &quot;stdin&quot; under format control
</DL>
<BR>See the section<B> Directory Functions</B> for functions which are related to directories.
<H3 ID="Process_Primitive_Functions"> Process Primitive Functions </H3>
<BR>These functions deal with process creation, execution and termination, signal handling, and timer operations.
<BR><BR>When a new process is started, it may replace the existing process
<UL>
<LI><TT> P_OVERLAY</TT> is specified with the <TT> spawn...</TT>&nbsp; functions
<LI>the <TT> exec...</TT>&nbsp; routines are invoked
</UL>
<BR>or the existing process may be suspended while the new process executes (control continues at the point following the
place where the new process was started)
<UL>
<LI><TT> P_WAIT</TT> is specified with the <TT> spawn...</TT>&nbsp; functions
<LI><TT> system</TT> is used
</UL>
<BR>The following functions are defined:
<DL>
<DT><A HREF="#abort">abort</A>
<DD>immediate termination of process, return code 3
<DT><A HREF="#atexit">atexit</A>
<DD>register exit routine
<DT><A HREF="#_beginthread">_beginthread</A>
<DD>start a new thread of execution
<DT><A HREF="#cwait">cwait</A>
<DD>wait for a child process to terminate
<DT>_cwait (see <A HREF="#cwait">cwait</A>)
<DD>wait for a child process to terminate
<DT><A HREF="#delay">delay</A>
<DD>delay for number of milliseconds
<DT><A HREF="#_endthread">_endthread</A>
<DD>end the current thread
<DT>execl (see <A HREF="#exec___">exec...</A>)
<DD>chain to program
<DT>_execl (see <A HREF="#exec___">exec...</A>)
<DD>chain to program
<DT>execle (see <A HREF="#exec___">exec...</A>)
<DD>chain to program, pass environment
<DT>_execle (see <A HREF="#exec___">exec...</A>)
<DD>chain to program, pass environment
<DT>execlp (see <A HREF="#exec___">exec...</A>)
<DD>chain to program
<DT>_execlp (see <A HREF="#exec___">exec...</A>)
<DD>chain to program
<DT>execlpe (see <A HREF="#exec___">exec...</A>)
<DD>chain to program, pass environment
<DT>_execlpe (see <A HREF="#exec___">exec...</A>)
<DD>chain to program, pass environment
<DT>execv (see <A HREF="#exec___">exec...</A>)
<DD>chain to program
<DT>_execv (see <A HREF="#exec___">exec...</A>)
<DD>chain to program
<DT>execve (see <A HREF="#exec___">exec...</A>)
<DD>chain to program, pass environment
<DT>_execve (see <A HREF="#exec___">exec...</A>)
<DD>chain to program, pass environment
<DT>execvp (see <A HREF="#exec___">exec...</A>)
<DD>chain to program
<DT>_execvp (see <A HREF="#exec___">exec...</A>)
<DD>chain to program
<DT>execvpe (see <A HREF="#exec___">exec...</A>)
<DD>chain to program, pass environment
<DT>_execvpe (see <A HREF="#exec___">exec...</A>)
<DD>chain to program, pass environment
<DT><A HREF="#exit">exit</A>
<DD>exit process, set return code
<DT><A HREF="#_Exit">_Exit</A>
<DD>exit process, set return code
<DT>_exit (see <A HREF="#_Exit">_Exit</A>)
<DD>exit process, set return code
<DT><A HREF="#onexit">onexit</A>
<DD>register exit routine
<DT><A HREF="#raise">raise</A>
<DD>signal an exceptional condition
<DT><A HREF="#signal">signal</A>
<DD>set handling for exceptional condition
<DT><A HREF="#sleep">sleep</A>
<DD>delay for number of seconds
<DT>spawnl (see <A HREF="#spawn___">spawn...</A>)
<DD>create process
<DT>_spawnl (see <A HREF="#spawn___">spawn...</A>)
<DD>create process
<DT>spawnle (see <A HREF="#spawn___">spawn...</A>)
<DD>create process, set environment
<DT>_spawnle (see <A HREF="#spawn___">spawn...</A>)
<DD>create process, set environment
<DT>spawnlp (see <A HREF="#spawn___">spawn...</A>)
<DD>create process
<DT>_spawnlp (see <A HREF="#spawn___">spawn...</A>)
<DD>create process
<DT>spawnlpe (see <A HREF="#spawn___">spawn...</A>)
<DD>create process, set environment
<DT>_spawnlpe (see <A HREF="#spawn___">spawn...</A>)
<DD>create process, set environment
<DT>spawnv (see <A HREF="#spawn___">spawn...</A>)
<DD>create process
<DT>_spawnv (see <A HREF="#spawn___">spawn...</A>)
<DD>create process
<DT>spawnve (see <A HREF="#spawn___">spawn...</A>)
<DD>create process, set environment
<DT>_spawnve (see <A HREF="#spawn___">spawn...</A>)
<DD>create process, set environment
<DT>spawnvp (see <A HREF="#spawn___">spawn...</A>)
<DD>create process
<DT>_spawnvp (see <A HREF="#spawn___">spawn...</A>)
<DD>create process
<DT>spawnvpe (see <A HREF="#spawn___">spawn...</A>)
<DD>create process, set environment
<DT>_spawnvpe (see <A HREF="#spawn___">spawn...</A>)
<DD>create process, set environment
<DT><A HREF="#system">system</A>
<DD>execute system command
<DT><A HREF="#wait">wait</A>
<DD>wait for any child process to terminate
<DT>_wexecl (see <A HREF="#exec___">exec...</A>)
<DD>chain to program
<DT>_wexecle (see <A HREF="#exec___">exec...</A>)
<DD>chain to program, pass environment
<DT>_wexeclp (see <A HREF="#exec___">exec...</A>)
<DD>chain to program
<DT>_wexeclpe (see <A HREF="#exec___">exec...</A>)
<DD>chain to program, pass environment
<DT>_wexecv (see <A HREF="#exec___">exec...</A>)
<DD>chain to program
<DT>_wexecve (see <A HREF="#exec___">exec...</A>)
<DD>chain to program, pass environment
<DT>_wexecvp (see <A HREF="#exec___">exec...</A>)
<DD>chain to program
<DT>_wexecvpe (see <A HREF="#exec___">exec...</A>)
<DD>chain to program, pass environment
<DT>_wspawnl (see <A HREF="#spawn___">spawn...</A>)
<DD>create process
<DT>_wspawnle (see <A HREF="#spawn___">spawn...</A>)
<DD>create process, set environment
<DT>_wspawnlp (see <A HREF="#spawn___">spawn...</A>)
<DD>create process
<DT>_wspawnlpe (see <A HREF="#spawn___">spawn...</A>)
<DD>create process, set environment
<DT>_wspawnv (see <A HREF="#spawn___">spawn...</A>)
<DD>create process
<DT>_wspawnve (see <A HREF="#spawn___">spawn...</A>)
<DD>create process, set environment
<DT>_wspawnvp (see <A HREF="#spawn___">spawn...</A>)
<DD>create process
<DT>_wspawnvpe (see <A HREF="#spawn___">spawn...</A>)
<DD>create process, set environment
<DT>_wsystem (see <A HREF="#system">system</A>)
<DD>execute system command
</DL>
<BR>There are eight <TT> spawn...</TT>&nbsp; and <TT> exec...</TT>&nbsp; functions each.&nbsp; The<TT> &quot;...&quot;</TT>
is one to three letters:
<UL>
<LI>&quot;l&quot; or &quot;v&quot; (one is required) to indicate the way the process parameters are passed
<LI>&quot;p&quot; (optional) to indicate whether the<B> PATH</B> environment variable is searched to locate the program for
the process
<LI>&quot;e&quot; (optional) to indicate that the environment variables are being passed
</UL>
<H3 ID="Process_Environment"> Process Environment </H3>
<BR>These functions deal with process identification, process groups, system identification, system time, environment variables,
and terminal identification.&nbsp; The following functions are defined:
<DL>
<DT><A HREF="#_bgetcmd">_bgetcmd</A>
<DD>get command line
<DT><A HREF="#clearenv">clearenv</A>
<DD>delete environment variables
<DT><A HREF="#getcmd">getcmd</A>
<DD>get command line
<DT><A HREF="#getegid">getegid</A>
<DD>get effective group ID of calling process
<DT><A HREF="#getenv">getenv</A>
<DD>get environment variable value
<DT><A HREF="#geteuid">geteuid</A>
<DD>get effective user ID
<DT><A HREF="#getgid">getgid</A>
<DD>get real group ID of calling process
<DT><A HREF="#getpgrp">getpgrp</A>
<DD>get process group ID of calling process
<DT><A HREF="#getpid">getpid</A>
<DD>get process ID of calling process
<DT>_getpid (see <A HREF="#getpid">getpid</A>)
<DD>get process ID of calling process
<DT><A HREF="#getppid">getppid</A>
<DD>get parent process ID of calling process
<DT><A HREF="#gettid">gettid</A>
<DD>get thread ID of current thread
<DT><A HREF="#getuid">getuid</A>
<DD>get real user ID
<DT><A HREF="#isatty">isatty</A>
<DD>determine if file descriptor associated with a terminal
<DT><A HREF="#putenv">putenv</A>
<DD>add, change or delete environment variable
<DT><A HREF="#_searchenv">_searchenv</A>
<DD>search for a file in list of directories
<DT><A HREF="#setenv">setenv</A>
<DD>add, change or delete environment variable
<DT><A HREF="#sysconf">sysconf</A>
<DD>determine value of configurable system limit or option
<DT><A HREF="#ttyname">ttyname</A>
<DD>return pointer to string containing pathname of terminal associated with file descriptor argument
<DT>_wgetenv (see <A HREF="#getenv">getenv</A>)
<DD>get environment variable value
<DT>_wputenv (see <A HREF="#putenv">putenv</A>)
<DD>add, change or delete environment variable
<DT>_wsearchenv (see <A HREF="#_searchenv">_searchenv</A>)
<DD>search for a file in list of directories
<DT>_wsetenv (see <A HREF="#setenv">setenv</A>)
<DD>add, change or delete environment variable
</DL>
<H3 ID="Directory_Functions"> Directory Functions </H3>
<BR>These functions pertain to directory manipulation.&nbsp; The following functions are defined:
<DL>
<DT><A HREF="#chdir">chdir</A>
<DD>change current working directory
<DT><A HREF="#closedir">closedir</A>
<DD>close opened directory file
<DT><A HREF="#getcwd">getcwd</A>
<DD>get current working directory
<DT><A HREF="#_getdcwd">_getdcwd</A>
<DD>get current directory on drive
<DT><A HREF="#mkdir">mkdir</A>
<DD>make a new directory
<DT><A HREF="#opendir">opendir</A>
<DD>open directory file
<DT><A HREF="#readdir">readdir</A>
<DD>read file name from directory
<DT><A HREF="#rewinddir">rewinddir</A>
<DD>reset position of directory stream
<DT><A HREF="#rmdir">rmdir</A>
<DD>remove a directory
<DT>_wchdir (see <A HREF="#chdir">chdir</A>)
<DD>change current working directory
<DT>_wclosedir (see <A HREF="#closedir">closedir</A>)
<DD>close opened directory file
<DT>_wgetcwd (see <A HREF="#getcwd">getcwd</A>)
<DD>get current working directory
<DT>_wgetdcwd (see <A HREF="#_getdcwd">_getdcwd</A>)
<DD>get current directory on drive
<DT>_wmkdir (see <A HREF="#mkdir">mkdir</A>)
<DD>make a new directory
<DT>_wopendir (see <A HREF="#opendir">opendir</A>)
<DD>open directory file
<DT>_wreaddir (see <A HREF="#readdir">readdir</A>)
<DD>read file name from directory
<DT>_wrewinddir (see <A HREF="#rewinddir">rewinddir</A>)
<DD>reset position of directory stream
<DT>_wrmdir (see <A HREF="#rmdir">rmdir</A>)
<DD>remove a directory
</DL>
<H3 ID="Operating_System_IDO_Functions"> Operating System I/O Functions </H3>
<BR>These functions operate at the operating-system level and are included for compatibility with other C implementations.
&nbsp;It is recommended that the functions used in the section<B> File Manipulation Functions</B> be used for new programs,
as these functions are defined portably and are part of the ISO/ANSI standard for the C language.
<BR><BR>The functions in this section reference opened files and devices using a<B> file handle</B> which is returned when
the file is opened.&nbsp; The file handle is passed to the other functions.
<BR><BR>The following functions are defined:
<DL>
<DT><A HREF="#chsize">chsize</A>
<DD>change the size of a file
<DT><A HREF="#close">close</A>
<DD>close file
<DT><A HREF="#_commit">_commit</A>
<DD>commit changes to disk
<DT><A HREF="#creat">creat</A>
<DD>create a file
<DT><A HREF="#dup">dup</A>
<DD>duplicate file handle, get unused handle number
<DT><A HREF="#dup2">dup2</A>
<DD>duplicate file handle, supply new handle number
<DT><A HREF="#eof">eof</A>
<DD>test for end of file
<DT><A HREF="#filelength">filelength</A>
<DD>get file size
<DT><A HREF="#fileno">fileno</A>
<DD>get file handle for stream file
<DT><A HREF="#fstat">fstat</A>
<DD>get file status
<DT><A HREF="#fsync">fsync</A>
<DD>write queued file and filesystem data to disk
<DT><A HREF="#_hdopen">_hdopen</A>
<DD>get POSIX handle from OS handle
<DT><A HREF="#lock">lock</A>
<DD>lock a section of a file
<DT><A HREF="#locking">locking</A>
<DD>lock/unlock a section of a file
<DT><A HREF="#lseek">lseek</A>
<DD>set current file position
<DT><A HREF="#open">open</A>
<DD>open a file
<DT><A HREF="#_os_handle">_os_handle</A>
<DD>get OS handle from POSIX handle
<DT><A HREF="#_pclose">_pclose</A>
<DD>close a pipe
<DT><A HREF="#pclose">pclose</A>
<DD>close a pipe
<DT><A HREF="#_popen">_popen</A>
<DD>open a pipe
<DT><A HREF="#popen">popen</A>
<DD>open a pipe
<DT><A HREF="#read">read</A>
<DD>read a record
<DT><A HREF="#setmode">setmode</A>
<DD>set file mode
<DT><A HREF="#sopen">sopen</A>
<DD>open a file for shared access
<DT><A HREF="#tell">tell</A>
<DD>get current file position
<DT><A HREF="#umask">umask</A>
<DD>set file permission mask
<DT><A HREF="#unlink">unlink</A>
<DD>delete a file
<DT><A HREF="#unlock">unlock</A>
<DD>unlock a section of a file
<DT><A HREF="#write">write</A>
<DD>write a record
<DT>_wcreat (see <A HREF="#creat">creat</A>)
<DD>create a file
<DT>_wopen (see <A HREF="#open">open</A>)
<DD>open a file
<DT>_wpopen (see <A HREF="#_popen">_popen</A>)
<DD>open a pipe
<DT>_wsopen (see <A HREF="#sopen">sopen</A>)
<DD>open a file for shared access
<DT>_wunlink (see <A HREF="#unlink">unlink</A>)
<DD>delete a file
</DL>
<H3 ID="File_Manipulation_Functions"> File Manipulation Functions </H3>
<BR>These functions operate directly with files.&nbsp; The following functions are defined:
<DL>
<DT><A HREF="#access">access</A>
<DD>test file or directory for mode of access
<DT><A HREF="#chmod">chmod</A>
<DD>change permissions for a file
<DT>lstat (see <A HREF="#stat">stat</A>)
<DD>get file status
<DT><A HREF="#remove">remove</A>
<DD>delete a file
<DT><A HREF="#rename">rename</A>
<DD>rename a file
<DT><A HREF="#stat">stat</A>
<DD>get file status
<DT><A HREF="#tmpnam">tmpnam</A>
<DD>create name for temporary file
<DT><A HREF="#utime">utime</A>
<DD>set modification time for a file
<DT>_waccess (see <A HREF="#access">access</A>)
<DD>test file or directory for mode of access
<DT>_wchmod (see <A HREF="#chmod">chmod</A>)
<DD>change permissions for a file
<DT>_wremove (see <A HREF="#remove">remove</A>)
<DD>delete a file
<DT>_wrename (see <A HREF="#rename">rename</A>)
<DD>rename a file
<DT>_wstat (see <A HREF="#stat">stat</A>)
<DD>get file status
<DT>_wtmpnam (see <A HREF="#tmpnam">tmpnam</A>)
<DD>create name for temporary file
<DT>_wutime (see <A HREF="#utime">utime</A>)
<DD>set modification time for a file
</DL>
<H3 ID="Console_IDO_Functions"> Console I/O Functions </H3>
<BR>These functions provide the capability to read and write data from the console.&nbsp; Data is read or written without
any special initialization (devices are not opened or closed), since the functions operate at the hardware level.
<BR><BR>The following functions are defined:
<DL>
<DT><A HREF="#cgets">cgets</A>
<DD>get a string from the console
<DT><A HREF="#cprintf">cprintf</A>
<DD>print formatted string to the console
<DT><A HREF="#cputs">cputs</A>
<DD>write a string to the console
<DT><A HREF="#cscanf">cscanf</A>
<DD>scan formatted data from the console
<DT><A HREF="#getch">getch</A>
<DD>get character from console, no echo
<DT><A HREF="#getche">getche</A>
<DD>get character from console, echo it
<DT><A HREF="#kbhit">kbhit</A>
<DD>test if keystroke available
<DT><A HREF="#putch">putch</A>
<DD>write a character to the console
<DT><A HREF="#ungetch">ungetch</A>
<DD>push back next character from console
</DL>
<H3 ID="Default_Windowing_Functions"> Default Windowing Functions </H3>
<BR>These functions provide the capability to manipulate attributes of various windows created by Open Watcom's default windowing
system for Microsoft Windows and IBM OS/2.
<BR><BR>The following functions are defined:
<DL>
<DT><A HREF="#_dwDeleteOnClose">_dwDeleteOnClose</A>
<DD>delete console window upon close
<DT><A HREF="#_dwSetAboutDlg">_dwSetAboutDlg</A>
<DD>set about dialogue box title and contents
<DT><A HREF="#_dwSetAppTitle">_dwSetAppTitle</A>
<DD>set main window's application title
<DT><A HREF="#_dwSetConTitle">_dwSetConTitle</A>
<DD>set console window's title
<DT><A HREF="#_dwShutDown">_dwShutDown</A>
<DD>shut down default windowing system
<DT><A HREF="#_dwYield">_dwYield</A>
<DD>yield control to other processes
</DL>
<H3 ID="BIOS_Functions"> BIOS Functions </H3>
<BR>This set of functions allows access to services provided by the BIOS.&nbsp; The following functions are defined:
<DL>
<DT><A HREF="#_bios_disk">_bios_disk</A>
<DD>provide disk access functions
<DT><A HREF="#_bios_equiplist">_bios_equiplist</A>
<DD>determine equipment list
<DT><A HREF="#_bios_keybrd">_bios_keybrd</A>
<DD>provide low-level keyboard access
<DT><A HREF="#_bios_memsize">_bios_memsize</A>
<DD>determine amount of system board memory
<DT><A HREF="#_bios_printer">_bios_printer</A>
<DD>provide access to printer services
<DT><A HREF="#_bios_serialcom">_bios_serialcom</A>
<DD>provide access to serial services
<DT><A HREF="#_bios_timeofday">_bios_timeofday</A>
<DD>get and set system clock
</DL>
<H3 ID="DOSMSpecific_Functions"> DOS-Specific Functions </H3>
<BR>These functions provide the capability to invoke DOS functions directly from a program.&nbsp; The following functions
are defined:
<DL>
<DT><A HREF="#bdos">bdos</A>
<DD>DOS call (short form)
<DT><A HREF="#dosexterr">dosexterr</A>
<DD>extract DOS error information
<DT><A HREF="#_dos_allocmem">_dos_allocmem</A>
<DD>allocate a block of memory
<DT><A HREF="#_dos_close">_dos_close</A>
<DD>close a file
<DT><A HREF="#_dos_commit">_dos_commit</A>
<DD>flush buffers to disk
<DT><A HREF="#_dos_creat">_dos_creat</A>
<DD>create a file
<DT><A HREF="#_dos_creatnew">_dos_creatnew</A>
<DD>create a new file
<DT>_dos_findclose (see <A HREF="#_dos_find___">_dos_find...</A>)
<DD>close find file matching
<DT>_dos_findfirst (see <A HREF="#_dos_find___">_dos_find...</A>)
<DD>find first file matching a specified pattern
<DT>_dos_findnext (see <A HREF="#_dos_find___">_dos_find...</A>)
<DD>find the next file matching a specified pattern
<DT><A HREF="#_dos_freemem">_dos_freemem</A>
<DD>free a block of memory
<DT><A HREF="#_dos_getdate">_dos_getdate</A>
<DD>get current system date
<DT><A HREF="#_dos_getdiskfree">_dos_getdiskfree</A>
<DD>get information about disk
<DT><A HREF="#_dos_getdrive">_dos_getdrive</A>
<DD>get the current drive
<DT><A HREF="#_dos_getfileattr">_dos_getfileattr</A>
<DD>get file attributes
<DT><A HREF="#_dos_getftime">_dos_getftime</A>
<DD>get file's last modification time
<DT><A HREF="#_dos_gettime">_dos_gettime</A>
<DD>get the current system time
<DT><A HREF="#_dos_getvect">_dos_getvect</A>
<DD>get contents of interrupt vector
<DT><A HREF="#_dos_keep">_dos_keep</A>
<DD>install a terminate-and-stay-resident program
<DT><A HREF="#_dos_open">_dos_open</A>
<DD>open a file
<DT><A HREF="#_dos_read">_dos_read</A>
<DD>read data from a file
<DT><A HREF="#_dos_setblock">_dos_setblock</A>
<DD>change the size of allocated block
<DT><A HREF="#_dos_setdate">_dos_setdate</A>
<DD>change current system date
<DT><A HREF="#_dos_setdrive">_dos_setdrive</A>
<DD>change the current default drive
<DT><A HREF="#_dos_setfileattr">_dos_setfileattr</A>
<DD>set the attributes of a file
<DT><A HREF="#_dos_setftime">_dos_setftime</A>
<DD>set a file's last modification time
<DT><A HREF="#_dos_settime">_dos_settime</A>
<DD>set the current system time
<DT><A HREF="#_dos_setvect">_dos_setvect</A>
<DD>set an interrupt vector
<DT><A HREF="#_dos_write">_dos_write</A>
<DD>write data to a file
<DT><A HREF="#intdos">intdos</A>
<DD>cause DOS interrupt
<DT><A HREF="#intdosx">intdosx</A>
<DD>cause DOS interrupt, with segment registers
<DT>_wdos_findclose (see <A HREF="#_dos_find___">_dos_find...</A>)
<DD>close find file matching
<DT>_wdos_findfirst (see <A HREF="#_dos_find___">_dos_find...</A>)
<DD>find first file matching a specified pattern
<DT>_wdos_findnext (see <A HREF="#_dos_find___">_dos_find...</A>)
<DD>find the next file matching a specified pattern
</DL>
<H3 ID="Intel_80x86_ArchitectureMSpecific_Functions"> Intel 80x86 Architecture-Specific Functions </H3>
<BR>These functions provide the capability to invoke Intel 80x86 processor-related functions directly from a program.&nbsp;
Functions that apply to the Intel 8086 CPU apply to that family including the 80286, 80386, 80486 and Pentium processors.
&nbsp;The following functions are defined:
<DL>
<DT><A HREF="#_chain_intr">_chain_intr</A>
<DD>chain to the previous interrupt handler
<DT><A HREF="#_disable">_disable</A>
<DD>disable interrupts
<DT><A HREF="#_enable">_enable</A>
<DD>enable interrupts
<DT><A HREF="#FP_OFF">FP_OFF</A>
<DD>get offset part of far pointer
<DT><A HREF="#FP_SEG">FP_SEG</A>
<DD>get segment part of far pointer
<DT><A HREF="#inp">inp</A>
<DD>get one byte from hardware port
<DT><A HREF="#inpw">inpw</A>
<DD>get two bytes (one word) from hardware port
<DT><A HREF="#int386">int386</A>
<DD>cause 386/486/Pentium CPU interrupt
<DT><A HREF="#int386x">int386x</A>
<DD>cause 386/486/Pentium CPU interrupt, with segment registers
<DT><A HREF="#int86">int86</A>
<DD>cause 8086 CPU interrupt
<DT><A HREF="#int86x">int86x</A>
<DD>cause 8086 CPU interrupt, with segment registers
<DT><A HREF="#intr">intr</A>
<DD>cause 8086 CPU interrupt, with segment registers
<DT><A HREF="#intrf">intrf</A>
<DD>cause 8086 CPU interrupt, with segment registers and CPU flags
<DT><A HREF="#MK_FP">MK_FP</A>
<DD>make a far pointer from the segment and offset values
<DT><A HREF="#nosound">nosound</A>
<DD>turn off the speaker
<DT><A HREF="#outp">outp</A>
<DD>write one byte to hardware port
<DT><A HREF="#outpw">outpw</A>
<DD>write two bytes (one word) to hardware port
<DT><A HREF="#segread">segread</A>
<DD>read segment registers
<DT><A HREF="#sound">sound</A>
<DD>turn on the speaker at specified frequency
</DL>
<H3 ID="Intel_Pentium_Multimedia_Extension_Functions"> Intel Pentium Multimedia Extension Functions </H3>
<BR>This set of functions allows access to Intel Architecture Multimedia Extensions (MMX).&nbsp; These functions are implemented
as in-line intrinsic functions.&nbsp; The general format for most functions is:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; mm_result = mm_function( mm_operand1, mm_operand2 );</TT>
<BR><BR>These functions provide a simple model for use of Intel Multimedia Extension (MMX).&nbsp; More advanced use of MMX
can be implemented in much the same way that these functions are implemented.&nbsp; See the<TT> &lt;mmintrin.h&gt;</TT> header
file for examples.&nbsp; The following functions are defined:
<DL>
<DT><A HREF="#_m_empty">_m_empty</A>
<DD>empty multimedia state
<DT><A HREF="#_m_from_int">_m_from_int</A>
<DD>form 64-bit MM value from unsigned 32-bit integer value
<DT><A HREF="#_m_packssdw">_m_packssdw</A>
<DD>pack and saturate 32-bit double-words from two MM elements into signed 16-bit words
<DT><A HREF="#_m_packsswb">_m_packsswb</A>
<DD>pack and saturate 16-bit words from two MM elements into signed bytes
<DT><A HREF="#_m_packuswb">_m_packuswb</A>
<DD>pack and saturate signed 16-bit words from two MM elements into unsigned bytes
<DT><A HREF="#_m_paddb">_m_paddb</A>
<DD>add packed bytes
<DT><A HREF="#_m_paddd">_m_paddd</A>
<DD>add packed 32-bit double-words
<DT><A HREF="#_m_paddsb">_m_paddsb</A>
<DD>add packed signed bytes with saturation
<DT><A HREF="#_m_paddsw">_m_paddsw</A>
<DD>add packed signed 16-bit words with saturation
<DT><A HREF="#_m_paddusb">_m_paddusb</A>
<DD>add packed unsigned bytes with saturation
<DT><A HREF="#_m_paddusw">_m_paddusw</A>
<DD>add packed unsigned 16-bit words with saturation
<DT><A HREF="#_m_paddw">_m_paddw</A>
<DD>add packed 16-bit words
<DT><A HREF="#_m_pand">_m_pand</A>
<DD>AND 64 bits of two MM elements
<DT><A HREF="#_m_pandn">_m_pandn</A>
<DD>invert the 64 bits in MM element, then AND 64 bits from second MM element
<DT><A HREF="#_m_pcmpeqb">_m_pcmpeqb</A>
<DD>compare packed bytes for equality
<DT><A HREF="#_m_pcmpeqd">_m_pcmpeqd</A>
<DD>compare packed 32-bit double-words for equality
<DT><A HREF="#_m_pcmpeqw">_m_pcmpeqw</A>
<DD>compare packed 16-bit words for equality
<DT><A HREF="#_m_pcmpgtb">_m_pcmpgtb</A>
<DD>compare packed bytes for greater than relationship
<DT><A HREF="#_m_pcmpgtd">_m_pcmpgtd</A>
<DD>compare packed 32-bit double-words for greater than relationship
<DT><A HREF="#_m_pcmpgtw">_m_pcmpgtw</A>
<DD>compare packed 16-bit words for greater than relationship
<DT><A HREF="#_m_pmaddwd">_m_pmaddwd</A>
<DD>multiply packed 16-bit words, then add 32-bit results pair-wise
<DT><A HREF="#_m_pmulhw">_m_pmulhw</A>
<DD>multiply the packed 16-bit words of two MM elements, then store high-order 16 bits of results
<DT><A HREF="#_m_pmullw">_m_pmullw</A>
<DD>multiply the packed 16-bit words of two MM elements, then store low-order 16 bits of results
<DT><A HREF="#_m_por">_m_por</A>
<DD>OR 64 bits of two MM elements
<DT><A HREF="#_m_pslld">_m_pslld</A>
<DD>shift left each 32-bit double-word by amount specified in second MM element
<DT><A HREF="#_m_pslldi">_m_pslldi</A>
<DD>shift left each 32-bit double-word by amount specified in constant value
<DT><A HREF="#_m_psllq">_m_psllq</A>
<DD>shift left each 64-bit quad-word by amount specified in second MM element
<DT><A HREF="#_m_psllqi">_m_psllqi</A>
<DD>shift left each 64-bit quad-word by amount specified in constant value
<DT><A HREF="#_m_psllw">_m_psllw</A>
<DD>shift left each 16-bit word by amount specified in second MM element
<DT><A HREF="#_m_psllwi">_m_psllwi</A>
<DD>shift left each 16-bit word by amount specified in constant value
<DT><A HREF="#_m_psrad">_m_psrad</A>
<DD>shift right (with sign propagation) each 32-bit double-word by amount specified in second MM element
<DT><A HREF="#_m_psradi">_m_psradi</A>
<DD>shift right (with sign propagation) each 32-bit double-word by amount specified in constant value
<DT><A HREF="#_m_psraw">_m_psraw</A>
<DD>shift right (with sign propagation) each 16-bit word by amount specified in second MM element
<DT><A HREF="#_m_psrawi">_m_psrawi</A>
<DD>shift right (with sign propagation) each 16-bit word by amount specified in constant value
<DT><A HREF="#_m_psrld">_m_psrld</A>
<DD>shift right (with zero fill) each 32-bit double-word by an amount specified in second MM element
<DT><A HREF="#_m_psrldi">_m_psrldi</A>
<DD>shift right (with zero fill) each 32-bit double-word by an amount specified in constant value
<DT><A HREF="#_m_psrlq">_m_psrlq</A>
<DD>shift right (with zero fill) each 64-bit quad-word by an amount specified in second MM element
<DT><A HREF="#_m_psrlqi">_m_psrlqi</A>
<DD>shift right (with zero fill) each 64-bit quad-word by an amount specified in constant value
<DT><A HREF="#_m_psrlw">_m_psrlw</A>
<DD>shift right (with zero fill) each 16-bit word by an amount specified in second MM element
<DT><A HREF="#_m_psrlwi">_m_psrlwi</A>
<DD>shift right (with zero fill) each 16-bit word by an amount specified in constant value
<DT><A HREF="#_m_psubb">_m_psubb</A>
<DD>subtract packed bytes in MM element from second MM element
<DT><A HREF="#_m_psubd">_m_psubd</A>
<DD>subtract packed 32-bit dwords in MM element from second MM element
<DT><A HREF="#_m_psubsb">_m_psubsb</A>
<DD>subtract packed signed bytes in MM element from second MM element with saturation
<DT><A HREF="#_m_psubsw">_m_psubsw</A>
<DD>subtract packed signed 16-bit words in MM element from second MM element with saturation
<DT><A HREF="#_m_psubusb">_m_psubusb</A>
<DD>subtract packed unsigned bytes in MM element from second MM element with saturation
<DT><A HREF="#_m_psubusw">_m_psubusw</A>
<DD>subtract packed unsigned 16-bit words in MM element from second MM element with saturation
<DT><A HREF="#_m_psubw">_m_psubw</A>
<DD>subtract packed 16-bit words in MM element from second MM element
<DT><A HREF="#_m_punpckhbw">_m_punpckhbw</A>
<DD>interleave bytes from the high halves of two MM elements
<DT><A HREF="#_m_punpckhdq">_m_punpckhdq</A>
<DD>interleave 32-bit double-words from the high halves of two MM elements
<DT><A HREF="#_m_punpckhwd">_m_punpckhwd</A>
<DD>interleave 16-bit words from the high halves of two MM elements
<DT><A HREF="#_m_punpcklbw">_m_punpcklbw</A>
<DD>interleave bytes from the low halves of two MM elements
<DT><A HREF="#_m_punpckldq">_m_punpckldq</A>
<DD>interleave 32-bit double-words from the low halves of two MM elements
<DT><A HREF="#_m_punpcklwd">_m_punpcklwd</A>
<DD>interleave 16-bit words from the low halves of two MM elements
<DT><A HREF="#_m_pxor">_m_pxor</A>
<DD>XOR 64 bits from two MM elements
<DT><A HREF="#_m_to_int">_m_to_int</A>
<DD>retrieve low-order 32 bits from MM value
</DL>
<H3 ID="Miscellaneous_Functions"> Miscellaneous Functions </H3>
<BR>The following functions are defined:
<DL>
<DT><A HREF="#assert">assert</A>
<DD>test an assertion and output a string upon failure
<DT><A HREF="#_fullpath">_fullpath</A>
<DD>return full path specification for file
<DT><A HREF="#_getmbcp">_getmbcp</A>
<DD>get current multibyte code page
<DT><A HREF="#getopt">getopt</A>
<DD>a command-line parser that can be used by applications that follow guidelines outlined in the Single UNIX Specification
<DT><A HREF="#_harderr">_harderr</A>
<DD>critical error handler
<DT>_hardresume (see <A HREF="#_harderr">_harderr</A>)
<DD>critical error handler resume
<DT><A HREF="#localeconv">localeconv</A>
<DD>obtain locale specific conversion information
<DT><A HREF="#longjmp">longjmp</A>
<DD>return and restore environment saved by &quot;setjmp&quot;
<DT><A HREF="#_lrotl">_lrotl</A>
<DD>rotate an &quot;unsigned long&quot; left
<DT><A HREF="#_lrotr">_lrotr</A>
<DD>rotate an &quot;unsigned long&quot; right
<DT><A HREF="#main">main</A>
<DD>the main program (user written)
<DT><A HREF="#offsetof">offsetof</A>
<DD>get offset of field in structure
<DT><A HREF="#_rotl">_rotl</A>
<DD>rotate an &quot;unsigned int&quot; left
<DT><A HREF="#_rotr">_rotr</A>
<DD>rotate an &quot;unsigned int&quot; right
<DT><A HREF="#setjmp">setjmp</A>
<DD>save environment for use with &quot;longjmp&quot; function
<DT><A HREF="#_makepath">_makepath</A>
<DD>make a full filename from specified components
<DT><A HREF="#setlocale">setlocale</A>
<DD>set locale category
<DT><A HREF="#_setmbcp">_setmbcp</A>
<DD>set current multibyte code page
<DT><A HREF="#_splitpath">_splitpath</A>
<DD>split a filename into its components
<DT><A HREF="#_splitpath2">_splitpath2</A>
<DD>split a filename into its components
<DT>_wfullpath (see <A HREF="#_fullpath">_fullpath</A>)
<DD>return full path specification for file
<DT>_wmakepath (see <A HREF="#_makepath">_makepath</A>)
<DD>make a full filename from specified components
<DT>_wsetlocale (see <A HREF="#setlocale">setlocale</A>)
<DD>set locale category
<DT>_wsplitpath (see <A HREF="#_splitpath">_splitpath</A>)
<DD>split a filename into its components
<DT>_wsplitpath2 (see <A HREF="#_splitpath2">_splitpath2</A>)
<DD>split a filename into its components
</DL>
<H3 ID="DOS_LFN_aware_Functions"> DOS LFN aware Functions </H3>
<BR>These functions deal with DOS Long File Name if an application is compiled with -D__WATCOM_LFN__ option and DOS LFN support
is available on host system.&nbsp; The following functions are defined:
<DL>
<DT><A HREF="#access">access</A>
<DD>test file or directory for mode of access
<DT><A HREF="#chdir">chdir</A>
<DD>change current working directory
<DT><A HREF="#chmod">chmod</A>
<DD>change permissions for a file
<DT><A HREF="#creat">creat</A>
<DD>create a file
<DT><A HREF="#_dos_creat">_dos_creat</A>
<DD>create a file
<DT><A HREF="#_dos_creatnew">_dos_creatnew</A>
<DD>create a new file
<DT>_dos_findfirst (see <A HREF="#_dos_find___">_dos_find...</A>)
<DD>find first file matching a specified pattern
<DT><A HREF="#_dos_getfileattr">_dos_getfileattr</A>
<DD>get file attributes
<DT><A HREF="#_dos_open">_dos_open</A>
<DD>open a file
<DT><A HREF="#_dos_setfileattr">_dos_setfileattr</A>
<DD>set the attributes of a file
<DT><A HREF="#_findfirst">_findfirst</A>
<DD>find first file matching a specified pattern
<DT><A HREF="#_fullpath">_fullpath</A>
<DD>return full path specification for file
<DT><A HREF="#getcwd">getcwd</A>
<DD>get current working directory
<DT><A HREF="#_getdcwd">_getdcwd</A>
<DD>get current directory on drive
<DT>lstat (see <A HREF="#stat">stat</A>)
<DD>get file status
<DT><A HREF="#mkdir">mkdir</A>
<DD>make a new directory
<DT><A HREF="#open">open</A>
<DD>open a file
<DT><A HREF="#opendir">opendir</A>
<DD>open directory file
<DT><A HREF="#remove">remove</A>
<DD>delete a file
<DT><A HREF="#rename">rename</A>
<DD>rename a file
<DT><A HREF="#rmdir">rmdir</A>
<DD>remove a directory
<DT><A HREF="#sopen">sopen</A>
<DD>open a file for shared access
<DT><A HREF="#stat">stat</A>
<DD>get file status
<DT><A HREF="#tmpnam">tmpnam</A>
<DD>create name for temporary file
<DT><A HREF="#unlink">unlink</A>
<DD>delete a file
<DT><A HREF="#utime">utime</A>
<DD>set modification time for a file
<DT>_waccess (see <A HREF="#access">access</A>)
<DD>test file or directory for mode of access
<DT>_wchdir (see <A HREF="#chdir">chdir</A>)
<DD>change current working directory
<DT>_wchmod (see <A HREF="#chmod">chmod</A>)
<DD>change permissions for a file
<DT>_wcreat (see <A HREF="#creat">creat</A>)
<DD>create a file
<DT>_wdos_findfirst (see <A HREF="#_dos_find___">_dos_find...</A>)
<DD>find first file matching a specified pattern
<DT>_wfindfirst (see <A HREF="#_findfirst">_findfirst</A>)
<DD>find first file matching a specified pattern
<DT>_wfullpath (see <A HREF="#_fullpath">_fullpath</A>)
<DD>return full path specification for file
<DT>_wgetcwd (see <A HREF="#getcwd">getcwd</A>)
<DD>get current working directory
<DT>_wgetdcwd (see <A HREF="#_getdcwd">_getdcwd</A>)
<DD>get current directory on drive
<DT>_wmkdir (see <A HREF="#mkdir">mkdir</A>)
<DD>make a new directory
<DT>_wopen (see <A HREF="#open">open</A>)
<DD>open a file
<DT>_wopendir (see <A HREF="#opendir">opendir</A>)
<DD>open directory file
<DT>_wremove (see <A HREF="#remove">remove</A>)
<DD>delete a file
<DT>_wrename (see <A HREF="#rename">rename</A>)
<DD>rename a file
<DT>_wrmdir (see <A HREF="#rmdir">rmdir</A>)
<DD>remove a directory
<DT>_wsopen (see <A HREF="#sopen">sopen</A>)
<DD>open a file for shared access
<DT>_wstat (see <A HREF="#stat">stat</A>)
<DD>get file status
<DT>_wtmpnam (see <A HREF="#tmpnam">tmpnam</A>)
<DD>create name for temporary file
<DT>_wunlink (see <A HREF="#unlink">unlink</A>)
<DD>delete a file
<DT>_wutime (see <A HREF="#utime">utime</A>)
<DD>set modification time for a file
</DL>
<H2 ID="Header_Files"> Header Files </H2>
<BR>The following header files are supplied with the C library.&nbsp; As has been previously noted, when a library function
is referenced in a source file, the related header files (shown in the synopsis for that function) should be included into
that source file.&nbsp; The header files provide the proper declarations for the functions and for the number and types of
arguments used with them.&nbsp; Constant values used in conjunction with the functions are also declared.&nbsp; The files
can be included multiple times and in any order.
<H3 ID="Header_Files_in_DwatcomDh"> Header Files in /watcom/h </H3>
<BR>The following header files are provided with the software.&nbsp; The header files that are located in the<TT> \WATCOM\H</TT>
directory are described first.&nbsp; 
<DL>
<DT>assert.h
<DD>This ISO C90 header file is required when an <TT> assert</TT> macro is used.&nbsp; These assertions will be ignored when the
identifier<TT> NDEBUG</TT> is defined.&nbsp; 
<DT>bios.h
<DD>This header file declares all BIOS related functions.&nbsp; 
<DT>conio.h
<DD>This header file declares console and Intel 80x86 port input/output functions.&nbsp; 
<DT>ctype.h
<DD>This ISO C90 header file declares functions that perform character classification and case conversion operations.&nbsp; Similar
functions for wide characters are declared in &lt;wctype.h&gt;.&nbsp; 
<DT>direct.h
<DD>This header file declares functions related to directories and the type <TT> DIR</TT> which describes an entry in a directory.
&nbsp;
<DT>dos.h
<DD>This header file declares functions that interact with DOS.&nbsp; It includes the definitions of the <TT> FP_OFF</TT>, <TT>
FP_SEG</TT> and <TT> MK_FP</TT> macros, and for the following structures and unions:&nbsp; 
<DL>
<DT>DOSERROR
<DD>describes the DOS error information.&nbsp; 
<DT>REGS
<DD>describes the CPU registers for Intel 8086 family.&nbsp; 
<DT>SREGS
<DD>describes the segment registers for the Intel 8086 family.&nbsp; 
<DT>REGPACK
<DD>describes the CPU registers and segment registers for Intel 8086 family.&nbsp; 
<DT>INTPACK
<DD>describes the input parameter to an &quot;interrupt&quot; function.
</DL>
<DT>env.h
<DD>This POSIX header file declares environment string functions.&nbsp; 
<DT>errno.h
<DD>This ISO C90 header file provides the <TT> extern</TT> declaration for error variable <TT> errno</TT> and provides the symbolic
names for error codes that can be placed in the error variable.&nbsp; 
<DT>fcntl.h
<DD>This POSIX header file defines the flags used by the <TT> open</TT> and <TT> sopen</TT> functions.&nbsp; The function declarations
for these functions are found in the<TT> &lt;io.h&gt;</TT> header file.&nbsp; 
<DT>fenv.h
<DD>This ISO C99 header file defines several types and declares several functions that give access to the floating point environment.
&nbsp;These functions can be used to control status flags and control modes in the floating point processor.&nbsp; 
<DT>float.h
<DD>This ISO C90 header file declares constants related to floating-point numbers, declarations for low-level floating-point functions,
and the declaration of the floating-point exception codes.&nbsp; 
<DT>fnmatch.h
<DD>This header file declares the pattern matching function <TT> fnmatch</TT> 
<DT>graph.h
<DD>This header file contains structure definitions and function declarations for the Open Watcom C Graphics library functions.
&nbsp;
<DT>inttypes.h
<DD>This ISO C99 header file includes &lt;stdint.h&gt; and expands on it by definition macros for printing and scanning specific
sized integer types.&nbsp; This header also declares several functions for manipulating maximum sized integers.
<BR><BR>Note that the format macros are not visible in C++ programs unless the macro <TT> __STDC_FORMAT_MACROS</TT> is defined.
&nbsp;
<DT>io.h
<DD>This header file declares functions that perform input/output operations at the operating system level.&nbsp; These functions
use file handles to reference files or devices.&nbsp; The function <TT> fstat</TT> is declared in the<TT> &lt;sys/stat.h&gt;</TT>
header file.&nbsp; 
<DT>limits.h
<DD>This ISO C90 header file contains constant declarations for limits or boundary values for ranges of integers and characters.
&nbsp;
<DT>locale.h
<DD>This ISO C90 header file contains declarations for the categories<TT> (LC...)</TT> of locales which can be selected using
the <TT> setlocale</TT> function which is also declared.&nbsp; 
<DT>malloc.h
<DD>This header file declares the memory allocation and deallocation functions.&nbsp; 
<DT>math.h
<DD>This ISO/ANSI header file declares the mathematical functions (which operate with floating-point numbers) and the structures:
&nbsp;
<DL>
<DT>exception
<DD>describes the exception structure passed to the <TT> matherr</TT> function; symbolic constants for the types of exceptions
are included 
<DT>complex
<DD>declares a complex number
</DL>
<DT>mmintrin.h
<DD>This header file declares functions that interact with the Intel Architecture Multimedia Extensions.&nbsp; It defines the
datatype used to store multimedia values:&nbsp; 
<DL>
<DT>__m64
<DD>describes the 64-bit multimedia data element.&nbsp; Note:&nbsp; the underlying implementation details of this datatype are
subject to change.&nbsp; Other compilers may implement a similar datatype in a different manner.
</DL>
<BR>It also contains prototypes for multimedia functions and pragmas for the in-line generation of code that operates on multimedia
registers.&nbsp; 
<DT>process.h
<DD>This header file declares the <TT> spawn...</TT>&nbsp; functions, the <TT> exec...</TT>&nbsp; functions, and the <TT> system</TT>
function.&nbsp; The file also contains declarations for the constants <TT> P_WAIT</TT>, <TT> P_NOWAIT</TT>, <TT> P_NOWAITO</TT>,
and <TT> P_OVERLAY</TT>.&nbsp; 
<DT>search.h
<DD>This header file declares the functions <TT> lfind</TT> and <TT> lsearch</TT> 
<DT>setjmp.h
<DD>This ISO C90 header file declares the <TT> setjmp</TT> and <TT> longjmp</TT> functions.&nbsp; 
<DT>share.h
<DD>This header file defines constants for shared access to files using the <TT> sopen</TT> function.&nbsp; 
<DT>signal.h
<DD>This ISO C90 header file declares the <TT> signal</TT> and <TT> raise</TT> functions.&nbsp; 
<DT>stdarg.h
<DD>This ISO C90 header file defines the macros which handle variable argument lists.&nbsp; 
<DT>stdbool.h
<DD>This ISO C99 header file defines the macro <TT> bool</TT> and the macros <TT> true</TT> and <TT> false</TT> for use in C programs.
&nbsp;If this header is included in a C++ program there is no effect.&nbsp; The C++ reserved words will not be redefined.
&nbsp;However the definition of <TT> bool</TT> , <TT> true</TT> , and <TT> false</TT> used in a C program will be compatible
with their C++ counterparts.&nbsp; In particular, a C function declared as taking a <TT> bool</TT> parameter and a structure
containing a <TT> bool</TT> member can both be shared between C and C++ without error.&nbsp; 
<DT>stddef.h
<DD>This ISO C90 header file defines a few popular constants and types including<TT> NULL</TT> (null pointer), <TT> size_t</TT>
(unsigned size of an object), and <TT> ptrdiff_t</TT> (difference between two pointers).&nbsp; It also contains a declaration
for the <TT> offsetof</TT> macro.&nbsp; 
<DT>stdint.h
<DD>This ISO C99 header file defines numerous type names for integers of various sizes.&nbsp; Such type names provide a reasonably
portable way to refer to integers with a specific number of bits.&nbsp; This header file also defines macros that describe
the minimum and maximum values for these types (similar to the macros in limits.h), and macros for writing integer constants
with specific sized types.
<BR><BR>Note that in C++ programs the limit macros are not visible unless the macro <TT> __STDC_LIMIT_MACROS</TT> is defined.
&nbsp;Similarly the constant writing macros are not visible unless the macro <TT> __STDC_CONSTANT_MACROS</TT> is defined.
&nbsp;
<DT>stdio.h
<DD>This ISO C90 header file declares the standard input/output functions.&nbsp; Files, devices and directories are referenced
using pointers to objects of the type <TT> FILE</TT>.&nbsp; 
<DT>stdlib.h
<DD>This ISO C90 header file declares many standard functions excluding those declared in other header files discussed in this
section.&nbsp; 
<DT>string.h
<DD>This ISO C90 header file declares functions that manipulate strings or blocks of memory.&nbsp; 
<DT>time.h
<DD>This ISO/ANSI header file declares functions related to times and dates and defines the structure <TT> struct tm</TT>.&nbsp;

<DT>varargs.h
<DD>This UNIX System V header file provides an alternate way of handling variable argument lists.&nbsp; The equivalent ISO/ANSI
header file is &lt;stdarg.h&gt;.&nbsp; 
<DT>wchar.h
<DD>This ISO C99 header file defines several data types including <TT> wchar_t</TT>, <TT> size_t</TT>, <TT> mbstate_t</TT> (an
object that can hold conversion state information necessary to convert between multibyte characters and wide characters),
<TT> wctype_t</TT> (a scalar type that can hold values which represent locale-specific character classification), and <TT>
wint_t</TT> which is an integral type that can hold any <TT> wchar_t</TT> value as well as <TT> WEOF</TT> (a character that
is not in the set of &quot;wchar_t&quot; characters and that is used to indicate<B> end-of-file</B> on an input stream).&nbsp;
The functions that are declared in this header file are grouped as follows:
<UL>
<LI>Wide character classification and case conversion.
<LI>Input and output of wide characters, or multibyte characters, or both.
<LI>Wide string numeric conversion.
<LI>Wide string manipulation.
<LI>Wide string data and time conversion.
<LI>Conversion between multibyte and wide character sequences.
</UL>
<DT>wctype.h
<DD>This ISO C99 header file declares functions that perform characater classification and case conversion operations on wide
characters.&nbsp; Similar functions for ordinary characters are declared in &lt;ctype.h&gt;.
</DL>
<H3 ID="Header_Files_in_DwatcomDhDsys"> Header Files in /watcom/h/sys </H3>
<BR>The following header files are present in the <TT> sys</TT> subdirectory.&nbsp; Their presence in this directory indicates
that they are system-dependent header files.&nbsp; 
<DL>
<DT>sys/locking.h
<DD>This header file contains the manifest constants used by the <TT> locking</TT> function.&nbsp; 
<DT>sys/stat.h
<DD>This POSIX header file contains the declarations pertaining to file status, including definitions for the <TT> fstat</TT>
and <TT> stat</TT> functions and for the structure:&nbsp; 
<DL>
<DT>stat
<DD>describes the information obtained for a directory, file or device
</DL>
<DT>sys/timeb.h
<DD>This header file describes the <TT> timeb</TT> structure used in conjunction with the <TT> ftime</TT> function.&nbsp; 
<DT>sys/types.h
<DD>This POSIX header file contains declarations for the types used by system-level calls to obtain file status or time information.
&nbsp;
<DT>sys/utime.h
<DD>This POSIX header file contains a declaration for the <TT> utime</TT> function and for the structured type <TT> utimbuf</TT>
used by it.
</DL>
<H2 ID="Global_Data"> Global Data </H2>
<BR>Certain data items are used by the Open Watcom C/C++ run-time library and may be inspected (or changed in some cases)
by a program.&nbsp; The defined items are:&nbsp; 
<DL>
<DT>_amblksiz
<DD>Prototype in<TT> &lt;stdlib.h&gt;.</TT>
<BR><BR>This<TT> unsigned int</TT> data item contains the increment by which the &quot;break&quot; pointer for memory allocation
will be advanced when there is no freed block large enough to satisfy a request to allocate a block of memory.&nbsp; This
value may be changed by a program at any time.&nbsp; 
<DT>__argc
<DD>Prototype in<TT> &lt;stdlib.h&gt;.</TT>
<BR><BR>This<TT> int</TT> item contains the number of arguments passed to <TT> main</TT>.&nbsp; 
<DT>__argv
<DD>Prototype in<TT> &lt;stdlib.h&gt;.</TT>
<BR><BR>This<TT> char **</TT> item contains a pointer to a vector containing the actual arguments passed to <TT> main</TT>.
&nbsp;
<DT>daylight
<DD>Prototype in<TT> &lt;time.h&gt;.</TT>
<BR><BR>This<TT> unsigned int</TT> has a value of one when daylight saving time is supported in this locale and zero otherwise.
&nbsp;Whenever a time function is called, the <TT> tzset</TT> function is called to set the value of the variable.&nbsp; The
value will be determined from the value of the<TT> TZ</TT> environment variable.&nbsp; 
<DT>_doserrno
<DD>Prototype in<TT> &lt;stdlib.h&gt;.</TT>
<BR><BR>This<TT> int</TT> item contains the actual error code returned when a DOS, Windows or OS/2 function fails.&nbsp; 
<DT>environ
<DD>Prototype in<TT> &lt;stdlib.h&gt;.</TT>
<BR><BR>This<TT> char ** __near</TT> data item is a pointer to an array of character pointers to the environment strings.
<DT>errno
<DD>Prototype in<TT> &lt;errno.h&gt;.</TT>
<BR><BR>This<TT> int</TT> item contains the number of the last error that was detected.&nbsp; The run-time library never resets
<TT> errno</TT> to 0.&nbsp; Symbolic names for these errors are found in the<TT> &lt;errno.h&gt;</TT> header file.&nbsp; See
the descriptions for the <TT> perror</TT> and <TT> strerror</TT> functions for information about the text which describes
these errors.&nbsp; 
<DT>fltused_
<DD>The C compiler places a reference to the <TT> fltused_</TT> symbol into any module that uses a floating-point library routine
or library routine that requires floating-point support (e.g., the use of a<TT> float</TT> or<TT> double</TT> as an argument
to the <TT> printf</TT> function).&nbsp; 
<DT>_fmode
<DD>Prototype in<TT> &lt;stdlib.h&gt;.</TT>
<BR><BR>This data item contains the default type of file (text or binary) translation for a file.&nbsp; It will contain a
value of either
<DL>
<DT>O_BINARY
<DD>indicates that data is transmitted to and from streams unchanged.
<DT>O_TEXT
<DD>indicates that carriage return characters are added before linefeed characters on output operations and are removed on input
operations when they precede linefeed characters.
</DL>
<BR>These values are defined in the<TT> &lt;fcntl.h&gt;</TT> header file.&nbsp; The value of <TT> _fmode</TT> may be changed
by a program to change the default behavior of the <TT> open</TT>, <TT> fopen</TT>, <TT> creat</TT> and <TT> sopen</TT> functions.
&nbsp;The default setting of <TT> _fmode</TT> is <TT> O_TEXT</TT>, for text-mode translation.&nbsp; <TT> O_BINARY</TT> is
the setting for binary mode.&nbsp; You can change the value of <TT> _fmode</TT> in either of two ways:&nbsp; 
<UL>
<LI>You can include the object file<TT> BINMODE.OBJ</TT> when linking your application.&nbsp; This object file contains code
to change the initial setting of <TT> _fmode</TT> to <TT> O_BINARY</TT>, causing all files except <TT> stdin</TT>, <TT> stdout</TT>,
and <TT> stderr</TT> to be opened in binary mode.
<LI>You can change the value of <TT> _fmode</TT> directly by setting it in your program.
</UL>
<DT>__MaxThreads
<DD>There is a limit to the number of threads an application can create under 16-bit OS/2 and 32-bit NetWare.&nbsp; The default
limit is 32.&nbsp; This limit can be adjusted by statically initializing the unsigned global variable<TT> __MaxThreads.</TT>
<BR><BR>Under 32-bit OS/2, there is no limit to the number of threads an application can create.&nbsp; However, due to the
way in which multiple threads are supported in the Open Watcom libraries, there is a small performance penalty once the number
of threads exceeds the default limit of 32 (this number includes the initial thread).&nbsp; If you are creating more than
32 threads and wish to avoid this performance penalty, you can redefine the threshold value of 32.&nbsp; You can statically
initialize the global variable<TT> __MaxThreads.</TT>
<BR><BR>By adding the following line to your multi-threaded application, the new threshold value will be set to 48.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned __MaxThreads = { 48 };</TT>
<DT>__minreal
<DD>Prototype in<TT> &lt;stdlib.h&gt;.</TT>
<BR><BR>This data item contains the minimum amount of real memory (below 640K) to reserve when running a 32-bit DOS extended
application.&nbsp; 
<DT>optarg
<DD>Prototype in<TT> &lt;unistd.h&gt;.</TT>
<BR><BR>This<TT> char *</TT> variable contains a pointer to an option-argument parsed by the <TT> getopt</TT> function.&nbsp;

<DT>opterr
<DD>Prototype in<TT> &lt;unistd.h&gt;.</TT>
<BR><BR>This<TT> int</TT> variable controls whether the <TT> getopt</TT> function will print error messages.&nbsp; The default
value is non-zero and will cause the <TT> getopt</TT> function to print error messages on the console.&nbsp; 
<DT>optind
<DD>Prototype in<TT> &lt;unistd.h&gt;.</TT>
<BR><BR>This<TT> int</TT> variable holds the index of the argument array element currently processed by the <TT> getopt</TT>
function.&nbsp; 
<DT>optopt
<DD>Prototype in<TT> &lt;unistd.h&gt;.</TT>
<BR><BR>This<TT> int</TT> variable contains the unrecognized option character in case the <TT> getopt</TT> function returns
an error.&nbsp; 
<DT>_osmajor
<DD>Prototype in<TT> &lt;stdlib.h&gt;.</TT>
<BR><BR>This<TT> unsigned char</TT> variable contains the major number for the version of Operating System executing on the
computer.&nbsp; By example, if current running DOS version is 3.20, then the value will be 3.&nbsp; 
<DT>_osminor
<DD>Prototype in<TT> &lt;stdlib.h&gt;.</TT>
<BR><BR>This<TT> unsigned char</TT> variable contains the minor number for the version of Operating System executing on the
computer.&nbsp; By example, if current running DOS version is 3.20, then the value will be 20.&nbsp; 
<DT>_osbuild
<DD>(Win32 only) Prototype in<TT> &lt;stdlib.h&gt;.</TT>
<BR><BR>This<TT> unsigned short</TT> variable contains the operating system build number for the version of Windows executing
on the computer.&nbsp; 
<DT>_osver
<DD>(Win32 only) Prototype in<TT> &lt;stdlib.h&gt;.</TT>
<BR><BR>This<TT> unsigned int</TT> variable contains the operating system build number for the version of Windows executing
on the computer.
<BR>On Win32s or Windows 95/98 platforms, the high bit of the low-order 16-bit word is turned on.&nbsp; Windows 95/98 do not
have build numbers.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned short dwBuild;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; // Get build numbers for Win32 or Win32s</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; if( _osver &lt; 0x8000 )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Windows NT/2000</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwBuild = _osver;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; else if (_winmajor &lt; 4)&nbsp;&nbsp;&nbsp;&nbsp; // Win32s</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwBuild = _osver &amp; 0x8000;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Windows 95 or 98</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwBuild =&nbsp; 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; // No build numbers provided</TT>
<BR><BR>Note that the Win32 <TT> GetVersionEx</TT> function is the preferred method for obtaining operating system version
number information.&nbsp; 
<DT>_osmode
<DD>(16-bit only) Prototype in<TT> &lt;stdlib.h&gt;.</TT>
<BR><BR>This<TT> unsigned char</TT> variable contains either the value DOS_MODE which indicates the program is running in
real address mode, or it contains the value OS2_MODE which indicates the program is running in protected address mode.&nbsp;

<DT>_psp
<DD>Prototype in<TT> &lt;stdlib.h&gt;.</TT>
<BR><BR>This data item contains the segment value for the DOS Program Segment Prefix.&nbsp; Consult the technical documentation
for your DOS system for the process information contained in the Program Segment Prefix.&nbsp; 
<DT>_stacksize
<DD>On 16-bit 80x86 systems, this<TT> unsigned int</TT> value contains the size of the stack for a TINY memory model program.
&nbsp;Changing the value of this item during the execution of a program will have no effect upon the program, since the value
is used when the program starts execution.&nbsp; To change the size of the stack to be 8K bytes, a statement such as follows
can be included with the program.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned int _stacksize = { 8 * 1024 };</TT>
<DT>stdaux
<DD>Prototype in<TT> &lt;stdio.h&gt;.</TT>
<BR><BR>This variable (with type<TT> FILE *)</TT> indicates the standard auxiliary port (not available in some Windows platforms).
&nbsp;
<DT>stderr
<DD>Prototype in<TT> &lt;stdio.h&gt;.</TT>
<BR><BR>This variable (with type<TT> FILE *)</TT> indicates the standard error stream (set to the console by default).&nbsp;

<DT>stdin
<DD>Prototype in<TT> &lt;stdio.h&gt;.</TT>
<BR><BR>This variable (with type<TT> FILE *)</TT> indicates the standard input stream (set to the console by default).&nbsp;

<DT>stdout
<DD>Prototype in<TT> &lt;stdio.h&gt;.</TT>
<BR><BR>This variable (with type<TT> FILE *)</TT> indicates the standard output stream (set to the console by default).&nbsp;

<DT>stdprn
<DD>Prototype in<TT> &lt;stdio.h&gt;.</TT>
<BR><BR>This variable (with type<TT> FILE *)</TT> indicates the standard printer.&nbsp; (not available in some Windows platforms).
&nbsp;
<DT>sys_errlist
<DD>Prototype in<TT> &lt;stdlib.h&gt;.</TT>
<BR><BR>This variable is an array of pointers to character strings for each error code defined in the<TT> &lt;errno.h&gt;</TT>
header file.&nbsp; 
<DT>sys_nerr
<DD>Prototype in<TT> &lt;stdlib.h&gt;.</TT>
<BR><BR>This<TT> int</TT> variable contains the number of messages declared in <TT> sys_errlist</TT>.&nbsp; 
<DT>_threadid
<DD>Prototype in<TT> &lt;stddef.h&gt;.</TT>
<BR><BR>This variable/function may be used to obtain the id of the current thread which is an<TT> int.</TT>&nbsp; In the 32-bit
libraries, <TT> _threadid</TT> is a function that returns a pointer to an int.&nbsp; In the 16-bit libraries, <TT> _threadid</TT>
is a far pointer to an int.&nbsp; Note that the value stored where <TT> _threadid</TT> points does not necessarily change
when a thread context switch occurs (so do not make a copy of the pointer ...&nbsp; it may change).&nbsp; To obtain the current
thread identifier, simply code:
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int tid = *_threadid;</TT>
<DT>timezone
<DD>Prototype in<TT> &lt;time.h&gt;.</TT>
<BR><BR>This<TT> long int</TT> contains the number of seconds of time that the local time zone is earlier than Coordinated
Universal Time (UTC) (formerly known as Greenwich Mean Time (GMT)).&nbsp; Whenever a time function is called, the <TT> tzset</TT>
function is called to set the value of the variable.&nbsp; The value will be determined from the value of the<TT> TZ</TT>
environment variable.&nbsp; 
<DT>tzname
<DD>Prototype in<TT> &lt;time.h&gt;.</TT>
<BR><BR>This array of two pointers to character strings indicates the name of the standard abbreviation for the time zone
and the name of the abbreviation for the time zone when daylight saving time is in effect.&nbsp; Whenever a time function
is called, the <TT> tzset</TT> function is called to set the values in the array.&nbsp; These values will be determined from
the value of the<TT> TZ</TT> environment variable.&nbsp; 
<DT>__wargc
<DD>Prototype in<TT> &lt;stdlib.h&gt;.</TT>
<BR><BR>This<TT> int</TT> item contains the number of arguments passed to <TT> wmain</TT>.&nbsp; 
<DT>__wargv
<DD>Prototype in<TT> &lt;stdlib.h&gt;.</TT>
<BR><BR>This<TT> wchar_t **</TT> item contains a pointer to a vector containing the actual arguments passed to <TT> wmain</TT>.
&nbsp;
<DT>_wenviron
<DD>Prototype in<TT> &lt;stdlib.h&gt;.</TT>
<BR><BR>This<TT> wchar_t ** __near</TT> data item is a pointer to an array of wide-character pointers to the wide-character
equivalents of the environment strings.&nbsp; 
<DT>__win_alloc_flags
<DD>Prototype in<TT> &lt;stdlib.h&gt;.</TT>
<BR><BR>This<TT> unsigned long int</TT> variable contains the flags to be used when allocating memory in Windows.&nbsp; 
<DT>__win_realloc_flags
<DD>Prototype in<TT> &lt;stdlib.h&gt;.</TT>
<BR><BR>This<TT> unsigned long int</TT> variable contains the flags to be used when reallocating memory in Windows.&nbsp;

<DT>_winmajor
<DD>(Win32 only) Prototype in<TT> &lt;stdlib.h&gt;.</TT>
<BR><BR>This<TT> unsigned int</TT> variable contains the operating system major version number for the version of Windows
executing on the computer.&nbsp; For example, the major version number of the Daytona release of Windows NT is 3.
<BR>Note that the Win32 <TT> GetVersionEx</TT> function is the preferred method for obtaining operating system version number
information.&nbsp; 
<DT>_winminor
<DD>(Win32 only) Prototype in<TT> &lt;stdlib.h&gt;.</TT>
<BR><BR>This<TT> unsigned int</TT> variable contains the operating system minor version number for the version of Windows
executing on the computer.&nbsp; For example, the minor version number of the Daytona release of Windows NT is 5.
<BR>Note that the Win32 <TT> GetVersionEx</TT> function is the preferred method for obtaining operating system version number
information.&nbsp; 
<DT>_winver
<DD>(Win32 only) Prototype in<TT> &lt;stdlib.h&gt;.</TT>
<BR><BR>This<TT> unsigned int</TT> variable contains the operating system version number for the version of Windows executing
on the computer.&nbsp; The low-order byte contains the minor version number (see also <TT> _winminor</TT>).&nbsp; The next
byte contains the major version number (see also <TT> _winmajor</TT>).&nbsp; The high-order word contains no useful information.
<BR>Note that the Win32 <TT> GetVersionEx</TT> function is the preferred method for obtaining operating system version number
information.
</DL>
<H2 ID="The_TZ_Environment_Variable"> The TZ Environment Variable </H2>
<BR>The <TT> TZ</TT> environment variable is used to establish the local time zone.&nbsp; The value of the variable is used
by various time functions to compute times relative to Coordinated Universal Time (UTC) (formerly known as Greenwich Mean
Time (GMT)).
<BR><BR>The time on the computer should be set to the local time.&nbsp; Use the DOS<TT> time</TT> command and the DOS<TT>
date</TT> command if the time is not automatically maintained by the computer hardware.
<BR><BR>The <TT> TZ</TT> environment variable can be set (before the program is executed) by using the DOS<TT> set</TT> command
as follows:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SET TZ=PST8PDT</TT>
<BR><BR>or (during the program execution) by using the <TT> setenv</TT> or <TT> putenv</TT> library functions:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setenv( &quot;TZ&quot;, &quot;PST8PDT&quot;, 1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; putenv( &quot;TZ=PST8PDT&quot; );</TT>
<BR><BR>The value of the variable can be obtained by using the <TT> getenv</TT> function:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *tzvalue;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; . . .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tzvalue = getenv( &quot;TZ&quot; );</TT>
<BR><BR>The <TT> tzset</TT> function processes the <TT> TZ</TT> environment variable and sets the global variables <TT> daylight</TT>
(indicates if daylight saving time is supported in the locale), <TT> timezone</TT> (contains the number of seconds of time
difference between the local time zone and Coordinated Universal Time (UTC)), and <TT> tzname</TT> (a vector of two pointers
to character strings containing the standard and daylight time-zone names).
<BR><BR>The value of the <TT> TZ</TT> environment variable should be set as follows (spaces are for clarity only):
<DL>
<DT>std offset dst offset , rule
<DD>
</DL>
<BR>On the OS/2 platform, an alternate format is also supported.&nbsp; Please refer to the following section for details.
<BR>The expanded format is as follows:
<DL>
<DT>stdoffset[dst[offset][,start[/time],end[/time]]]
<DD>
</DL>
<DL>
<DT>std, dst
<DD>three or more letters that are the designation for the standard<B> (std)</B> or summer<B> (dst)</B> time zone.&nbsp; Only<B>
std</B> is required.&nbsp; If<B> dst</B> is omitted, then summer time does not apply in this locale.&nbsp; Upper- and lowercase
letters are allowed.&nbsp; Any characters except for a leading colon (:), digits, comma (,), minus (-), plus (+), and ASCII
NUL (\0) are allowed.
<DT>offset
<DD>indicates the value one must add to the local time to arrive at Coordinated Universal Time (UTC).&nbsp; The<B> offset</B>
has the form:
<DL>
<DT>hh[:mm[:ss]]
<DD>
</DL>
<BR>The minutes<B> (mm)</B> and seconds<B> (ss)</B> are optional.&nbsp; The hour<B> (hh)</B> is required and may be a single
digit.&nbsp; The<B> offset</B> following<B> std</B> is required.&nbsp; If no<B> offset</B> follows<B> dst,</B> summer time
is assumed to be one hour ahead of standard time.&nbsp; One or more digits may be used; the value is always interpreted as
a decimal number.&nbsp; The hour may be between 0 and 24, and the minutes (and seconds) - if present - between 0 and 59.&nbsp;
If preceded by a &quot;-&quot;, the time zone will be east of the <B> Prime Meridian</B>; otherwise it will be west (which
may be indicated by an optional preceding &quot;+&quot;).
<DT>rule
<DD>indicates when to change to and back from summer time.&nbsp; The<B> rule</B> has the form:
<DL>
<DT>date/time,date/time
<DD>
</DL>
<BR>where the first<B> date</B> describes when the change from standard to summer time occurs and the second<B> date</B> describes
when the change back happens.&nbsp; Each<B> time</B> field describes when, in current local time, the change to the other
time is made.
<BR><BR>The format of<B> date</B> may be one of the following:
<DL>
<DT>Jn
<DD>The Julian day n (1 &lt;= n &lt;= 365).&nbsp; Leap days are not counted.&nbsp; That is, in all years - including leap years
- February 28 is day 59 and March 1 is day 60.&nbsp; It is impossible to explicitly refer to the occasional February 29.
<DT>n
<DD>The zero-based Julian day (0 &lt;= n &lt;= 365).&nbsp; Leap years are counted, and it is possible to refer to February 29.
<DT>Mm.n.d
<DD>The d'th day (0 &lt;= d &lt;= 6) of week n of month m of the year (1 &lt;= n &lt;= 5, 1 &lt;= m &lt;= 12, where week 5 means
&quot;the last d day in month m&quot; which may occur in the fourth or fifth week).&nbsp; Week 1 is the first week in which
the d'th day occurs.&nbsp; Day zero is Sunday.
</DL>
<BR>The<B> time</B> has the same format as<B> offset</B> except that no leading sign (&quot;+&quot; or &quot;-&quot;) is allowed.
&nbsp;The default, if<B> time</B> is omitted, is<TT> 02:00:00.</TT>
</DL>
<BR>Whenever <TT> ctime</TT>, <TT> _ctime</TT>, <TT> localtime</TT>, <TT> _localtime</TT> or <TT> mktime</TT> is called, the
time zone names contained in the external variable <TT> tzname</TT> will be set as if the <TT> tzset</TT> function had been
called.&nbsp; The same is true if the<TT> %Z</TT> directive of <TT> strftime</TT> is used.
<BR><BR>Some examples are:
<DL>
<DT>TZ=EST5EDT
<DD>Eastern Standard Time is 5 hours earlier than Coordinated Universal Time (UTC).&nbsp; Standard time and daylight saving time
both apply to this locale.&nbsp; By default, Eastern Daylight Time (EDT) is one hour ahead of standard time (i.e., EDT4).
&nbsp;Since it is not specified, daylight saving time starts on the first Sunday of April at 2:00 A.M.&nbsp; and ends on the
last Sunday of October at 2:00 A.M.&nbsp; This is the default when the <TT> TZ</TT> variable is not set.
<DT>TZ=EST5EDT4,M4.1.0/02:00:00,M10.5.0/02:00:00
<DD>This is the full specification for the default when the <TT> TZ</TT> variable is not set.&nbsp; Eastern Standard Time is 5
hours earlier than Coordinated Universal Time (UTC).&nbsp; Standard time and daylight saving time both apply to this locale.
&nbsp;Eastern Daylight Time (EDT) is one hour ahead of standard time.&nbsp; Daylight saving time starts on the first (1) Sunday
(0) of April (4) at 2:00 A.M.&nbsp; and ends on the last (5) Sunday (0) of October (10) at 2:00 A.M.
<DT>TZ=PST8PDT
<DD>Pacific Standard Time is 8 hours earlier than Coordinated Universal Time (UTC).&nbsp; Standard time and daylight saving time
both apply to this locale.&nbsp; By default, Pacific Daylight Time is one hour ahead of standard time (i.e., PDT7).&nbsp;
Since it is not specified, daylight saving time starts on the first Sunday of April at 2:00 A.M.&nbsp; and ends on the last
Sunday of October at 2:00 A.M.
<DT>TZ=NST3:30NDT1:30
<DD>Newfoundland Standard Time is 3 and 1/2 hours earlier than Coordinated Universal Time (UTC).&nbsp; Standard time and daylight
saving time both apply to this locale.&nbsp; Newfoundland Daylight Time is 1 and 1/2 hours earlier than Coordinated Universal
Time (UTC).
<DT>TZ=Central Europe Time-2:00
<DD>Central European Time is 2 hours later than Coordinated Universal Time (UTC).&nbsp; Daylight saving time does not apply in
this locale.
</DL>
<H2 ID="The_OSD2_TZ_Environment_Variable"> The OS/2 TZ Environment Variable </H2>
<BR>On the OS/2 platform, an alternate format of the <TT> TZ</TT> environment variable is supported, in addition to the standard
format described in the preceding section.&nbsp; The value of the OS/2 <TT> TZ</TT> environment variable should be set as
follows (spaces are for clarity only):
<DL>
<DT>std offset dst, rule
<DD>
</DL>
<BR>This format will be used if after scanning the standard format there are additional fields or the format has not been
identified as standard.
<BR>The standard format is identified if an offset follows dst; characters J, M, /, or :&nbsp; are found in rule; or some
fields are empty.
<BR><BR>The alternate expanded format is as follows (fields may not be empty):
<DL>
<DT>stdoffsetdst,sm,sw,sd,st,em,ew,ed,et,shift
<DD>
</DL>
<DL>
<DT>std, dst
<DD>three or more letters that are the designation for the standard<B> (std)</B> and summer<B> (dst)</B> time zone.&nbsp; Upper-
and lowercase letters are allowed.&nbsp; Any characters except for a leading colon (:), digits, comma (,), minus (-), plus
(+), and ASCII NUL (\0) are allowed.
<DT>offset
<DD>indicates the value one must add to the local time to arrive at Coordinated Universal Time (UTC).&nbsp; The<B> offset</B>
has the form:
<DL>
<DT>hh[:mm[:ss]]
<DD>
</DL>
<BR>The minutes<B> (mm)</B> and seconds<B> (ss)</B> are optional.&nbsp; The hour<B> (hh)</B> is required and may be a single
digit.&nbsp; The value is always interpreted as a decimal number.&nbsp; The hour may be between 0 and 24, and the minutes
(and seconds) - if present - between 0 and 59.&nbsp; If preceded by a &quot;-&quot;, the time zone will be east of the <B>
Prime Meridian</B>; otherwise it will be west (which may be indicated by an optional preceding &quot;+&quot;).
<DT>rule
<DD>indicates when to change to and back from summer time and the time shift for summer time.&nbsp; The<B> rule</B> has the form:
<DL>
<DT>sm,sw,sd,st,em,ew,ed,et,shift
<DD>
</DL>
<BR>where<B> sm,sw,sd,st</B> describe when the change from standard to summer time occurs and<B> em,ew,ed,et</B> describe
when the change back happens.
<BR><BR><B>sm</B> and<B> em</B> specify the starting and ending month (1 - 12) of the summer time.
<BR><BR><B>sw</B> and<B> ew</B> specify the starting and ending week of the summer time.&nbsp; You can specify the last week
of the month ( -1 ), or week 1 to 4.&nbsp; Week 0 has a special meaning for the day field (<B> sd</B> or<B> ed</B> ).
<BR><BR><B>sd/ed</B> Starting/ending day of dst,
<BR><BR>0 - 6 ( weekday Sun to Sat ) if<B> sw/ew</B> is not zero,
<BR><BR>1 - 31 ( day of the month ) if<B> sw/ew</B> is zero
<BR><BR><B>st/et</B> Starting/ending time (in seconds after midnight) of the summer time.
<BR><BR><B>shift</B> Amount of time change (in seconds).
</DL>
<BR>An example of the default setting is:
<DL>
<DT>TZ=EST5EDT,4,1,0,7200,10,-1,0,7200,3600
<DD>This is the full specification for the default when the <TT> TZ</TT> variable is not set.&nbsp; Eastern Standard Time is 5
hours earlier than Coordinated Universal Time (UTC).&nbsp; Standard time and daylight saving time both apply to this locale.
&nbsp;Eastern Daylight Time (EDT) is one hour ahead of standard time.&nbsp; Daylight saving time starts on the first (1) Sunday
(0) of April (4) at 2:00 A.M.&nbsp; and ends on the last (-1) Sunday (0) of October (10) at 2:00 A.M.
</DL>
<H1 ID="Graphics_Library"> Graphics Library </H1>
<BR>The Open Watcom C Graphics Library consists of a large number of functions that provide graphical image support under
DOS and QNX.&nbsp; This chapter provides an overview of this support.&nbsp; The following topics are discussed.
<UL>
<LI>Graphics Functions
<LI>Graphics Adapters
<LI>Classes of Graphics Functions
<OL>
<LI>Environment Functions
<LI>Coordinate System Functions
<LI>Attribute Functions
<LI>Drawing Functions
<LI>Text Functions
<LI>Graphics Text Functions
<LI>Image Manipulation Functions
<LI>Font Manipulation Functions
<LI>Presentation Graphics Functions
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp; Display Functions
<BR>&nbsp;&nbsp;&nbsp;&nbsp; Analyze Functions
<BR>&nbsp;&nbsp;&nbsp;&nbsp; Utility Functions
</OL>
<LI>Graphics Header Files
</UL>
<H2 ID="Graphics_Functions"> Graphics Functions </H2>
<BR>Graphics functions are used to display graphical images such as lines and circles upon the computer screen.&nbsp; Functions
are also provided for displaying text along with the graphics output.
<H2 ID="Graphics_Adapters"> Graphics Adapters </H2>
<BR>Support is provided for both color and monochrome screens which are connected to the computer using any of the following
graphics adapters:
<UL>
<LI>IBM Monochrome Display/Printer Adapter (MDPA)
<LI>IBM Color Graphics Adapter (CGA)
<LI>IBM Enhanced Graphics Adapter (EGA)
<LI>IBM Multi-Color Graphics Array (MCGA)
<LI>IBM Video Graphics Array (VGA)
<LI>Hercules Monochrome Adapter
<LI>SuperVGA adapters (SVGA) supplied by various manufacturers
</UL>
<H2 ID="Classes_of_Graphics_Functions"> Classes of Graphics Functions </H2>
<BR>The functions in the Open Watcom C Graphics Library can be organized into a number of classes:
<DL>
<DT>Environment Functions
<DD>
<BR><BR>These functions deal with the hardware environment.
<DT>Coordinate System Functions
<DD>
<BR><BR>These functions deal with coordinate systems and mapping coordinates from one system to another.
<DT>Attribute Functions
<DD>
<BR><BR>These functions control the display of graphical images.
<DT>Drawing Functions
<DD>
<BR><BR>These functions display graphical images such as lines and ellipses.
<DT>Text Functions
<DD>
<BR><BR>These functions deal with displaying text in both graphics and text modes.
<DT>Graphics Text Functions
<DD>
<BR><BR>These functions deal with displaying graphics text.
<DT>Image Manipulation Functions
<DD>
<BR><BR>These functions store and retrieve screen images.
<DT>Font Manipulation Functions
<DD>
<BR><BR>These functions deal with displaying font based text.
<DT>Presentation Graphics Functions
<DD>
<BR><BR>These functions deal with displaying presentation graphics elements such as bar charts and pie charts.
</DL>
<BR>The following subsections describe these function classes in more detail.&nbsp; Each function in the class is noted with
a brief description of its purpose.
<H3 ID="Environment_Functions"> Environment Functions </H3>
<BR>These functions deal with the hardware environment.&nbsp; The <TT> _getvideoconfig</TT> function returns information about
the current video mode and the hardware configuration.&nbsp; The <TT> _setvideomode</TT> function selects a new video mode.
<BR><BR>Some video modes support multiple pages of screen memory.&nbsp; The visual page (the one displayed on the screen)
may be different than the active page (the one to which objects are being written).
<BR><BR>The following functions are defined:
<DL>
<DT><A HREF="#_getactivepage">_getactivepage</A>
<DD>get the number of the current active graphics page
<DT><A HREF="#_getvideoconfig">_getvideoconfig</A>
<DD>get information about the graphics configuration
<DT><A HREF="#_getvisualpage">_getvisualpage</A>
<DD>get the number of the current visual graphics page
<DT><A HREF="#_grstatus">_grstatus</A>
<DD>get the status of the most recently called graphics library function
<DT><A HREF="#_setactivepage">_setactivepage</A>
<DD>set the active graphics page (the page to which graphics objects are drawn)
<DT><A HREF="#_settextrows">_settextrows</A>
<DD>set the number of rows of text displayed on the screen
<DT><A HREF="#_setvideomode">_setvideomode</A>
<DD>select the video mode to be used
<DT><A HREF="#_setvideomoderows">_setvideomoderows</A>
<DD>select the video mode and the number of text rows to be used
<DT><A HREF="#_setvisualpage">_setvisualpage</A>
<DD>set the visual graphics page (the page displayed on the screen)
</DL>
<H3 ID="Coordinate_System_Functions"> Coordinate System Functions </H3>
<BR>These functions deal with coordinate systems and mapping coordinates from one system to another.&nbsp; The Open Watcom
C Graphics Library supports three coordinate systems:&nbsp; 
<OL>
<LI>Physical coordinates
<LI>View coordinates
<LI>Window coordinates
</OL>
<BR>Physical coordinates match the physical dimensions of the screen.&nbsp; The physical origin, denoted (0,0), is located
at the top left corner of the screen.&nbsp; A pixel to the right of the origin has a positive x-coordinate and a pixel below
the origin will have a positive y-coordinate.&nbsp; The x- and y-coordinates will never be negative values.
<BR><BR>The view coordinate system can be defined upon the physical coordinate system by moving the origin from the top left
corner of the screen to any physical coordinate (see the <TT> _setvieworg</TT> function).&nbsp; In the view coordinate system,
negative x- and y-coordinates are allowed.&nbsp; The scale of the view and physical coordinate systems is identical (both
are in terms of pixels).
<BR><BR>The window coordinate system is defined in terms of a range of user-specified values (see the <TT> _setwindow</TT>
function).&nbsp; These values are scaled to map onto the physical coordinates of the screen.&nbsp; This allows for consistent
pictures regardless of the resolution (number of pixels) of the screen.
<BR><BR>The following functions are defined:
<DL>
<DT><A HREF="#_getcliprgn">_getcliprgn</A>
<DD>get the boundary of the current clipping region
<DT><A HREF="#_getphyscoord">_getphyscoord</A>
<DD>get the physical coordinates of a point in view coordinates
<DT><A HREF="#_getviewcoord">_getviewcoord</A>
<DD>get the view coordinates of a point in physical coordinates
<DT>_getviewcoord_w (see <A HREF="#_getviewcoord">_getviewcoord</A>)
<DD>get the view coordinates of a point in window coordinates
<DT>_getviewcoord_wxy (see <A HREF="#_getviewcoord">_getviewcoord</A>)
<DD>get the view coordinates of a point in window coordinates
<DT><A HREF="#_getwindowcoord">_getwindowcoord</A>
<DD>get the window coordinates of a point in view coordinates
<DT><A HREF="#_setcliprgn">_setcliprgn</A>
<DD>set the boundary of the clipping region
<DT><A HREF="#_setvieworg">_setvieworg</A>
<DD>set the position to be used as the origin of the view coordinate system
<DT><A HREF="#_setviewport">_setviewport</A>
<DD>set the boundary of the clipping region and the origin of the view coordinate system
<DT><A HREF="#_setwindow">_setwindow</A>
<DD>define the boundary of the window coordinate system
</DL>
<H3 ID="Attribute_Functions"> Attribute Functions </H3>
<BR>These functions control the display of graphical images such as lines and circles.&nbsp; Lines and figures are drawn using
the current color (see the <TT> _setcolor</TT> function), the current line style (see the <TT> _setlinestyle</TT> function),
the current fill mask (see the <TT> _setfillmask</TT> function), and the current plotting action (see the <TT> _setplotaction</TT>
function).
<BR><BR>The following functions are defined:
<DL>
<DT><A HREF="#_getarcinfo">_getarcinfo</A>
<DD>get the endpoints of the most recently drawn arc
<DT><A HREF="#_getbkcolor">_getbkcolor</A>
<DD>get the background color
<DT><A HREF="#_getcolor">_getcolor</A>
<DD>get the current color
<DT><A HREF="#_getfillmask">_getfillmask</A>
<DD>get the current fill mask
<DT><A HREF="#_getlinestyle">_getlinestyle</A>
<DD>get the current line style
<DT><A HREF="#_getplotaction">_getplotaction</A>
<DD>get the current plotting action
<DT><A HREF="#_remapallpalette">_remapallpalette</A>
<DD>assign colors for all pixel values
<DT><A HREF="#_remappalette">_remappalette</A>
<DD>assign color for one pixel value
<DT><A HREF="#_selectpalette">_selectpalette</A>
<DD>select a palette
<DT><A HREF="#_setbkcolor">_setbkcolor</A>
<DD>set the background color
<DT><A HREF="#_setcolor">_setcolor</A>
<DD>set the current color
<DT><A HREF="#_setfillmask">_setfillmask</A>
<DD>set the current fill mask
<DT><A HREF="#_setlinestyle">_setlinestyle</A>
<DD>set the current line style
<DT><A HREF="#_setplotaction">_setplotaction</A>
<DD>set the current plotting action
</DL>
<H3 ID="Drawing_Functions"> Drawing Functions </H3>
<BR>These functions display graphical images such as lines and ellipses.&nbsp; Functions exist to draw straight lines (see
the <TT> _lineto</TT> functions), rectangles (see the <TT> _rectangle</TT> functions), polygons (see the <TT> _polygon</TT>
functions), ellipses (see the <TT> _ellipse</TT> functions), elliptical arcs (see the <TT> _arc</TT> functions) and pie-shaped
wedges from ellipses (see the <TT> _pie</TT> functions).
<BR><BR>These figures are drawn using the attributes described in the previous section.&nbsp; The functions ending with<TT>
_w</TT> or<TT> _wxy</TT> use the window coordinate system; the others use the view coordinate system.
<BR><BR>The following functions are defined:
<DL>
<DT><A HREF="#_arc">_arc</A>
<DD>draw an arc
<DT>_arc_w (see <A HREF="#_arc">_arc</A>)
<DD>draw an arc using window coordinates
<DT>_arc_wxy (see <A HREF="#_arc">_arc</A>)
<DD>draw an arc using window coordinates
<DT><A HREF="#_clearscreen">_clearscreen</A>
<DD>clear the screen and fill with the background color
<DT><A HREF="#_ellipse">_ellipse</A>
<DD>draw an ellipse
<DT>_ellipse_w (see <A HREF="#_ellipse">_ellipse</A>)
<DD>draw an ellipse using window coordinates
<DT>_ellipse_wxy (see <A HREF="#_ellipse">_ellipse</A>)
<DD>draw an ellipse using window coordinates
<DT><A HREF="#_floodfill">_floodfill</A>
<DD>fill an area of the screen with the current color
<DT>_floodfill_w (see <A HREF="#_floodfill">_floodfill</A>)
<DD>fill an area of the screen in window coordinates with the current color
<DT><A HREF="#_getcurrentposition">_getcurrentposition</A>
<DD>get the coordinates of the current output position
<DT>_getcurrentposition_w (see <A HREF="#_getcurrentposition">_getcurrentposition</A>)
<DD>get the window coordinates of the current output position
<DT><A HREF="#_getpixel">_getpixel</A>
<DD>get the color of the pixel at the specified position
<DT>_getpixel_w (see <A HREF="#_getpixel">_getpixel</A>)
<DD>get the color of the pixel at the specified position in window coordinates
<DT><A HREF="#_lineto">_lineto</A>
<DD>draw a line from the current position to a specified position
<DT>_lineto_w (see <A HREF="#_lineto">_lineto</A>)
<DD>draw a line from the current position to a specified position in window coordinates
<DT><A HREF="#_moveto">_moveto</A>
<DD>set the current output position
<DT>_moveto_w (see <A HREF="#_moveto">_moveto</A>)
<DD>set the current output position using window coordinates
<DT><A HREF="#_pie">_pie</A>
<DD>draw a wedge of a &quot;pie&quot;
<DT>_pie_w (see <A HREF="#_pie">_pie</A>)
<DD>draw a wedge of a &quot;pie&quot; using window coordinates
<DT>_pie_wxy (see <A HREF="#_pie">_pie</A>)
<DD>draw a wedge of a &quot;pie&quot; using window coordinates
<DT><A HREF="#_polygon">_polygon</A>
<DD>draw a polygon
<DT>_polygon_w (see <A HREF="#_polygon">_polygon</A>)
<DD>draw a polygon using window coordinates
<DT>_polygon_wxy (see <A HREF="#_polygon">_polygon</A>)
<DD>draw a polygon using window coordinates
<DT><A HREF="#_rectangle">_rectangle</A>
<DD>draw a rectangle
<DT>_rectangle_w (see <A HREF="#_rectangle">_rectangle</A>)
<DD>draw a rectangle using window coordinates
<DT>_rectangle_wxy (see <A HREF="#_rectangle">_rectangle</A>)
<DD>draw a rectangle using window coordinates
<DT><A HREF="#_setpixel">_setpixel</A>
<DD>set the color of the pixel at the specified position
<DT>_setpixel_w (see <A HREF="#_setpixel">_setpixel</A>)
<DD>set the color of the pixel at the specified position in window coordinates
</DL>
<H3 ID="Text_Functions"> Text Functions </H3>
<BR>These functions deal with displaying text in both graphics and text modes.&nbsp; This type of text output can be displayed
in only one size.
<BR><BR>This text is displayed using the <TT> _outtext</TT> and <TT> _outmem</TT> functions.&nbsp; The output position for
text follows the last text that was displayed or can be reset (see the <TT> _settextposition</TT> function).&nbsp; Text windows
can be created (see the <TT> _settextwindow</TT> function) in which the text will scroll.&nbsp; Text is displayed with the
current text color (see the <TT> _settextcolor</TT> function).
<BR><BR>The following functions are defined:
<DL>
<DT><A HREF="#_clearscreen">_clearscreen</A>
<DD>clear the screen and fill with the background color
<DT><A HREF="#_displaycursor">_displaycursor</A>
<DD>determine whether the cursor is to be displayed after a graphics function completes execution
<DT><A HREF="#_getbkcolor">_getbkcolor</A>
<DD>get the background color
<DT><A HREF="#_gettextcolor">_gettextcolor</A>
<DD>get the color used to display text
<DT><A HREF="#_gettextcursor">_gettextcursor</A>
<DD>get the shape of the text cursor
<DT><A HREF="#_gettextposition">_gettextposition</A>
<DD>get the current output position for text
<DT><A HREF="#_gettextwindow">_gettextwindow</A>
<DD>get the boundary of the current text window
<DT><A HREF="#_outmem">_outmem</A>
<DD>display a text string of a specified length
<DT><A HREF="#_outtext">_outtext</A>
<DD>display a text string
<DT><A HREF="#_scrolltextwindow">_scrolltextwindow</A>
<DD>scroll the contents of the text window
<DT><A HREF="#_setbkcolor">_setbkcolor</A>
<DD>set the background color
<DT><A HREF="#_settextcolor">_settextcolor</A>
<DD>set the color used to display text
<DT><A HREF="#_settextcursor">_settextcursor</A>
<DD>set the shape of the text cursor
<DT><A HREF="#_settextposition">_settextposition</A>
<DD>set the output position for text
<DT><A HREF="#_settextwindow">_settextwindow</A>
<DD>set the boundary of the region used to display text
<DT><A HREF="#_wrapon">_wrapon</A>
<DD>permit or disallow wrap-around of text in a text window
</DL>
<H3 ID="Graphics_Text_Functions"> Graphics Text Functions </H3>
<BR>These functions deal with displaying graphics text.&nbsp; Graphics text is displayed as a sequence of line segments, and
can be drawn in different sizes (see the <TT> _setcharsize</TT> function), with different orientations (see the <TT> _settextorient</TT>
function) and alignments (see the <TT> _settextalign</TT> function).&nbsp; The functions ending with<TT> _w</TT> use the window
coordinate system; the others use the view coordinate system.
<BR><BR>The following functions are defined:
<DL>
<DT><A HREF="#_gettextextent">_gettextextent</A>
<DD>get the bounding rectangle for a graphics text string
<DT><A HREF="#_gettextsettings">_gettextsettings</A>
<DD>get information about the current settings used to display graphics text
<DT><A HREF="#_grtext">_grtext</A>
<DD>display graphics text
<DT>_grtext_w (see <A HREF="#_grtext">_grtext</A>)
<DD>display graphics text using window coordinates
<DT><A HREF="#_setcharsize">_setcharsize</A>
<DD>set the character size used to display graphics text
<DT>_setcharsize_w (see <A HREF="#_setcharsize">_setcharsize</A>)
<DD>set the character size in window coordinates used to display graphics text
<DT><A HREF="#_setcharspacing">_setcharspacing</A>
<DD>set the character spacing used to display graphics text
<DT>_setcharspacing_w (see <A HREF="#_setcharspacing">_setcharspacing</A>)
<DD>set the character spacing in window coordinates used to display graphics text
<DT><A HREF="#_settextalign">_settextalign</A>
<DD>set the alignment used to display graphics text
<DT><A HREF="#_settextorient">_settextorient</A>
<DD>set the orientation used to display graphics text
<DT><A HREF="#_settextpath">_settextpath</A>
<DD>set the path used to display graphics text
</DL>
<H3 ID="Image_Manipulation_Functions"> Image Manipulation Functions </H3>
<BR>These functions are used to transfer screen images.&nbsp; The <TT> _getimage</TT> function transfers a rectangular image
from the screen into memory.&nbsp; The <TT> _putimage</TT> function transfers an image from memory back onto the screen.&nbsp;
The functions ending with<TT> _w</TT> or<TT> _wxy</TT> use the window coordinate system; the others use the view coordinate
system.
<BR><BR>The following functions are defined:
<DL>
<DT><A HREF="#_getimage">_getimage</A>
<DD>store an image of an area of the screen into memory
<DT>_getimage_w (see <A HREF="#_getimage">_getimage</A>)
<DD>store an image of an area of the screen in window coordinates into memory
<DT>_getimage_wxy (see <A HREF="#_getimage">_getimage</A>)
<DD>store an image of an area of the screen in window coordinates into memory
<DT><A HREF="#_imagesize">_imagesize</A>
<DD>get the size of a screen area
<DT>_imagesize_w (see <A HREF="#_imagesize">_imagesize</A>)
<DD>get the size of a screen area in window coordinates
<DT>_imagesize_wxy (see <A HREF="#_imagesize">_imagesize</A>)
<DD>get the size of a screen area in window coordinates
<DT><A HREF="#_putimage">_putimage</A>
<DD>display an image from memory on the screen
<DT>_putimage_w (see <A HREF="#_putimage">_putimage</A>)
<DD>display an image from memory on the screen using window coordinates
</DL>
<H3 ID="Font_Manipulation_Functions"> Font Manipulation Functions </H3>
<BR>These functions are for the display of fonts compatible with Microsoft Windows.&nbsp; Fonts are contained in files with
an extension of<TT> .FON.</TT>&nbsp; Before font based text can be displayed, the fonts must be registered with the <TT> _registerfonts</TT>
function, and a font must be selected with the <TT> _setfont</TT> function.
<BR><BR>The following functions are defined:
<DL>
<DT><A HREF="#_getfontinfo">_getfontinfo</A>
<DD>get information about the currently selected font
<DT><A HREF="#_getgtextextent">_getgtextextent</A>
<DD>get the length in pixels of a text string
<DT><A HREF="#_getgtextvector">_getgtextvector</A>
<DD>get the current value of the font text orientation vector
<DT><A HREF="#_outgtext">_outgtext</A>
<DD>display a string of text in the current font
<DT><A HREF="#_registerfonts">_registerfonts</A>
<DD>initialize the font graphics system
<DT><A HREF="#_setfont">_setfont</A>
<DD>select a font from among the registered fonts
<DT><A HREF="#_setgtextvector">_setgtextvector</A>
<DD>set the font text orientation vector
<DT><A HREF="#_unregisterfonts">_unregisterfonts</A>
<DD>frees memory allocated by the font graphics system
</DL>
<H3 ID="Presentation_Graphics_Functions"> Presentation Graphics Functions </H3>
<BR>These functions provide a system for displaying and manipulating presentation graphics elements such as bar charts and
pie charts.&nbsp; The presentation graphics functions can be further divided into three classes:
<DL>
<DT>Display Functions
<DD>
<BR><BR>These functions are for the initialization of the presentation graphics system and the displaying of charts.
<DT>Analyze Functions
<DD>
<BR><BR>These functions calculate default values for chart elements without actually displaying the chart.
<DT>Utility Functions
<DD>
<BR><BR>These functions provide additional support to control the appearance of presentation graphics elements.
</DL>
<BR>The following subsections describe these function classes in more detail.&nbsp; Each function in the class is noted with
a brief description of its purpose.
<H4 ID="Display_Functions"> Display Functions </H4>
<BR>These functions are for the initialization of the presentation graphics system and the displaying of charts.&nbsp; The
<TT> _pg_initchart</TT> function initializes the system and should be the first presentation graphics function called.&nbsp;
The single-series functions display a single set of data on a chart; the multi-series functions (those ending with<TT> ms)</TT>
display several sets of data on the same chart.
<BR><BR>The following functions are defined:
<DL>
<DT><A HREF="#_pg_chart">_pg_chart</A>
<DD>display a bar, column or line chart
<DT>_pg_chartms (see <A HREF="#_pg_chart">_pg_chart</A>)
<DD>display a multi-series bar, column or line chart
<DT><A HREF="#_pg_chartpie">_pg_chartpie</A>
<DD>display a pie chart
<DT><A HREF="#_pg_chartscatter">_pg_chartscatter</A>
<DD>display a scatter chart
<DT>_pg_chartscatterms (see <A HREF="#_pg_chartscatter">_pg_chartscatter</A>)
<DD>display a multi-series scatter chart
<DT><A HREF="#_pg_defaultchart">_pg_defaultchart</A>
<DD>initialize the chart environment for a specific chart type
<DT><A HREF="#_pg_initchart">_pg_initchart</A>
<DD>initialize the presentation graphics system
</DL>
<H4 ID="Analyze_Functions"> Analyze Functions </H4>
<BR>These functions calculate default values for chart elements without actually displaying the chart.&nbsp; The functions
ending with<TT> ms</TT> analyze multi-series charts; the others analyze single-series charts.
<BR><BR>The following functions are defined:
<DL>
<DT><A HREF="#_pg_analyzechart">_pg_analyzechart</A>
<DD>analyze a bar, column or line chart
<DT>_pg_analyzechartms (see <A HREF="#_pg_analyzechart">_pg_analyzechart</A>)
<DD>analyze a multi-series bar, column or line chart
<DT><A HREF="#_pg_analyzepie">_pg_analyzepie</A>
<DD>analyze a pie chart
<DT><A HREF="#_pg_analyzescatter">_pg_analyzescatter</A>
<DD>analyze a scatter chart
<DT>_pg_analyzescatterms (see <A HREF="#_pg_analyzescatter">_pg_analyzescatter</A>)
<DD>analyze a multi-series scatter chart
</DL>
<H4 ID="Utility_Functions"> Utility Functions </H4>
<BR>These functions provide additional support to control the appearance of presentation graphics elements.
<BR><BR>The following functions are defined:
<DL>
<DT><A HREF="#_pg_getchardef">_pg_getchardef</A>
<DD>get bit-map definition for a specific character
<DT><A HREF="#_pg_getpalette">_pg_getpalette</A>
<DD>get presentation graphics palette (colors, line styles, fill patterns and plot characters)
<DT><A HREF="#_pg_getstyleset">_pg_getstyleset</A>
<DD>get presentation graphics style-set (line styles for window borders and grid lines)
<DT><A HREF="#_pg_hlabelchart">_pg_hlabelchart</A>
<DD>display text horizontally on a chart
<DT><A HREF="#_pg_resetpalette">_pg_resetpalette</A>
<DD>reset presentation graphics palette to default values
<DT><A HREF="#_pg_resetstyleset">_pg_resetstyleset</A>
<DD>reset presentation graphics style-set to default values
<DT><A HREF="#_pg_setchardef">_pg_setchardef</A>
<DD>set bit-map definition for a specific character
<DT><A HREF="#_pg_setpalette">_pg_setpalette</A>
<DD>set presentation graphics palette (colors, line styles, fill patterns and plot characters)
<DT><A HREF="#_pg_setstyleset">_pg_setstyleset</A>
<DD>set presentation graphics style-set (line styles for window borders and grid lines)
<DT><A HREF="#_pg_vlabelchart">_pg_vlabelchart</A>
<DD>display text vertically on a chart
</DL>
<H2 ID="Graphics_Header_Files"> Graphics Header Files </H2>
<BR>All program modules which use the Graphics Library should include the header file<TT> graph.h.</TT>&nbsp; This file contains
prototypes for all the functions in the library as well as the structures and constants used by them.
<BR><BR>Modules using the presentation graphics functions should also include the header file<TT> pgchart.h.</TT>
<H1 ID="DOS_Considerations"> DOS Considerations </H1>
<BR>For the most part, DOS (Disk Operating System) for your personal computer can be ignored, unless an application is highly
dependent upon the hardware or uses specialized functions from the operating system.&nbsp; In this section, some of these
aspects will be addressed.&nbsp; For a more detailed explanation, the technical documentation for the DOS that you are using
should be consulted.
<H2 ID="DOS_Devices"> DOS Devices </H2>
<BR>Most of the hardware devices attached to your computer have names which are recognized by DOS.&nbsp; These names cannot
be used as the names of files.&nbsp; Some examples are:
<DL>
<DT>CON
<DD>the console (screen)
<DT>AUX
<DD>the serial (auxiliary) port
<DT>COM1
<DD>serial port 1
<DT>COM2
<DD>serial port 2
<DT>PRN
<DD>the printer on the parallel port
<DT>LPT1
<DD>the printer on the first parallel port
<DT>LPT2
<DD>the printer on the second parallel port
<DT>LPT3
<DD>the printer on the third parallel port
<DT>NUL
<DD>a non-existent device, which accepts (and discards) output
</DL>
<BR>Disks (such as diskette drives and hard disks) are specified as single letters, starting with the letter A.&nbsp; A colon
character (:) follows the letter for the drive.&nbsp; Either uppercase or lowercase letters can be used.&nbsp; Some examples
are:
<DL>
<DT>A:
<DD>the first disk drive
<DT>a:
<DD>the first disk drive
<DT>e:
<DD>the fifth disk drive
</DL>
<H2 ID="DOS_Directories"> DOS Directories </H2>
<BR>Each disk drive is conceptually divided into directories.&nbsp; Each directory is capable of containing files and/or other
directories.&nbsp; The initial directory, called the<B> root directory,</B> is not named; all other directories are named
and can be accessed with a<B> path</B> specification.&nbsp; A path is either absolute or relative to the current working directory.
&nbsp;Some examples are:
<DL>
<DT>b:\
<DD>the root directory of the second disk drive
<DT>\
<DD>the root directory of the current disk drive
<DT>\outer\middle\inner
<DD>
<BR><BR>directory<TT> inner</TT> which is contained within directory<TT> middle</TT> which is contained within directory<TT>
outer</TT> which is contained within the root directory of the current disk drive.
</DL>
<BR>Directory names are separated by backslash characters (\).&nbsp; The initial backslash character informs DOS that the
path starts with the root directory.&nbsp; When the first character is not a backslash, the path starts with the current working
directory on the indicated device.
<BR><BR>The DOS<TT> CHDIR (CD)</TT> command can be used to change the current working directory for a device.&nbsp; Suppose
that the following DOS commands were issued:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; chdir a:\apps\payroll</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; chdir c:\mydir</TT>
<BR><BR>Then, the following path specifications are:
<DL>
<DT>Relative Path&nbsp;&nbsp;&nbsp;&nbsp; Absolute Path
<DT>a:xxx\y
<DD>a:\apps\payroll\xxx\y
<DT>c:zzzzz
<DD>c:\mydir\zzzzz
</DL>
<BR>When no drive is specified, DOS uses the current disk drive.
<H2 ID="DOS_File_Names"> DOS File Names </H2>
<BR>The name of a file within a directory has the format<TT> filename.ext</TT> where the required<TT> filename</TT> portion
is up to eight characters in length and the optional<TT> ext</TT> portion is up to three characters in length.&nbsp; A period
character (.) separates the two names when the<TT> ext</TT> portion is present.
<BR><BR>More than eight characters can be given in the<TT> filename.</TT>&nbsp; DOS truncates the name to eight characters
when a longer<TT> filename</TT> is given.&nbsp; This may lead to erroneous results in some cases, since the files<TT> MYBIGDATAFILE</TT>
and<TT> MYBIGDATES</TT> both refer to the file<TT> MYBIGDAT.</TT>
<BR><BR>The characters used in file names may be letters, digits as well as some other characters documented in your DOS technical
documentation.&nbsp; Most people restrict their file names to contain only letters and digits.&nbsp; Uppercase and lowercase
letters are treated as being equivalent (file names are case insensitive).&nbsp; Thus, the files
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; MYDATA.NEW</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; mydata.new</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; MyData.New</TT>
<BR><BR>all refer to the same file.
<BR><BR>You cannot use a DOS device name (such as <TT> CON</TT> or <TT> PRN</TT>, for example) for a file name.&nbsp; See
the section<B> DOS Devices</B> for a list of these reserved names.
<BR><BR>A complete file designation has the following format:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; drive:\path\filename.ext</TT>
<BR><BR>where:
<DL>
<DT>drive:
<DD>is an optional disk drive specification.&nbsp; If omitted, the default drive is used.&nbsp; Some examples are:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; A:&nbsp; (first disk drive)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; c:&nbsp; (third disk drive)</TT>
<DT>\path\
<DD>is the path specification for the directory containing the desired file.&nbsp; Some examples are:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; \mylib\</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; \apps\payroll\</TT>
<DT>filename.ext
<DD>is the name of the file.
</DL>
<BR>Suppose that the current working directories are as follows:
<DL>
<DT>Drive&nbsp;&nbsp;&nbsp;&nbsp; Directory
<DT>A:
<DD>\payroll
<DT>B:
<DD>\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (root directory)
<DT>C:
<DD>\source\c
</DL>
<BR>and that the default disk drive is<TT> C:.</TT>&nbsp; Then, the following file designations will result in the indicated
file references:
<DL>
<DT>Designation&nbsp;&nbsp;&nbsp;&nbsp; Actual File
<DT>pgm.c
<DD>C:\SOURCE\C\PGM.C
<DT>\basic.dat
<DD>C:\BASIC.DAT
<DT>paypgm\outsep.c
<DD>C:\SOURCE\C\PAYPGM\OUTSEP.C
<DT>b:data
<DD>B:\DATA
<DT>a:employee
<DD>A:\PAYROLL\EMPLOYEE
<DT>a:\deduct\yr1988
<DD>A:\DEDUCT\YR1988
</DL>
<H2 ID="DOS_Files"> DOS Files </H2>
<BR>DOS files are stored within directories on disk drives.&nbsp; Most software, including Open Watcom C/C++, treats files
in two representations:
<DL>
<DT>BINARY
<DD>These files can contain arbitrary data.&nbsp; It is the responsibility of the software to recognize records within the file
if they exist.
<DT>TEXT
<DD>These files contain lines of &quot;printable&quot; characters.&nbsp; Each line is delimited by a carriage return character
followed by a linefeed character.
</DL>
<BR>Since the conceptual view of text files in the C and C++ languages is that lines are terminated by only linefeed characters,
the Open Watcom C library will remove carriage returns on input and add them on output, provided the mode is set to be<B>
text.</B>&nbsp; This mode is set upon opening the file or with the <TT> setmode</TT> function.
<H2 ID="DOS_Commands"> DOS Commands </H2>
<BR>DOS commands are documented in the technical documentation for your DOS system.&nbsp; These may be invoked from a C or
C++ program with the <TT> system</TT> function.
<H2 ID="DOS_Interrupts"> DOS Interrupts </H2>
<BR>DOS interrupts and 8086 interrupts are documented in the technical documentation for your DOS system.&nbsp; These may
be generated from a C or C++ program by calling the <TT> bdos</TT>, <TT> intdos</TT>, <TT> intdosx</TT>, <TT> intr</TT>, <TT>
intrf</TT>, <TT> int386</TT>, <TT> int386x</TT>, <TT> int86</TT> and <TT> int86x</TT> functions.
<H2 ID="DOS_Processes"> DOS Processes </H2>
<BR>Currently, DOS has the capability to execute only one process at a time.&nbsp; Thus, when a process is initiated with
the <TT> spawn...</TT>&nbsp; parameter <TT> P_WAIT</TT>, the new process will execute to completion before control returns
to the initiating program.&nbsp; Otherwise, the new task replaces the initial task.&nbsp; Tasks can be started by using the
<TT> system</TT>, <TT> exec...</TT>&nbsp; and <TT> spawn...</TT>&nbsp; functions.
<H1 ID="Library_Functions_and_Macros"> Library Functions and Macros </H1>
<BR>Each of the functions or macros in the C Library is described in this chapter.&nbsp; Each description consists of a number
of subsections:
<DL>
<DT>Synopsis:
<DD>This subsection gives the header files that should be included within a source file that references the function or macro.
&nbsp;It also shows an appropriate declaration for the function or for a function that could be substituted for a macro.&nbsp;
This declaration is not included in your program; only the header file(s) should be included.
<BR><BR>When a pointer argument is passed to a function and that function does not modify the item indicated by that pointer,
the argument is shown with <TT> const</TT> before the argument.&nbsp; For example,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; const char *string</TT>
<BR><BR>indicates that the array pointed at by<B> string</B> is not changed.
<DT>Constraints:
<DD>This subsection describes Runtime-constraints for Safer C Library functions.
<DT>Safer C:
<DD>This subsection points to the Safer C version of the described &quot;unsafe&quot; function.
<DT>Description:
<DD>This subsection is a description of the function or macro.
<DT>Returns:
<DD>This subsection describes the return value (if any) for the function or macro.
<DT>Errors:
<DD>This subsection describes the possible <TT> errno</TT> values.
<DT>See Also:
<DD>This optional subsection provides a list of related functions or macros.
<DT>Example:
<DD>This optional subsection consists of one or more examples of the use of the function.&nbsp; The examples are often just fragments
of code (not complete programs) for illustration purposes.
<DT>Classification:
<DD>This subsection provides an indication of where the function or macro is commonly found.&nbsp; The following notation is used:
<DL>
<DT>ISO C
<DD>These functions or macros are defined by the ISO/ANSI C standard ISO/IEC 9899:1989.
<DT>ISO C90
<DD>These functions or macros are defined by the ISO/ANSI C standard ISO/IEC 9899:1990.
<DT>ISO C95
<DD>These functions or macros are defined by the ISO/ANSI C standard ISO/IEC 9899:1990/AMD 1:1995.
<DT>ISO C99
<DD>These functions or macros are defined by the ISO/ANSI C standard ISO/IEC 9899:1999.
<DT>POSIX 1003.1
<DD>The functions or macros are not defined by the ISO C standard.&nbsp; These functions are specified in the document<B> IEEE
Standard Portable Operating System Interface for Computer Environments</B> (IEEE Draft Standard 1003.1-1990).
<DT>POSIX 1003.2
<DD>These functions or macros are not defined by the ISO C standard.&nbsp; These functions are specified in the document<B> Shell
and Utility Application Interface for Computer Operating System Environments</B> (IEEE Computer Society Working Group 1003.2).
<DT>POSIX 1003.4
<DD>These functions or macros are not defined by the ISO C standard.&nbsp; These functions are specified in the document<B> Realtime
Extensions for Computer Operating System Environments</B> (IEEE Computer Society Working Group 1003.4).
<DT>Intel
<DD>These functions or macros are neither ISO C nor POSIX.&nbsp; It performs a function related to the Intel x86 architecture.
&nbsp;It may be found in other implementations of C for personal computers using Intel chips.&nbsp; Use these functions with
caution, if portability is a consideration.
<DT>BIOS
<DD>These functions access a service of the BIOS found in IBM Personal Computers and compatibles.&nbsp; These functions should
not be used if portability is a consideration.
<DT>DOS
<DD>These functions or macros are neither ISO C nor POSIX.&nbsp; They perform a function related to DOS.&nbsp; They may be found
in other implementations of C for personal computers with DOS.&nbsp; Use these functions with caution, if portability is a
consideration.
<DT>OS/2
<DD>These functions are specific to OS/2.
<DT>PC Graphics
<DD>These functions are part of the PC graphics library.
<DT>Windows
<DD>These functions are specific to Microsoft Windows.
<DT>WATCOM
<DD>These functions or macros are neither ISO C nor POSIX.&nbsp; They may be found in other implementations of the C language,
but caution should be used if portability is a consideration.
<DT>TR 24731
<DD>These functions are &quot;safer&quot; versions of normal C library functions.&nbsp; They perform more checks on parameters
and should be used in preference over their &quot;unsafe&quot; version.
</DL>
<DT>Systems:
<DD>This subsection provides an indication of where the function or macro is supported.&nbsp; The following notation is used:
<DL>
<DT>All
<DD>This function is available on all systems (we do not include RDOS, Linux, Netware or DOS/PM in this category).
<DT>DOS
<DD>This function is available on both 16-bit DOS and 32-bit extended DOS.
<DT>DOS/16
<DD>This function is available on 16-bit, real-mode DOS.
<DT>DOS/32
<DD>This function is available on 32-bit, protected-mode extended DOS.
<DT>DOS/PM
<DD>This 16-bit DOS protected-mode function is supported under Phar Lap's 286|DOS-Extender &quot;RUN286&quot;.&nbsp; The function
is found in one of Open Watcom's 16-bit protected-mode DOS libraries (DOSPM*.LIB under the 16-bit OS2 subdirectory).
<DT>Linux
<DD>This function is available on the Linux operating system for Intel 80386 and upwards compatible systems.
<DT>MACRO
<DD>This function is implemented as a macro (#define) on all systems.
<DT>Math
<DD>This function is a math function.&nbsp; Math functions are available on all systems.
<DT>Netware
<DD>This function is available on the 32-bit Novell Netware operating system.
<DT>OS/2 1.x
<DD>This function is available on IBM OS/2 1.x, a 16-bit protected-mode system for Intel 80286 and upwards compatible systems.
<BR><BR>When &quot;(MT)&quot; appears after OS/2, it refers to the<TT> CLIBMTL</TT> library which supports multi-threaded
applications.
<BR><BR>When &quot;(DL)&quot; appears after OS/2, it refers to the<TT> CLIBDLL</TT> library which supports creation of Dynamic
Link Libraries.
<BR><BR>When &quot;(all)&quot; appears after &quot;OS/2 1&quot;, it means all versions of the OS/2 1.x libraries.
<BR><BR>If a function is missing from the OS/2 library, it may be found in Open Watcom's 16-bit protected-mode DOS libraries
(DOSPM*.LIB) for Phar Lap's 286|DOS-Extender (RUN286).
<DT>OS/2-32
<DD>This function is available on 32-bit IBM OS/2, a protected-mode system for Intel 80386 and upwards compatible systems.
<DT>RDOS
<DD>This function is available on RDOS operating system.
<DT>QNX
<DD>This function is available on QNX Software Systems' 16 or 32-bit operating systems.
<DT>QNX/16
<DD>This function is available on QNX Software Systems' 16-bit operating system.
<DT>QNX/32
<DD>This function is available on QNX Software Systems' 32-bit operating system.
<DT>Windows
<DD>This function is available on 16-bit, protected-mode Windows 3.x.
<DT>Win386
<DD>This function is available on Microsoft Windows 3.x, using Open Watcom's Windows Extender for 32-bit protected-mode applications
running on Intel 386 or upward compatible systems.
<DT>Win32
<DD>This function is available on 32-bit Microsoft Windows platforms (Windows 95, Windows 98, Windows NT, Windows 2000, etc.).
&nbsp;It may also be available for Windows 3.x using Win32s support.
</DL>
</DL>
<H2 ID="abort"> abort </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>void abort( void );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> abort</TT> function raises the signal SIGABRT.&nbsp; The default action for SIGABRT is to terminate program execution,
returning control to the process that started the calling program (usually the operating system).&nbsp; The status<B> unsuccessful
termination</B> is returned to the invoking process by means of the function call<TT> raise(SIGABRT).</TT>&nbsp; The exit
code returned to the invoking process is <TT> EXIT_FAILURE</TT> which is defined in the<TT> &lt;stdlib.h&gt;</TT> header file.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> abort</TT> function does not return to its caller.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#atexit">atexit</A>, <A HREF="#_bgetcmd">_bgetcmd</A>, <A HREF="#exec___">exec...</A>, <A HREF="#exit">exit</A>,
<A HREF="#_Exit">_Exit</A>, <A HREF="#_exit">_exit</A>, <A HREF="#getcmd">getcmd</A>, <A HREF="#getenv">getenv</A>, <A HREF="#main">main</A>,
<A HREF="#onexit">onexit</A>, <A HREF="#putenv">putenv</A>, <A HREF="#spawn___">spawn...</A>, <A HREF="#system">system</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int major_error = 1;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; if( major_error )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; abort();</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="abort_handler_s"> abort_handler_s </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__ 1</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>void abort_handler_s(</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char * restrict msg,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void * restrict ptr,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; errno_t error );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> abort_handler_s</TT> function may be passed as an argument to the<TT> set_constraint_handler_s</TT> function.&nbsp;
It writes a message on the standard error stream in the following format:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Runtime-constraint violation: &lt;msg&gt;</TT>
<BR><BR>The<TT> abort_handler_s</TT> function then calls the<TT> abort</TT> function.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> abort_handler_s</TT> function does not return to its caller.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#ignore_handler_s">ignore_handler_s</A>, <A HREF="#set_constraint_handler_s">set_constraint_handler_s</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__ 1</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; constraint_handler_t&nbsp;&nbsp;&nbsp; old_handler;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; old_handler = set_constraint_handler_s( abort_handler_s );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( getenv_s( NULL, NULL, 0, NULL ) ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;getenv_s failed\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; set_constraint_handler_s( old_handler );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>Runtime-constraint violation: getenv_s, name == NULL.</TT>
<BR><TT>ABNORMAL TERMINATION</TT>
</DL>
<DL>
<DT>Classification:
<DD>TR 24731
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="abs"> abs </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>int abs( int j );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> abs</TT> function returns the absolute value of its integer argument<B> j</B>.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> abs</TT> function returns the absolute value of its argument.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#labs">labs</A>, <A HREF="#llabs">llabs</A>, <A HREF="#imaxabs">imaxabs</A>, <A HREF="#fabs">fabs</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%d %d %d\n&quot;, abs( -5 ), abs( 0 ), abs( 5 ) );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>5 0 5</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C90
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="access"> access, _access, _waccess </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;io.h&gt;</TT>
<BR><TT>int access( const char *path, int mode );</TT>
<BR><TT>int _access( const char *path, int mode );</TT>
<BR><TT>int _waccess( const wchar_t *path, int mode );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> access</TT> function determines if the file or directory specified by<B> path</B> exists and if it can be accessed
with the file permission given by<B> mode</B>.
<BR><BR>When the value of<B> mode</B> is zero, only the existence of the file is verified.&nbsp; The read and/or write permission
for the file can be determined when<B> mode</B> is a combination of the bits:
<DL>
<DT>Bit&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>R_OK
<DD>test for read permission
<DT>W_OK
<DD>test for write permission
<DT>X_OK
<DD>test for execute permission
<DT>F_OK
<DD>test for existence of file
</DL>
<BR>With DOS, all files have read permission; it is a good idea to test for read permission anyway, since a later version
of DOS may support write-only files.
<BR><BR>The<TT> _access</TT> function is identical to<TT> access</TT>.&nbsp; Use<TT> _access</TT> for ANSI naming conventions.
<BR><BR>The<TT> _waccess</TT> function is a wide-character version of<TT> access</TT> that operates with wide-character strings.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> access</TT> function returns zero if the file or directory exists and can be accessed with the specified mode.&nbsp;
Otherwise, -1 is returned and <TT> errno</TT> is set to indicate the error.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>EACCES
<DD>Access denied because the file's permission does not allow the specified access.
<DT>ENOENT
<DD>Path or file not found.
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#chmod">chmod</A>, <A HREF="#fstat">fstat</A>, <A HREF="#open">open</A>, <A HREF="#sopen">sopen</A>, <A HREF="#stat">stat</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>#include &lt;io.h&gt;</TT>
<BR><BR><TT>void main( int argc, char *argv[] )</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( argc != 2 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf( stderr, &quot;Use: check &lt;filename&gt;\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit( 1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; if( access( argv[1], F_OK ) == 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%s exists\n&quot;, argv[1] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%s does not exist\n&quot;, argv[1] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit( EXIT_FAILURE );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( access( argv[1], R_OK ) == 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%s is readable\n&quot;, argv[1] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( access( argv[1], W_OK ) == 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%s is writeable\n&quot;, argv[1] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( access( argv[1], X_OK ) == 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%s is executable\n&quot;, argv[1] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; exit( EXIT_SUCCESS );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>POSIX 1003.1
<BR><BR>_access conforms to ANSI naming conventions
<BR>_waccess is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> access - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_access - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
<BR><TT>_waccess - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</TT>
</DL>
<H2 ID="acos"> acos </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>double acos( double x );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> acos</TT> function computes the principal value of the arccosine of<B> x</B>.&nbsp; A domain error occurs for arguments
not in the range [-1,1].
</DL>
<DL>
<DT>Returns:
<DD>The<TT> acos</TT> function returns the arccosine in the range [0,P].&nbsp; When the argument is outside the permissible range,
the <TT> matherr</TT> function is called.&nbsp; Unless the default <TT> matherr</TT> function is replaced, it will set the
global variable <TT> errno</TT> to <TT> EDOM</TT>, and print a &quot;DOMAIN error&quot; diagnostic message using the <TT>
stderr</TT> stream.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#asin">asin</A>, <A HREF="#atan">atan</A>, <A HREF="#atan2">atan2</A>, <A HREF="#matherr">matherr</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, acos(.5) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>1.047197</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD>Math
</DL>
<H2 ID="acosh"> acosh </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>double acosh( double x );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> acosh</TT> function computes the inverse hyperbolic cosine of<B> x</B>.&nbsp; A domain error occurs if the value of<B>
x</B> is less than 1.0.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> acosh</TT> function returns the inverse hyperbolic cosine value.&nbsp; When the argument is outside the permissible
range, the <TT> matherr</TT> function is called.&nbsp; Unless the default <TT> matherr</TT> function is replaced, it will
set the global variable <TT> errno</TT> to <TT> EDOM</TT>, and print a &quot;DOMAIN error&quot; diagnostic message using the
<TT> stderr</TT> stream.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#asinh">asinh</A>, <A HREF="#atanh">atanh</A>, <A HREF="#cosh">cosh</A>, <A HREF="#matherr">matherr</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, acosh( 1.5 ) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>0.962424</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>Math
</DL>
<H2 ID="alloca"> alloca </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;malloc.h&gt;</TT>
<BR><TT>void *alloca( size_t size );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> alloca</TT> function allocates space for an object of<B> size</B> bytes from the stack.&nbsp; The allocated space
is automatically discarded when the current function exits.&nbsp; The<TT> alloca</TT> function should not be used in an expression
that is an argument to a function.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> alloca</TT> function returns a pointer to the start of the allocated memory.&nbsp; The return value is<TT> NULL</TT>
if there is insufficient stack space available.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#calloc">calloc</A>, <A HREF="#malloc">malloc</A>, <A HREF="#stackavail">stackavail</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>#include &lt;malloc.h&gt;</TT>
<BR><TT>FILE *open_err_file( char * );</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FILE *fp;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; fp = open_err_file( &quot;alloca&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( fp == NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Unable to open error file\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( fp );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR><TT>FILE *open_err_file( char *name )</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char *buffer;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* allocate temp buffer for file name */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; buffer = (char *) alloca( strlen(name) + 5 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; if( buffer ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf( buffer, &quot;%s.err&quot;, name );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( fopen( buffer, &quot;w&quot; ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; return( (FILE *) NULL );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="_arc"> _arc, _arc_w, _arc_wxy </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>short _FAR _arc( short x1, short y1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short x2, short y2,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short x3, short y3,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short x4, short y4
);</TT>
<BR><BR><TT>short _FAR _arc_w( double x1, double y1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double
x2, double y2,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double
x3, double y3,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double
x4, double y4 );</TT>
<BR><BR><TT>short _FAR _arc_wxy( struct _wxycoord _FAR *p1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;struct _wxycoord _FAR *p2,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;struct _wxycoord _FAR *p3,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;struct _wxycoord _FAR *p4 );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _arc</TT> functions draw elliptical arcs.&nbsp; The<TT> _arc</TT> function uses the view coordinate system.&nbsp;
The<TT> _arc_w</TT> and<TT> _arc_wxy</TT> functions use the window coordinate system.
<BR><BR>The center of the arc is the center of the rectangle established by the points<TT> (x1,y1)</TT> and<TT> (x2,y2).</TT>
&nbsp;The arc is a segment of the ellipse drawn within this bounding rectangle.&nbsp; The arc starts at the point on this
ellipse that intersects the vector from the centre of the ellipse to the point<TT> (x3,y3).</TT>&nbsp; The arc ends at the
point on this ellipse that intersects the vector from the centre of the ellipse to the point<TT> (x4,y4).</TT>&nbsp; The arc
is drawn in a counter-clockwise direction with the current plot action using the current color and the current line style.
<BR><BR>The following picture illustrates the way in which the bounding rectangle and the vectors specifying the start and
end points are defined.
<BR><BR><IMG SRC="pic1.bmp" ALIGN=MIDDLE>
<BR>When the coordinates<TT> (x1,y1)</TT> and<TT> (x2,y2)</TT> establish a line or a point (this happens when one or more
of the x-coordinates or y-coordinates are equal), nothing is drawn.
<BR><BR>The current output position for graphics output is set to be the point at the end of the arc that was drawn.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _arc</TT> functions return a non-zero value when the arc was successfully drawn; otherwise, zero is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_ellipse">_ellipse</A>, <A HREF="#_pie">_pie</A>, <A HREF="#_rectangle">_rectangle</A>, <A HREF="#_getarcinfo">_getarcinfo</A>,
<A HREF="#_setcolor">_setcolor</A>, <A HREF="#_setlinestyle">_setlinestyle</A>, <A HREF="#_setplotaction">_setplotaction</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _arc( 120, 90, 520, 390, 500, 20, 450, 460 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><IMG SRC="eg_arc.bmp" ALIGN=MIDDLE>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD><TT> _arc - DOS</TT>
<BR><BR><TT>_arc_w - DOS</TT>
<BR><TT>_arc_wxy - DOS</TT>
</DL>
<H2 ID="asctime"> asctime Functions </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;time.h&gt;</TT>
<BR><TT>char * asctime( const struct tm *timeptr );</TT>
<BR><TT>char *_asctime( const struct tm *timeptr, char *buf );</TT>
<BR><TT>wchar_t *_wasctime( const struct tm *timeptr );</TT>
<BR><TT>wchar_t *__wasctime( const struct tm *timeptr, wchar_t *buf );</TT>
<BR><BR><TT>struct&nbsp; tm {</TT>
<BR><TT>&nbsp; int tm_sec;&nbsp;&nbsp; /* seconds after the minute -- [0,61] */</TT>
<BR><TT>&nbsp; int tm_min;&nbsp;&nbsp; /* minutes after the hour&nbsp;&nbsp; -- [0,59] */</TT>
<BR><TT>&nbsp; int tm_hour;&nbsp; /* hours after midnight&nbsp;&nbsp;&nbsp;&nbsp; -- [0,23] */</TT>
<BR><TT>&nbsp; int tm_mday;&nbsp; /* day of the month&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- [1,31] */</TT>
<BR><TT>&nbsp; int tm_mon;&nbsp;&nbsp; /* months since January&nbsp;&nbsp;&nbsp;&nbsp; -- [0,11] */</TT>
<BR><TT>&nbsp; int tm_year;&nbsp; /* years since 1900&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp; int tm_wday;&nbsp; /* days since Sunday&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- [0,6]&nbsp; */</TT>
<BR><TT>&nbsp; int tm_yday;&nbsp; /* days since January 1&nbsp;&nbsp;&nbsp;&nbsp; -- [0,365]*/</TT>
<BR><TT>&nbsp; int tm_isdst; /* Daylight Savings Time flag */</TT>
<BR><TT>};</TT>
</DL>
<DL>
<DT>Safer C:
<DD>The Safer C Library extension provides the <A HREF="#asctime_s">asctime_s</A> function which is a safer alternative to<TT>
asctime</TT> This newer<TT> asctime_s</TT> function is recommended to be used instead of the traditional &quot;unsafe&quot;<TT>
asctime</TT> function.
</DL>
<DL>
<DT>Description:
<DD>The<B> asctime</B> functions convert the time information in the structure pointed to by<B> timeptr</B> into a string containing
exactly 26 characters.&nbsp; This string has the form shown in the following example:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Sat Mar 21 15:58:27 1987\n\0</TT>
<BR><BR>All fields have a constant width.&nbsp; The new-line character<TT> '\n'</TT> and the null character<TT> '\0'</TT>
occupy the last two positions of the string.
<BR><BR>The ISO C function<B> asctime</B> places the result string in a static buffer that is re-used each time<B> asctime</B>
or <TT> ctime</TT> is called.&nbsp; The non-ISO C function <TT> _asctime</TT> places the result string in the buffer pointed
to by<B> buf</B>.
<BR><BR>The <TT> _wasctime</TT> and <TT> __wasctime</TT> functions are identical to their <TT> asctime</TT> and <TT> _asctime</TT>
counterparts except that they deal with wide-character strings.
</DL>
<DL>
<DT>Returns:
<DD>The<B> asctime</B> functions return a pointer to the character string result.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#asctime_s">asctime_s</A>, <A HREF="#clock">clock</A>, <A HREF="#ctime">ctime</A> Functions, <A HREF="#ctime_s">ctime_s</A>,
<A HREF="#difftime">difftime</A>, <A HREF="#gmtime">gmtime</A>, <A HREF="#gmtime_s">gmtime_s</A>, <A HREF="#localtime">localtime</A>,
<A HREF="#localtime_s">localtime_s</A>, <A HREF="#mktime">mktime</A>, <A HREF="#strftime">strftime</A>, <A HREF="#time">time</A>,
<A HREF="#tzset">tzset</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;time.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct tm&nbsp; time_of_day;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp;&nbsp;&nbsp; ltime;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; auto char&nbsp; buf[26];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; time( &amp;ltime );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _localtime( &amp;ltime, &amp;time_of_day );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Date and time is: %s\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _asctime( &amp;time_of_day, buf ) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>Date and time is: Sat Mar 21 15:58:27 1987</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>_asctime is WATCOM
<BR>_wasctime is WATCOM
<BR>__wasctime is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> asctime - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_asctime - All, RDOS, Netware</TT>
<BR><TT>_wasctime - All, Linux</TT>
<BR><TT>__wasctime - All, Linux</TT>
</DL>
<H2 ID="asctime_s"> asctime_s, _wasctime_s </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__ 1</TT>
<BR><TT>#include &lt;time.h&gt;</TT>
<BR><TT>errno_t asctime_s( char * s,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rsize_t
maxsize,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const
struct tm * timeptr);</TT>
<BR><TT>errno_t _wasctime_s( wchar_t * s,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;rsize_t maxsize,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;const struct tm * timeptr);</TT>
<BR><BR><TT>struct&nbsp; tm {</TT>
<BR><TT>&nbsp; int tm_sec;&nbsp;&nbsp; /* seconds after the minute -- [0,61] */</TT>
<BR><TT>&nbsp; int tm_min;&nbsp;&nbsp; /* minutes after the hour&nbsp;&nbsp; -- [0,59] */</TT>
<BR><TT>&nbsp; int tm_hour;&nbsp; /* hours after midnight&nbsp;&nbsp;&nbsp;&nbsp; -- [0,23] */</TT>
<BR><TT>&nbsp; int tm_mday;&nbsp; /* day of the month&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- [1,31] */</TT>
<BR><TT>&nbsp; int tm_mon;&nbsp;&nbsp; /* months since January&nbsp;&nbsp;&nbsp;&nbsp; -- [0,11] */</TT>
<BR><TT>&nbsp; int tm_year;&nbsp; /* years since 1900&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp; int tm_wday;&nbsp; /* days since Sunday&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- [0,6]&nbsp; */</TT>
<BR><TT>&nbsp; int tm_yday;&nbsp; /* days since January 1&nbsp;&nbsp;&nbsp;&nbsp; -- [0,365]*/</TT>
<BR><TT>&nbsp; int tm_isdst; /* Daylight Savings Time flag */</TT>
<BR><TT>};</TT>
</DL>
<DL>
<DT>Constraints:
<DD>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<TT>
asctime_s</TT> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<BR><BR>Neither<B> s</B> nor<B> timeptr</B> shall be a null pointer.&nbsp; maxsize shall not be less than 26 and shall not
be greater than<B> RSIZE_MAX</B>.&nbsp; The broken-down time pointed to by<B> timeptr</B> shall be normalized.&nbsp; The calendar
year represented by the broken-down time pointed to by<B> timeptr</B> shall not be less than calendar year 0 and shall not
be greater than calendar year 9999.&nbsp; If there is a runtime-constraint violation, there is no attempt to convert the time,
and<B> s[0]</B> is set to a null character if<B> s</B> is not a null pointer and<B> maxsize</B> is not zero and is not greater
than<B> RSIZE_MAX</B>.
</DL>
<DL>
<DT>Description:
<DD>The<TT> asctime_s</TT> function converts the normalized broken-down time in the structure pointed to by<B> timeptr</B> into
a 26 character (including the null character) string in the form
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Sun Sep 16 01:03:52 1973\n\0</TT>
<BR><BR>The fields making up this string are (in order):
<OL>
<LI>The name of the day of the week represented by<B> timeptr-&gt;tm_wday</B> using the following three character weekday
names:
<BR><BR>Sun, Mon, Tue, Wed, Thu, Fri, and Sat.
<LI>The character space.
<LI>The name of the month represented by<B> timeptr-&gt;tm_mon</B> using the following three character month names:
<BR><BR>Jan, Feb, Mar,Apr,May,Jun, Jul, Aug, Sep, Oct, Nov, and Dec.
<LI>The character space.
<LI>The value of<B> timeptr-&gt;tm_mday</B> as if printed using the fprintf format &quot;%2d&quot;.
<LI>The character space.
<LI>The value of timeptr-&gt;tm_hour as if printed using the fprintf format &quot;%.2d&quot;.
<LI>The character colon.
<LI>The value of<B> timeptr-&gt;tm_min</B> as if printed using the fprintf format &quot;%.2d&quot;.
<LI>The character colon.
<LI>The value of<B> timeptr-&gt;tm_sec</B> as if printed using the fprintf format &quot;%.2d&quot;.
<LI>The character space.
<LI>The value of<B> timeptr-&gt;tm_year + 1900</B> as if printed using the fprintf format &quot;%4d&quot;.
<LI>The character new line.
<LI>The null character.
</OL>
<BR>The<TT> _wasctime_s</TT> function is a wide-character version of<TT> asctime_s</TT> that operates with wide-character
strings.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> asctime_s</TT> function returns zero if there was no runtime-constraint violation.&nbsp; Otherwise, a non-zero value
is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#asctime">asctime</A> Functions, <A HREF="#clock">clock</A>, <A HREF="#ctime">ctime</A> Functions, <A HREF="#ctime_s">ctime_s</A>,
<A HREF="#difftime">difftime</A>, <A HREF="#gmtime">gmtime</A>, <A HREF="#gmtime_s">gmtime_s</A>, <A HREF="#localtime">localtime</A>,
<A HREF="#localtime_s">localtime_s</A>, <A HREF="#mktime">mktime</A>, <A HREF="#strftime">strftime</A>, <A HREF="#time">time</A>,
<A HREF="#tzset">tzset</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__ 1</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;time.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct tm&nbsp; time_of_day;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp;&nbsp;&nbsp; ltime;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; auto char&nbsp; buf[26];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; time( &amp;ltime );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _localtime( &amp;ltime, &amp;time_of_day );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; asctime_s( buf, sizeof( buf ), &amp;time_of_day );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Date and time is: %s\n&quot;, buf );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>Date and time is: Mon Jan 30 11:32:45 2006</TT>
</DL>
<DL>
<DT>Classification:
<DD>TR 24731
<BR><BR>_wasctime_s is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> asctime_s - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, Linux, RDOS, Netware</TT>
<BR><BR><TT>_wasctime_s - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, Linux</TT>
</DL>
<H2 ID="asin"> asin </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>double asin( double x );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> asin</TT> function computes the principal value of the arcsine of<B> x</B>.&nbsp; A domain error occurs for arguments
not in the range [-1,1].
</DL>
<DL>
<DT>Returns:
<DD>The<TT> asin</TT> function returns the arcsine in the range [-P/2,P/2].&nbsp; When the argument is outside the permissible
range, the <TT> matherr</TT> function is called.&nbsp; Unless the default <TT> matherr</TT> function is replaced, it will
set the global variable <TT> errno</TT> to <TT> EDOM</TT>, and print a &quot;DOMAIN error&quot; diagnostic message using the
<TT> stderr</TT> stream.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#acos">acos</A>, <A HREF="#atan">atan</A>, <A HREF="#atan2">atan2</A>, <A HREF="#matherr">matherr</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, asin(.5) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>0.523599</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD>Math
</DL>
<H2 ID="asinh"> asinh </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>double asinh( double x );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> asinh</TT> function computes the inverse hyperbolic sine of<B> x</B>.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> asinh</TT> function returns the inverse hyperbolic sine value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#acosh">acosh</A>, <A HREF="#atanh">atanh</A>, <A HREF="#sinh">sinh</A>, <A HREF="#matherr">matherr</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, asinh( 0.5 ) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>0.481212</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>Math
</DL>
<H2 ID="assert"> assert </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;assert.h&gt;</TT>
<BR><TT>void assert( int expression );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> assert</TT> macro prints a diagnostic message upon the <TT> stderr</TT> stream and terminates the program if<B> expression</B>
is false (0).&nbsp; The diagnostic message has the form
<BR><BR><TT>Assertion failed:</TT><B>&nbsp; expression</B>,<TT> file</TT><B> filename</B>,<TT> line</TT><B> linenumber</B>
<BR><BR>where<B> filename</B> is the name of the source file and<B> linenumber</B> is the line number of the assertion that
failed in the source file.<B>&nbsp; Filename</B> and<B> linenumber</B> are the values of the preprocessing macros <TT> __FILE__</TT>
and <TT> __LINE__</TT> respectively.&nbsp; No action is taken if<B> expression</B> is true (non-zero).
<BR><BR>The<TT> assert</TT> macro is typically used during program development to identify program logic errors.&nbsp; The
given<B> expression</B> should be chosen so that it is true when the program is functioning as intended.&nbsp; After the program
has been debugged, the special &quot;no debug&quot; identifier <TT> NDEBUG</TT> can be used to remove<TT> assert</TT> calls
from the program when it is re-compiled.&nbsp; If <TT> NDEBUG</TT> is defined (with any value) with a<TT> -d</TT> command
line option or with a<TT> #define</TT> directive, the C preprocessor ignores all<TT> assert</TT> calls in the program source.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> assert</TT> macro does not return a value.
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;assert.h&gt;</TT>
<BR><BR><TT>void process_string( char *string )</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* use assert to check argument */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; assert( string != NULL );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; assert( *string != '\0' );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* rest of code follows here */</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; process_string( &quot;hello&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; process_string( &quot;&quot; );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="atan"> atan </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>double atan( double x );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> atan</TT> function computes the principal value of the arctangent of<B> x</B>.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> atan</TT> function returns the arctangent in the range (-P/2,P/2).
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#acos">acos</A>, <A HREF="#asin">asin</A>, <A HREF="#atan2">atan2</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, atan(.5) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>0.463648</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD>Math
</DL>
<H2 ID="atan2"> atan2 </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>double atan2( double y, double x );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> atan2</TT> function computes the principal value of the arctangent of<B> y/x</B>, using the signs of both arguments
to determine the quadrant of the return value.&nbsp; A domain error occurs if both arguments are zero.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> atan2</TT> function returns the arctangent of<B> y/x</B>, in the range (-P,P).&nbsp; When the argument is outside
the permissible range, the <TT> matherr</TT> function is called.&nbsp; Unless the default <TT> matherr</TT> function is replaced,
it will set the global variable <TT> errno</TT> to <TT> EDOM</TT>, and print a &quot;DOMAIN error&quot; diagnostic message
using the <TT> stderr</TT> stream.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#acos">acos</A>, <A HREF="#asin">asin</A>, <A HREF="#atan">atan</A>, <A HREF="#matherr">matherr</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, atan2( .5, 1. ) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>0.463648</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD>Math
</DL>
<H2 ID="atanh"> atanh </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>double atanh( double x );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> atanh</TT> function computes the inverse hyperbolic tangent of<B> x</B>.&nbsp; A domain error occurs if the value
of<B> x</B> is outside the range (-1,1).
</DL>
<DL>
<DT>Returns:
<DD>The<TT> atanh</TT> function returns the inverse hyperbolic tangent value.&nbsp; When the argument is outside the permissible
range, the <TT> matherr</TT> function is called.&nbsp; Unless the default <TT> matherr</TT> function is replaced, it will
set the global variable <TT> errno</TT> to <TT> EDOM</TT>, and print a &quot;DOMAIN error&quot; diagnostic message using the
<TT> stderr</TT> stream.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#acosh">acosh</A>, <A HREF="#asinh">asinh</A>, <A HREF="#matherr">matherr</A>, <A HREF="#tanh">tanh</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, atanh( 0.5 ) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>0.549306</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>Math
</DL>
<H2 ID="atexit"> atexit </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>int atexit( void (*func)(void) );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> atexit</TT> function is passed the address of function<B> func</B> to be called when the program terminates normally.
&nbsp;Successive calls to atexit create a list of functions that will be executed on a &quot;last-in, first-out&quot; basis.
&nbsp;No more than 32 functions can be registered with the<TT> atexit</TT> function.
<BR><BR>The functions have no parameters and do not return values.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> atexit</TT> function returns zero if the registration succeeds, non-zero if it fails.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#abort">abort</A>, <A HREF="#_Exit">_Exit</A>, <A HREF="#_exit">_exit</A>, <A HREF="#exit">exit</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; extern void func1(void), func2(void), func3(void);</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; atexit( func1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; atexit( func2 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; atexit( func3 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Do this first.\n&quot; );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR><TT>void func1(void) { printf( &quot;last.\n&quot; ); }</TT>
<BR><BR><TT>void func2(void) { printf( &quot;this &quot; ); }</TT>
<BR><BR><TT>void func3(void) { printf( &quot;Do &quot; ); }</TT>
<BR><BR>produces the following:
<BR><BR><TT>Do this first.</TT>
<BR><TT>Do this last.</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="atof"> atof, _wtof </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>double atof( const char *ptr );</TT>
<BR><TT>double _wtof( const wchar_t *ptr );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> atof</TT> function converts the string pointed to by<B> ptr</B> to<TT> double</TT> representation.&nbsp; It is equivalent
to
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; strtod( ptr, (char **)NULL )</TT>
<BR><BR>The<TT> _wtof</TT> function is a wide-character version of<TT> atof</TT> that operates with wide-character strings.
&nbsp;It is equivalent to
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; wcstod( ptr, (wchar_t **)NULL )</TT>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> atof</TT> function returns the converted value.&nbsp; Zero is returned when the input string cannot be converted.
&nbsp;In this case, <TT> errno</TT> is not set.&nbsp; When an error has occurred, <TT> errno</TT> contains a value indicating
the type of error that has been detected.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#sscanf">sscanf</A>, <A HREF="#strtod">strtod</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; double x;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; x = atof( &quot;3.1415926&quot; );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>_wtof is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> atof - Math</TT>
<BR><BR><TT>_wtof - Math</TT>
</DL>
<H2 ID="atoi"> atoi, _wtoi </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>int atoi( const char *ptr );</TT>
<BR><TT>int _wtoi( const wchar_t *ptr );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> atoi</TT> function converts the string pointed to by<B> ptr</B> to<TT> int</TT> representation.
<BR><BR>The<TT> _wtoi</TT> function is a wide-character version of<TT> atoi</TT> that operates with wide-character strings.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> atoi</TT> function returns the converted value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#atol">atol</A>, <A HREF="#atoll">atoll</A>, <A HREF="#itoa">itoa</A>, <A HREF="#ltoa">ltoa</A>, <A HREF="#lltoa">lltoa</A>,
<A HREF="#sscanf">sscanf</A>, <A HREF="#strtol">strtol</A>, <A HREF="#strtoll">strtoll</A>, <A HREF="#strtoul">strtoul</A>,
<A HREF="#strtoull">strtoull</A>, <A HREF="#strtoimax">strtoimax</A>, <A HREF="#strtoumax">strtoumax</A>, <A HREF="#ultoa">ultoa</A>,
<A HREF="#ulltoa">ulltoa</A>, <A HREF="#utoa">utoa</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int x;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; x = atoi( &quot;-289&quot; );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>_wtoi is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> atoi - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_wtoi - All, Linux, RDOS</TT>
</DL>
<H2 ID="atol"> atol, _wtol </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>long int atol( const char *ptr );</TT>
<BR><TT>long int _wtol( const wchar_t *ptr );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> atol</TT> function converts the string pointed to by<B> ptr</B> to<TT> long int</TT> representation.
<BR><BR>The<TT> _wtol</TT> function is a wide-character version of<TT> atol</TT> that operates with wide-character strings.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> atol</TT> function returns the converted value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#atoi">atoi</A>, <A HREF="#atoll">atoll</A>, <A HREF="#itoa">itoa</A>, <A HREF="#ltoa">ltoa</A>, <A HREF="#lltoa">lltoa</A>,
<A HREF="#sscanf">sscanf</A>, <A HREF="#strtol">strtol</A>, <A HREF="#strtoll">strtoll</A>, <A HREF="#strtoul">strtoul</A>,
<A HREF="#strtoull">strtoull</A>, <A HREF="#strtoimax">strtoimax</A>, <A HREF="#strtoumax">strtoumax</A>, <A HREF="#ultoa">ultoa</A>,
<A HREF="#ulltoa">ulltoa</A>, <A HREF="#utoa">utoa</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; long int x;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; x = atol( &quot;-289&quot; );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>_wtol is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> atol - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_wtol - All, Linux, RDOS</TT>
</DL>
<H2 ID="atoll"> atoll, _wtoll </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>long long int atoll( const char *ptr );</TT>
<BR><TT>long long int _wtoll( const wchar_t *ptr );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> atoll</TT> function converts the string pointed to by<B> ptr</B> to<TT> long long int</TT> representation.
<BR><BR>The<TT> _wtoll</TT> function is a wide-character version of<TT> atoll</TT> that operates with wide-character strings.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> atoll</TT> function returns the converted value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#atoi">atoi</A>, <A HREF="#atol">atol</A>, <A HREF="#itoa">itoa</A>, <A HREF="#ltoa">ltoa</A>, <A HREF="#lltoa">lltoa</A>,
<A HREF="#sscanf">sscanf</A>, <A HREF="#strtol">strtol</A>, <A HREF="#strtoll">strtoll</A>, <A HREF="#strtoul">strtoul</A>,
<A HREF="#strtoull">strtoull</A>, <A HREF="#strtoimax">strtoimax</A>, <A HREF="#strtoumax">strtoumax</A>, <A HREF="#ultoa">ultoa</A>,
<A HREF="#ulltoa">ulltoa</A>, <A HREF="#utoa">utoa</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; long int x;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; x = atoll( &quot;-289356768201&quot; );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>_wtoll is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> atoll - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_wtoll - All, Linux, RDOS</TT>
</DL>
<H2 ID="_atouni"> _atouni </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>wchar_t *_atouni( wchar_t *wcs, const char *sbcs );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _atouni</TT> function converts the string pointed to by<B> sbcs</B> to a wide-character string and places it in the
buffer pointed to by<B> wcs</B>.
<BR><BR>The conversion ends at the first null character.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _atouni</TT> function returns the first argument as a result.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#atoi">atoi</A>, <A HREF="#atol">atol</A>, <A HREF="#itoa">itoa</A>, <A HREF="#ltoa">ltoa</A>, <A HREF="#strtod">strtod</A>,
<A HREF="#strtol">strtol</A>, <A HREF="#strtoul">strtoul</A>, <A HREF="#ultoa">ultoa</A>, <A HREF="#utoa">utoa</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; wchar_t wcs[12];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _atouni( wcs, &quot;Hello world&quot; );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="basename"> basename </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;libgen.h&gt;</TT>
<BR><TT>char *basename( char *path );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> basename</TT> function returns a pointer to the final component of a pathname pointed to by the<B> path</B> argument,
deleting trailing path separators.
<BR><BR>If the string pointed to by<B> path</B> consists entirely of path separators, a string consisting of single path separator
is returned.
<BR><BR>If<B> path</B> is a null pointer or points to an empty string, a pointer to the string &quot;.&quot; is returned.
<BR><BR>The<TT> basename</TT> function may modify the string pointed to by<B> path</B> and may return a pointer to static
storage that may be overwritten by a subsequent call to<TT> basename</TT>
<BR><BR>The<TT> basename</TT> function is not re-entrant or thread-safe.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> basename</TT> function returns a pointer to the final component of<B> path</B>.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#dirname">dirname</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;libgen.h&gt;</TT>
<BR><BR><TT>int main( void )</TT>
<BR><TT>{</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; puts( basename( &quot;/usr/lib&quot; ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; puts( basename( &quot;//usr//lib//&quot; ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; puts( basename( &quot;///&quot; ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; puts( basename( &quot;foo&quot; ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; puts( basename( NULL ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; return( 0 );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>lib</TT>
<BR><TT>lib</TT>
<BR><TT>/</TT>
<BR><TT>foo</TT>
<BR><TT>.</TT>
</DL>
<DL>
<DT>Classification:
<DD>POSIX
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="bdos"> bdos </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><TT>int bdos( int dos_func, unsigned dx, unsigned char al );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> bdos</TT> function causes the computer's central processor (CPU) to be interrupted with an interrupt number hexadecimal
21 (<TT>0x21</TT>), which is a request to invoke a specific DOS function.&nbsp; Before the interrupt, the DX register is loaded
from<B> dx</B>, the AH register is loaded with the DOS function number from<B> dos_func</B> and the AL register is loaded
from<B> al</B>.&nbsp; The remaining registers are passed unchanged to DOS.
<BR><BR>You should consult the technical documentation for the DOS operating system you are using to determine the expected
register contents before and after the interrupt in question.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> bdos</TT> function returns the value of the AX register after the interrupt has completed.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#int386">int386</A>, <A HREF="#int386x">int386x</A>, <A HREF="#int86">int86</A>, <A HREF="#int86x">int86x</A>, <A HREF="#intdos">intdos</A>,
<A HREF="#intdosx">intdosx</A>, <A HREF="#intr">intr</A>, <A HREF="#intrf">intrf</A>, <A HREF="#segread">segread</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><BR><TT>#define DISPLAY_OUTPUT&nbsp; 2</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int rc;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; rc = bdos( DISPLAY_OUTPUT, 'B', 0 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; rc = bdos( DISPLAY_OUTPUT, 'D', 0 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; rc = bdos( DISPLAY_OUTPUT, 'O', 0 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; rc = bdos( DISPLAY_OUTPUT, 'S', 0 );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>DOS
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, DOS/PM
</DL>
<H2 ID="_beginthread"> _beginthread, _beginthreadex </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;process.h&gt;</TT>
<BR><TT>#if defined(__386__)</TT>
<BR><TT>#&nbsp;&nbsp; define FAR</TT>
<BR><TT>#else</TT>
<BR><TT>#&nbsp;&nbsp; define FAR __far</TT>
<BR><TT>#endif</TT>
<BR><BR><TT>#if defined(__NT__)</TT>
<BR><TT>unsigned long _beginthread(</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void (*start_address)(void *),</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned stack_size,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void&nbsp;&nbsp;&nbsp;&nbsp; *arglist);</TT>
<BR><TT>unsigned long _beginthreadex(</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void *security,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned stack_size,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned (__stdcall *start_address)(void *),</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void *arglist,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned initflag,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned *thrdid );</TT>
<BR><TT>#else</TT>
<BR><TT>int FAR _beginthread(</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void (FAR *start_address)(void FAR *),</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void FAR *stack_bottom,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned stack_size,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void FAR *arglist );</TT>
<BR><TT>#endif</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _beginthread</TT> function is used to start a new thread of execution at the function identified by<B> start_address</B>
with a single parameter identified by<B> arglist</B>.
<BR><BR>For each operating environment under which<TT> _beginthread</TT> is supported, the<TT> _beginthread</TT> function
uses the appropriate system call to begin a new thread of execution.
<BR><BR>The new thread will use the memory identified by<B> stack_bottom</B> and<B> stack_size</B> for its stack.
<BR><BR><B>Note for 16-bit applications:</B>&nbsp; If the stack is not in DGROUP (i.e., the stack pointer does not point to
an area in DGROUP) then you must compile your application with the &quot;zu&quot; option.&nbsp; For example, the pointer returned
by <TT> malloc</TT> in a large data model may not be in DGROUP.&nbsp; The &quot;zu&quot; option relaxes the restriction that
the SS register contains the base address of the default data segment, &quot;DGROUP&quot;.&nbsp; Normally, all data items
are placed into the group DGROUP and the SS register contains the base address of this group.&nbsp; In a thread, the SS register
will likely not contain the base address of this group.&nbsp; When the &quot;zu&quot; option is selected, the SS register
is volatile (assumed to point to another segment) and any global data references require loading a segment register such as
DS with the base address of DGROUP.
<BR><BR><B>Note for OS/2 32-bit applications:</B>&nbsp; Memory for a stack need not be provided by the application.&nbsp;
The<B> stack_bottom</B> may be NULL in which case the run-time system will provide a stack.&nbsp; You must specify a non-zero<B>
stack_size</B> for this stack.
<BR><BR><B>Note for Win32 applications:</B>&nbsp; Memory for a stack is provided by the run-time system.&nbsp; The size of
the stack is determined by<B> stack_size</B> and must not be zero.
<BR><BR>The <TT> _beginthreadex</TT> function can be used to create a new thread, in a running or suspended state specified
by<B> initflag</B>, with security attributes specified by<B> security</B>.
<BR><BR>The initial state of the new thread (running or suspended) is specified by the<B> initflag</B> argument.&nbsp; If
the <TT> CREATE_SUSPENDED</TT> flag (WINBASE.H) is specified, the thread is created in a suspended state, and will not run
until the Win32 <TT> ResumeThread</TT> function is called with the thread handle as an argument.&nbsp; If this value is zero,
the thread runs immediately after creation.
<BR><BR>The security descriptor for the new thread is specified by the<B> security</B> argument.&nbsp; This is a pointer to
a Win32 <TT> SECURITY_ATTRIBUTES</TT> structure (see Microsoft's<B> Win32 Programmer's Reference</B> for more information).
&nbsp;For default behaviour, the security structure pointer can be <TT> NULL</TT>.
<BR><BR>The thread identifier is returned in the location identified by the<B> thrdid</B> argument.
<BR><BR>The thread ends when it exits from its main function or calls <TT> exit</TT>, <TT> _Exit</TT>, <TT> _exit</TT>, <TT>
_endthread</TT> or <TT> _endthreadex</TT>.
<BR><BR>The variable/function <TT> _threadid</TT> which is defined in<TT> &lt;stddef.h&gt;</TT> may be used by the executing
thread to obtain its thread ID.&nbsp; In the 16-bit libraries, <TT> _threadid</TT> is a far pointer to an int.&nbsp; In the
32-bit libraries, it is a function that returns an int.
<BR><BR>There is no limit to the number of threads an application can create under Win32 platforms.
<BR><BR>There is a limit to the number of threads an application can create under 16-bit OS/2 and 32-bit NetWare.&nbsp; The
default limit is 32.&nbsp; This limit can be adjusted by statically initializing the unsigned global variable<TT> __MaxThreads.</TT>
<BR><BR>Under 32-bit OS/2, there is no limit to the number of threads an application can create.&nbsp; However, due to the
way in which multiple threads are supported in the Open Watcom libraries, there is a small performance penalty once the number
of threads exceeds the default limit of 32 (this number includes the initial thread).&nbsp; If you are creating more than
32 threads and wish to avoid this performance penalty, you can redefine the threshold value of 32.&nbsp; You can statically
initialize the global variable<TT> __MaxThreads.</TT>
<BR><BR>By adding the following line to your multi-threaded application, the new threshold value will be set to 48.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned __MaxThreads = { 48 };</TT>
</DL>
<DL>
<DT>Returns:
<DD>Under Win32, the<TT> _beginthread</TT> function returns the thread handle for the new thread if successful; otherwise it returns
-1 to indicate that the thread could not be started.
<BR><BR>Under all other systems that support the<TT> _beginthread</TT> function (OS/2, Netware and QNX), it returns the thread
ID for the new thread if successful; otherwise it returns -1 to indicate that the thread could not be started.
<BR><BR>The <TT> _beginthreadex</TT> function returns the thread handle for the new thread if successful; otherwise it returns
0 to indicate that the thread could not be started.
<BR><BR>When the thread could not be started, the value of <TT> errno</TT> could be set to <TT> EAGAIN</TT> if there are too
many threads, or to <TT> EINVAL</TT> if the argument is invalid or the stack size is incorrect, or to <TT> ENOMEM</TT> if
there is not enough available memory.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_endthread">_endthread</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>#include &lt;stddef.h&gt;</TT>
<BR><TT>#include &lt;malloc.h&gt;</TT>
<BR><TT>#include &lt;process.h&gt;</TT>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><BR><TT>#if defined(__386__)</TT>
<BR><TT>&nbsp; #define FAR</TT>
<BR><TT>&nbsp; #define STACK_SIZE&nbsp;&nbsp;&nbsp; 8192</TT>
<BR><TT>#else</TT>
<BR><TT>&nbsp; #define FAR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __far</TT>
<BR><TT>&nbsp; #define STACK_SIZE&nbsp;&nbsp;&nbsp; 4096</TT>
<BR><TT>#endif</TT>
<BR><BR><TT>static volatile int&nbsp;&nbsp;&nbsp;&nbsp; WaitForThread;</TT>
<BR><BR><TT>void FAR child( void FAR *parm )</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char * FAR *argv = (char * FAR *) parm;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp; i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Child thread ID = %x\n&quot;, *_threadid );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; argv[i]; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;argv[%d] = %s\n&quot;, i, argv[i] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; WaitForThread = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _endthread();</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *args[3];</TT>
<BR><TT>#if defined(__NT__)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned long&nbsp;&nbsp; tid;</TT>
<BR><TT>#else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *stack;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tid;</TT>
<BR><TT>#endif</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; args[0] = &quot;child&quot;;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; args[1] = &quot;parm&quot;;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; args[2] = NULL;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; WaitForThread = 1;</TT>
<BR><TT>#if defined(__NT__)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; tid = _beginthread( child, STACK_SIZE, args );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Thread handle = %lx\n&quot;, tid );</TT>
<BR><TT>#else</TT>
<BR><TT>&nbsp; #if defined(__386__)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; stack = (char *) malloc( STACK_SIZE );</TT>
<BR><TT>&nbsp; #else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; stack = (char *) _nmalloc( STACK_SIZE );</TT>
<BR><TT>&nbsp; #endif</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; tid = _beginthread( child, stack, STACK_SIZE, args );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Thread ID = %x\n&quot;, tid );</TT>
<BR><TT>#endif</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; while( WaitForThread ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sleep( 0 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> _beginthread - Win32, OS/2 1.x(MT), OS/2 1.x(DL), OS/2-32, Linux, RDOS, Netware</TT>
<BR><BR><TT>_beginthreadex - Win32</TT>
</DL>
<H2 ID="bessel"> bessel Functions </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>double j0( double x );</TT>
<BR><TT>double j1( double x );</TT>
<BR><TT>double jn( int n, double x );</TT>
<BR><TT>double y0( double x );</TT>
<BR><TT>double y1( double x );</TT>
<BR><TT>double yn( int n, double x );</TT>
</DL>
<DL>
<DT>Description:
<DD>Functions <TT> j0</TT>, <TT> j1</TT>, and <TT> jn</TT> return Bessel functions of the first kind.
<BR><BR>Functions <TT> y0</TT>, <TT> y1</TT>, and <TT> yn</TT> return Bessel functions of the second kind.&nbsp; The argument<B>
x</B> must be positive.&nbsp; If<B> x</B> is negative, <TT> _matherr</TT> will be called to print a DOMAIN error message to
<TT> stderr</TT>, set <TT> errno</TT> to <TT> EDOM</TT>, and return the value<TT> -HUGE_VAL.</TT>&nbsp; This error handling
can be modified by using the <TT> matherr</TT> routine.
</DL>
<DL>
<DT>Returns:
<DD>These functions return the result of the desired Bessel function of<B> x</B>.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#matherr">matherr</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; double x, y, z;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; x = j0( 2.4 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; y = y1( 1.58 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; z = jn( 3, 2.4 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;j0(2.4) = %f, y1(1.58) = %f\n&quot;, x, y );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;jn(3,2.4) = %f\n&quot;, z );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> j0 - Math</TT>
<BR><BR><TT>j1 - Math</TT>
<BR><TT>jn - Math</TT>
<BR><TT>y0 - Math</TT>
<BR><TT>y1 - Math</TT>
<BR><TT>yn - Math</TT>
</DL>
<H2 ID="bcmp"> bcmp </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>int bcmp(const void *s1, const void *s2, size_t n);</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> bcmp</TT> function compares the byte string pointed to by<B> s1</B> to the string pointed to by<B> s2</B>.&nbsp; The
number of bytes to compare is specified by<B> n</B>.&nbsp; Null characters may be included in the comparision.
<BR><BR>Note that this function is similar to the ISO C <TT> memcmp</TT> function but just tests for equality (new code should
use the ISO C function).
</DL>
<DL>
<DT>Returns:
<DD>The<TT> bcmp</TT> function returns zero if the byte strings are identical; otherwise it returns 1.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#bcopy">bcopy</A>, <A HREF="#bzero">bzero</A>, <A HREF="#memcmp">memcmp</A>, <A HREF="#strcmp">strcmp</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( bcmp( &quot;Hello there&quot;, &quot;Hello world&quot;, 6 ) ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Not equal\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Equal\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>Equal</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="bcopy"> bcopy </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>void bcopy( const void *src, void *dst, size_t n );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> bcopy</TT> function copies the byte string pointed to by<B> src</B> (including any null characters) into the array
pointed to by<B> dst</B>.&nbsp; The number of bytes to copy is specified by<B> n</B>.&nbsp; Copying of overlapping objects
is guaranteed to work properly.
<BR><BR>Note that this function is similar to the ISO C <TT> memmove</TT> function but the order of arguments is different
(new code should use the ISO C function).
</DL>
<DL>
<DT>Returns:
<DD>The<TT> bcopy</TT> function has no return value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#bcmp">bcmp</A>, <A HREF="#bzero">bzero</A>, <A HREF="#memmove">memmove</A>, <A HREF="#strcpy">strcpy</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; auto char buffer[80];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; bcopy( &quot;Hello &quot;, buffer,&nbsp;&nbsp;&nbsp;&nbsp; 6 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; bcopy( &quot;world&quot;,&nbsp; &amp;buffer[6], 6 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, buffer );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>Hello world</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="_bfreeseg"> _bfreeseg </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;malloc.h&gt;</TT>
<BR><TT>int _bfreeseg( __segment seg );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _bfreeseg</TT> function frees a based-heap segment.
<BR><BR>The argument<B> seg</B> indicates the segment returned by an earlier call to <TT> _bheapseg</TT>.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _bfreeseg</TT> function returns 0 if successful and -1 if an error occurred.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_bheapseg">_bheapseg</A>, <A HREF="#calloc">calloc</A>, <A HREF="#_expand">_expand</A>, <A HREF="#free">free</A>,
<A HREF="#malloc">malloc</A>, <A HREF="#realloc">realloc</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>#include &lt;malloc.h&gt;</TT>
<BR><BR><TT>struct list {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct list __based(__self) *next;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value;</TT>
<BR><TT>};</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; __segment&nbsp;&nbsp; seg;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct list __based(seg) *head;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct list __based(seg) *p;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; /* allocate based heap */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; seg = _bheapseg( 1024 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( seg == _NULLSEG ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Unable to allocate based heap\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit( 1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; /* create a linked list in the based heap */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; head = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 1; i &lt; 10; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p = _bmalloc( seg, sizeof( struct list ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( p == _NULLOFF ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;_bmalloc failed\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p-&gt;next = head;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p-&gt;value = i;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; head = p;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; /* traverse the linked list, printing out values */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( p = head; p != 0; p = p-&gt;next ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Value = %d\n&quot;, p-&gt;value );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; /* free all the elements of the linked list */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( ; p = head; ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; head = p-&gt;next;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _bfree( seg, p );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* free the based heap */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _bfreeseg( seg );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>DOS/16, Windows, OS/2 1.x(all)
</DL>
<H2 ID="_bgetcmd"> _bgetcmd </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;process.h&gt;</TT>
<BR><TT>int _bgetcmd( char *cmd_line, int len );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _bgetcmd</TT> function causes the command line information, with the program name removed, to be copied to<B> cmd_line</B>.
&nbsp;The argument<B> len</B> specifies the size of<B> cmd_line</B>.&nbsp; The information is terminated with a null character.
&nbsp;This provides a method of obtaining the original parameters to a program unchanged (with the white space intact).
<BR><BR>This information can also be obtained by examining the vector of program parameters passed to the main function in
the program.
</DL>
<DL>
<DT>Returns:
<DD>The number of bytes required to store the entire command line, excluding the terminating null character, is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#abort">abort</A>, <A HREF="#atexit">atexit</A>, <A HREF="#exec___">exec...</A>, <A HREF="#exit">exit</A>, <A HREF="#_Exit">_Exit</A>,
<A HREF="#_exit">_exit</A>, <A HREF="#getcmd">getcmd</A>, <A HREF="#getenv">getenv</A>, <A HREF="#main">main</A>, <A HREF="#onexit">onexit</A>,
<A HREF="#putenv">putenv</A>, <A HREF="#spawn___">spawn...</A>, <A HREF="#system">system</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR>Suppose a program were invoked with the command line
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; myprog arg-1 ( my&nbsp;&nbsp; stuff ) here</TT>
<BR><BR>where that program contains
<BR><BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>#include &lt;process.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp; *cmdline;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; cmdlen;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; cmdlen = _bgetcmd( NULL, 0 ) + 1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; cmdline = malloc( cmdlen );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( cmdline != NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmdlen = _bgetcmd( cmdline, cmdlen );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, cmdline );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>&nbsp; arg-1 ( my&nbsp;&nbsp; stuff ) here</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="_bheapseg"> _bheapseg </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;malloc.h&gt;</TT>
<BR><TT>__segment _bheapseg( size_t size );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _bheapseg</TT> function allocates a based-heap segment of at least<B> size</B> bytes.
<BR><BR>The argument<B> size</B> indicates the initial size for the heap.&nbsp; The heap will automatically be enlarged as
needed if there is not enough space available within the heap to satisfy an allocation request by <TT> _bcalloc</TT>, <TT>
_bexpand</TT>, <TT> _bmalloc</TT>, or <TT> _brealloc</TT>.
<BR><BR>The value returned by<TT> _bheapseg</TT> is the segment value or selector for the based heap.&nbsp; This value must
be saved and used as an argument to other based heap functions to indicate which based heap to operate upon.
<BR><BR>Each call to<TT> _bheapseg</TT> allocates a new based heap.
</DL>
<DL>
<DT>Returns:
<DD>The value returned by<TT> _bheapseg</TT> is the segment value or selector for the based heap.&nbsp; This value must be saved
and used as an argument to other based heap functions to indicate which based heap to operate upon.&nbsp; A special value
of <TT> _NULLSEG</TT> is returned if the segment could not be allocated.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_bfreeseg">_bfreeseg</A>, <A HREF="#calloc">calloc</A>, <A HREF="#_expand">_expand</A>, <A HREF="#malloc">malloc</A>,
<A HREF="#realloc">realloc</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>#include &lt;malloc.h&gt;</TT>
<BR><BR><TT>struct list {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct list __based(__self) *next;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value;</TT>
<BR><TT>};</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; __segment&nbsp;&nbsp; seg;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct list __based(seg) *head;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct list __based(seg) *p;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; /* allocate based heap */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; seg = _bheapseg( 1024 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( seg == _NULLSEG ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Unable to allocate based heap\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit( 1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; /* create a linked list in the based heap */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; head = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 1; i &lt; 10; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p = _bmalloc( seg, sizeof( struct list ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( p == _NULLOFF ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;_bmalloc failed\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p-&gt;next = head;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p-&gt;value = i;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; head = p;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; /* traverse the linked list, printing out values */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( p = head; p != 0; p = p-&gt;next ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Value = %d\n&quot;, p-&gt;value );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; /* free all the elements of the linked list */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( ; p = head; ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; head = p-&gt;next;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _bfree( seg, p );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* free the based heap */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _bfreeseg( seg );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>DOS/16, Windows, OS/2 1.x(all)
</DL>
<H2 ID="_bios_disk"> _bios_disk </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;bios.h&gt;</TT>
<BR><TT>unsigned short _bios_disk( unsigned service,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct diskinfo_t *diskinfo );</TT>
<BR><TT>struct&nbsp; diskinfo_t {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* disk parameters&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned drive;&nbsp;&nbsp;&nbsp;&nbsp; /* drive number&nbsp;&nbsp;&nbsp;
&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned head;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* head number&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned track;&nbsp;&nbsp;&nbsp;&nbsp; /* track number&nbsp;&nbsp;&nbsp;
&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned sector;&nbsp;&nbsp;&nbsp; /* sector number&nbsp;&nbsp;&nbsp;&nbsp;
*/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned nsectors;&nbsp; /* number of sectors */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void __far *buffer; /* buffer address&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>};</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _bios_disk</TT> function uses INT 0x13 to provide access to the BIOS disk functions.&nbsp; Information for the desired<B>
service</B> is passed the <TT> diskinfo_t</TT> structure pointed to by<B> diskinfo</B>.&nbsp; The value for<B> service</B>
can be one of the following values:
<DL>
<DT>Value&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>_DISK_RESET
<DD>Forces the disk controller to do a reset on the disk.&nbsp; This request does not use the<B> diskinfo</B> argument.
<DT>_DISK_STATUS
<DD>Obtains the status of the last disk operation.
<DT>_DISK_READ
<DD>Reads the specified number of sectors from the disk.&nbsp; This request uses all of the information passed in the<B> diskinfo</B>
structure.
<DT>_DISK_WRITE
<DD>Writes the specified amount of data to the disk.&nbsp; This request uses all of the information passed in the<B> diskinfo</B>
structure.
<DT>_DISK_VERIFY
<DD>Checks the disk to be sure the specified sectors exist and can be read.&nbsp; A CRC (cyclic redundancy check) test is performed.
&nbsp;This request uses all of the information passed in the<B> diskinfo</B> structure except for the<B> buffer</B> field.
<DT>_DISK_FORMAT
<DD>Formats the specified track on the disk.&nbsp; The<B> head</B> and<B> track</B> fields indicate the track to be formatted.
&nbsp;Only one track can be formatted per call.&nbsp; The<B> buffer</B> field points to a set of sector markers, whose format
depends on the type of disk drive.&nbsp; This service has no return value.
</DL>
<BR>This function is not supported by DOS/4GW (you must use the Simulate Real-Mode Interrupt DPMI call).
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _bios_disk</TT> function returns status information in the high-order byte when<B> service</B> is _DISK_STATUS, _DISK_READ,
_DISK_WRITE, or _DISK_VERIFY.&nbsp; The possible values are:
<DL>
<DT>Value&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>0x00
<DD>Operation successful
<DT>0x01
<DD>Bad command
<DT>0x02
<DD>Address mark not found
<DT>0x03
<DD>Attempt to write to write-protected disk
<DT>0x04
<DD>Sector not found
<DT>0x05
<DD>Reset failed
<DT>0x06
<DD>Disk changed since last operation
<DT>0x07
<DD>Drive parameter activity failed
<DT>0x08
<DD>DMA overrun
<DT>0x09
<DD>Attempt to DMA across 64K boundary
<DT>0x0A
<DD>Bad sector detected
<DT>0x0B
<DD>Bad track detected
<DT>0x0C
<DD>Unsupported track
<DT>0x10
<DD>Data read (CRC/ECC) error
<DT>0x11
<DD>CRC/ECC corrected data error
<DT>0x20
<DD>Controller failure
<DT>0x40
<DD>Seek operation failed
<DT>0x80
<DD>Disk timed out or failed to respond
<DT>0xAA
<DD>Drive not ready
<DT>0xBB
<DD>Undefined error occurred
<DT>0xCC
<DD>Write fault occurred
<DT>0xE0
<DD>Status error
<DT>0xFF
<DD>Sense operation failed
</DL>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;bios.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct diskinfo_t di;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned short status;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; di.drive = di.head = di.track = di.sector = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; di.nsectors = 1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; di.buffer = NULL;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; status = _bios_disk( _DISK_VERIFY, &amp;di );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Status = 0x%4.4X\n&quot;, status );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>BIOS
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386
</DL>
<H2 ID="_bios_equiplist"> _bios_equiplist </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;bios.h&gt;</TT>
<BR><TT>unsigned short _bios_equiplist( void );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _bios_equiplist</TT> function uses INT 0x11 to determine what hardware and peripherals are installed on the machine.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _bios_equiplist</TT> function returns a set of bits indicating what is currently installed on the machine.&nbsp; Those
bits are defined as follows:
<DL>
<DT>Bit&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>bit 0
<DD>Set to 1 if system boots from disk
<DT>bit 1
<DD>Set to 1 if a math coprocessor is installed
<DT>bits 2-3
<DD>Indicates motherboard RAM size
<DT>bits 4-5
<DD>Initial video mode
<DT>bits 6-7
<DD>Number of diskette drives
<DT>bit 8
<DD>Set to 1 if machine does not have DMA
<DT>bits 9-11
<DD>Number of serial ports
<DT>bit 12
<DD>Set to 1 if a game port is attached
<DT>bit 13
<DD>Set to 1 if a serial printer is attached
<DT>bits 14-15
<DD>Number of parallel printers installed
</DL>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;bios.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned short equipment;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; equipment = _bios_equiplist();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Equipment flags = 0x%4.4X\n&quot;, equipment );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>BIOS
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386
</DL>
<H2 ID="_bios_keybrd"> _bios_keybrd </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;bios.h&gt;</TT>
<BR><TT>unsigned short _bios_keybrd( unsigned service );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _bios_keybrd</TT> function uses INT 0x16 to access the BIOS keyboard services.&nbsp; The possible values for<B> service</B>
are the following constants:
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>_KEYBRD_READ
<DD>Reads the next character from the keyboard.&nbsp; The function will wait until a character has been typed.
<DT>_KEYBRD_READY
<DD>Checks to see if a character has been typed.&nbsp; If there is one, then its value will be returned, but it is not removed
from the input buffer.
<DT>_KEYBRD_SHIFTSTATUS
<DD>Returns the current state of special keys.
<DT>_NKEYBRD_READ
<DD>Reads the next character from an enhanced keyboard.&nbsp; The function will wait until a character has been typed.
<DT>_NKEYBRD_READY
<DD>Checks to see if a character has been typed on an enhanced keyboard.&nbsp; If there is one, then its value will be returned,
but it is not removed from the input buffer.
<DT>_NKEYBRD_SHIFTSTATUS
<DD>Returns the current state of special keys on an enhanced keyboard.
</DL>
</DL>
<DL>
<DT>Returns:
<DD>The return value depends on the<B> service</B> requested.
<BR><BR>The <TT> _KEYBRD_READ</TT> and <TT> _NKEYBRD_READ</TT> services return the character's ASCII value in the low-order
byte and the character's keyboard scan code in the high-order byte.
<BR><BR>The <TT> _KEYBRD_READY</TT> and <TT> _NKEYBRD_READY</TT> services return zero if there was no character available,
otherwise it returns the same value returned by <TT> _KEYBRD_READ</TT> and <TT> _NKEYBRD_READ</TT>.
<BR><BR>The shift status is returned in the low-order byte with one bit for each special key defined as follows:
<DL>
<DT>Bit&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>bit 0 (0x01)
<DD>Right SHIFT key is pressed
<DT>bit 1 (0x02)
<DD>Left SHIFT key is pressed
<DT>bit 2 (0x04)
<DD>CTRL key is pressed
<DT>bit 3 (0x08)
<DD>ALT key is pressed
<DT>bit 4 (0x10)
<DD>SCROLL LOCK is on
<DT>bit 5 (0x20)
<DD>NUM LOCK is on
<DT>bit 6 (0x40)
<DD>CAPS LOCK is on
<DT>bit 7 (0x80)
<DD>Insert mode is set
</DL>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;bios.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned short key_state;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; key_state = _bios_keybrd( _KEYBRD_SHIFTSTATUS );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( key_state &amp; 0x10 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;SCROLL LOCK is on\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( key_state &amp; 0x20 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;NUM LOCK is on\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( key_state &amp; 0x40 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;CAPS LOCK is on\n&quot; );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>NUM LOCK is on</TT>
</DL>
<DL>
<DT>Classification:
<DD>BIOS
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386
</DL>
<H2 ID="_bios_memsize"> _bios_memsize </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;bios.h&gt;</TT>
<BR><TT>unsigned short _bios_memsize( void );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _bios_memsize</TT> function uses INT 0x12 to determine the total amount of memory available.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _bios_memsize</TT> function returns the total amount of 1K blocks of memory installed (maximum 640).
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;bios.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned short memsize;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; memsize = _bios_memsize();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;The total amount of memory is: %dK\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memsize );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>The total amount of memory is: 640K</TT>
</DL>
<DL>
<DT>Classification:
<DD>BIOS
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386
</DL>
<H2 ID="_bios_printer"> _bios_printer </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;bios.h&gt;</TT>
<BR><TT>unsigned short _bios_printer( unsigned service,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned port,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned data );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _bios_printer</TT> function uses INT 0x17 to perform printer output services to the printer specified by<B> port</B>.
&nbsp;The values for service are:
<DL>
<DT>Value&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>_PRINTER_WRITE
<DD>Sends the low-order byte of<B> data</B> to the printer specified by<B> port</B>.
<DT>_PRINTER_INIT
<DD>Initializes the printer specified by<B> port</B>.
<DT>_PRINTER_STATUS
<DD>Get the status of the printer specified by<B> port</B>.
</DL>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _bios_printer</TT> function returns a printer status byte defined as follows:
<DL>
<DT>Bit&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>bit 0 (0x01)
<DD>Printer timed out
<DT>bits 1-2
<DD>Unused
<DT>bit 3 (0x08)
<DD>I/O error
<DT>bit 4 (0x10)
<DD>Printer selected
<DT>bit 5 (0x20)
<DD>Out of paper
<DT>bit 6 (0x40)
<DD>Printer acknowledge
<DT>bit 7 (0x80)
<DD>Printer not busy
</DL>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;bios.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned short status;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; status = _bios_printer( _PRINTER_STATUS, 1, 0 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Printer status: 0x%2.2X\n&quot;, status );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>BIOS
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386
</DL>
<H2 ID="_bios_serialcom"> _bios_serialcom </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;bios.h&gt;</TT>
<BR><TT>unsigned short _bios_serialcom( unsigned service,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned serial_port,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned data );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _bios_serialcom</TT> function uses INT 0x14 to provide serial communications services to the serial port specified
by<B> serial_port</B>.&nbsp; 0 represents COM1, 1 represents COM2, etc.&nbsp; The values for service are:
<DL>
<DT>Value&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>_COM_INIT
<DD>Initializes the serial port to the parameters specified in<B> data</B>.
<DT>_COM_SEND
<DD>Transmits the low-order byte of<B> data</B> to the serial port.
<DT>_COM_RECEIVE
<DD>Reads an input character from the serial port.
<DT>_COM_STATUS
<DD>Returns the current status of the serial port.
</DL>
<BR>The value passed in<B> data</B> for the <TT> _COM_INIT</TT> service can be built using the appropriate combination of
the following values:
<DL>
<DT>Value&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>_COM_110
<DD>110 baud
<DT>_COM_150
<DD>150 baud
<DT>_COM_300
<DD>300 baud
<DT>_COM_600
<DD>600 baud
<DT>_COM_1200
<DD>1200 baud
<DT>_COM_2400
<DD>2400 baud
<DT>_COM_4800
<DD>4800 baud
<DT>_COM_9600
<DD>9600 baud
<DT>_COM_NOPARITY
<DD>No parity
<DT>_COM_EVENPARITY
<DD>Even parity
<DT>_COM_ODDPARITY
<DD>Odd parity
<DT>_COM_CHR7
<DD>7 data bits
<DT>_COM_CHR8
<DD>8 data bits
<DT>_COM_STOP1
<DD>1 stop bit
<DT>_COM_STOP2
<DD>2 stop bits
</DL>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _bios_serialcom</TT> function returns a 16-bit value with the high-order byte containing status information defined
as follows:
<DL>
<DT>Bit&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>bit 15 (0x8000)
<DD>Timed out
<DT>bit 14 (0x4000)
<DD>Transmit shift register empty
<DT>bit 13 (0x2000)
<DD>Transmit holding register empty
<DT>bit 12 (0x1000)
<DD>Break detected
<DT>bit 11 (0x0800)
<DD>Framing error
<DT>bit 10 (0x0400)
<DD>Parity error
<DT>bit 9 (0x0200)
<DD>Overrun error
<DT>bit 8 (0x0100)
<DD>Data ready
</DL>
<BR>The low-order byte of the return value depends on the value of the<B> service</B> argument.
<BR><BR>When<B> service</B> is _COM_SEND, bit 15 will be set if the<B> data</B> could not be sent.&nbsp; If bit 15 is clear,
the return value equals the byte sent.
<BR><BR>When<B> service</B> is _COM_RECEIVE, the byte read will be returned in the low-order byte if there was no error.&nbsp;
If there was an error, at least one of the high-order status bits will be set.
<BR><BR>When<B> service</B> is _COM_INIT or _COM_STATUS the low-order bits are defined as follows:
<DL>
<DT>Bit&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>bit 0 (0x01)
<DD>Clear to send (CTS) changed
<DT>bit 1 (0x02)
<DD>Data set ready changed
<DT>bit 2 (0x04)
<DD>Trailing-edge ring detector
<DT>bit 3 (0x08)
<DD>Receive line signal detector changed
<DT>bit 4 (0x10)
<DD>Clear to send
<DT>bit 5 (0x20)
<DD>Data-set ready
<DT>bit 6 (0x40)
<DD>Ring indicator
<DT>bit 7 (0x80)
<DD>Receive-line signal detected
</DL>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;bios.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned short status;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; status = _bios_serialcom( _COM_STATUS, 1, 0 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Serial status: 0x%2.2X\n&quot;, status );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>BIOS
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386
</DL>
<H2 ID="_bios_timeofday"> _bios_timeofday </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;bios.h&gt;</TT>
<BR><TT>int _bios_timeofday( int service, long *timeval );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _bios_timeofday</TT> function uses INT 0x1A to get or set the current system clock value.&nbsp; The values for service
are:
<DL>
<DT>Value&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>_TIME_GETCLOCK
<DD>Places the current system clock value in the location pointed to by<B> timeval</B>.&nbsp; The function returns zero if midnight
has not passed since the last time the system clock was read or set; otherwise, it returns 1.
<DT>_TIME_SETCLOCK
<DD>Sets the system clock to the value in the location pointed to by<B> timeval</B>.
</DL>
</DL>
<DL>
<DT>Returns:
<DD>A value of -1 is returned if neither _TIME_GETCLOCK nor _TIME_SETCLOCK were specified; otherwise 0 is returned.
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;bios.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; long time_of_day;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _bios_timeofday( _TIME_GETCLOCK, &amp;time_of_day );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Ticks since midnight: %lu\n&quot;, time_of_day );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>Ticks since midnight: 762717</TT>
</DL>
<DL>
<DT>Classification:
<DD>BIOS
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386
</DL>
<H2 ID="_bprintf"> _bprintf, _bwprintf </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>int _bprintf( char *buf, size_t bufsize,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *format, ... );</TT>
<BR><TT>int _bwprintf( wchar_t *buf, size_t bufsize,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t *format, ... );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _bprintf</TT> function is equivalent to the <TT> sprintf</TT> function, except that the argument<B> bufsize</B> specifies
the size of the character array<B> buf</B> into which the generated output is placed.&nbsp; A null character is placed at
the end of the generated character string.&nbsp; The<B> format</B> string is described under the description of the <TT> printf</TT>
function.
<BR><BR>The<TT> _bwprintf</TT> function is a wide-character version of<TT> _bprintf</TT>.&nbsp; It accepts a wide-character
string argument for<B> format</B> and produces wide character output.&nbsp; The argument<B> buf</B> specifies an array of
wide characters into which the generated output is to be written, rather than converted to multibyte characters and written
to a stream.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _bprintf</TT> function returns the number of characters written into the array, not counting the terminating null
character.&nbsp; The<TT> _bwprintf</TT> function returns the number of wide characters written into the array, not counting
the terminating null character.&nbsp; An error can occur while converting a value for output.&nbsp; When an error has occurred,
<TT> errno</TT> contains a value indicating the type of error that has been detected.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#cprintf">cprintf</A>, <A HREF="#fprintf">fprintf</A>, <A HREF="#printf">printf</A>, <A HREF="#sprintf">sprintf</A>,
<A HREF="#_vbprintf">_vbprintf</A>, <A HREF="#vcprintf">vcprintf</A>, <A HREF="#vfprintf">vfprintf</A>, <A HREF="#vprintf">vprintf</A>,
<A HREF="#vsprintf">vsprintf</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>void main( int argc, char *argv[] )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char file_name[9];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char file_ext[4];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _bprintf( file_name, 9, &quot;%s&quot;, argv[1] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _bprintf( file_ext,&nbsp; 4, &quot;%s&quot;, argv[2] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s.%s\n&quot;, file_name, file_ext );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> _bprintf - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_bwprintf - All, Linux</TT>
</DL>
<H2 ID="break___"> break...&nbsp; Functions </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>void break_off( void );</TT>
<BR><TT>void break_on( void );</TT>
</DL>
<DL>
<DT>Description:
<DD>The <TT> break_off</TT> function can be used with DOS to restrict break checking (Ctrl+C, Ctrl+Break) to screen output and
keyboard input.&nbsp; The <TT> break_on</TT> function can be used with DOS to add break checking (Ctrl+C, Ctrl+Break) to other
activities such as disk file input/output.
</DL>
<DL>
<DT>Returns:
<DD>The <TT> break_off</TT> and <TT> break_on</TT> functions to not return anything.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#signal">signal</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; long i;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FILE *tmpf;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; tmpf = tmpfile();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( tmpf != NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Start\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break_off();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( i = 1; i &lt; 100000; i++ )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf( tmpf, &quot;%ld\n&quot;, i );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break_on();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Finish\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>DOS
</DL>
<DL>
<DT>Systems:
<DD><TT> break_off - DOS, Windows, Win386</TT>
<BR><BR><TT>break_on - DOS, Windows, Win386</TT>
</DL>
<H2 ID="bsearch"> bsearch </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>void *bsearch( const void *key,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const void *base,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t num,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t width,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int (*compar)( const void *pkey,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const void *pbase) );</TT>
</DL>
<DL>
<DT>Safer C:
<DD>The Safer C Library extension provides the <A HREF="#bsearch_s">bsearch_s</A> function which is a safer alternative to<TT>
bsearch</TT> This newer<TT> bsearch_s</TT> function is recommended to be used instead of the traditional &quot;unsafe&quot;<TT>
bsearch</TT> function.
</DL>
<DL>
<DT>Description:
<DD>The<TT> bsearch</TT> function performs a binary search of a sorted array of<B> num</B> elements, which is pointed to by<B>
base</B>, for an item which matches the object pointed to by<B> key</B>.&nbsp; Each element in the array is<B> width</B> bytes
in size.&nbsp; The comparison function pointed to by<B> compar</B> is called with two arguments that point to elements in
the array.&nbsp; The first argument<B> pkey</B> points to the same object pointed to by<B> key</B>.&nbsp; The second argument<B>
pbase</B> points to a element in the array.&nbsp; The comparison function shall return an integer less than, equal to, or
greater than zero if the<B> key</B> object is less than, equal to, or greater than the element in the array.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> bsearch</TT> function returns a pointer to the matching member of the array, or<TT> NULL</TT> if a matching object
could not be found.&nbsp; If there are multiple values in the array which are equal to the<B> key</B>, the return value is
not necessarily the first occurrence of a matching value when the array is searched linearly.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#bsearch_s">bsearch_s</A>, <A HREF="#lfind">lfind</A>, <A HREF="#lsearch">lsearch</A>, <A HREF="#qsort">qsort</A>,
<A HREF="#qsort_s">qsort_s</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><BR><TT>static const char *keywords[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;auto&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;break&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;case&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;char&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* . */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* . */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* . */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;while&quot;</TT>
<BR><TT>&nbsp; };</TT>
<BR><BR><TT>#define NUM_KW&nbsp; sizeof(keywords) / sizeof(char *)</TT>
<BR><BR><TT>int kw_compare( const void *p1, const void *p2 )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; const char *p1c = (const char *) p1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; const char **p2c = (const char **) p2;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; return( strcmp( p1c, *p2c ) );</TT>
<BR><TT>}</TT>
<BR><BR><TT>int keyword_lookup( const char *name )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; const char **key;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; key = (char const **) bsearch( name, keywords, NUM_KW,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sizeof(
char * ),&nbsp; kw_compare );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( key == NULL ) return( -1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; return key - keywords;</TT>
<BR><TT>}</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, keyword_lookup( &quot;case&quot; ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, keyword_lookup( &quot;crigger&quot; ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, keyword_lookup( &quot;auto&quot; ) );</TT>
<BR><TT>}</TT>
<BR><TT>//************ Sample program output ************</TT>
<BR><TT>//2</TT>
<BR><TT>//-1</TT>
<BR><TT>//0</TT>
<BR><BR>produces the following:
<BR><BR><TT>2</TT>
<BR><TT>-1</TT>
<BR><TT>0</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="bsearch_s"> bsearch_s </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__ 1</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>void *bsearch_s( const void *key,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const void *base,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rsize_t nmemb,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rsize_t size,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int (*compar)( const void *k, const void *y, void *context ),</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void *context );</TT>
</DL>
<DL>
<DT>Constraints:
<DD>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<TT>
bsearch_s</TT> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<BR><BR>Neither<B> nmemb</B> nor<B> size</B> shall be greater than <TT> RSIZE_MAX</TT>.&nbsp; If<B> nmemb</B> is not equal
to zero, then none of<B> key, base</B>, or<B> compar</B> shall be a null pointer.&nbsp; If there is a runtime-constraint violation,
the<TT> bsearch_s</TT> function does not search the array.
</DL>
<DL>
<DT>Description:
<DD>The<TT> bsearch_s</TT> function searches an array of<B> nmemb</B> objects, the initial element of which is pointed to by<B>
base</B>, for an element that matches the object pointed to by<B> key</B>.&nbsp; The size of each element of the array is
specified by<B> size</B>.&nbsp; The comparison function pointed to by<B> compar</B> is called with three arguments.&nbsp;
The first two point to the key object and to an array element, in that order.&nbsp; The function shall return an integer less
than, equal to, or greater than zero if the key object is considered, respectively, to be less than, to match, or to be greater
than the array element.&nbsp; The array shall consist of:&nbsp; all the elements that compare less than, all the elements
that compare equal to, and all the elements that compare greater than the key object, in that order.&nbsp; The third argument
to the comparison function is the<B> context</B> argument passed to<TT> bsearch_s</TT> The sole use of context by<TT> bsearch_s</TT>
is to pass it to the comparison function.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> bsearch_s</TT> function returns a pointer to a matching element of the array,or a null pointer if no match is found
or there is a runtime-constraint violation.&nbsp; If two elements compare as equal, which element is matched is unspecified.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#bsearch">bsearch</A>, <A HREF="#lfind">lfind</A>, <A HREF="#lsearch">lsearch</A>, <A HREF="#qsort">qsort</A>, <A HREF="#qsort_s">qsort_s</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__ 1</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><BR><TT>static const char *keywords[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;auto&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;break&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;case&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;char&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* . */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* . */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* . */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;while&quot;</TT>
<BR><TT>};</TT>
<BR><TT>static void * context = NULL;</TT>
<BR><BR><TT>#define NUM_KW&nbsp; sizeof(keywords) / sizeof(char *)</TT>
<BR><BR><TT>int kw_compare( const void *p1, const void *p2, void *context )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; const char *p1c = (const char *) p1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; const char **p2c = (const char **) p2;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; return( strcmp( p1c, *p2c ) );</TT>
<BR><TT>}</TT>
<BR><BR><TT>int keyword_lookup( const char *name )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; const char **key;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; key = (char const **) bsearch_s( name, keywords, NUM_KW,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sizeof(
char * ),&nbsp; kw_compare, context );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( key == NULL ) return( -1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; return key - keywords;</TT>
<BR><TT>}</TT>
<BR><BR><TT>int main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, keyword_lookup( &quot;case&quot; ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, keyword_lookup( &quot;crigger&quot; ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, keyword_lookup( &quot;auto&quot; ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; return 0;</TT>
<BR><TT>}</TT>
<BR><TT>//************ Sample program output ************</TT>
<BR><TT>//2</TT>
<BR><TT>//-1</TT>
<BR><TT>//0</TT>
<BR><BR>produces the following:
<BR><BR><TT>2</TT>
<BR><TT>-1</TT>
<BR><TT>0</TT>
</DL>
<DL>
<DT>Classification:
<DD>TR 24731
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="btowc"> btowc </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>wint_t btowc( int c );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> btowc</TT> function determines whether<B> c</B> is a valid single-byte character in the initial shift state.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> btowc</TT> function returns <TT> WEOF</TT> if<B> c</B> has the value <TT> EOF</TT> or if<B> (unsigned char)c</B> does
not constitute a valid single-byte character in the initial shift state.&nbsp; Otherwise,<TT> btowc</TT> returns the wide
character representation of that character.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_mbccmp">_mbccmp</A>, <A HREF="#_mbccpy">_mbccpy</A>, <A HREF="#_mbcicmp">_mbcicmp</A>, <A HREF="#_mbcjistojms">_mbcjistojms</A>,
<A HREF="#_mbcjmstojis">_mbcjmstojis</A>, <A HREF="#_mbclen">_mbclen</A>, <A HREF="#_mbctohira">_mbctohira</A>, <A HREF="#_mbctokata">_mbctokata</A>,
<A HREF="#_mbctolower">_mbctolower</A>, <A HREF="#_mbctombb">_mbctombb</A>, <A HREF="#_mbctoupper">_mbctoupper</A>, <A HREF="#mblen">mblen</A>,
<A HREF="#mbrlen">mbrlen</A>, <A HREF="#mbrtowc">mbrtowc</A>, <A HREF="#mbsrtowcs">mbsrtowcs</A>, <A HREF="#mbsrtowcs_s">mbsrtowcs_s</A>,
<A HREF="#mbstowcs">mbstowcs</A>, <A HREF="#mbstowcs_s">mbstowcs_s</A>, <A HREF="#mbtowc">mbtowc</A>, <A HREF="#wcrtomb">wcrtomb</A>,
<A HREF="#wcrtomb_s">wcrtomb_s</A>, <A HREF="#wcsrtombs">wcsrtombs</A>, <A HREF="#wcsrtombs_s">wcsrtombs_s</A>, <A HREF="#wcstombs">wcstombs</A>,
<A HREF="#wcstombs_s">wcstombs_s</A>, <A HREF="#wctob">wctob</A>, <A HREF="#wctomb">wctomb</A>, <A HREF="#wctomb_s">wctomb_s</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;EOF is %sa valid single-byte character\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; btowc( EOF ) == WEOF ? &quot;not &quot; : &quot;&quot; );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>EOF is not a valid single-byte character</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS
</DL>
<H2 ID="bzero"> bzero </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>void bzero( void *dst, size_t n );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> bzero</TT> function fills the first<B> n</B> bytes of the object pointed to by<B> dst</B> with zero (null) bytes.
<BR><BR>Note that this function is similar to the ISO C <TT> memset</TT> function (new code should use the ISO C function).
</DL>
<DL>
<DT>Returns:
<DD>The<TT> bzero</TT> function has no return value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#bcmp">bcmp</A>, <A HREF="#bcopy">bcopy</A>, <A HREF="#memset">memset</A>, <A HREF="#strset">strset</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char buffer[80];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; bzero( buffer, 80 );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="cabs"> cabs </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>double cabs( struct complex value );</TT>
<BR><BR><TT>struct _complex {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; double&nbsp; x;&nbsp; /* real part */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; double&nbsp; y;&nbsp; /* imaginary part */</TT>
<BR><TT>};</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> cabs</TT> function computes the absolute value of the complex number<B> value</B> by a calculation which is equivalent
to
<BR><BR><TT>sqrt( (value.x*value.x) + (value.y*value.y) )</TT>
<BR><BR>In certain cases, overflow errors may occur which will cause the <TT> matherr</TT> routine to be invoked.
</DL>
<DL>
<DT>Returns:
<DD>The absolute value is returned.
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><BR><TT>struct _complex c = { -3.0, 4.0 };</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, cabs( c ) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>5.000000</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>Math
</DL>
<H2 ID="calloc"> calloc Functions </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;&nbsp; For ISO C compatibility (calloc only)</TT>
<BR><TT>#include &lt;malloc.h&gt;&nbsp; Required for other function prototypes</TT>
<BR><TT>void *calloc( size_t n, size_t size );</TT>
<BR><TT>void __based(void) *_bcalloc( __segment seg,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t n,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t size );</TT>
<BR><TT>void __far&nbsp; *_fcalloc( size_t n, size_t size );</TT>
<BR><TT>void __near *_ncalloc( size_t n, size_t size );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<B> calloc</B> functions allocate space for an array of<B> n</B> objects, each of length<B> size</B> bytes.&nbsp; Each
element is initialized to 0.
<BR><BR>Each function allocates memory from a particular heap, as listed below:
<DL>
<DT>Function&nbsp;&nbsp;&nbsp;&nbsp; Heap
<DT>calloc
<DD>Depends on data model of the program
<DT>_bcalloc
<DD>Based heap specified by<B> seg</B> value
<DT>_fcalloc
<DD>Far heap (outside the default data segment)
<DT>_ncalloc
<DD>Near heap (inside the default data segment)
</DL>
<BR>In a small data memory model, the<B> calloc</B> function is equivalent to the <TT> _ncalloc</TT> function; in a large
data memory model, the<B> calloc</B> function is equivalent to the <TT> _fcalloc</TT> function.
<BR><BR>A block of memory allocated should be freed using the appropriate <TT> free</TT> function.
</DL>
<DL>
<DT>Returns:
<DD>The<B> calloc</B> functions return a pointer to the start of the allocated memory.&nbsp; The return value is<TT> NULL</TT>
(<TT> _NULLOFF</TT> for <TT> _bcalloc</TT>) if there is insufficient memory available or if the value of the<B> size</B> argument
is zero.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_expand">_expand</A> Functions, <A HREF="#free">free</A> Functions, <A HREF="#halloc">halloc</A>, <A HREF="#hfree">hfree</A>,
<A HREF="#malloc">malloc</A> Functions, <A HREF="#_msize">_msize</A> Functions, <A HREF="#realloc">realloc</A> Functions,
<A HREF="#sbrk">sbrk</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char *buffer;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; buffer = (char *)calloc( 80, sizeof(char) );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>_bcalloc is WATCOM
<BR>_fcalloc is WATCOM
<BR>_ncalloc is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> calloc - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_bcalloc - DOS/16, Windows, OS/2 1.x(all)</TT>
<BR><TT>_fcalloc - DOS/16, Windows, OS/2 1.x(all)</TT>
<BR><TT>_ncalloc - DOS, Windows, Win386, Win32, OS/2 1.x, OS/2 1.x(MT), OS/2-32, Linux, RDOS</TT>
</DL>
<H2 ID="cbrt"> cbrt </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>double cbrt( double x );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> cbrt</TT> function computes the cubed root of the argument<B> x</B>.
</DL>
<DL>
<DT>Returns:
<DD>The cubed root of the value.
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, cbrt( 8.0 ) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>2.000000</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C99
</DL>
<DL>
<DT>Systems:
<DD>Math
</DL>
<H2 ID="ceil"> ceil </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>double ceil( double x );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> ceil</TT> function (ceiling function) computes the smallest integer not less than<B> x</B>.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> ceil</TT> function returns the smallest integer not less than<B> x</B>, expressed as a<TT> double.</TT>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#floor">floor</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%f %f %f %f %f\n&quot;, ceil( -2.1 ), ceil( -2. ),</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ceil( 0.0 ), ceil( 2. ), ceil( 2.1 ) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>-2.000000 -2.000000 0.000000 2.000000 3.000000</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD>Math
</DL>
<H2 ID="cgets"> cgets </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>char *cgets( char *buf );</TT>
</DL>
<DL>
<DT>Description:
<DD>The cgets function gets a string of characters directly from the console and stores the string and its length in the array
pointed to by<B> buf</B>.&nbsp; The first element of the array<B> buf[0]</B> must contain the maximum length in characters
of the string to be read.&nbsp; The array must be big enough to hold the string, a terminating null character, and two additional
bytes.
<BR><BR>The<TT> cgets</TT> function reads characters until a carriage-return line-feed combination is read, or until the specified
number of characters is read.&nbsp; The string is stored in the array starting at<B> buf[2]</B>.&nbsp; The carriage-return
line-feed combination, if read, is replaced by a null character.&nbsp; The actual length of the string read is placed in<B>
buf[1]</B>.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> cgets</TT> function returns a pointer to the start of the string which is at<B> buf[2]</B>.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#fgets">fgets</A>, <A HREF="#getch">getch</A>, <A HREF="#getche">getche</A>, <A HREF="#gets">gets</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char buffer[82];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; buffer[0] = 80;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; cgets( buffer );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; cprintf( &quot;%s\r\n&quot;, &amp;buffer[2] );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="_chain_intr"> _chain_intr </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><TT>void _chain_intr( void (__interrupt __far *func)() );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _chain_intr</TT> function is used at the end of an interrupt routine to start executing another interrupt handler
(usually the previous handler for that interrupt).&nbsp; When the interrupt handler designated by<B> func</B> receives control,
the stack and registers appear as though the interrupt just occurred.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _chain_intr</TT> function does not return to its caller.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_dos_getvect">_dos_getvect</A>, <A HREF="#_dos_keep">_dos_keep</A>, <A HREF="#_dos_setvect">_dos_setvect</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><BR><TT>volatile int clock_ticks;</TT>
<BR><TT>void (__interrupt __far *prev_int_1c)();</TT>
<BR><TT>#define BLIP_COUNT&nbsp; (5*18)&nbsp; /* 5 seconds */</TT>
<BR><BR><TT>void __interrupt __far timer_rtn()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ++clock_ticks;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _chain_intr( prev_int_1c );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR><TT>int delays = 0;</TT>
<BR><BR><TT>int compile_a_line()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( delays &gt; 15 ) return( 0 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; delay( 1000 );&nbsp; /* delay for 1 second */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Delayed for 1 second\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; delays++;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; return( 1 );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; prev_int_1c = _dos_getvect( 0x1c );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _dos_setvect( 0x1c, timer_rtn );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; while( compile_a_line() ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( clock_ticks &gt;= BLIP_COUNT ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; putchar( '.' );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clock_ticks -= BLIP_COUNT;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _dos_setvect( 0x1c, prev_int_1c );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows
</DL>
<H2 ID="chdir"> chdir, _chdir, _wchdir </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;sys/types.h&gt;</TT>
<BR><TT>#include &lt;direct.h&gt;</TT>
<BR><TT>int chdir( const char *path );</TT>
<BR><TT>int _chdir( const char *path );</TT>
<BR><TT>int _wchdir( const wchar_t *path );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> chdir</TT> function changes the current directory on the specified drive to the specified<B> path</B>.&nbsp; If no
drive is specified in<B> path</B> then the current drive is assumed.&nbsp; The<B> path</B> can be either relative to the current
directory on the specified drive or it can be an absolute path name.
<BR><BR>Each drive under DOS, OS/2 or Windows has a current directory.&nbsp; The current working directory is the current
directory of the current drive.&nbsp; If you wish to change the current drive, you must use the <TT> _dos_setdrive</TT> function.
<BR><BR>The<TT> _chdir</TT> function is identical to<TT> chdir</TT>.&nbsp; Use<TT> _chdir</TT> for ANSI naming conventions.
<BR><BR>The<TT> _wchdir</TT> function is a wide-character version of<TT> chdir</TT> that operates with wide-character strings.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> chdir</TT> function returns zero if successful.&nbsp; Otherwise, -1 is returned, <TT> errno</TT> is set to indicate
the error, and the current working directory remains unchanged.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>ENOENT
<DD>The specified<B> path</B> does not exist or<B> path</B> is an empty string.
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#chmod">chmod</A>, <A HREF="#_dos_setdrive">_dos_setdrive</A>, <A HREF="#getcwd">getcwd</A>, <A HREF="#mkdir">mkdir</A>,
<A HREF="#rmdir">rmdir</A>, <A HREF="#stat">stat</A>, <A HREF="#umask">umask</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>#include &lt;direct.h&gt;</TT>
<BR><BR><TT>void main( int argc, char *argv[] )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( argc != 2 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf( stderr, &quot;Use: cd &lt;directory&gt;\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit( 1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; if( chdir( argv[1] ) == 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Directory changed to %s\n&quot;, argv[1] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit( 0 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; perror( argv[1] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit( 1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>POSIX 1003.1
<BR><BR>_chdir conforms to ANSI naming conventions
<BR>_wchdir is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> chdir - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_chdir - All, RDOS, Netware</TT>
<BR><TT>_wchdir - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</TT>
</DL>
<H2 ID="_chdrive"> _chdrive </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;direct.h&gt;</TT>
<BR><TT>int _chdrive( int drive );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _chdrive</TT> function changes the current working drive to the one specified by<B> drive</B>.&nbsp; A value of 1
is drive A, 2 is drive B, 3 is drive C, etc.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _chdrive</TT> function returns zero if drive is successfully changed.&nbsp; Otherwise, -1 is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_dos_getdrive">_dos_getdrive</A>, <A HREF="#_dos_setdrive">_dos_setdrive</A>, <A HREF="#_getdrive">_getdrive</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;direct.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int drive = 3;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; if( _chdrive( drive&nbsp; ) == 0 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Changed the current drive to %c\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'A' + drive - 1 );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>Changed the current drive to C</TT>
</DL>
<DL>
<DT>Classification:
<DD>DOS
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS, DOS/PM
</DL>
<H2 ID="chmod"> chmod, _chmod, _wchmod </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;sys/types.h&gt;</TT>
<BR><TT>#include &lt;sys/stat.h&gt;</TT>
<BR><TT>#include &lt;io.h&gt;</TT>
<BR><TT>int chmod( const char *path, mode_t permission );</TT>
<BR><TT>int _chmod( const char *path, mode_t permission );</TT>
<BR><TT>int _wchmod( const wchar_t *path, mode_t permission );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> chmod</TT> function changes the permissions for a file specified by<B> path</B> to be the settings in the mode given
by<B> permission</B>.&nbsp; The access permissions for the file or directory are specified as a combination of bits (defined
in the<TT> &lt;sys/stat.h&gt;</TT> header file).
<BR><BR>The following bits define permissions for the owner.
<DL>
<DT>Permission&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>S_IRWXU
<DD>Read, write, execute/search
<DT>S_IRUSR
<DD>Read permission
<DT>S_IWUSR
<DD>Write permission
<DT>S_IXUSR
<DD>Execute/search permission
</DL>
<BR>The following bits define permissions for the group.
<DL>
<DT>Permission&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>S_IRWXG
<DD>Read, write, execute/search
<DT>S_IRGRP
<DD>Read permission
<DT>S_IWGRP
<DD>Write permission
<DT>S_IXGRP
<DD>Execute/search permission
</DL>
<BR>The following bits define permissions for others.
<DL>
<DT>Permission&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>S_IRWXO
<DD>Read, write, execute/search
<DT>S_IROTH
<DD>Read permission
<DT>S_IWOTH
<DD>Write permission
<DT>S_IXOTH
<DD>Execute/search permission
</DL>
<BR>The following bits define miscellaneous permissions used by other implementations.
<DL>
<DT>Permission&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>S_IREAD
<DD>is equivalent to S_IRUSR (read permission)
<DT>S_IWRITE
<DD>is equivalent to S_IWUSR (write permission)
<DT>S_IEXEC
<DD>is equivalent to S_IXUSR (execute/search permission)
</DL>
<BR>Upon successful completion, the<TT> chmod</TT> function will mark for update the<B> st_ctime</B> field of the file.
<BR><BR>The<TT> _chmod</TT> function is identical to<TT> chmod</TT>.&nbsp; Use<TT> _chmod</TT> for ANSI naming conventions.
<BR><BR>The<TT> _wchmod</TT> function is a wide-character version of<TT> chmod</TT> that operates with wide-character strings.
</DL>
<DL>
<DT>Returns:
<DD>The chmod returns zero if the new settings are successfully made; otherwise, -1 is returned and <TT> errno</TT> is set to
indicate the error.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>EACCES
<DD>Search permission is denied for a component of<B> path</B>.
<DT>ENOENT
<DD>The specified<B> path</B> does not exist or<B> path</B> is an empty string.
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#fstat">fstat</A>, <A HREF="#open">open</A>, <A HREF="#sopen">sopen</A>, <A HREF="#stat">stat</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>/*</TT>
<BR><TT> * change the permissions of a list of files</TT>
<BR><TT> * to be read/write by the owner only</TT>
<BR><TT> */</TT>
<BR><BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>#include &lt;sys/types.h&gt;</TT>
<BR><TT>#include &lt;sys/stat.h&gt;</TT>
<BR><TT>#include &lt;io.h&gt;</TT>
<BR><BR><TT>void main( int argc, char *argv[] )</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int i;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int ecode = 0;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; for( i = 1; i &lt; argc; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( chmod( argv[i], S_IRUSR | S_IWUSR ) == -1 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; perror( argv[i] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ecode++;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; exit( ecode );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>POSIX 1003.1
<BR><BR>_chmod conforms to ANSI naming conventions
<BR>_wchmod is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> chmod - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_chmod - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
<BR><TT>_wchmod - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</TT>
</DL>
<H2 ID="chsize"> chsize, _chsize </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;io.h&gt;</TT>
<BR><TT>int chsize( int handle, long size );</TT>
<BR><TT>int _chsize( int handle, long size );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> chsize</TT> function changes the size of the file associated with<B> handle</B> by extending or truncating the file
to the length specified by<B> size</B>.&nbsp; If the file needs to be extended, the file is padded with NULL ('\0') characters.
<BR><BR>The<TT> _chsize</TT> function is identical to<TT> chsize</TT>.&nbsp; Use<TT> _chsize</TT> for ANSI naming conventions.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> chsize</TT> function returns zero if successful.&nbsp; A return value of -1 indicates an error, and <TT> errno</TT>
is set to indicate the error.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>EACCES
<DD>The specified file is locked against access.
<DT>EBADF
<DD>Invalid file handle.
<DT>ENOSPC
<DD>Not enough space left on the device to extend the file.
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#close">close</A>, <A HREF="#creat">creat</A>, <A HREF="#open">open</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;io.h&gt;</TT>
<BR><TT>#include &lt;fcntl.h&gt;</TT>
<BR><TT>#include &lt;sys/stat.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp; handle;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; handle = open( &quot;file&quot;, O_RDWR | O_CREAT,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S_IRUSR | S_IWUSR | S_IRGRP
| S_IWGRP );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( handle != -1 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( chsize( handle, 32 * 1024L ) != 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Error extending file\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close( handle );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
<BR><BR>_chsize conforms to ANSI naming conventions
</DL>
<DL>
<DT>Systems:
<DD><TT> chsize - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_chsize - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="_clear87"> _clear87 </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;float.h&gt;</TT>
<BR><TT>unsigned int _clear87( void );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _clear87</TT> function clears the floating-point status word which is used to record the status of 8087/80287/80387/80486
floating-point operations.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _clear87</TT> function returns the old floating-point status.&nbsp; The description of this status is found in the<TT>
&lt;float.h&gt;</TT> header file.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_control87">_control87</A>, <A HREF="#_controlfp">_controlfp</A>, <A HREF="#_finite">_finite</A>, <A HREF="#_fpreset">_fpreset</A>,
<A HREF="#_status87">_status87</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;float.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned int fp_status;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; fp_status = _clear87();</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;80x87 status =&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( fp_status &amp; SW_INVALID )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot; invalid&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( fp_status &amp; SW_DENORMAL )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot; denormal&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( fp_status &amp; SW_ZERODIVIDE )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot; zero_divide&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( fp_status &amp; SW_OVERFLOW )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot; overflow&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( fp_status &amp; SW_UNDERFLOW )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot; underflow&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( fp_status &amp; SW_INEXACT )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot; inexact_result&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;\n&quot; );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>Math
</DL>
<H2 ID="clearenv"> clearenv </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;env.h&gt;</TT>
<BR><TT>int clearenv( void );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> clearenv</TT> function clears the process environment area.&nbsp; No environment variables are defined immediately
after a call to the<TT> clearenv</TT> function.&nbsp; Note that this clears the <TT> PATH</TT>, <TT> COMSPEC</TT>, and <TT>
TZ</TT> environment variables which may then affect the operation of other library functions.
<BR><BR>The<TT> clearenv</TT> function may manipulate the value of the pointer <TT> environ</TT>.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> clearenv</TT> function returns zero upon successful completion.&nbsp; Otherwise, it will return a non-zero value and
set <TT> errno</TT> to indicate the error.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>ENOMEM
<DD>Not enough memory to allocate a control structure.
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#exec___">exec...</A>, <A HREF="#getenv">getenv</A>, <A HREF="#getenv_s">getenv_s</A>, <A HREF="#putenv">putenv</A>,
<A HREF="#_searchenv">_searchenv</A>, <A HREF="#setenv">setenv</A>, <A HREF="#spawn___">spawn...</A>, <A HREF="#system">system</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR>The following example clears the entire environment area and sets up a new TZ environment variable.
<BR><BR><TT>#include &lt;env.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; clearenv();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; setenv( &quot;TZ&quot;, &quot;EST5EDT&quot;, 0 );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="clearerr"> clearerr </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>void clearerr( FILE *fp );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> clearerr</TT> function clears the end-of-file and error indicators for the stream pointed to by<B> fp</B>.&nbsp; These
indicators are cleared only when the file is opened or by an explicit call to the<TT> clearerr</TT> or <TT> rewind</TT> functions.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> clearerr</TT> function returns no value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#feof">feof</A>, <A HREF="#ferror">ferror</A>, <A HREF="#perror">perror</A>, <A HREF="#strerror">strerror</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FILE *fp;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int c;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; c = 'J';</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fp = fopen( &quot;file&quot;, &quot;w&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( fp != NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fputc( c, fp );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( ferror( fp ) ) {&nbsp; /* if error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clearerr( fp );&nbsp;&nbsp; /* clear the error */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fputc( c, fp );&nbsp;&nbsp; /* and retry it&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="_clearscreen"> _clearscreen </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>void _FAR _clearscreen( short area );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _clearscreen</TT> function clears the indicated<B> area</B> and fills it with the background color.&nbsp; The<B> area</B>
argument must be one of the following values:
<DL>
<DT>_GCLEARSCREEN
<DD>area is entire screen
<DT>_GVIEWPORT
<DD>area is current viewport or clip region
<DT>_GWINDOW
<DD>area is current text window
</DL>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _clearscreen</TT> function does not return a value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_setbkcolor">_setbkcolor</A>, <A HREF="#_setviewport">_setviewport</A>, <A HREF="#_setcliprgn">_setcliprgn</A>,
<A HREF="#_settextwindow">_settextwindow</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _rectangle( _GFILLINTERIOR, 100, 100, 540, 380 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setviewport( 200, 200, 440, 280 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _clearscreen( _GVIEWPORT );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="clock"> clock </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;time.h&gt;</TT>
<BR><TT>clock_t clock(void);</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> clock</TT> function returns the number of clock ticks of processor time used by program since the program started
executing.&nbsp; This can be converted to seconds by dividing by the value of the macro <TT> CLOCKS_PER_SEC</TT>.
<BR><BR>Note that under DOS and OS/2, the clock tick counter will reset to 0 for each subsequent 24 hour interval that elapses.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> clock</TT> function returns the number of clock ticks that have occurred since the program started executing.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#asctime">asctime</A> Functions, <A HREF="#asctime_s">asctime_s</A>, <A HREF="#ctime">ctime</A> Functions, <A HREF="#ctime_s">ctime_s</A>,
<A HREF="#difftime">difftime</A>, <A HREF="#gmtime">gmtime</A>, <A HREF="#gmtime_s">gmtime_s</A>, <A HREF="#localtime">localtime</A>,
<A HREF="#localtime_s">localtime_s</A>, <A HREF="#mktime">mktime</A>, <A HREF="#strftime">strftime</A>, <A HREF="#time">time</A>,
<A HREF="#tzset">tzset</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>#include &lt;time.h&gt;</TT>
<BR><BR><TT>void compute( void )</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int i, j;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; double x;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; x = 0.0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 1; i &lt;= 100; i++ )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( j = 1; j &lt;= 100; j++ )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x += sqrt( (double) i * j );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%16.7f\n&quot;, x );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; clock_t start_time, end_time;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; start_time = clock();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; compute();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; end_time = clock();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Execution time was %lu seconds\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (end_time - start_time) / CLOCKS_PER_SEC );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="clock_getres"> clock_getres </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;time.h&gt;</TT>
<BR><TT>int clock_getres(clockid_t clockid, struct timespec *ts);</TT>
<BR><BR><TT>struct timespec {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; time_t tv_sec;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; long tv_nsec;</TT>
<BR><TT>};</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> clock_getres</TT> function retrieves the minimum resolution of the clock specified by<B> clockid</B> in the<B> ts</B>
pointer.
</DL>
<DL>
<DT>Returns:
<DD>If successful, the function will return zero.&nbsp; If the call fails, the return value is the negation of the appropriate
<TT> errno</TT> value as specified below.&nbsp; This implementation will also set <TT> errno</TT> appropriately on failures.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>EINVAL
<DD>The value of<B> clockid</B> is invalid.
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#clock_settime">clock_settime</A>, <A HREF="#clock_gettime">clock_gettime</A>, <A HREF="#clock_nanosleep">clock_nanosleep</A>
</DL>
<DL>
<DT>Classification:
<DD>POSIX
</DL>
<DL>
<DT>Systems:
<DD>Linux
</DL>
<H2 ID="clock_gettime"> clock_gettime </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;time.h&gt;</TT>
<BR><TT>int clock_gettime(clockid_t clockid, struct timespec *ts);</TT>
<BR><BR><TT>struct timespec {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; time_t tv_sec;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; long tv_nsec;</TT>
<BR><TT>};</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> clock_gettime</TT> function retrieves the time for the clock specified by<B> clockid</B> in the<B> ts</B> pointer.
</DL>
<DL>
<DT>Returns:
<DD>If successful, the function will return zero.&nbsp; If the call fails, the return value is the negation of the appropriate
<TT> errno</TT> value as specified below.&nbsp; This implementation will also set <TT> errno</TT> appropriately on failures.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>EINVAL
<DD>The value of<B> clockid</B> is invalid.
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#clock_settime">clock_settime</A>, <A HREF="#clock_getres">clock_getres</A>, <A HREF="#clock_nanosleep">clock_nanosleep</A>
</DL>
<DL>
<DT>Classification:
<DD>POSIX
</DL>
<DL>
<DT>Systems:
<DD>Linux
</DL>
<H2 ID="clock_nanosleep"> clock_nanosleep </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;time.h&gt;</TT>
<BR><TT>int clock_nanosleep(clockid_t clockid, int flags,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const struct timespec *request,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
struct timespec *remains);</TT>
<BR><BR><TT>struct timespec {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; time_t tv_sec;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; long tv_nsec;</TT>
<BR><TT>};</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> clock_nanosleep</TT> function causes the current thread to be suspended until the time period specified by<B> request</B>
has elapsed according to the clock specified by<B> clockid</B> if the<B> flags</B> do not contain the value TIMER_ABSTIME.
<BR><BR>If<B> flags</B> does contain TIMER_ABSTIME, the<TT> clock_nanosleep</TT> function causes the current thread to be
suspended until the absolute time specified by<B> request</B> has been reached according to the clock specified by<B> clockid</B>
if the flags.
<BR><BR>If<B> remains</B> is not NULL, the structure will contain the amount of time remaining to be slept if<TT> clock_nanosleep</TT>
is interrupted by a signal.
</DL>
<DL>
<DT>Returns:
<DD>If successful and uninterrupted, the function will return zero.&nbsp; If the call fails or is interrupted, the return value
is the negation of the appropriate <TT> errno</TT> value as specified below.&nbsp; This implementation will also set <TT>
errno</TT> appropriately on failures.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>EINTR
<DD>The sleep was interrupted by a signal.
<DT>EINVAL
<DD>The value of<B> clockid</B> ,<B> request</B> , or<B> flags</B> is invalid.
<DT>ENOTSUP
<DD>The specified clock does not support this function.
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#clock_gettime">clock_gettime</A>, <A HREF="#clock_getres">clock_getres</A>, <A HREF="#clock_settime">clock_settime</A>
</DL>
<DL>
<DT>Classification:
<DD>POSIX
</DL>
<DL>
<DT>Systems:
<DD>Linux
</DL>
<H2 ID="clock_settime"> clock_settime </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;time.h&gt;</TT>
<BR><TT>int clock_settime(clockid_t clockid, const struct timespec *ts);</TT>
<BR><BR><TT>struct timespec {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; time_t tv_sec;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; long tv_nsec;</TT>
<BR><TT>};</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> clock_settime</TT> function sets the time for the clock specified by<B> clockid</B> to the time contained in the<B>
ts</B> pointer.&nbsp; Depending on the value of<B> clockid</B> , the function may fail if the user has insufficient privileges.
<BR><BR>Values of<B> ts</B> that specify significance beyond the clock's resolution will be truncated.
</DL>
<DL>
<DT>Returns:
<DD>If successful, the function will return zero.&nbsp; If the call fails, the return value is the negation of the appropriate
<TT> errno</TT> value as specified below.&nbsp; This implementation will also set <TT> errno</TT> appropriately on failures.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>EINVAL
<DD>The value of<B> clockid</B> is invalid, or the value of<B> ts</B> exceeds the range of this clock.
<DT>EPERM
<DD>The user does not have sufficient privileges to modify the specified clock.
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#clock_gettime">clock_gettime</A>, <A HREF="#clock_getres">clock_getres</A>, <A HREF="#clock_nanosleep">clock_nanosleep</A>
</DL>
<DL>
<DT>Classification:
<DD>POSIX
</DL>
<DL>
<DT>Systems:
<DD>Linux
</DL>
<H2 ID="clone"> clone </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;sched.h&gt;</TT>
<BR><BR><TT>pid_t&nbsp; clone( int (*fn)(void *), void *child_stack,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int flags, void *args, ... );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* pid_t *ppid, void *tls, pid_t *ctid */</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> clone</TT> function creates a &quot;clone&quot; of the currently running process that shares the address space of
the original, parent process, and starts execution within the clone process at the<B> fn</B> function.&nbsp; The child function
is called with<B> args</B> as its argument, and, once complete, with will terminate with the return value of<B> fn</B> as
its exit code.&nbsp; This function provides a wrapper around the Linux kernel's <TT> SYS_clone</TT> system call.
<BR><BR>The<B> child_stack</B> argument points to a user-allocated memory block within the process's heap for use as the cloned
process's new stack space.&nbsp; Because the stack will grow in the direction of descending address, the<B> child_stack</B>
argument should refer to the highest address in the allocated memory.
<BR><BR>The<B> flags</B> argument may be one of the following values:
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>CLONE_VM
<DD>Virtual memory should be shared across processes
<DT>CLONE_FS
<DD>File system information should be shared across processes
<DT>CLONE_FILES
<DD>File handles should be shared across processes
<DT>CLONE_SIGHAND
<DD>Signal handlers and blocked signals should be shared across processes
<DT>CLONE_PTRACE
<DD>Allow tracing within the child process (if enabled in the parent)
<DT>CLONE_VFORK
<DD>The child can wake the parent via <TT> mm_release</TT>
<DT>CLONE_PARENT
<DD>The new child should share the same parent as the cloning process
<DT>CLONE_THREAD
<DD>The new process is to be considered a thread, and should be grouped in the same thread group as the parent
<DT>CLONE_NEWNS
<DD>The child process is provided a new mount namespace
<DT>CLONE_SYSVSEM
<DD>The child process shares all System V semaphores
<DT>CLONE_SETTLS
<DD>The thread-local storage, an optional argument, should be passed and set appropriately.&nbsp; The user must specify the<B>
tls</B> argument if this flag is set.
<DT>CLONE_PARENT_SETTID
<DD>Store the thread ID of the parent in the<B> ptid</B> argument.&nbsp; The user must specify the optional<B> ptid</B> argument
if this flag is set.
<DT>CLONE_CHILD_CLEARTID
<DD>Clear the thread ID stored in<B> ctid</B> argument.&nbsp; The user must specify the optional<B> ctid</B> argument if this
flag is set.
<DT>CLONE_UNTRACED
<DD>The parent process cannot force tracing on the child process
<DT>CLONE_CHILD_SETTID
<DD>Store the thread ID of the child process in the<B> ctid</B> argument.&nbsp; The user must specify the optional<B> ctid</B>
argument if this flag is set.
<DT>CLONE_NEWUTS
<DD>The child process has a new UTS namespace
<DT>CLONE_NEWIPC
<DD>The child process has a new IPC namespace
<DT>CLONE_NEWUSER
<DD>The child process has a new user namespace
<DT>CLONE_NEWPID
<DD>The child process has a new PID namespace
<DT>CLONE_NEWNET
<DD>The child process has a new network namespace
<DT>CLONE_IO
<DD>The parent and child share io contexts
</DL>
<BR>This function provides a low-level threading interface that is normally meant for designing higher level thread libraries.
</DL>
<DL>
<DT>Returns:
<DD>If successful, the function will return the process ID of the child process.&nbsp; If the system call fails, the return value
will be -1, and <TT> errno</TT> will be set appropriately.
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>Linux
</DL>
<H2 ID="close"> close, _close </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;io.h&gt;</TT>
<BR><TT>int close( int handle );</TT>
<BR><TT>int _close( int handle );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> close</TT> function closes a file at the operating system level.&nbsp; The<B> handle</B> value is the file handle
returned by a successful execution of one of the <TT> creat</TT>, <TT> dup</TT>, <TT> dup2</TT>, <TT> open</TT> or <TT> sopen</TT>
functions.
<BR><BR>The<TT> _close</TT> function is identical to<TT> close</TT>.&nbsp; Use<TT> _close</TT> for ANSI naming conventions.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> close</TT> function returns zero if successful.&nbsp; Otherwise, it returns -1 and <TT> errno</TT> is set to indicate
the error.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>EBADF
<DD>The<B> handle</B> argument is not a valid file handle.
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#creat">creat</A>, <A HREF="#dup">dup</A>, <A HREF="#dup2">dup2</A>, <A HREF="#open">open</A>, <A HREF="#sopen">sopen</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;fcntl.h&gt;</TT>
<BR><TT>#include &lt;io.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int handle;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; handle = open( &quot;file&quot;, O_RDONLY );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( handle != -1 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* process file */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close( handle );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>POSIX 1003.1
<BR><BR>_close conforms to ANSI naming conventions
</DL>
<DL>
<DT>Systems:
<DD><TT> close - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_close - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="closedir"> closedir, _wclosedir </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;direct.h&gt;</TT>
<BR><TT>int closedir( DIR *dirp );</TT>
<BR><TT>int _wclosedir( WDIR *dirp );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> closedir</TT> function closes the directory specified by<B> dirp</B> and frees the memory allocated by <TT> opendir</TT>.
<BR><BR>The<TT> _wclosedir</TT> function is identical to<TT> closedir</TT> except that it closes a directory of wide-character
filenames opened by <TT> _wopendir</TT>.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> closedir</TT> function returns zero if successful, non-zero otherwise.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>EBADF
<DD>The argument<B> dirp</B> does not refer to an open directory stream.
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_dos_find___">_dos_find...</A>, <A HREF="#opendir">opendir</A>, <A HREF="#readdir">readdir</A>, <A HREF="#rewinddir">rewinddir</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR>To get a list of files contained in the directory<TT> \watcom\h</TT> on your default disk:
<BR><BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;direct.h&gt;</TT>
<BR><BR><TT>typedef struct {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; twosecs : 5;&nbsp;&nbsp;&nbsp; /* seconds / 2 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; minutes : 6;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; hours&nbsp;&nbsp; : 5;</TT>
<BR><TT>} ftime_t;</TT>
<BR><BR><TT>typedef struct {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; day&nbsp;&nbsp;&nbsp;&nbsp; : 5;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; month&nbsp;&nbsp; : 4;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; year&nbsp;&nbsp;&nbsp; : 7;</TT>
<BR><TT>} fdate_t;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; DIR *dirp;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct dirent *direntp;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ftime_t *f_time;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fdate_t *f_date;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; dirp = opendir( &quot;\\watcom\\h&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( dirp != NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(;;) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; direntp = readdir( dirp );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( direntp == NULL ) break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f_time = (ftime_t *)&amp;direntp-&gt;d_time;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f_date = (fdate_t *)&amp;direntp-&gt;d_date;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%-12s %d/%2.2d/%2.2d &quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;%2.2d:%2.2d:%2.2d
\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; direntp-&gt;d_name,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f_date-&gt;year + 1980,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f_date-&gt;month,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f_date-&gt;day,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f_time-&gt;hours,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f_time-&gt;minutes,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f_time-&gt;twosecs * 2 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; closedir( dirp );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>Note the use of two adjacent backslash characters (\) within character-string constants to signify a single backslash.
</DL>
<DL>
<DT>Classification:
<DD>POSIX 1003.1
<BR><BR>_wclosedir is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> closedir - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_wclosedir - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</TT>
</DL>
<H2 ID="_cmdname"> _cmdname </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;process.h&gt;</TT>
<BR><TT>char *_cmdname( char *buffer );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _cmdname</TT> function obtains a copy of the executing program's pathname and places it in<B> buffer</B>.
</DL>
<DL>
<DT>Returns:
<DD>If the pathname of the executing program cannot be determined then<TT> NULL</TT> is returned; otherwise the address of<B>
buffer</B> is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#getcmd">getcmd</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;process.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char buffer[PATH_MAX];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, _cmdname( buffer ) );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="_commit"> _commit </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;io.h&gt;</TT>
<BR><TT>int _commit( int handle );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _commit</TT> function commits changes to the file specified by<B> handle</B> to disk immediately.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _commit</TT> function returns -1 if the changes have been successfully committed.&nbsp; Otherwise, 0 is returned and
<TT> errno</TT> is set to indicate the error.
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32
</DL>
<H2 ID="_control87"> _control87 </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;float.h&gt;</TT>
<BR><TT>unsigned int _control87( unsigned int newcw,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; unsigned int mask );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _control87</TT> function updates the control word of the 8087/80287/80387/80486.&nbsp; If<B> mask</B> is zero, then
the control word is not updated.&nbsp; If<B> mask</B> is non-zero, then the control word is updated with bits from<B> newcw</B>
corresponding to every bit that is on in<B> mask</B>.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _control87</TT> function returns the new control word.&nbsp; The description of bits defined for the control word
is found in the<TT> &lt;float.h&gt;</TT> header file.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_clear87">_clear87</A>, <A HREF="#_controlfp">_controlfp</A>, <A HREF="#_finite">_finite</A>, <A HREF="#_fpreset">_fpreset</A>,
<A HREF="#_status87">_status87</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;float.h&gt;</TT>
<BR><BR><TT>char *status[2] = { &quot;disabled&quot;, &quot;enabled&quot; };</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned int fp_cw = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned int fp_mask = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned int bits;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; fp_cw = _control87( fp_cw,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; fp_mask );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Interrupt Exception Masks\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; bits = fp_cw &amp; MCW_EM;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;&nbsp; Invalid Operation exception %s\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; status[ (bits &amp; EM_INVALID) == 0 ] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;&nbsp; Denormalized exception %s\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; status[ (bits &amp; EM_DENORMAL) == 0 ] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;&nbsp; Divide-By-Zero exception %s\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; status[ (bits &amp; EM_ZERODIVIDE) == 0 ] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;&nbsp; Overflow exception %s\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; status[ (bits &amp; EM_OVERFLOW) == 0 ] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;&nbsp; Underflow exception %s\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; status[ (bits &amp; EM_UNDERFLOW) == 0 ] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;&nbsp; Precision exception %s\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; status[ (bits &amp; EM_PRECISION) == 0 ] );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Infinity Control = &quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; bits = fp_cw &amp; MCW_IC;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( bits == IC_AFFINE )&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;affine\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( bits == IC_PROJECTIVE ) printf( &quot;projective\n&quot; );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Rounding Control = &quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; bits = fp_cw &amp; MCW_RC;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( bits == RC_NEAR )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;near\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( bits == RC_DOWN )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;down\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( bits == RC_UP )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;up\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( bits == RC_CHOP )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;chop\n&quot; );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Precision Control = &quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; bits = fp_cw &amp; MCW_PC;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( bits == PC_24 )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;24 bits\n&quot;
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( bits == PC_53 )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;53 bits\n&quot;
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( bits == PC_64 )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;64 bits\n&quot;
);</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="_controlfp"> _controlfp </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;float.h&gt;</TT>
<BR><TT>unsigned int _controlfp( unsigned int newcw,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; unsigned int mask );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _controlfp</TT> function updates the control word of the 8087/80287/80387/80486.&nbsp; If<B> mask</B> is zero, then
the control word is not updated.&nbsp; If<B> mask</B> is non-zero, then the control word is updated with bits from<B> newcw</B>
corresponding to every bit that is on in<B> mask</B>.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _controlfp</TT> function returns the new control word.&nbsp; The description of bits defined for the control word
is found in the<TT> &lt;float.h&gt;</TT> header file.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_clear87">_clear87</A>, <A HREF="#_control87">_control87</A>, <A HREF="#_finite">_finite</A>, <A HREF="#_fpreset">_fpreset</A>,
<A HREF="#_status87">_status87</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;float.h&gt;</TT>
<BR><BR><TT>char *status[2] = { &quot;disabled&quot;, &quot;enabled&quot; };</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned int fp_cw = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned int fp_mask = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned int bits;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; fp_cw = _controlfp( fp_cw,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; fp_mask );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Interrupt Exception Masks\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; bits = fp_cw &amp; MCW_EM;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;&nbsp; Invalid Operation exception %s\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; status[ (bits &amp; EM_INVALID) == 0 ] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;&nbsp; Denormalized exception %s\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; status[ (bits &amp; EM_DENORMAL) == 0 ] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;&nbsp; Divide-By-Zero exception %s\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; status[ (bits &amp; EM_ZERODIVIDE) == 0 ] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;&nbsp; Overflow exception %s\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; status[ (bits &amp; EM_OVERFLOW) == 0 ] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;&nbsp; Underflow exception %s\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; status[ (bits &amp; EM_UNDERFLOW) == 0 ] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;&nbsp; Precision exception %s\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; status[ (bits &amp; EM_PRECISION) == 0 ] );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Infinity Control = &quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; bits = fp_cw &amp; MCW_IC;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( bits == IC_AFFINE )&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;affine\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( bits == IC_PROJECTIVE ) printf( &quot;projective\n&quot; );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Rounding Control = &quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; bits = fp_cw &amp; MCW_RC;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( bits == RC_NEAR )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;near\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( bits == RC_DOWN )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;down\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( bits == RC_UP )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;up\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( bits == RC_CHOP )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;chop\n&quot; );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Precision Control = &quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; bits = fp_cw &amp; MCW_PC;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( bits == PC_24 )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;24 bits\n&quot;
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( bits == PC_53 )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;53 bits\n&quot;
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( bits == PC_64 )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;64 bits\n&quot;
);</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="copysign"> copysign </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>double copysign( double x, double y );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> copysign</TT> function returns a value whose absolute value is equal to the absolute value of the argument<B> x</B>
and whose sign matches argument<B> y</B>.
</DL>
<DL>
<DT>Returns:
<DD>A value of the same magnitude as<B> x</B> and the same sign as<B> y</B>.
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, copysign( -2.0, 3.0 ) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>2.000000</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C99
</DL>
<DL>
<DT>Systems:
<DD>Math
</DL>
<H2 ID="cos"> cos </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>double cos( double x );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> cos</TT> function computes the cosine of<B> x</B> (measured in radians).&nbsp; A large magnitude argument may yield
a result with little or no significance.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> cos</TT> function returns the cosine value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#acos">acos</A>, <A HREF="#sin">sin</A>, <A HREF="#tan">tan</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; double value;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; value = cos( 3.1415278 );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD>Math
</DL>
<H2 ID="cosh"> cosh </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>double cosh( double x );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> cosh</TT> function computes the hyperbolic cosine of<B> x</B>.&nbsp; A range error occurs if the magnitude of<B> x</B>
is too large.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> cosh</TT> function returns the hyperbolic cosine value.&nbsp; When the argument is outside the permissible range,
the <TT> matherr</TT> function is called.&nbsp; Unless the default <TT> matherr</TT> function is replaced, it will set the
global variable <TT> errno</TT> to <TT> ERANGE</TT>, and print a &quot;RANGE error&quot; diagnostic message using the <TT>
stderr</TT> stream.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#sinh">sinh</A>, <A HREF="#tanh">tanh</A>, <A HREF="#matherr">matherr</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, cosh(.5) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>1.127626</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD>Math
</DL>
<H2 ID="cprintf"> cprintf </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>int cprintf( const char *format, ... );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> cprintf</TT> function writes output directly to the console under control of the argument<B> format</B>.&nbsp; The
<TT> putch</TT> function is used to output characters to the console.&nbsp; The<B> format</B> string is described under the
description of the <TT> printf</TT> function.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> cprintf</TT> function returns the number of characters written.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_bprintf">_bprintf</A>, <A HREF="#fprintf">fprintf</A>, <A HREF="#printf">printf</A>, <A HREF="#sprintf">sprintf</A>,
<A HREF="#_vbprintf">_vbprintf</A>, <A HREF="#vcprintf">vcprintf</A>, <A HREF="#vfprintf">vfprintf</A>, <A HREF="#vprintf">vprintf</A>,
<A HREF="#vsprintf">vsprintf</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char *weekday, *month;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int day, year;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; weekday = &quot;Saturday&quot;;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; month = &quot;April&quot;;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; day = 18;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; year = 1987;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; cprintf( &quot;%s, %s %d, %d\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; weekday, month, day, year );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>Saturday, April 18, 1987</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="cputs"> cputs </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>int cputs( const char *buf );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> cputs</TT> function writes the character string pointed to by<B> buf</B> directly to the console using the <TT> putch</TT>
function.&nbsp; Unlike the <TT> puts</TT> function, the carriage-return and line-feed characters are not appended to the string.
&nbsp;The terminating null character is not written.
</DL>
<DL>
<DT>Returns:
<DD>The cputs function returns a non-zero value if an error occurs; otherwise, it returns zero.&nbsp; When an error has occurred,
<TT> errno</TT> contains a value indicating the type of error that has been detected.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#fputs">fputs</A>, <A HREF="#putch">putch</A>, <A HREF="#puts">puts</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char buffer[82];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; buffer[0] = 80;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; cgets( buffer );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; cputs( &amp;buffer[2] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; putch( '\r' );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; putch( '\n' );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="creat"> creat, _creat, _wcreat </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;sys/types.h&gt;</TT>
<BR><TT>#include &lt;sys/stat.h&gt;</TT>
<BR><TT>#include &lt;io.h&gt;</TT>
<BR><TT>int creat( const char *path, mode_t mode );</TT>
<BR><TT>int _creat( const char *path, mode_t mode );</TT>
<BR><TT>int _wcreat( const wchar_t *path, mode_t mode );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> creat</TT> function creates (and opens) a file at the operating system level.&nbsp; It is equivalent to:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; open( path, O_WRONLY | O_CREAT | O_TRUNC, mode );</TT>
<BR><BR>The<TT> _creat</TT> function is identical to<TT> creat</TT>.&nbsp; Use<TT> _creat</TT> for ANSI naming conventions.
<BR><BR>The<TT> _wcreat</TT> function is identical to<TT> creat</TT> except that it accepts a wide character string argument.
<BR><BR>The name of the file to be created is given by<B> path</B>.&nbsp; When the file exists (it must be writeable), it
is truncated to contain no data and the preceding<B> mode</B> setting is unchanged.
<BR><BR>When the file does not exist, it is created with access permissions given by the<B> mode</B> argument.&nbsp; The access
permissions for the file or directory are specified as a combination of bits (defined in the<TT> &lt;sys/stat.h&gt;</TT> header
file).
<BR><BR>The following bits define permissions for the owner.
<DL>
<DT>Permission&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>S_IRWXU
<DD>Read, write, execute/search
<DT>S_IRUSR
<DD>Read permission
<DT>S_IWUSR
<DD>Write permission
<DT>S_IXUSR
<DD>Execute/search permission
</DL>
<BR>The following bits define permissions for the group.
<DL>
<DT>Permission&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>S_IRWXG
<DD>Read, write, execute/search
<DT>S_IRGRP
<DD>Read permission
<DT>S_IWGRP
<DD>Write permission
<DT>S_IXGRP
<DD>Execute/search permission
</DL>
<BR>The following bits define permissions for others.
<DL>
<DT>Permission&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>S_IRWXO
<DD>Read, write, execute/search
<DT>S_IROTH
<DD>Read permission
<DT>S_IWOTH
<DD>Write permission
<DT>S_IXOTH
<DD>Execute/search permission
</DL>
<BR>The following bits define miscellaneous permissions used by other implementations.
<DL>
<DT>Permission&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>S_IREAD
<DD>is equivalent to S_IRUSR (read permission)
<DT>S_IWRITE
<DD>is equivalent to S_IWUSR (write permission)
<DT>S_IEXEC
<DD>is equivalent to S_IXUSR (execute/search permission)
</DL>
<BR>All files are readable with DOS; however, it is a good idea to set<TT> S_IREAD</TT> when read permission is intended for
the file.
</DL>
<DL>
<DT>Returns:
<DD>If successful,<TT> creat</TT> returns a handle for the file.&nbsp; When an error occurs while opening the file, -1 is returned,
and <TT> errno</TT> is set to indicate the error.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>EACCES
<DD>Access denied because<B> path</B> specifies a directory or a volume ID, or a read-only file.
<DT>EMFILE
<DD>No more handles available (too many open files).
<DT>ENOENT
<DD>The specified<B> path</B> does not exist or<B> path</B> is an empty string.
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#chsize">chsize</A>, <A HREF="#close">close</A>, <A HREF="#dup">dup</A>, <A HREF="#dup2">dup2</A>, <A HREF="#eof">eof</A>,
<A HREF="#exec___">exec...</A>, <A HREF="#fdopen">fdopen</A>, <A HREF="#filelength">filelength</A>, <A HREF="#fileno">fileno</A>,
<A HREF="#fstat">fstat</A>, <A HREF="#_grow_handles">_grow_handles</A>, <A HREF="#isatty">isatty</A>, <A HREF="#lseek">lseek</A>,
<A HREF="#open">open</A>, <A HREF="#read">read</A>, <A HREF="#setmode">setmode</A>, <A HREF="#sopen">sopen</A>, <A HREF="#stat">stat</A>,
<A HREF="#tell">tell</A>, <A HREF="#write">write</A>, <A HREF="#umask">umask</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;sys/types.h&gt;</TT>
<BR><TT>#include &lt;sys/stat.h&gt;</TT>
<BR><TT>#include &lt;io.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int handle;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; handle = creat( &quot;file&quot;, S_IWRITE | S_IREAD );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( handle != -1 ) {</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* process file */</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close( handle );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>POSIX 1003.1
<BR><BR>_creat conforms to ANSI naming conventions
<BR>_wcreat is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> creat - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_creat - All, Linux, RDOS, Netware</TT>
<BR><TT>_wcreat - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</TT>
</DL>
<H2 ID="cscanf"> cscanf </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>int cscanf( const char *format, ... );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> cscanf</TT> function scans input from the console under control of the argument<B> format</B>.&nbsp; Following the
format string is a list of addresses to receive values.&nbsp; The<TT> cscanf</TT> function uses the function <TT> getche</TT>
to read characters from the console.&nbsp; The<B> format</B> string is described under the description of the <TT> scanf</TT>
function.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> cscanf</TT> function returns <TT> EOF</TT> when the scanning is terminated by reaching the end of the input stream.
&nbsp;Otherwise, the number of input arguments for which values were successfully scanned and stored is returned.&nbsp; When
a file input error occurs, the <TT> errno</TT> global variable may be set.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#fscanf">fscanf</A>, <A HREF="#scanf">scanf</A>, <A HREF="#sscanf">sscanf</A>, <A HREF="#vcscanf">vcscanf</A>, <A HREF="#vfscanf">vfscanf</A>,
<A HREF="#vscanf">vscanf</A>, <A HREF="#vsscanf">vsscanf</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR>To scan a date in the form &quot;Saturday April 18 1987&quot;:
<BR><BR><TT>#include &lt;conio.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int day, year;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char weekday[10], month[10];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; cscanf( &quot;%s %s %d %d&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; weekday, month, &amp;day, &amp;year );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; cprintf( &quot;\n%s, %s %d, %d\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; weekday, month, day, year );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="ctime"> ctime Functions </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;time.h&gt;</TT>
<BR><TT>char *ctime( const time_t *timer );</TT>
<BR><TT>char *_ctime( const time_t *timer, char *buf );</TT>
<BR><TT>wchar_t *_wctime( const time_t *timer );</TT>
<BR><TT>wchar_t *__wctime( const time_t *timer, wchar_t *buf );</TT>
</DL>
<DL>
<DT>Safer C:
<DD>The Safer C Library extension provides the <A HREF="#ctime_s">ctime_s</A> function which is a safer alternative to<TT> ctime</TT>
This newer<TT> ctime_s</TT> function is recommended to be used instead of the traditional &quot;unsafe&quot;<TT> ctime</TT>
function.
</DL>
<DL>
<DT>Description:
<DD>The<B> ctime</B> functions convert the calendar time pointed to by<B> timer</B> to local time in the form of a string.&nbsp;
The<B> ctime</B> function is equivalent to
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; asctime( localtime( timer ) )</TT>
<BR><BR>The<B> ctime</B> functions convert the time into a string containing exactly 26 characters.&nbsp; This string has
the form shown in the following example:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Sat Mar 21 15:58:27 1987\n\0</TT>
<BR><BR>All fields have a constant width.&nbsp; The new-line character<TT> '\n'</TT> and the null character<TT> '\0'</TT>
occupy the last two positions of the string.
<BR><BR>The ISO C function<B> ctime</B> places the result string in a static buffer that is re-used each time<B> ctime</B>
or <TT> asctime</TT> is called.&nbsp; The non-ISO C function <TT> _ctime</TT> places the result string in the buffer pointed
to by<B> buf</B>.
<BR><BR>The wide-character function <TT> _wctime</TT> is identical to<B> ctime</B> except that it produces a wide-character
string.&nbsp; The wide-character function <TT> __wctime</TT> is identical to <TT> _ctime</TT> except that it produces a wide-character
string.
<BR><BR>Whenever the<B> ctime</B> functions are called, the <TT> tzset</TT> function is also called.
<BR><BR>The calendar time is usually obtained by using the <TT> time</TT> function.&nbsp; That time is Coordinated Universal
Time (UTC) (formerly known as Greenwich Mean Time (GMT)).
<BR><BR>The time set on the computer with the DOS<TT> time</TT> command and the DOS<TT> date</TT> command reflects the local
time.&nbsp; The environment variable<TT> TZ</TT> is used to establish the time zone to which this local time applies.&nbsp;
See the section<B> The TZ Environment Variable</B> for a discussion of how to set the time zone.
</DL>
<DL>
<DT>Returns:
<DD>The<B> ctime</B> functions return the pointer to the string containing the local time.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#asctime">asctime</A> Functions, <A HREF="#asctime_s">asctime_s</A>, <A HREF="#clock">clock</A>, <A HREF="#ctime_s">ctime_s</A>,
<A HREF="#difftime">difftime</A>, <A HREF="#gmtime">gmtime</A>, <A HREF="#gmtime_s">gmtime_s</A>, <A HREF="#localtime">localtime</A>,
<A HREF="#localtime_s">localtime_s</A>, <A HREF="#mktime">mktime</A>, <A HREF="#strftime">strftime</A>, <A HREF="#time">time</A>,
<A HREF="#tzset">tzset</A>, <A HREF="#ctime_s">ctime_s</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;time.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; time_t time_of_day;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; auto char buf[26];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; time_of_day = time( NULL );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;It is now: %s&quot;, _ctime( &amp;time_of_day, buf ) );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>It is now: Fri Dec 25 15:58:42 1987</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>_ctime is WATCOM
<BR>_wctime is WATCOM
<BR>__wctime is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> ctime - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_ctime - All, Linux, RDOS</TT>
<BR><TT>_wctime - All, Linux</TT>
<BR><TT>__wctime - All, Linux</TT>
</DL>
<H2 ID="ctime_s"> ctime_s, _wctime_s </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__ 1</TT>
<BR><TT>#include &lt;time.h&gt;</TT>
<BR><TT>errno_t ctime_s( char * s,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rsize_t maxsize,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const time_t * timer);</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>errno_t _wctime_s( wchar_t * s,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rsize_t
maxsize,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const
time_t * timer);</TT>
</DL>
<DL>
<DT>Constraints:
<DD>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<TT>
ctime_s</TT> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<BR><BR>Neither<B> s</B> nor<B> timer</B> shall be a null pointer.<B>&nbsp; maxsize</B> shall not be less than 26 and shall
not be greater than<B> RSIZE_MAX</B>.&nbsp; If there is a runtime-constraint violation,<B> s[0]</B> is set to a null character
if<B> s</B> is not a null pointer and<B> maxsize</B> is not equal zero and is not greater than<B> RSIZE_MAX</B>.
</DL>
<DL>
<DT>Description:
<DD>The<TT> ctime_s</TT> function converts the calendar time pointed to by<B> timer</B> to local time in the form of a string.
&nbsp;It is equivalent to
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; asctime_s( s, maxsize, localtime_s( timer ) )</TT>
</DL>
<DL>
<DT>Recommended practice:
<DD>
<BR><BR>The<B> strftime</B> function allows more flexible formatting and supports locale-specific behavior.&nbsp; If you do
not require the exact form of the result string produced by the<TT> ctime_s</TT> function, consider using the<B> strftime</B>
function instead.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> ctime_s</TT> function returns zero if there was no runtime-constraint violation.&nbsp; Otherwise, a non-zero value
is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#asctime">asctime</A> Functions, <A HREF="#asctime_s">asctime_s</A>, <A HREF="#clock">clock</A>, <A HREF="#ctime">ctime</A>
Functions, <A HREF="#difftime">difftime</A>, <A HREF="#gmtime">gmtime</A>, <A HREF="#gmtime_s">gmtime_s</A>, <A HREF="#localtime">localtime</A>,
<A HREF="#localtime_s">localtime_s</A>, <A HREF="#mktime">mktime</A>, <A HREF="#strftime">strftime</A>, <A HREF="#time">time</A>,
<A HREF="#tzset">tzset</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__ 1</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;time.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; time_t time_of_day;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; auto char buf[26];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; time_of_day = time( NULL );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ctime_s( buf, sizeof( buf ), &amp;time_of_day );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;It is now: %s&quot;, buf );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>It is now: Mon Jan 30 14:29:55 2006</TT>
</DL>
<DL>
<DT>Classification:
<DD>TR 24731
<BR><BR>_wctime_s is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> ctime_s - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, Linux, RDOS, Netware</TT>
<BR><BR><TT>_wctime_s - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, Linux</TT>
</DL>
<H2 ID="cwait"> cwait, _cwait </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;process.h&gt;</TT>
<BR><TT>int cwait( int *status, int process_id, int action );</TT>
<BR><TT>int _cwait( int *status, int process_id, int action );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> cwait</TT> function suspends the calling process until the specified process terminates.
<BR><BR>If<B> status</B> is not<TT> NULL,</TT> it points to a word that will be filled in with the termination status word
and return code of the terminated child process.
<BR><BR>If the child process terminated normally, then the low order byte of the status word will be set to 0, and the high
order byte will contain the low order byte of the return code that the child process passed to the <TT> DOSEXIT</TT> function.
&nbsp;The <TT> DOSEXIT</TT> function is called whenever <TT> main</TT> returns, or <TT> exit</TT> , or <TT> _Exit</TT> or
<TT> _exit</TT> are explicity called.
<BR><BR>If the child process did not terminate normally, then the high order byte of the status word will be set to 0, and
the low order byte will contain one of the following values:
<DL>
<DT>Value&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>1
<DD>Hard-error abort
<DT>2
<DD>Trap operation
<DT>3
<DD>SIGTERM signal not intercepted
</DL>
<DL>
<DT>Note:
<DD>This implementation of the status value follows the OS/2 model and differs from the Microsoft implementation.&nbsp; Under
Microsoft, the return code is returned in the low order byte and it is not possible to determine whether a return code of
1, 2, or 3 imply that the process terminated normally.&nbsp; For portability to Microsoft compilers, you should ensure that
the application that is waited on does not return one of these values.&nbsp; The following shows how to handle the status
value in a portable manner.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; cwait( &amp;status, process_id, WAIT_CHILD );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #if defined(__WATCOMC__)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; switch( status &amp; 0xff ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; case 0:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Normal termination exit code = %d\n&quot;, status &gt;&gt;
8 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; case 1:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Hard-error abort\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; case 2:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Trap operation\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; case 3:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;SIGTERM signal not intercepted\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; default:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Bogus return status\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #else if defined(_MSC_VER)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; switch( status &amp; 0xff ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; case 1:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Possible Hard-error abort\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; case 2:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Possible Trap operation\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; case 3:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Possible SIGTERM signal not intercepted\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; default:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Normal termination exit code = %d\n&quot;, status );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #endif</TT>
</DL>
<BR>The<B> process_id</B> argument specifies which process to wait for.&nbsp; Under Win32, any process can wait for any other
process for which the process ID is known.&nbsp; Under OS/2, a process can wait for any of its child processes.&nbsp; For
example, a process ID is returned by certain forms of the <TT> spawn...</TT>&nbsp; functions that is used to start a child
process.
<BR><BR>The<B> action</B> argument specifies when the parent process resumes execution.&nbsp; This argument is ignored in
Win32, but is accepted for compatibility with OS/2 (although Microsoft handles the<B> status</B> value differently from OS/2!).
&nbsp;The possible values are:
<DL>
<DT>Value&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>WAIT_CHILD
<DD>Wait until the specified child process has ended.
<DT>WAIT_GRANDCHILD
<DD>Wait until the specified child process and all of the child processes of that child process have ended.
</DL>
<BR>Under Win32, there is no parent-child relationship.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> cwait</TT> function returns the (child's) process ID if the (child) process terminated normally.&nbsp; Otherwise,<TT>
cwait</TT> returns -1 and sets <TT> errno</TT> to one of the following values:
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>EINVAL
<DD>Invalid action code
<DT>ECHILD
<DD>Invalid process ID, or the child does not exist.
<DT>EINTR
<DD>The child process terminated abnormally.
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#exit">exit</A>, <A HREF="#_Exit">_Exit</A>, <A HREF="#_exit">_exit</A>, <A HREF="#spawn___">spawn...</A>, <A HREF="#wait">wait</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;process.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; process_id;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; status;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; process_id = spawnl( P_NOWAIT, &quot;child.exe&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;child&quot;, &quot;parm&quot;,
NULL );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; cwait( &amp;status, process_id, WAIT_CHILD );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> cwait - Win32, OS/2 1.x(all), OS/2-32</TT>
<BR><BR><TT>_cwait - Win32, OS/2 1.x(all), OS/2-32</TT>
</DL>
<H2 ID="delay"> delay </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;i86.h&gt;</TT>
<BR><TT>void delay( unsigned milliseconds );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> delay</TT> function suspends execution by the specified number of<B> milliseconds</B>.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> delay</TT> function has no return value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#sleep">sleep</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;i86.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; sound( 200 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; delay( 500 );&nbsp; /* delay for 1/2 second */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; nosound();</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>All, RDOS, Netware
</DL>
<H2 ID="_dieeetomsbin"> _dieeetomsbin </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>extern int _dieeetomsbin( double *src, double *dest );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _dieeetomsbin</TT> function loads the double pointed to by<B> src</B> in IEEE format and converts it to Microsoft
binary format, storing the result into the double pointed to by<B> dest</B>.
<BR><BR>For<TT> _dieeetomsbin</TT> IEEE Nan's and Infinities will cause overflow.&nbsp; IEEE denormals will be converted if
within range.&nbsp; Otherwise, they will be converted to 0 in the Microsoft binary format.
<BR><BR>The range of Microsoft binary format floats is 2.938736e-39 to 1.701412e+38.&nbsp; The range of Microsoft binary format
doubles is 2.938735877056e-39 to 1.701411834605e+38.
<BR><BR>Microsoft Binary Format was used by early versions of Microsoft QuickBASIC before coprocessors became standard.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _dieeetomsbin</TT> function returns 0 if the conversion was successful.&nbsp; Otherwise, it returns 1 if conversion
would cause an overflow.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_dmsbintoieee">_dmsbintoieee</A>, <A HREF="#_fieeetomsbin">_fieeetomsbin</A>, <A HREF="#_fmsbintoieee">_fmsbintoieee</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; float fieee, fmsb;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; double dieee, dmsb;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; fieee = 0.5;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; dieee = -2.0;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; /* Convert IEEE format to Microsoft binary format */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _fieeetomsbin( &amp;fieee, &amp;fmsb );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _dieeetomsbin( &amp;dieee, &amp;dmsb );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; /* Convert Microsoft binary format back to IEEE format */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _fmsbintoieee( &amp;fmsb, &amp;fieee );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _dmsbintoieee( &amp;dmsb, &amp;dieee );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; /* Display results */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;fieee = %f, dieee = %f\n&quot;, fieee, dieee );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>fieee = 0.500000, dieee = -2.000000</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="difftime"> difftime </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;time.h&gt;</TT>
<BR><TT>double difftime( time_t time1, time_t time0 );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> difftime</TT> function calculates the difference between the two calendar times:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time1 - time0</TT>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> difftime</TT> function returns the difference between the two times in seconds as a<TT> double.</TT>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#asctime">asctime</A> Functions, <A HREF="#asctime_s">asctime_s</A>, <A HREF="#clock">clock</A>, <A HREF="#ctime">ctime</A>
Functions, <A HREF="#ctime_s">ctime_s</A>, <A HREF="#gmtime">gmtime</A>, <A HREF="#gmtime_s">gmtime_s</A>, <A HREF="#localtime">localtime</A>,
<A HREF="#localtime_s">localtime_s</A>, <A HREF="#mktime">mktime</A>, <A HREF="#strftime">strftime</A>, <A HREF="#time">time</A>,
<A HREF="#tzset">tzset</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;time.h&gt;</TT>
<BR><BR><TT>void compute( void );</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; time_t start_time, end_time;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; start_time = time( NULL );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; compute();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; end_time = time( NULL );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Elapsed time: %f seconds\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; difftime( end_time, start_time ) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR><TT>void compute( void )</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int i, j;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; for( i = 1; i &lt;= 20; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( j = 1; j &lt;= 20; j++ )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%3d &quot;, i * j );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD>Math
</DL>
<H2 ID="dirname"> dirname </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;libgen.h&gt;</TT>
<BR><TT>char *dirname( char *path );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> dirname</TT> function takes a pointer to a character string that contains a pathname, and returns a pointer to a string
that is a pathname of the parent directory of that file.&nbsp; Trailing path separators are not considered as part of the
path.
<BR><BR>The<TT> dirname</TT> function may modify the string pointed to by<B> path</B> and may return a pointer to static storage
that may be overwritten by a subsequent call to<TT> dirname</TT>
<BR><BR>The<TT> dirname</TT> function is not re-entrant or thread-safe.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> dirname</TT> function returns a pointer to a string that is the parent directory of<B> path</B>.&nbsp; If<B> path</B>
is a null pointer or points to an empty string, a pointer to the string &quot;.&quot; is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#basename">basename</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;libgen.h&gt;</TT>
<BR><BR><TT>int main( void )</TT>
<BR><TT>{</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; puts( dirname( &quot;/usr/lib&quot; ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; puts( dirname( &quot;/usr/&quot; ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; puts( dirname( &quot;usr&quot; ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; puts( dirname( &quot;/&quot; ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; puts( dirname( &quot;..&quot; ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; return( 0 );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>/usr</TT>
<BR><TT>/</TT>
<BR><TT>.</TT>
<BR><TT>/</TT>
<BR><TT>.</TT>
</DL>
<DL>
<DT>Classification:
<DD>POSIX
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="_disable"> _disable </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;i86.h&gt;</TT>
<BR><TT>void _disable( void );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _disable</TT> function causes interrupts to become disabled.
<BR><BR>The<TT> _disable</TT> function would be used in conjunction with the <TT> _enable</TT> function to make sure that
a sequence of instructions are executed without any intervening interrupts occurring.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _disable</TT> function returns no value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_enable">_enable</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>#include &lt;i86.h&gt;</TT>
<BR><BR><TT>struct list_entry {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct list_entry *next;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp; data;</TT>
<BR><TT>};</TT>
<BR><TT>volatile struct list_entry *ListHead = NULL;</TT>
<BR><TT>volatile struct list_entry *ListTail = NULL;</TT>
<BR><BR><TT>void insert( struct list_entry *new_entry )</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* insert new_entry at end of linked list */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; new_entry-&gt;next = NULL;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _disable();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* disable interrupts */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( ListTail == NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ListHead = new_entry;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ListTail-&gt;next = new_entry;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ListTail = new_entry;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _enable();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* enable interrupts now */</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct list_entry *p;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; for( i = 1; i &lt;= 10; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p = (struct list_entry *)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; malloc( sizeof( struct list_entry ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( p == NULL ) break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p-&gt;data = i;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; insert( p );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="_displaycursor"> _displaycursor </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>short _FAR _displaycursor( short mode );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _displaycursor</TT> function is used to establish whether the text cursor is to be displayed when graphics functions
complete.&nbsp; On entry to a graphics function, the text cursor is turned off.&nbsp; When the function completes, the<B>
mode</B> setting determines whether the cursor is turned back on.&nbsp; The<B> mode</B> argument can have one of the following
values:
<DL>
<DT>_GCURSORON
<DD>the cursor will be displayed
<DT>_GCURSOROFF
<DD>the cursor will not be displayed
</DL>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _displaycursor</TT> function returns the previous setting for<B> mode</B>.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_gettextcursor">_gettextcursor</A>, <A HREF="#_settextcursor">_settextcursor</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char buf[ 80 ];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _TEXTC80 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _settextposition( 2, 1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _displaycursor( _GCURSORON );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _outtext( &quot;Cursor ON\n\nEnter your name &gt;&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; gets( buf );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _displaycursor( _GCURSOROFF );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _settextposition( 6, 1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _outtext( &quot;Cursor OFF\n\nEnter your name &gt;&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; gets( buf );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="div"> div </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>div_t div( int numer, int denom );</TT>
<BR><BR><TT>typedef struct {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int quot;&nbsp;&nbsp;&nbsp;&nbsp; /* quotient */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int rem;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* remainder */</TT>
<BR><TT>} div_t;</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> div</TT> function calculates the quotient and remainder of the division of the numerator<B> numer</B> by the denominator<B>
denom</B>.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> div</TT> function returns a structure of type <TT> div_t</TT> which contains the fields <TT> quot</TT> and <TT> rem</TT>.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#ldiv">ldiv</A>, <A HREF="#lldiv">lldiv</A>, <A HREF="#imaxdiv">imaxdiv</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>void print_time( int seconds )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; div_t&nbsp; min_sec;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; min_sec = div( seconds, 60 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;It took %d minutes and %d seconds\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; min_sec.quot, min_sec.rem );</TT>
<BR><TT>}</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; print_time( 130 );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>It took 2 minutes and 10 seconds</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C90
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="_dmsbintoieee"> _dmsbintoieee </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>extern int _dmsbintoieee( double *src, double *dest );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _dmsbintoieee</TT> function loads the double pointed to by<B> src</B> in Microsoft binary format and converts it to
IEEE format, storing the result into the double pointed to by<B> dest</B>.
<BR><BR>The range of Microsoft binary format floats is 2.938736e-39 to 1.701412e+38.&nbsp; The range of Microsoft binary format
doubles is 2.938735877056e-39 to 1.701411834605e+38.
<BR><BR>Microsoft Binary Format was used by early versions of Microsoft QuickBASIC before coprocessors became standard.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _dmsbintoieee</TT> function returns 0 if the conversion was successful.&nbsp; Otherwise, it returns 1 if conversion
would cause an overflow.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_dieeetomsbin">_dieeetomsbin</A>, <A HREF="#_fieeetomsbin">_fieeetomsbin</A>, <A HREF="#_fmsbintoieee">_fmsbintoieee</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; float fieee, fmsb;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; double dieee, dmsb;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; fieee = 0.5;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; dieee = -2.0;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; /* Convert IEEE format to Microsoft binary format */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _fieeetomsbin( &amp;fieee, &amp;fmsb );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _dieeetomsbin( &amp;dieee, &amp;dmsb );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; /* Convert Microsoft binary format back to IEEE format */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _fmsbintoieee( &amp;fmsb, &amp;fieee );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _dmsbintoieee( &amp;dmsb, &amp;dieee );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; /* Display results */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;fieee = %f, dieee = %f\n&quot;, fieee, dieee );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>fieee = 0.500000, dieee = -2.000000</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="_dos_allocmem"> _dos_allocmem </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><TT>#if defined(__NT__) || \</TT>
<BR><TT>&nbsp; ( defined(__OS2__) &amp;&amp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (defined(__386__) || defined(__PPC__)) )</TT>
<BR><TT>unsigned _dos_allocmem( unsigned size,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; void * *segment);</TT>
<BR><TT>#else</TT>
<BR><TT>unsigned _dos_allocmem( unsigned size,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; unsigned *segment);</TT>
<BR><TT>#endif</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _dos_allocmem</TT> function uses system call 0x48 to allocate<B> size</B> paragraphs directly from DOS.&nbsp; The
size of a paragraph is 16 bytes.&nbsp; The allocated memory is always paragraph aligned.&nbsp; The segment descriptor for
the allocated memory is returned in the word pointed to by<B> segment</B>.&nbsp; If the allocation request fails, the maximum
number of paragraphs that can be allocated is returned in this word instead.
<BR><BR>For 32-bit DOS applications, it is recommended that the corresponding DPMI services be used.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _dos_allocmem</TT> function returns zero if successful.&nbsp; Otherwise, it returns an OS error code and sets <TT>
errno</TT> accordingly.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#alloca">alloca</A>, <A HREF="#calloc">calloc</A>, <A HREF="#_dos_freemem">_dos_freemem</A>, <A HREF="#_dos_setblock">_dos_setblock</A>,
<A HREF="#halloc">halloc</A>, <A HREF="#malloc">malloc</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>#if defined(__NT__) || \</TT>
<BR><TT>&nbsp; ( defined(__OS2__) &amp;&amp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (defined(__386__) || defined(__PPC__)) )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; void *segment;</TT>
<BR><TT>#else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned segment;</TT>
<BR><TT>#endif</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; /* Try to allocate 100 paragraphs, then free them */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( _dos_allocmem( 100, &amp;segment ) != 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;_dos_allocmem failed\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Only %u paragraphs available\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; segment );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;_dos_allocmem succeeded\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( _dos_freemem( segment ) != 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;_dos_freemem failed\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;_dos_freemem succeeded\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>DOS
</DL>
<DL>
<DT>Systems:
<DD>DOS, Win32, OS/2 1.x(all), OS/2-32, DOS/PM
</DL>
<H2 ID="_dos_close"> _dos_close </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><TT>unsigned _dos_close( int handle );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _dos_close</TT> function uses system call 0x3E to close the file indicated by<B> handle</B>.&nbsp; The value for<B>
handle</B> is the one returned by a function call that created or last opened the file.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _dos_close</TT> function returns zero if successful.&nbsp; Otherwise, it returns an OS error code and sets <TT> errno</TT>
accordingly.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#creat">creat</A>, <A HREF="#_dos_creat">_dos_creat</A>, <A HREF="#_dos_creatnew">_dos_creatnew</A>, <A HREF="#_dos_open">_dos_open</A>,
<A HREF="#dup">dup</A>, <A HREF="#fclose">fclose</A>, <A HREF="#open">open</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><TT>#include &lt;fcntl.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int handle;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; /* Try to open &quot;stdio.h&quot; and then close it */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( _dos_open( &quot;stdio.h&quot;, O_RDONLY, &amp;handle ) != 0 ){</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Unable to open file\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Open succeeded\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( _dos_close( handle ) != 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Close failed\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Close succeeded\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>DOS
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, DOS/PM
</DL>
<H2 ID="_dos_commit"> _dos_commit </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><TT>unsigned _dos_commit( int handle );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _dos_commit</TT> function uses system call 0x68 to flush to disk the DOS buffers associated with the file indicated
by<B> handle</B>.&nbsp; It also forces an update on the corresponding disk directory and the file allocation table.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _dos_commit</TT> function returns zero if successful.&nbsp; Otherwise, it returns an OS error code and sets <TT> errno</TT>
accordingly.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_dos_close">_dos_close</A>, <A HREF="#_dos_creat">_dos_creat</A>, <A HREF="#_dos_open">_dos_open</A>, <A HREF="#_dos_write">_dos_write</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><TT>#include &lt;fcntl.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int handle;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; if( _dos_open( &quot;file&quot;, O_RDONLY, handle ) != 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Unable to open file\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( _dos_commit( handle ) == 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Commit succeeded.\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _dos_close( handle );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>Commit succeeded.</TT>
</DL>
<DL>
<DT>Classification:
<DD>DOS
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, DOS/PM
</DL>
<H2 ID="_dos_creat"> _dos_creat </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><TT>unsigned _dos_creat( const char *path,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;unsigned attribute,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;int *handle );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _dos_creat</TT> function uses system call 0x3C to create a new file named<B> path</B>, with the access attributes
specified by<B> attribute</B>.&nbsp; The handle for the new file is returned in the word pointed to by<B> handle</B>.&nbsp;
If the file already exists, the contents will be erased, and the attributes of the file will remain unchanged.&nbsp; The possible
values for<B> attribute</B> are:
<DL>
<DT>Attribute&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>_A_NORMAL
<DD>Indicates a normal file.&nbsp; File can be read or written without any restrictions.
<DT>_A_RDONLY
<DD>Indicates a read-only file.&nbsp; File cannot be opened for &quot;write&quot;.
<DT>_A_HIDDEN
<DD>Indicates a hidden file.&nbsp; This file will not show up in a normal directory search.
<DT>_A_SYSTEM
<DD>Indicates a system file.&nbsp; This file will not show up in a normal directory search.
</DL>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _dos_creat</TT> function returns zero if successful.&nbsp; Otherwise, it returns an OS error code and sets <TT> errno</TT>
accordingly.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#creat">creat</A>, <A HREF="#_dos_creatnew">_dos_creatnew</A>, <A HREF="#_dos_open">_dos_open</A>, <A HREF="#_dos_open">_dos_open</A>,
<A HREF="#open">open</A>, <A HREF="#fdopen">fdopen</A>, <A HREF="#fopen">fopen</A>, <A HREF="#freopen">freopen</A>, <A HREF="#_fsopen">_fsopen</A>,
<A HREF="#_grow_handles">_grow_handles</A>, <A HREF="#_hdopen">_hdopen</A>, <A HREF="#open">open</A>, <A HREF="#_open_osfhandle">_open_osfhandle</A>,
<A HREF="#_popen">_popen</A>, <A HREF="#sopen">sopen</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int handle;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; if( _dos_creat( &quot;file&quot;, _A_NORMAL, &amp;handle ) != 0 ){</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Unable to create file\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Create succeeded\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _dos_close( handle );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>DOS
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, DOS/PM
</DL>
<H2 ID="_dos_creatnew"> _dos_creatnew </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><TT>unsigned _dos_creatnew( const char *path,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; unsigned attribute,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; int *handle );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _dos_creatnew</TT> function uses system call 0x5B to create a new file named<B> path</B>, with the access attributes
specified by<B> attribute</B>.&nbsp; The handle for the new file is returned in the word pointed to by<B> handle</B>.&nbsp;
If the file already exists, the create will fail.&nbsp; The possible values for<B> attribute</B> are:
<DL>
<DT>Attribute&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>_A_NORMAL
<DD>Indicates a normal file.&nbsp; File can be read or written without any restrictions.
<DT>_A_RDONLY
<DD>Indicates a read-only file.&nbsp; File cannot be opened for &quot;write&quot;.
<DT>_A_HIDDEN
<DD>Indicates a hidden file.&nbsp; This file will not show up in a normal directory search.
<DT>_A_SYSTEM
<DD>Indicates a system file.&nbsp; This file will not show up in a normal directory search.
</DL>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _dos_creatnew</TT> function returns zero if successful.&nbsp; Otherwise, it returns an OS error code and sets <TT>
errno</TT>.&nbsp; Possible values and their interpretations:
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>EACCES
<DD>Access denied because the directory is full, or the file exists and cannot be overwritten.
<DT>EEXIST
<DD>File already exists
<DT>EMFILE
<DD>No more handles available (i.e., too many open files)
<DT>ENOENT
<DD>Path or file not found
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#creat">creat</A>, <A HREF="#_dos_creat">_dos_creat</A>, <A HREF="#_dos_open">_dos_open</A>, <A HREF="#_dos_open">_dos_open</A>,
<A HREF="#open">open</A>, <A HREF="#fdopen">fdopen</A>, <A HREF="#fopen">fopen</A>, <A HREF="#freopen">freopen</A>, <A HREF="#_fsopen">_fsopen</A>,
<A HREF="#_grow_handles">_grow_handles</A>, <A HREF="#_hdopen">_hdopen</A>, <A HREF="#open">open</A>, <A HREF="#_open_osfhandle">_open_osfhandle</A>,
<A HREF="#_popen">_popen</A>, <A HREF="#sopen">sopen</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int handle1, handle2;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( _dos_creat( &quot;file&quot;, _A_NORMAL, &amp;handle1 ) ){</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Unable to create file\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Create succeeded\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( _dos_creatnew( &quot;file&quot;, _A_NORMAL, &amp;handle2 ) ){</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Unable to create new file\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _dos_close( handle1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>DOS
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, DOS/PM
</DL>
<H2 ID="dosexterr"> dosexterr </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><TT>int dosexterr( struct DOSERROR *err_info );</TT>
<BR><BR><TT>struct _DOSERROR {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int exterror;&nbsp;&nbsp; /* contents of AX register */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char errclass;&nbsp; /* contents of BH register */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char action;&nbsp;&nbsp;&nbsp; /* contents of BL register */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char locus;&nbsp;&nbsp;&nbsp;&nbsp; /* contents of CH register */</TT>
<BR><TT>};</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> dosexterr</TT> function extracts extended error information following a failed DOS function.&nbsp; This information
is placed in the structure located by<B> err_info</B>.&nbsp; This function is only useful with DOS version 3.0 or later.
<BR><BR>You should consult the technical documentation for the DOS system on your computer for an interpretation of the error
information.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> dosexterr</TT> function returns an unpredictable result when the preceding DOS call did not result in an error.&nbsp;
Otherwise,<TT> dosexterr</TT> returns the number of the extended error.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#perror">perror</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><TT>#include &lt;fcntl.h&gt;</TT>
<BR><BR><TT>struct _DOSERROR dos_err;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int handle;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; /* Try to open &quot;stdio.h&quot; and then close it */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( _dos_open( &quot;stdio.h&quot;, O_RDONLY, &amp;handle ) != 0 ){</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dosexterr( &amp;dos_err );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Unable to open file\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;exterror (AX) = %d\n&quot;, dos_err.exterror );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;errclass (BH) = %d\n&quot;, dos_err.errclass );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;action&nbsp;&nbsp; (BL) = %d\n&quot;, dos_err.action );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;locus&nbsp;&nbsp;&nbsp; (CH) = %d\n&quot;, dos_err.locus );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Open succeeded\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( _dos_close( handle ) != 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Close failed\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Close succeeded\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>Unable to open file</TT>
<BR><TT>exterror (AX) = 2</TT>
<BR><TT>errclass (BH) = 8</TT>
<BR><TT>action&nbsp;&nbsp; (BL) = 3</TT>
<BR><TT>locus&nbsp;&nbsp;&nbsp; (CH) = 2</TT>
</DL>
<DL>
<DT>Classification:
<DD>DOS
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, DOS/PM
</DL>
<H2 ID="_dos_find___"> _dos_find...&nbsp; Functions </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><TT>unsigned _dos_findfirst( const char *path,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; unsigned attributes,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; struct find_t *buffer );</TT>
<BR><TT>unsigned _dos_findnext(&nbsp; struct find_t *buffer );</TT>
<BR><TT>unsigned _dos_findclose( struct find_t *buffer );</TT>
<BR><BR><TT>struct find_t {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char reserved[21];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* reserved for use by DOS&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char attrib;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* attribute byte
for file&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned short wr_time; /* time of last write to file*/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned short wr_date; /* date of last write to file*/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned long&nbsp; size;&nbsp;&nbsp;&nbsp; /* length of file in bytes&nbsp;&nbsp; */</TT>
<BR><TT>#if defined(__OS2__) || defined(__NT__)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char name[256];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* null-terminated filename&nbsp;
*/</TT>
<BR><TT>#else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char name[13];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* null-terminated filename
&nbsp;*/</TT>
<BR><TT>#endif</TT>
<BR><TT>};</TT>
<BR><TT>unsigned _wdos_findfirst( const wchar_t *path,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned attributes,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct _wfind_t *buffer );</TT>
<BR><TT>unsigned _wdos_findnext( struct _wfind_t *buffer );</TT>
<BR><TT>unsigned _wdos_findclose( struct _wfind_t *buffer );</TT>
<BR><BR><TT>struct _wfind_t {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char reserved[21];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* reserved for use by DOS&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char attrib;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* attribute byte
for file&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned short wr_time; /* time of last write to file */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned short wr_date; /* date of last write to file */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned long&nbsp; size;&nbsp;&nbsp;&nbsp; /* length of file in bytes&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>#if defined(__OS2__) || defined(__NT__)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; wchar_t name[256];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* null-terminated filename&nbsp;&nbsp; */</TT>
<BR><TT>#else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; wchar_t name[13];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* null-terminated filename&nbsp;&nbsp; */</TT>
<BR><TT>#endif</TT>
<BR><TT>};</TT>
</DL>
<DL>
<DT>Description:
<DD>The <TT> _dos_findfirst</TT> function uses system call 0x4E to return information on the first file whose name and attributes
match the<B> path</B> and<B> attributes</B> arguments.&nbsp; The information is returned in a <TT> find_t</TT> structure pointed
to by<B> buffer</B>.&nbsp; The<B> path</B> argument may contain wildcard characters ('?' and '*').&nbsp; The<B> attributes</B>
argument may be any combination of the following constants:
<DL>
<DT>Attribute&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>_A_NORMAL
<DD>Indicates a normal file.&nbsp; File can be read or written without any restrictions.
<DT>_A_RDONLY
<DD>Indicates a read-only file.&nbsp; File cannot be opened for &quot;write&quot;.
<DT>_A_HIDDEN
<DD>Indicates a hidden file.&nbsp; This file will not show up in a normal directory search.
<DT>_A_SYSTEM
<DD>Indicates a system file.&nbsp; This file will not show up in a normal directory search.
<DT>_A_VOLID
<DD>Indicates a volume-ID.
<DT>_A_SUBDIR
<DD>Indicates a sub-directory.
<DT>_A_ARCH
<DD>This is the archive flag.&nbsp; It is set whenever the file is modified, and is cleared by the MS-DOS BACKUP command and other
backup utility programs.
</DL>
<BR>The<B> attributes</B> argument is interpreted by DOS as follows:
<OL>
<LI>If <TT> _A_NORMAL</TT> is specified, then normal files are included in the search.
<LI>If any of <TT> _A_HIDDEN</TT>, <TT> _A_SYSTEM</TT>, <TT> _A_SUBDIR</TT> are specified, then normal files and the specified
type of files are included in the search.
<LI>If <TT> _A_VOLID</TT> is specified, then volume-ID's are also included in the search.&nbsp; Note:&nbsp; The <TT> _A_VOLID</TT>
attribute is not supported on systems other than DOS (e.g.&nbsp; Win32, OS/2).
<LI><TT> _A_RDONLY</TT> and <TT> _A_ARCH</TT> are ignored by this function.
</OL>
<BR>The format of the <TT> wr_time</TT> field is described by the following structure (this structure is not defined in any
Open Watcom header file).
<BR><BR><TT>typedef struct {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; twosecs : 5;&nbsp;&nbsp;&nbsp; /* seconds / 2 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; minutes : 6;&nbsp;&nbsp;&nbsp; /* minutes (0,59) */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; hours&nbsp;&nbsp; : 5;&nbsp;&nbsp;&nbsp; /* hours (0,23) */</TT>
<BR><TT>} ftime_t;</TT>
<BR>The format of the <TT> wr_date</TT> field is described by the following structure (this structure is not defined in any
Open Watcom header file).
<BR><BR><TT>typedef struct {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; day&nbsp;&nbsp;&nbsp;&nbsp; : 5;&nbsp;&nbsp;&nbsp; /* day (1,31) */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; month&nbsp;&nbsp; : 4;&nbsp;&nbsp;&nbsp; /* month (1,12) */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; year&nbsp;&nbsp;&nbsp; : 7;&nbsp;&nbsp;&nbsp; /* 0 is 1980 */</TT>
<BR><TT>} fdate_t;</TT>
<BR>The <TT> _dos_findnext</TT> function uses system call 0x4F to return information on the next file whose name and attributes
match the pattern supplied to the <TT> _dos_findfirst</TT> function.
<BR><BR>On some systems (e.g.&nbsp; Win32, OS/2), you must call <TT> _dos_findclose</TT> to indicate that you are done matching
files.&nbsp; This function deallocates any resources that were allocated by the <TT> _dos_findfirst</TT> function.
<BR><BR>The<TT> _wdos_find...</TT>&nbsp; functions are similar to their counterparts but operate on wide-character strings.
</DL>
<DL>
<DT>Returns:
<DD>The <TT> _dos_find...</TT>&nbsp; functions return zero if successful.&nbsp; Otherwise, the <TT> _dos_findfirst</TT> and <TT>
_dos_findnext</TT> functions return an OS error code and set <TT> errno</TT> accordingly.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#opendir">opendir</A>, <A HREF="#readdir">readdir</A>, <A HREF="#closedir">closedir</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct find_t&nbsp;&nbsp; fileinfo;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;/* return code */</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; /* Display name and size of &quot;*.c&quot; files */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; rc = _dos_findfirst( &quot;*.c&quot;, _A_NORMAL, &amp;fileinfo );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; while( rc == 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%14s %10ld\n&quot;, fileinfo.name,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fileinfo.size );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc = _dos_findnext( &amp;fileinfo );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; #if defined(__OS2__)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _dos_findclose( &amp;fileinfo );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; #endif</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>DOS
</DL>
<DL>
<DT>Systems:
<DD><TT> _dos_findclose - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, DOS/PM</TT>
<BR><BR><TT>_dos_findfirst - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, DOS/PM</TT>
<BR><TT>_dos_findnext - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, DOS/PM</TT>
<BR><TT>_wdos_findclose - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</TT>
<BR><TT>_wdos_findfirst - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</TT>
<BR><TT>_wdos_findnext - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</TT>
</DL>
<H2 ID="_dos_freemem"> _dos_freemem </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><TT>#if defined(__NT__) || \</TT>
<BR><TT>&nbsp; ( defined(__OS2__) &amp;&amp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (defined(__386__) || defined(__PPC__)) )</TT>
<BR><TT>unsigned _dos_freemem( void *&nbsp;&nbsp; segment );</TT>
<BR><TT>#else</TT>
<BR><TT>unsigned _dos_freemem( unsigned segment );</TT>
<BR><TT>#endif</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _dos_freemem</TT> function uses system call 0x49 to release memory that was previously allocated by <TT> _dos_allocmem</TT>.
&nbsp;The value contained in<B> segment</B> is the one returned by a previous call to <TT> _dos_allocmem</TT>.
<BR><BR>For 32-bit DOS applications, it is recommended that the corresponding DPMI services be used.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _dos_freemem</TT> function returns zero if successful.&nbsp; Otherwise, it returns an OS error code and sets <TT>
errno</TT> accordingly.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_dos_allocmem">_dos_allocmem</A>, <A HREF="#_dos_setblock">_dos_setblock</A>, <A HREF="#free">free</A>, <A HREF="#hfree">hfree</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>#if defined(__NT__) || \</TT>
<BR><TT>&nbsp; ( defined(__OS2__) &amp;&amp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (defined(__386__) || defined(__PPC__)) )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; void *segment;</TT>
<BR><TT>#else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned segment;</TT>
<BR><TT>#endif</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; /* Try to allocate 100 paragraphs, then free them */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( _dos_allocmem( 100, &amp;segment ) != 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;_dos_allocmem failed\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Only %u paragraphs available\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; segment );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;_dos_allocmem succeeded\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( _dos_freemem( segment ) != 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;_dos_freemem failed\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;_dos_freemem succeeded\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>DOS
</DL>
<DL>
<DT>Systems:
<DD>DOS, Win32, OS/2 1.x(all), OS/2-32, DOS/PM
</DL>
<H2 ID="_dos_getdate"> _dos_getdate </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><TT>void _dos_getdate( struct dosdate_t *date );</TT>
<BR><BR><TT>struct dosdate_t {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char day;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* 1-31 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char month;&nbsp;&nbsp;&nbsp; /* 1-12 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned short year;&nbsp;&nbsp;&nbsp; /* 1980-2099 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char dayofweek;/* 0-6 (0=Sunday) */</TT>
<BR><TT>};</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _dos_getdate</TT> function uses system call 0x2A to get the current system date.&nbsp; The date information is returned
in a <TT> dosdate_t</TT> structure pointed to by<B> date</B>.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _dos_getdate</TT> function has no return value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_dos_gettime">_dos_gettime</A>, <A HREF="#_dos_setdate">_dos_setdate</A>, <A HREF="#_dos_settime">_dos_settime</A>,
<A HREF="#gmtime">gmtime</A>, <A HREF="#localtime">localtime</A>, <A HREF="#mktime">mktime</A>, <A HREF="#time">time</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct dosdate_t date;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct dostime_t time;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; /* Get and display the current date and time */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _dos_getdate( &amp;date );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _dos_gettime( &amp;time );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;The date (MM-DD-YYYY) is: %d-%d-%d\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; date.month,
date.day, date.year );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;The time (HH:MM:SS) is: %.2d:%.2d:%.2d\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time.hour,
time.minute, time.second );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>The date (MM-DD-YYYY) is: 12-25-1989</TT>
<BR><TT>The time (HH:MM:SS) is: 14:23:57</TT>
</DL>
<DL>
<DT>Classification:
<DD>DOS
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, DOS/PM
</DL>
<H2 ID="_dos_getdiskfree"> _dos_getdiskfree </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><TT>unsigned _dos_getdiskfree( unsigned drive,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; struct diskfree_t *diskspace );</TT>
<BR><TT>struct diskfree_t {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned short total_clusters;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned short avail_clusters;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned short sectors_per_cluster;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned short bytes_per_sector;</TT>
<BR><TT>};</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _dos_getdiskfree</TT> function uses system call 0x36 to obtain useful information on the disk drive specified by<B>
drive</B>.&nbsp; Specify 0 for the default drive, 1 for drive A, 2 for drive B, etc.&nbsp; The information about the drive
is returned in the structure <TT> diskfree_t</TT> pointed to by<B> diskspace</B>.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _dos_getdiskfree</TT> function returns zero if successful.&nbsp; Otherwise, it returns a non-zero value and sets <TT>
errno</TT> to <TT> EINVAL</TT> indicating an invalid drive was specified.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_dos_getdrive">_dos_getdrive</A>, <A HREF="#_dos_setdrive">_dos_setdrive</A>, <A HREF="#_getdiskfree">_getdiskfree</A>,
<A HREF="#_getdrive">_getdrive</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct diskfree_t disk_data;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; /* get information about drive 3 (the C drive) */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( _dos_getdiskfree( 3, &amp;disk_data ) == 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;total clusters: %u\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; disk_data.total_clusters );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;available clusters: %u\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; disk_data.avail_clusters );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;sectors/cluster: %u\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; disk_data.sectors_per_cluster );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;bytes per sector: %u\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; disk_data.bytes_per_sector );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Invalid drive specified\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>total clusters: 16335</TT>
<BR><TT>available clusters: 510</TT>
<BR><TT>sectors/cluster: 4</TT>
<BR><TT>bytes per sector: 512</TT>
</DL>
<DL>
<DT>Classification:
<DD>DOS
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, DOS/PM
</DL>
<H2 ID="_dos_getdrive"> _dos_getdrive </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><TT>void _dos_getdrive( unsigned *drive );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _dos_getdrive</TT> function uses system call 0x19 to get the current disk drive number.&nbsp; The current disk drive
number is returned in the word pointed to by<B> drive</B>.&nbsp; A value of 1 is drive A, 2 is drive B, 3 is drive C, etc.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _dos_getdrive</TT> function has no return value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_dos_getdiskfree">_dos_getdiskfree</A>, <A HREF="#_dos_setdrive">_dos_setdrive</A>, <A HREF="#_getdiskfree">_getdiskfree</A>,
<A HREF="#_getdrive">_getdrive</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned drive;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _dos_getdrive( &amp;drive );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;The current drive is %c\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'A' + drive - 1 );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>The current drive is C</TT>
</DL>
<DL>
<DT>Classification:
<DD>DOS
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, DOS/PM
</DL>
<H2 ID="_dos_getfileattr"> _dos_getfileattr </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><TT>unsigned _dos_getfileattr( const char *path,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned *attributes );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _dos_getfileattr</TT> function uses system call 0x43 to get the current attributes of the file or directory that<B>
path</B> points to.&nbsp; The possible attributes are:
<DL>
<DT>Attribute&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>_A_NORMAL
<DD>Indicates a normal file.&nbsp; File can be read or written without any restrictions.
<DT>_A_RDONLY
<DD>Indicates a read-only file.&nbsp; File cannot be opened for &quot;write&quot;.
<DT>_A_HIDDEN
<DD>Indicates a hidden file.&nbsp; This file will not show up in a normal directory search.
<DT>_A_SYSTEM
<DD>Indicates a system file.&nbsp; This file will not show up in a normal directory search.
<DT>_A_VOLID
<DD>Indicates a volume-ID.
<DT>_A_SUBDIR
<DD>Indicates a sub-directory.
<DT>_A_ARCH
<DD>This is the archive flag.&nbsp; It is set whenever the file is modified, and is cleared by the MS-DOS BACKUP command and other
backup utility programs.
</DL>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _dos_getfileattr</TT> function returns zero if successful.&nbsp; Otherwise, it returns an OS error code and sets <TT>
errno</TT> accordingly.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_dos_setfileattr">_dos_setfileattr</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><BR><TT>print_attribute()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned attribute;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _dos_getfileattr( &quot;file&quot;, &amp;attribute );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;File attribute is %d\n&quot;, attribute );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( attribute &amp; _A_RDONLY ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;This is a read-only file.\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;This is not a read-only file.\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handle;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; if( _dos_creat( &quot;file&quot;, _A_RDONLY, &amp;handle ) != 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Error creating file\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; print_attribute();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _dos_setfileattr( &quot;file&quot;, _A_NORMAL );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; print_attribute();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _dos_close( handle );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>DOS
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, DOS/PM
</DL>
<H2 ID="_dos_getftime"> _dos_getftime </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><TT>unsigned _dos_getftime( int handle,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; unsigned *date,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; unsigned *time );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _dos_getftime</TT> function uses system call 0x57 to get the date and time that the file associated with<B> handle</B>
was last modified.&nbsp; The date consists of the year, month and day packed into 16 bits as follows:
<DL>
<DT>Bits&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>bits 0-4
<DD>Day (1-31)
<DT>bits 5-8
<DD>Month (1-12)
<DT>bits 9-15
<DD>Year (0-119 representing 1980-2099)
</DL>
<BR>The time consists of the hour, minute and seconds/2 packed into 16 bits as follows:
<DL>
<DT>Bits&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>bits 0-4
<DD>Seconds/2 (0-29)
<DT>bits 5-10
<DD>Minutes (0-59)
<DT>bits 11-15
<DD>Hours (0-23)
</DL>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _dos_getftime</TT> function returns zero if successful.&nbsp; Otherwise, it returns an OS error code and sets <TT>
errno</TT> accordingly.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_dos_setftime">_dos_setftime</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><TT>#include &lt;fcntl.h&gt;</TT>
<BR><BR><TT>#define YEAR(t)&nbsp;&nbsp; (((t &amp; 0xFE00) &gt;&gt; 9) + 1980)</TT>
<BR><TT>#define MONTH(t)&nbsp; ((t &amp; 0x01E0) &gt;&gt; 5)</TT>
<BR><TT>#define DAY(t)&nbsp;&nbsp;&nbsp; (t &amp; 0x001F)</TT>
<BR><TT>#define HOUR(t)&nbsp;&nbsp; ((t &amp; 0xF800) &gt;&gt; 11)</TT>
<BR><TT>#define MINUTE(t) ((t &amp; 0x07E0) &gt;&gt; 5)</TT>
<BR><TT>#define SECOND(t) ((t &amp; 0x001F) &lt;&lt; 1)</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handle;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned date, time;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; if( _dos_open( &quot;file&quot;, O_RDONLY, &amp;handle ) != 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Unable to open file\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Open succeeded\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _dos_getftime( handle, &amp;date, &amp;time );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;The file was last modified on %d/%d/%d&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MONTH(date), DAY(date),
YEAR(date) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot; at %.2d:%.2d:%.2d\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HOUR(time), MINUTE(time),
SECOND(time) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _dos_close( handle );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>Open succeeded</TT>
<BR><TT>The file was last modified on 12/29/1989 at 14:32:46</TT>
</DL>
<DL>
<DT>Classification:
<DD>DOS
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, DOS/PM
</DL>
<H2 ID="_dos_gettime"> _dos_gettime </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><TT>void _dos_gettime( struct dostime_t *time );</TT>
<BR><BR><TT>struct dostime_t {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char hour;&nbsp;&nbsp;&nbsp;&nbsp; /* 0-23 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char minute;&nbsp;&nbsp; /* 0-59 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char second;&nbsp;&nbsp; /* 0-59 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char hsecond;&nbsp; /* 1/100 second; 0-99 */</TT>
<BR><TT>};</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _dos_gettime</TT> function uses system call 0x2C to get the current system time.&nbsp; The time information is returned
in a <TT> dostime_t</TT> structure pointed to by<B> time</B>.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _dos_gettime</TT> function has no return value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_dos_getdate">_dos_getdate</A>, <A HREF="#_dos_setdate">_dos_setdate</A>, <A HREF="#_dos_settime">_dos_settime</A>,
<A HREF="#gmtime">gmtime</A>, <A HREF="#localtime">localtime</A>, <A HREF="#mktime">mktime</A>, <A HREF="#time">time</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct dosdate_t date;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct dostime_t time;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; /* Get and display the current date and time */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _dos_getdate( &amp;date );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _dos_gettime( &amp;time );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;The date (MM-DD-YYYY) is: %d-%d-%d\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; date.month, date.day, date.year );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;The time (HH:MM:SS) is: %.2d:%.2d:%.2d\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time.hour, time.minute, time.second );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>The date (MM-DD-YYYY) is: 12-25-1989</TT>
<BR><TT>The time (HH:MM:SS) is: 14:23:57</TT>
</DL>
<DL>
<DT>Classification:
<DD>DOS
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, DOS/PM
</DL>
<H2 ID="_dos_getvect"> _dos_getvect </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><TT>void (__interrupt __far *_dos_getvect(unsigned intnum))();</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _dos_getvect</TT> function gets the current value of interrupt vector number<B> intnum</B>.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _dos_getvect</TT> function returns a far pointer to the current interrupt handler for interrupt number<B> intnum</B>.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_chain_intr">_chain_intr</A>, <A HREF="#_dos_keep">_dos_keep</A>, <A HREF="#_dos_setvect">_dos_setvect</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><BR><TT>volatile int clock_ticks;</TT>
<BR><TT>void (__interrupt __far *prev_int_1c)();</TT>
<BR><TT>#define BLIP_COUNT&nbsp; (5*18)&nbsp; /* 5 seconds */</TT>
<BR><BR><TT>void __interrupt __far timer_rtn()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ++clock_ticks;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _chain_intr( prev_int_1c );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR><TT>int delays = 0;</TT>
<BR><BR><TT>int compile_a_line()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( delays &gt; 15 ) return( 0 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; delay( 1000 );&nbsp; /* delay for 1 second */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Delayed for 1 second\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; delays++;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; return( 1 );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; prev_int_1c = _dos_getvect( 0x1c );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _dos_setvect( 0x1c, timer_rtn );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; while( compile_a_line() ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( clock_ticks &gt;= BLIP_COUNT ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; putchar( '.' );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clock_ticks -= BLIP_COUNT;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _dos_setvect( 0x1c, prev_int_1c );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, DOS/PM
</DL>
<H2 ID="_dos_keep"> _dos_keep </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><TT>void _dos_keep( unsigned retcode, unsigned memsize );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _dos_keep</TT> function is used to install terminate-and-stay-resident programs (&quot;TSR's&quot;) in memory.&nbsp;
The amount of memory kept for the program is<B> memsize</B> paragraphs (a paragraph is 16 bytes) from the Program Segment
Prefix which is stored in the variable <TT> _psp</TT>.&nbsp; The value of<B> retcode</B> is returned to the parent process.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _dos_keep</TT> function does not return to its caller.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_chain_intr">_chain_intr</A>, <A HREF="#_dos_getvect">_dos_getvect</A>, <A HREF="#_dos_setvect">_dos_setvect</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><BR><TT>void permanent()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* . */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* . */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* . */</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR><TT>void transient()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* . */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* . */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* . */</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* initialize our TSR */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; transient();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /*</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; now terminate and keep resident</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the non-transient portion</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _dos_keep( 0, (FP_OFF( transient ) + 15) &gt;&gt; 4 );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>DOS
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_dos_open"> _dos_open </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><TT>#include &lt;fcntl.h&gt;</TT>
<BR><TT>#include &lt;share.h&gt;</TT>
<BR><TT>unsigned _dos_open( const char *path,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
unsigned mode,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
int *handle );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _dos_open</TT> function uses system call 0x3D to open the file specified by<B> path</B>, which must be an existing
file.&nbsp; The<B> mode</B> argument specifies the file's access, sharing and inheritance permissions.&nbsp; The access mode
must be one of:
<DL>
<DT>Mode&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>O_RDONLY
<DD>Read only
<DT>O_WRONLY
<DD>Write only
<DT>O_RDWR
<DD>Both read and write
</DL>
<BR>The sharing permissions, if specified, must be one of:
<DL>
<DT>Permission&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>SH_COMPAT
<DD>Set compatibility mode.
<DT>SH_DENYRW
<DD>Prevent read or write access to the file.
<DT>SH_DENYWR
<DD>Prevent write access of the file.
<DT>SH_DENYRD
<DD>Prevent read access to the file.
<DT>SH_DENYNO
<DD>Permit both read and write access to the file.
</DL>
<BR>The inheritance permission, if specified, is:
<DL>
<DT>Permission&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>O_NOINHERIT
<DD>File is not inherited by a child process
</DL>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _dos_open</TT> function returns zero if successful.&nbsp; Otherwise, it returns an MS-DOS error code and sets <TT>
errno</TT> to one of the following values:
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>EACCES
<DD>Access denied because<B> path</B> specifies a directory or a volume ID, or opening a read-only file for write access
<DT>EINVAL
<DD>A sharing mode was specified when file sharing is not installed, or access-mode value is invalid
<DT>EMFILE
<DD>No more handles available, (too many open files)
<DT>ENOENT
<DD>Path or file not found
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_dos_close">_dos_close</A>, <A HREF="#_dos_creat">_dos_creat</A>, <A HREF="#_dos_creatnew">_dos_creatnew</A>, <A HREF="#_dos_read">_dos_read</A>,
<A HREF="#_dos_write">_dos_write</A>, <A HREF="#fdopen">fdopen</A>, <A HREF="#fopen">fopen</A>, <A HREF="#freopen">freopen</A>,
<A HREF="#_fsopen">_fsopen</A>, <A HREF="#_grow_handles">_grow_handles</A>, <A HREF="#_hdopen">_hdopen</A>, <A HREF="#open">open</A>,
<A HREF="#_open_osfhandle">_open_osfhandle</A>, <A HREF="#_popen">_popen</A>, <A HREF="#sopen">sopen</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><TT>#include &lt;fcntl.h&gt;</TT>
<BR><TT>#include &lt;share.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int handle;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; if( _dos_open( &quot;file&quot;, O_RDONLY, &amp;handle ) != 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Unable to open file\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Open succeeded\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _dos_close( handle );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>DOS
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, DOS/PM
</DL>
<H2 ID="_dos_read"> _dos_read </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><TT>unsigned _dos_read( int handle, void __far *buffer,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
unsigned count, unsigned *bytes );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _dos_read</TT> function uses system call 0x3F to read<B> count</B> bytes of data from the file specified by<B> handle</B>
into the buffer pointed to by<B> buffer</B>.&nbsp; The number of bytes successfully read will be stored in the unsigned integer
pointed to by<B> bytes</B>.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _dos_read</TT> function returns zero if successful.&nbsp; Otherwise, it returns an OS error code and sets <TT> errno</TT>
accordingly.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_dos_close">_dos_close</A>, <A HREF="#_dos_open">_dos_open</A>, <A HREF="#_dos_write">_dos_write</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><TT>#include &lt;fcntl.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned len_read;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handle;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; auto char buffer[80];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; if( _dos_open( &quot;file&quot;, O_RDONLY, &amp;handle ) != 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Unable to open file\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Open succeeded\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _dos_read( handle, buffer, 80, &amp;len_read );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _dos_close( handle );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>DOS
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, DOS/PM
</DL>
<H2 ID="_dos_setblock"> _dos_setblock </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><TT>unsigned _dos_setblock( unsigned size,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; unsigned segment,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; unsigned *maxsize );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _dos_setblock</TT> function uses system call 0x4A to change the size of<B> segment</B>, which was previously allocated
by <TT> _dos_allocmem</TT>, to<B> size</B> paragraphs.&nbsp; If the request fails, the maximum number of paragraphs that this
memory block can be changed to is returned in the word pointed to by<B> maxsize</B>.
<BR><BR>For 32-bit DOS applications, it is recommended that the corresponding DPMI services be used.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _dos_setblock</TT> function returns zero if successful.&nbsp; Otherwise, it returns an OS error code and sets <TT>
errno</TT> to <TT> ENOMEM</TT> indicating a bad segment value, insufficient memory or corrupted memory.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_dos_allocmem">_dos_allocmem</A>, <A HREF="#_dos_freemem">_dos_freemem</A>, <A HREF="#realloc">realloc</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>#if defined(__NT__) || \</TT>
<BR><TT>&nbsp; ( defined(__OS2__) &amp;&amp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (defined(__386__) || defined(__PPC__)) )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; void *segment;</TT>
<BR><TT>#else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned segment;</TT>
<BR><TT>#endif</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; /* Try to allocate 100 paragraphs, then free them */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( _dos_allocmem( 100, &amp;segment ) != 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;_dos_allocmem failed\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Only %u paragraphs available\n&quot;, segment);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;_dos_allocmem succeeded\n&quot; );</TT>
<BR><BR><TT>#if defined(__DOS__)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { unsigned maxsize = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Try to increase it to 200 paragraphs */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( _dos_setblock( 200, segment, &amp;maxsize ) != 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;_dos_setblock failed: max=%u, err=%s\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
maxsize, strerror( errno) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;_dos_setblock succeeded\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>#endif</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( _dos_freemem( segment ) != 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;_dos_freemem failed\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;_dos_freemem succeeded\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>DOS
</DL>
<DL>
<DT>Systems:
<DD>DOS, DOS/PM
</DL>
<H2 ID="_dos_setdate"> _dos_setdate </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><TT>unsigned _dos_setdate( struct dosdate_t *date );</TT>
<BR><BR><TT>struct dosdate_t {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char day;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* 1-31 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char month;&nbsp;&nbsp;&nbsp; /* 1-12 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned short year;&nbsp;&nbsp;&nbsp; /* 1980-2099 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char dayofweek;/* 0-6 (0=Sunday) */</TT>
<BR><TT>};</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _dos_setdate</TT> function uses system call 0x2B to set the current system date.&nbsp; The date information is passed
in a <TT> dosdate_t</TT> structure pointed to by<B> date</B>.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _dos_setdate</TT> function returns zero if successful.&nbsp; Otherwise, it returns an OS error code and sets <TT>
errno</TT> accordingly.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_dos_getdate">_dos_getdate</A>, <A HREF="#_dos_gettime">_dos_gettime</A>, <A HREF="#_dos_settime">_dos_settime</A>,
<A HREF="#gmtime">gmtime</A>, <A HREF="#localtime">localtime</A>, <A HREF="#mktime">mktime</A>, <A HREF="#time">time</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct dosdate_t date;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct dostime_t time;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; /* Get and display the current date and time */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _dos_getdate( &amp;date );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _dos_gettime( &amp;time );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;The date (MM-DD-YYYY) is: %d-%d-%d\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; date.month, date.day, date.year );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;The time (HH:MM:SS) is: %.2d:%.2d:%.2d\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time.hour, time.minute, time.second );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; /* Change it to the turn of the century */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; date.year = 1999;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; date.month = 12;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; date.day = 31;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; time.hour = 23;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; time.minute = 59;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _dos_setdate( &amp;date );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _dos_settime( &amp;time );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;New date (MM-DD-YYYY) is: %d-%d-%d\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; date.month, date.day, date.year );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;New time (HH:MM:SS) is: %.2d:%.2d:%.2d\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time.hour, time.minute, time.second );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>The date (MM-DD-YYYY) is: 12-25-1989</TT>
<BR><TT>The time (HH:MM:SS) is: 14:23:15</TT>
<BR><TT>New date (MM-DD-YYYY) is: 12-31-1999</TT>
<BR><TT>New time (HH:MM:SS) is: 23:59:16</TT>
</DL>
<DL>
<DT>Classification:
<DD>DOS
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, DOS/PM
</DL>
<H2 ID="_dos_setdrive"> _dos_setdrive </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><TT>void _dos_setdrive( unsigned drive, unsigned *total );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _dos_setdrive</TT> function uses system call 0x0E to set the current default disk drive to be the drive specified
by<B> drive</B>, where 1 = drive A, 2 = drive B, etc.&nbsp; The total number of disk drives is returned in the word pointed
to by<B> total</B>.&nbsp; For DOS versions 3.0 or later, the minimum number of drives returned is 5.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _dos_setdrive</TT> function has no return value.&nbsp; If an invalid drive number is specified, the function fails
with no error indication.&nbsp; You must use the <TT> _dos_getdrive</TT> function to check that the desired drive has been
set.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_dos_getdiskfree">_dos_getdiskfree</A>, <A HREF="#_dos_getdrive">_dos_getdrive</A>, <A HREF="#_getdiskfree">_getdiskfree</A>,
<A HREF="#_getdrive">_getdrive</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned drive1, drive2, total;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _dos_getdrive( &amp;drive1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Current drive is %c\n&quot;, 'A' + drive1 - 1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* try to change to drive C */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _dos_setdrive( 3, &amp;total );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _dos_getdrive( &amp;drive2 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Current drive is %c\n&quot;, 'A' + drive2 - 1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* go back to original drive */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _dos_setdrive( drive1, &amp;total );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _dos_getdrive( &amp;drive1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Current drive is %c\n&quot;, 'A' + drive1 - 1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Total number of drives is %u\n&quot;, total );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>Current drive is D</TT>
<BR><TT>Current drive is C</TT>
<BR><TT>Total number of drives is 6</TT>
</DL>
<DL>
<DT>Classification:
<DD>DOS
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, DOS/PM
</DL>
<H2 ID="_dos_setfileattr"> _dos_setfileattr </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><TT>unsigned _dos_setfileattr( const char *path,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned attributes );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _dos_setfileattr</TT> function uses system call 0x43 to set the attributes of the file or directory that<B> path</B>
points to.&nbsp; The possible attributes are:
<DL>
<DT>Attribute&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>_A_NORMAL
<DD>Indicates a normal file.&nbsp; File can be read or written without any restrictions.
<DT>_A_RDONLY
<DD>Indicates a read-only file.&nbsp; File cannot be opened for &quot;write&quot;.
<DT>_A_HIDDEN
<DD>Indicates a hidden file.&nbsp; This file will not show up in a normal directory search.
<DT>_A_SYSTEM
<DD>Indicates a system file.&nbsp; This file will not show up in a normal directory search.
<DT>_A_VOLID
<DD>Indicates a volume-ID.
<DT>_A_SUBDIR
<DD>Indicates a sub-directory.
<DT>_A_ARCH
<DD>This is the archive flag.&nbsp; It is set whenever the file is modified, and is cleared by the MS-DOS BACKUP command and other
backup utility programs.
</DL>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _dos_setfileattr</TT> function returns zero if successful.&nbsp; Otherwise, it returns an OS error code and sets <TT>
errno</TT> accordingly.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_dos_getfileattr">_dos_getfileattr</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><BR><TT>print_attribute()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned attribute;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _dos_getfileattr( &quot;file&quot;, &amp;attribute );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;File attribute is %x\n&quot;, attribute );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( attribute &amp; _A_RDONLY ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;This is a read-only file\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;This is not a read-only file\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handle;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; if( _dos_creat( &quot;file&quot;, _A_RDONLY, &amp;handle ) != 0 ){</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Error creating file\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; print_attribute();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _dos_setfileattr( &quot;file&quot;, _A_NORMAL );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; print_attribute();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _dos_close( handle );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>DOS
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, DOS/PM
</DL>
<H2 ID="_dos_setftime"> _dos_setftime </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><TT>unsigned _dos_setftime( int handle,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; unsigned date,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; unsigned time );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _dos_setftime</TT> function uses system call 0x57 to set the date and time that the file associated with<B> handle</B>
was last modified.&nbsp; The date consists of the year, month and day packed into 16 bits as follows:
<DL>
<DT>Bits&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>bits 0-4
<DD>Day (1-31)
<DT>bits 5-8
<DD>Month (1-12)
<DT>bits 9-15
<DD>Year (0-119 representing 1980-2099)
</DL>
<BR>The time consists of the hour, minute and seconds/2 packed into 16 bits as follows:
<DL>
<DT>Bits&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>bits 0-4
<DD>Seconds/2 (0-29)
<DT>bits 5-10
<DD>Minutes (0-59)
<DT>bits 11-15
<DD>Hours (0-23)
</DL>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _dos_setftime</TT> function returns zero if successful.&nbsp; Otherwise, it returns an OS error code and sets <TT>
errno</TT> accordingly.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_dos_getftime">_dos_getftime</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><TT>#include &lt;fcntl.h&gt;</TT>
<BR><BR><TT>#define YEAR(t)&nbsp;&nbsp; (((t &amp; 0xFE00) &gt;&gt; 9) + 1980)</TT>
<BR><TT>#define MONTH(t)&nbsp; ((t &amp; 0x01E0) &gt;&gt; 5)</TT>
<BR><TT>#define DAY(t)&nbsp;&nbsp;&nbsp; (t &amp; 0x001F)</TT>
<BR><TT>#define HOUR(t)&nbsp;&nbsp; ((t &amp; 0xF800) &gt;&gt; 11)</TT>
<BR><TT>#define MINUTE(t) ((t &amp; 0x07E0) &gt;&gt; 5)</TT>
<BR><TT>#define SECOND(t) ((t &amp; 0x001F) &lt;&lt; 1)</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handle;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned short date, time;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; if( _dos_open( &quot;file&quot;, O_RDWR, &amp;handle ) != 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Unable to open file\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Open succeeded\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _dos_getftime( handle, &amp;date, &amp;time );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;The file was last modified on %d/%d/%d&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MONTH(date), DAY(date),
YEAR(date) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot; at %.2d:%.2d:%.2d\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HOUR(time), MINUTE(time),
SECOND(time) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* set the time to 12 noon */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time = (12 &lt;&lt; 11) + (0 &lt;&lt; 5) + 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _dos_setftime( handle, date, time );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _dos_getftime( handle, &amp;date, &amp;time );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;The file was last modified on %d/%d/%d&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MONTH(date), DAY(date),
YEAR(date) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot; at %.2d:%.2d:%.2d\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HOUR(time), MINUTE(time),
SECOND(time) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _dos_close( handle );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>Open succeeded</TT>
<BR><TT>The file was last modified on 12/29/1989 at 14:32:46</TT>
<BR><TT>The file was last modified on 12/29/1989 at 12:00:00</TT>
</DL>
<DL>
<DT>Classification:
<DD>DOS
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, DOS/PM
</DL>
<H2 ID="_dos_settime"> _dos_settime </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><TT>unsigned _dos_settime( struct dostime_t *time );</TT>
<BR><TT>struct dostime_t {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char hour;&nbsp;&nbsp;&nbsp;&nbsp; /* 0-23 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char minute;&nbsp;&nbsp; /* 0-59 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char second;&nbsp;&nbsp; /* 0-59 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char hsecond;&nbsp; /* 1/100 second; 0-99 */</TT>
<BR><TT>};</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _dos_settime</TT> function uses system call 0x2D to set the current system time.&nbsp; The time information is passed
in a <TT> dostime_t</TT> structure pointed to by<B> time</B>.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _dos_settime</TT> function returns zero if successful.&nbsp; Otherwise, it returns a non-zero value and sets <TT>
errno</TT> to <TT> EINVAL</TT> indicating that an invalid time was given.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_dos_getdate">_dos_getdate</A>, <A HREF="#_dos_setdate">_dos_setdate</A>, <A HREF="#_dos_gettime">_dos_gettime</A>,
<A HREF="#gmtime">gmtime</A>, <A HREF="#localtime">localtime</A>, <A HREF="#mktime">mktime</A>, <A HREF="#time">time</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct dosdate_t date;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct dostime_t time;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; /* Get and display the current date and time */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _dos_getdate( &amp;date );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _dos_gettime( &amp;time );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;The date (MM-DD-YYYY) is: %d-%d-%d\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; date.month, date.day, date.year );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;The time (HH:MM:SS) is: %.2d:%.2d:%.2d\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time.hour, time.minute, time.second );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; /* Change it to the turn of the century */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; date.year = 1999;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; date.month = 12;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; date.day = 31;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; time.hour = 23;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; time.minute = 59;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _dos_setdate( &amp;date );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _dos_settime( &amp;time );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;New date (MM-DD-YYYY) is: %d-%d-%d\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; date.month,
date.day, date.year );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;New time (HH:MM:SS) is: %.2d:%.2d:%.2d\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time.hour,
time.minute, time.second );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>The date (MM-DD-YYYY) is: 12-25-1989</TT>
<BR><TT>The time (HH:MM:SS) is: 14:23:15</TT>
<BR><TT>New date (MM-DD-YYYY) is: 12-31-1999</TT>
<BR><TT>New time (HH:MM:SS) is: 23:59:16</TT>
</DL>
<DL>
<DT>Classification:
<DD>DOS
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, DOS/PM
</DL>
<H2 ID="_dos_setvect"> _dos_setvect </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><TT>void _dos_setvect( unsigned intnum,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void
(__interrupt __far *handler)() );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _dos_setvect</TT> function sets interrupt vector number<B> intnum</B> to point to the interrupt handling function
pointed to by<B> handler</B>.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _dos_setvect</TT> function does not return a value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_chain_intr">_chain_intr</A>, <A HREF="#_dos_getvect">_dos_getvect</A>, <A HREF="#_dos_keep">_dos_keep</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><BR><TT>volatile int clock_ticks;</TT>
<BR><TT>void (__interrupt __far *prev_int_1c)();</TT>
<BR><TT>#define BLIP_COUNT&nbsp; (5*18)&nbsp; /* 5 seconds */</TT>
<BR><BR><TT>void __interrupt __far timer_rtn()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ++clock_ticks;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _chain_intr( prev_int_1c );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR><TT>int compile_a_line()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; static int delays = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( delays &gt; 15 ) return( 0 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; delay( 1000 );&nbsp; /* delay for 1 second */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Delayed for 1 second\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; delays++;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; return( 1 );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; prev_int_1c = _dos_getvect( 0x1c );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _dos_setvect( 0x1c, timer_rtn );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; while( compile_a_line() ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( clock_ticks &gt;= BLIP_COUNT ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; putchar( '.' );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clock_ticks -= BLIP_COUNT;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _dos_setvect( 0x1c, prev_int_1c );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, DOS/PM
</DL>
<H2 ID="_dos_write"> _dos_write </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><TT>unsigned _dos_write( int handle, void const __far *buffer,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;unsigned count, unsigned *bytes );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _dos_write</TT> function uses system call 0x40 to write<B> count</B> bytes of data from the buffer pointed to by<B>
buffer</B> to the file specified by<B> handle</B>.&nbsp; The number of bytes successfully written will be stored in the unsigned
integer pointed to by<B> bytes</B>.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _dos_write</TT> function returns zero if successful.&nbsp; Otherwise, it returns an OS error code and sets <TT> errno</TT>
accordingly.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_dos_close">_dos_close</A>, <A HREF="#_dos_open">_dos_open</A>, <A HREF="#_dos_read">_dos_read</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><TT>#include &lt;fcntl.h&gt;</TT>
<BR><BR><TT>char buffer[] = &quot;This is a test for _dos_write.&quot;;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned len_written;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handle;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; if( _dos_creat( &quot;file&quot;, _A_NORMAL, &amp;handle ) != 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Unable to create file\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Create succeeded\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _dos_write( handle, buffer, sizeof(buffer),</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;len_written
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _dos_close( handle );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>DOS
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, DOS/PM
</DL>
<H2 ID="dup"> dup, _dup </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;io.h&gt;</TT>
<BR><TT>int dup( int handle );</TT>
<BR><TT>int _dup( int handle );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> dup</TT> function duplicates the file handle given by the argument<B> handle</B>.&nbsp; The new file handle refers
to the same open file handle as the original file handle, and shares any locks.&nbsp; The new file handle is identical to
the original in that it references the same file or device, it has the same open mode (read and/or write) and it will have
file position identical to the original.&nbsp; Changing the position with one handle will result in a changed position in
the other.
<BR><BR>The<TT> _dup</TT> function is identical to<TT> dup</TT>.&nbsp; Use<TT> _dup</TT> for ANSI naming conventions.
</DL>
<DL>
<DT>Returns:
<DD>If successful, the new file handle is returned to be used with the other functions which operate on the file.&nbsp; Otherwise,
-1 is returned and <TT> errno</TT> is set to indicate the error.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>EBADF
<DD>The argument<B> handle</B> is not a valid open file handle.
<DT>EMFILE
<DD>The number of file handles would exceed {OPEN_MAX}.
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#chsize">chsize</A>, <A HREF="#close">close</A>, <A HREF="#creat">creat</A>, <A HREF="#dup2">dup2</A>, <A HREF="#eof">eof</A>,
<A HREF="#exec___">exec...</A>, <A HREF="#fdopen">fdopen</A>, <A HREF="#filelength">filelength</A>, <A HREF="#fileno">fileno</A>,
<A HREF="#fstat">fstat</A>, <A HREF="#_grow_handles">_grow_handles</A>, <A HREF="#isatty">isatty</A>, <A HREF="#lseek">lseek</A>,
<A HREF="#open">open</A>, <A HREF="#read">read</A>, <A HREF="#setmode">setmode</A>, <A HREF="#sopen">sopen</A>, <A HREF="#stat">stat</A>,
<A HREF="#tell">tell</A>, <A HREF="#write">write</A>, <A HREF="#umask">umask</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;fcntl.h&gt;</TT>
<BR><TT>#include &lt;io.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int handle, dup_handle;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; handle = open( &quot;file&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; O_WRONLY | O_CREAT | O_TRUNC
| O_TEXT,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S_IRUSR | S_IWUSR | S_IRGRP
| S_IWGRP );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( handle != -1 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dup_handle = dup( handle );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( dup_handle != -1 ) {</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* process file */</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close( dup_handle );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close( handle );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>POSIX 1003.1
<BR><BR>_dup conforms to ANSI naming conventions
</DL>
<DL>
<DT>Systems:
<DD><TT> dup - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_dup - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="dup2"> dup2, _dup2 </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;io.h&gt;</TT>
<BR><TT>int dup2( int handle, int handle2 );</TT>
<BR><TT>int _dup2( int handle, int handle2 );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> dup2</TT> function duplicates the file handle given by the argument<B> handle</B>.&nbsp; The new file handle is identical
to the original in that it references the same file or device, it has the same open mode (read and/or write) and it will have
identical file position to the original (changing the position with one handle will result in a changed position in the other).
<BR><BR>The number of the new handle is<B> handle2</B>.&nbsp; If a file already is opened with this handle, the file is closed
before the duplication is attempted.
<BR><BR>The<TT> _dup2</TT> function is identical to<TT> dup2</TT>.&nbsp; Use<TT> _dup2</TT> for ANSI naming conventions.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> dup2</TT> function returns zero if successful.&nbsp; Otherwise, -1 is returned and <TT> errno</TT> is set to indicate
the error.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>EBADF
<DD>The argument<B> handle</B> is not a valid open file handle or<B> handle2</B> is out of range.
<DT>EMFILE
<DD>The number of file handles would exceed {OPEN_MAX}, or no file handles above<B> handle2</B> are available.
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#chsize">chsize</A>, <A HREF="#close">close</A>, <A HREF="#creat">creat</A>, <A HREF="#dup">dup</A>, <A HREF="#eof">eof</A>,
<A HREF="#exec___">exec...</A>, <A HREF="#fdopen">fdopen</A>, <A HREF="#filelength">filelength</A>, <A HREF="#fileno">fileno</A>,
<A HREF="#fstat">fstat</A>, <A HREF="#_grow_handles">_grow_handles</A>, <A HREF="#isatty">isatty</A>, <A HREF="#lseek">lseek</A>,
<A HREF="#open">open</A>, <A HREF="#read">read</A>, <A HREF="#setmode">setmode</A>, <A HREF="#sopen">sopen</A>, <A HREF="#stat">stat</A>,
<A HREF="#tell">tell</A>, <A HREF="#write">write</A>, <A HREF="#umask">umask</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;fcntl.h&gt;</TT>
<BR><TT>#include &lt;io.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int handle, dup_handle;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; handle = open( &quot;file&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; O_WRONLY | O_CREAT | O_TRUNC
| O_TEXT,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S_IRUSR | S_IWUSR | S_IRGRP
| S_IWGRP );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( handle != -1 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dup_handle = 4;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( dup2( handle, dup_handle ) != -1 ) {</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* process file */</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close( dup_handle );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close( handle );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>POSIX 1003.1
<BR><BR>_dup2 conforms to ANSI naming conventions
</DL>
<DL>
<DT>Systems:
<DD><TT> dup2 - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_dup2 - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="_dwDeleteOnClose"> _dwDeleteOnClose </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wdefwin.h&gt;</TT>
<BR><TT>int _dwDeleteOnClose( int handle );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _dwDeleteOnClose</TT> function tells the console window that it should close itself when the corresponding file is
closed.&nbsp; The argument<B> handle</B> is the handle associated with the opened console.
<BR><BR>The<TT> _dwDeleteOnClose</TT> function is one of the support functions that can be called from an application using
Open Watcom's default windowing support.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _dwDeleteOnClose</TT> function returns 1 if it was successful and 0 if not.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_dwSetAboutDlg">_dwSetAboutDlg</A>, <A HREF="#_dwSetAppTitle">_dwSetAppTitle</A>, <A HREF="#_dwSetConTitle">_dwSetConTitle</A>,
<A HREF="#_dwShutDown">_dwShutDown</A>, <A HREF="#_dwYield">_dwYield</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;wdefwin.h&gt;</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FILE *sec;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _dwSetAboutDlg( &quot;Hello World About Dialog&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&quot;About Hello World\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&quot;Copyright 1994 by WATCOM\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _dwSetAppTitle( &quot;Hello World Application Title&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _dwSetConTitle( 0, &quot;Hello World Console Title&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Hello World\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; sec = fopen( &quot;CON&quot;, &quot;r+&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _dwSetConTitle( fileno( sec ),</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&quot;Hello World Second Console Title&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _dwDeleteOnClose( fileno( sec ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fprintf( sec, &quot;Hello to second console\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fprintf( sec, &quot;Press Enter to close this console\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fflush( sec );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fgetc( sec );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fclose( sec );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>Windows, Win386, Win32, OS/2-32
</DL>
<H2 ID="_dwSetAboutDlg"> _dwSetAboutDlg </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wdefwin.h&gt;</TT>
<BR><TT>int _dwSetAboutDlg( const char *title, const char *text );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _dwSetAboutDlg</TT> function sets the &quot;About&quot; dialog box of the default windowing system.&nbsp; The argument<B>
title</B> points to the string that will replace the current title.&nbsp; If<B> title</B> is NULL then the title will not
be replaced.&nbsp; The argument<B> text</B> points to a string which will be placed in the &quot;About&quot; box.&nbsp; To
get multiple lines, embed a new line after each logical line in the string.&nbsp; If<B> text</B> is NULL, then the current
text in the &quot;About&quot; box will not be replaced.
<BR><BR>The<TT> _dwSetAboutDlg</TT> function is one of the support functions that can be called from an application using
Open Watcom's default windowing support.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _dwSetAboutDlg</TT> function returns 1 if it was successful and 0 if not.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_dwDeleteOnClose">_dwDeleteOnClose</A>, <A HREF="#_dwSetAppTitle">_dwSetAppTitle</A>, <A HREF="#_dwSetConTitle">_dwSetConTitle</A>,
<A HREF="#_dwShutDown">_dwShutDown</A>, <A HREF="#_dwYield">_dwYield</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;wdefwin.h&gt;</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FILE *sec;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _dwSetAboutDlg( &quot;Hello World About Dialog&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&quot;About Hello World\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&quot;Copyright 1994 by WATCOM\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _dwSetAppTitle( &quot;Hello World Application Title&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _dwSetConTitle( 0, &quot;Hello World Console Title&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Hello World\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; sec = fopen( &quot;CON&quot;, &quot;r+&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _dwSetConTitle( fileno( sec ),</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&quot;Hello World Second Console Title&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _dwDeleteOnClose( fileno( sec ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fprintf( sec, &quot;Hello to second console\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fprintf( sec, &quot;Press Enter to close this console\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fflush( sec );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fgetc( sec );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fclose( sec );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>Windows, Win386, Win32, OS/2-32
</DL>
<H2 ID="_dwSetAppTitle"> _dwSetAppTitle </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wdefwin.h&gt;</TT>
<BR><TT>int _dwSetAppTitle( const char *title );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _dwSetAppTitle</TT> function sets the main window's title.&nbsp; The argument<B> title</B> points to the string that
will replace the current title.
<BR><BR>The<TT> _dwSetAppTitle</TT> function is one of the support functions that can be called from an application using
Open Watcom's default windowing support.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _dwSetAppTitle</TT> function returns 1 if it was successful and 0 if not.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_dwDeleteOnClose">_dwDeleteOnClose</A>, <A HREF="#_dwSetAboutDlg">_dwSetAboutDlg</A>, <A HREF="#_dwSetConTitle">_dwSetConTitle</A>,
<A HREF="#_dwShutDown">_dwShutDown</A>, <A HREF="#_dwYield">_dwYield</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;wdefwin.h&gt;</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FILE *sec;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _dwSetAboutDlg( &quot;Hello World About Dialog&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&quot;About Hello World\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&quot;Copyright 1994 by WATCOM\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _dwSetAppTitle( &quot;Hello World Application Title&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _dwSetConTitle( 0, &quot;Hello World Console Title&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Hello World\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; sec = fopen( &quot;CON&quot;, &quot;r+&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _dwSetConTitle( fileno( sec ),</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&quot;Hello World Second Console Title&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _dwDeleteOnClose( fileno( sec ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fprintf( sec, &quot;Hello to second console\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fprintf( sec, &quot;Press Enter to close this console\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fflush( sec );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fgetc( sec );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fclose( sec );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>Windows, Win386, Win32, OS/2-32
</DL>
<H2 ID="_dwSetConTitle"> _dwSetConTitle </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wdefwin.h&gt;</TT>
<BR><TT>int _dwSetConTitle( int handle, const char *title );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _dwSetConTitle</TT> function sets the console window's title which corresponds to the handle passed to it.&nbsp; The
argument<B> handle</B> is the handle associated with the opened console.&nbsp; The argument<B> title</B> points to the string
that will replace the current title.
<BR><BR>The<TT> _dwSetConTitle</TT> function is one of the support functions that can be called from an application using
Open Watcom's default windowing support.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _dwSetConTitle</TT> function returns 1 if it was successful and 0 if not.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_dwDeleteOnClose">_dwDeleteOnClose</A>, <A HREF="#_dwSetAboutDlg">_dwSetAboutDlg</A>, <A HREF="#_dwSetAppTitle">_dwSetAppTitle</A>,
<A HREF="#_dwShutDown">_dwShutDown</A>, <A HREF="#_dwYield">_dwYield</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;wdefwin.h&gt;</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FILE *sec;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _dwSetAboutDlg( &quot;Hello World About Dialog&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&quot;About Hello World\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&quot;Copyright 1994 by WATCOM\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _dwSetAppTitle( &quot;Hello World Application Title&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _dwSetConTitle( 0, &quot;Hello World Console Title&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Hello World\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; sec = fopen( &quot;CON&quot;, &quot;r+&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _dwSetConTitle( fileno( sec ),</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&quot;Hello World Second Console Title&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _dwDeleteOnClose( fileno( sec ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fprintf( sec, &quot;Hello to second console\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fprintf( sec, &quot;Press Enter to close this console\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fflush( sec );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fgetc( sec );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fclose( sec );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>Windows, Win386, Win32, OS/2-32
</DL>
<H2 ID="_dwShutDown"> _dwShutDown </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wdefwin.h&gt;</TT>
<BR><TT>int _dwShutDown( void );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _dwShutDown</TT> function shuts down the default windowing I/O system.&nbsp; The application will continue to execute
but no windows will be available for output.&nbsp; Care should be exercised when using this function since any subsequent
output may cause unpredictable results.
<BR><BR>When the application terminates, it will not be necessary to manually close the main window.
<BR><BR>The<TT> _dwShutDown</TT> function is one of the support functions that can be called from an application using Open
Watcom's default windowing support.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _dwShutDown</TT> function returns 1 if it was successful and 0 if not.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_dwDeleteOnClose">_dwDeleteOnClose</A>, <A HREF="#_dwSetAboutDlg">_dwSetAboutDlg</A>, <A HREF="#_dwSetAppTitle">_dwSetAppTitle</A>,
<A HREF="#_dwSetConTitle">_dwSetConTitle</A>, <A HREF="#_dwYield">_dwYield</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;wdefwin.h&gt;</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FILE *sec;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _dwSetAboutDlg( &quot;Hello World About Dialog&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&quot;About Hello World\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&quot;Copyright 1994 by WATCOM\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _dwSetAppTitle( &quot;Hello World Application Title&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _dwSetConTitle( 0, &quot;Hello World Console Title&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Hello World\n&quot; );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; sec = fopen( &quot;CON&quot;, &quot;r+&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _dwSetConTitle( fileno( sec ),</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&quot;Hello World Second Console Title&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _dwDeleteOnClose( fileno( sec ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fprintf( sec, &quot;Hello to second console\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fprintf( sec, &quot;Press Enter to close this console\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fflush( sec );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fgetc( sec );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fclose( sec );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _dwShutDown();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /*</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do more computing that does not involve</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; console input/output</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>Windows, Win386, Win32, OS/2-32
</DL>
<H2 ID="_dwYield"> _dwYield </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wdefwin.h&gt;</TT>
<BR><TT>int _dwYield( void );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _dwYield</TT> function yields control back to the operating system, thereby giving other processes a chance to run.
<BR><BR>The<TT> _dwYield</TT> function is one of the support functions that can be called from an application using Open Watcom's
default windowing support.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _dwYield</TT> function returns 1 if it was successful and 0 if not.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_dwDeleteOnClose">_dwDeleteOnClose</A>, <A HREF="#_dwSetAboutDlg">_dwSetAboutDlg</A>, <A HREF="#_dwSetAppTitle">_dwSetAppTitle</A>,
<A HREF="#_dwSetConTitle">_dwSetConTitle</A>, <A HREF="#_dwShutDown">_dwShutDown</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;wdefwin.h&gt;</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; 1000; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* give other processes a chance to run */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _dwYield();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* do CPU-intensive calculation */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*&nbsp; .&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*&nbsp; .&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*&nbsp; .&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>Windows, Win386, Win32, OS/2-32
</DL>
<H2 ID="ecvt"> ecvt, _ecvt, _wecvt </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>char *ecvt( double value,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int ndigits,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int *dec,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int *sign );</TT>
<BR><TT>char *_ecvt( double value,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int ndigits,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int *dec,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int *sign );</TT>
<BR><TT>wchar_t *_wecvt( double value,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int ndigits,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int *dec,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int *sign );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> ecvt</TT> function converts the floating-point number<B> value</B> into a character string.&nbsp; The parameter<B>
ndigits</B> specifies the number of significant digits desired.&nbsp; The converted number will be rounded to<B> ndigits</B>
of precision.
<BR><BR>The character string will contain only digits and is terminated by a null character.&nbsp; The integer pointed to
by<B> dec</B> will be filled in with a value indicating the position of the decimal point relative to the start of the string
of digits.&nbsp; A zero or negative value indicates that the decimal point lies to the left of the first digit.&nbsp; The
integer pointed to by<B> sign</B> will contain 0 if the number is positive, and non-zero if the number is negative.
<BR><BR>The<TT> _ecvt</TT> function is identical to<TT> ecvt</TT>.&nbsp; Use<TT> _ecvt</TT> for ANSI naming conventions.
<BR><BR>The<TT> _wecvt</TT> function is a wide-character version of<TT> ecvt</TT>.&nbsp; It produces a wide-character string.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> ecvt</TT> function returns a pointer to a static buffer containing the converted string of digits.&nbsp; Note:<TT>
&nbsp;ecvt</TT> and <TT> fcvt</TT> both use the same static buffer.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#fcvt">fcvt</A>, <A HREF="#gcvt">gcvt</A>, <A HREF="#printf">printf</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char *str;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp; dec, sign;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; str = ecvt( 123.456789, 6, &amp;dec, &amp;sign );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;str=%s, dec=%d, sign=%d\n&quot;, str,dec,sign );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>str=123457, dec=3, sign=0</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
<BR><BR>_ecvt conforms to ANSI naming conventions
</DL>
<DL>
<DT>Systems:
<DD><TT> ecvt - Math</TT>
<BR><BR><TT>_ecvt - Math</TT>
<BR><TT>_wecvt - Math</TT>
</DL>
<H2 ID="_ellipse"> _ellipse, _ellipse_w, _ellipse_wxy </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>short _FAR _ellipse( short fill, short x1, short y1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short x2, short y2 );</TT>
<BR><BR><TT>short _FAR _ellipse_w( short fill, double x1, double y1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double x2, double y2 );</TT>
<BR><BR><TT>short _FAR _ellipse_wxy( short fill,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; struct _wxycoord _FAR *p1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; struct _wxycoord _FAR *p2 );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _ellipse</TT> functions draw ellipses.&nbsp; The<TT> _ellipse</TT> function uses the view coordinate system.&nbsp;
The<TT> _ellipse_w</TT> and<TT> _ellipse_wxy</TT> functions use the window coordinate system.
<BR><BR>The center of the ellipse is the center of the rectangle established by the points<TT> (x1,y1)</TT> and<TT> (x2,y2).</TT>
<BR><BR>The argument<B> fill</B> determines whether the ellipse is filled in or has only its outline drawn.&nbsp; The argument
can have one of two values:
<DL>
<DT>_GFILLINTERIOR
<DD>fill the interior by writing pixels with the current plot action using the current color and the current fill mask
<DT>_GBORDER
<DD>leave the interior unchanged; draw the outline of the figure with the current plot action using the current color and line
style
</DL>
<BR>When the coordinates<TT> (x1,y1)</TT> and<TT> (x2,y2)</TT> establish a line or a point (this happens when one or more
of the x-coordinates or y-coordinates are equal), nothing is drawn.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _ellipse</TT> functions return a non-zero value when the ellipse was successfully drawn; otherwise, zero is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_arc">_arc</A>, <A HREF="#_rectangle">_rectangle</A>, <A HREF="#_setcolor">_setcolor</A>, <A HREF="#_setfillmask">_setfillmask</A>,
<A HREF="#_setlinestyle">_setlinestyle</A>, <A HREF="#_setplotaction">_setplotaction</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _ellipse( _GBORDER, 120, 90, 520, 390 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><IMG SRC="eg_ellip.bmp" ALIGN=MIDDLE>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD><TT> _ellipse - DOS</TT>
<BR><BR><TT>_ellipse_w - DOS</TT>
<BR><TT>_ellipse_wxy - DOS</TT>
</DL>
<H2 ID="_enable"> _enable </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;i86.h&gt;</TT>
<BR><TT>void _enable( void );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _enable</TT> function causes interrupts to become enabled.
<BR><BR>The<TT> _enable</TT> function would be used in conjunction with the <TT> _disable</TT> function to make sure that
a sequence of instructions are executed without any intervening interrupts occurring.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _enable</TT> function returns no value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_disable">_disable</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>#include &lt;i86.h&gt;</TT>
<BR><BR><TT>struct list_entry {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct list_entry *next;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp; data;</TT>
<BR><TT>};</TT>
<BR><TT>struct list_entry *ListHead = NULL;</TT>
<BR><TT>struct list_entry *ListTail = NULL;</TT>
<BR><BR><TT>void insert( struct list_entry *new_entry )</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* insert new_entry at end of linked list */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; new_entry-&gt;next = NULL;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _disable();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* disable interrupts */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( ListTail == NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ListHead = new_entry;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ListTail-&gt;next = new_entry;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ListTail = new_entry;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _enable();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* enable interrupts now */</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct list_entry *p;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; for( i = 1; i &lt;= 10; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p = (struct list_entry *)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; malloc( sizeof( struct list_entry ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( p == NULL ) break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p-&gt;data = i;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; insert( p );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="endhostent"> endhostent </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;netdb.h&gt;</TT>
<BR><TT>void endhostent( void );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> endhostent</TT> function closes the network host database at /etc/hosts.&nbsp; If the network host database is not
open, this call results in no actions.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#gethostent">gethostent</A>, <A HREF="#sethostent">sethostent</A>
</DL>
<DL>
<DT>Classification:
<DD>POSIX
</DL>
<DL>
<DT>Systems:
<DD>Linux
</DL>
<H2 ID="endnetent"> endnetent </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;netdb.h&gt;</TT>
<BR><TT>void endnetent( void );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> endnetent</TT> function closes the network database.
<BR><BR>This function is not thread-safe.&nbsp; Other calls to this function or to other functions accessing the hostname
database may affect the return value from this function.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#getnetent">getnetent</A>, <A HREF="#setnetent">setnetent</A>, <A HREF="#getnetbyname">getnetbyname</A>, <A HREF="#getnetbyaddr">getnetbyaddr</A>
</DL>
<DL>
<DT>Classification:
<DD>POSIX
</DL>
<DL>
<DT>Systems:
<DD>Linux
</DL>
<H2 ID="endprotoent"> endprotoent </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;netdb.h&gt;</TT>
<BR><TT>void endprotoent( void );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> endprotoent</TT> function explicitly closes the protocol database.
<BR><BR>This function is not thread-safe.&nbsp; Other calls to this function or to other functions accessing the protocol
database may affect the return value from this function.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#getprotoent">getprotoent</A>, <A HREF="#setprotoent">setprotoent</A>, <A HREF="#getprotobyname">getprotobyname</A>,
<A HREF="#getprotobynumber">getprotobynumber</A>
</DL>
<DL>
<DT>Classification:
<DD>POSIX
</DL>
<DL>
<DT>Systems:
<DD>Linux
</DL>
<H2 ID="endpwent"> endpwent </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;pwd.h&gt;</TT>
<BR><TT>void endpwent( void );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> endpwent</TT> function closes the system's password database after calls to<TT> getpwent</TT> are complete.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#setpwent">setpwent</A>, <A HREF="#getpwent">getpwent</A>, <A HREF="#getpwnam">getpwnam</A>, <A HREF="#getpwuid">getpwuid</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR>The following program will print out each user and their user ID in the system's password database
<BR><BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;pwd.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct passwd *pw;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; setpwent();</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; while((pw = getpwent()) != NULL) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;User id %d is %s\n&quot;, (int)pw-&gt;pw_uid, pw-&gt;pw_name);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; endpwent();</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>POSIX
</DL>
<DL>
<DT>Systems:
<DD>Linux
</DL>
<H2 ID="endservent"> endservent </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;netdb.h&gt;</TT>
<BR><TT>void endservent( void );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> endservent</TT> function closes the service database.
<BR><BR>This function is not thread-safe.&nbsp; Other calls to this function or to other functions accessing the hostname
database may affect the return value from this function.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#getservent">getservent</A>, <A HREF="#setservent">setservent</A>, <A HREF="#getservbyname">getservbyname</A>, <A HREF="#getservbyport">getservbyport</A>
</DL>
<DL>
<DT>Classification:
<DD>POSIX
</DL>
<DL>
<DT>Systems:
<DD>Linux
</DL>
<H2 ID="_endthread"> _endthread, _endthreadex </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;process.h&gt;</TT>
<BR><TT>void _endthread(void);</TT>
<BR><TT>void _endthreadex( unsigned retval );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _endthread</TT> function is used to terminate a thread created by <TT> _beginthread</TT>.&nbsp; For each operating
environment under which<TT> _endthread</TT> is supported, the<TT> _endthread</TT> function uses the appropriate system call
to end the current thread of execution.
<BR><BR>The <TT> _endthreadex</TT> function is used to terminate a thread created by <TT> _beginthreadex</TT>.&nbsp; The thread
exit code<B> retval</B> must be specified.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _endthread</TT> function does not return any value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_beginthread">_beginthread</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>#include &lt;stddef.h&gt;</TT>
<BR><TT>#include &lt;malloc.h&gt;</TT>
<BR><TT>#include &lt;process.h&gt;</TT>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><BR><TT>#if defined(__386__)</TT>
<BR><TT>&nbsp; #define FAR</TT>
<BR><TT>&nbsp; #define STACK_SIZE&nbsp;&nbsp;&nbsp; 8192</TT>
<BR><TT>#else</TT>
<BR><TT>&nbsp; #define FAR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __far</TT>
<BR><TT>&nbsp; #define STACK_SIZE&nbsp;&nbsp;&nbsp; 4096</TT>
<BR><TT>#endif</TT>
<BR><BR><TT>static volatile int&nbsp;&nbsp;&nbsp;&nbsp; WaitForThread;</TT>
<BR><BR><TT>void FAR child( void FAR *parm )</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char * FAR *argv = (char * FAR *) parm;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp; i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Child thread ID = %x\n&quot;, *_threadid );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; argv[i]; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;argv[%d] = %s\n&quot;, i, argv[i] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; WaitForThread = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _endthread();</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *args[3];</TT>
<BR><TT>#if defined(__NT__)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned long&nbsp;&nbsp; tid;</TT>
<BR><TT>#else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *stack;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tid;</TT>
<BR><TT>#endif</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; args[0] = &quot;child&quot;;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; args[1] = &quot;parm&quot;;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; args[2] = NULL;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; WaitForThread = 1;</TT>
<BR><TT>#if defined(__NT__)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; tid = _beginthread( child, STACK_SIZE, args );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Thread handle = %lx\n&quot;, tid );</TT>
<BR><TT>#else</TT>
<BR><TT>&nbsp; #if defined(__386__)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; stack = (char *) malloc( STACK_SIZE );</TT>
<BR><TT>&nbsp; #else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; stack = (char *) _nmalloc( STACK_SIZE );</TT>
<BR><TT>&nbsp; #endif</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; tid = _beginthread( child, stack, STACK_SIZE, args );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Thread ID = %x\n&quot;, tid );</TT>
<BR><TT>#endif</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; while( WaitForThread ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sleep( 0 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> _endthread - Win32, OS/2 1.x(MT), OS/2 1.x(DL), OS/2-32, Linux, RDOS, Netware</TT>
<BR><BR><TT>_endthreadex - Win32</TT>
</DL>
<H2 ID="eof"> eof, _eof </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;io.h&gt;</TT>
<BR><TT>int eof( int handle );</TT>
<BR><TT>int _eof( int handle );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> eof</TT> function determines, at the operating system level, if the end of the file has been reached for the file
whose file handle is given by<B> handle</B>.&nbsp; Because the current file position is set following an input operation,
the<TT> eof</TT> function may be called to detect the end of the file before an input operation beyond the end of the file
is attempted.
<BR><BR>The<TT> _eof</TT> function is identical to<TT> eof</TT>.&nbsp; Use<TT> _eof</TT> for ANSI naming conventions.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> eof</TT> function returns 1 if the current file position is at the end of the file, 0 if the current file position
is not at the end.&nbsp; A return value of -1 indicates an error, and in this case <TT> errno</TT> is set to indicate the
error.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
<DL>
<DT>EBADF
<DD>The<B> handle</B> argument is not a valid file handle.
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#read">read</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;fcntl.h&gt;</TT>
<BR><TT>#include &lt;io.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int handle, len;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char buffer[100];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; handle = open( &quot;file&quot;, O_RDONLY );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( handle != -1 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( ! eof( handle ) ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; len = read( handle, buffer, sizeof(buffer) - 1
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buffer[ len ] = '\0';</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%s&quot;, buffer );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close( handle );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
<BR><BR>_eof conforms to ANSI naming conventions
</DL>
<DL>
<DT>Systems:
<DD><TT> eof - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_eof - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="erf"> erf </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>double erf( double x );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> erf</TT> function computes the value of the error function, also known as the Gauss error function, for the argument<B>
x</B>.
</DL>
<DL>
<DT>Returns:
<DD>For non-infinite values of<B> x</B> the function returns the value of the error function.&nbsp; For positive infinity or negative
infinity the function returns positive or negative one respectively.&nbsp; For not-a-number the function returns NAN.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#erfc">erfc</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, erf( 0.0 ) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>0.000000</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C99
</DL>
<DL>
<DT>Systems:
<DD>Math
</DL>
<H2 ID="erfc"> erfc </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>double erfc( double x );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> erfc</TT> function computes the value of the complementary error function, also known as the Gauss error function,
for the argument<B> x</B>.
</DL>
<DL>
<DT>Returns:
<DD>For non-infinite values of<B> x</B> the function returns the value of the error function.&nbsp; For positive infinity or negative
infinity the function returns negative or positive one respectively.&nbsp; For not-a-number the function returns NAN.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#erf">erf</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, erfc( 0.0 ) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>0.000000</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>Math
</DL>
<H2 ID="exec___"> exec...&nbsp; Functions </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;process.h&gt;</TT>
<BR><TT>int execl(&nbsp;&nbsp; path, arg0, arg1..., argn, NULL );</TT>
<BR><TT>int execle(&nbsp; path, arg0, arg1..., argn, NULL, envp );</TT>
<BR><TT>int execlp(&nbsp; file, arg0, arg1..., argn, NULL );</TT>
<BR><TT>int execlpe( file, arg0, arg1..., argn, NULL, envp );</TT>
<BR><TT>int execv(&nbsp;&nbsp; path, argv );</TT>
<BR><TT>int execve(&nbsp; path, argv, envp );</TT>
<BR><TT>int execvp(&nbsp; file, argv );</TT>
<BR><TT>int execvpe( file, argv, envp );</TT>
<BR><TT>int _execl(&nbsp;&nbsp; path, arg0, arg1..., argn, NULL );</TT>
<BR><TT>int _execle(&nbsp; path, arg0, arg1..., argn, NULL, envp );</TT>
<BR><TT>int _execlp(&nbsp; file, arg0, arg1..., argn, NULL );</TT>
<BR><TT>int _execlpe( file, arg0, arg1..., argn, NULL, envp );</TT>
<BR><TT>int _execv(&nbsp;&nbsp; path, argv );</TT>
<BR><TT>int _execve(&nbsp; path, argv, envp );</TT>
<BR><TT>int _execvp(&nbsp; file, argv );</TT>
<BR><TT>int _execvpe( file, argv, envp );</TT>
<BR><TT>&nbsp; const char *path;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* file name incl.
path */</TT>
<BR><TT>&nbsp; const char *file;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* file name&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp; const char *arg0, ..., *argn; /* arguments&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
*/</TT>
<BR><TT>&nbsp; const char *const argv[];&nbsp;&nbsp;&nbsp;&nbsp; /* array of arguments&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp; const char *const envp[];&nbsp;&nbsp;&nbsp;&nbsp; /* environment strings&nbsp; */</TT>
<BR><TT>int _wexecl(&nbsp;&nbsp; path, arg0, arg1..., argn, NULL );</TT>
<BR><TT>int _wexecle(&nbsp; path, arg0, arg1..., argn, NULL, envp );</TT>
<BR><TT>int _wexeclp(&nbsp; file, arg0, arg1..., argn, NULL );</TT>
<BR><TT>int _wexeclpe( file, arg0, arg1..., argn, NULL, envp );</TT>
<BR><TT>int _wexecv(&nbsp;&nbsp; path, argv );</TT>
<BR><TT>int _wexecve(&nbsp; path, argv, envp );</TT>
<BR><TT>int _wexecvp(&nbsp; file, argv );</TT>
<BR><TT>int _wexecvpe( file, argv, envp );</TT>
<BR><TT>&nbsp; const wchar_t *path;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* file name incl. path
*/</TT>
<BR><TT>&nbsp; const wchar_t *file;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* file name&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp; const wchar_t *arg0, ..., *argn;/* arguments&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
*/</TT>
<BR><TT>&nbsp; const wchar_t *const argv[];&nbsp;&nbsp;&nbsp; /* array of arguments&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp; const wchar_t *const envp[];&nbsp;&nbsp;&nbsp; /* environment strings&nbsp; */</TT>
</DL>
<DL>
<DT>Description:
<DD>The<B> exec...</B>&nbsp; functions load and execute a new child process, named by<B> path</B> or<B> file</B>.&nbsp; If the
child process is successfully loaded, it replaces the current process in memory.&nbsp; No return is made to the original program.
<BR><BR>The program is located by using the following logic in sequence:
<OL>
<LI>An attempt is made to locate the program in the current working directory if no directory specification precedes the program
name; otherwise, an attempt is made in the specified directory.
<LI>If no file extension is given, an attempt is made to find the program name, in the directory indicated in the first point,
with<TT> .COM</TT> concatenated to the end of the program name.
<LI>If no file extension is given, an attempt is made to find the program name, in the directory indicated in the first point,
with<TT> .EXE</TT> concatenated to the end of the program name.
<LI>When no directory specification is given as part of the program name, the <TT> execlp</TT>, <TT> execlpe</TT>, <TT> execvp</TT>,
and <TT> execvpe</TT> functions will repeat the preceding three steps for each of the directories specified by the <TT> PATH</TT>
environment variable.&nbsp; The command
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; path c:\myapps;d:\lib\applns</TT>
<BR><BR>indicates that the two directories
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; c:\myapps</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; d:\lib\applns</TT>
<BR><BR>are to be searched.&nbsp; The DOS<TT> PATH</TT> command (without any directory specification) will cause the current
path definition to be displayed.
</OL>
<BR>An error is detected when the program cannot be found.
<BR><BR>Arguments are passed to the child process by supplying one or more pointers to character strings as arguments in the<B>
exec...</B>&nbsp; call.&nbsp; These character strings are concatenated with spaces inserted to separate the arguments to form
one argument string for the child process.&nbsp; The length of this concatenated string must not exceed 128 bytes for DOS
systems.
<BR><BR>The arguments may be passed as a list of arguments (<TT> execl</TT>, <TT> execle</TT>, <TT> execlp</TT>, and <TT>
execlpe</TT>) or as a vector of pointers (<TT> execv</TT>, <TT> execve</TT>, <TT> execvp</TT>, and <TT> execvpe</TT>).&nbsp;
At least one argument,<B> arg0</B> or<B> argv[0]</B>, must be passed to the child process.&nbsp; By convention, this first
argument is a pointer to the name of the program.
<BR><BR>If the arguments are passed as a list, there must be a<TT> NULL</TT> pointer to mark the end of the argument list.
&nbsp;Similarly, if a pointer to an argument vector is passed, the argument vector must be terminated by a<TT> NULL</TT> pointer.
<BR><BR>The environment for the invoked program is inherited from the parent process when you use the <TT> execl</TT>, <TT>
execlp</TT>, <TT> execv</TT>, and <TT> execvp</TT> functions.&nbsp; The <TT> execle</TT>, <TT> execlpe</TT>, <TT> execve</TT>,
and <TT> execvpe</TT> functions allow a different environment to be passed to the child process through the<B> envp</B> argument.
&nbsp;The argument<B> envp</B> is a pointer to an array of character pointers, each of which points to a string defining an
environment variable.&nbsp; The array is terminated with a<TT> NULL</TT> pointer.&nbsp; Each pointer locates a character string
of the form
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; variable=value</TT>
<BR><BR>that is used to define an environment variable.&nbsp; If the value of<B> envp</B> is<TT> NULL</TT>, then the child
process inherits the environment of the parent process.
<BR><BR>The environment is the collection of environment variables whose values have been defined with the DOS<TT> SET</TT>
command or by the successful execution of the <TT> putenv</TT> function.&nbsp; A program may read these values with the <TT>
getenv</TT> function.
<BR><BR>The <TT> execvpe</TT> and <TT> execlpe</TT> functions are extensions to POSIX 1003.1.
<BR><BR>The<TT> _wexec...</TT>&nbsp; functions are similar to their counterparts but operate on wide-character strings.
</DL>
<DL>
<DT>Returns:
<DD>When the invoked program is successfully initiated, no return occurs.&nbsp; When an error is detected while invoking the indicated
program, exec...&nbsp; returns -1 and <TT> errno</TT> is set to indicate the error.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>E2BIG
<DD>The argument list exceeds 128 bytes, or the space required for the environment information exceeds 32K.
<DT>EACCES
<DD>The specified file has a locking or sharing violation.
<DT>EMFILE
<DD>Too many files open
<DT>ENOENT
<DD>Path or file not found
<DT>ENOMEM
<DD>Not enough memory is available to execute the child process.
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#abort">abort</A>, <A HREF="#atexit">atexit</A>, <A HREF="#exit">exit</A>, <A HREF="#_Exit">_Exit</A>, <A HREF="#_exit">_exit</A>,
<A HREF="#getcmd">getcmd</A>, <A HREF="#getenv">getenv</A>, <A HREF="#main">main</A>, <A HREF="#putenv">putenv</A>, <A HREF="#spawn___">spawn...</A>,
<A HREF="#system">system</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stddef.h&gt;</TT>
<BR><TT>#include &lt;process.h&gt;</TT>
<BR><BR><TT>execl( &quot;myprog&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;myprog&quot;, &quot;ARG1&quot;, &quot;ARG2&quot;, NULL );</TT>
<BR><BR>The preceding invokes &quot;myprog&quot; as if
<BR><BR><TT>&nbsp;&nbsp;&nbsp; myprog ARG1 ARG2</TT>
<BR><BR>had been entered as a command to DOS.&nbsp; The program will be found if one of
<BR><BR><TT>&nbsp;&nbsp;&nbsp; myprog.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; myprog.com</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; myprog.exe</TT>
<BR><BR>is found in the current working directory.
<BR><BR><TT>#include &lt;stddef.h&gt;</TT>
<BR><TT>#include &lt;process.h&gt;</TT>
<BR><BR><TT>char *env_list[] = { &quot;SOURCE=MYDATA&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&quot;TARGET=OUTPUT&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&quot;lines=65&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;NULL</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
};</TT>
<BR><BR><TT>execle( &quot;myprog&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;myprog&quot;, &quot;ARG1&quot;, &quot;ARG2&quot;, NULL,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env_list );</TT>
<BR><BR>The preceding invokes &quot;myprog&quot; as if
<BR><BR><TT>&nbsp;&nbsp;&nbsp; myprog ARG1 ARG2</TT>
<BR>had been entered as a command to DOS.&nbsp; The program will be found if one of
<BR><BR><TT>&nbsp;&nbsp;&nbsp; myprog.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; myprog.com</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; myprog.exe</TT>
<BR><BR>is found in the current working directory.&nbsp; The DOS environment for the invoked program will consist of the three
environment variables<TT> SOURCE, TARGET</TT> and<TT> lines.</TT>
<BR><BR><TT>#include &lt;stddef.h&gt;</TT>
<BR><TT>#include &lt;process.h&gt;</TT>
<BR><BR><TT>char *arg_list[] = { &quot;myprog&quot;, &quot;ARG1&quot;, &quot;ARG2&quot;, NULL };</TT>
<BR><BR><TT>execv( &quot;myprog&quot;, arg_list );</TT>
<BR><BR>The preceding invokes &quot;myprog&quot; as if
<BR><BR><TT>&nbsp;&nbsp;&nbsp; myprog ARG1 ARG2</TT>
<BR><BR>had been entered as a command to DOS.&nbsp; The program will be found if one of
<BR><BR><TT>&nbsp;&nbsp;&nbsp; myprog.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; myprog.com</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; myprog.exe</TT>
<BR><BR>is found in the current working directory.
</DL>
<DL>
<DT>Classification:
<DD>POSIX 1003.1 with extensions
<BR><BR>_exec...&nbsp; conforms to ANSI naming conventions
<BR>_wexec...&nbsp; is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> execl - DOS/16, Win32, OS/2 1.x(all), OS/2-32, Linux, RDOS</TT>
<BR><BR><TT>execle - DOS/16, Win32, OS/2 1.x(all), OS/2-32, Linux, RDOS</TT>
<BR><TT>execlp - DOS/16, Win32, OS/2 1.x(all), OS/2-32, Linux, RDOS</TT>
<BR><TT>execlpe - DOS/16, Win32, OS/2 1.x(all), OS/2-32, Linux, RDOS</TT>
<BR><TT>execv - DOS/16, Win32, OS/2 1.x(all), OS/2-32, Linux, RDOS</TT>
<BR><TT>execve - DOS/16, Win32, OS/2 1.x(all), OS/2-32, Linux, RDOS</TT>
<BR><TT>execvp - DOS/16, Win32, OS/2 1.x(all), OS/2-32, Linux, RDOS</TT>
<BR><TT>execvpe - DOS/16, Win32, OS/2 1.x(all), OS/2-32, Linux, RDOS</TT>
<BR><TT>_execl - DOS/16, Win32, OS/2 1.x(all), OS/2-32, Linux, RDOS</TT>
<BR><TT>_execle - DOS/16, Win32, OS/2 1.x(all), OS/2-32, Linux, RDOS</TT>
<BR><TT>_execlp - DOS/16, Win32, OS/2 1.x(all), OS/2-32, Linux, RDOS</TT>
<BR><TT>_execlpe - DOS/16, Win32, OS/2 1.x(all), OS/2-32, Linux, RDOS</TT>
<BR><TT>_execv - DOS/16, Win32, OS/2 1.x(all), OS/2-32, Linux, RDOS</TT>
<BR><TT>_execve - DOS/16, Win32, OS/2 1.x(all), OS/2-32, Linux, RDOS</TT>
<BR><TT>_execvp - DOS/16, Win32, OS/2 1.x(all), OS/2-32, Linux, RDOS</TT>
<BR><TT>_execvpe - DOS/16, Win32, OS/2 1.x(all), OS/2-32, Linux, RDOS</TT>
<BR><TT>_wexecl - DOS/16, Win32, OS/2 1.x(all), OS/2-32</TT>
<BR><TT>_wexecle - DOS/16, Win32, OS/2 1.x(all), OS/2-32</TT>
<BR><TT>_wexeclp - DOS/16, Win32, OS/2 1.x(all), OS/2-32</TT>
<BR><TT>_wexeclpe - DOS/16, Win32, OS/2 1.x(all), OS/2-32</TT>
<BR><TT>_wexecv - DOS/16, Win32, OS/2 1.x(all), OS/2-32</TT>
<BR><TT>_wexecve - DOS/16, Win32, OS/2 1.x(all), OS/2-32</TT>
<BR><TT>_wexecvp - DOS/16, Win32, OS/2 1.x(all), OS/2-32</TT>
<BR><TT>_wexecvpe - DOS/16, Win32, OS/2 1.x(all), OS/2-32</TT>
</DL>
<H2 ID="_Exit"> _Exit, _exit </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>void _Exit( int status );</TT>
<BR><TT>void _exit( int status );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _Exit</TT> function causes normal program termination to occur.
<OL>
<LI>The functions registered by the <TT> atexit</TT> or <TT> onexit</TT> functions are not called.
<LI>Any unopened files are not closed and any buffered output is not flushed to the associated files or devices.
<LI>Any files created by <TT> tmpfile</TT> are not removed.
<LI>The return<B> status</B> is made available to the parent process.&nbsp; Only the low order byte of<B> status</B> is available
on DOS systems.&nbsp; The<B> status</B> value is typically set to 0 to indicate successful termination and set to some other
value to indicate an error.
</OL>
<BR>The<TT> _exit</TT> is functionaly equivalent to<TT> _Exit.</TT>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _Exit</TT> function does not return to its caller.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#abort">abort</A>, <A HREF="#atexit">atexit</A>, <A HREF="#_bgetcmd">_bgetcmd</A>, <A HREF="#exec___">exec...</A>,
<A HREF="#exit">exit</A>, <A HREF="#_exit">_exit</A>, <A HREF="#getcmd">getcmd</A>, <A HREF="#getenv">getenv</A>, <A HREF="#main">main</A>,
<A HREF="#onexit">onexit</A>, <A HREF="#putenv">putenv</A>, <A HREF="#spawn___">spawn...</A>, <A HREF="#system">system</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>void main( int argc, char *argv[] )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FILE *fp;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; if( argc &lt;= 1 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf( stderr, &quot;Missing argument\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit( EXIT_FAILURE );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; fp = fopen( argv[1], &quot;r&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( fp == NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf( stderr, &quot;Unable to open '%s'\n&quot;, argv[1] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _Exit( EXIT_FAILURE );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fclose( fp );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _Exit( EXIT_SUCCESS );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C99
<BR><BR>_exit is POSIX 1003.1
</DL>
<DL>
<DT>Systems:
<DD><TT> _Exit - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_exit - All, Linux, RDOS, Netware</TT>
</DL>
<H2 ID="exit"> exit </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>void exit( int status );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> exit</TT> function causes normal program termination to occur.
<BR><BR>First, all functions registered by the <TT> atexit</TT> function are called in the reverse order of their registration.
&nbsp;Next, all open files are flushed and closed, and all files created by the <TT> tmpfile</TT> function are removed.&nbsp;
Finally, the return<B> status</B> is made available to the parent process.&nbsp; Only the low order byte of<B> status</B>
is available on DOS systems.&nbsp; The<B> status</B> value is typically set to 0 to indicate successful termination and set
to some other value to indicate an error.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> exit</TT> function does not return to its caller.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#abort">abort</A>, <A HREF="#atexit">atexit</A>, <A HREF="#_Exit">_Exit</A>, <A HREF="#_exit">_exit</A>, <A HREF="#onexit">onexit</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>void main( int argc, char *argv[] )</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FILE *fp;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; if( argc &lt;= 1 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf( stderr, &quot;Missing argument\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit( EXIT_FAILURE );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; fp = fopen( argv[1], &quot;r&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( fp == NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf( stderr, &quot;Unable to open '%s'\n&quot;, argv[1] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit( EXIT_FAILURE );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fclose( fp );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; exit( EXIT_SUCCESS );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="exp"> exp </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>double exp( double x );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> exp</TT> function computes the exponential function of<B> x</B>.&nbsp; A range error occurs if the magnitude of<B>
x</B> is too large.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> exp</TT> function returns the exponential value.&nbsp; When the argument is outside the permissible range, the <TT>
matherr</TT> function is called.&nbsp; Unless the default <TT> matherr</TT> function is replaced, it will set the global variable
<TT> errno</TT> to <TT> ERANGE</TT>, and print a &quot;RANGE error&quot; diagnostic message using the <TT> stderr</TT> stream.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#log">log</A>, <A HREF="#matherr">matherr</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, exp(.5) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>1.648721</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD>Math
</DL>
<H2 ID="exp2"> exp2 </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>double exp2( double x );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> exp2</TT> function computes 2.0 raised to the value<B> x</B>.&nbsp; The current implementation uses a simple power
calculation.
</DL>
<DL>
<DT>Returns:
<DD>The function returns two to the power<B> x</B>.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#exp">exp</A>, <A HREF="#pow">pow</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, exp2( 2.0 ) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>4.000000</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C99
</DL>
<DL>
<DT>Systems:
<DD>Math
</DL>
<H2 ID="expm1"> expm1 </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>double expm1( double x );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> expm1</TT> function computes the value of the exponential of<B> x</B> minus 1.&nbsp; This routine provides far better
accuracy for cases where the exponential of the argument<B> x</B> is significantly less than 1.0.
</DL>
<DL>
<DT>Returns:
<DD>The function returns a the exponential of ,arg x minus 1 without loss of accuracy due to subtractive cancelation.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#exp">exp</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, expm1( -1.0E-3 ) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>-0.000995</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C99
</DL>
<DL>
<DT>Systems:
<DD>Math
</DL>
<H2 ID="_expand"> _expand Functions </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;malloc.h&gt;</TT>
<BR><TT>void&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *_expand( void *mem_blk, size_t size );</TT>
<BR><TT>void __based(void) *_bexpand( __segment seg,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void __based(void) *mem_blk,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t size );</TT>
<BR><TT>void __far&nbsp; *_fexpand(void __far&nbsp; *mem_blk,size_t size);</TT>
<BR><TT>void __near *_nexpand(void __near *mem_blk,size_t size);</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _expand</TT> functions change the size of the previously allocated block pointed to by<B> mem_blk</B> by attempting
to expand or contract the memory block without moving its location in the heap.&nbsp; The argument<B> size</B> specifies the
new desired size for the memory block.&nbsp; The contents of the memory block are unchanged up to the shorter of the new and
old sizes.
<BR><BR>Each function expands the memory from a particular heap, as listed below:
<DL>
<DT>Function&nbsp;&nbsp;&nbsp;&nbsp; Heap Expanded
<DT>_expand
<DD>Depends on data model of the program
<DT>_bexpand
<DD>Based heap specified by<B> seg</B> value
<DT>_fexpand
<DD>Far heap (outside the default data segment)
<DT>_nexpand
<DD>Near heap (inside the default data segment)
</DL>
<BR>In a small data memory model, the<TT> _expand</TT> function is equivalent to the <TT> _nexpand</TT> function; in a large
data memory model, the<TT> _expand</TT> function is equivalent to the <TT> _fexpand</TT> function.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _expand</TT> functions return the value<B> mem_blk</B> if it was successful in changing the size of the block.&nbsp;
The return value is<TT> NULL</TT> (<TT>_NULLOFF</TT> for <TT> _bexpand</TT>) if the memory block could not be expanded to
the desired size.&nbsp; It will be expanded as much as possible in this case.
<BR><BR>The appropriate <TT> _msize</TT> function can be used to determine the new size of the expanded block.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#calloc">calloc</A> Functions, <A HREF="#free">free</A> Functions, <A HREF="#halloc">halloc</A>, <A HREF="#hfree">hfree</A>,
<A HREF="#malloc">malloc</A> Functions, <A HREF="#_msize">_msize</A> Functions, <A HREF="#realloc">realloc</A> Functions,
<A HREF="#sbrk">sbrk</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;malloc.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char *buf;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char __far *buf2;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; buf = (char *) malloc( 80 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Size of buffer is %u\n&quot;, _msize(buf) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( _expand( buf, 100 ) == NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Unable to expand buffer\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;New size of buffer is %u\n&quot;, _msize(buf) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; buf2 = (char __far *) _fmalloc( 2000 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Size of far buffer is %u\n&quot;, _fmsize(buf2) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( _fexpand( buf2, 8000 ) == NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Unable to expand far buffer\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;New size of far buffer is %u\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fmsize(buf2) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>Size of buffer is 80</TT>
<BR><TT>Unable to expand buffer</TT>
<BR><TT>New size of buffer is 80</TT>
<BR><TT>Size of far buffer is 2000</TT>
<BR><TT>New size of far buffer is 8000</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> _expand - All, Linux, RDOS</TT>
<BR><BR><TT>_bexpand - DOS/16, Windows, OS/2 1.x(all)</TT>
<BR><TT>_fexpand - DOS/16, Windows, OS/2 1.x(all)</TT>
<BR><TT>_nexpand - DOS, Windows, Win386, Win32, OS/2 1.x, OS/2 1.x(MT), OS/2-32, Linux, RDOS</TT>
</DL>
<H2 ID="fabs"> fabs </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>double fabs( double x );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> fabs</TT> function computes the absolute value of the argument<B> x</B>.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> fabs</TT> function returns the absolute value of<B> x</B>.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#abs">abs</A>, <A HREF="#labs">labs</A>, <A HREF="#imaxabs">imaxabs</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%f %f\n&quot;, fabs(.5), fabs(-.5) );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>0.500000 0.500000</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD>Math
</DL>
<H2 ID="fclose"> fclose </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>int fclose( FILE *fp );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> fclose</TT> function closes the file<B> fp</B>.&nbsp; If there was any unwritten buffered data for the file, it is
written out before the file is closed.&nbsp; Any unread buffered data is discarded.&nbsp; If the associated buffer was automatically
allocated, it is deallocated.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> fclose</TT> function returns zero if the file was successfully closed, or non-zero if any errors were detected.&nbsp;
When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#fcloseall">fcloseall</A>, <A HREF="#fdopen">fdopen</A>, <A HREF="#fopen">fopen</A>, <A HREF="#freopen">freopen</A>,
<A HREF="#_fsopen">_fsopen</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FILE *fp;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; fp = fopen( &quot;stdio.h&quot;, &quot;r&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( fp != NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( fp );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="fcloseall"> fcloseall </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>int fcloseall( void );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> fcloseall</TT> function closes all open stream files, except <TT> stdin</TT>, <TT> stdout</TT>, <TT> stderr</TT>,
<TT> stdaux</TT>, and <TT> stdprn</TT>.&nbsp; This includes streams created (and not yet closed) by <TT> fdopen</TT>, <TT>
fopen</TT> and <TT> freopen</TT>.&nbsp; The<B> stdaux</B> and<B> stdprn</B> files are not available for some Windows platforms.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> fcloseall</TT> function returns the number of streams that were closed if no errors were encountered.&nbsp; When an
error occurs, <TT> EOF</TT> is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#fclose">fclose</A>, <A HREF="#fdopen">fdopen</A>, <A HREF="#fopen">fopen</A>, <A HREF="#freopen">freopen</A>, <A HREF="#_fsopen">_fsopen</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;The number of files closed is %d\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fcloseall() );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="fcvt"> fcvt, _fcvt, _wfcvt </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>char *fcvt( double value,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int ndigits,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int *dec,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int *sign );</TT>
<BR><TT>char *_fcvt( double value,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int ndigits,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int *dec,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int *sign );</TT>
<BR><TT>wchar_t *_wfcvt( double value,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int ndigits,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int *dec,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int *sign );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> fcvt</TT> function converts the floating-point number<B> value</B> into a character string.&nbsp; The parameter<B>
ndigits</B> specifies the number of digits desired after the decimal point.&nbsp; The converted number will be rounded to
this position.
<BR><BR>The character string will contain only digits and is terminated by a null character.&nbsp; The integer pointed to
by<B> dec</B> will be filled in with a value indicating the position of the decimal point relative to the start of the string
of digits.&nbsp; A zero or negative value indicates that the decimal point lies to the left of the first digit.&nbsp; The
integer pointed to by<B> sign</B> will contain 0 if the number is positive, and non-zero if the number is negative.
<BR><BR>The<TT> _fcvt</TT> function is identical to<TT> fcvt</TT>.&nbsp; Use<TT> _fcvt</TT> for ANSI naming conventions.
<BR><BR>The<TT> _wfcvt</TT> function is a wide-character version of<TT> fcvt</TT>.&nbsp; It produces a wide-character string.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> fcvt</TT> function returns a pointer to a static buffer containing the converted string of digits.&nbsp; Note:&nbsp;
<TT> ecvt</TT> and<TT> fcvt</TT> both use the same static buffer.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#ecvt">ecvt</A>, <A HREF="#gcvt">gcvt</A>, <A HREF="#printf">printf</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char *str;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp; dec, sign;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; str = fcvt( -123.456789, 5, &amp;dec, &amp;sign );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;str=%s, dec=%d, sign=%d\n&quot;, str,dec,sign );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>str=12345679, dec=3, sign=-1</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
<BR><BR>_fcvt conforms to ANSI naming conventions
</DL>
<DL>
<DT>Systems:
<DD><TT> fcvt - Math</TT>
<BR><BR><TT>_fcvt - Math</TT>
<BR><TT>_wfcvt - Math</TT>
</DL>
<H2 ID="fdim"> fdim </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>double fdim( double x, double y );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> fdim</TT> function computes the positive difference of<B> x</B> and<B> y</B>.&nbsp; The function is equivalent to:
<BR><BR><TT>fmax( x - y, 0.0 );</TT>
</DL>
<DL>
<DT>Returns:
<DD>The routine will either return<B> x</B> -<B> y</B> or 0.0, whichever is greater.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#fmax">fmax</A>, <A HREF="#fmin">fmin</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, fdim( 3.0, 2.0 ) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>1.000000</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C99
</DL>
<DL>
<DT>Systems:
<DD>Math
</DL>
<H2 ID="fdopen"> fdopen, _fdopen, _wfdopen </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>FILE *fdopen( int handle, const char *mode );</TT>
<BR><TT>FILE *_fdopen( int handle, const char *mode );</TT>
<BR><TT>FILE *_wfdopen( int handle, const wchar_t *mode );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> fdopen</TT> function associates a stream with the file handle<B> handle</B> which represents an opened file or device.
&nbsp;The handle was returned by one of <TT> creat</TT>, <TT> dup</TT>, <TT> dup2</TT>, <TT> open</TT>, or <TT> sopen</TT>.
&nbsp;The open mode<B> mode</B> must match the mode with which the file or device was originally opened.
<BR><BR>The argument<B> mode</B> is described in the description of the <TT> fopen</TT> function.
<BR><BR>The<TT> _fdopen</TT> function is identical to<TT> fdopen</TT>.&nbsp; Use<TT> _fdopen</TT> for ANSI naming conventions.
<BR><BR>The<TT> _wfdopen</TT> function is identical to<TT> fdopen</TT> except that it accepts a wide character string for
the second argument.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> fdopen</TT> function returns a pointer to the object controlling the stream.&nbsp; This pointer must be passed as
a parameter to subsequent functions for performing operations on the file.&nbsp; If the open operation fails,<TT> fdopen</TT>
returns a NULL pointer.&nbsp; When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that
has been detected.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#creat">creat</A>, <A HREF="#_dos_open">_dos_open</A>, <A HREF="#dup">dup</A>, <A HREF="#dup2">dup2</A>, <A HREF="#fopen">fopen</A>,
<A HREF="#freopen">freopen</A>, <A HREF="#_fsopen">_fsopen</A>, <A HREF="#_grow_handles">_grow_handles</A>, <A HREF="#_hdopen">_hdopen</A>,
<A HREF="#open">open</A>, <A HREF="#_open_osfhandle">_open_osfhandle</A>, <A HREF="#_popen">_popen</A>, <A HREF="#sopen">sopen</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;fcntl.h&gt;</TT>
<BR><TT>#include &lt;io.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int handle;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FILE *fp;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; handle = open( &quot;file&quot;, O_RDONLY | O_TEXT );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( handle != -1 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fp = fdopen( handle, &quot;r&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( fp != NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; process the stream</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( fp );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close( handle );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>POSIX 1003.1
<BR><BR>_fdopen conforms to ANSI naming conventions
<BR>_wfdopen is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> fdopen - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_fdopen - All, Linux, RDOS, Netware</TT>
<BR><TT>_wfdopen - All, Linux</TT>
</DL>
<H2 ID="feclearexcept"> feclearexcept </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;fenv.h&gt;</TT>
<BR><TT>int feclearexcept( int excepts );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> feclearexcept</TT> function attempts to clear the floating-point exceptions specified by the<B> excepts</B> argument.
<BR><BR>For valid exception values see <A HREF="#fegetexceptflag">fegetexceptflag</A>.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> feclearexcept</TT> function returns zero if the<B> excepts</B> argument is zero or if all the specified exceptions
were successfully cleared.&nbsp; Otherwise, it returns a nonzero value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#fegetexceptflag">fegetexceptflag</A>, <A HREF="#feraiseexcept">feraiseexcept</A>, <A HREF="#fesetexceptflag">fesetexceptflag</A>,
<A HREF="#fetestexcept">fetestexcept</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;fenv.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; feclearexcept( FE_OVERFLOW|FE_UNDERFLOW );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C99
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="fedisableexcept"> fedisableexcept, __fedisableexcept </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;fenv.h&gt;</TT>
<BR><TT>void fedisableexcept( int excepts );</TT>
<BR><TT>void __fedisableexcept( int excepts );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> fedisableexcept</TT> function disables the floating point exceptions specified by the<B> excepts</B> argument.
<BR><BR>For valid exception values see <A HREF="#fegetexceptflag">fegetexceptflag</A>.
</DL>
<DL>
<DT>Returns:
<DD>No value is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#feenableexcept">feenableexcept</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;fenv.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fedisableexcept( FE_DIVBYZERO );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> fedisableexcept - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>__fedisableexcept - All, Linux, RDOS, Netware</TT>
</DL>
<H2 ID="feenableexcept"> feenableexcept, __feenableexcept </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;fenv.h&gt;</TT>
<BR><TT>void feenableexcept( int excepts );</TT>
<BR><TT>void __feenableexcept( int excepts );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> feenableexcept</TT> function enables the floating point exceptions specified by the<B> excepts</B> argument.
<BR><BR>For valid exception values see <A HREF="#fegetexceptflag">fegetexceptflag</A>.
</DL>
<DL>
<DT>Returns:
<DD>No value is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#fedisableexcept">fedisableexcept</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;fenv.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; feenableexcept( FE_DIVBYZERO );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> feenableexcept - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>__feenableexcept - All, Linux, RDOS, Netware</TT>
</DL>
<H2 ID="fegetenv"> fegetenv </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;fenv.h&gt;</TT>
<BR><TT>int fegetenv( fenv_t *envp );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> fegetenv</TT> function attempts to store the current floating-point environment in the object pointed to by<B> envp</B>
argument.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> fegetenv</TT> function returns zero if the environment was successfully stored.&nbsp; Otherwise, it returns a nonzero
value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#feholdexcept">feholdexcept</A>, <A HREF="#fesetenv">fesetenv</A>, <A HREF="#feupdateenv">feupdateenv</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;fenv.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fenv_t env;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fegetenv( &amp;env );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C99
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="fegetexceptflag"> fegetexceptflag </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;fenv.h&gt;</TT>
<BR><TT>int fegetexceptflag( fexcept_t *flagp, int excepts );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> fegetexceptflag</TT> function attempts to store a representation of the floating-point exceptions specified by the<B>
excepts</B> argument into the fexcept_t object pointed by the<B> flagp</B> argument.
<BR><BR>Valid exception bit values are
<DL>
<DT>FE_INVALID
<DD>At least one of the arguments is a value for which the function is not defined.
<DT>FE_DENORMAL
<DD>The result is not normalized.
<DT>FE_DIVBYZERO
<DD>Division by zero.
<DT>FE_OVERFLOW
<DD>The result is too large in magnitude to be represented as the return type.
<DT>FE_UNDERFLOW
<DD>The result is too small in magnitude to be represented as the return type.
<DT>FE_INEXACT
<DD>The result is not exact.
<DT>FE_ALL_EXCEPT
<DD>Is the logical OR of all exceptions.
</DL>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> fegetexceptflag</TT> function returns zero if the representation was successfully stored.&nbsp; Otherwise, it returns
a nonzero value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#feclearexcept">feclearexcept</A>, <A HREF="#feraiseexcept">feraiseexcept</A>, <A HREF="#fesetexceptflag">fesetexceptflag</A>,
<A HREF="#fetestexcept">fetestexcept</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;fenv.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fexcept_t flags;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fegetexceptflag( &amp;flags, FE_DIVBYZERO );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C99
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="fegetround"> fegetround </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;fenv.h&gt;</TT>
<BR><TT>int fegetround( void );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> fegetround</TT> function returns a value that indicates the rounding direction mode, as specified in the current floating
point environment.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> fegetround</TT> function returns the value of the rounding direction macro representing the current rounding direction
or a negative value if there is no such rounding direction macro or the current rounding direction is not determinable.
<BR><BR>For valid rounding modes see <A HREF="#fesetround">fesetround</A>.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#fesetround">fesetround</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;fenv.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int mode;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; mode = fegetround();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if ( mode == FE_TONEAREST )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Nearest\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; else if ( mode == FE_DOWNWARD )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Down\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; else if ( mode == FE_TOWARDZERO )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;To Zero\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; else if ( mode == FE_UPWARD )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Up\n&quot; );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C99
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="feholdexcept"> feholdexcept </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;fenv.h&gt;</TT>
<BR><TT>int feholdexcept( fenv_t *envp );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> feholdexcept</TT> function saves the current floating-point environment in the object pointed to by<B> envp</B> argument,
clears the floating-point status flags, and then installs a non-stop (continue on floating-point exceptions) mode, if available,
for all floating-point exceptions.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> feholdexcept</TT> function returns zero if and only if non-stop floating-point exception handling was successfully
installed.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#fegetenv">fegetenv</A>, <A HREF="#fesetenv">fesetenv</A>, <A HREF="#feupdateenv">feupdateenv</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;fenv.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fenv_t env;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; feholdexcept( &amp;env );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C99
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="feof"> feof </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>int feof( FILE *fp );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> feof</TT> function tests the end-of-file indicator for the stream pointed to by<B> fp</B>.&nbsp; Because this indicator
is set when an input operation attempts to read past the end of the file the feof function will detect the end of the file
only after an attempt is made to read beyond the end of the file.&nbsp; Thus, if a file contains 10 lines, the<TT> feof</TT>
will not detect end of file after the tenth line is read; it will detect end of file once the program attempts to read more
data.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> feof</TT> function returns non-zero if the end-of-file indicator is set for<B> fp</B>.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#clearerr">clearerr</A>, <A HREF="#ferror">ferror</A>, <A HREF="#fopen">fopen</A>, <A HREF="#freopen">freopen</A>,
<A HREF="#perror">perror</A>, <A HREF="#read">read</A>, <A HREF="#strerror">strerror</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>void process_record( char *buf )</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, buf );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FILE *fp;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char buffer[100];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; fp = fopen( &quot;file&quot;, &quot;r&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fgets( buffer, sizeof( buffer ), fp );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; while( ! feof( fp ) ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; process_record( buffer );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fgets( buffer, sizeof( buffer ), fp );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fclose( fp );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="feraiseexcept"> feraiseexcept </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;fenv.h&gt;</TT>
<BR><TT>int feraiseexcept( int excepts );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> feraiseexcept</TT> function attempts to raise the floating-point exceptions specified by the<B> excepts</B> argument.
<BR><BR>For valid exception values see <A HREF="#fegetexceptflag">fegetexceptflag</A>.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> feraiseexcept</TT> function returns zero if the<B> excepts</B> argument is zero or if all the specified exceptions
were successfully raised.&nbsp; Otherwise, it returns a nonzero value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#feclearexcept">feclearexcept</A>, <A HREF="#fegetexceptflag">fegetexceptflag</A>, <A HREF="#fetestexcept">fetestexcept</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;fenv.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; feraiseexcept( FE_DIVBYZERO );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C99
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="ferror"> ferror </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>int ferror( FILE *fp );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> ferror</TT> function tests the error indicator for the stream pointed to by<B> fp</B>.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> ferror</TT> function returns non-zero if the error indicator is set for<B> fp</B>.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#clearerr">clearerr</A>, <A HREF="#feof">feof</A>, <A HREF="#perror">perror</A>, <A HREF="#strerror">strerror</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FILE *fp;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int c;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; fp = fopen( &quot;file&quot;, &quot;r&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( fp != NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c = fgetc( fp );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( ferror( fp ) ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Error reading file\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fclose( fp );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="fesetenv"> fesetenv </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;fenv.h&gt;</TT>
<BR><TT>int fesetenv( const fenv_t *envp );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> fesetenv</TT> function attempts to establish the floating-point environment to environment represented by the object
pointed by<B> envp</B> argument.&nbsp; The<B> envp</B> argument shall point to an object set by a call to <TT> fegetenv</TT>
or <TT> feholdexcept</TT> , or equal the <TT> FE_DFL_ENV</TT> macro.&nbsp; Note that fesetenv merely installs the state of
the floating-point status flags represented through its argument, and does not raise these floating-point exceptions.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> fesetenv</TT> function returns zero if the environment was successfully established.&nbsp; Otherwise, it returns a
nonzero value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#fegetenv">fegetenv</A>, <A HREF="#feholdexcept">feholdexcept</A>, <A HREF="#feupdateenv">feupdateenv</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;fenv.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fenv_t env;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fegetenv( &amp;env );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fesetenv( FE_DFL_ENV );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fesetenv( &amp;env );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C99
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="fesetexceptflag"> fesetexceptflag </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;fenv.h&gt;</TT>
<BR><TT>int fesetexceptflag( const fexcept_t *flagp, int excepts );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> fesetexceptflag</TT> function attempts to set the exceptions indicated by<B> excepts</B> argument with the states
stored in the object pointed by<B> flagp</B> argument.&nbsp; The value pointed by the<B> flagp</B> argument shall have been
set by a previous call to <TT> fegetexceptflag</TT> whose second argument represented at least those floating-point exceptions
represented by the<B> excepts</B> argument.&nbsp; This function does not raise floating-point exceptions, but only sets the
state of the flags.
<BR><BR>For valid exception values see <A HREF="#fegetexceptflag">fegetexceptflag</A>.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> fesetexceptflag</TT> function returns zero if the<B> excepts</B> argument is zero or if all the specified flags were
successfully set to the appropriate state.&nbsp; Otherwise, it returns a nonzero value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#feclearexcept">feclearexcept</A>, <A HREF="#fegetexceptflag">fegetexceptflag</A>, <A HREF="#fetestexcept">fetestexcept</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;fenv.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fexcept_t flags;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fgetexceptflag( &amp;flags, FE_DENORMAL|FE_INVALID );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fsetexceptflag( &amp;flags, FE_INVALID );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C99
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="fesetround"> fesetround </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;fenv.h&gt;</TT>
<BR><TT>int fesetround( int mode );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> fesetround</TT> function sets the rounding direction mode, specified by<B> mode</B>, for the current floating point
environment.
<BR><BR>The rounding direction mode can be one of the following values:
<DL>
<DT>FE_TONEAREST
<DD>Round to nearest integer, halfway rounding away from zero
<DT>FE_DOWNWARD
<DD>Round downward to the next lowest integer
<DT>FE_TOWARDZERO
<DD>Round to the nearest integer in the direction of zero
<DT>FE_UPWARD
<DD>Round upward to the next highest integer
</DL>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> fesetround</TT> function returns a zero value if and only if the requested rounding direction was established.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#fegetround">fegetround</A>, <A HREF="#nearbyint">nearbyint</A>, <A HREF="#rint">rint</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fesetround(FE_DOWNWARD)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, rint( 1.5 ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fesetround(FE_UPWARD)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, rint( 1.5 ) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>1.00000</TT>
<BR><TT>2.00000</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C99
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="fetestexcept"> fetestexcept </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;fenv.h&gt;</TT>
<BR><TT>int fetestexcept( int excepts );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> fetestexcept</TT> function tests which of the specified floating-point exceptions flags are currently set.&nbsp; The<B>
excepts</B> argument specifies the floating-point exceptions to be queried.
<BR><BR>For valid exception values see <A HREF="#fegetexceptflag">fegetexceptflag</A>.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> fetestexcept</TT> function returns the value of the bitwise OR of the floating-point exception macros corresponding
to the currently set floating-point exceptions included in the<B> excepts</B> argument.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#feclearexcept">feclearexcept</A>, <A HREF="#fegetexceptflag">fegetexceptflag</A>, <A HREF="#feraiseexcept">feraiseexcept</A>,
<A HREF="#fesetexceptflag">fesetexceptflag</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;fenv.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int excepts;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; feclearexcept( FE_DIVBYZERO );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; ...code that may cause a divide by zero exception</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; excepts = fetestexcept( FE_DIVBYZERO );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if ( excepts &amp; FE_DIVBYZERO)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Divide by zero occurred\n&quot; );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C99
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="feupdateenv"> feupdateenv </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;fenv.h&gt;</TT>
<BR><TT>int feupdateenv( const fenv_t *envp );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> feupdateenv</TT> function attempts to save the currently raised floating-point exceptions in its automatic storage,
installs the floating-point environment represented by the object pointed to by<B> envp</B> argument, and then raises the
saved floating-point exceptions.&nbsp; The argument<B> envp</B> shall point to an object set by a call to feholdexcept or
fegetenv, or equal a floating-point environment macro.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> feupdateenv</TT> function returns zero if all the actions were successfully carried out.&nbsp; Otherwise, it returns
a nonzero value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#fegetenv">fegetenv</A>, <A HREF="#feholdexcept">feholdexcept</A>, <A HREF="#fesetenv">fesetenv</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;fenv.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fenv_t env;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fegetenv( &amp;env );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fesetenv( FE_DFL_ENV );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; feupdateenv( &amp;env );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C99
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="fflush"> fflush </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>int fflush( FILE *fp );</TT>
</DL>
<DL>
<DT>Description:
<DD>If the file<B> fp</B> is open for output or update, the fflush function causes any unwritten data to be written to the file.
&nbsp;If the file<B> fp</B> is open for input or update, the<TT> fflush</TT> function undoes the effect of any preceding <TT>
ungetc</TT> operation on the stream.&nbsp; If the value of<B> fp</B> is<TT> NULL,</TT> then all files that are open will be
flushed.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> fflush</TT> function returns <TT> EOF</TT> if a write error occurs and zero otherwise.&nbsp; When an error has occurred,
<TT> errno</TT> contains a value indicating the type of error that has been detected.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#fgetc">fgetc</A>, <A HREF="#fgets">fgets</A>, <A HREF="#flushall">flushall</A>, <A HREF="#fopen">fopen</A>, <A HREF="#getc">getc</A>,
<A HREF="#gets">gets</A>, <A HREF="#setbuf">setbuf</A>, <A HREF="#setvbuf">setvbuf</A>, <A HREF="#ungetc">ungetc</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Press any key to continue...&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fflush( stdout );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="ffs"> ffs </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;strings.h&gt;</TT>
<BR><TT>int ffs( int i );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> ffs</TT> finds the first bit set, beginning with the least significant bit, in<B> i</B>.&nbsp; Bits are numbered starting
at one (the least significant bit).
</DL>
<DL>
<DT>Returns:
<DD>The<TT> ffs</TT> function returns the index of the first bit set.&nbsp; If<B> i</B> is 0,<TT> ffs</TT> returns zero.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_lrotl">_lrotl</A>, <A HREF="#_lrotr">_lrotr</A>, <A HREF="#_rotl">_rotl</A>, <A HREF="#_rotr">_rotr</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;strings.h&gt;</TT>
<BR><BR><TT>int main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, ffs( 0 ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, ffs( 16 ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, ffs( 127 ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, ffs( -16 ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; return( 0 );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>0</TT>
<BR><TT>5</TT>
<BR><TT>1</TT>
<BR><TT>5</TT>
</DL>
<DL>
<DT>Classification:
<DD>POSIX
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="fgetc"> fgetc, fgetwc </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>int fgetc( FILE *fp );</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>wint_t fgetwc( FILE *fp );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> fgetc</TT> function gets the next character from the file designated by<B> fp</B>.&nbsp; The character is<TT> signed.</TT>
<BR><BR>The<TT> fgetwc</TT> function is identical to<TT> fgetc</TT> except that it gets the next multibyte character (if present)
from the input stream pointed to by<B> fp</B> and converts it to a wide character.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> fgetc</TT> function returns the next character from the input stream pointed to by<B> fp</B>.&nbsp; If the stream
is at end-of-file, the end-of-file indicator is set and<TT> fgetc</TT> returns <TT> EOF</TT>.&nbsp; If a read error occurs,
the error indicator is set and<TT> fgetc</TT> returns <TT> EOF</TT>.
<BR><BR>The<TT> fgetwc</TT> function returns the next wide character from the input stream pointed to by<B> fp</B>.&nbsp;
If the stream is at end-of-file, the end-of-file indicator is set and<TT> fgetwc</TT> returns <TT> WEOF</TT>.&nbsp; If a read
error occurs, the error indicator is set and<TT> fgetwc</TT> returns <TT> WEOF</TT>.&nbsp; If an encoding error occurs, <TT>
errno</TT> is set to <TT> EILSEQ</TT> and<TT> fgetwc</TT> returns <TT> WEOF</TT>.
<BR><BR>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#fgetchar">fgetchar</A>, <A HREF="#fgets">fgets</A>, <A HREF="#fopen">fopen</A>, <A HREF="#getc">getc</A>, <A HREF="#getchar">getchar</A>,
<A HREF="#gets">gets</A>, <A HREF="#ungetc">ungetc</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FILE *fp;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int c;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; fp = fopen( &quot;file&quot;, &quot;r&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( fp != NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( (c = fgetc( fp )) != EOF )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fputc( c, stdout );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( fp );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD><TT> fgetc - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>fgetwc - All, Linux</TT>
</DL>
<H2 ID="fgetchar"> fgetchar, _fgetchar, _fgetwchar </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>int fgetchar( void );</TT>
<BR><TT>int _fgetchar( void );</TT>
<BR><TT>wint_t _fgetwchar( void );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> fgetchar</TT> function is equivalent to <TT> fgetc</TT> with the argument <TT> stdin</TT>.
<BR><BR>The<TT> _fgetchar</TT> function is identical to<TT> fgetchar</TT>.&nbsp; Use<TT> _fgetchar</TT> for ANSI naming conventions.
<BR><BR>The<TT> _fgetwchar</TT> function is identical to<TT> fgetchar</TT> except that it gets the next multibyte character
(if present) from the input stream pointed to by <TT> stdin</TT> and converts it to a wide character.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> fgetchar</TT> function returns the next character from the input stream pointed to by <TT> stdin</TT>.&nbsp; If the
stream is at end-of-file, the end-of-file indicator is set and<TT> fgetchar</TT> returns <TT> EOF</TT>.&nbsp; If a read error
occurs, the error indicator is set and<TT> fgetchar</TT> returns <TT> EOF</TT>.
<BR><BR>The<TT> _fgetwchar</TT> function returns the next wide character from the input stream pointed to by <TT> stdin</TT>.
&nbsp;If the stream is at end-of-file, the end-of-file indicator is set and<TT> _fgetwchar</TT> returns <TT> WEOF</TT>.&nbsp;
If a read error occurs, the error indicator is set and<TT> _fgetwchar</TT> returns <TT> WEOF</TT>.&nbsp; If an encoding error
occurs, <TT> errno</TT> is set to <TT> EILSEQ</TT> and<TT> _fgetwchar</TT> returns <TT> WEOF</TT>.
<BR><BR>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#fgetc">fgetc</A>, <A HREF="#fgets">fgets</A>, <A HREF="#fopen">fopen</A>, <A HREF="#getc">getc</A>, <A HREF="#getchar">getchar</A>,
<A HREF="#gets">gets</A>, <A HREF="#ungetc">ungetc</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FILE *fp;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int c;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; fp = freopen( &quot;file&quot;, &quot;r&quot;, stdin );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( fp != NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( (c = fgetchar()) != EOF )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fputchar(c);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( fp );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
<BR><BR>_fgetchar conforms to ANSI naming conventions
</DL>
<DL>
<DT>Systems:
<DD><TT> fgetchar - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_fgetchar - All, Linux, RDOS, Netware</TT>
<BR><TT>_fgetwchar - All, Linux</TT>
</DL>
<H2 ID="fgetpos"> fgetpos </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>int fgetpos( FILE *fp, fpos_t *pos );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> fgetpos</TT> function stores the current position of the file<B> fp</B> in the object pointed to by<B> pos</B>.&nbsp;
The value stored is usable by the <TT> fsetpos</TT> function for repositioning the file to its position at the time of the
call to the<TT> fgetpos</TT> function.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> fgetpos</TT> function returns zero if successful, otherwise, the<TT> fgetpos</TT> function returns a non-zero value.
&nbsp;When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#fopen">fopen</A>, <A HREF="#fseek">fseek</A>, <A HREF="#fsetpos">fsetpos</A>, <A HREF="#ftell">ftell</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FILE *fp;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fpos_t position;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; auto char buffer[80];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; fp = fopen( &quot;file&quot;, &quot;r&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( fp != NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fgetpos( fp, &amp;position ); /* get position&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fgets( buffer, 80, fp );&nbsp; /* read record&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fsetpos( fp, &amp;position ); /* set position&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fgets( buffer, 80, fp );&nbsp; /* read same record */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( fp );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="fgets"> fgets, fgetws </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>char *fgets( char *buf, int n, FILE *fp );</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>wchar_t *fgetws( wchar_t *buf, int n, FILE *fp );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> fgets</TT> function gets a string of characters from the file designated by<B> fp</B> and stores them in the array
pointed to by<B> buf</B>.&nbsp; The<TT> fgets</TT> function stops reading characters when end-of-file is reached, or when
a newline character is read, or when<B> n-1</B> characters have been read, whichever comes first.&nbsp; The new-line character
is not discarded.&nbsp; A null character is placed immediately after the last character read into the array.
<BR><BR>The<TT> fgetws</TT> function is identical to<TT> fgets</TT> except that it gets a string of multibyte characters (if
present) from the input stream pointed to by<B> fp</B>, converts them to wide characters, and stores them in the wide-character
array pointed to by<B> buf</B>.&nbsp; In this case,<B> n</B> specifies the number of wide characters, less one, to be read.
<BR><BR>A common programming error is to assume the presence of a new-line character in every string that is read into the
array.&nbsp; A new-line character will not be present when more than<B> n-1</B> characters occur before the new-line.&nbsp;
Also, a new-line character may not appear as the last character in a file, just before end-of-file.
<BR><BR>The <TT> gets</TT> function is similar to<TT> fgets</TT> except that it operates with<TT> stdin</TT>, it has no size
argument, and it replaces a newline character with the null character.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> fgets</TT> function returns<B> buf</B> if successful.<TT>&nbsp; NULL</TT> is returned if end-of-file is encountered,
or a read error occurs.&nbsp; When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that
has been detected.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#fgetc">fgetc</A>, <A HREF="#fgetchar">fgetchar</A>, <A HREF="#fopen">fopen</A>, <A HREF="#getc">getc</A>, <A HREF="#getchar">getchar</A>,
<A HREF="#gets">gets</A>, <A HREF="#ungetc">ungetc</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FILE *fp;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char buffer[80];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; fp = fopen( &quot;file&quot;, &quot;r&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( fp != NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( fgets( buffer, 80, fp ) != NULL )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fputs( buffer, stdout );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( fp );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD><TT> fgets - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>fgetws - All, Linux</TT>
</DL>
<H2 ID="_fieeetomsbin"> _fieeetomsbin </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>extern int _fieeetomsbin( float *src, float *dest );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _fieeetomsbin</TT> function loads the float pointed to by<B> src</B> in IEEE format and converts it to Microsoft binary
format, storing the result into the float pointed to by<B> dest</B>.
<BR><BR>For<TT> _fieeetomsbin</TT> IEEE Nan's and Infinities will cause overflow.&nbsp; IEEE denormals will be converted if
within range.&nbsp; Otherwise, they will be converted to 0 in the Microsoft binary format.
<BR><BR>The range of Microsoft binary format floats is 2.938736e-39 to 1.701412e+38.&nbsp; The range of Microsoft binary format
doubles is 2.938735877056e-39 to 1.701411834605e+38.
<BR><BR>Microsoft Binary Format was used by early versions of Microsoft QuickBASIC before coprocessors became standard.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _fieeetomsbin</TT> function returns 0 if the conversion was successful.&nbsp; Otherwise, it returns 1 if conversion
would cause an overflow.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_dieeetomsbin">_dieeetomsbin</A>, <A HREF="#_dmsbintoieee">_dmsbintoieee</A>, <A HREF="#_fmsbintoieee">_fmsbintoieee</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; float fieee, fmsb;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; double dieee, dmsb;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; fieee = 0.5;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; dieee = -2.0;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; /* Convert IEEE format to Microsoft binary format */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _fieeetomsbin( &amp;fieee, &amp;fmsb );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _dieeetomsbin( &amp;dieee, &amp;dmsb );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; /* Convert Microsoft binary format back to IEEE format */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _fmsbintoieee( &amp;fmsb, &amp;fieee );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _dmsbintoieee( &amp;dmsb, &amp;dieee );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; /* Display results */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;fieee = %f, dieee = %f\n&quot;, fieee, dieee );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>fieee = 0.500000, dieee = -2.000000</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, Netware
</DL>
<H2 ID="filelength"> filelength, _filelength, _filelengthi64 </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;io.h&gt;</TT>
<BR><TT>long filelength( int handle );</TT>
<BR><TT>long _filelength( int handle );</TT>
<BR><TT>__int64 _filelengthi64( int handle );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> filelength</TT> function returns, as a 32-bit long integer, the number of bytes in the opened file indicated by the
file handle<B> handle</B>.
<BR><BR>The _filelengthi64 function returns, as a 64-bit integer, the number of bytes in the opened file indicated by the
file handle<B> handle</B>.
<BR><BR>The<TT> _filelength</TT> function is identical to<TT> filelength</TT>.&nbsp; Use<TT> _filelength</TT> for ANSI naming
conventions.
</DL>
<DL>
<DT>Returns:
<DD>If an error occurs in<TT> filelength</TT> (-1L) is returned.
<BR><BR>If an error occurs in _filelengthi64, (-1I64) is returned.
<BR><BR>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
<BR><BR>Otherwise, the number of bytes written to the file is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#fstat">fstat</A>, <A HREF="#lseek">lseek</A>, <A HREF="#tell">tell</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;sys/types.h&gt;</TT>
<BR><TT>#include &lt;fcntl.h&gt;</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;io.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int handle;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; /* open a file for input&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; handle = open( &quot;file&quot;, O_RDONLY | O_TEXT );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( handle != -1 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Size of file is %ld bytes\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; filelength( handle ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close( handle );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>Size of file is 461 bytes</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
<BR><BR>_filelength conforms to ANSI naming conventions
</DL>
<DL>
<DT>Systems:
<DD><TT> filelength - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_filelength - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</TT>
<BR><TT>_filelengthi64 - All, Linux</TT>
</DL>
<H2 ID="FILENAME_MAX"> FILENAME_MAX </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#define FILENAME_MAX 123</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> FILENAME_MAX</TT> macro is the size of an array of char big enough to hold a string naming any file that the implementation
expects to open; If there is no practical file name length limit,<TT> FILENAME_MAX</TT> is the recommended size of such an
array.&nbsp; As file name string contents must meet other system-specific constraints, some strings of length<TT> FILENAME_MAX</TT>
may not work.
<BR><BR><TT>FILENAME_MAX</TT> typically sizes an array to hold a file name.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> FILENAME_MAX</TT> macro returns a positive integer value.
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><BR><TT>int main( int argc, char *argv[] )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( argc ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char fname[FILENAME_MAX];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcpy( fname, argv[0] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; puts( fname );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; return( 0 );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="fileno"> fileno </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>int fileno( FILE *stream );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> fileno</TT> function returns the number of the file handle for the file designated by<B> stream</B>.&nbsp; This number
can be used in POSIX input/output calls anywhere the value returned by <TT> open</TT> can be used.&nbsp; The following symbolic
values in<TT> &lt;io.h&gt;</TT> define the file handles that are associated with the C language <B> stdin, stdout, stderr,
stdaux,</B> and<B> stdprn</B> files when the application is started.&nbsp; The<B> stdaux</B> and<B> stdprn</B> files are not
available for Win32.
<DL>
<DT>Value&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>STDIN_FILENO
<DD>Standard input file number,<B> stdin</B> (0)
<DT>STDOUT_FILENO
<DD>Standard output file number,<B> stdout</B> (1)
<DT>STDERR_FILENO
<DD>Standard error file number,<B> stderr</B> (2)
<DT>STDAUX_FILENO
<DD>Standard auxiliary file number,<B> stdaux</B> (3)
<DT>STDPRN_FILENO
<DD>Standard printer file number,<B> stdprn</B> (4)
</DL>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> fileno</TT> function returns the number of the file handle for the file designated by<B> stream</B>.&nbsp; If an error
occurs, a value of -1 is returned and <TT> errno</TT> is set to indicate the error.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#open">open</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FILE *stream;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; stream = fopen( &quot;file&quot;, &quot;r&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;File number is %d\n&quot;, fileno( stream ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fclose( stream );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>File number is 7</TT>
</DL>
<DL>
<DT>Classification:
<DD>POSIX 1003.1
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="_findclose"> _findclose </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;io.h&gt;</TT>
<BR><TT>int _findclose( intptr_t handle );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _findclose</TT> function closes the directory of filenames established by a call to the <TT> _findfirst</TT> function.
&nbsp;The<B> handle</B> argument was returned by the <TT> _findfirst</TT> function.
</DL>
<DL>
<DT>Returns:
<DD>If successful,<TT> _findclose</TT> returns 0; otherwise,<TT> _findclose</TT> and returns -1 and sets <TT> errno</TT> to one
of the following values:
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>ENOENT
<DD>No matching files
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_dos_find___">_dos_find...</A>, <A HREF="#_findfirst">_findfirst</A>, <A HREF="#_findnext">_findnext</A>, <A HREF="#closedir">closedir</A>,
<A HREF="#opendir">opendir</A>, <A HREF="#readdir">readdir</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;io.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct _finddata_t&nbsp; fileinfo;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; intptr_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handle;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
rc;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; /* Display name and size of &quot;*.c&quot; files */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; handle = _findfirst( &quot;*.c&quot;, &amp;fileinfo );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; rc = handle;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; while( rc != -1 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%14s %10ld\n&quot;, fileinfo.name,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fileinfo.size );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc = _findnext( handle, &amp;fileinfo );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _findclose( handle );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>DOS
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS
</DL>
<H2 ID="_findfirst"> _findfirst, _findfirsti64, _wfindfirst, _wfindfirsti64 </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;io.h&gt;</TT>
<BR><TT>intptr_t _findfirst( const char *filespec,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct _finddata_t
*fileinfo );</TT>
<BR><TT>intptr_t _findfirsti64( const char *filespec,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
struct _finddatai64_t *fileinfo );</TT>
<BR><TT>intptr_t _wfindfirst( const wchar_t *filespec,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct _wfinddata_t
*fileinfo );</TT>
<BR><TT>intptr_t _wfindfirsti64( const wchar_t *filespec,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct _wfinddatai64_t
*fileinfo );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _findfirst</TT> function returns information on the first file whose name matches the<B> filespec</B> argument.&nbsp;
The<B> filespec</B> argument may contain wildcard characters ('?' and '*').&nbsp; The information is returned in a <TT> _finddata_t</TT>
structure pointed to by<B> fileinfo</B>.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct _finddata_t {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned&nbsp; attrib;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp;&nbsp; time_create;&nbsp; /* -1 for FAT file systems */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp;&nbsp; time_access;&nbsp; /* -1 for FAT file systems */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp;&nbsp; time_write;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fsize_t&nbsp; size;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name[_MAX_PATH];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR>The _findfirsti64 function returns information on the first file whose name matches the<B> filespec</B> argument.
&nbsp;It differs from the<TT> _findfirst</TT> function in that it returns a 64-bit file size.&nbsp; The<B> filespec</B> argument
may contain wildcard characters ('?' and '*').&nbsp; The information is returned in a <TT> _finddatai64_t</TT> structure pointed
to by<B> fileinfo</B>.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct _finddatai64_t {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned&nbsp; attrib;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp;&nbsp; time_create;&nbsp; /* -1 for FAT file systems */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp;&nbsp; time_access;&nbsp; /* -1 for FAT file systems */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp;&nbsp; time_write;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __int64&nbsp;&nbsp; size;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*
64-bit size info */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name[_MAX_PATH];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR>The<TT> _wfindfirsti64</TT> function is a wide-character version of<TT> _findfirst</TT> that operates with wide-character
strings.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct _wfinddata_t {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned&nbsp; attrib;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp;&nbsp; time_create;&nbsp; /* -1 for FAT file systems */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp;&nbsp; time_access;&nbsp; /* -1 for FAT file systems */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp;&nbsp; time_write;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fsize_t&nbsp; size;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t&nbsp;&nbsp; name[_MAX_PATH];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR>The wide-character _wfindfirsti64 function is similar to the _findfirsti64 function but operates on wide-character
strings.&nbsp; It differs from the<TT> _wfindfirsti64</TT> function in that it returns a 64-bit file size.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct _wfinddatai64_t {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned&nbsp; attrib;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp;&nbsp; time_create;&nbsp; /* -1 for FAT file systems */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp;&nbsp; time_access;&nbsp; /* -1 for FAT file systems */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp;&nbsp; time_write;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __int64&nbsp;&nbsp; size;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*
64-bit size info */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t&nbsp;&nbsp; name[_MAX_PATH];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
</DL>
<DL>
<DT>Returns:
<DD>If successful,<TT> _findfirst</TT> returns a unique search handle identifying the file or group of files matching the<B> filespec</B>
specification, which can be used in a subsequent call to <TT> _findnext</TT> or to <TT> _findclose</TT>.&nbsp; Otherwise,<TT>
_findfirst</TT> returns -1 and sets <TT> errno</TT> to one of the following values:
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>ENOENT
<DD>No matching files
<DT>EINVAL
<DD>Invalid filename specification
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_dos_find___">_dos_find...</A>, <A HREF="#_findclose">_findclose</A>, <A HREF="#_findnext">_findnext</A>, <A HREF="#closedir">closedir</A>,
<A HREF="#opendir">opendir</A>, <A HREF="#readdir">readdir</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;io.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct _finddata_t&nbsp; fileinfo;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; intptr_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handle;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
rc;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; /* Display name and size of &quot;*.c&quot; files */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; handle = _findfirst( &quot;*.c&quot;, &amp;fileinfo );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; rc = handle;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; while( rc != -1 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%14s %10ld\n&quot;, fileinfo.name,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fileinfo.size );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc = _findnext( handle, &amp;fileinfo );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _findclose( handle );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>DOS
</DL>
<DL>
<DT>Systems:
<DD><TT> _findfirst - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
<BR><BR><TT>_findfirsti64 - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</TT>
<BR><TT>_wfindfirst - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</TT>
<BR><TT>_wfindfirsti64 - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</TT>
</DL>
<H2 ID="_findnext"> _findnext, _findnexti64, _wfindnext, _wfindnexti64 </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;io.h&gt;</TT>
<BR><TT>int _findnext( intptr_t handle, struct _finddata_t *fileinfo );</TT>
<BR><TT>int _findnexti64( intptr_t handle, struct _finddatai64_t *fileinfo );</TT>
<BR><TT>int _wfindnext( intptr_t handle, struct _wfinddata_t *fileinfo );</TT>
<BR><TT>int _wfindnexti64( intptr_t handle, struct _wfinddatai64_t *fileinfo );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _findnext</TT> function returns information on the next file whose name matches the<B> filespec</B> argument that
was specified in a call to the <TT> _findfirst</TT> function.&nbsp; The<B> handle</B> argument was returned by the <TT> _findfirst</TT>
function.&nbsp; The information is returned in a <TT> _finddata_t</TT> structure pointed to by<B> fileinfo</B>.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct _finddata_t {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned&nbsp; attrib;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp;&nbsp; time_create;&nbsp; /* -1 for FAT file systems */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp;&nbsp; time_access;&nbsp; /* -1 for FAT file systems */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp;&nbsp; time_write;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fsize_t&nbsp; size;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name[_MAX_PATH];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR>The<TT> _findnexti64</TT> function returns information on the next file whose name matches the<B> filespec</B> argument
that was specified in a call to the <TT> _findfirsti64</TT> function.&nbsp; It differs from the<TT> _findnext</TT> function
in that it returns a 64-bit file size.&nbsp; The<B> handle</B> argument was returned by the <TT> _findfirsti64</TT> function.
&nbsp;The information is returned in a <TT> _finddatai64_t</TT> structure pointed to by<B> fileinfo</B>.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct _finddatai64_t {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned&nbsp; attrib;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp;&nbsp; time_create;&nbsp; /* -1 for FAT file systems */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp;&nbsp; time_access;&nbsp; /* -1 for FAT file systems */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp;&nbsp; time_write;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __int64&nbsp;&nbsp; size;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*
64-bit size info */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name[_MAX_PATH];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR>The<TT> _wfindnexti64</TT> function is a wide-character version of<TT> _findnext</TT> that operates with wide-character
strings.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct _wfinddata_t {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned&nbsp; attrib;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp;&nbsp; time_create;&nbsp; /* -1 for FAT file systems */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp;&nbsp; time_access;&nbsp; /* -1 for FAT file systems */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp;&nbsp; time_write;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fsize_t&nbsp; size;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t&nbsp;&nbsp; name[_MAX_PATH];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR>The wide-character<TT> _wfindnexti64</TT> function is similar to the<TT> _findnexti64</TT> function but operates on
wide-character strings.&nbsp; It differs from the<TT> _wfindnexti64</TT> function in that it returns a 64-bit file size.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct _wfinddatai64_t {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned&nbsp; attrib;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp;&nbsp; time_create;&nbsp; /* -1 for FAT file systems */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp;&nbsp; time_access;&nbsp; /* -1 for FAT file systems */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp;&nbsp; time_write;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __int64&nbsp;&nbsp; size;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*
64-bit size info */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t&nbsp;&nbsp; name[_MAX_PATH];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
</DL>
<DL>
<DT>Returns:
<DD>If successful,<TT> _findnext</TT> returns 0; otherwise,<TT> _findnext</TT> and returns -1 and sets <TT> errno</TT> to one
of the following values:
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>ENOENT
<DD>No matching files
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_dos_find___">_dos_find...</A>, <A HREF="#_findclose">_findclose</A>, <A HREF="#_findfirst">_findfirst</A>, <A HREF="#closedir">closedir</A>,
<A HREF="#opendir">opendir</A>, <A HREF="#readdir">readdir</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;io.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct _finddata_t&nbsp; fileinfo;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; intptr_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handle;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
rc;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; /* Display name and size of &quot;*.c&quot; files */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; handle = _findfirst( &quot;*.c&quot;, &amp;fileinfo );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; rc = handle;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; while( rc != -1 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%14s %10ld\n&quot;, fileinfo.name,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fileinfo.size );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc = _findnext( handle, &amp;fileinfo );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _findclose( handle );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>DOS
</DL>
<DL>
<DT>Systems:
<DD><TT> _findnext - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
<BR><BR><TT>_findnexti64 - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</TT>
<BR><TT>_wfindnext - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</TT>
<BR><TT>_wfindnexti64 - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</TT>
</DL>
<H2 ID="_finite"> _finite </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;float.h&gt;</TT>
<BR><TT>int _finite( double x );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _finite</TT> function determines whether the double precision floating-point argument is a valid number (i.e., not
infinite and not a NAN).
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _finite</TT> function returns 0 if the number is not valid and non-zero otherwise.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_clear87">_clear87</A>, <A HREF="#_control87">_control87</A>, <A HREF="#_controlfp">_controlfp</A>, <A HREF="#_fpreset">_fpreset</A>,
<A HREF="#printf">printf</A>, <A HREF="#_status87">_status87</A>, <A HREF="#isfinite">isfinite</A>, <A HREF="#fpclassify">fpclassify</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;float.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, (_finite( 1.797693134862315e+308 ) )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ? &quot;Valid&quot; : &quot;Invalid&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, (_finite( 1.797693134862320e+308 ) )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ? &quot;Valid&quot; : &quot;Invalid&quot; );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>Valid</TT>
<BR><TT>Invalid</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>Math
</DL>
<H2 ID="_floodfill"> _floodfill, _floodfill_w </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>short _FAR _floodfill( short x, short y,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; short stop_color );</TT>
<BR><BR><TT>short _FAR _floodfill_w( double x, double y,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; short stop_color );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _floodfill</TT> functions fill an area of the screen.&nbsp; The<TT> _floodfill</TT> function uses the view coordinate
system.&nbsp; The<TT> _floodfill_w</TT> function uses the window coordinate system.
<BR><BR>The filling starts at the point<TT> (x,y)</TT> and continues in all directions:&nbsp; when a pixel is filled, the
neighbouring pixels (horizontally and vertically) are then considered for filling.&nbsp; Filling is done using the current
color and fill mask.&nbsp; No filling will occur if the point<TT> (x,y)</TT> lies outside the clipping region.
<BR><BR>If the argument<B> stop_color</B> is a valid pixel value, filling will occur in each direction until a pixel is encountered
with a pixel value of<B> stop_color</B>.&nbsp; The filled area will be the area around<TT> (x,y),</TT> bordered by<B> stop_color</B>.
&nbsp;No filling will occur if the point<TT> (x,y)</TT> has the pixel value<B> stop_color</B>.
<BR><BR>If<B> stop_color</B> has the value (-1), filling occurs until a pixel is encountered with a pixel value different
from the pixel value of the starting point<TT> (x,y).</TT>&nbsp; No filling will occur if the pixel value of the point<TT>
(x,y)</TT> is the current color.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _floodfill</TT> functions return zero when no filling takes place; a non-zero value is returned to indicate that filling
has occurred.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_setcliprgn">_setcliprgn</A>, <A HREF="#_setcolor">_setcolor</A>, <A HREF="#_setfillmask">_setfillmask</A>, <A HREF="#_setplotaction">_setplotaction</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setcolor( 1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _ellipse( _GBORDER, 120, 90, 520, 390 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setcolor( 2 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _floodfill( 320, 240, 1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD><TT> _floodfill - DOS</TT>
<BR><BR><TT>_floodfill_w - DOS</TT>
</DL>
<H2 ID="floor"> floor </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>double floor( double x );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> floor</TT> function computes the largest integer not greater than<B> x</B>.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> floor</TT> function computes the largest integer not greater than<B> x</B>, expressed as a<TT> double.</TT>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#ceil">ceil</A>, <A HREF="#fmod">fmod</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, floor( -3.14 ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, floor( -3. ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, floor( 0. ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, floor( 3.14 ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, floor( 3. ) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>-4.000000</TT>
<BR><TT>-3.000000</TT>
<BR><TT>0.000000</TT>
<BR><TT>3.000000</TT>
<BR><TT>3.000000</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD>Math
</DL>
<H2 ID="flushall"> flushall </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>int flushall( void );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> flushall</TT> function clears all buffers associated with input streams and writes any buffers associated with output
streams.&nbsp; A subsequent read operation on an input file causes new data to be read from the associated file or device.
<BR><BR>Calling the<TT> flushall</TT> function is equivalent to calling the <TT> fflush</TT> for all open stream files.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> flushall</TT> function returns the number of open streams.&nbsp; When an output error occurs while writing to a file,
the <TT> errno</TT> global variable will be set.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#fopen">fopen</A>, <A HREF="#fflush">fflush</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;The number of open files is %d\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; flushall() );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>The number of open files is 4</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="fma"> fma </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>double fma( double x, double y, double z );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> fma</TT> function performs a fused multiply-add operation.&nbsp; The resultant value is the product of<B> x</B> and<B>
y</B> summed with<B> z</B>.
</DL>
<DL>
<DT>Returns:
<DD>The x*y+z
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, fma( 2.0, 3.0, 1.0 ) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>7.00000</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C99
</DL>
<DL>
<DT>Systems:
<DD>Math
</DL>
<H2 ID="fmax"> fmax </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>double fmax( double x, double y );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> fmax</TT> function returns the larger of<B> x</B> and<B> y</B>.
</DL>
<DL>
<DT>Returns:
<DD>The routine will return the larger of<B> x</B> or<B> y</B>.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#fdim">fdim</A>, <A HREF="#fmin">fmin</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, fmax( 3.0, 2.0 ) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>3.000000</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C99
</DL>
<DL>
<DT>Systems:
<DD>Math
</DL>
<H2 ID="fmin"> fmin </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>double fmin( double x, double y );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> fmin</TT> function returns the smaller of<B> x</B> and<B> y</B>.
</DL>
<DL>
<DT>Returns:
<DD>The routine will return the smaller of<B> x</B> or<B> y</B>.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#fdim">fdim</A>, <A HREF="#fmax">fmax</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, fmin( 3.0, 2.0 ) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>2.000000</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C99
</DL>
<DL>
<DT>Systems:
<DD>Math
</DL>
<H2 ID="fmod"> fmod </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>double fmod( double x, double y );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> fmod</TT> function computes the floating-point remainder of<B> x/y</B>, even if the quotient<B> x/y</B> is not representable.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> fmod</TT> function returns the value<B> x - (i * y)</B>, for some integer<B> i</B> such that, if<B> y</B> is non-zero,
the result has the same sign as<B> x</B> and magnitude less than the magnitude of<B> y</B>.&nbsp; If the value of<B> y</B>
is zero, then the value returned is zero.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#ceil">ceil</A>, <A HREF="#fabs">fabs</A>, <A HREF="#floor">floor</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, fmod(&nbsp; 4.5,&nbsp; 2.0 ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, fmod( -4.5,&nbsp; 2.0 ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, fmod(&nbsp; 4.5, -2.0 ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, fmod( -4.5, -2.0 ) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>0.500000</TT>
<BR><TT>-0.500000</TT>
<BR><TT>0.500000</TT>
<BR><TT>-0.500000</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD>Math
</DL>
<H2 ID="_fmsbintoieee"> _fmsbintoieee </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>extern int _fmsbintoieee( float *src, float *dest );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _fmsbintoieee</TT> function loads the float pointed to by<B> src</B> in Microsoft binary format and converts it to
IEEE format, storing the result &amp;into the float pointed to by<B> dest</B>.
<BR><BR>The range of Microsoft binary format floats is 2.938736e-39 to 1.701412e+38.&nbsp; The range of Microsoft binary format
doubles is 2.938735877056e-39 to 1.701411834605e+38.
<BR><BR>Microsoft Binary Format was used by early versions of Microsoft QuickBASIC before coprocessors became standard.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _fmsbintoieee</TT> function returns 0 if the conversion was successful.&nbsp; Otherwise, it returns 1 if conversion
would cause an overflow.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_dieeetomsbin">_dieeetomsbin</A>, <A HREF="#_dmsbintoieee">_dmsbintoieee</A>, <A HREF="#_fieeetomsbin">_fieeetomsbin</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; float fieee, fmsb;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; double dieee, dmsb;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; fieee = 0.5;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; dieee = -2.0;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; /* Convert IEEE format to Microsoft binary format */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _fieeetomsbin( &amp;fieee, &amp;fmsb );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _dieeetomsbin( &amp;dieee, &amp;dmsb );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; /* Convert Microsoft binary format back to IEEE format */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _fmsbintoieee( &amp;fmsb, &amp;fieee );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _dmsbintoieee( &amp;dmsb, &amp;dieee );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; /* Display results */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;fieee = %f, dieee = %f\n&quot;, fieee, dieee );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>fieee = 0.500000, dieee = -2.000000</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="fnmatch"> fnmatch </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;fnmatch.h&gt;</TT>
<BR><TT>int fnmatch( const char *pattern,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *string, int flags );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> fnmatch</TT> function checks the string specified by the<B> string</B> argument to see if it matches the pattern specified
by the<B> pattern</B> argument.
<BR><BR>The<B> flag</B> argument is a bitwise inclusive OR of the bits described below.&nbsp; It modifies the interpretation
of<B> pattern</B> and<B> string</B>.
<DL>
<DT>Flag&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>FNM_PATHNAME
<DD>If set, a path separator in<B> string</B> is explicitly matched by a slash in<B> pattern</B>.&nbsp; It isn't matched by either
the asterisk or question mark special characters, or by a bracket expression.
<DT>FNM_PERIOD
<DD>If set, a leading period in<B> string</B> matches a period in<B> pattern</B>, where the definition of &quot;leading&quot;
depends on FNM_PATHNAME:
<UL>
<LI>If FNM_PATHNAME is set, a period is leading if it's the first character in<B> string</B>, or if it immediately follows
a path separator.
<LI>If FNM_PATHNAME isn't set, a period is leading only if it's the first character in<B> string</B>.
</UL>
<DT>FNM_NOESCAPE
<DD>If set, disables backslash escaping:
<UL>
<LI>If FNM_NOESCAPE isn't set in<B> flags</B>, a backslash character (\) in<B> pattern</B> followed by any other character
matches that second character in<B> string</B>.&nbsp; In particular, \\ matches a backslash in<B> string</B>.
<LI>If FNM_NOESCAPE is set, a backslash character is treated as an ordinary character.
</UL>
<DT>FNM_IGNORECASE
<DD>If set, the matching is case-insensitive.
<DT>FNM_CASEFOLD
<DD>A synonym for FNM_IGNORECASE.
<DT>FNM_LEADING_DIR
<DD>If set, the final path separator and any following characters in<B> string</B> are ignored during matching.
</DL>
<BR>A pattern-matching special character that is quoted is a pattern that matches the special character itself.&nbsp; When
not quoted, such special characters have special meaning in the specification of patterns.&nbsp; The pattern-matching special
characters and the contexts in which they have their special meaning are as follows:
<DL>
<DT>?
<DD>a ?&nbsp; is a pattern that matches any printable or nonprintable character except &lt;newline&gt;.
<DT>*
<DD>the * matches any string, including the null string.
<DT>[br_exp]
<DD>a pattern that matches a single character as per Regular Expression Bracket Expressions (1003.2 2.9.1.2) except that
<UL>
<LI>The exclamation point character (!) replaces the circumflex character (^) in its role as a nonmatching list in the regular
expression notation.
<LI>The backslash is used as an escape character within bracket expressions.
</UL>
</DL>
<BR>The<TT> ?, *</TT> and<TT> [</TT> characters aren't special when used inside a bracket expression.
<BR>The concatenation of patterns matching a single character is a valid pattern that matches the concatenation of the single
characters matched by each of the concatenated patterns.&nbsp; For example, the pattern<TT> a[bc]</TT> matches the strings<TT>
ab</TT> and<TT> ac.</TT>
<BR><BR>The concatenation of one or more patterns matching a single character with one or more asterisks (*) is a valid pattern.
&nbsp;In such patterns, each asterisk matches a string of zero or more characters, up to the first character that matches
the character following the asterisk in the pattern.&nbsp; For example, the pattern<TT> a*d</TT> matches the strings<TT> ad,
abd,</TT> and<TT> abcd,</TT> but not the string<TT> abc.</TT>
<BR><BR>When asterisk is the first or last character in a pattern, it matches zero or more characters that precede or follow
the characters matched by the remainded of the pattern.&nbsp; For example, the pattern<TT> a*d*</TT> matches the strings<TT>
ad, abcd, abcdef, aaaad</TT> and<TT> adddd.</TT>&nbsp; The pattern<TT> *a*d</TT> matches the strings<TT> ad, abcd, efabcd,
aaaad</TT> and<TT> adddd.</TT>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> fnmatch</TT> function returns zero when<B> string</B> matches the pattern specified by<B> pattern</B>.&nbsp; If there
is no match, FNM_NOMATCH is returned.&nbsp; If an error occurs, fnmatch returns another non-zero value.
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;fnmatch.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>#include &lt;limits.h&gt;</TT>
<BR><BR><TT>int main( int argc, char **argv )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; i;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; buffer[PATH_MAX+1];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; while( gets( buffer ) ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( i = 1; i &lt; argc; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( fnmatch( argv[i], buffer, 0 ) == 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;'%s' matches
pattern '%s'\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; buffer, argv[i] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; return( EXIT_SUCCESS );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>POSIX 1003.2
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="fopen"> fopen, _wfopen </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>FILE *fopen( const char *filename, const char *mode );</TT>
<BR><TT>FILE *_wfopen( const wchar_t *filename,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t *mode );</TT>
</DL>
<DL>
<DT>Safer C:
<DD>The Safer C Library extension provides the <A HREF="#fopen_s">fopen_s</A> function which is a safer alternative to<TT> fopen</TT>
This newer<TT> fopen_s</TT> function is recommended to be used instead of the traditional &quot;unsafe&quot;<TT> fopen</TT>
function.
</DL>
<DL>
<DT>Description:
<DD>The<TT> fopen</TT> function opens the file whose name is the string pointed to by<B> filename</B>, and associates a stream
with it.&nbsp; The argument<B> mode</B> points to a string beginning with one of the following sequences:
<DL>
<DT>Mode&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>&quot;r&quot;
<DD>open file for reading
<DT>&quot;w&quot;
<DD>create file for writing, or truncate to zero length
<DT>&quot;a&quot;
<DD>append:&nbsp; open file or create for writing at end-of-file
<DT>&quot;r+&quot;
<DD>open file for update (reading and/or writing)
<DT>&quot;w+&quot;
<DD>create file for update, or truncate to zero length
<DT>&quot;a+&quot;
<DD>append:&nbsp; open file or create for update, writing at end-of-file
</DL>
<BR>In addition to the above characters, you can also include one of the following characters in<B> mode</B> to specify the
translation mode for newline characters:
<DL>
<DT>t
<DD>The letter &quot;t&quot; may be added to any of the above sequences in the second or later position to indicate that the file
is (or must be) a text file.&nbsp; It also overrides the global translation mode flag if you link your program with<TT> BINMODE.OBJ.</TT>
&nbsp;The global translation mode flag default is &quot;text&quot; unless you explicitly link your program with<TT> BINMODE.OBJ.</TT>
<BR><BR>When neither &quot;t&quot; nor &quot;b&quot; is specified, the value of the global variable <TT> _fmode</TT> establishes
whether the file is to treated as a binary or a text file.&nbsp; Unless this value is changed by the program or you have linked
your program with<TT> BINMODE.OBJ,</TT> the default will be text mode.
<DT>b
<DD>The letter &quot;b&quot; may be added to any of the above sequences in the second or later position to indicate that the file
is (or must be) a binary file (an ISO C requirement for portability to systems that make a distinction between text and binary
files).
</DL>
<BR>You can also include one of the following characters to enable or disable the &quot;commit&quot; flag for the associated
file.
<DL>
<DT>c
<DD>The letter &quot;c&quot; may be added to any of the above sequences in the second or later position to indicate that any output
is committed by the operating system whenever a flush ( <TT> fflush</TT> or <TT> flushall</TT>) is done.
<BR><BR>This option is not supported under Netware.
<DT>n
<DD>The letter &quot;n&quot; may be added to any of the above sequences in the second or later position to indicate that the operating
system need not commit any output whenever a flush is done.&nbsp; It also overrides the global commit flag if you link your
program with<TT> COMMODE.OBJ.</TT>&nbsp; The global commit flag default is &quot;no-commit&quot; unless you explicitly link
your program with<TT> COMMODE.OBJ.</TT>
<BR><BR>This option is not supported under Netware.
</DL>
<BR>The &quot;t&quot;, &quot;c&quot;, and &quot;n&quot; mode options are extensions for<TT> fopen</TT> and <TT> _fdopen</TT>
and should not be used where ISO C portability is desired.
<BR><BR>Opening a file with read mode (<TT>r</TT> as the first character in the<B> mode</B> argument) fails if the file does
not exist or it cannot be read.&nbsp; Opening a file with append mode (<TT>a</TT> as the first character in the<B> mode</B>
argument) causes all subsequent writes to the file to be forced to the current end-of-file, regardless of previous calls to
the <TT> fseek</TT> function.&nbsp; When a file is opened with update mode (<TT>+</TT> as the second or later character of
the<B> mode</B> argument), both input and output may be performed on the associated stream.
<BR><BR>When a stream is opened in update mode, both reading and writing may be performed.&nbsp; However, writing may not
be followed by reading without an intervening call to the <TT> fflush</TT> function or to a file positioning function (<TT>
fseek</TT>, <TT> fsetpos</TT>, <TT> rewind</TT>).&nbsp; Similarly, reading may not be followed by writing without an intervening
call to a file positioning function, unless the read resulted in end-of-file.
<BR><BR>The<TT> _wfopen</TT> function is a wide-character version of<TT> fopen</TT> that operates with wide-character strings.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> fopen</TT> function returns a pointer to the object controlling the stream.&nbsp; This pointer must be passed as a
parameter to subsequent functions for performing operations on the file.&nbsp; If the open operation fails,<TT> fopen</TT>
returns<TT> NULL.</TT>&nbsp; When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that
has been detected.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_dos_open">_dos_open</A>, <A HREF="#fclose">fclose</A>, <A HREF="#fcloseall">fcloseall</A>, <A HREF="#fdopen">fdopen</A>,
<A HREF="#fopen_s">fopen_s</A>, <A HREF="#freopen">freopen</A>, <A HREF="#freopen_s">freopen_s</A>, <A HREF="#_fsopen">_fsopen</A>,
<A HREF="#_grow_handles">_grow_handles</A>, <A HREF="#_hdopen">_hdopen</A>, <A HREF="#open">open</A>, <A HREF="#_open_osfhandle">_open_osfhandle</A>,
<A HREF="#_popen">_popen</A>, <A HREF="#sopen">sopen</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FILE *fp;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; fp = fopen( &quot;file&quot;, &quot;r&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( fp != NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* rest of code goes here */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( fp );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C ('t', 'c', 'n' are Open Watcom extensions)
<BR><BR>_wfopen is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> fopen - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_wfopen - All, Linux</TT>
</DL>
<H2 ID="fopen_s"> fopen_s, _wfopen_s </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__ 1</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>errno_t fopen_s( FILE * restrict * restrict streamptr,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char * restrict
filename,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char * restrict
mode);</TT>
<BR><TT>errno_t _wfopen_s( FILE * restrict * restrict streamptr,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const
wchar_t * restrict filename,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const
wchar_t * restrict mode);</TT>
</DL>
<DL>
<DT>Constraints:
<DD>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<TT>
fopen_s</TT> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<BR><BR>None of<B> streamptr</B>,<B> filename</B>, or<B> mode</B> shall be a null pointer.&nbsp; If there is a runtime-constraint
violation,<TT> fopen_s</TT> does not attempt to open a file.&nbsp; Furthermore, if<B> streamptr</B> is not a null pointer,<TT>
fopen_s</TT> sets<B> *streamptr</B> to the null pointer.
</DL>
<DL>
<DT>Description:
<DD>The<TT> fopen_s</TT> function opens the file whose name is the string pointed to by<B> filename</B>, and associates a stream
with it.&nbsp; The<B> mode</B> string shall be as described for fopen, with the addition that modes starting with the character
'w' or 'a' may be preceded by the character 'u', see below:
<DL>
<DT>Mode&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>&quot;uw&quot;
<DD>truncate to zero length or create text file for writing, default permissions
<DT>&quot;ua&quot;
<DD>append; open or create text file for writing at end-of-file, default permissions
<DT>&quot;uwb&quot;
<DD>truncate to zero length or create binary file for writing, default permissions
<DT>&quot;uab&quot;
<DD>append; open or create binary file for writing at end-of-file, default permissions
<DT>&quot;uw+&quot;
<DD>truncate to zero length or create text file for update, default permissions
<DT>&quot;ua+&quot;
<DD>append; open or create text file for update, writing at end-of-file, default permissions
<DT>&quot;uw+b or uwb+&quot;
<DD>truncate to zero length or create binary file for update, default permissions
<DT>&quot;ua+b or uab+&quot;
<DD>append; open or create binary file for update, writing at end-of-file, default permissions
</DL>
<BR>To the extent that the underlying system supports the concepts, files opened for writing shall be opened with exclusive
(also known as non-shared) access.&nbsp; If the file is being created, and the first character of the<B> mode</B> string is
not 'u', to the extent that the underlying system supports it, the file shall have a file permission that prevents other users
on the system from accessing the file.&nbsp; If the file is being created and first character of the mode string is 'u', then
by the time the file has been closed, it shall have the system default file access permissions.&nbsp; If the file was opened
successfully, then the pointer to FILE pointed to by<B> streamptr</B> will be set to the pointer to the object controlling
the opened file.&nbsp; Otherwise, the pointer to FILE pointed to by<B> streamptr</B> will be set to a null pointer.
<BR><BR>In addition to the above characters, you can also include one of the following characters in<B> mode</B> to specify
the translation mode for newline characters:
<DL>
<DT>t
<DD>The letter &quot;t&quot; may be added to any of the above sequences in the second or later position to indicate that the file
is (or must be) a text file.&nbsp; It also overrides the global translation mode flag if you link your program with<TT> BINMODE.OBJ.</TT>
&nbsp;The global translation mode flag default is &quot;text&quot; unless you explicitly link your program with<TT> BINMODE.OBJ.</TT>
<BR><BR>When neither &quot;t&quot; nor &quot;b&quot; is specified, the value of the global variable <TT> _fmode</TT> establishes
whether the file is to treated as a binary or a text file.&nbsp; Unless this value is changed by the program or you have linked
your program with<TT> BINMODE.OBJ,</TT> the default will be text mode.
<DT>b
<DD>The letter &quot;b&quot; may be added to any of the above sequences in the second or later position to indicate that the file
is (or must be) a binary file (an ISO C requirement for portability to systems that make a distinction between text and binary
files).
</DL>
<BR>You can also include one of the following characters to enable or disable the &quot;commit&quot; flag for the associated
file.
<DL>
<DT>c
<DD>The letter &quot;c&quot; may be added to any of the above sequences in the second or later position to indicate that any output
is committed by the operating system whenever a flush ( <TT> fflush</TT> or <TT> flushall</TT>) is done.
<BR><BR>This option is not supported under Netware.
<DT>n
<DD>The letter &quot;n&quot; may be added to any of the above sequences in the second or later position to indicate that the operating
system need not commit any output whenever a flush is done.&nbsp; It also overrides the global commit flag if you link your
program with<TT> COMMODE.OBJ.</TT>&nbsp; The global commit flag default is &quot;no-commit&quot; unless you explicitly link
your program with<TT> COMMODE.OBJ.</TT>
<BR><BR>This option is not supported under Netware.
</DL>
<BR>The &quot;t&quot;, &quot;c&quot;, and &quot;n&quot; mode options are extensions for fopen_s and should not be used where
ISO C portability is desired.
<BR><BR>Opening a file with read mode (<TT>r</TT> as the first character in the<B> mode</B> argument) fails if the file does
not exist or it cannot be read.&nbsp; Opening a file with append mode (<TT>a</TT> as the first character in the<B> mode</B>
argument) causes all subsequent writes to the file to be forced to the current end-of-file, regardless of previous calls to
the <TT> fseek</TT> function.&nbsp; When a file is opened with update mode (<TT>+</TT> as the second or later character of
the<B> mode</B> argument), both input and output may be performed on the associated stream.
<BR><BR>When a stream is opened in update mode, both reading and writing may be performed.&nbsp; However, writing may not
be followed by reading without an intervening call to the <TT> fflush</TT> function or to a file positioning function (<TT>
fseek</TT>, <TT> fsetpos</TT>, <TT> rewind</TT>).&nbsp; Similarly, reading may not be followed by writing without an intervening
call to a file positioning function, unless the read resulted in end-of-file.
<BR><BR>The<TT> _wfopen_s</TT> function is a wide-character version of<TT> fopen_s</TT> that operates with wide-character
strings.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> fopen_s</TT> function returns zero if it opened the file.&nbsp; If it did not open the file or if there was a runtime-constraint
violation,<TT> fopen_s</TT> returns a non-zero value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_dos_open">_dos_open</A>, <A HREF="#fclose">fclose</A>, <A HREF="#fcloseall">fcloseall</A>, <A HREF="#fdopen">fdopen</A>,
<A HREF="#fopen">fopen</A>, <A HREF="#freopen">freopen</A>, <A HREF="#freopen_s">freopen_s</A>, <A HREF="#_fsopen">_fsopen</A>,
<A HREF="#_grow_handles">_grow_handles</A>, <A HREF="#_hdopen">_hdopen</A>, <A HREF="#open">open</A>, <A HREF="#_open_osfhandle">_open_osfhandle</A>,
<A HREF="#_popen">_popen</A>, <A HREF="#sopen">sopen</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__ 1</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; errno_t rc;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FILE&nbsp;&nbsp;&nbsp; *fp;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; rc = fopen_s( &amp;fp, &quot;file&quot;, &quot;r&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( fp != NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* rest of code goes here */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( fp );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>TR 24731
<BR><BR>_wfopen_s is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> fopen_s - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_wfopen_s - All, Linux</TT>
</DL>
<H2 ID="FP_OFF"> FP_OFF </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;i86.h&gt;</TT>
<BR><TT>unsigned FP_OFF( void __far *far_ptr );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> FP_OFF</TT> macro can be used to obtain the offset portion of the far pointer value given in<B> far_ptr</B>.
</DL>
<DL>
<DT>Returns:
<DD>The macro returns an unsigned integer value which is the offset portion of the pointer value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#FP_SEG">FP_SEG</A>, <A HREF="#MK_FP">MK_FP</A>, <A HREF="#segread">segread</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;i86.h&gt;</TT>
<BR><BR><TT>char ColourTable[256][3];</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; union REGPACK r;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; /* read block of colour registers */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; r.h.ah = 0x10;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; r.h.al = 0x17;</TT>
<BR><TT>#if defined(__386__)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; r.x.ebx = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; r.x.ecx = 256;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; r.x.edx = FP_OFF( ColourTable );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; r.w.ds = r.w.fs = r.w.gs = FP_SEG( &amp;r );</TT>
<BR><TT>#else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; r.w.bx = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; r.w.cx = 256;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; r.w.dx = FP_OFF( ColourTable );</TT>
<BR><TT>#endif</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; r.w.es = FP_SEG( ColourTable );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; intr( 0x10, &amp;r );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; 256; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Colour index = %d &quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;{ Red=%d, Green=%d, Blue=%d }\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ColourTable[i][0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ColourTable[i][1],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ColourTable[i][2] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="FP_SEG"> FP_SEG </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;i86.h&gt;</TT>
<BR><TT>unsigned FP_SEG( void __far *far_ptr );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> FP_SEG</TT> macro can be used to obtain the segment portion of the far pointer value given in<B> far_ptr</B>.
</DL>
<DL>
<DT>Returns:
<DD>The macro returns an unsigned integer value which is the segment portion of the pointer value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#FP_OFF">FP_OFF</A>, <A HREF="#MK_FP">MK_FP</A>, <A HREF="#segread">segread</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;i86.h&gt;</TT>
<BR><BR><TT>char ColourTable[256][3];</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; union REGPACK r;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; /* read block of colour registers */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; r.h.ah = 0x10;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; r.h.al = 0x17;</TT>
<BR><TT>#if defined(__386__)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; r.x.ebx = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; r.x.ecx = 256;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; r.x.edx = FP_OFF( ColourTable );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; r.w.ds = r.w.fs = r.w.gs = FP_SEG( &amp;r );</TT>
<BR><TT>#else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; r.w.bx = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; r.w.cx = 256;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; r.w.dx = FP_OFF( ColourTable );</TT>
<BR><TT>#endif</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; r.w.es = FP_SEG( ColourTable );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; intr( 0x10, &amp;r );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; 256; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Colour index = %d &quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;{ Red=%d, Green=%d, Blue=%d }\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ColourTable[i][0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ColourTable[i][1],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ColourTable[i][2] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="fpclassify"> fpclassify </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>int fpclassify( x );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> fpclassify</TT> macro classifies its argument<B> x</B> as NaN, infinite, normal, subnormal, or zero.&nbsp; First,
an argument represented in a format wider than its semantic type is converted to its semantic type.&nbsp; Then classification
is based on the type of the argument.
<BR><BR>The argument<B> x</B> must be an expression of real floating type.
<BR><BR>The possible return values of<TT> fpclassify</TT> and their meanings are listed below.
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>FP_INFINITE
<DD>positive or negative infinity
<DT>FP_NAN
<DD>NaN (not-a-number)
<DT>FP_NORMAL
<DD>normal number (neither zero, subnormal, NaN, nor infinity)
<DT>FP_SUBNORMAL
<DD>subnormal number
<DT>FP_ZERO
<DD>positive or negative zero
</DL>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> fpclassify</TT> macro returns the value of the number classification macro appropriate to the value of its argument<B>
x</B>.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#isfinite">isfinite</A>, <A HREF="#isinf">isinf</A>, <A HREF="#isnan">isnan</A>, <A HREF="#isnormal">isnormal</A>,
<A HREF="#signbit">signbit</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;infinity %s a normal number\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fpclassify( INFINITY ) == FP_NORMAL ?</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;is&quot; : &quot;is not&quot; );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>infinity is not a normal number</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="_fpreset"> _fpreset </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;float.h&gt;</TT>
<BR><TT>void _fpreset( void );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _fpreset</TT> function resets the floating-point unit to the default state that the math library requires for correct
function.&nbsp; After a floating-point exception, it may be necessary to call the<TT> _fpreset</TT> function before any further
floating-point operations are attempted.
<BR><BR>In multi-threaded environments,<TT> _fpreset</TT> only affects the current thread.
</DL>
<DL>
<DT>Returns:
<DD>No value is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_clear87">_clear87</A>, <A HREF="#_control87">_control87</A>, <A HREF="#_controlfp">_controlfp</A>, <A HREF="#_finite">_finite</A>,
<A HREF="#_status87">_status87</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;float.h&gt;</TT>
<BR><BR><TT>char *status[2] = { &quot;No&quot;, &quot;&nbsp; &quot; };</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned int fp_status;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; fp_status = _status87();</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;80x87 status\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s invalid operation\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; status[ (fp_status &amp; SW_INVALID) == 0 ] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s denormalized operand\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; status[ (fp_status &amp; SW_DENORMAL) == 0 ] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s divide by zero\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; status[ (fp_status &amp; SW_ZERODIVIDE) == 0 ]
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s overflow\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; status[ (fp_status &amp; SW_OVERFLOW) == 0 ] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s underflow\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; status[ (fp_status &amp; SW_UNDERFLOW) == 0 ] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s inexact result\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; status[ (fp_status &amp; SW_INEXACT) == 0 ] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _fpreset();</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="fprintf"> fprintf, fwprintf </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>int fprintf( FILE *fp, const char *format, ... );</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>int fwprintf( FILE *fp, const wchar_t *format, ... );</TT>
</DL>
<DL>
<DT>Safer C:
<DD>The Safer C Library extension provides the <A HREF="#fprintf_s">fprintf_s</A> function which is a safer alternative to<TT>
fprintf</TT> This newer<TT> fprintf_s</TT> function is recommended to be used instead of the traditional &quot;unsafe&quot;<TT>
fprintf</TT> function.
</DL>
<DL>
<DT>Description:
<DD>The<TT> fprintf</TT> function writes output to the file pointed to by<B> fp</B> under control of the argument<B> format</B>.
&nbsp;The<B> format</B> string is described under the description of the <TT> printf</TT> function.
<BR><BR>The<TT> fwprintf</TT> function is a wide-character version of<TT> fprintf</TT>.&nbsp; It accepts a wide-character
string argument for<B> format</B> and produces wide character output.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> fprintf</TT> function returns the number of characters written, or a negative value if an output error occurred.&nbsp;
The<TT> fwprintf</TT> function returns the number of wide characters written, or a negative value if an output error occurred.
&nbsp;When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_bprintf">_bprintf</A>, <A HREF="#cprintf">cprintf</A>, <A HREF="#printf">printf</A>, <A HREF="#sprintf">sprintf</A>,
<A HREF="#_vbprintf">_vbprintf</A>, <A HREF="#vcprintf">vcprintf</A>, <A HREF="#vfprintf">vfprintf</A>, <A HREF="#vprintf">vprintf</A>,
<A HREF="#vsprintf">vsprintf</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>char *weekday = { &quot;Saturday&quot; };</TT>
<BR><TT>char *month = { &quot;April&quot; };</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fprintf( stdout, &quot;%s, %s %d, %d\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; weekday, month, 18, 1987 );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>Saturday, April 18, 1987</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>fwprintf is ISO C95
</DL>
<DL>
<DT>Systems:
<DD><TT> fprintf - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>fwprintf - All, Linux</TT>
</DL>
<H2 ID="fprintf_s"> fprintf_s, fwprintf_s </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__ 1</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>int fprintf_s( FILE * restrict stream,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char * restrict format, ... );</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>int fwprintf_s( FILE * restrict stream.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t * restrict format, ... );</TT>
</DL>
<DL>
<DT>Constraints:
<DD>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<TT>
fprintf_s</TT> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<BR><BR>Neither<B> stream</B> nor<B> format</B> shall be a null pointer.&nbsp; The<TT> %n</TT> specifier (modified or not
by flags, field width, or precision) shall not appear in the string pointed to by<B> format</B>.&nbsp; Any argument to<TT>
fprintf_s</TT> corresponding to a<TT> %s</TT> specifier shall not be a null pointer.
<BR><BR>If there is a runtime-constraint violation, the<TT> fprintf_s</TT> function does not attempt to produce further output,
and it is unspecified to what extent<TT> fprintf_s</TT> produced output before discovering the runtime-constraint violation.
</DL>
<DL>
<DT>Description:
<DD>The<TT> fprintf_s</TT> function is equivalent to the <TT> fprintf</TT> function except for the explicit runtime-constraints
listed above.
<BR><BR>The<TT> fwprintf_s</TT> function is a wide-character version of<TT> fprintf_s</TT>.&nbsp; It accepts a wide-character
string argument for<B> format</B> and produces wide character output.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> fprintf_s</TT> function returns the number of characters written, or a negative value if an output error or runtime-constraint
violation occurred.
<BR><BR>The<TT> fwprintf_s</TT> function returns the number of wide characters written, or a negative value if an output error
or runtime-constraint violation occurred.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_bprintf">_bprintf</A>, <A HREF="#cprintf">cprintf</A>, <A HREF="#fprintf">fprintf</A>, <A HREF="#printf">printf</A>,
<A HREF="#sprintf">sprintf</A>, <A HREF="#_vbprintf">_vbprintf</A>, <A HREF="#vcprintf">vcprintf</A>, <A HREF="#vfprintf">vfprintf</A>,
<A HREF="#vprintf">vprintf</A>, <A HREF="#vsprintf">vsprintf</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__ 1</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>char *weekday = { &quot;Friday&quot; };</TT>
<BR><TT>char *month = { &quot;August&quot; };</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fprintf_s( stdout, &quot;%s, %s %d, %d\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; weekday, month, 13, 2004 );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>Friday, August 13, 2004</TT>
</DL>
<DL>
<DT>Classification:
<DD>TR 24731
</DL>
<DL>
<DT>Systems:
<DD><TT> fprintf_s - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>fwprintf_s - All, Linux</TT>
</DL>
<H2 ID="fputc"> fputc, fputwc </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>int fputc( int c, FILE *fp );</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>wint_t fputwc( wint_t c, FILE *fp );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> fputc</TT> function writes the character specified by the argument<B> c</B> to the output stream designated by<B>
fp</B>.
<BR><BR>The<TT> fputwc</TT> function is identical to<TT> fputc</TT> except that it converts the wide character specified by<B>
c</B> to a multibyte character and writes it to the output stream.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> fputc</TT> function returns the character written or, if a write error occurs, the error indicator is set and<TT>
fputc</TT> returns <TT> EOF</TT>.
<BR><BR>The<TT> fputwc</TT> function returns the wide character written or, if a write error occurs, the error indicator is
set and<TT> fputwc</TT> returns <TT> WEOF</TT>.&nbsp; If an encoding error occurs, <TT> errno</TT> is set to <TT> EILSEQ</TT>
and<TT> fputwc</TT> returns <TT> WEOF</TT>.
<BR><BR>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#fopen">fopen</A>, <A HREF="#fputchar">fputchar</A>, <A HREF="#fputs">fputs</A>, <A HREF="#putc">putc</A>, <A HREF="#putchar">putchar</A>,
<A HREF="#puts">puts</A>, <A HREF="#ferror">ferror</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FILE *fp;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int c;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; fp = fopen( &quot;file&quot;, &quot;r&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( fp != NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( (c = fgetc( fp )) != EOF )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fputc( c, stdout );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( fp );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD><TT> fputc - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>fputwc - All, Linux</TT>
</DL>
<H2 ID="fputchar"> fputchar, _fputchar, _fputwchar </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>int fputchar( int c );</TT>
<BR><TT>int _fputchar( int c );</TT>
<BR><TT>wint_t _fputwchar( wint_t c );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> fputchar</TT> function writes the character specified by the argument<B> c</B> to the output stream <TT> stdout</TT>.
&nbsp;This function is identical to the <TT> putchar</TT> function.
<BR><BR>The function is equivalent to:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fputc( c, stdout );</TT>
<BR><BR>The<TT> _fputchar</TT> function is identical to<TT> fputchar</TT>.&nbsp; Use<TT> _fputchar</TT> for ANSI naming conventions.
<BR><BR>The<TT> _fputwchar</TT> function is identical to<TT> fputchar</TT> except that it converts the wide character specified
by<B> c</B> to a multibyte character and writes it to the output stream.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> fputchar</TT> function returns the character written or, if a write error occurs, the error indicator is set and<TT>
fputchar</TT> returns <TT> EOF</TT>.
<BR><BR>The<TT> _fputwchar</TT> function returns the wide character written or, if a write error occurs, the error indicator
is set and<TT> _fputwchar</TT> returns <TT> WEOF</TT>.
<BR><BR>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#fopen">fopen</A>, <A HREF="#fputc">fputc</A>, <A HREF="#fputs">fputs</A>, <A HREF="#putc">putc</A>, <A HREF="#putchar">putchar</A>,
<A HREF="#puts">puts</A>, <A HREF="#ferror">ferror</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FILE *fp;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int c;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; fp = fopen( &quot;file&quot;, &quot;r&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( fp != NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c = fgetc( fp );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( c != EOF ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fputchar( c );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c = fgetc( fp );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( fp );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
<BR><BR>_fputchar conforms to ANSI naming conventions
</DL>
<DL>
<DT>Systems:
<DD><TT> fputchar - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_fputchar - All, Linux, RDOS, Netware</TT>
<BR><TT>_fputwchar - All, Linux</TT>
</DL>
<H2 ID="fputs"> fputs, fputws </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>int fputs( const char *buf, FILE *fp );</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>int fputws( const wchar_t *buf, FILE *fp );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> fputs</TT> function writes the character string pointed to by<B> buf</B> to the output stream designated by<B> fp</B>.
&nbsp;The terminating null character is not written.
<BR><BR>The<TT> fputws</TT> function is identical to<TT> fputs</TT> except that it converts the wide character string specified
by<B> buf</B> to a multibyte character string and writes it to the output stream.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> fputs</TT> function returns <TT> EOF</TT> if an error occurs; otherwise, it returns a non-negative value (the number
of characters written).&nbsp; The<TT> fputws</TT> function returns <TT> EOF</TT> if a write or encoding error occurs; otherwise,
it returns a non-negative value (the number of characters written).&nbsp; When an error has occurred, <TT> errno</TT> contains
a value indicating the type of error that has been detected.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#fopen">fopen</A>, <A HREF="#fputc">fputc</A>, <A HREF="#fputchar">fputchar</A>, <A HREF="#putc">putc</A>, <A HREF="#putchar">putchar</A>,
<A HREF="#puts">puts</A>, <A HREF="#ferror">ferror</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FILE *fp;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char buffer[80];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; fp = fopen( &quot;file&quot;, &quot;r&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( fp != NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( fgets( buffer, 80, fp ) != NULL )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fputs( buffer, stdout );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( fp );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD><TT> fputs - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>fputws - All, Linux</TT>
</DL>
<H2 ID="fread"> fread </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>size_t fread( void *buf,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t elsize,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t nelem,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FILE *fp );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> fread</TT> function reads<B> nelem</B> elements of<B> elsize</B> bytes each from the file specified by<B> fp</B> into
the buffer specified by<B> buf</B>.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> fread</TT> function returns the number of complete elements successfully read.&nbsp; This value may be less than the
requested number of elements.
<BR><BR>The <TT> feof</TT> and <TT> ferror</TT> functions can be used to determine whether the end of the file was encountered
or if an input/output error has occurred.&nbsp; When an error has occurred, <TT> errno</TT> contains a value indicating the
type of error that has been detected.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#fopen">fopen</A>, <A HREF="#feof">feof</A>, <A HREF="#ferror">ferror</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR>The following example reads a simple student record containing binary data.&nbsp; The student record is described by the<TT>
struct student_data</TT> declaration.
<BR><BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>struct student_data {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp; student_id;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned char marks[10];</TT>
<BR><TT>};</TT>
<BR><BR><TT>size_t read_data( FILE *fp, struct student_data *p )</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; return( fread( p, sizeof(*p), 1, fp ) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FILE *fp;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct student_data std;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; fp = fopen( &quot;file&quot;, &quot;r&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( fp != NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( read_data( fp, &amp;std ) != 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;id=%d &quot;, std.student_id );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; 10; i++ )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%3d &quot;, std.marks[ i ] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( fp );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="free"> free Functions </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;&nbsp; For ISO C compatibility (free only)</TT>
<BR><TT>#include &lt;malloc.h&gt;&nbsp; Required for other function prototypes</TT>
<BR><TT>void free( void *ptr );</TT>
<BR><TT>void _bfree( __segment seg, void __based(void) *ptr );</TT>
<BR><TT>void _ffree( void __far&nbsp; *ptr );</TT>
<BR><TT>void _nfree( void __near *ptr );</TT>
</DL>
<DL>
<DT>Description:
<DD>When the value of the argument<B> ptr</B> is<TT> NULL,</TT> the<TT> free</TT> function does nothing; otherwise, the<TT> free</TT>
function deallocates the memory block located by the argument<B> ptr</B> which points to a memory block previously allocated
through a call to the appropriate version of <TT> calloc</TT>, <TT> malloc</TT> or <TT> realloc</TT>.&nbsp; After the call,
the freed block is available for allocation.
<BR><BR>Each function deallocates memory from a particular heap, as listed below:
<DL>
<DT>Function&nbsp;&nbsp;&nbsp;&nbsp; Heap
<DT>free
<DD>Depends on data model of the program
<DT>_bfree
<DD>Based heap specified by<B> seg</B> value
<DT>_ffree
<DD>Far heap (outside the default data segment)
<DT>_nfree
<DD>Near heap (inside the default data segment)
</DL>
<BR>In a large data memory model, the<TT> free</TT> function is equivalent to the <TT> _ffree</TT> function; in a small data
memory model, the<TT> free</TT> function is equivalent to the <TT> _nfree</TT> function.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> free</TT> functions return no value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#calloc">calloc</A> Functions, <A HREF="#_expand">_expand</A> Functions, <A HREF="#halloc">halloc</A>, <A HREF="#hfree">hfree</A>,
<A HREF="#malloc">malloc</A> Functions, <A HREF="#_msize">_msize</A> Functions, <A HREF="#realloc">realloc</A> Functions,
<A HREF="#sbrk">sbrk</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char *buffer;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; buffer = (char *)malloc( 80 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( buffer == NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Unable to allocate memory\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* rest of code goes here */</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; free( buffer );&nbsp; /* deallocate buffer */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>_bfree is WATCOM
<BR>_ffree is WATCOM
<BR>_nfree is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> free - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_bfree - DOS/16, Windows, OS/2 1.x(all)</TT>
<BR><TT>_ffree - DOS/16, Windows, OS/2 1.x(all)</TT>
<BR><TT>_nfree - DOS, Windows, Win386, Win32, OS/2 1.x, OS/2 1.x(MT), OS/2-32, Linux, RDOS</TT>
</DL>
<H2 ID="_freect"> _freect </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;malloc.h&gt;</TT>
<BR><TT>unsigned int _freect( size_t size );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _freect</TT> function returns the number of times that <TT> _nmalloc</TT> (or <TT> malloc</TT> in small data models)
can be called to allocate a item of<B> size</B> bytes.&nbsp; In the tiny, small and medium memory models, the default data
segment is only extended as needed to satisfy requests for memory allocation.&nbsp; Therefore, you will need to call <TT>
_nheapgrow</TT> in these memory models before calling _freect in order to get a meaningful result.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _freect</TT> function returns the number of calls as an unsigned integer.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#calloc">calloc</A>, <A HREF="#_heapgrow">_heapgrow</A> Functions, <A HREF="#malloc">malloc</A> Functions, <A HREF="#_memavl">_memavl</A>,
<A HREF="#_memmax">_memmax</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;malloc.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp; i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Can allocate %u longs before _nheapgrow\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _freect( sizeof(long) ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _nheapgrow();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Can allocate %u longs after _nheapgrow\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _freect( sizeof(long) ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 1; i &lt; 1000; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _nmalloc( sizeof(long) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;After allocating 1000 longs:\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Can still allocate %u longs\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _freect( sizeof(long) ) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>Can allocate 0 longs before _nheapgrow</TT>
<BR><TT>Can allocate 10447 longs after _nheapgrow</TT>
<BR><TT>After allocating 1000 longs:</TT>
<BR><TT>Can still allocate 9447 longs</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS
</DL>
<H2 ID="freopen"> freopen, _wfreopen </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>FILE *freopen( const char *filename,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *mode,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FILE *fp );</TT>
<BR><TT>FILE *_wfreopen( const wchar_t *filename,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t *mode,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FILE *fp );</TT>
</DL>
<DL>
<DT>Safer C:
<DD>The Safer C Library extension provides the <A HREF="#freopen_s">freopen_s</A> function which is a safer alternative to<TT>
freopen</TT> This newer<TT> freopen_s</TT> function is recommended to be used instead of the traditional &quot;unsafe&quot;<TT>
freopen</TT> function.
</DL>
<DL>
<DT>Description:
<DD>The stream located by the <TT> fp</TT> pointer is closed.&nbsp; The<TT> freopen</TT> function opens the file whose name is
the string pointed to by<B> filename</B>, and associates a stream with it.&nbsp; The stream information is placed in the structure
located by the<B> fp</B> pointer.
<BR><BR>The argument<B> mode</B> is described in the description of the <TT> fopen</TT> function.
<BR><BR>The<TT> _wfreopen</TT> function is a wide-character version of<TT> freopen</TT> that operates with wide-character
strings.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> freopen</TT> function returns a pointer to the object controlling the stream.&nbsp; This pointer must be passed as
a parameter to subsequent functions for performing operations on the file.&nbsp; If the open operation fails,<TT> freopen</TT>
returns<TT> NULL.</TT>&nbsp; When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that
has been detected.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_dos_open">_dos_open</A>, <A HREF="#fclose">fclose</A>, <A HREF="#fcloseall">fcloseall</A>, <A HREF="#fdopen">fdopen</A>,
<A HREF="#fopen">fopen</A>, <A HREF="#fopen_s">fopen_s</A>, <A HREF="#freopen_s">freopen_s</A>, <A HREF="#_fsopen">_fsopen</A>,
<A HREF="#_grow_handles">_grow_handles</A>, <A HREF="#_hdopen">_hdopen</A>, <A HREF="#open">open</A>, <A HREF="#_open_osfhandle">_open_osfhandle</A>,
<A HREF="#_popen">_popen</A>, <A HREF="#sopen">sopen</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FILE *fp;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int c;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; fp = freopen( &quot;file&quot;, &quot;r&quot;, stdin );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( fp != NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( (c = fgetchar()) != EOF )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fputchar(c);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( fp );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>_wfreopen is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> freopen - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_wfreopen - All, Linux</TT>
</DL>
<H2 ID="freopen_s"> freopen_s, _wfreopen_s </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#define __STDC_WANT_LIB_EXT1__ 1</TT>
<BR><TT>errno_t&nbsp; freopen_s( FILE * restrict * restrict newstreamptr,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const char * filename,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const char * restrict mode,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
FILE * restrict stream );</TT>
<BR><TT>errno_t _wfreopen_s( FILE * restrict * restrict newstreamptr,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;const wchar_t * restrict filename,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;const wchar_t * restrict mode,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;FILE * restrict stream );</TT>
</DL>
<DL>
<DT>Constraints:
<DD>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<TT>
freopen_s</TT> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<BR><BR>None of<B> newstreamptr</B>,<B> mode</B>, and<B> stream</B> shall be a null pointer.&nbsp; If there is a runtime-constraint
violation,<TT> freopen_s</TT> neither attempts to close any file associated with<B> stream</B> nor attempts to open a file.
&nbsp;Furthermore, if<B> newstreamptr</B> is not a null pointer,<TT> freopen_s</TT> sets<B> *newstreamptr</B> to the null
pointer.
</DL>
<DL>
<DT>Description:
<DD>The<TT> freopen_s</TT> function opens the file whose name is the string pointed to by<B> filename</B> and associates the stream
pointed to by<B> stream</B> with it.&nbsp; The<B> mode</B> argument has the same meaning as in the fopen_s function (including
the mode's effect on exclusive access and file permissions).&nbsp; If<B> filename</B> is a null pointer,the<TT> freopen_s</TT>
function attempts to change the mode of the<B> stream</B> to that specified by<B> mode</B> ,as if the name of the file currently
associated with the stream had been used.&nbsp; It is implementation-defined which changes of mode are permitted (if any),
and under what circumstances.&nbsp; The<TT> freopen_s</TT> function first attempts to close any file that is associated with<B>
stream</B>.&nbsp; Failure to close the file is ignored.&nbsp; The error and end-of-file indicators for the stream are cleared.
&nbsp;If the file was opened successfully, then the pointer to FILE pointed to by<B> newstreamptr</B> will be set to the value
of stream.&nbsp; Otherwise, the pointer to FILE pointed to by<B> newstreamptr</B> will be set to a null pointer.
<BR><BR>The<TT> _wfreopen_s</TT> function is a wide-character version of<TT> freopen_s</TT> that operates with wide-character
strings.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> freopen_s</TT> function returns zero if it opened the file.&nbsp; If it did not open the file or there was a runtime-constraint
violation,<TT> freopen_s</TT> returns a non-zero value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_dos_open">_dos_open</A>, <A HREF="#fclose">fclose</A>, <A HREF="#fcloseall">fcloseall</A>, <A HREF="#fdopen">fdopen</A>,
<A HREF="#fopen">fopen</A>, <A HREF="#fopen_s">fopen_s</A>, <A HREF="#freopen">freopen</A>, <A HREF="#_fsopen">_fsopen</A>,
<A HREF="#_grow_handles">_grow_handles</A>, <A HREF="#_hdopen">_hdopen</A>, <A HREF="#open">open</A>, <A HREF="#_open_osfhandle">_open_osfhandle</A>,
<A HREF="#_popen">_popen</A>, <A HREF="#sopen">sopen</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__ 1</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; errno_t rc;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FILE&nbsp;&nbsp;&nbsp; *fp;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; c;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; rc = freopen_s( &amp;fp, &quot;file&quot;, &quot;r&quot;, stdin );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( rc == 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( (c = fgetc( fp )) != EOF )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fputchar(c);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( fp );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>TR 24731
<BR><BR>_wfreopen_s is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> freopen_s - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_wfreopen_s - All, Linux</TT>
</DL>
<H2 ID="frexp"> frexp </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>double frexp( double value, int *exp );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> frexp</TT> function breaks a floating-point number into a normalized fraction and an integral power of 2.&nbsp; It
stores the integral power of 2 in the<B> int</B> object pointed to by<B> exp</B>.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> frexp</TT> function returns the value of<B> x</B>, such that<B> x</B> is a<TT> double</TT> with magnitude in the interval
[0.5,1) or zero, and<B> value</B> equals<B> x</B> times 2 raised to the power<B> *exp</B>.&nbsp; If<B> value</B> is zero,
then both parts of the result are zero.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#ldexp">ldexp</A>, <A HREF="#modf">modf</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp; expon;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; double value;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; value = frexp(&nbsp; 4.25, &amp;expon );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%f %d\n&quot;, value, expon );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; value = frexp( -4.25, &amp;expon );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%f %d\n&quot;, value, expon );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>0.531250 3</TT>
<BR><TT>-0.531250 3</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD>Math
</DL>
<H2 ID="fscanf"> fscanf, fwscanf </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>int fscanf( FILE *fp, const char *format, ... );</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>int fwscanf( FILE *fp, const wchar_t *format, ... );</TT>
</DL>
<DL>
<DT>Safer C:
<DD>The Safer C Library extension provides the <A HREF="#fscanf_s">fscanf_s</A> function which is a safer alternative to<TT> fscanf</TT>
This newer<TT> fscanf_s</TT> function is recommended to be used instead of the traditional &quot;unsafe&quot;<TT> fscanf</TT>
function.
</DL>
<DL>
<DT>Description:
<DD>The<TT> fscanf</TT> function scans input from the file designated by<B> fp</B> under control of the argument<B> format</B>.
&nbsp;Following the format string is a list of addresses to receive values.&nbsp; The<B> format</B> string is described under
the description of the <TT> scanf</TT> function.
<BR><BR>The<TT> fwscanf</TT> function is identical to<TT> fscanf</TT> except that it accepts a wide-character string argument
for<B> format</B>.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> fscanf</TT> function returns <TT> EOF</TT> if an input failure occurred before any conversion.&nbsp; Otherwise, the
number of input arguments for which values were successfully scanned and stored is returned.&nbsp; When a file input error
occurs, the <TT> errno</TT> global variable may be set.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#cscanf">cscanf</A>, <A HREF="#scanf">scanf</A>, <A HREF="#sscanf">sscanf</A>, <A HREF="#vcscanf">vcscanf</A>, <A HREF="#vfscanf">vfscanf</A>,
<A HREF="#vscanf">vscanf</A>, <A HREF="#vsscanf">vsscanf</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR>To scan a date in the form &quot;Saturday April 18 1987&quot;:
<BR><BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int day, year;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char weekday[10], month[10];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FILE *in_data;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; in_data = fopen( &quot;file&quot;, &quot;r&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( in_data != NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fscanf( in_data, &quot;%s %s %d %d&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; weekday, month, &amp;day,
&amp;year );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Weekday=%s Month=%s Day=%d Year=%d\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; weekday, month, day, year
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( in_data );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C90
<BR><BR>fwscanf is ISO C95
</DL>
<DL>
<DT>Systems:
<DD><TT> fscanf - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>fwscanf - All, Linux</TT>
</DL>
<H2 ID="fscanf_s"> fscanf_s, fwscanf_s </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__ 1</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>int fscanf_s( FILE * restrict stream,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char * restrict format, ... );</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>int fwscanf_s( FILE * restrict stream,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t * restrict format, ... );</TT>
</DL>
<DL>
<DT>Constraints:
<DD>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<TT>
fscanf_s</TT> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<BR><BR>Neither<B> stream</B> nor<B> format</B> shall be a null pointer.&nbsp; Any argument indirected through in order to
store converted input shall not be a null pointer.
<BR><BR>If there is a runtime-constraint violation, the<TT> fscanf_s</TT> function does not attempt to perform further input,
and it is unspecified to what extent<TT> fscanf_s</TT> performed input before discovering the runtime-constraint violation.
</DL>
<DL>
<DT>Description:
<DD>The<TT> fscanf_s</TT> function is equivalent to <TT> fscanf</TT> except that the<TT> c, s,</TT> and<TT> [</TT> conversion
specifiers apply to a pair of arguments (unless assignment suppression is indicated by a<TT> *</TT>).&nbsp; The first of these
arguments is the same as for <TT> fscanf</TT>.&nbsp; That argument is immediately followed in the argument list by the second
argument, which has type <TT> size_t</TT> and gives the number of elements in the array pointed to by the first argument of
the pair.&nbsp; If the first argument points to a scalar object, it is considered to be an array of one element.
<BR><BR>A matching failure occurs if the number of elements in a receiving object is insufficient to hold the converted input
(including any trailing null character).
<BR><BR>The<TT> fwscanf_s</TT> function is identical to<TT> fscanf_s</TT> except that it accepts a wide-character string argument
for<B> format</B>.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> fscanf_s</TT> function returns <TT> EOF</TT> if an input failure occurred before any conversion or if there was a
runtime-constraint violation.&nbsp; Otherwise, the<TT> fscanf_s</TT> function returns the number of input items successfully
assigned, which can be fewer than provided for, or even zero.
<BR><BR>When a file input error occurs, the <TT> errno</TT> global variable may be set.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#cscanf">cscanf</A>, <A HREF="#fscanf">fscanf</A>, <A HREF="#scanf">scanf</A>, <A HREF="#sscanf">sscanf</A>, <A HREF="#vcscanf">vcscanf</A>,
<A HREF="#vfscanf">vfscanf</A>, <A HREF="#vscanf">vscanf</A>, <A HREF="#vsscanf">vsscanf</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR>To scan a date in the form &quot;Friday August 13 2004&quot;:
<BR><BR><TT>#define __STDC_WANT_LIB_EXT1__ 1</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int day, year;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char weekday[10], month[10];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FILE *in_data;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; in_data = fopen( &quot;file&quot;, &quot;r&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( in_data != NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fscanf_s( in_data, &quot;%s %s %d %d&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; weekday, sizeof( weekday
),</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; month, sizeof( month ),</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;day, &amp;year );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf_s( &quot;Weekday=%s Month=%s Day=%d Year=%d\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; weekday, month, day, year
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( in_data );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>TR 24731
</DL>
<DL>
<DT>Systems:
<DD><TT> fscanf_s - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>fwscanf_s - All, Linux</TT>
</DL>
<H2 ID="fseek"> fseek </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>int fseek( FILE *fp, long int offset, int where );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> fseek</TT> function changes the read/write position of the file specified by<B> fp</B>.&nbsp; This position defines
the character that will be read or written on the next I/O operation on the file.&nbsp; The argument<B> fp</B> is a file pointer
returned by <TT> fopen</TT> or <TT> freopen</TT>.&nbsp; The argument<B> offset</B> is the position to seek to relative to
one of three positions specified by the argument<B> where</B>.&nbsp; Allowable values for<B> where</B> are:
<DL>
<DT>Value&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>SEEK_SET
<DD>The new file position is computed relative to the start of the file.&nbsp; The value of<B> offset</B> must not be negative.
<DT>SEEK_CUR
<DD>The new file position is computed relative to the current file position.&nbsp; The value of<B> offset</B> may be positive,
negative or zero.
<DT>SEEK_END
<DD>The new file position is computed relative to the end of the file.
</DL>
<BR>The<TT> fseek</TT> function clears the end-of-file indicator and undoes any effects of the <TT> ungetc</TT> function on
the same file.
<BR><BR>The <TT> ftell</TT> function can be used to obtain the current position in the file before changing it.&nbsp; The
position can be restored by using the value returned by <TT> ftell</TT> in a subsequent call to<TT> fseek</TT> with the<B>
where</B> parameter set to <TT> SEEK_SET</TT>.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> fseek</TT> function returns zero if successful, non-zero otherwise.&nbsp; When an error has occurred, <TT> errno</TT>
contains a value indicating the type of error that has been detected.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#fgetpos">fgetpos</A>, <A HREF="#fopen">fopen</A>, <A HREF="#fsetpos">fsetpos</A>, <A HREF="#ftell">ftell</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR>The size of a file can be determined by the following example which saves and restores the current position of the file.
<BR><BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>long int filesize( FILE *fp )</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; long int save_pos, size_of_file;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; save_pos = ftell( fp );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fseek( fp, 0L, SEEK_END );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; size_of_file = ftell( fp );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fseek( fp, save_pos, SEEK_SET );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; return( size_of_file );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FILE *fp;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; fp = fopen( &quot;file&quot;, &quot;r&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( fp != NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;File size=%ld\n&quot;, filesize( fp ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( fp );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="fsetpos"> fsetpos </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>int fsetpos( FILE *fp, fpos_t *pos );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> fsetpos</TT> function positions the file<B> fp</B> according to the value of the object pointed to by<B> pos</B>,
which shall be a value returned by an earlier call to the <TT> fgetpos</TT> function on the same file.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> fsetpos</TT> function returns zero if successful, otherwise, the<TT> fsetpos</TT> function returns a non-zero value.
&nbsp;When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#fgetpos">fgetpos</A>, <A HREF="#fopen">fopen</A>, <A HREF="#fseek">fseek</A>, <A HREF="#ftell">ftell</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FILE *fp;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fpos_t position;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; auto char buffer[80];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; fp = fopen( &quot;file&quot;, &quot;r&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( fp != NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fgetpos( fp, &amp;position ); /* get position&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fgets( buffer, 80, fp );&nbsp; /* read record&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fsetpos( fp, &amp;position ); /* set position&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fgets( buffer, 80, fp );&nbsp; /* read same record */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( fp );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="_fsopen"> _fsopen, _wfsopen </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>FILE *_fsopen( const char *filename,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *mode, int share );</TT>
<BR><TT>FILE *_wfsopen( const wchar_t *filename,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t *mode, int
share );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _fsopen</TT> function opens the file whose name is the string pointed to by<B> filename</B>, and associates a stream
with it.&nbsp; The arguments<B> mode</B> and<B> share</B> control shared reading or writing.&nbsp; The argument<B> mode</B>
points to a string beginning with one of the following sequences:
<DL>
<DT>Mode&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>&quot;r&quot;
<DD>open file for reading; use default file translation
<DT>&quot;w&quot;
<DD>create file for writing, or truncate to zero length; use default file translation
<DT>&quot;a&quot;
<DD>append:&nbsp; open text file or create for writing at end-of-file; use default file translation
<DT>&quot;rb&quot;
<DD>open binary file for reading
<DT>&quot;rt&quot;
<DD>open text file for reading
<DT>&quot;wb&quot;
<DD>create binary file for writing, or truncate to zero length
<DT>&quot;wt&quot;
<DD>create text file for writing, or truncate to zero length
<DT>&quot;ab&quot;
<DD>append; open binary file or create for writing at end-of-file
<DT>&quot;at&quot;
<DD>append; open text file or create for writing at end-of-file
<DT>&quot;r+&quot;
<DD>open file for update (reading and/or writing); use default file translation
<DT>&quot;w+&quot;
<DD>create file for update, or truncate to zero length; use default file translation
<DT>&quot;a+&quot;
<DD>append; open file or create for update, writing at end-of-file; use default file translation
<DT>&quot;r+b&quot;, &quot;rb+&quot;
<DD>open binary file for update (reading and/or writing)
<DT>&quot;r+t&quot;, &quot;rt+&quot;
<DD>open text file for update (reading and/or writing)
<DT>&quot;w+b&quot;, &quot;wb+&quot;
<DD>create binary file for update, or truncate to zero length
<DT>&quot;w+t&quot;, &quot;wt+&quot;
<DD>create text file for update, or truncate to zero length
<DT>&quot;a+b&quot;, &quot;ab+&quot;
<DD>append; open binary file or create for update, writing at end-of-file
<DT>&quot;a+t&quot;, &quot;at+&quot;
<DD>append; open text file or create for update, writing at end-of-file
</DL>
<BR>When default file translation is specified, the value of the global variable <TT> _fmode</TT> establishes whether the
file is to treated as a binary or a text file.&nbsp; Unless this value is changed by the program, the default will be text
mode.
<BR><BR>Opening a file with read mode (<TT>'r'</TT> as the first character in the<B> mode</B> argument) fails if the file
does not exist or it cannot be read.&nbsp; Opening a file with append mode (<TT>'a'</TT> as the first character in the<B>
mode</B> argument) causes all subsequent writes to the file to be forced to the current end-of-file, regardless of previous
calls to the <TT> fseek</TT> function.&nbsp; When a file is opened with update mode (<TT>'+'</TT> as the second or third character
of the<B> mode</B> argument), both input and output may be performed on the associated stream.
<BR><BR>When a stream is opened in update mode, both reading and writing may be performed.&nbsp; However, writing may not
be followed by reading without an intervening call to the <TT> fflush</TT> function or to a file positioning function (<TT>
fseek</TT> , <TT> fsetpos</TT> , <TT> rewind</TT>).&nbsp; Similarly, reading may not be followed by writing without an intervening
call to a file positioning function, unless the read resulted in end-of-file.
<BR><BR>The shared access for the file,<B> share</B>, is established by a combination of bits defined in the<TT> &lt;share.h&gt;</TT>
header file.&nbsp; The following values may be set:
<DL>
<DT>Value&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>SH_COMPAT
<DD>Set compatibility mode.
<DT>SH_DENYRW
<DD>Prevent read or write access to the file.
<DT>SH_DENYWR
<DD>Prevent write access of the file.
<DT>SH_DENYRD
<DD>Prevent read access to the file.
<DT>SH_DENYNO
<DD>Permit both read and write access to the file.
</DL>
<BR>You should consult the technical documentation for the DOS system that you are using for more detailed information about
these sharing modes.
<BR><BR>The<TT> _wfsopen</TT> function is a wide-character version of<TT> _fsopen</TT> that operates with wide-character strings.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _fsopen</TT> function returns a pointer to the object controlling the stream.&nbsp; This pointer must be passed as
a parameter to subsequent functions for performing operations on the file.&nbsp; If the open operation fails,<TT> _fsopen</TT>
returns<TT> NULL.</TT>&nbsp; When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that
has been detected.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_dos_open">_dos_open</A>, <A HREF="#fclose">fclose</A>, <A HREF="#fcloseall">fcloseall</A>, <A HREF="#fdopen">fdopen</A>,
<A HREF="#fopen">fopen</A>, <A HREF="#freopen">freopen</A>, <A HREF="#_grow_handles">_grow_handles</A>, <A HREF="#_hdopen">_hdopen</A>,
<A HREF="#open">open</A>, <A HREF="#_open_osfhandle">_open_osfhandle</A>, <A HREF="#_popen">_popen</A>, <A HREF="#sopen">sopen</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;share.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FILE *fp;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; /*</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; open a file and prevent others from writing to it</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fp = _fsopen( &quot;report.dat&quot;, &quot;w&quot;, SH_DENYWR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( fp != NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* rest of code goes here */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( fp );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> _fsopen - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_wfsopen - All, Linux</TT>
</DL>
<H2 ID="fstat"> fstat, _fstat, _fstati64, _wfstat, _wfstati64 </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;sys/types.h&gt;</TT>
<BR><TT>#include &lt;sys/stat.h&gt;</TT>
<BR><TT>int fstat( int handle, struct stat *buf );</TT>
<BR><TT>int _fstat( int handle, struct stat *buf );</TT>
<BR><TT>int _fstati64( int handle, struct _stati64 *buf );</TT>
<BR><TT>int _wfstat( int handle, struct _stat *buf );</TT>
<BR><TT>int _wfstati64( int handle, struct _stati64 *buf );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> fstat</TT> functions obtain information about an open file whose file handle is<B> handle</B>.&nbsp; This information
is placed in the structure located at the address indicated by<B> buf</B>.
<BR><BR>The file<TT> &lt;sys/stat.h&gt;</TT> contains definitions for the structure <TT> stat</TT>.
<DL>
<DT>Field&nbsp;&nbsp;&nbsp;&nbsp; Type/Meaning
<DT>st_dev
<DD>(dev_t) the disk drive the file resides on
<DT>st_ino
<DD>(ino_t) this inode's number (not used for DOS)
<DT>st_mode
<DD>(unsigned short) file mode
<DT>st_nlink
<DD>(short) number of hard links
<DT>st_uid
<DD>(unsigned long) user-id (always 'root' for DOS)
<DT>st_gid
<DD>(short) group-id (always 'root' for DOS)
<DT>st_rdev
<DD>(dev_t) this should be the device type but it is the same as st_dev for the time being
<DT>st_size
<DD>(off_t) total file size
<DT>st_atime
<DD>(time_t) this should be the file &quot;last accessed&quot; time if the file system supports it
<DT>st_mtime
<DD>(time_t) the file &quot;last modified&quot; time
<DT>st_ctime
<DD>(time_t) this should be the file &quot;last status change&quot; time if the file system supports it
<BR><BR><B>The following fields are Netware only:</B>
<DT>st_btime
<DD>(time_t) the file &quot;last archived&quot; time
<DT>st_attr
<DD>(unsigned long) the file's attributes
<DT>st_archivedID
<DD>(unsigned long) the user/object ID that last archived file
<DT>st_updatedID
<DD>(unsigned long) the user/object ID that last updated file
<DT>st_inheritedRightsMask
<DD>(unsigned short) the inherited rights mask
<DT>st_originatingNameSpace
<DD>(unsigned char) the originating name space
</DL>
<BR>The structure <TT> _stati64</TT> differs from <TT> stat</TT> in the following way:
<DL>
<DT>st_size
<DD>(__int64) total file size (as a 64-bit value)
</DL>
<BR>At least the following macros are defined in the<TT> &lt;sys/stat.h&gt;</TT> header file.
<DL>
<DT>Macro&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>S_ISFIFO(m)
<DD>Test for FIFO.
<DT>S_ISCHR(m)
<DD>Test for character special file.
<DT>S_ISDIR(m)
<DD>Test for directory file.
<DT>S_ISBLK(m)
<DD>Test for block special file.
<DT>S_ISREG(m)
<DD>Test for regular file.
</DL>
<BR>The value<B> m</B> supplied to the macros is the value of the <TT> st_mode</TT> field of a <TT> stat</TT> structure.&nbsp;
The macro evaluates to a non-zero value if the test is true and zero if the test is false.
<BR><BR>The following bits are encoded within the <TT> st_mode</TT> field of a <TT> stat</TT> structure.
<DL>
<DT>Mask&nbsp;&nbsp;&nbsp;&nbsp; Owner Permissions
<DT>S_IRWXU
<DD>Read, write, search (if a directory), or execute (otherwise)
<DT>S_IRUSR
<DD>Read permission bit
<DT>S_IWUSR
<DD>Write permission bit
<DT>S_IXUSR
<DD>Search/execute permission bit
<DT>S_IREAD
<DD>== <TT> S_IRUSR</TT> (for Microsoft compatibility)
<DT>S_IWRITE
<DD>== <TT> S_IWUSR</TT> (for Microsoft compatibility)
<DT>S_IEXEC
<DD>== <TT> S_IXUSR</TT> (for Microsoft compatibility)
</DL>
<BR><TT> S_IRWXU</TT> is the bitwise inclusive OR of <TT> S_IRUSR</TT>, <TT> S_IWUSR</TT>, and <TT> S_IXUSR</TT>.
<DL>
<DT>Mask&nbsp;&nbsp;&nbsp;&nbsp; Group Permissions (same as owner's on DOS, OS/2 or Windows)
<DT>S_IRWXG
<DD>Read, write, search (if a directory), or execute (otherwise)
<DT>S_IRGRP
<DD>Read permission bit
<DT>S_IWGRP
<DD>Write permission bit
<DT>S_IXGRP
<DD>Search/execute permission bit
</DL>
<BR><TT> S_IRWXG</TT> is the bitwise inclusive OR of <TT> S_IRGRP</TT>, <TT> S_IWGRP</TT>, and <TT> S_IXGRP</TT>.
<DL>
<DT>Mask&nbsp;&nbsp;&nbsp;&nbsp; Other Permissions (same as owner's on DOS, OS/2 or Windows)
<DT>S_IRWXO
<DD>Read, write, search (if a directory), or execute (otherwise)
<DT>S_IROTH
<DD>Read permission bit
<DT>S_IWOTH
<DD>Write permission bit
<DT>S_IXOTH
<DD>Search/execute permission bit
</DL>
<BR><TT> S_IRWXO</TT> is the bitwise inclusive OR of <TT> S_IROTH</TT>, <TT> S_IWOTH</TT>, and <TT> S_IXOTH</TT>.
<DL>
<DT>Mask&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>S_ISUID
<DD>(Not supported by DOS, OS/2 or Windows) Set user ID on execution.&nbsp; The process's effective user ID shall be set to that
of the owner of the file when the file is run as a program.&nbsp; On a regular file, this bit should be cleared on any write.
<DT>S_ISGID
<DD>(Not supported by DOS, OS/2 or Windows) Set group ID on execution.&nbsp; Set effective group ID on the process to the file's
group when the file is run as a program.&nbsp; On a regular file, this bit should be cleared on any write.
</DL>
<BR>The<TT> _fstat</TT> function is identical to<TT> fstat</TT>.&nbsp; Use<TT> _fstat</TT> for ANSI naming conventions.
<BR><BR>The <TT> _fstati64</TT>, <TT> _wfstat</TT>, and <TT> _wfstati64</TT> functions differ from<TT> fstat</TT> in the type
of structure that they are asked to fill in.&nbsp; The <TT> _wfstat</TT> and <TT> _wfstati64</TT> functions deal with wide
character strings.&nbsp; The differences in the structures are described above.
</DL>
<DL>
<DT>Returns:
<DD>All forms of the<TT> fstat</TT> function return zero when the information is successfully obtained.&nbsp; Otherwise, -1 is
returned.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>EBADF
<DD>The<B> handle</B> argument is not a valid file handle.
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#creat">creat</A>, <A HREF="#dup">dup</A>, <A HREF="#dup2">dup2</A>, <A HREF="#open">open</A>, <A HREF="#sopen">sopen</A>,
<A HREF="#stat">stat</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;sys/types.h&gt;</TT>
<BR><TT>#include &lt;sys/stat.h&gt;</TT>
<BR><TT>#include &lt;fcntl.h&gt;</TT>
<BR><TT>#include &lt;io.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int handle, rc;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct stat buf;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; handle = open( &quot;file&quot;, O_RDONLY );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( handle != -1 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc = fstat( handle, &amp;buf );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( rc != -1 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;File size = %d\n&quot;, buf.st_size
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close( handle );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>POSIX
<BR><BR>_fstat conforms to ANSI naming conventions
<BR>_fstati64 is WATCOM
<BR>_wfstat is WATCOM
<BR>_wfstati64 is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> fstat - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_fstat - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
<BR><TT>_fstati64 - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</TT>
<BR><TT>_wfstat - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</TT>
<BR><TT>_wfstati64 - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</TT>
</DL>
<H2 ID="fsync"> fsync </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;io.h&gt;</TT>
<BR><TT>int fsync( int fd );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> fsync</TT> function writes to disk all the currently queued data for the open file specified by<B> fd</B>.&nbsp; All
necessary file system information required to retrieve the data is also written to disk.&nbsp; The file access times are also
updated.
<BR><BR>The<TT> fsync</TT> function is used when you wish to ensure that both the file data and file system information required
to recover the complete file have been written to the disk.
<BR><BR>The<TT> fsync</TT> function does not return until the transfer is completed.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> fsync</TT> function returns zero if successful.&nbsp; Otherwise, it returns -1 and <TT> errno</TT> is set to indicate
the error.&nbsp; If the<TT> fsync</TT> function fails, outstanding i/o operations are not guaranteed to have been completed.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>EBADF
<DD>The<B> fd</B> argument is not a valid file handle.
<DT>EINVAL
<DD>Synchronized i/o is not supported for this file.
<DT>EIO
<DD>A physical I/O error occurred (e.g., a bad block).&nbsp; The precise meaning is device dependent.
<DT>ENOSYS
<DD>The<TT> fsync</TT> function is not supported.
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#fstat">fstat</A>, <A HREF="#open">open</A>, <A HREF="#stat">stat</A>, <A HREF="#write">write</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>/*</TT>
<BR><TT> *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Write a file and make sure it is on disk.</TT>
<BR><TT> */</TT>
<BR><TT>#include &lt;fcntl.h&gt;</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>#include &lt;io.h&gt;</TT>
<BR><BR><TT>char buf[512];</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int handle;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; handle = creat( &quot;file&quot;, S_IWRITE | S_IREAD );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( handle == -1 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; perror( &quot;Error creating file&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit( EXIT_FAILURE );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; 255; ++i ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memset( buf, i, sizeof( buf ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( write( handle, buf, sizeof(buf) ) != sizeof(buf) ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; perror( &quot;Error writing file&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit( EXIT_FAILURE );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; if( fsync( handle ) == -1 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; perror( &quot;Error sync'ing file&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit( EXIT_FAILURE );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; close( handle );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; exit( EXIT_SUCCESS );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>POSIX 1003.4
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="ftell"> ftell </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>long int ftell( FILE *fp );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> ftell</TT> function returns the current read/write position of the file specified by<B> fp</B>.&nbsp; This position
defines the character that will be read or written by the next I/O operation on the file.&nbsp; The value returned by<TT>
ftell</TT> can be used in a subsequent call to <TT> fseek</TT> to set the file to the same position.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> ftell</TT> function returns the current read/write position of the file specified by<B> fp</B>.&nbsp; When an error
is detected,<TT> -1L</TT> is returned.&nbsp; When an error has occurred, <TT> errno</TT> contains a value indicating the type
of error that has been detected.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#fgetpos">fgetpos</A>, <A HREF="#fopen">fopen</A>, <A HREF="#fsetpos">fsetpos</A>, <A HREF="#fseek">fseek</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>long int filesize( FILE *fp )</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; long int save_pos, size_of_file;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; save_pos = ftell( fp );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fseek( fp, 0L, SEEK_END );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; size_of_file = ftell( fp );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fseek( fp, save_pos, SEEK_SET );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; return( size_of_file );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FILE *fp;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; fp = fopen( &quot;file&quot;, &quot;r&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( fp != NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;File size=%ld\n&quot;, filesize( fp ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( fp );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="ftime"> ftime </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;sys/timeb.h&gt;</TT>
<BR><TT>int ftime( struct timeb *timeptr );</TT>
<BR><BR><TT>struct timeb {</TT>
<BR><TT> time_t time;&nbsp; /* time in seconds since Jan 1, 1970 UTC */</TT>
<BR><TT> unsigned short millitm; /* milliseconds */</TT>
<BR><TT> short timezone; /* difference in minutes from UTC */</TT>
<BR><TT> short dstflag;&nbsp; /* nonzero if in daylight savings time */</TT>
<BR><TT>};</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> ftime</TT> function gets the current time and stores it in the structure pointed to by<B> timeptr</B>.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> ftime</TT> function fills in the fields of the structure pointed to by<B> timeptr</B>.&nbsp; The<TT> ftime</TT> function
returns -1 if not successful, and no useful value otherwise.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#asctime">asctime</A> Functions, <A HREF="#asctime_s">asctime_s</A>, <A HREF="#clock">clock</A>, <A HREF="#ctime">ctime</A>
Functions, <A HREF="#ctime_s">ctime_s</A>, <A HREF="#difftime">difftime</A>, <A HREF="#gmtime">gmtime</A>, <A HREF="#gmtime_s">gmtime_s</A>,
<A HREF="#localtime">localtime</A>, <A HREF="#localtime_s">localtime_s</A>, <A HREF="#mktime">mktime</A>, <A HREF="#strftime">strftime</A>,
<A HREF="#time">time</A>, <A HREF="#tzset">tzset</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;time.h&gt;</TT>
<BR><TT>#include &lt;sys/timeb.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct timeb timebuf;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp; *tod;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; ftime( &amp;timebuf );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; tod = ctime( &amp;timebuf.time );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;The time is %.19s.%hu %s&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tod, timebuf.millitm, &amp;tod[20] );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>The time is Tue Dec 25 15:58:42.870 1990</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS
</DL>
<H2 ID="_fullpath"> _fullpath, _wfullpath </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>char *_fullpath( char *buffer,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *path,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t size );</TT>
<BR><TT>wchar_t *_wfullpath( wchar_t *buffer ,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;const wchar_t *path,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;size_t size );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _fullpath</TT> function returns the full pathname of the file specification in<B> path</B> in the specified buffer<B>
buffer</B> of length<B> size</B>.
<BR><BR>The maximum size that might be required for<B> buffer</B> is <TT> _MAX_PATH</TT>.&nbsp; If the buffer provided is
too small,<TT> NULL</TT> is returned and <TT> errno</TT> is set.
<BR><BR>If<B> buffer</B> is<TT> NULL</TT> then a buffer of size <TT> _MAX_PATH</TT> is allocated using <TT> malloc</TT>.&nbsp;
This buffer may be freed using the <TT> free</TT> function.
<BR><BR>If<B> path</B> is<TT> NULL</TT> or points to a null string (&quot;&quot;) then the current working directory is returned
in<B> buffer</B>.
<BR><BR>The<TT> _wfullpath</TT> function is a wide-character version of<TT> _fullpath</TT> that operates with wide-character
strings.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _fullpath</TT> function returns a pointer to the full path specification if no error occurred.&nbsp; Otherwise,<TT>
NULL</TT> is returned.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>ENOENT
<DD>The current working directory could not be obtained.
<DT>ENOMEM
<DD>The buffer could not be allocated.
<DT>ERANGE
<DD>The buffer passed was too small.
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_makepath">_makepath</A>, <A HREF="#_splitpath">_splitpath</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>void main( int argc, char *argv[] )</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int i;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char buff[ PATH_MAX ];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; for( i = 1; i &lt; argc; ++i ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; puts( argv[i] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( _fullpath( buff, argv[i], PATH_MAX ) ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; puts( buff );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; puts( &quot;FAIL!&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> _fullpath - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_wfullpath - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</TT>
</DL>
<H2 ID="fwide"> fwide </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>int fwide( FILE *fp, int mode );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> fwide</TT> function determines the orientation of the stream pointed to by<B> fp</B>.&nbsp; If<B> mode</B> is greater
than zero, the function first attempts to make the stream wide oriented.&nbsp; If<B> mode</B> is less than zero, the function
first attempts to make the stream byte oriented.&nbsp; Otherwise,<B> mode</B> is zero and the<TT> fwide</TT> function does
not alter the orientation of the stream.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> fwide</TT> function returns a value greater than zero if, after the call, the stream has wide orientation, a value
less than zero if the stream has byte orientation, or zero if the stream has no orientation.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#fopen">fopen</A>, <A HREF="#freopen">freopen</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FILE&nbsp;&nbsp;&nbsp; *fp;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; mode;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; fp = fopen( &quot;file&quot;, &quot;r&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( fp != NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode = fwide( fp, -33 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;orientation: %s\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode &gt; 0 ? &quot;wide&quot; :</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode &lt; 0 ? &quot;byte&quot; : &quot;none&quot;
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>orientation: byte</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C95
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS
</DL>
<H2 ID="fwrite"> fwrite </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>size_t fwrite( const void *buf,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t elsize,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t nelem,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FILE *fp );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> fwrite</TT> function writes<B> nelem</B> elements of<B> elsize</B> bytes each to the file specified by<B> fp</B>.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> fwrite</TT> function returns the number of complete elements successfully written.&nbsp; This value will be less than
the requested number of elements only if a write error occurs.&nbsp; When an error has occurred, <TT> errno</TT> contains
a value indicating the type of error that has been detected.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#ferror">ferror</A>, <A HREF="#fopen">fopen</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>struct student_data {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp; student_id;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned char marks[10];</TT>
<BR><TT>};</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FILE *fp;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct student_data std;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; fp = fopen( &quot;file&quot;, &quot;w&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( fp != NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std.student_id = 1001;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; 10; i++ )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std.marks[ i ] = (unsigned char) (85 + i);</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* write student record with marks */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = fwrite( &amp;std, sizeof(std), 1, fp );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%d record written\n&quot;, i );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( fp );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="gcvt"> gcvt, _gcvt, _wgcvt </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>char *gcvt( double value,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int ndigits,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *buffer );</TT>
<BR><TT>char *_gcvt( double value,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int ndigits,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *buffer );</TT>
<BR><TT>wchar_t *_wgcvt( double value,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int ndigits,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t *buffer );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> gcvt</TT> function converts the floating-point number<B> value</B> into a character string and stores the result in<B>
buffer</B>.&nbsp; The parameter<B> ndigits</B> specifies the number of significant digits desired.&nbsp; The converted number
will be rounded to this position.
<BR><BR>If the exponent of the number is less than -4 or is greater than or equal to the number of significant digits wanted,
then the number is converted into E-format, otherwise the number is formatted using F-format.
<BR><BR>The<TT> _gcvt</TT> function is identical to<TT> gcvt</TT>.&nbsp; Use<TT> _gcvt</TT> for ANSI naming conventions.
<BR><BR>The<TT> _wgcvt</TT> function is a wide-character version of<TT> gcvt</TT>.&nbsp; It produces a wide-character string.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> gcvt</TT> function returns a pointer to the string of digits.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#ecvt">ecvt</A>, <A HREF="#fcvt">fcvt</A>, <A HREF="#printf">printf</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char buffer[80];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, gcvt( -123.456789, 5, buffer ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, gcvt( 123.456789E+12, 5, buffer ) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>-123.46</TT>
<BR><TT>1.2346E+014</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
<BR><BR>_gcvt conforms to ANSI naming conventions
</DL>
<DL>
<DT>Systems:
<DD><TT> gcvt - Math</TT>
<BR><BR><TT>_gcvt - Math</TT>
<BR><TT>_wgcvt - Math</TT>
</DL>
<H2 ID="_getactivepage"> _getactivepage </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>short _FAR _getactivepage( void );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _getactivepage</TT> function returns the number of the currently selected active graphics page.
<BR><BR>Only some combinations of video modes and hardware allow multiple pages of graphics to exist.&nbsp; When multiple
pages are supported, the active page may differ from the visual page.&nbsp; The graphics information in the visual page determines
what is displayed upon the screen.&nbsp; Animation may be accomplished by alternating the visual page.&nbsp; A graphics page
can be constructed without affecting the screen by setting the active page to be different than the visual page.
<BR><BR>The number of available video pages can be determined by using the <TT> _getvideoconfig</TT> function.&nbsp; The default
video page is 0.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _getactivepage</TT> function returns the number of the currently selected active graphics page.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_setactivepage">_setactivepage</A>, <A HREF="#_setvisualpage">_setvisualpage</A>, <A HREF="#_getvisualpage">_getvisualpage</A>,
<A HREF="#_getvideoconfig">_getvideoconfig</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int old_apage;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int old_vpage;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _HRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; old_apage = _getactivepage();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; old_vpage = _getvisualpage();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* draw an ellipse on page 0 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setactivepage( 0 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvisualpage( 0 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _ellipse( _GFILLINTERIOR, 100, 50, 540, 150 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* draw a rectangle on page 1 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setactivepage( 1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _rectangle( _GFILLINTERIOR, 100, 50, 540, 150 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* display page 1 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvisualpage( 1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setactivepage( old_apage );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvisualpage( old_vpage );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_getarcinfo"> _getarcinfo </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>short _FAR _getarcinfo( struct xycoord _FAR *start_pt,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; struct xycoord _FAR *end_pt,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; struct xycoord _FAR *inside_pt );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _getarcinfo</TT> function returns information about the arc most recently drawn by the <TT> _arc</TT> or <TT> _pie</TT>
functions.&nbsp; The arguments<B> start_pt</B> and<B> end_pt</B> are set to contain the endpoints of the arc.&nbsp; The argument<B>
inside_pt</B> will contain the coordinates of a point within the pie.&nbsp; The points are all specified in the view coordinate
system.
<BR><BR>The endpoints of the arc can be used to connect other lines to the arc.&nbsp; The interior point can be used to fill
the pie.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _getarcinfo</TT> function returns a non-zero value when successful.&nbsp; If the previous arc or pie was not successfully
drawn, zero is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_arc">_arc</A>, <A HREF="#_pie">_pie</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct xycoord start_pt, end_pt, inside_pt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _arc( 120, 90, 520, 390, 520, 90, 120, 390 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _getarcinfo( &amp;start_pt, &amp;end_pt, &amp;inside_pt );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _moveto( start_pt.xcoord, start_pt.ycoord );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _lineto( end_pt.xcoord, end_pt.ycoord );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><IMG SRC="eg_getai.bmp" ALIGN=MIDDLE>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_getbkcolor"> _getbkcolor </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>long _FAR _getbkcolor( void );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _getbkcolor</TT> function returns the current background color.&nbsp; In text modes, the background color controls
the area behind each individual character.&nbsp; In graphics modes, the background refers to the entire screen.&nbsp; The
default background color is 0.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _getbkcolor</TT> function returns the current background color.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_setbkcolor">_setbkcolor</A>, <A HREF="#_remappalette">_remappalette</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><BR><TT>long colors[ 16 ] = {</TT>
<BR><TT>&nbsp;&nbsp; _BLACK, _BLUE, _GREEN, _CYAN,</TT>
<BR><TT>&nbsp;&nbsp; _RED, _MAGENTA, _BROWN, _WHITE,</TT>
<BR><TT>&nbsp;&nbsp; _GRAY, _LIGHTBLUE, _LIGHTGREEN, _LIGHTCYAN,</TT>
<BR><TT>&nbsp;&nbsp; _LIGHTRED, _LIGHTMAGENTA, _YELLOW, _BRIGHTWHITE</TT>
<BR><TT>};</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; long old_bk;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int bk;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; old_bk = _getbkcolor();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( bk = 0; bk &lt; 16; ++bk ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _setbkcolor( colors[ bk ] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setbkcolor( old_bk );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="getc"> getc, getwc </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>int getc( FILE *fp );</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>wint_t getwc( FILE *fp );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> getc</TT> function gets the next character from the file designated by<B> fp</B>.&nbsp; The character is returned
as an<TT> int</TT> value.&nbsp; The<TT> getc</TT> function is equivalent to <TT> fgetc</TT>, except that it may be implemented
as a macro.
<BR><BR>The<TT> getwc</TT> function is identical to<TT> getc</TT> except that it gets the next multibyte character (if present)
from the input stream pointed to by<B> fp</B> and converts it to a wide character.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> getc</TT> function returns the next character from the input stream pointed to by<B> fp</B>.&nbsp; If the stream is
at end-of-file, the end-of-file indicator is set and<TT> getc</TT> returns <TT> EOF</TT>.&nbsp; If a read error occurs, the
error indicator is set and<TT> getc</TT> returns <TT> EOF</TT>.
<BR><BR>The<TT> getwc</TT> function returns the next wide character from the input stream pointed to by<B> fp</B>.&nbsp; If
the stream is at end-of-file, the end-of-file indicator is set and<TT> getwc</TT> returns <TT> WEOF</TT>.&nbsp; If a read
error occurs, the error indicator is set and<TT> getwc</TT> returns <TT> WEOF</TT>.&nbsp; If an encoding error occurs, <TT>
errno</TT> is set to <TT> EILSEQ</TT> and<TT> getwc</TT> returns <TT> WEOF</TT>.
<BR><BR>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#fgetc">fgetc</A>, <A HREF="#fgetchar">fgetchar</A>, <A HREF="#fgets">fgets</A>, <A HREF="#fopen">fopen</A>, <A HREF="#getchar">getchar</A>,
<A HREF="#gets">gets</A>, <A HREF="#ungetc">ungetc</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FILE *fp;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int c;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; fp = fopen( &quot;file&quot;, &quot;r&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( fp != NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( (c = getc( fp )) != EOF )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; putchar(c);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( fp );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD><TT> getc - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>getwc - All, Linux</TT>
</DL>
<H2 ID="getch"> getch </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>int getch( void );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> getch</TT> function obtains the next available keystroke from the console.&nbsp; Nothing is echoed on the screen (the
function <TT> getche</TT> will echo the keystroke, if possible).&nbsp; When no keystroke is available, the function waits
until a key is depressed.
<BR><BR>The <TT> kbhit</TT> function can be used to determine if a keystroke is available.
</DL>
<DL>
<DT>Returns:
<DD>A value of <TT> EOF</TT> is returned when an error is detected; otherwise the<TT> getch</TT> function returns the value of
the keystroke (or character).
<BR><BR>When the keystroke represents an extended function key (for example, a function key, a cursor-movement key or the
ALT key with a letter or a digit), zero is returned and the next call to<TT> getch</TT> returns a value for the extended function.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#getche">getche</A>, <A HREF="#kbhit">kbhit</A>, <A HREF="#putch">putch</A>, <A HREF="#ungetch">ungetch</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int c;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Press any key\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; c = getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;You pressed %c(%d)\n&quot;, c, c );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="getchar"> getchar, getwchar </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>int getchar( void );</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>wint_t getwchar( void );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> getchar</TT> function is equivalent to <TT> getc</TT> with the argument <TT> stdin</TT>.
<BR><BR>The<TT> getwchar</TT> function is similar to<TT> getchar</TT> except that it is equivalent to <TT> getwc</TT> with
the argument <TT> stdin</TT>.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> getchar</TT> function returns the next character from the input stream pointed to by <TT> stdin</TT>.&nbsp; If the
stream is at end-of-file, the end-of-file indicator is set and<TT> getchar</TT> returns <TT> EOF</TT>.&nbsp; If a read error
occurs, the error indicator is set and<TT> getchar</TT> returns <TT> EOF</TT>.
<BR><BR>The<TT> getwchar</TT> function returns the next wide character from the input stream pointed to by <TT> stdin</TT>.
&nbsp;If the stream is at end-of-file, the end-of-file indicator is set and<TT> getwchar</TT> returns <TT> WEOF</TT>.&nbsp;
If a read error occurs, the error indicator is set and<TT> getwchar</TT> returns <TT> WEOF</TT>.&nbsp; If an encoding error
occurs, <TT> errno</TT> is set to <TT> EILSEQ</TT> and<TT> getwchar</TT> returns <TT> WEOF</TT>.
<BR><BR>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#fgetc">fgetc</A>, <A HREF="#fgetchar">fgetchar</A>, <A HREF="#fgets">fgets</A>, <A HREF="#fopen">fopen</A>, <A HREF="#getc">getc</A>,
<A HREF="#gets">gets</A>, <A HREF="#ungetc">ungetc</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FILE *fp;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int c;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; fp = freopen( &quot;file&quot;, &quot;r&quot;, stdin );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; while( (c = getchar()) != EOF )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; putchar(c);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fclose( fp );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD><TT> getchar - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>getwchar - All, Linux</TT>
</DL>
<H2 ID="getche"> getche </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>int getche( void );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> getche</TT> function obtains the next available keystroke from the console.&nbsp; The function will wait until a keystroke
is available.&nbsp; That character is echoed on the screen at the position of the cursor (use <TT> getch</TT> when it is not
desired to echo the keystroke).
<BR><BR>The <TT> kbhit</TT> function can be used to determine if a keystroke is available.
</DL>
<DL>
<DT>Returns:
<DD>A value of <TT> EOF</TT> is returned when an error is detected; otherwise, the<TT> getche</TT> function returns the value
of the keystroke (or character).
<BR><BR>When the keystroke represents an extended function key (for example, a function key, a cursor-movement key or the
ALT key with a letter or a digit), zero is returned and the next call to<TT> getche</TT> returns a value for the extended
function.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#getch">getch</A>, <A HREF="#kbhit">kbhit</A>, <A HREF="#putch">putch</A>, <A HREF="#ungetch">ungetch</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int c;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Press any key\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; c = getche();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;You pressed %c(%d)\n&quot;, c, c );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="_getcliprgn"> _getcliprgn </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>void _FAR _getcliprgn( short _FAR *x1, short _FAR *y1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; short _FAR *x2, short _FAR *y2 );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _getcliprgn</TT> function returns the location of the current clipping region.&nbsp; A clipping region is defined
with the <TT> _setcliprgn</TT> or <TT> _setviewport</TT> functions.&nbsp; By default, the clipping region is the entire screen.
<BR><BR>The current clipping region is a rectangular area of the screen to which graphics output is restricted.&nbsp; The
top left corner of the clipping region is placed in the arguments<TT> (x1,y1).</TT>&nbsp; The bottom right corner of the clipping
region is placed in<TT> (x2,y2).</TT>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _getcliprgn</TT> function returns the location of the current clipping region.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_setcliprgn">_setcliprgn</A>, <A HREF="#_setviewport">_setviewport</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; short x1, y1, x2, y2;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _getcliprgn( &amp;x1, &amp;y1, &amp;x2, &amp;y2 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setcliprgn( 130, 100, 510, 380 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _ellipse( _GBORDER, 120, 90, 520, 390 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setcliprgn( x1, y1, x2, y2 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="getcmd"> getcmd </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;process.h&gt;</TT>
<BR><TT>char *getcmd( char *cmd_line );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> getcmd</TT> function causes the command line information, with the program name removed, to be copied to<B> cmd_line</B>.
&nbsp;The information is terminated with a null character.&nbsp; This provides a method of obtaining the original parameters
to a program unchanged (with the white space intact).
<BR><BR>This information can also be obtained by examining the vector of program parameters passed to the main function in
the program.
</DL>
<DL>
<DT>Returns:
<DD>The address of the target<B> cmd_line</B> is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#abort">abort</A>, <A HREF="#atexit">atexit</A>, <A HREF="#_bgetcmd">_bgetcmd</A>, <A HREF="#exec___">exec...</A>,
<A HREF="#exit">exit</A>, <A HREF="#_Exit">_Exit</A>, <A HREF="#_exit">_exit</A>, <A HREF="#getenv">getenv</A>, <A HREF="#main">main</A>,
<A HREF="#onexit">onexit</A>, <A HREF="#putenv">putenv</A>, <A HREF="#spawn___">spawn...</A>, <A HREF="#system">system</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR>Suppose a program were invoked with the command line
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; myprog arg-1 ( my&nbsp;&nbsp; stuff ) here</TT>
<BR><BR>where that program contains
<BR><BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;process.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char cmds[128];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, getcmd( cmds ) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>&nbsp; arg-1 ( my&nbsp;&nbsp; stuff ) here</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="_getcolor"> _getcolor </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>short _FAR _getcolor( void );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _getcolor</TT> function returns the pixel value for the current color.&nbsp; This is the color used for displaying
graphics output.&nbsp; The default color value is one less than the maximum number of colors in the current video mode.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _getcolor</TT> function returns the pixel value for the current color.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_setcolor">_setcolor</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int col, old_col;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; old_col = _getcolor();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( col = 0; col &lt; 16; ++col ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _setcolor( col );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _rectangle( _GFILLINTERIOR, 100, 100, 540, 380 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setcolor( old_col );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_getcurrentposition"> _getcurrentposition, _getcurrentposition_w </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>struct xycoord _FAR _getcurrentposition( void );</TT>
<BR><BR><TT>struct _wxycoord _FAR _getcurrentposition_w( void );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _getcurrentposition</TT> functions return the current output position for graphics.&nbsp; The<TT> _getcurrentposition</TT>
function returns the point in view coordinates.&nbsp; The<TT> _getcurrentposition_w</TT> function returns the point in window
coordinates.
<BR><BR>The current position defaults to the origin,<TT> (0,0),</TT> when a new video mode is selected.&nbsp; It is changed
by successful calls to the <TT> _arc</TT>, <TT> _moveto</TT> and <TT> _lineto</TT> functions as well as the <TT> _setviewport</TT>
function.
<BR><BR>Note that the output position for graphics output differs from that for text output.&nbsp; The output position for
text output can be set by use of the <TT> _settextposition</TT> function.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _getcurrentposition</TT> functions return the current output position for graphics.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_moveto">_moveto</A>, <A HREF="#_settextposition">_settextposition</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct xycoord old_pos;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; old_pos = _getcurrentposition();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _moveto( 100, 100 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _lineto( 540, 100 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _lineto( 320, 380 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _lineto( 100, 100 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _moveto( old_pos.xcoord, old_pos.ycoord );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD><TT> _getcurrentposition - DOS</TT>
<BR><BR><TT>_getcurrentposition_w - DOS</TT>
</DL>
<H2 ID="getcwd"> getcwd, _wgetcwd </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;direct.h&gt;</TT>
<BR><TT>char *getcwd( char *buffer, size_t maxlen );</TT>
<BR><TT>wchar_t *_wgetcwd( wchar_t *buffer, size_t maxlen );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> getcwd</TT> function returns the name of the current working directory.&nbsp; The<B> buffer</B> address is either<TT>
NULL</TT> or is the location at which a string containing the name of the current working directory is placed.&nbsp; In the
latter case, the value of<B> maxlen</B> is the length in characters (including the terminating null character) which can be
be used to store this name.&nbsp; An error occurs if the length of the path (including the terminating null character) exceeds<B>
maxlen</B>.
<BR><BR>The maximum size that might be required for<B> buffer</B> is <TT> PATH_MAX</TT> + 1 bytes.
<BR><BR><B>Extension:</B>&nbsp; When<B> buffer</B> has a value of<TT> NULL,</TT> a string is allocated using <TT> malloc</TT>
to contain the name of the current working directory.&nbsp; This string may be freed using the <TT> free</TT> function.
<BR><BR>The<TT> _wgetcwd</TT> function is a wide-character version of<TT> getcwd</TT> that operates with wide-character strings.
&nbsp;The<B> maxlen</B> is the length in wide-characters (wchar_t).
</DL>
<DL>
<DT>Returns:
<DD>The<TT> getcwd</TT> function returns the address of the string containing the name of the current working directory, unless
an error occurs, in which case<TT> NULL</TT> is returned.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>EINVAL
<DD>The argument<B> maxlen</B> is negative.
<DT>ENOMEM
<DD>Not enough memory to allocate a buffer.
<DT>ERANGE
<DD>The buffer is too small (specified by<B> maxlen</B>) to contain the name of the current working directory.
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#chdir">chdir</A>, <A HREF="#chmod">chmod</A>, <A HREF="#_getdcwd">_getdcwd</A>, <A HREF="#mkdir">mkdir</A>, <A HREF="#rmdir">rmdir</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>#include &lt;direct.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char *cwd;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; cwd = getcwd( NULL, 0 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( cwd != NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;My working directory is %s\n&quot;, cwd );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; free( cwd );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>My working directory is C:\PROJECT\C</TT>
</DL>
<DL>
<DT>Classification:
<DD>POSIX 1003.1 with extensions
<BR><BR>_wgetcwd is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> getcwd - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_wgetcwd - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</TT>
</DL>
<H2 ID="_getdcwd"> _getdcwd, _wgetdcwd </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;direct.h&gt;</TT>
<BR><TT>char *_getdcwd( int drive, char *buffer, size_t maxlen );</TT>
<BR><TT>wchar_t *_wgetdcwd( int drive, wchar_t *buffer, size_t maxlen );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _getdcwd</TT> function gets the full path of the current working directory on the specified drive.&nbsp; The<B> drive</B>
argument specifies the drive (0 = default drive, 1 = A, 2 = B, etc.).&nbsp; The<B> buffer</B> address is either<TT> NULL</TT>
or is the location at which a string containing the name of the current working directory is placed.&nbsp; In the latter case,
the value of<B> maxlen</B> is the length in characters (including the terminating null character) which can be be used to
store this name.&nbsp; An error occurs if the length of the path (including the terminating null character) exceeds<B> maxlen</B>.
<BR><BR>The maximum size that might be required for<B> buffer</B> is <TT> PATH_MAX</TT> + 1 bytes.
<BR><BR>When<B> buffer</B> has a value of<TT> NULL,</TT> a string is allocated using <TT> malloc</TT> to contain the name
of the current working directory.&nbsp; This string may be freed using the <TT> free</TT> function.
<BR><BR>The<TT> _wgetdcwd</TT> function is a wide-character version of<TT> _getdcwd</TT> that operates with wide-character
strings.&nbsp; The<B> maxlen</B> is the length in wide-characters (wchar_t).
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _getdcwd</TT> function returns the address of the string containing the name of the current working directory on the
specified drive, unless an error occurs, in which case<TT> NULL</TT> is returned.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>ENODEV
<DD>The drive cannot be accessed.
<DT>ENOMEM
<DD>Not enough memory to allocate a buffer.
<DT>ERANGE
<DD>The buffer is too small (specified by<B> size</B>) to contain the name of the current working directory.
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#chdir">chdir</A>, <A HREF="#chmod">chmod</A>, <A HREF="#getcwd">getcwd</A>, <A HREF="#mkdir">mkdir</A>, <A HREF="#rmdir">rmdir</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>#include &lt;direct.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char *cwd;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; cwd = _getdcwd( 3, NULL, 0 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( cwd != NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;The current directory on drive C is %s\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cwd );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; free( cwd );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>The current directory on drive C is C:\PROJECT\C</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> _getdcwd - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
<BR><BR><TT>_wgetdcwd - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</TT>
</DL>
<H2 ID="getdelim"> getdelim </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>ssize_t getdelim( char **line, size_t *n, int delim, FILE *fp );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> getdelim</TT> function reads in text from a stream<B> fp</B> up to and including a delimiter<B> delim</B> and returns
the resulting text in a buffer pointed to by<B> line</B> when complete.&nbsp; The buffer pointed to by<B> line</B> should
be of the size pointed to by<B> n</B> initially.
<BR><BR>The buffer pointed to by<B> line</B> can initially be null and<B> n</B> should reflect the size of<B> line</B> and
be set to null.&nbsp; When<TT> getdelim</TT> is invoked, it will check if the buffer pointed to by<B> line</B> is allocated
and large enough.&nbsp; If not, it will first call<TT> realloc</TT> to resize the buffer appropriately and adjust the value
pointed to by<B> n</B> to reflect the new size of<B> line</B> after reallocation.&nbsp; If allocation fails, errno will be
set to ENOMEM.
</DL>
<DL>
<DT>Returns:
<DD>The function returns the number of characters read into the buffer or -1 on either error or if no further data is available.
</DL>
<DL>
<DT>Example:
<DD>
<BR>The following program would print out each line in a text file &quot;test.txt&quot; .
<BR><BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char *line;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; size_t n;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FILE *fp;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; fp = fopen(&quot;test.txt&quot;, &quot;r&quot;);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; while(getdelim(&amp;line, &amp;n, '\n', fp) &gt;= 0) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;&gt; %s&quot;, line);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fclose(fp);</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>POSIX
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="_getdiskfree"> _getdiskfree </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;direct.h&gt;</TT>
<BR><TT>unsigned _getdiskfree( unsigned drive,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; struct diskfree_t *diskspace );</TT>
<BR><TT>struct diskfree_t {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned short total_clusters;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned short avail_clusters;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned short sectors_per_cluster;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned short bytes_per_sector;</TT>
<BR><TT>};</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _getdiskfree</TT> function uses system call 0x36 to obtain useful information on the disk drive specified by<B> drive</B>.
&nbsp;Specify 0 for the default drive, 1 for drive A, 2 for drive B, etc.&nbsp; The information about the drive is returned
in the structure <TT> diskfree_t</TT> pointed to by<B> diskspace</B>.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _getdiskfree</TT> function returns zero if successful.&nbsp; Otherwise, it returns a non-zero value and sets <TT>
errno</TT> to <TT> EINVAL</TT> indicating an invalid drive was specified.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_dos_getdiskfree">_dos_getdiskfree</A>, <A HREF="#_dos_getdrive">_dos_getdrive</A>, <A HREF="#_dos_setdrive">_dos_setdrive</A>,
<A HREF="#_getdrive">_getdrive</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;direct.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct diskfree_t disk_data;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; /* get information about drive 3 (the C drive) */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( _getdiskfree( 3, &amp;disk_data ) == 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;total clusters: %u\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; disk_data.total_clusters );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;available clusters: %u\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; disk_data.avail_clusters );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;sectors/cluster: %u\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; disk_data.sectors_per_cluster );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;bytes per sector: %u\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; disk_data.bytes_per_sector );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Invalid drive specified\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>total clusters: 16335</TT>
<BR><TT>available clusters: 510</TT>
<BR><TT>sectors/cluster: 4</TT>
<BR><TT>bytes per sector: 512</TT>
</DL>
<DL>
<DT>Classification:
<DD>DOS
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS
</DL>
<H2 ID="_getdrive"> _getdrive </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;direct.h&gt;</TT>
<BR><TT>int _getdrive( void );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _getdrive</TT> function returns the current (default) drive number.
</DL>
<DL>
<DT>Returns:
<DD>A value of 1 is drive A, 2 is drive B, 3 is drive C, etc.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_dos_getdiskfree">_dos_getdiskfree</A>, <A HREF="#_dos_getdrive">_dos_getdrive</A>, <A HREF="#_dos_setdrive">_dos_setdrive</A>,
<A HREF="#_getdiskfree">_getdiskfree</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;direct.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;The current drive is %c\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'A' + _getdrive() - 1 );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>The current drive is C</TT>
</DL>
<DL>
<DT>Classification:
<DD>DOS
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS
</DL>
<H2 ID="getegid"> getegid </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;unistd.h&gt;</TT>
<BR><TT>gid_t getegid( void );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> getegid</TT> function returns the efective group ID for the current process.
</DL>
<DL>
<DT>Returns:
<DD>The efective group ID for the current process.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#getgid">getgid</A>, <A HREF="#getuid">getuid</A>, <A HREF="#geteuid">geteuid</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>/*</TT>
<BR><TT> * Print the effective group ID of the process.</TT>
<BR><TT> */</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;unistd.h&gt;</TT>
<BR><BR><TT>int main( void )</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;My effective group ID is %d\n&quot;, getegid() );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; return( 0 );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>POSIX 1003.1
</DL>
<DL>
<DT>Systems:
<DD>Linux
</DL>
<H2 ID="getenv"> getenv, _wgetenv </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>char *getenv( const char *name );</TT>
<BR><TT>wchar_t *_wgetenv( const wchar_t *name );</TT>
</DL>
<DL>
<DT>Safer C:
<DD>The Safer C Library extension provides the <A HREF="#getenv_s">getenv_s</A> function which is a safer alternative to<TT> getenv</TT>
This newer<TT> getenv_s</TT> function is recommended to be used instead of the traditional &quot;unsafe&quot;<TT> getenv</TT>
function.
</DL>
<DL>
<DT>Description:
<DD>The<TT> getenv</TT> function searches the environment list for an entry matching the string pointed to by<B> name</B>.&nbsp;
The matching is case-insensitive; all lowercase letters are treated as if they were in upper case.
<BR><BR>Entries can be added to the environment list with the DOS<TT> set</TT> command or with the <TT> putenv</TT> or <TT>
setenv</TT> functions.&nbsp; All entries in the environment list can be displayed by using the DOS<TT> set</TT> command with
no arguments.
<BR><BR>To assign a string to a variable and place it in the environment list:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C&gt;SET INCLUDE=C:\WATCOM\H</TT>
<BR><BR>To see what variables are in the environment list, and their current assignments:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C&gt;SET</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; COMSPEC=C:\COMMAND.COM</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PATH=C:\;C:\WATCOM</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INCLUDE=C:\WATCOM\H</TT>
<BR><BR>The<TT> _wgetenv</TT> function is a wide-character version of<TT> getenv</TT> that operates with wide-character strings.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> getenv</TT> function returns a pointer to the string assigned to the environment variable if found, and NULL if no
match was found.&nbsp; Note:&nbsp; the value returned should be duplicated if you intend to modify the contents of the string.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#clearenv">clearenv</A>, <A HREF="#exec___">exec...</A>, <A HREF="#getenv_s">getenv_s</A>, <A HREF="#putenv">putenv</A>,
<A HREF="#_searchenv">_searchenv</A>, <A HREF="#setenv">setenv</A>, <A HREF="#spawn___">spawn...</A>, <A HREF="#system">system</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char *path;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; path = getenv( &quot;INCLUDE&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( path != NULL )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;INCLUDE=%s\n&quot;, path );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>_wgetenv is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> getenv - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_wgetenv - All, Linux</TT>
</DL>
<H2 ID="getenv_s"> getenv_s </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__ 1</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>errno_t getenv_s( size_t * restrict len,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char * restrict
value,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rsize_t maxsize,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char
* restrict name );</TT>
</DL>
<DL>
<DT>Constraints:
<DD>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<TT>
getenv_s</TT> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<BR><BR><B>name</B> shall not be a null pointer.<B>&nbsp; maxsize</B> shall neither be equal to zero nor be greater than <TT>
RSIZE_MAX</TT>.&nbsp; If<B> maxsize</B> is not equal to zero, then<B> value</B> shall not be a null pointer.
<BR><BR>If there is a runtime-constraint violation, the integer pointed to by<B> len</B> (if<B> len</B> is not null) is set
to zero, and the environment list is not searched.
</DL>
<DL>
<DT>Description:
<DD>The<TT> getenv_s</TT> function searches the environment list for an entry matching the string pointed to by<B> name</B>.
<BR><BR>If that entry is found,<TT> getenv_s</TT> performs the following actions.&nbsp; If<B> len</B> is not a null pointer,
the length of the string associated with the matched entry is stored in the integer pointed to by<B> len</B>.&nbsp; If the
length of the associated string is less than<B> maxsize</B>, then the associated string is copied to the array pointed to
by<B> value</B>.
<BR><BR>If that entry is not found,<TT> getenv_s</TT> performs the following actions.&nbsp; If<B> len</B> is not a null pointer,
zero is stored in the integer pointed to by<B> len</B>.&nbsp; If<B> maxsize</B> is greater than zero, then<B> value[0]</B>
is set to the null character.
<BR><BR>The matching is case-insensitive; all lowercase letters are treated as if they were in upper case.
<BR><BR>Entries can be added to the environment list with the DOS<TT> set</TT> command or with the <TT> putenv</TT> or <TT>
setenv</TT> functions.&nbsp; All entries in the environment list can be displayed by using the DOS<TT> set</TT> command with
no arguments.
<BR><BR>To assign a string to a variable and place it in the environment list:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C&gt;SET INCLUDE=C:\WATCOM\H</TT>
<BR><BR>To see what variables are in the environment list, and their current assignments:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C&gt;SET</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; COMSPEC=C:\COMMAND.COM</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PATH=C:\;C:\WATCOM</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INCLUDE=C:\WATCOM\H</TT>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> getenv_s</TT> function returns zero if the environment string specified by<B> name</B> was found and successfully
stored in the buffer pointed to by<B> value</B>.&nbsp; Otherwise, a non-zero value is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#clearenv">clearenv</A>, <A HREF="#exec___">exec...</A>, <A HREF="#getenv">getenv</A>, <A HREF="#putenv">putenv</A>,
<A HREF="#_searchenv">_searchenv</A>, <A HREF="#setenv">setenv</A>, <A HREF="#spawn___">spawn...</A>, <A HREF="#system">system</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__ 1</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; buffer[128];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; size_t&nbsp; len;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; if( getenv_s( &amp;len, buffer, sizeof( buffer ), &quot;INCLUDE&quot; ) == 0 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;INCLUDE=%s\n&quot;, buffer );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>TR 24731
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="geteuid"> geteuid </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;unistd.h&gt;</TT>
<BR><TT>uid_t geteuid( void );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> geteuid</TT> function returns the efective user ID for the calling process.
</DL>
<DL>
<DT>Returns:
<DD>The efective user ID for the calling process
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#getuid">getuid</A>, <A HREF="#getgid">getgid</A>, <A HREF="#getegid">getegid</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>/*</TT>
<BR><TT> * Print the effective user ID of the process.</TT>
<BR><TT> */</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;unistd.h&gt;</TT>
<BR><BR><TT>int main( void )</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;My effective user ID is %d\n&quot;, geteuid() );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; return( 0 );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>POSIX 1003.1
</DL>
<DL>
<DT>Systems:
<DD>Linux
</DL>
<H2 ID="_getfillmask"> _getfillmask </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>unsigned char _FAR * _FAR</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _getfillmask( unsigned char _FAR *mask );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _getfillmask</TT> function copies the current fill mask into the area located by the argument<B> mask</B>.&nbsp; The
fill mask is used by the <TT> _ellipse</TT>, <TT> _floodfill</TT>, <TT> _pie</TT>, <TT> _polygon</TT> and <TT> _rectangle</TT>
functions that fill an area of the screen.
<BR><BR>The fill mask is an eight-byte array which is interpreted as a square pattern (8 by 8) of 64 bits.&nbsp; Each bit
in the mask corresponds to a pixel.&nbsp; When a region is filled, each point in the region is mapped onto the fill mask.
&nbsp;When a bit from the mask is one, the pixel value of the corresponding point is set using the current plotting action
with the current color; when the bit is zero, the pixel value of that point is not affected.
<BR><BR>When the fill mask is not set, a fill operation will set all points in the fill region to have a pixel value of the
current color.
</DL>
<DL>
<DT>Returns:
<DD>If no fill mask has been set,<TT> NULL</TT> is returned; otherwise, the<TT> _getfillmask</TT> function returns<B> mask</B>.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_floodfill">_floodfill</A>, <A HREF="#_setfillmask">_setfillmask</A>, <A HREF="#_setplotaction">_setplotaction</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><BR><TT>char old_mask[ 8 ];</TT>
<BR><TT>char new_mask[ 8 ] = { 0x81, 0x42, 0x24, 0x18,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; 0x18, 0x24, 0x42, 0x81 };</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _getfillmask( old_mask );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setfillmask( new_mask );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _rectangle( _GFILLINTERIOR, 100, 100, 540, 380 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setfillmask( old_mask );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_getfontinfo"> _getfontinfo </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>short _FAR _getfontinfo( struct _fontinfo _FAR *info );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _getfontinfo</TT> function returns information about the currently selected font.&nbsp; Fonts are selected with the
<TT> _setfont</TT> function.&nbsp; The font information is returned in the<TT> _fontinfo</TT> structure indicated by the argument<B>
info</B>.&nbsp; The structure contains the following fields:
<DL>
<DT>type
<DD>1 for a vector font, 0 for a bit-mapped font
<DT>ascent
<DD>distance from top of character to baseline in pixels
<DT>pixwidth
<DD>character width in pixels (0 for a proportional font)
<DT>pixheight
<DD>character height in pixels
<DT>avgwidth
<DD>average character width in pixels
<DT>filename
<DD>name of the file containing the current font
<DT>facename
<DD>name of the current font
</DL>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _getfontinfo</TT> function returns zero if the font information is returned successfully; otherwise a negative value
is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_registerfonts">_registerfonts</A>, <A HREF="#_unregisterfonts">_unregisterfonts</A>, <A HREF="#_setfont">_setfont</A>,
<A HREF="#_outgtext">_outgtext</A>, <A HREF="#_getgtextextent">_getgtextextent</A>, <A HREF="#_setgtextvector">_setgtextvector</A>,
<A HREF="#_getgtextvector">_getgtextvector</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int width;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct _fontinfo info;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _getfontinfo( &amp;info );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _moveto( 100, 100 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _outgtext( &quot;WATCOM Graphics&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; width = _getgtextextent( &quot;WATCOM Graphics&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _rectangle( _GBORDER, 100, 100,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 100 + width, 100 + info.pixheight
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="getgid"> getgid </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;unistd.h&gt;</TT>
<BR><TT>gid_t getgid( void );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> getgid</TT> function returns the group ID for the current process.
</DL>
<DL>
<DT>Returns:
<DD>The group ID for the current process.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#getuid">getuid</A>, <A HREF="#geteuid">geteuid</A>, <A HREF="#getegid">getegid</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>/*</TT>
<BR><TT> * Print the group ID of the process.</TT>
<BR><TT> */</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;unistd.h&gt;</TT>
<BR><BR><TT>int main( void )</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;I belong to group ID %d\n&quot;, getgid() );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; return( 0 );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>POSIX 1003.1
</DL>
<DL>
<DT>Systems:
<DD>Linux
</DL>
<H2 ID="_getgtextextent"> _getgtextextent </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>short _FAR _getgtextextent( char _FAR *text );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _getgtextextent</TT> function returns the length in pixels of the argument<B> text</B> as it would be displayed in
the current font by the function <TT> _outgtext</TT>.&nbsp; Note that the text is not displayed on the screen, only its length
is determined.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _getgtextextent</TT> function returns the length in pixels of a string.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_registerfonts">_registerfonts</A>, <A HREF="#_unregisterfonts">_unregisterfonts</A>, <A HREF="#_setfont">_setfont</A>,
<A HREF="#_getfontinfo">_getfontinfo</A>, <A HREF="#_outgtext">_outgtext</A>, <A HREF="#_setgtextvector">_setgtextvector</A>,
<A HREF="#_getgtextvector">_getgtextvector</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int width;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct _fontinfo info;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _getfontinfo( &amp;info );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _moveto( 100, 100 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _outgtext( &quot;WATCOM Graphics&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; width = _getgtextextent( &quot;WATCOM Graphics&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _rectangle( _GBORDER, 100, 100,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 100 + width, 100 + info.pixheight
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_getgtextvector"> _getgtextvector </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>struct xycoord _FAR _getgtextvector( void );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _getgtextvector</TT> function returns the current value of the text orientation vector.&nbsp; This is the direction
used when text is displayed by the <TT> _outgtext</TT> function.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _getgtextvector</TT> function returns, as an<TT> xycoord</TT> structure, the current value of the text orientation
vector.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_registerfonts">_registerfonts</A>, <A HREF="#_unregisterfonts">_unregisterfonts</A>, <A HREF="#_setfont">_setfont</A>,
<A HREF="#_getfontinfo">_getfontinfo</A>, <A HREF="#_outgtext">_outgtext</A>, <A HREF="#_getgtextextent">_getgtextextent</A>,
<A HREF="#_setgtextvector">_setgtextvector</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct xycoord old_vec;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; old_vec = _getgtextvector();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setgtextvector( 0, -1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _moveto( 100, 100 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _outgtext( &quot;WATCOM Graphics&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setgtextvector( old_vec.xcoord, old_vec.ycoord );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="gethostbyname"> gethostbyname </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;netdb.h&gt;</TT>
<BR><TT>struct hostent *gethostbyname( const char *name );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> gethostbyname</TT> function determines the address or addresses of a host specified by the<B> name</B> argument.&nbsp;
The routine will query the local database initially.&nbsp; If not found, the routine will perform a DNS query, returning all
&quot;A&quot; records for the given host name.
<BR><BR>The structure returned is defined as:
<BR><BR><TT>struct hostent {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *h_name;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*
host official name */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; **h_aliases;&nbsp;&nbsp; /* host alternate names,
up to 16,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * terminated by a NULL pointer</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; h_addrtype;&nbsp;&nbsp;&nbsp; /* address type
*/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; h_length;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*
address length in bytes */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char **&nbsp;&nbsp;&nbsp;&nbsp; **h_addr_list; /* array of pointers to network</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * addresses in network byte</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * order, terminated by a NULL</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * pointer</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>};</TT>
<BR>In the current Open Watcom implementation, this routine will only ever return IPv4 addresses, and all addresses will be
of <TT> AF_INET</TT> address type.
<BR><BR>The pointer returned by<TT> gethostbyname</TT> points to a private location, and the user should free neither the
pointer itself nor any of its constituent structure members.&nbsp; Subsequent calls to this function may result in the values
changing.
<BR><BR>This function is not thread-safe.&nbsp; Other calls to this function or to other functions accessing the hostname
database may affect the return value from this function.
</DL>
<DL>
<DT>Returns:
<DD>If a matching host is found, the return value will be non-NULL.&nbsp; The returned pointer should not be freed by the calling
routine.
<BR><BR>If the host is found, the <TT> h_name</TT> member will be a copy of the<B> name</B> argument.&nbsp; The addresses
are contained in the <TT> h_addr_list</TT> member as a NULL-terminated list, and this structure entry will never be NULL.
<BR><BR>If no matching host is found or an error occurs, the return value will be NULL.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#gethostent">gethostent</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR>The following program will attempt to determine the address of a hostname passed as an argument.
<BR><BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;netdb.h&gt;</TT>
<BR><TT>#include &lt;arpa/inet.h&gt;</TT>
<BR><BR><TT>int main(int argc, char *argv[])</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int i;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct hostent *he;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct in_addr **addr_list;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; if (argc != 2) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(stderr,&quot;usage: %s &lt;hostname&gt;\n&quot;, argv[0]);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; if ((he = gethostbyname(argv[1])) == NULL) {&nbsp; // get the host info</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;Failed to find %s\n&quot;, argv[1]);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 2;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; printf(&quot;IP addresses for %s:\n&quot;, argv[1]);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; addr_list = (struct in_addr **)he-&gt;h_addr_list;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for(i = 0; addr_list[i] != NULL; i++) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;&nbsp;&nbsp;&nbsp; %s\n&quot;, inet_ntoa(*addr_list[i]));</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; return 0;</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>POSIX
</DL>
<DL>
<DT>Systems:
<DD>Linux
</DL>
<H2 ID="gethostent"> gethostent </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;netdb.h&gt;</TT>
<BR><TT>struct hostent *gethostent( void );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> gethostent</TT> function reads, parses, and returns entries from the network host database at /etc/hosts.&nbsp; The
first call will return the first entry, and subsequent calls return subsequent entries.&nbsp; A null pointer is returned if
either an error is encountered or no further entries exist.
<BR><BR>If a call to <TT> sethostent</TT> was not first made, the<TT> gethostent</TT> function will open the database if necessary
initially.&nbsp; By default, this will always return the first entry in the database.
<BR><BR>The structure returned is defined as:
<BR><BR><TT>struct hostent {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *h_name;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*
host official name */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; **h_aliases;&nbsp;&nbsp; /* host alternate names,
up to 16,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * terminated by a NULL pointer</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; h_addrtype;&nbsp;&nbsp;&nbsp; /* address type
*/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; h_length;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*
address length in bytes */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char **&nbsp;&nbsp;&nbsp;&nbsp; **h_addr_list; /* array of pointers to network</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * addresses in network byte</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * order, terminated by a NULL</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * pointer</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>};</TT>
<BR>In the current Open Watcom implementation, this routine will only ever return IPv4 addresses, and all addresses will be
of <TT> AF_INET</TT> address type.
<BR><BR>The pointer returned by<TT> gethostent</TT> points to a static location, and the user should free neither the pointer
itself nor any of its consituent structure members.
<BR><BR>This function is not thread-safe.&nbsp; Other calls to functions accessing the hostname database may affect the return
value from this function.
</DL>
<DL>
<DT>Returns:
<DD>A parsed host database entry, or NULL if no further entries exist or an error occurred.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#sethostent">sethostent</A>, <A HREF="#endhostent">endhostent</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR>The following program will print out each user and their user ID in the system's password database
<BR><BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;netdb.h&gt;</TT>
<BR><TT>#include &lt;arpa/inet.h&gt;</TT>
<BR><BR><TT>int main(int argc, char *argv[])</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp; struct hostent *e;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; sethostent(1);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; e = gethostent();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; while(e != NULL) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *ia = e-&gt;h_addr_list[0];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;%s - %d.%d.%d.%d\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e-&gt;h_name,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ia[0],ia[1],ia[2],ia[3]</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e = gethostent();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; endhostent();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; return 0;</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>POSIX
</DL>
<DL>
<DT>Systems:
<DD>Linux
</DL>
<H2 ID="_getimage"> _getimage, _getimage_w, _getimage_wxy </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>void _FAR _getimage( short x1, short y1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;short x2, short y2,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;char _HUGE *image );</TT>
<BR><BR><TT>void _FAR _getimage_w( double x1, double y1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; double x2, double y2,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; char _HUGE *image );</TT>
<BR><BR><TT>void _FAR _getimage_wxy( struct _wxycoord _FAR *p1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; struct _wxycoord _FAR *p2,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; char _HUGE *image );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _getimage</TT> functions store a copy of an area of the screen into the buffer indicated by the<B> image</B> argument.
&nbsp;The<TT> _getimage</TT> function uses the view coordinate system.&nbsp; The<TT> _getimage_w</TT> and<TT> _getimage_wxy</TT>
functions use the window coordinate system.
<BR><BR>The screen image is the rectangular area defined by the points<TT> (x1,y1)</TT> and<TT> (x2,y2).</TT>&nbsp; The buffer<B>
image</B> must be large enough to contain the image (the size of the image can be determined by using the <TT> _imagesize</TT>
function).&nbsp; The image may be displayed upon the screen at some later time by using the <TT> _putimage</TT> functions.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _getimage</TT> functions do not return a value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_imagesize">_imagesize</A>, <A HREF="#_putimage">_putimage</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>#include &lt;malloc.h&gt;</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char *buf;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int y;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _ellipse( _GFILLINTERIOR, 100, 100, 200, 200 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; buf = (char*) malloc(</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _imagesize(
100, 100, 201, 201 ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( buf != NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _getimage( 100, 100, 201, 201, buf );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _putimage( 260, 200, buf, _GPSET );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _putimage( 420, 100, buf, _GPSET );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( y = 100; y &lt; 300; ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _putimage( 420, y, buf, _GXOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y += 20;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _putimage( 420, y, buf, _GXOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; free( buf );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD><TT> _getimage - DOS</TT>
<BR><BR><TT>_getimage_w - DOS</TT>
<BR><TT>_getimage_wxy - DOS</TT>
</DL>
<H2 ID="getline"> getline </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>ssize_t getline( char **line, size_t *n, FILE *fp );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> getline</TT> function reads a single line of text from a stream<B> fp</B> and returns the resulting text, including
any new line characters, in a buffer pointed to by<B> line</B> when complete.&nbsp; The buffer pointed to by<B> line</B> should
be of the size pointed to by<B> n</B> initially.
<BR><BR>The buffer pointed to by<B> line</B> can initially be null and<B> n</B> should reflect the size of<B> line</B> and
be set to 0.&nbsp; When<TT> getline</TT> is invoked, it will check if the buffer pointed to by<B> line</B> is allocated and
large enough.&nbsp; If not, it will first call<TT> realloc</TT> to resize the buffer appropriately and adjust the value pointed
to by<B> n</B> to reflect the new size of<B> line</B> after reallocation.&nbsp; If allocation fails, errno will be set to
ENOMEM.
</DL>
<DL>
<DT>Returns:
<DD>The function returns the number of characters read into the buffer or -1 on either error or if no further data is available.
</DL>
<DL>
<DT>Example:
<DD>
<BR>The following program would print out each line in a text file &quot;test.txt&quot;
<BR><BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char *line;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; size_t n;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FILE *fp;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; fp = fopen(&quot;test.txt&quot;, &quot;r&quot;);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; while(getline(&amp;line, &amp;n, fp) &gt;= 0) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;&gt; %s&quot;, line);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fclose(fp);</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>POSIX
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="_getlinestyle"> _getlinestyle </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>unsigned short _FAR _getlinestyle( void );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _getlinestyle</TT> function returns the current line-style mask.
<BR><BR>The line-style mask determines the style by which lines and arcs are drawn.&nbsp; The mask is treated as an array
of 16 bits.&nbsp; As a line is drawn, a pixel at a time, the bits in this array are cyclically tested.&nbsp; When a bit in
the array is 1, the pixel value for the current point is set using the current color according to the current plotting action;
otherwise, the pixel value for the point is left unchanged.&nbsp; A solid line would result from a value of<TT> 0xFFFF</TT>
and a dashed line would result from a value of<TT> 0xF0F0</TT>
<BR><BR>The default line style mask is<TT> 0xFFFF</TT>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _getlinestyle</TT> function returns the current line-style mask.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_lineto">_lineto</A>, <A HREF="#_pie">_pie</A>, <A HREF="#_rectangle">_rectangle</A>, <A HREF="#_polygon">_polygon</A>,
<A HREF="#_setlinestyle">_setlinestyle</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><BR><TT>#define DASHED 0xf0f0</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned old_style;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; old_style = _getlinestyle();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setlinestyle( DASHED );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _rectangle( _GBORDER, 100, 100, 540, 380 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setlinestyle( old_style );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_getmbcp"> _getmbcp </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><TT>int _getmbcp( void );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _getmbcp</TT> function returns the current multibyte code page number.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _getmbcp</TT> function returns the current multibyte code page.&nbsp; A return value of zero indicates that a single
byte code page is in use.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_mbbtombc">_mbbtombc</A>, <A HREF="#_mbcjistojms">_mbcjistojms</A>, <A HREF="#_mbcjmstojis">_mbcjmstojis</A>, <A HREF="#_mbctombb">_mbctombb</A>,
<A HREF="#_ismbbalnum">_ismbbalnum</A>, <A HREF="#_ismbbalpha">_ismbbalpha</A>, <A HREF="#_ismbbgraph">_ismbbgraph</A>, <A HREF="#_ismbbkalnum">_ismbbkalnum</A>,
<A HREF="#_ismbbkalpha">_ismbbkalpha</A>, <A HREF="#_ismbbkana">_ismbbkana</A>, <A HREF="#_ismbbkprint">_ismbbkprint</A>,
<A HREF="#_ismbbkpunct">_ismbbkpunct</A>, <A HREF="#_ismbblead">_ismbblead</A>, <A HREF="#_ismbbprint">_ismbbprint</A>, <A HREF="#_ismbbpunct">_ismbbpunct</A>,
<A HREF="#_ismbbtrail">_ismbbtrail</A>, <A HREF="#_mbbtombc">_mbbtombc</A>, <A HREF="#_mbcjistojms">_mbcjistojms</A>, <A HREF="#_mbcjmstojis">_mbcjmstojis</A>,
<A HREF="#_mbctombb">_mbctombb</A>, <A HREF="#_mbbtype">_mbbtype</A>, <A HREF="#_setmbcp">_setmbcp</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, _setmbcp( 932 ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, _getmbcp() );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>0</TT>
<BR><TT>932</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS
</DL>
<H2 ID="getnetbyaddr"> getnetbyaddr </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;netdb.h&gt;</TT>
<BR><TT>struct netent *getnetbyaddr( in_addr_t net, int type );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> getnetbyaddr</TT> function searches the network database for a network with a matching address type, specified by<B>
type</B> as <TT> AF_INET</TT> , <TT> AF_INET6</TT> , etc., and address matching the<B> net</B> argument.&nbsp; The function
returns information about said network if a match is found.&nbsp; The routine will query the local database only.
<BR><BR>The structure returned is defined as:
<BR><BR><TT>struct netent {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp; *n_name;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* official network name
*/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp; **n_aliases;&nbsp;&nbsp; /* alias list */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n_addrtype;&nbsp;&nbsp;&nbsp; /* address type */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; uint32_t n_net;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* network number */</TT>
<BR><TT>};</TT>
<BR>The pointer returned by<TT> getnetbyaddr</TT> points to a private location, and the user should free neither the pointer
itself nor any of its constituent structure members.&nbsp; Subsequent calls to this function may result in the values changing.
<BR><BR>This function is not thread-safe.&nbsp; Other calls to this function or to other functions accessing the hostname
database may affect the return value from this function.
</DL>
<DL>
<DT>Returns:
<DD>If a matching host is found, the return value will be non-NULL.&nbsp; The returned pointer should not be freed by the calling
routine.
<BR><BR>The alias names of said network are contained in the <TT> n_aliases</TT> member as a NULL-terminated list, and this
structure entry will never be NULL.
<BR><BR>If no matching host is found or an error occurs, the return value will be NULL.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#getnetent">getnetent</A>, <A HREF="#getnetbyname">getnetbyname</A>
</DL>
<DL>
<DT>Classification:
<DD>POSIX
</DL>
<DL>
<DT>Systems:
<DD>Linux
</DL>
<H2 ID="getnetbyname"> getnetbyname </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;netdb.h&gt;</TT>
<BR><TT>struct netent *getnetbyname( const char *name );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> getnetbyname</TT> function searches the network database for a network<B> name</B> and returns information about said
network if a match is found.&nbsp; The routine will query the local database only.
<BR><BR>The structure returned is defined as:
<BR><BR><TT>struct netent {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp; *n_name;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* official network name
*/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp; **n_aliases;&nbsp;&nbsp; /* alias list */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n_addrtype;&nbsp;&nbsp;&nbsp; /* address type */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; uint32_t n_net;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* network number */</TT>
<BR><TT>};</TT>
<BR>The pointer returned by<TT> getnetbyname</TT> points to a private location, and the user should free neither the pointer
itself nor any of its constituent structure members.&nbsp; Subsequent calls to this function may result in the values changing.
<BR><BR>This function is not thread-safe.&nbsp; Other calls to this function or to other functions accessing the hostname
database may affect the return value from this function.
</DL>
<DL>
<DT>Returns:
<DD>If a matching host is found, the return value will be non-NULL.&nbsp; The returned pointer should not be freed by the calling
routine.
<BR><BR>The addresses are contained in the <TT> n_aliases</TT> member as a NULL-terminated list, and this structure entry
will never be NULL.
<BR><BR>If no matching host is found or an error occurs, the return value will be NULL.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#getnetent">getnetent</A>, <A HREF="#getnetbyaddr">getnetbyaddr</A>
</DL>
<DL>
<DT>Classification:
<DD>POSIX
</DL>
<DL>
<DT>Systems:
<DD>Linux
</DL>
<H2 ID="getnetent"> getnetent </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;netdb.h&gt;</TT>
<BR><TT>struct netent *getnetent( void );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> getnetent</TT> function retrieves the next entry in the network database.&nbsp; If not proceeded by an appropriate
call to <TT> setnetent</TT> , the function will always return the first network in the database.&nbsp; The routine will query
the local database only.
<BR><BR>The structure returned is defined as:
<BR><BR><TT>struct netent {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp; *n_name;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* official network name
*/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp; **n_aliases;&nbsp;&nbsp; /* alias list */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n_addrtype;&nbsp;&nbsp;&nbsp; /* address type */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; uint32_t n_net;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* network number */</TT>
<BR><TT>};</TT>
<BR>The pointer returned by<TT> getnetent</TT> points to a private location, and the user should free neither the pointer
itself nor any of its constituent structure members.&nbsp; Subsequent calls to this function may result in the values changing.
<BR><BR>This function is not thread-safe.&nbsp; Other calls to this function or to other functions accessing the hostname
database may affect the return value from this function.
</DL>
<DL>
<DT>Returns:
<DD>If the database contains more entries, the return value will be non-NULL.&nbsp; The returned pointer should not be freed by
the calling routine.
<BR><BR>The alias names of said network are contained in the <TT> n_aliases</TT> member as a NULL-terminated list, and this
structure entry will never be NULL.
<BR><BR>If no additional network is found or an error occurs, the return value will be NULL.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#setnetent">setnetent</A>, <A HREF="#endnetent">endnetent</A>, <A HREF="#getnetbyname">getnetbyname</A>, <A HREF="#getnetbyaddr">getnetbyaddr</A>
</DL>
<DL>
<DT>Classification:
<DD>POSIX
</DL>
<DL>
<DT>Systems:
<DD>Linux
</DL>
<H2 ID="getopt"> getopt </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;unistd.h&gt;</TT>
<BR><TT>int getopt( int argc, char * const argv[],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *optstring );</TT>
<BR><BR><TT>char&nbsp;&nbsp; *optarg;</TT>
<BR><TT>int&nbsp;&nbsp;&nbsp; optind, opterr, optopt;</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> getopt</TT> function is a command-line parser that can be used by applications that follow Utility Syntax Guidelines
3, 4, 5, 6, 7, 9 and 10 in the Base Definitions volume of IEEE Std 1003.1-2001, Section 12.2, Utility Syntax Guidelines.
<BR><BR>The parameters<B> argc</B> and<B> argv</B> are the argument count and argument array as passed to <TT> main</TT>.
&nbsp;The argument<B> optstring</B> is a string of recognised option characters; if a character is followed by a colon, the
option takes an argument.&nbsp; All option characters allowed by Utility Syntax Guideline 3 are allowed in<B> optstring</B>.
<BR><BR>The global variable <TT> optind</TT> is the index of the next element of the<B> argv[]</B> vector to be processed.
&nbsp;It is initialised to 1 by the system, and getopt updates it when it finishes with each element of<B> argv[]</B>.&nbsp;
When an element of<B> argv[]</B> contains multiple option characters,<TT> getopt</TT> uses a static variable to determine
which options have already been processed.
<BR><BR>The<TT> getopt</TT> function returns the next option character (if one is found) from<B> argv</B> that matches a character
in<B> optstring</B>, if there is one that matches.&nbsp; If the option takes an argument,<TT> getopt</TT> sets the variable
<TT> optarg</TT> to point to the option-argument as follows:
<BR><BR>If the option was the last character in the string pointed to by an element of<B> argv</B>, then <TT> optarg</TT>
contains the next element of<B> argv</B>, and <TT> optind</TT> is incremented by 2.&nbsp; If the resulting value of <TT> optind</TT>
is not less than<B> argc</B>, this indicates a missing option-argument, and<TT> getopt</TT> returns an error indication.
<BR><BR>Otherwise, <TT> optarg</TT> points to the string following the option character in that element of<B> argv</B>, and
<TT> optind</TT> is incremented by 1.
<BR><BR>If, when<TT> getopt</TT> is called:
<UL>
<LI><B> argv[optind]</B> is a null pointer
<LI><B> *argv[optind]</B> is not the character '-'
<LI><B> argv[optind]</B> points to the string &quot;-&quot;
</UL>
<BR><TT>getopt</TT> returns -1 without changing <TT> optind</TT>.&nbsp; If<B> argv[optind]</B> points to the string &quot;--&quot;,<TT>
getopt</TT> returns -1 after incrementing <TT> optind</TT>.
<BR><BR>If<TT> getopt</TT> encounters an option character that is not contained in<B> optstring</B>, it returns the question-mark
(?) character.&nbsp; If it detects a missing option-argument, it returns the colon character (:) if the first character of<B>
optstring</B> was a colon, or a question-mark character (?) otherwise.&nbsp; In either case, getopt will set the global variable
<TT> optopt</TT> to the option character that caused the error.&nbsp; If the application has not set the global variable <TT>
opterr</TT> to 0 and the first character of<B> optstring</B> is not a colon,<TT> getopt</TT> also prints a diagnostic message
to <TT> stderr</TT>.
<BR><BR>The<TT> getopt</TT> function is not re-entrant and hence not thread-safe.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> getopt</TT> function returns the next option character specified on the command line.
<BR><BR>A colon (:) is returned if<TT> getopt</TT> detects a missing argument and the first character of<B> optstring</B>
was a colon (:).
<BR><BR>A question mark (?) is returned if<TT> getopt</TT> encounters an option character not in<B> optstring</B> or detects
a missing argument and the first character of<B> optstring</B> was not a colon (:).
<BR><BR>Otherwise,<TT> getopt</TT> returns -1 when all command line options are parsed.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#abort">abort</A>, <A HREF="#atexit">atexit</A>, <A HREF="#_bgetcmd">_bgetcmd</A>, <A HREF="#exec___">exec...</A>,
<A HREF="#exit">exit</A>, <A HREF="#_Exit">_Exit</A>, <A HREF="#_exit">_exit</A>, <A HREF="#getcmd">getcmd</A>, <A HREF="#getenv">getenv</A>,
<A HREF="#main">main</A>, <A HREF="#onexit">onexit</A>, <A HREF="#putenv">putenv</A>, <A HREF="#spawn___">spawn...</A>, <A HREF="#system">system</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;unistd.h&gt;</TT>
<BR><BR><TT>int main( int argc, char **argv )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; c;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; *ifile;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; *ofile;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; while( (c = getopt( argc, argv, &quot;:abf:o:&quot; )) != -1 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch( c ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'a':</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;option a is set\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'b':</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;option b is set\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'f':</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ifile = optarg;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;input filename is '%s'\n&quot;, ifile
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'o':</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ofile = optarg;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;output filename is '%s'\n&quot;,
ofile );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case ':':</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;-%c without filename\n&quot;, optopt
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case '?':</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;usage: %s -ab -f &lt;filename&gt;
-o &lt;filename&gt;\n&quot;, argv[0] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; return( 0 );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>option a is set</TT>
<BR><TT>input filename is 'in'</TT>
<BR><TT>output filename is 'out'</TT>
<BR><BR>when the program is executed with the command
<BR><BR><TT>&lt;program name&gt; -afin -o out</TT>
</DL>
<DL>
<DT>Classification:
<DD>POSIX
</DL>
<DL>
<DT>Systems:
<DD>All, Linux
</DL>
<H2 ID="_get_osfhandle"> _get_osfhandle </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;io.h&gt;</TT>
<BR><TT>long _get_osfhandle( int posixhandle );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _get_osfhandle</TT> function returns the operating system's internal file handle that corresponds to the POSIX-level
file handle specified by<B> posixhandle</B>.
<BR><BR>The value returned by<TT> _get_osfhandle</TT> can be used as an argument to the <TT> _open_osfhandle</TT> function
which can be used to connect a second POSIX-level handle to an open file.
<BR><BR>The example below demonstrates the use of these two functions.&nbsp; Note that the example shows how the <TT> dup2</TT>
function can be used to obtain almost identical functionality.
<BR><BR>When the POSIX-level file handles associated with one OS file handle are closed, the first one closes successfully
but the others return an error (since the first call close the file and released the OS file handle).&nbsp; So it is important
to call <TT> close</TT> at the right time, i.e., after all I/O operations are completed to the file.
</DL>
<DL>
<DT>Returns:
<DD>If successful,<TT> _get_osfhandle</TT> returns an operating system file handle corresponding to<B> posixhandle</B>.&nbsp;
Otherwise, it returns -1 and sets <TT> errno</TT> to <TT> EBADF</TT>, indicating an invalid file handle.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#close">close</A>, <A HREF="#dup2">dup2</A>, <A HREF="#fdopen">fdopen</A>, <A HREF="#_hdopen">_hdopen</A>, <A HREF="#open">open</A>,
<A HREF="#_open_osfhandle">_open_osfhandle</A>, <A HREF="#_os_handle">_os_handle</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>#include &lt;io.h&gt;</TT>
<BR><TT>#include &lt;fcntl.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; long os_handle;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int fh1, fh2, rc;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; fh1 = open( &quot;file&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; O_WRONLY | O_CREAT | O_TRUNC
| O_BINARY,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S_IRUSR | S_IWUSR | S_IRGRP
| S_IWGRP );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( fh1 == -1 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Could not open output file\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit( EXIT_FAILURE );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;First POSIX handle %d\n&quot;, fh1 );</TT>
<BR><BR><TT>#if defined(USE_DUP2)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fh2 = 6;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( dup2( fh1, fh2 ) == -1 ) fh2 = -1;</TT>
<BR><TT>#else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; os_handle = _get_osfhandle( fh1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;OS Handle %ld\n&quot;, os_handle );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; fh2 = _open_osfhandle( os_handle, O_WRONLY |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; O_BINARY );</TT>
<BR><TT>#endif</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( fh2 == -1 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Could not open with second handle\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit( EXIT_FAILURE );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Second POSIX handle %d\n&quot;, fh2 );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; rc = write( fh2, &quot;trash\x0d\x0a&quot;, 7 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Write file using second handle %d\n&quot;, rc );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; rc = close( fh2 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Closing second handle %d\n&quot;, rc );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; rc = close( fh1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Closing first handle %d\n&quot;, rc );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, Linux, Netware
</DL>
<H2 ID="getpgrp"> getpgrp </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;unistd.h&gt;</TT>
<BR><TT>gid_t getpgrp( void );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> getpgrp</TT> function returns the process group ID for the current process.
</DL>
<DL>
<DT>Returns:
<DD>The process group ID for the current process.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#getuid">getuid</A>, <A HREF="#geteuid">geteuid</A>, <A HREF="#getegid">getegid</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>/*</TT>
<BR><TT> * Print the process group ID of the process.</TT>
<BR><TT> */</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;unistd.h&gt;</TT>
<BR><BR><TT>int main( void )</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;I belong to group ID %d\n&quot;, getpgrp() );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; return( 0 );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>POSIX 1003.1
</DL>
<DL>
<DT>Systems:
<DD>Linux
</DL>
<H2 ID="_getphyscoord"> _getphyscoord </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>struct xycoord _FAR _getphyscoord( short x, short y );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _getphyscoord</TT> function returns the physical coordinates of the position with view coordinates<TT> (x,y).</TT>
&nbsp;View coordinates are defined by the <TT> _setvieworg</TT> and <TT> _setviewport</TT> functions.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _getphyscoord</TT> function returns the physical coordinates, as an<TT> xycoord</TT> structure, of the given point.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getviewcoord">_getviewcoord</A>, <A HREF="#_setvieworg">_setvieworg</A>, <A HREF="#_setviewport">_setviewport</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct xycoord pos;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvieworg( rand() % 640, rand() % 480 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; pos = _getphyscoord( 0, 0 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _rectangle( _GBORDER, - pos.xcoord, - pos.ycoord,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
639 - pos.xcoord, 479 - pos.ycoord );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="getpid"> getpid, _getpid </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;unistd.h&gt;</TT>
<BR><TT>pid_t getpid( void );</TT>
<BR><TT>pid_t _getpid( void );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> getpid</TT> function returns the process ID for the current process.
</DL>
<DL>
<DT>Returns:
<DD>The process ID for the current process.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#getppid">getppid</A>, <A HREF="#gettid">gettid</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>/*</TT>
<BR><TT> * print out the ID of this process</TT>
<BR><TT> */</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;unistd.h&gt;</TT>
<BR><BR><TT>int main( void )</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;I'm process %d\n&quot;, getpid() );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; return( 0 );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>POSIX 1003.1
<BR><BR>_getpid is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> getpid - All, Linux, RDOS</TT>
<BR><BR><TT>_getpid - All, Linux, RDOS</TT>
</DL>
<H2 ID="_getpixel"> _getpixel, _getpixel_w </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>short _FAR _getpixel( short x, short y );</TT>
<BR><BR><TT>short _FAR _getpixel_w( double x, double y );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _getpixel</TT> functions return the pixel value for the point with coordinates<TT> (x,y).</TT>&nbsp; The<TT> _getpixel</TT>
function uses the view coordinate system.&nbsp; The<TT> _getpixel_w</TT> function uses the window coordinate system.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _getpixel</TT> functions return the pixel value for the given point when the point lies within the clipping region;
otherwise, (-1) is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_setpixel">_setpixel</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int x, y;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _rectangle( _GBORDER, 100, 100, 540, 380 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt;= 60000; ++i ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = 101 + rand() % 439;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y = 101 + rand() % 279;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _setcolor( _getpixel( x, y ) + 1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _setpixel( x, y );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD><TT> _getpixel - DOS</TT>
<BR><BR><TT>_getpixel_w - DOS</TT>
</DL>
<H2 ID="_getplotaction"> _getplotaction </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>short _FAR _getplotaction( void );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _getplotaction</TT> function returns the current plotting action.
<BR><BR>The drawing functions cause pixels to be set with a pixel value.&nbsp; By default, the value to be set is obtained
by replacing the original pixel value with the supplied pixel value.&nbsp; Alternatively, the replaced value may be computed
as a function of the original and the supplied pixel values.
<BR><BR>The plotting action can have one of the following values:
<DL>
<DT>_GPSET
<DD>replace the original screen pixel value with the supplied pixel value
<DT>_GAND
<DD>replace the original screen pixel value with the<B> bitwise and</B> of the original pixel value and the supplied pixel value
<DT>_GOR
<DD>replace the original screen pixel value with the<B> bitwise or</B> of the original pixel value and the supplied pixel value
<DT>_GXOR
<DD>replace the original screen pixel value with the<B> bitwise exclusive-or</B> of the original pixel value and the supplied
pixel value.&nbsp; Performing this operation twice will restore the original screen contents, providing an efficient method
to produce animated effects.
</DL>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _getplotaction</TT> function returns the current plotting action.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_setplotaction">_setplotaction</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int old_act;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; old_act = _getplotaction();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setplotaction( _GPSET );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _rectangle( _GFILLINTERIOR, 100, 100, 540, 380 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setplotaction( _GXOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _rectangle( _GFILLINTERIOR, 100, 100, 540, 380 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setplotaction( old_act );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="getppid"> getppid </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;unistd.h&gt;</TT>
<BR><TT>pid_t getppid(void);</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> getppid</TT> function allows the calling process to find out its parent ID.
</DL>
<DL>
<DT>Returns:
<DD>The process parent's process ID.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#getpid">getpid</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>/*</TT>
<BR><TT> * Print the parent's process ID.</TT>
<BR><TT> */</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;unistd.h&gt;</TT>
<BR><BR><TT>int main( void )</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;My parent is %d\n&quot;, getppid() );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; return( 0 );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>POSIX 1003.1
</DL>
<DL>
<DT>Systems:
<DD>Linux
</DL>
<H2 ID="getprotobyname"> getprotobyname </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;netdb.h&gt;</TT>
<BR><TT>struct netent *getprotobyname( const char *name );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> getprotobyname</TT> function searches the protocol database for a protocol matching the specified<B> name</B> , considering
both the official name and aliases.&nbsp; The routine will query the local database only.
<BR><BR>The structure returned is defined as:
<BR><BR><TT>struct protoent {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; *p_name;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* official protocol
name */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; **p_aliases;&nbsp;&nbsp;&nbsp; /* alias list */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; p_proto;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* protocol number
*/</TT>
<BR><TT>};</TT>
<BR>The pointer returned by<TT> getprotobyname</TT> points to a private location, and the user should free neither the pointer
itself nor any of its constituent structure members.&nbsp; Subsequent calls to this function may result in the values changing.
<BR><BR>This function is not thread-safe.&nbsp; Other calls to this function or to other functions accessing the protocol
database may affect the return value from this function.
</DL>
<DL>
<DT>Returns:
<DD>If a matching protocol database entry is found, the return value will point to a <TT> struct protoent</TT> as defined above.
<BR><BR>The alias names of said protocol are contained in the <TT> p_aliases</TT> member as a NULL-terminated list, and this
structure entry will never be NULL.
<BR><BR>If no protocol is found or an error occurs, the return value will be NULL.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#getprotoent">getprotoent</A>, <A HREF="#setprotoent">setprotoent</A>, <A HREF="#endprotoent">endprotoent</A>, <A HREF="#getprotobynumber">getprotobynumber</A>
</DL>
<DL>
<DT>Classification:
<DD>POSIX
</DL>
<DL>
<DT>Systems:
<DD>Linux
</DL>
<H2 ID="getprotobynumber"> getprotobynumber </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;netdb.h&gt;</TT>
<BR><TT>struct netent *getprotobynumber( int protocol );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> getprotobynumber</TT> function searches the protocol database for a protocol matching the specified by the<B> protocol</B>
argument.&nbsp; The routine will query the local database only.
<BR><BR>The structure returned is defined as:
<BR><BR><TT>struct protoent {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; *p_name;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* official protocol
name */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; **p_aliases;&nbsp;&nbsp;&nbsp; /* alias list */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; p_proto;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* protocol number
*/</TT>
<BR><TT>};</TT>
<BR>The pointer returned by<TT> getprotobynumber</TT> points to a private location, and the user should free neither the pointer
itself nor any of its constituent structure members.&nbsp; Subsequent calls to this function may result in the values changing.
<BR><BR>This function is not thread-safe.&nbsp; Other calls to this function or to other functions accessing the protocol
database may affect the return value from this function.
</DL>
<DL>
<DT>Returns:
<DD>If a matching protocol database entry is found, the return value will point to a <TT> struct protoent</TT> as defined above.
<BR><BR>The alias names of said protocol are contained in the <TT> p_aliases</TT> member as a NULL-terminated list, and this
structure entry will never be NULL.
<BR><BR>If no protocol is found or an error occurs, the return value will be NULL.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#getprotoent">getprotoent</A>, <A HREF="#setprotoent">setprotoent</A>, <A HREF="#endprotoent">endprotoent</A>, <A HREF="#getprotobyname">getprotobyname</A>
</DL>
<DL>
<DT>Classification:
<DD>POSIX
</DL>
<DL>
<DT>Systems:
<DD>Linux
</DL>
<H2 ID="getprotoent"> getprotoent </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;netdb.h&gt;</TT>
<BR><TT>struct netent *getprotoent( void );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> getprotoent</TT> function retrieves the next entry in the protocol database.&nbsp; If not proceeded by an appropriate
call to <TT> setprotoent</TT> , the function will always return the first protocol in the database.&nbsp; The routine will
query the local database only.
<BR><BR>The structure returned is defined as:
<BR><BR><TT>struct protoent {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; *p_name;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* official protocol
name */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; **p_aliases;&nbsp;&nbsp;&nbsp; /* alias list */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; p_proto;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* protocol number
*/</TT>
<BR><TT>};</TT>
<BR>The pointer returned by<TT> getprotoent</TT> points to a private location, and the user should free neither the pointer
itself nor any of its constituent structure members.&nbsp; Subsequent calls to this function may result in the values changing.
<BR><BR>This function is not thread-safe.&nbsp; Other calls to this function or to other functions accessing the protocol
database may affect the return value from this function.
</DL>
<DL>
<DT>Returns:
<DD>If the database contains more entries, the return value will be non-NULL.&nbsp; The returned pointer should not be freed by
the calling routine.
<BR><BR>The alias names of said protocol are contained in the <TT> p_aliases</TT> member as a NULL-terminated list, and this
structure entry will never be NULL.
<BR><BR>If no protocol is found or an error occurs, the return value will be NULL.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#setprotoent">setprotoent</A>, <A HREF="#endprotoent">endprotoent</A>, <A HREF="#getprotobyname">getprotobyname</A>,
<A HREF="#getprotobynumber">getprotobynumber</A>
</DL>
<DL>
<DT>Classification:
<DD>POSIX
</DL>
<DL>
<DT>Systems:
<DD>Linux
</DL>
<H2 ID="getpwent"> getpwent </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;pwd.h&gt;</TT>
<BR><TT>struct passwd *getpwent( void );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> getpwent</TT> function reads, parses, and returns entries from the password database at /etc/passwd.&nbsp; The first
call will return the first entry, and subsequent calls return subsequent entries.&nbsp; A null pointer is returned if either
an error is encountered or no further entries exist.
<BR><BR>The structure returned is defined as:
<BR><BR><TT>struct passwd {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pw_name;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*
user's login name */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pw_passwd;&nbsp;&nbsp;&nbsp;&nbsp; /* user's password
&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; uid_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pw_uid;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* user ID number&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; gid_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pw_gid;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* group ID number&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pw_gecos;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* real
name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pw_dir;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* home directory&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pw_shell;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* initial
program&nbsp;&nbsp; */</TT>
<BR><TT>};</TT>
<BR>On most modern Linux implementations, the resulting password will simply be 'x' as passwords are not normally stored in
the password database itself.
<BR><BR>The pointer returned by<TT> getpwent</TT> points to a static location, and the user should free neither the pointer
itself nor any of its consituent structure members.
<BR><BR>This function is not thread-safe.&nbsp; Other calls to functions accessing the password database may affect the return
value from this function.
</DL>
<DL>
<DT>Returns:
<DD>A parsed password database entry, or NULL if no further entries exist or an error occurred.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#setpwent">setpwent</A>, <A HREF="#endpwent">endpwent</A>, <A HREF="#getpwnam">getpwnam</A>, <A HREF="#getpwuid">getpwuid</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR>The following program will print out each user and their user ID in the system's password database
<BR><BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;pwd.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct passwd *pw;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; setpwent();</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; while((pw = getpwent()) != NULL) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;User id %d is %s\n&quot;, (int)pw-&gt;pw_uid, pw-&gt;pw_name);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; endpwent();</TT>
<BR><BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>POSIX
</DL>
<DL>
<DT>Systems:
<DD>Linux
</DL>
<H2 ID="getpwnam"> getpwnam </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;pwd.h&gt;</TT>
<BR><TT>struct passwd *getpwnam( const char *name );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> getpwnam</TT> function locates and returns a parsed password database entry for the user with the specified username.
&nbsp;If a matching entry is not found or an error occurs, a null pointer will be returned.
<BR><BR>The structure returned is defined as:
<BR><BR><TT>struct passwd {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pw_name;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*
user's login name */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pw_passwd;&nbsp;&nbsp;&nbsp;&nbsp; /* user's password
&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; uid_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pw_uid;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* user ID number&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; gid_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pw_gid;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* group ID number&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pw_gecos;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* real
name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pw_dir;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* home directory&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pw_shell;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* initial
program&nbsp;&nbsp; */</TT>
<BR><TT>};</TT>
<BR>On most modern Linux implementations, the resulting password will simply be 'x' as passwords are not normally stored in
the password database itself.
<BR><BR>The pointer returned by<TT> getpwnam</TT> points to a static location, and the user should free neither the pointer
itself nor any of its consituent structure members.
<BR><BR>This function is not thread-safe.&nbsp; Other calls to functions accessing the password database may affect the return
value from this function.
</DL>
<DL>
<DT>Returns:
<DD>A matching parsed password database entry, or NULL if no match is found.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#setpwent">setpwent</A>, <A HREF="#endpwent">endpwent</A>, <A HREF="#getpwuid">getpwuid</A>, <A HREF="#getpwent">getpwent</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR>The following program will locate and print out the user ID corresponding to a user name 'root.'
<BR><BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;pwd.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct passwd *pw;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; pw = getpwnam( &quot;root&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if(pw) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;The user id for root is %d\n&quot;, (int)pw-&gt;pw_uid);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;User 'root' was not found.\n&quot;);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>POSIX
</DL>
<DL>
<DT>Systems:
<DD>Linux
</DL>
<H2 ID="getpwuid"> getpwuid </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;pwd.h&gt;</TT>
<BR><TT>struct passwd *getpwuid( uit_t uid );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> getpwuid</TT> function locates and returns a parsed password database entry for the user with the specified user ID.
&nbsp;If a matching entry is not found or an error occurs, a null pointer will be returned.
<BR><BR>The structure returned is defined as:
<BR><BR><TT>struct passwd {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pw_name;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*
user's login name */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pw_passwd;&nbsp;&nbsp;&nbsp;&nbsp; /* user's password
&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; uid_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pw_uid;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* user ID number&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; gid_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pw_gid;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* group ID number&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pw_gecos;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* real
name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pw_dir;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* home directory&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pw_shell;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* initial
program&nbsp;&nbsp; */</TT>
<BR><TT>};</TT>
<BR>On most modern Linux implementations, the resulting password will simply be 'x' as passwords are not normally stored in
the password database itself.
<BR><BR>The pointer returned by<TT> getpwuid</TT> points to a static location, and the user should free neither the pointer
itself nor any of its consituent structure members.
<BR><BR>This function is not thread-safe.&nbsp; Other calls to functions accessing the password database may affect the return
value from this function.
</DL>
<DL>
<DT>Returns:
<DD>A matching parsed password database entry, or NULL if no match is found.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#setpwent">setpwent</A>, <A HREF="#endpwent">endpwent</A>, <A HREF="#getpwnam">getpwnam</A>, <A HREF="#getpwent">getpwent</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR>The following program will locate and print out the user name corresponding to a user ID of 1000.
<BR><BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;pwd.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct passwd *pw;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; pw = getpwuid( (uid_t)1000 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if(pw)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;The corresponding username is '%s'\n&quot;, pw-&gt;pw_name);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;User id 1000 was not found.\n&quot;);</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>POSIX
</DL>
<DL>
<DT>Systems:
<DD>Linux
</DL>
<H2 ID="gets"> gets, _getws </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>char *gets( char *buf );</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>wchar_t *_getws( wchar_t *buf );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> gets</TT> function gets a string of characters from the file designated by <TT> stdin</TT> and stores them in the
array pointed to by<B> buf</B> until end-of-file is encountered or a new-line character is read.&nbsp; Any new-line character
is discarded, and a null character is placed immediately after the last character read into the array.
<BR><BR>The<TT> _getws</TT> function is a wide-character version of<TT> gets</TT> that operates with wide-character strings.
&nbsp;The<TT> _getws</TT> function gets a string of multibyte characters (if present) from the input stream pointed to by
<TT> stdin</TT>, converts them to wide characters, and stores them in the wide-character array pointed to by<B> buf</B> until
end-of-file is encountered or a wide-character new-line character is read.
<BR><BR>It is recommended that <TT> fgets</TT> be used instead of<TT> gets</TT> because data beyond the array<B> buf</B> will
be destroyed if a new-line character is not read from the input stream <TT> stdin</TT> before the end of the array<B> buf</B>
is reached.
<BR><BR>A common programming error is to assume the presence of a new-line character in every string that is read into the
array.&nbsp; A new-line character may not appear as the last character in a file, just before end-of-file.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> gets</TT> function returns<B> buf</B> if successful.<TT>&nbsp; NULL</TT> is returned if end-of-file is encountered,
or if a read error occurs.&nbsp; When an error has occurred, <TT> errno</TT> contains a value indicating the type of error
that has been detected.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#fgetc">fgetc</A>, <A HREF="#fgetchar">fgetchar</A>, <A HREF="#fgets">fgets</A>, <A HREF="#fopen">fopen</A>, <A HREF="#getc">getc</A>,
<A HREF="#getchar">getchar</A>, <A HREF="#ungetc">ungetc</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char buffer[80];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; while( gets( buffer ) != NULL )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; puts( buffer );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>_getws is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> gets - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_getws - All, Linux</TT>
</DL>
<H2 ID="gets_s"> gets_s </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__ 1</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>char *gets_s( char *s, rsize_t n );</TT>
</DL>
<DL>
<DT>Constraints:
<DD>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<TT>
gets_s</TT> will set<B> s[0]</B> to be the null character, and characters are read and discarded from <TT> stdin</TT> until
a new-line character is read, or end-of-file or a read error occurs.
<BR><BR><B>s</B> shall not be a null pointer.<B>&nbsp; n</B> shall neither be equal to zero nor be greater than <TT> RSIZE_MAX</TT>
.&nbsp; A new-line character, end-of-file, or read error shall occur within reading<B> n-1</B> characters from <TT> stdin</TT>
.
</DL>
<DL>
<DT>Description:
<DD>The<TT> gets_s</TT> function gets a string of characters from the file designated by <TT> stdin</TT> and stores them in the
array pointed to by<B> s</B> until end-of-file is encountered or a new-line character is read.&nbsp; Size of the array<B>
s</B> is specified by the argument<B> n</B> , this information is used to protect buffer from overflow.&nbsp; If buffer<B>
s</B> is about to be overflown, runtime-constraint is activated.&nbsp; Any new-line character is discarded, and a null character
is placed immediately after the last character read into the array.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> gets_s</TT> function returns<B> s</B> if successful.<TT>&nbsp; NULL</TT> is returned if there was a runtime-constraint
violation, or if end-of-file is encountered and no caracters have been read into the array, or if a read error occurs.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#fgetc">fgetc</A>, <A HREF="#fgetchar">fgetchar</A>, <A HREF="#fgets">fgets</A>, <A HREF="#fopen">fopen</A>, <A HREF="#getc">getc</A>,
<A HREF="#getchar">getchar</A>, <A HREF="#gets">gets</A>, <A HREF="#ungetc">ungetc</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__ 1</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>int main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char buffer[80];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; while( gets_s( buffer, sizeof( buffer ) ) != NULL )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; puts( buffer );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>TR 24731
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="getservbyname"> getservbyname </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;netdb.h&gt;</TT>
<BR><TT>struct servent *getservbyname( const char *name, const char *protocol );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> getservbyname</TT> function searches the service database for a service with matching<B> name</B> and<B> protocol</B>
, returning a pointer the a <TT> struct servent</TT> if found.&nbsp; The function will search for matching aliases as well.
&nbsp;If<B> protocol</B> is NULL, the first encountered service matching the specified name will be returned regardless of
protocol.&nbsp; The routine will query the local database only.
<BR><BR>The structure returned is defined as:
<BR><BR><TT>struct servent {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; *s_name;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* official service name
*/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; **s_aliases;&nbsp;&nbsp;&nbsp; /* alias list */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; s_port;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* port number
*/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; *s_proto;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* protocol to use */</TT>
<BR><TT>};</TT>
<BR>The pointer returned by<TT> getservbyname</TT> points to a private location, and the user should free neither the pointer
itself nor any of its constituent structure members.&nbsp; Subsequent calls to this function may result in the values changing.
<BR><BR>This function is not thread-safe.&nbsp; Other calls to this function or to other functions accessing the hostname
database may affect the return value from this function.
</DL>
<DL>
<DT>Returns:
<DD>If a match is found, the return value will be non-NULL.&nbsp; The returned pointer should not be freed by the calling routine.
<BR><BR>The alias names of said network are contained in the <TT> s_aliases</TT> member as a NULL-terminated list, and this
structure entry will never be NULL.
<BR><BR>If no additional network is found or an error occurs, the return value will be NULL.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#getservent">getservent</A>, <A HREF="#setservent">setservent</A>, <A HREF="#endservent">endservent</A>
</DL>
<DL>
<DT>Classification:
<DD>POSIX
</DL>
<DL>
<DT>Systems:
<DD>Linux
</DL>
<H2 ID="getservbyport"> getservbyport </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;netdb.h&gt;</TT>
<BR><TT>struct servent *getservbyname( int port, const char *protocol );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> getservbyport</TT> function searches the service database for a service listening on<B> port</B> using<B> protocol</B>
, returning a pointer the a <TT> struct servent</TT> if found.&nbsp; If<B> protocol</B> is NULL, the first encountered service
matching the specified port number will be returned regardless of protocol.&nbsp; The routine will query the local database
only.
<BR><BR>The structure returned is defined as:
<BR><BR><TT>struct servent {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; *s_name;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* official service name
*/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; **s_aliases;&nbsp;&nbsp;&nbsp; /* alias list */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; s_port;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* port number
*/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; *s_proto;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* protocol to use */</TT>
<BR><TT>};</TT>
<BR>The pointer returned by<TT> getservbyport</TT> points to a private location, and the user should free neither the pointer
itself nor any of its constituent structure members.&nbsp; Subsequent calls to this function may result in the values changing.
<BR><BR>This function is not thread-safe.&nbsp; Other calls to this function or to other functions accessing the hostname
database may affect the return value from this function.
</DL>
<DL>
<DT>Returns:
<DD>If a match is found, the return value will be non-NULL.&nbsp; The returned pointer should not be freed by the calling routine.
<BR><BR>The alias names of said network are contained in the <TT> s_aliases</TT> member as a NULL-terminated list, and this
structure entry will never be NULL.
<BR><BR>If no additional network is found or an error occurs, the return value will be NULL.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#getservent">getservent</A>, <A HREF="#setservent">setservent</A>, <A HREF="#endservent">endservent</A>, <A HREF="#getservbyname">getservbyname</A>
</DL>
<DL>
<DT>Classification:
<DD>POSIX
</DL>
<DL>
<DT>Systems:
<DD>Linux
</DL>
<H2 ID="getservent"> getservent </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;netdb.h&gt;</TT>
<BR><TT>struct servent *getservent( void );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> getservent</TT> function retrieves the next entry in the service database.&nbsp; If not proceeded by an appropriate
call to <TT> setservent</TT> , the function will always return the first service in the database.&nbsp; The routine will query
the local database only.
<BR><BR>The structure returned is defined as:
<BR><BR><TT>struct servent {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; *s_name;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* official service name
*/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; **s_aliases;&nbsp;&nbsp;&nbsp; /* alias list */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; s_port;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* port number
*/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; *s_proto;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* protocol to use */</TT>
<BR><TT>};</TT>
<BR>The pointer returned by<TT> getservent</TT> points to a private location, and the user should free neither the pointer
itself nor any of its constituent structure members.&nbsp; Subsequent calls to this function may result in the values changing.
<BR><BR>This function is not thread-safe.&nbsp; Other calls to this function or to other functions accessing the hostname
database may affect the return value from this function.
</DL>
<DL>
<DT>Returns:
<DD>If the database contains more entries, the return value will be non-NULL.&nbsp; The returned pointer should not be freed by
the calling routine.
<BR><BR>The alias names of said network are contained in the <TT> s_aliases</TT> member as a NULL-terminated list, and this
structure entry will never be NULL.
<BR><BR>If no additional network is found or an error occurs, the return value will be NULL.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#setservent">setservent</A>, <A HREF="#endservent">endservent</A>, <A HREF="#getservbyname">getservbyname</A>, <A HREF="#getservbyport">getservbyport</A>
</DL>
<DL>
<DT>Classification:
<DD>POSIX
</DL>
<DL>
<DT>Systems:
<DD>Linux
</DL>
<H2 ID="_gettextcolor"> _gettextcolor </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>short _FAR _gettextcolor( void );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _gettextcolor</TT> function returns the pixel value of the current text color.&nbsp; This is the color used for displaying
text with the <TT> _outtext</TT> and <TT> _outmem</TT> functions.&nbsp; The default text color value is set to 7 whenever
a new video mode is selected.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _gettextcolor</TT> function returns the pixel value of the current text color.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_settextcolor">_settextcolor</A>, <A HREF="#_setcolor">_setcolor</A>, <A HREF="#_outtext">_outtext</A>, <A HREF="#_outmem">_outmem</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int old_col;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; long old_bk;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _TEXTC80 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; old_col = _gettextcolor();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; old_bk = _getbkcolor();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _settextcolor( 7 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setbkcolor( _BLUE );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _outtext( &quot; WATCOM \nGraphics&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _settextcolor( old_col );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setbkcolor( old_bk );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_gettextcursor"> _gettextcursor </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>short _FAR _gettextcursor( void );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _gettextcursor</TT> function returns the current cursor attribute, or shape.&nbsp; The cursor shape is set with the
<TT> _settextcursor</TT> function.&nbsp; See the <TT> _settextcursor</TT> function for a description of the value returned
by the<TT> _gettextcursor</TT> function.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _gettextcursor</TT> function returns the current cursor shape when successful; otherwise, (-1) is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_settextcursor">_settextcursor</A>, <A HREF="#_displaycursor">_displaycursor</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int old_shape;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; old_shape = _gettextcursor();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _settextcursor( 0x0007 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _outtext( &quot;\nBlock cursor&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _settextcursor( 0x0407 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _outtext( &quot;\nHalf height cursor&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _settextcursor( 0x2000 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _outtext( &quot;\nNo cursor&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _settextcursor( old_shape );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_gettextextent"> _gettextextent </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>void _FAR _gettextextent( short x, short y,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char _FAR *text,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct xycoord _FAR *concat,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct xycoord _FAR *extent );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _gettextextent</TT> function simulates the effect of using the <TT> _grtext</TT> function to display the text string<B>
text</B> at the position<TT> (x,y),</TT> using the current text settings.&nbsp; The concatenation point is returned in the
argument<B> concat</B>.&nbsp; The text extent parallelogram is returned in the array<B> extent</B>.
<BR><BR>The concatenation point is the position to use to output text after the given string.&nbsp; The text extent parallelogram
outlines the area where the text string would be displayed.&nbsp; The four points are returned in counter-clockwise order,
starting at the upper-left corner.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _gettextextent</TT> function does not return a value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_grtext">_grtext</A>, <A HREF="#_gettextsettings">_gettextsettings</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct xycoord concat;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct xycoord extent[ 4 ];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _grtext( 100, 100, &quot;hot&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _gettextextent( 100, 100, &quot;hot&quot;, &amp;concat, extent );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _polygon( _GBORDER, 4, extent );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _grtext( concat.xcoord, concat.ycoord, &quot;dog&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><IMG SRC="eg_gette.bmp" ALIGN=MIDDLE>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_gettextposition"> _gettextposition </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>struct rccoord _FAR _gettextposition( void );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _gettextposition</TT> function returns the current output position for text.&nbsp; This position is in terms of characters,
not pixels.
<BR><BR>The current position defaults to the top left corner of the screen,<TT> (1,1),</TT> when a new video mode is selected.
&nbsp;It is changed by successful calls to the <TT> _outtext</TT>, <TT> _outmem</TT>, <TT> _settextposition</TT> and <TT>
_settextwindow</TT> functions.
<BR><BR>Note that the output position for graphics output differs from that for text output.&nbsp; The output position for
graphics output can be set by use of the <TT> _moveto</TT> function.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _gettextposition</TT> function returns, as an<TT> rccoord</TT> structure, the current output position for text.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_outtext">_outtext</A>, <A HREF="#_outmem">_outmem</A>, <A HREF="#_settextposition">_settextposition</A>, <A HREF="#_settextwindow">_settextwindow</A>,
<A HREF="#_moveto">_moveto</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct rccoord old_pos;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _TEXTC80 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; old_pos = _gettextposition();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _settextposition( 10, 40 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _outtext( &quot;WATCOM Graphics&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _settextposition( old_pos.row, old_pos.col );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_gettextsettings"> _gettextsettings </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>struct textsettings _FAR * _FAR _gettextsettings</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ( struct textsettings _FAR *settings );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _gettextsettings</TT> function returns information about the current text settings used when text is displayed by
the <TT> _grtext</TT> function.&nbsp; The information is stored in the<TT> textsettings</TT> structure indicated by the argument<B>
settings</B>.&nbsp; The structure contains the following fields (all are<TT> short</TT> fields):
<DL>
<DT>basevectorx
<DD>x-component of the current base vector
<DT>basevectory
<DD>y-component of the current base vector
<DT>path
<DD>current text path
<DT>height
<DD>current text height (in pixels)
<DT>width
<DD>current text width (in pixels)
<DT>spacing
<DD>current text spacing (in pixels)
<DT>horizalign
<DD>horizontal component of the current text alignment
<DT>vertalign
<DD>vertical component of the current text alignment
</DL>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _gettextsettings</TT> function returns information about the current graphics text settings.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_grtext">_grtext</A>, <A HREF="#_setcharsize">_setcharsize</A>, <A HREF="#_setcharspacing">_setcharspacing</A>,
<A HREF="#_settextalign">_settextalign</A>, <A HREF="#_settextpath">_settextpath</A>, <A HREF="#_settextorient">_settextorient</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct textsettings ts;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _gettextsettings( &amp;ts );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _grtext( 100, 100, &quot;WATCOM&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setcharsize( 2 * ts.height, 2 * ts.width );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _grtext( 100, 300, &quot;Graphics&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setcharsize( ts.height, ts.width );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_gettextwindow"> _gettextwindow </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>void _FAR _gettextwindow(</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short _FAR *row1, short
_FAR *col1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short _FAR *row2, short
_FAR *col2 );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _gettextwindow</TT> function returns the location of the current text window.&nbsp; A text window is defined with
the <TT> _settextwindow</TT> function.&nbsp; By default, the text window is the entire screen.
<BR><BR>The current text window is a rectangular area of the screen.&nbsp; Text display is restricted to be within this window.
&nbsp;The top left corner of the text window is placed in the arguments<TT> (row1,col1).</TT>&nbsp; The bottom right corner
of the text window is placed in<TT> (row2,col2).</TT>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _gettextwindow</TT> function returns the location of the current text window.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_settextwindow">_settextwindow</A>, <A HREF="#_outtext">_outtext</A>, <A HREF="#_outmem">_outmem</A>, <A HREF="#_settextposition">_settextposition</A>,
<A HREF="#_scrolltextwindow">_scrolltextwindow</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int i;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; short r1, c1, r2, c2;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char buf[ 80 ];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _TEXTC80 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _gettextwindow( &amp;r1, &amp;c1, &amp;r2, &amp;c2 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _settextwindow( 5, 20, 20, 40 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 1; i &lt;= 20; ++i ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf( buf, &quot;Line %d\n&quot;, i );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _outtext( buf );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _settextwindow( r1, c1, r2, c2 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="gettid"> gettid </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;process.h&gt;</TT>
<BR><TT>int gettid(void);</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> gettid</TT> function returns the thread id for the current thread on Linux systems.&nbsp; It provides a wrapper around
the appropriate kernel system call.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> gettid</TT> function returns the thread id for the current thread.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#getpid">getpid</A>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>Linux
</DL>
<H2 ID="getuid"> getuid </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;unistd.h&gt;</TT>
<BR><TT>uid_t getuid( void );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> getuid</TT> function returns the user ID for the calling process.
</DL>
<DL>
<DT>Returns:
<DD>The user ID for the calling process
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#geteuid">geteuid</A>, <A HREF="#getgid">getgid</A>, <A HREF="#getegid">getegid</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>/*</TT>
<BR><TT> * Print the user ID of this process.</TT>
<BR><TT> */</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;unistd.h&gt;</TT>
<BR><BR><TT>int main( void )</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;My userid is %d\n&quot;, getuid() );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; return( 0 );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>POSIX 1003.1
</DL>
<DL>
<DT>Systems:
<DD>Linux
</DL>
<H2 ID="_getvideoconfig"> _getvideoconfig </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>struct videoconfig _FAR * _FAR _getvideoconfig</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ( struct videoconfig _FAR *config );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _getvideoconfig</TT> function returns information about the current video mode and the hardware configuration.&nbsp;
The information is returned in the<TT> videoconfig</TT> structure indicated by the argument<B> config</B>.&nbsp; The structure
contains the following fields (all are<TT> short</TT> fields):
<DL>
<DT>numxpixels
<DD>number of pixels in x-axis
<DT>numypixels
<DD>number of pixels in y-axis
<DT>numtextcols
<DD>number of text columns
<DT>numtextrows
<DD>number of text rows
<DT>numcolors
<DD>number of actual colors
<DT>bitsperpixel
<DD>number of bits in a pixel value
<DT>numvideopages
<DD>number of video pages
<DT>mode
<DD>current video mode
<DT>adapter
<DD>adapter type
<DT>monitor
<DD>monitor type
<DT>memory
<DD>number of kilobytes (1024 characters) of video memory
</DL>
<BR>The<TT> adapter</TT> field will contain one of the following values:
<DL>
<DT>_NODISPLAY
<DD>no display adapter attached
<DT>_UNKNOWN
<DD>unknown adapter/monitor type
<DT>_MDPA
<DD>Monochrome Display/Printer Adapter
<DT>_CGA
<DD>Color Graphics Adapter
<DT>_HERCULES
<DD>Hercules Monochrome Adapter
<DT>_MCGA
<DD>Multi-Color Graphics Array
<DT>_EGA
<DD>Enhanced Graphics Adapter
<DT>_VGA
<DD>Video Graphics Array
<DT>_SVGA
<DD>SuperVGA Adapter
</DL>
<BR>The<TT> monitor</TT> field will contain one of the following values:
<DL>
<DT>_MONO
<DD>regular monochrome
<DT>_COLOR
<DD>regular color
<DT>_ENHANCED
<DD>enhanced color
<DT>_ANALOGMONO
<DD>analog monochrome
<DT>_ANALOGCOLOR
<DD>analog color
</DL>
<BR>The amount of memory reported by<TT> _getvideoconfig</TT> will not always be correct for SuperVGA adapters.&nbsp; Since
it is not always possible to determine the amount of memory,<TT> _getvideoconfig</TT> will always report 256K, the minimum
amount.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _getvideoconfig</TT> function returns information about the current video mode and the hardware configuration.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_setvideomode">_setvideomode</A>, <A HREF="#_setvideomoderows">_setvideomoderows</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int mode;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct videoconfig vc;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char buf[ 80 ];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _getvideoconfig( &amp;vc );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* select &quot;best&quot; video mode */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; switch( vc.adapter ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; case _VGA :</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; case _SVGA :</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode = _VRES16COLOR;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; case _MCGA :</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode = _MRES256COLOR;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; case _EGA :</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( vc.monitor == _MONO ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode = _ERESNOCOLOR;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode = _ERESCOLOR;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; case _CGA :</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode = _MRES4COLOR;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; case _HERCULES :</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode = _HERCMONO;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; default :</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; puts( &quot;No graphics adapter&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit( 1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( _setvideomode( mode ) ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _getvideoconfig( &amp;vc );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf( buf, &quot;%d x %d x %d\n&quot;, vc.numxpixels,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; vc.numypixels, vc.numcolors );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _outtext( buf );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_getviewcoord"> _getviewcoord, _getviewcoord_w, _getviewcoord_wxy </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>struct xycoord _FAR _getviewcoord( short x, short y );</TT>
<BR><BR><TT>struct xycoord _FAR _getviewcoord_w( double x, double y );</TT>
<BR><BR><TT>struct xycoord _FAR _getviewcoord_wxy(</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
struct _wxycoord _FAR *p );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _getviewcoord</TT> functions translate a point from one coordinate system to viewport coordinates.&nbsp; The<TT> _getviewcoord</TT>
function translates the point<TT> (x,y)</TT> from physical coordinates.&nbsp; The<TT> _getviewcoord_w</TT> and<TT> _getviewcoord_wxy</TT>
functions translate the point from the window coordinate system.
<BR><BR>Viewport coordinates are defined by the <TT> _setvieworg</TT> and <TT> _setviewport</TT> functions.&nbsp; Window coordinates
are defined by the <TT> _setwindow</TT> function.
<BR><BR><B>Note:</B>&nbsp; In previous versions of the software, the<TT> _getviewcoord</TT> function was called<TT> _getlogcoord.</TT>
&nbsp;uindex=2 
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _getviewcoord</TT> functions return the viewport coordinates, as an<TT> xycoord</TT> structure, of the given point.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getphyscoord">_getphyscoord</A>, <A HREF="#_setvieworg">_setvieworg</A>, <A HREF="#_setviewport">_setviewport</A>,
<A HREF="#_setwindow">_setwindow</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct xycoord pos1, pos2;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvieworg( rand() % 640, rand() % 480 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; pos1 = _getviewcoord( 0, 0 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; pos2 = _getviewcoord( 639, 479 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _rectangle( _GBORDER, pos1.xcoord, pos1.ycoord,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pos2.xcoord, pos2.ycoord );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD><TT> _getviewcoord - DOS</TT>
<BR><BR><TT>_getviewcoord_w - DOS</TT>
<BR><TT>_getviewcoord_wxy - DOS</TT>
</DL>
<H2 ID="_getvisualpage"> _getvisualpage </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>short _FAR _getvisualpage( void );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _getvisualpage</TT> function returns the number of the currently selected visual graphics page.
<BR><BR>Only some combinations of video modes and hardware allow multiple pages of graphics to exist.&nbsp; When multiple
pages are supported, the active page may differ from the visual page.&nbsp; The graphics information in the visual page determines
what is displayed upon the screen.&nbsp; Animation may be accomplished by alternating the visual page.&nbsp; A graphics page
can be constructed without affecting the screen by setting the active page to be different than the visual page.
<BR><BR>The number of available video pages can be determined by using the <TT> _getvideoconfig</TT> function.&nbsp; The default
video page is 0.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _getvisualpage</TT> function returns the number of the currently selected visual graphics page.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_setvisualpage">_setvisualpage</A>, <A HREF="#_setactivepage">_setactivepage</A>, <A HREF="#_getactivepage">_getactivepage</A>,
<A HREF="#_getvideoconfig">_getvideoconfig</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int old_apage;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int old_vpage;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _HRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; old_apage = _getactivepage();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; old_vpage = _getvisualpage();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* draw an ellipse on page 0 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setactivepage( 0 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvisualpage( 0 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _ellipse( _GFILLINTERIOR, 100, 50, 540, 150 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* draw a rectangle on page 1 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setactivepage( 1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _rectangle( _GFILLINTERIOR, 100, 50, 540, 150 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* display page 1 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvisualpage( 1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setactivepage( old_apage );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvisualpage( old_vpage );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_getw"> _getw </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>int _getw( int binint, FILE *fp );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _getw</TT> function reads a binary value of type<B> int</B> from the current position of the stream<B> fp</B> and
increments the associated file pointer to point to the next unread character in the input stream.<TT>&nbsp; _getw</TT> does
not assume any special alignment of items in the stream.
<BR><BR><TT>_getw</TT> is provided primarily for compatibility with previous libraries.&nbsp; Portability problems may occur
with<TT> _getw</TT> because the size of an<B> int</B> and the ordering of bytes within an<B> int</B> differ across systems.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _getw</TT> function returns the integer value read or, if a read error or end-of-file occurs, the error indicator
is set and<TT> _getw</TT> returns <TT> EOF</TT>.&nbsp; Since <TT> EOF</TT> is a legitimate value to read from<B> fp</B>, use
<TT> ferror</TT> to verify that an error has occurred.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#ferror">ferror</A>, <A HREF="#fgetc">fgetc</A>, <A HREF="#fgetchar">fgetchar</A>, <A HREF="#fgets">fgets</A>, <A HREF="#fopen">fopen</A>,
<A HREF="#getc">getc</A>, <A HREF="#getchar">getchar</A>, <A HREF="#gets">gets</A>, <A HREF="#_putw">_putw</A>, <A HREF="#ungetc">ungetc</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FILE *fp;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int c;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; fp = fopen( &quot;file&quot;, &quot;r&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( fp != NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( (c = _getw( fp )) != EOF )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _putw( c, stdout );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( fp );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="_getwindowcoord"> _getwindowcoord </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>struct _wxycoord _FAR _getwindowcoord( short x, short y );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _getwindowcoord</TT> function returns the window coordinates of the position with view coordinates<TT> (x,y).</TT>
&nbsp;Window coordinates are defined by the <TT> _setwindow</TT> function.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _getwindowcoord</TT> function returns the window coordinates, as a<TT> _wxycoord</TT> structure, of the given point.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_setwindow">_setwindow</A>, <A HREF="#_getviewcoord">_getviewcoord</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct xycoord centre;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct _wxycoord pos1, pos2;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; /* draw a box 50 pixels square */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* in the middle of the screen */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _MAXRESMODE );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; centre = _getviewcoord_w( 0.5, 0.5 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; pos1 = _getwindowcoord( centre.xcoord - 25,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; centre.ycoord - 25 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; pos2 = _getwindowcoord( centre.xcoord + 25,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; centre.ycoord + 25 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _rectangle_wxy( _GBORDER, &amp;pos1, &amp;pos2 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="gmtime"> gmtime Functions </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;time.h&gt;</TT>
<BR><TT>struct tm * gmtime( const time_t *timer );</TT>
<BR><TT>struct tm *_gmtime( const time_t *timer,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
struct tm *tmbuf );</TT>
<BR><BR><TT>struct&nbsp; tm {</TT>
<BR><TT>&nbsp; int tm_sec;&nbsp;&nbsp; /* seconds after the minute -- [0,61] */</TT>
<BR><TT>&nbsp; int tm_min;&nbsp;&nbsp; /* minutes after the hour&nbsp;&nbsp; -- [0,59] */</TT>
<BR><TT>&nbsp; int tm_hour;&nbsp; /* hours after midnight&nbsp;&nbsp;&nbsp;&nbsp; -- [0,23] */</TT>
<BR><TT>&nbsp; int tm_mday;&nbsp; /* day of the month&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- [1,31] */</TT>
<BR><TT>&nbsp; int tm_mon;&nbsp;&nbsp; /* months since January&nbsp;&nbsp;&nbsp;&nbsp; -- [0,11] */</TT>
<BR><TT>&nbsp; int tm_year;&nbsp; /* years since 1900&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp; int tm_wday;&nbsp; /* days since Sunday&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- [0,6]&nbsp; */</TT>
<BR><TT>&nbsp; int tm_yday;&nbsp; /* days since January 1&nbsp;&nbsp;&nbsp;&nbsp; -- [0,365]*/</TT>
<BR><TT>&nbsp; int tm_isdst; /* Daylight Savings Time flag */</TT>
<BR><TT>};</TT>
</DL>
<DL>
<DT>Safer C:
<DD>The Safer C Library extension provides the <A HREF="#gmtime_s">gmtime_s</A> function which is a safer alternative to<TT> gmtime</TT>
This newer<TT> gmtime_s</TT> function is recommended to be used instead of the traditional &quot;unsafe&quot;<TT> gmtime</TT>
function.
</DL>
<DL>
<DT>Description:
<DD>The<TT> gmtime</TT> functions convert the calendar time pointed to by<B> timer</B> into a broken-down time, expressed as Coordinated
Universal Time (UTC) (formerly known as Greenwich Mean Time, or GMT).
<BR><BR>The function <TT> _gmtime</TT> places the converted time in the <TT> tm</TT> structure pointed to by<B> tmbuf</B>,
and the<TT> gmtime</TT> function places the converted time in a static structure that is re-used each time<TT> gmtime</TT>
is called.
<BR><BR>The time set on the computer with the DOS<TT> time</TT> command and the DOS<TT> date</TT> command reflects the local
time.&nbsp; The environment variable<TT> TZ</TT> is used to establish the time zone to which this local time applies.&nbsp;
See the section<B> The TZ Environment Variable</B> for a discussion of how to set the time zone.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> gmtime</TT> functions return a pointer to a structure containing the broken-down time.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#asctime">asctime</A> Functions, <A HREF="#asctime_s">asctime_s</A>, <A HREF="#clock">clock</A>, <A HREF="#ctime">ctime</A>
Functions, <A HREF="#ctime_s">ctime_s</A>, <A HREF="#difftime">difftime</A>, <A HREF="#gmtime_s">gmtime_s</A>, <A HREF="#localtime">localtime</A>,
<A HREF="#localtime_s">localtime_s</A>, <A HREF="#mktime">mktime</A>, <A HREF="#strftime">strftime</A>, <A HREF="#time">time</A>,
<A HREF="#tzset">tzset</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;time.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; time_t time_of_day;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; auto char buf[26];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; auto struct tm tmbuf;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; time_of_day = time( NULL );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _gmtime( &amp;time_of_day, &amp;tmbuf );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;It is now: %.24s GMT\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _asctime( &amp;tmbuf, buf ) );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>It is now: Fri Dec 25 15:58:27 1987 GMT</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>_gmtime is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> gmtime - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_gmtime - All, Linux, RDOS</TT>
</DL>
<H2 ID="gmtime_s"> gmtime_s </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__ 1</TT>
<BR><TT>#include &lt;time.h&gt;</TT>
<BR><TT>struct tm * gmtime_s( const time_t * restrict timer,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; struct tm * restrict result );</TT>
<BR><BR><TT>struct&nbsp; tm {</TT>
<BR><TT>&nbsp; int tm_sec;&nbsp;&nbsp; /* seconds after the minute -- [0,61] */</TT>
<BR><TT>&nbsp; int tm_min;&nbsp;&nbsp; /* minutes after the hour&nbsp;&nbsp; -- [0,59] */</TT>
<BR><TT>&nbsp; int tm_hour;&nbsp; /* hours after midnight&nbsp;&nbsp;&nbsp;&nbsp; -- [0,23] */</TT>
<BR><TT>&nbsp; int tm_mday;&nbsp; /* day of the month&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- [1,31] */</TT>
<BR><TT>&nbsp; int tm_mon;&nbsp;&nbsp; /* months since January&nbsp;&nbsp;&nbsp;&nbsp; -- [0,11] */</TT>
<BR><TT>&nbsp; int tm_year;&nbsp; /* years since 1900&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp; int tm_wday;&nbsp; /* days since Sunday&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- [0,6]&nbsp; */</TT>
<BR><TT>&nbsp; int tm_yday;&nbsp; /* days since January 1&nbsp;&nbsp;&nbsp;&nbsp; -- [0,365]*/</TT>
<BR><TT>&nbsp; int tm_isdst; /* Daylight Savings Time flag */</TT>
<BR><TT>};</TT>
</DL>
<DL>
<DT>Constraints:
<DD>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<TT>
gmtime_s</TT> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<BR><BR>Neither<B> timer</B> nor<B> result</B> shall be a null pointer.&nbsp; If there is a runtime-constraint violation,
there is no attempt to convert the time.
</DL>
<DL>
<DT>Description:
<DD>The<TT> gmtime_s</TT> function converts the calendar time pointed to by<B> timer</B> into a broken-down time, expressed as
UTC.&nbsp; The broken-down time is stored in the structure pointed to by<B> result</B>.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> gmtime_s</TT> function returns<B> result</B>, or a null pointer if the specified time cannot be converted to UTC or
there is a runtime-constraint violation.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#asctime">asctime</A> Functions, <A HREF="#asctime_s">asctime_s</A>, <A HREF="#clock">clock</A>, <A HREF="#ctime">ctime</A>
Functions, <A HREF="#ctime_s">ctime_s</A>, <A HREF="#difftime">difftime</A>, <A HREF="#gmtime">gmtime</A>, <A HREF="#localtime">localtime</A>,
<A HREF="#localtime_s">localtime_s</A>, <A HREF="#mktime">mktime</A>, <A HREF="#strftime">strftime</A>, <A HREF="#time">time</A>,
<A HREF="#tzset">tzset</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__ 1</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;time.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; time_t time_of_day;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; auto char buf[26];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; auto struct tm tmbuf;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; time_of_day = time( NULL );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; gmtime_s( &amp;time_of_day, &amp;tmbuf );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; asctime_s( buf, sizeof( buf ), &amp;tmbuf );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;It is now: %.24s GMT\n&quot;, buf );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>It is now: Thu Jan 31 15:12:27 2006 GMT</TT>
</DL>
<DL>
<DT>Classification:
<DD>TR 24731
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, Linux, RDOS, Netware
</DL>
<H2 ID="_grow_handles"> _grow_handles </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>int _grow_handles( int new_count );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _grow_handles</TT> function increases the number of POSIX level files that are allowed to be open at one time.&nbsp;
The parameter<B> new_count</B> is the new requested number of files that are allowed to be opened.&nbsp; The return value
is the number that is allowed to be opened after the call.&nbsp; This may be less than, equal to, or greater than the number
requested.&nbsp; If the number is less than, an error has occurred and the errno variable should be consulted for the reason.
&nbsp;If the number returned is greater than or equal to the number requested, the call was successful.
<BR><BR>Note that even if<TT> _grow_handles</TT> returns successfully, you still might not be able to open the requested number
of files due to some system limit (e.g.&nbsp; FILES= in the CONFIG.SYS file under DOS) or because some file handles are already
in use (stdin, stdout, stderr, etc.).
<BR><BR>The number of file handles that the run-time system can open by default is described by <TT> _NFILES</TT> in<TT> &lt;stdio.h&gt;</TT>
but this can be changed by the application developer.&nbsp; To change the number of file handles available during execution,
follow the steps outlined below.
<OL>
<LI>Let<TT> n</TT> represent the number of files to be opened concurrently.&nbsp; Ensure that the <B> stdin,</B> <B> stdout,</B>
and <B> stderr</B> files are included in the count.&nbsp; Also include <B> stdaux</B> and <B> stdprn</B> files in the count
for some versions of DOS.&nbsp; The<B> stdaux</B> and<B> stdprn</B> files are not available for Win32.
<LI>For DOS-based systems, change the<TT> CONFIG.SYS</TT> file to include &quot;FILES=n&quot; where &quot;n&quot; is the number
of file handles required by the application plus an additional 5 handles for the standard files.&nbsp; The number of standard
files that are opened by DOS varies from 3 to 5 depending on the version of DOS that you are using.
<BR><BR>If you are running a network such as Novell's NetWare, this will also affect the number of available file handles.
&nbsp;In this case, you may have to increase the number specified in the &quot;FILES=n&quot; statement.
<LI>Add a call to<TT> _grow_handles</TT> in your application similar to that shown in the example below.
</OL>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _grow_handles</TT> function returns the maximum number of file handles which the run-time system can accommodate.
&nbsp;This number can exceed an operating system limit such as that imposed by the &quot;FILES=&quot; statement under DOS.
&nbsp;This limit will be the determining factor in how many files can be open concurrently.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_dos_open">_dos_open</A>, <A HREF="#fdopen">fdopen</A>, <A HREF="#fileno">fileno</A>, <A HREF="#fopen">fopen</A>,
<A HREF="#freopen">freopen</A>, <A HREF="#_fsopen">_fsopen</A>, <A HREF="#_hdopen">_hdopen</A>, <A HREF="#open">open</A>,
<A HREF="#_open_osfhandle">_open_osfhandle</A>, <A HREF="#_popen">_popen</A>, <A HREF="#sopen">sopen</A>, <A HREF="#tmpfile">tmpfile</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>FILE *fp[ 50 ];</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int hndl_count;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; hndl_count = _NFILES;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( hndl_count &lt; 50 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hndl_count = _grow_handles( 50 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; hndl_count; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fp[ i ] = tmpfile();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( fp[ i ] == NULL ) break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;File %d successfully opened\n&quot;, i );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%d files were successfully opened\n&quot;, i );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>All, Linux
</DL>
<H2 ID="_grstatus"> _grstatus </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>short _FAR _grstatus( void );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _grstatus</TT> function returns the status of the most recently called graphics library function.&nbsp; The function
can be called after any graphics function to determine if any errors or warnings occurred.&nbsp; The function returns 0 if
the previous function was successful.&nbsp; Values less than 0 indicate an error occurred; values greater than 0 indicate
a warning condition.
<BR><BR>The following values can be returned:&nbsp; uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 uindex=2
uindex=2 uindex=2 
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Constant&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Value
&nbsp;Explanation</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _GROK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp; no error</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _GRERROR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-1&nbsp;&nbsp;&nbsp; graphics error</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _GRMODENOTSUPPORTED&nbsp;&nbsp;&nbsp; -2&nbsp;&nbsp;&nbsp; video mode not supported</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _GRNOTINPROPERMODE&nbsp;&nbsp;&nbsp;&nbsp; -3&nbsp;&nbsp;&nbsp; function n/a in this mode</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _GRINVALIDPARAMETER&nbsp;&nbsp;&nbsp; -4&nbsp;&nbsp;&nbsp; invalid parameter(s)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _GRINSUFFICIENTMEMORY&nbsp; -5&nbsp;&nbsp;&nbsp; out of memory</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _GRFONTFILENOTFOUND&nbsp;&nbsp;&nbsp; -6&nbsp;&nbsp;&nbsp; can't open font file</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _GRINVALIDFONTFILE&nbsp;&nbsp;&nbsp;&nbsp; -7&nbsp;&nbsp;&nbsp; font file has invalid format</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _GRNOOUTPUT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;
&nbsp; nothing was done</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _GRCLIPPED&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
2&nbsp;&nbsp;&nbsp; output clipped</TT>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _grstatus</TT> function returns the status of the most recently called graphics library function.
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int x, y;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; while( _grstatus() == _GROK ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = rand() % 700;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y = rand() % 500;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _setpixel( x, y );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_grtext"> _grtext, _grtext_w </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>short _FAR _grtext( short x, short y,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
char _FAR *text );</TT>
<BR><BR><TT>short _FAR _grtext_w( double x, double y,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; char _FAR *text );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _grtext</TT> functions display a character string.&nbsp; The<TT> _grtext</TT> function uses the view coordinate system.
&nbsp;The<TT> _grtext_w</TT> function uses the window coordinate system.
<BR><BR>The character string<B> text</B> is displayed at the point<TT> (x,y).</TT>&nbsp; The string must be terminated by
a null character ('\0').&nbsp; The text is displayed in the current color using the current text settings.
<BR><BR>The graphics library can display text in three different ways.
<OL>
<LI>The <TT> _outtext</TT> and <TT> _outmem</TT> functions can be used in any video mode.&nbsp; However, this variety of text
can be displayed in only one size.
<LI>The <TT> _grtext</TT> function displays text as a sequence of line segments, and can be drawn in different sizes, with
different orientations and alignments.
<LI>The <TT> _outgtext</TT> function displays text in the currently selected font.&nbsp; Both bit-mapped and vector fonts
are supported; the size and type of text depends on the fonts that are available.
</OL>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _grtext</TT> functions return a non-zero value when the text was successfully drawn; otherwise, zero is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_outtext">_outtext</A>, <A HREF="#_outmem">_outmem</A>, <A HREF="#_outgtext">_outgtext</A>, <A HREF="#_setcharsize">_setcharsize</A>,
<A HREF="#_settextalign">_settextalign</A>, <A HREF="#_settextpath">_settextpath</A>, <A HREF="#_settextorient">_settextorient</A>,
<A HREF="#_setcharspacing">_setcharspacing</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _grtext( 200, 100, &quot; WATCOM&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _grtext( 200, 200, &quot;Graphics&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><IMG SRC="eg_grtxt.bmp" ALIGN=MIDDLE>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD><TT> _grtext - DOS</TT>
<BR><BR><TT>_grtext_w - DOS</TT>
</DL>
<H2 ID="halloc"> halloc </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;malloc.h&gt;</TT>
<BR><TT>void __huge *halloc( long int numb, size_t size );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> halloc</TT> function allocates space for an array of<B> numb</B> objects of<B> size</B> bytes each and initializes
each object to 0.&nbsp; When the size of the array is greater than 64K bytes, then the size of an array element must be a
power of 2 since an object could straddle a segment boundary.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> halloc</TT> function returns a far pointer (of type<TT> void huge *</TT>) to the start of the allocated memory.&nbsp;
The<TT> NULL</TT> value is returned if there is insufficient memory available.&nbsp; The<TT> NULL</TT> value is also returned
if the size of the array is greater than 64K bytes and the size of an array element is not a power of 2.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#calloc">calloc</A> Functions, <A HREF="#_expand">_expand</A> Functions, <A HREF="#free">free</A> Functions, <A HREF="#hfree">hfree</A>,
<A HREF="#malloc">malloc</A> Functions, <A HREF="#_msize">_msize</A> Functions, <A HREF="#realloc">realloc</A> Functions,
<A HREF="#sbrk">sbrk</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;malloc.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; long int __huge *big_buffer;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; big_buffer = (long int __huge *)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; halloc( 1024L,
sizeof(long) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( big_buffer == NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Unable to allocate memory\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* rest of code goes here */</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hfree( big_buffer );&nbsp; /* deallocate */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>DOS/16, Windows, OS/2 1.x(all)
</DL>
<H2 ID="_harderr"> _harderr, _hardresume, _hardretn </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><TT>void _harderr( int (__far *handler)() );</TT>
<BR><TT>void _hardresume( int action );</TT>
<BR><TT>void _hardretn( int error );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _harderr</TT> routine installs a critical error handler (for INT 0x24) to handle hardware errors.&nbsp; This critical
error handler will call the user-defined function specified by<B> handler</B> when a critical error occurs (for example, attempting
to open a file on a floppy disk when the drive door is open).&nbsp; The parameters to this function are as follows:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int handler( unsigned deverror,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned errcode,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned __far
*devhdr );</TT>
<BR><BR>The low-order byte of<B> errcode</B> can be one of the following values:
<DL>
<DT>Value&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>0x00
<DD>Attempt to write to a write-protected disk
<DT>0x01
<DD>Unknown unit
<DT>0x02
<DD>Drive not ready
<DT>0x03
<DD>Unknown command
<DT>0x04
<DD>CRC error in data
<DT>0x05
<DD>Bad drive-request structure length
<DT>0x06
<DD>Seek error
<DT>0x07
<DD>Unknown media type
<DT>0x08
<DD>Sector not found
<DT>0x09
<DD>Printer out of paper
<DT>0x0A
<DD>Write fault
<DT>0x0B
<DD>Read fault
<DT>0x0C
<DD>General failure
</DL>
<BR>The<B> devhdr</B> argument points to a device header control-block that contains information about the device on which
the error occurred.&nbsp; Your error handler may inspect the information in this control-block but must not change it.
<BR><BR>If the error occurred on a disk device, bit 15 of the<B> deverror</B> argument will be 0 and the<B> deverror</B> argument
will indicate the following:
<DL>
<DT>Bit&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>bit 15
<DD>0 indicates disk error
<DT>bit 14
<DD>not used
<DT>bit 13
<DD>0 indicates &quot;Ignore&quot; response not allowed
<DT>bit 12
<DD>0 indicates &quot;Retry&quot; response not allowed
<DT>bit 11
<DD>0 indicates &quot;Fail&quot; response not allowed
<DT>bit 9,10
<DD>location of error
<DL>
<DT>Value&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>00
<DD>MS-DOS
<DT>01
<DD>File Allocation Table (FAT)
<DT>10
<DD>Directory
<DT>11
<DD>Data area
</DL>
<DT>bit 8
<DD>0 indicates read error, 1 indicates write error
</DL>
<BR>The low-order byte of<B> deverror</B> indicates the drive where the error occurred; (0 = drive A, 1 = drive B, etc.).
<BR><BR>The handler is very restricted in the type of system calls that it can perform.&nbsp; System calls 0x01 through 0x0C,
and 0x59 are the only system calls allowed to be issued by the handler.&nbsp; Therefore, many of the standard C run-time functions
such as stream I/O and low-level I/O cannot be used by the handler.&nbsp; Console I/O is allowed (e.g., cprintf, cputs).
<BR><BR>The handler must indicate what action to take by returning one of the following values or calling <TT> _hardresume</TT>
with one of the following values:
<DL>
<DT>Value&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>_HARDERR_IGNORE
<DD>Ignore the error
<DT>_HARDERR_RETRY
<DD>Retry the operation
<DT>_HARDERR_ABORT
<DD>Abort the program issuing INT 0x23
<DT>_HARDERR_FAIL
<DD>Fail the system call that is in progress (DOS 3.0 or higher)
</DL>
<BR>Alternatively, the handler can return directly to the application program rather than returning to DOS by using the <TT>
_hardretn</TT> function.&nbsp; The application program resumes at the point just after the failing I/O function request.&nbsp;
The <TT> _hardretn</TT> function should be called only from within a user-defined hardware error-handler function.
<BR><BR>The<B> error</B> argument of <TT> _hardretn</TT> should be a DOS error code.&nbsp; See<B> The MS-DOS Encyclopedia</B>
or<B> Programmer's PC Sourcebook, 2nd Edition,</B> for more detailed information on DOS error codes that may be returned by
a given DOS function call.
<BR><BR>If the failing I/O function request is an INT 0x21 function greater than or equal to function 0x38, <TT> _hardretn</TT>
will return to the application with the carry flag set and the AX register set to the <TT> _hardretn</TT><B> error</B> argument.
&nbsp;If the failing INT 0x21 function request is less than function 0x38 abd the function can return an error, the AL register
will be set to 0xFF on return to the application.&nbsp; If the failing INT 0x21 function does not have a way of returning
an error condition (which is true of certain INT 0x21 functions below 0x38), the<B> error</B> argument of <TT> _hardretn</TT>
is not used, and no error code is returned to the application.
</DL>
<DL>
<DT>Returns:
<DD>These functions do not return a value.&nbsp; The <TT> _hardresume</TT> and <TT> _hardretn</TT> functions do not return to
the caller.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_chain_intr">_chain_intr</A>, <A HREF="#_dos_getvect">_dos_getvect</A>, <A HREF="#_dos_setvect">_dos_setvect</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><BR><TT>#if defined(__DOS__) &amp;&amp; defined(__386__)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; #define FAR __far</TT>
<BR><TT>#else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; #if defined(__386__)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #define FAR</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; #else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #define FAR __far</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; #endif</TT>
<BR><TT>#endif</TT>
<BR><BR><TT>int FAR critical_error_handler( unsigned deverr,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned errcode,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned FAR *devhdr )</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; cprintf( &quot;Critical error: &quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; cprintf( &quot;deverr=%4.4X errcode=%d\r\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; deverr, errcode );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; cprintf( &quot;devhdr = %Fp\r\n&quot;, devhdr );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; return( _HARDERR_IGNORE );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR><TT>main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FILE *fp;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _harderr( critical_error_handler );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fp = fopen( &quot;a:tmp.tmp&quot;, &quot;r&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;fp = %p\n&quot;, fp );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>Critical error: deverr=1A00 errcode=2</TT>
<BR><TT>devhdr = 0070:01b6</TT>
<BR><TT>fp = 0000</TT>
</DL>
<DL>
<DT>Classification:
<DD>DOS
</DL>
<DL>
<DT>Systems:
<DD><TT> _harderr - DOS</TT>
<BR><BR><TT>_hardresume - DOS</TT>
<BR><TT>_hardretn - DOS/16</TT>
</DL>
<H2 ID="_hdopen"> _hdopen </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;io.h&gt;</TT>
<BR><TT>int _hdopen( int os_handle, int mode );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _hdopen</TT> function takes a previously opened operating system file handle specified by<B> os_handle</B> and opened
with access and sharing specified by<B> mode</B>, and creates a POSIX-style file handle.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _hdopen</TT> function returns the new POSIX-style file handle if successful.&nbsp; Otherwise, it returns -1.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#close">close</A>, <A HREF="#_dos_open">_dos_open</A>, <A HREF="#fdopen">fdopen</A>, <A HREF="#fopen">fopen</A>,
<A HREF="#freopen">freopen</A>, <A HREF="#_fsopen">_fsopen</A>, <A HREF="#_grow_handles">_grow_handles</A>, <A HREF="#open">open</A>,
<A HREF="#_open_osfhandle">_open_osfhandle</A>, <A HREF="#_os_handle">_os_handle</A>, <A HREF="#_popen">_popen</A>, <A HREF="#sopen">sopen</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><TT>#include &lt;fcntl.h&gt;</TT>
<BR><TT>#include &lt;io.h&gt;</TT>
<BR><TT>#include &lt;windows.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; HANDLE os_handle;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; DWORD desired_access, share_mode;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int handle;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; os_handle = CreateFileA( &quot;file&quot;, GENERIC_WRITE,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, NULL, CREATE_ALWAYS,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FILE_ATTRIBUTE_NORMAL, NULL );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; if( os_handle == INVALID_HANDLE_VALUE ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Unable to open file\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handle = _hdopen( os_handle, O_RDONLY );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( handle != -1 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write( handle, &quot;hello\n&quot;, 6 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close( handle );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CloseHandle( os_handle );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, Netware
</DL>
<H2 ID="_heapchk"> _heapchk Functions </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;malloc.h&gt;</TT>
<BR><TT>int&nbsp; _heapchk( void );</TT>
<BR><TT>int _bheapchk( __segment seg );</TT>
<BR><TT>int _fheapchk( void );</TT>
<BR><TT>int _nheapchk( void );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _heapchk</TT> functions along with <TT> _heapset</TT> and <TT> _heapwalk</TT> are provided for debugging heap related
problems in programs.
<BR><BR>The<TT> _heapchk</TT> functions perform a consistency check on the unallocated memory space or &quot;heap&quot;.&nbsp;
The consistency check determines whether all the heap entries are valid.&nbsp; Each function checks a particular heap, as
listed below:
<DL>
<DT>Function&nbsp;&nbsp;&nbsp;&nbsp; Heap Checked
<DT>_heapchk
<DD>Depends on data model of the program
<DT>_bheapchk
<DD>Based heap specified by<B> seg</B> value; <TT> _NULLSEG</TT> specifies all based heaps
<DT>_fheapchk
<DD>Far heap (outside the default data segment)
<DT>_nheapchk
<DD>Near heap (inside the default data segment)
</DL>
<BR>In a small data memory model, the<TT> _heapchk</TT> function is equivalent to the <TT> _nheapchk</TT> function; in a large
data memory model, the<TT> _heapchk</TT> function is equivalent to the <TT> _fheapchk</TT> function.
</DL>
<DL>
<DT>Returns:
<DD>All four functions return one of the following manifest constants which are defined in<TT> &lt;malloc.h&gt;.</TT>
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>_HEAPOK
<DD>The heap appears to be consistent.
<DT>_HEAPEMPTY
<DD>The heap is empty.
<DT>_HEAPBADBEGIN
<DD>The heap has been damaged.
<DT>_HEAPBADNODE
<DD>The heap contains a bad node, or is damaged.
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_heapenable">_heapenable</A>, <A HREF="#_heapgrow">_heapgrow</A>, <A HREF="#_heapmin">_heapmin</A>, <A HREF="#_heapset">_heapset</A>,
<A HREF="#_heapshrink">_heapshrink</A>, <A HREF="#_heapwalk">_heapwalk</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;malloc.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char *buffer;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; buffer = (char *)malloc( 80 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; malloc( 1024 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; free( buffer );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; switch( _heapchk() ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; case _HEAPOK:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;OK - heap is good\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; case _HEAPEMPTY:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;OK - heap is empty\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; case _HEAPBADBEGIN:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;ERROR - heap is damaged\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; case _HEAPBADNODE:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;ERROR - bad node in heap\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> _heapchk - All, Linux, RDOS</TT>
<BR><BR><TT>_bheapchk - DOS/16, Windows, OS/2 1.x(all)</TT>
<BR><TT>_fheapchk - DOS/16, Windows, OS/2 1.x(all)</TT>
<BR><TT>_nheapchk - DOS, Windows, Win386, Win32, OS/2 1.x, OS/2 1.x(MT), OS/2-32, Linux, RDOS</TT>
</DL>
<H2 ID="_heapenable"> _heapenable </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;malloc.h&gt;</TT>
<BR><TT>int _heapenable( int enabled );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _heapenable</TT> function is used to control attempts by the heap allocation manager to request more memory from the
operating system's memory pool.&nbsp; If<B> enabled</B> is 0 then all further allocations which would normally go to the operating
system for more memory will instead fail and return NULL.&nbsp; If<B> enabled</B> is 1 then requests for more memory from
the operating system's memory pool are re-enabled.
<BR><BR>This function can be used to impose a limit on the amount of system memory that is allocated by an application.&nbsp;
For example, if an application wishes to allocate no more than 200K bytes of memory, it could allocate 200K and immediately
free it.&nbsp; It can then call<TT> _heapenable</TT> to disable any further requests from the system memory pool.&nbsp; After
this, the application can allocate memory from the 200K pool that it has already obtained.
</DL>
<DL>
<DT>Returns:
<DD>The return value is the previous state of the system allocation flag.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_heapchk">_heapchk</A>, <A HREF="#_heapgrow">_heapgrow</A>, <A HREF="#_heapmin">_heapmin</A>, <A HREF="#_heapset">_heapset</A>,
<A HREF="#_heapshrink">_heapshrink</A>, <A HREF="#_heapwalk">_heapwalk</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;malloc.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char *p;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; p = malloc( 200*1024 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( p != NULL ) free( p );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _heapenable( 0 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /*</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; allocate memory from a pool that</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; has been capped at 200K</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS
</DL>
<H2 ID="_heapgrow"> _heapgrow Functions </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;malloc.h&gt;</TT>
<BR><TT>void&nbsp; _heapgrow( void );</TT>
<BR><TT>void _nheapgrow( void );</TT>
<BR><TT>void _fheapgrow( void );</TT>
</DL>
<DL>
<DT>Description:
<DD>The <TT> _nheapgrow</TT> function attempts to grow the near heap to the maximum size of 64K.&nbsp; You will want to do this
in the small data models if you are using both <TT> malloc</TT> and <TT> _fmalloc</TT> or <TT> halloc</TT>.&nbsp; Once a call
to <TT> _fmalloc</TT> or <TT> halloc</TT> has been made, you may not be able to allocate any memory with <TT> malloc</TT>
unless space has been reserved for the near heap using either <TT> malloc</TT>, <TT> sbrk</TT> or <TT> _nheapgrow</TT>.
<BR><BR>The <TT> _fheapgrow</TT> function doesn't do anything to the heap because the far heap will be extended automatically
when needed.&nbsp; If the current far heap cannot be extended, then another far heap will be started.
<BR><BR>In a small data memory model, the<TT> _heapgrow</TT> function is equivalent to the <TT> _nheapgrow</TT> function;
in a large data memory model, the<TT> _heapgrow</TT> function is equivalent to the <TT> _fheapgrow</TT> function.
</DL>
<DL>
<DT>Returns:
<DD>These functions do not return a value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_heapchk">_heapchk</A>, <A HREF="#_heapenable">_heapenable</A>, <A HREF="#_heapmin">_heapmin</A>, <A HREF="#_heapset">_heapset</A>,
<A HREF="#_heapshrink">_heapshrink</A>, <A HREF="#_heapwalk">_heapwalk</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;malloc.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char *p, *fmt_string;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fmt_string = &quot;Amount of memory available is %u\n&quot;;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( fmt_string, _memavl() );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _nheapgrow();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( fmt_string, _memavl() );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; p = (char *) malloc( 2000 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( fmt_string, _memavl() );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>Amount of memory available is 0</TT>
<BR><TT>Amount of memory available is 62732</TT>
<BR><TT>Amount of memory available is 60730</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> _heapgrow - All, Linux, RDOS</TT>
<BR><BR><TT>_fheapgrow - DOS/16, Windows, OS/2 1.x(all)</TT>
<BR><TT>_nheapgrow - DOS, Windows, Win386, Win32, OS/2 1.x, OS/2 1.x(MT), OS/2-32, Linux, RDOS</TT>
</DL>
<H2 ID="_heapmin"> _heapmin Functions </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;malloc.h&gt;</TT>
<BR><TT>int&nbsp; _heapmin( void );</TT>
<BR><TT>int _bheapmin( __segment seg );</TT>
<BR><TT>int _fheapmin( void );</TT>
<BR><TT>int _nheapmin( void );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _heapmin</TT> functions attempt to shrink the specified heap to its smallest possible size by returning all free entries
at the end of the heap back to the system.&nbsp; This can be used to free up as much memory as possible before using the <TT>
system</TT> function or one of the <TT> spawn...</TT>&nbsp; functions.
<BR><BR>The various<TT> _heapmin</TT> functions shrink the following heaps:
<DL>
<DT>Function&nbsp;&nbsp;&nbsp;&nbsp; Heap Minimized
<DT>_heapmin
<DD>Depends on data model of the program
<DT>_bheapmin
<DD>Based heap specified by<B> seg</B> value;<TT> _NULLSEG</TT> specifies all based heaps
<DT>_fheapmin
<DD>Far heap (outside the default data segment)
<DT>_nheapmin
<DD>Near heap (inside the default data segment)
</DL>
<BR>In a small data memory model, the<TT> _heapmin</TT> function is equivalent to the <TT> _nheapmin</TT> function; in a large
data memory model, the<TT> _heapmin</TT> function is equivalent to the <TT> _fheapmin</TT> function.&nbsp; It is identical
to the <TT> _heapshrink</TT> function.
</DL>
<DL>
<DT>Returns:
<DD>These functions return zero if successful, and non-zero if some error occurred.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_heapchk">_heapchk</A>, <A HREF="#_heapenable">_heapenable</A>, <A HREF="#_heapgrow">_heapgrow</A>, <A HREF="#_heapset">_heapset</A>,
<A HREF="#_heapshrink">_heapshrink</A>, <A HREF="#_heapwalk">_heapwalk</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>#include &lt;malloc.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _heapmin();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; system( &quot;chdir c:\\watcomc&quot; );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>Note the use of two adjacent backslash characters (\) within character-string constants to signify a single backslash.
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> _heapmin - All, Linux, RDOS</TT>
<BR><BR><TT>_bheapmin - DOS/16, Windows, OS/2 1.x(all)</TT>
<BR><TT>_fheapmin - DOS/16, Windows, OS/2 1.x(all)</TT>
<BR><TT>_nheapmin - DOS, Windows, Win386, Win32, OS/2 1.x, OS/2 1.x(MT), OS/2-32, Linux, RDOS</TT>
</DL>
<H2 ID="_heapset"> _heapset Functions </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;malloc.h&gt;</TT>
<BR><TT>int&nbsp; _heapset( unsigned int fill_char );</TT>
<BR><TT>int _bheapset( __segment seg, unsigned int fill_char );</TT>
<BR><TT>int _fheapset( unsigned int fill_char );</TT>
<BR><TT>int _nheapset( unsigned int fill_char );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _heapset</TT> functions along with <TT> _heapchk</TT> and <TT> _heapwalk</TT> are provided for debugging heap related
problems in programs.
<BR><BR>The<TT> _heapset</TT> functions perform a consistency check on the unallocated memory space or &quot;heap&quot; just
as <TT> _heapchk</TT> does, and sets the heap's free entries with the<B> fill_char</B> value.
<BR><BR>Each function checks and sets a particular heap, as listed below:
<DL>
<DT>Function&nbsp;&nbsp;&nbsp;&nbsp; Heap Filled
<DT>_heapset
<DD>Depends on data model of the program
<DT>_bheapset
<DD>Based heap specified by<B> seg</B> value;<TT> _NULLSEG</TT> specifies all based heaps
<DT>_fheapset
<DD>Far heap (outside the default data segment)
<DT>_nheapset
<DD>Near heap (inside the default data segment)
</DL>
<BR>In a small data memory model, the<TT> _heapset</TT> function is equivalent to the <TT> _nheapset</TT> function; in a large
data memory model, the<TT> _heapset</TT> function is equivalent to the <TT> _fheapset</TT> function.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _heapset</TT> functions return one of the following manifest constants which are defined in<TT> &lt;malloc.h&gt;.</TT>
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>_HEAPOK
<DD>The heap appears to be consistent.
<DT>_HEAPEMPTY
<DD>The heap is empty.
<DT>_HEAPBADBEGIN
<DD>The heap has been damaged.
<DT>_HEAPBADNODE
<DD>The heap contains a bad node, or is damaged.
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_heapchk">_heapchk</A>, <A HREF="#_heapenable">_heapenable</A>, <A HREF="#_heapgrow">_heapgrow</A>, <A HREF="#_heapmin">_heapmin</A>,
<A HREF="#_heapshrink">_heapshrink</A>, <A HREF="#_heapwalk">_heapwalk</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;malloc.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int heap_status;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char *buffer;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; buffer = (char *)malloc( 80 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; malloc( 1024 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; free( buffer );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; heap_status = _heapset( 0xff );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; switch( heap_status ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; case _HEAPOK:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;OK - heap is good\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; case _HEAPEMPTY:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;OK - heap is empty\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; case _HEAPBADBEGIN:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;ERROR - heap is damaged\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; case _HEAPBADNODE:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;ERROR - bad node in heap\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> _heapset - All, Linux, RDOS</TT>
<BR><BR><TT>_bheapset - DOS/16, Windows, OS/2 1.x(all)</TT>
<BR><TT>_fheapset - DOS/16, Windows, OS/2 1.x(all)</TT>
<BR><TT>_nheapset - DOS, Windows, Win386, Win32, OS/2 1.x, OS/2 1.x(MT), OS/2-32, Linux, RDOS</TT>
</DL>
<H2 ID="_heapshrink"> _heapshrink Functions </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;malloc.h&gt;</TT>
<BR><TT>int&nbsp; _heapshrink( void );</TT>
<BR><TT>int _bheapshrink( __segment seg );</TT>
<BR><TT>int _fheapshrink( void );</TT>
<BR><TT>int _nheapshrink( void );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _heapshrink</TT> functions attempt to shrink the heap to its smallest possible size by returning all free entries
at the end of the heap back to the system.&nbsp; This can be used to free up as much memory as possible before using the <TT>
system</TT> function or one of the <TT> spawn...</TT>&nbsp; functions.
<BR><BR>The various<TT> _heapshrink</TT> functions shrink the following heaps:
<DL>
<DT>Function&nbsp;&nbsp;&nbsp;&nbsp; Heap Shrinked
<DT>_heapshrink
<DD>Depends on data model of the program
<DT>_bheapshrink
<DD>Based heap specified by<B> seg</B> value; <TT> _NULLSEG</TT> specifies all based heaps
<DT>_fheapshrink
<DD>Far heap (outside the default data segment)
<DT>_nheapshrink
<DD>Near heap (inside the default data segment)
</DL>
<BR>In a small data memory model, the<TT> _heapshrink</TT> function is equivalent to the <TT> _nheapshrink</TT> function;
in a large data memory model, the<TT> _heapshrink</TT> function is equivalent to the <TT> _fheapshrink</TT> function.&nbsp;
It is identical to the <TT> _heapmin</TT> function.
</DL>
<DL>
<DT>Returns:
<DD>These functions return zero if successful, and non-zero if some error occurred.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_heapchk">_heapchk</A>, <A HREF="#_heapenable">_heapenable</A>, <A HREF="#_heapgrow">_heapgrow</A>, <A HREF="#_heapmin">_heapmin</A>,
<A HREF="#_heapset">_heapset</A>, <A HREF="#_heapwalk">_heapwalk</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>#include &lt;malloc.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _heapshrink();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; system( &quot;chdir c:\\watcomc&quot; );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>Note the use of two adjacent backslash characters (\) within character-string constants to signify a single backslash.
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> _heapshrink - All, Linux, RDOS</TT>
<BR><BR><TT>_bheapshrink - DOS/16, Windows, OS/2 1.x(all)</TT>
<BR><TT>_fheapshrink - DOS/16, Windows, OS/2 1.x(all)</TT>
<BR><TT>_nheapshrink - DOS, Windows, Win386, Win32, OS/2 1.x, OS/2 1.x(MT), OS/2-32, Linux, RDOS</TT>
</DL>
<H2 ID="_heapwalk"> _heapwalk Functions </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;malloc.h&gt;</TT>
<BR><TT>int&nbsp; _heapwalk( struct _heapinfo *entry );</TT>
<BR><TT>int _bheapwalk( __segment seg, struct _heapinfo *entry );</TT>
<BR><TT>int _fheapwalk( struct _heapinfo *entry );</TT>
<BR><TT>int _nheapwalk( struct _heapinfo *entry );</TT>
<BR><BR><TT>struct _heapinfo {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; void __far *_pentry;&nbsp;&nbsp; /* heap pointer */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; size_t&nbsp;&nbsp;&nbsp;&nbsp; _size;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* heap entry size */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _useflag;&nbsp;&nbsp; /* heap entry 'in-use' flag
*/</TT>
<BR><TT>};</TT>
<BR><TT>#define _USEDENTRY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0</TT>
<BR><TT>#define _FREEENTRY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _heapwalk</TT> functions along with <TT> _heapchk</TT> and <TT> _heapset</TT> are provided for debugging heap related
problems in programs.
<BR><BR>The<TT> _heapwalk</TT> functions walk through the heap, one entry per call, updating the <TT> _heapinfo</TT> structure
with information on the next heap entry.&nbsp; The structure is defined in<TT> &lt;malloc.h&gt;.</TT>&nbsp; You must initialize
the<B> _pentry</B> field with<TT> NULL</TT> to start the walk through the heap.
<BR><BR>Each function walks a particular heap, as listed below:
<DL>
<DT>Function&nbsp;&nbsp;&nbsp;&nbsp; Heap Walked
<DT>_heapwalk
<DD>Depends on data model of the program
<DT>_bheapwalk
<DD>Based heap specified by<B> seg</B> value;<TT> _NULLSEG</TT> specifies all based heaps
<DT>_fheapwalk
<DD>Far heap (outside the default data segment)
<DT>_nheapwalk
<DD>Near heap (inside the default data segment)
</DL>
<BR>In a small data memory model, the<TT> _heapwalk</TT> function is equivalent to the <TT> _nheapwalk</TT> function; in a
large data memory model, the<TT> _heapwalk</TT> function is equivalent to the <TT> _fheapwalk</TT> function.
</DL>
<DL>
<DT>Returns:
<DD>These functions return one of the following manifest constants which are defined in<TT> &lt;malloc.h&gt;.</TT>
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>_HEAPOK
<DD>The heap is OK so far, and the <TT> _heapinfo</TT> structure contains information about the next entry in the heap.
<DT>_HEAPEMPTY
<DD>The heap is empty.
<DT>_HEAPBADPTR
<DD>The <TT> _pentry</TT> field of the<B> entry</B> structure does not contain a valid pointer into the heap.
<DT>_HEAPBADBEGIN
<DD>The header information for the heap was not found or has been damaged.
<DT>_HEAPBADNODE
<DD>The heap contains a bad node, or is damaged.
<DT>_HEAPEND
<DD>The end of the heap was reached successfully.
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_heapchk">_heapchk</A>, <A HREF="#_heapenable">_heapenable</A>, <A HREF="#_heapgrow">_heapgrow</A>, <A HREF="#_heapmin">_heapmin</A>,
<A HREF="#_heapset">_heapset</A>, <A HREF="#_heapshrink">_heapshrink</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;malloc.h&gt;</TT>
<BR><BR><TT>heap_dump()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct _heapinfo h_info;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int heap_status;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; h_info._pentry = NULL;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for(;;) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; heap_status = _heapwalk( &amp;h_info );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( heap_status != _HEAPOK ) break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;&nbsp; %s block at %Fp of size %4.4X\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (h_info._useflag == _USEDENTRY ? &quot;USED&quot; : &quot;FREE&quot;),</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; h_info._pentry, h_info._size );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; switch( heap_status ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; case _HEAPEND:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;OK - end of heap\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; case _HEAPEMPTY:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;OK - heap is empty\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; case _HEAPBADBEGIN:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;ERROR - heap is damaged\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; case _HEAPBADPTR:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;ERROR - bad pointer to heap\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; case _HEAPBADNODE:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;ERROR - bad node in heap\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char *p;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; heap_dump();&nbsp;&nbsp; p = (char *) malloc( 80 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; heap_dump();&nbsp;&nbsp; free( p );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; heap_dump();</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR>On 16-bit 80x86 systems, the following output is produced:
<BR><BR><TT>OK - heap is empty</TT>
<BR><TT>&nbsp; USED block at 23f8:0ab6 of size 0202</TT>
<BR><TT>&nbsp; USED block at 23f8:0cb8 of size 0052</TT>
<BR><TT>&nbsp; FREE block at 23f8:0d0a of size 1DA2</TT>
<BR><TT>OK - end of heap</TT>
<BR><TT>&nbsp; USED block at 23f8:0ab6 of size 0202</TT>
<BR><TT>&nbsp; FREE block at 23f8:0cb8 of size 1DF4</TT>
<BR><TT>OK - end of heap</TT>
<BR><BR>On 32-bit 80386/486 systems, the following output is produced:
<BR><BR><TT>OK - heap is empty</TT>
<BR><TT>&nbsp; USED block at 0014:00002a7c of size 0204</TT>
<BR><TT>&nbsp; USED block at 0014:00002c80 of size 0054</TT>
<BR><TT>&nbsp; FREE block at 0014:00002cd4 of size 1D98</TT>
<BR><TT>OK - end of heap</TT>
<BR><TT>&nbsp; USED block at 0014:00002a7c of size 0204</TT>
<BR><TT>&nbsp; FREE block at 0014:00002c80 of size 1DEC</TT>
<BR><TT>OK - end of heap</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> _heapwalk - All, Linux, RDOS</TT>
<BR><BR><TT>_bheapwalk - DOS/16, Windows, OS/2 1.x(all)</TT>
<BR><TT>_fheapwalk - DOS/16, Windows, OS/2 1.x(all)</TT>
<BR><TT>_nheapwalk - DOS, Windows, Win386, Win32, OS/2 1.x, OS/2 1.x(MT), OS/2-32, Linux, RDOS</TT>
</DL>
<H2 ID="hfree"> hfree </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;malloc.h&gt;</TT>
<BR><TT>void hfree( void __huge *ptr );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> hfree</TT> function deallocates a memory block previously allocated by the <TT> halloc</TT> function.&nbsp; The argument<B>
ptr</B> points to a memory block to be deallocated.&nbsp; After the call, the freed block is available for allocation.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> hfree</TT> function returns no value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#calloc">calloc</A> Functions, <A HREF="#_expand">_expand</A> Functions, <A HREF="#free">free</A> Functions, <A HREF="#halloc">halloc</A>,
<A HREF="#malloc">malloc</A> Functions, <A HREF="#_msize">_msize</A> Functions, <A HREF="#realloc">realloc</A> Functions,
<A HREF="#sbrk">sbrk</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;malloc.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; long int __huge *big_buffer;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; big_buffer = (long int __huge *)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; halloc( 1024L,
sizeof(long) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( big_buffer == NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Unable to allocate memory\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* rest of code goes here */</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hfree( big_buffer );&nbsp; /* deallocate */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>DOS/16, Windows, OS/2 1.x(all)
</DL>
<H2 ID="hypot"> hypot </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>double hypot( double x, double y );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> hypot</TT> function computes the length of the hypotenuse of a right triangle whose sides are<B> x</B> and<B> y</B>
adjacent to that right angle.&nbsp; The calculation is equivalent to
<BR><BR><TT>&nbsp;&nbsp;&nbsp; sqrt( x*x + y*y )</TT>
<BR><BR>The computation may cause an overflow, in which case the <TT> matherr</TT> function will be invoked.
</DL>
<DL>
<DT>Returns:
<DD>The value of the hypotenuse is returned.&nbsp; When an error has occurred, <TT> errno</TT> contains a value indicating the
type of error that has been detected.
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, hypot( 3.0, 4.0 ) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>5.000000</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>Math
</DL>
<H2 ID="ignore_handler_s"> ignore_handler_s </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__ 1</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>void ignore_handler_s(</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char * restrict msg,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void * restrict ptr,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; errno_t error );</TT>
</DL>
<DL>
<DT>Description:
<DD>A pointer to the<TT> ignore_handler_s</TT> function may be passed as an argument to the<TT> set_constraint_handler_s</TT>
function.&nbsp; The<TT> ignore_handler_s</TT> function simply returns to its caller.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> ignore_handler_s</TT> function does not returns no value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#abort_handler_s">abort_handler_s</A>, <A HREF="#set_constraint_handler_s">set_constraint_handler_s</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__ 1</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; constraint_handler_t&nbsp;&nbsp;&nbsp; old_handler;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; old_handler =</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set_constraint_handler_s( ignore_handler_s );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( getenv_s( NULL, NULL, 0, NULL ) ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;getenv_s failed\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; set_constraint_handler_s( old_handler );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>getenv_s failed</TT>
</DL>
<DL>
<DT>Classification:
<DD>TR 24731
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="ilogb"> ilogb </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>int ilogb( double x );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> ilogb</TT> function returns the exponent portion of the argument<B> x</B> as an int.
</DL>
<DL>
<DT>Returns:
<DD>If successful, the return value is the exponent of<B> x</B>.&nbsp; When the argument is zero, the function returns FP_ILOGB0.
&nbsp;When the argument is not-a-number, or NAN, the function returns FP_ILOGBNAN.&nbsp; For positive or negative infinity,
the function returns INT_MAX.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#logb">logb</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, ilogb( 1024.0 ) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>10</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C99
</DL>
<DL>
<DT>Systems:
<DD>Math
</DL>
<H2 ID="_imagesize"> _imagesize, _imagesize_w, _imagesize_wxy </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>long _FAR _imagesize( short x1, short y1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; short x2, short y2 );</TT>
<BR><BR><TT>long _FAR _imagesize_w( double x1, double y1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; double x2, double y2 );</TT>
<BR><BR><TT>long _FAR _imagesize_wxy( struct _wxycoord _FAR *p1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct _wxycoord _FAR *p2 );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _imagesize</TT> functions compute the number of bytes required to store a screen image.&nbsp; The<TT> _imagesize</TT>
function uses the view coordinate system.&nbsp; The<TT> _imagesize_w</TT> and<TT> _imagesize_wxy</TT> functions use the window
coordinate system.
<BR><BR>The screen image is the rectangular area defined by the points<TT> (x1,y1)</TT> and<TT> (x2,y2).</TT>&nbsp; The storage
area used by the <TT> _getimage</TT> functions must be at least this large (in bytes).
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _imagesize</TT> functions return the size of a screen image.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getimage">_getimage</A>, <A HREF="#_putimage">_putimage</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>#include &lt;malloc.h&gt;</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char *buf;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int y;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _ellipse( _GFILLINTERIOR, 100, 100, 200, 200 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; buf = (char*) malloc(</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _imagesize(
100, 100, 201, 201 ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( buf != NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _getimage( 100, 100, 201, 201, buf );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _putimage( 260, 200, buf, _GPSET );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _putimage( 420, 100, buf, _GPSET );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( y = 100; y &lt; 300; ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _putimage( 420, y, buf, _GXOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y += 20;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _putimage( 420, y, buf, _GXOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; free( buf );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD><TT> _imagesize - DOS</TT>
<BR><BR><TT>_imagesize_w - DOS</TT>
<BR><TT>_imagesize_wxy - DOS</TT>
</DL>
<H2 ID="imaxabs"> imaxabs </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;inttypes.h&gt;</TT>
<BR><TT>intmax_t imaxabs( intmax_t j );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> imaxabs</TT> function returns the absolute value of its maximum-size integer argument<B> j</B>.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> imaxabs</TT> function returns the absolute value of its argument.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#labs">labs</A>, <A HREF="#llabs">llabs</A>, <A HREF="#abs">abs</A>, <A HREF="#fabs">fabs</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;inttypes.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; intmax_t&nbsp;&nbsp;&nbsp; x, y;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; x = -500000000000;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; y = imaxabs( x );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;imaxabs(%jd) = %jd\n&quot;, x, y );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>imaxabs(-500000000000) = 500000000000</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C99
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="imaxdiv"> imaxdiv </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>imaxdiv_t imaxdiv( intmax_t numer, intmax_t denom );</TT>
<BR><BR><TT>typedef struct {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; intmax_t&nbsp;&nbsp;&nbsp; quot;&nbsp; /* quotient */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; intmax_t&nbsp;&nbsp;&nbsp; rem;&nbsp;&nbsp; /* remainder */</TT>
<BR><TT>} imaxdiv_t;</TT>
</DL>
<DL>
<DT>Description:
<DD>The imaxdiv function calculates the quotient and remainder of the division of the numerator<B> numer</B> by the denominator<B>
denom</B>.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> imaxdiv</TT> function returns a structure of type <TT> imaxdiv_t</TT> that contains the fields <TT> quot</TT> and
<TT> rem</TT>, which are both of type<TT> intmax_t.</TT>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#div">div</A>, <A HREF="#ldiv">ldiv</A>, <A HREF="#lldiv">lldiv</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;inttypes.h&gt;</TT>
<BR><BR><TT>void print_time( intmax_t ticks )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; imaxdiv_t sec_ticks;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; imaxdiv_t min_sec;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; sec_ticks = imaxdiv( ticks, 1000000 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; min_sec&nbsp;&nbsp; = imaxdiv( sec_ticks.quot, 60 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;It took %jd minutes and %jd seconds\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; min_sec.quot, min_sec.rem );</TT>
<BR><TT>}</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; print_time( 9876543210 );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>It took 164 minutes and 36 seconds</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C99
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="inp"> inp </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>unsigned int inp( int port );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> inp</TT> function reads one byte from the 80x86 hardware port whose number is given by<B> port</B>.
<BR><BR>A hardware port is used to communicate with a device.&nbsp; One or two bytes can be read and/or written from each
port, depending upon the hardware.&nbsp; Consult the technical documentation for your computer to determine the port numbers
for a device and the expected usage of each port for a device.
</DL>
<DL>
<DT>Returns:
<DD>The value returned is the byte that was read.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#inpd">inpd</A>, <A HREF="#inpw">inpw</A>, <A HREF="#outp">outp</A>, <A HREF="#outpd">outpd</A>, <A HREF="#outpw">outpw</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* turn off speaker */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; outp( 0x61, inp( 0x61 ) &amp; 0xFC );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="inpd"> inpd </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>unsigned long inpd( int port );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> inpd</TT> function reads a double-word (four bytes) from the 80x86 hardware port whose number is given by<B> port</B>.
<BR><BR>A hardware port is used to communicate with a device.&nbsp; One or two bytes can be read and/or written from each
port, depending upon the hardware.&nbsp; Consult the technical documentation for your computer to determine the port numbers
for a device and the expected usage of each port for a device.
</DL>
<DL>
<DT>Returns:
<DD>The value returned is the double-word that was read.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#inp">inp</A>, <A HREF="#inpw">inpw</A>, <A HREF="#outp">outp</A>, <A HREF="#outpd">outpd</A>, <A HREF="#outpw">outpw</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#define DEVICE 34</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned long transmitted;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; transmitted = inpd( DEVICE );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>DOS/32, Win386, Win32, OS/2-32, Linux, RDOS, Netware
</DL>
<H2 ID="inpw"> inpw </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>unsigned int inpw( int port );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> inpw</TT> function reads a word (two bytes) from the 80x86 hardware port whose number is given by<B> port</B>.
<BR><BR>A hardware port is used to communicate with a device.&nbsp; One or two bytes can be read and/or written from each
port, depending upon the hardware.&nbsp; Consult the technical documentation for your computer to determine the port numbers
for a device and the expected usage of each port for a device.
</DL>
<DL>
<DT>Returns:
<DD>The value returned is the word that was read.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#inp">inp</A>, <A HREF="#inpd">inpd</A>, <A HREF="#outp">outp</A>, <A HREF="#outpd">outpd</A>, <A HREF="#outpw">outpw</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#define DEVICE 34</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned int transmitted;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; transmitted = inpw( DEVICE );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="int386"> int386 </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;i86.h&gt;</TT>
<BR><TT>int int386( int inter_no,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const union REGS *in_regs,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; union REGS *out_regs );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> int386</TT> function causes the computer's central processor (CPU) to be interrupted with an interrupt whose number
is given by<B> inter_no</B>.&nbsp; This function is present in the 386 C libraries and may be executed on 80386/486 systems.
&nbsp;Before the interrupt, the CPU registers are loaded from the structure located by<B> in_regs</B>.&nbsp; Following the
interrupt, the structure located by<B> out_regs</B> is filled with the contents of the CPU registers.&nbsp; These structures
may be located at the same location in memory.
<BR><BR>You should consult the technical documentation for the computer that you are using to determine the expected register
contents before and after the interrupt in question.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> int386</TT> function returns the value of the CPU EAX register after the interrupt.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#bdos">bdos</A>, <A HREF="#int386x">int386x</A>, <A HREF="#int86">int86</A>, <A HREF="#int86x">int86x</A>, <A HREF="#intdos">intdos</A>,
<A HREF="#intdosx">intdosx</A>, <A HREF="#intr">intr</A>, <A HREF="#intrf">intrf</A>, <A HREF="#segread">segread</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>/*</TT>
<BR><TT> * This example clears the screen on DOS</TT>
<BR><TT> */</TT>
<BR><TT>#include &lt;i86.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; union REGS&nbsp; regs;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; regs.w.cx = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; regs.w.dx = 0x1850;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; regs.h.bh = 7;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; regs.w.ax = 0x0600;</TT>
<BR><TT>#if defined(__386__) &amp;&amp; defined(__DOS__)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int386( 0x10, &amp;regs, &amp;regs );</TT>
<BR><TT>#else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int86( 0x10, &amp;regs, &amp;regs );</TT>
<BR><TT>#endif</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>DOS/32, Linux, RDOS, Netware
</DL>
<H2 ID="int386x"> int386x </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;i86.h&gt;</TT>
<BR><TT>int int386x( int inter_no,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const union REGS *in_regs,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; union REGS *out_regs,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct SREGS *seg_regs );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> int386x</TT> function causes the computer's central processor (CPU) to be interrupted with an interrupt whose number
is given by<B> inter_no</B>.&nbsp; This function is present in the 32-bit C libraries and may be executed on Intel 386 compatible
systems.&nbsp; Before the interrupt, the CPU registers are loaded from the structure located by<B> in_regs</B> and the DS,
ES, FS and GS segment registers are loaded from the structure located by<B> seg_regs</B>.&nbsp; All of the segment registers
must contain valid values.&nbsp; Failure to do so will cause a segment violation when running in protect mode.&nbsp; If you
don't care about a particular segment register, then it can be set to 0 which will not cause a segment violation.&nbsp; The
function <TT> segread</TT> can be used to initialize<B> seg_regs</B> to their current values.
<BR><BR>Following the interrupt, the structure located by<B> out_regs</B> is filled with the contents of the CPU registers.
&nbsp;The<B> in_regs</B> and<B> out_regs</B> structures may be located at the same location in memory.&nbsp; The original
values of the DS, ES, FS and GS registers are restored.&nbsp; The structure<B> seg_regs</B> is updated with the values of
the segment registers following the interrupt.
<BR><BR>You should consult the technical documentation for the computer that you are using to determine the expected register
contents before and after the interrupt in question.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> int386x</TT> function returns the value of the CPU EAX register after the interrupt.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#bdos">bdos</A>, <A HREF="#int386">int386</A>, <A HREF="#int86">int86</A>, <A HREF="#int86x">int86x</A>, <A HREF="#intdos">intdos</A>,
<A HREF="#intdosx">intdosx</A>, <A HREF="#intr">intr</A>, <A HREF="#intrf">intrf</A>, <A HREF="#segread">segread</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;i86.h&gt;</TT>
<BR><BR><TT>/* get current mouse interrupt handler address */</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; union REGS r;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct SREGS s;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; s.ds = s.es = s.fs = s.gs = FP_SEG( &amp;s );</TT>
<BR><BR><TT>#if defined(__PHARLAP__)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; r.w.ax = 0x2503;&nbsp;&nbsp;&nbsp; /* get real-mode vector */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; r.h.cl = 0x33;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* interrupt vector 0x33 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int386( 0x21, &amp;r, &amp;r );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;mouse handler real-mode address=&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;%lx\n&quot;, r.x.ebx );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; r.w.ax = 0x2502;&nbsp;&nbsp;&nbsp; /* get protected-mode vector */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; r.h.cl = 0x33;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* interrupt vector 0x33 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int386x( 0x21, &amp;r, &amp;r, &amp;s );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;mouse handler protected-mode address=&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;%x:%lx\n&quot;, s.es, r.x.ebx );</TT>
<BR><BR><TT>#else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; r.h.ah = 0x35;&nbsp; /* get vector */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; r.h.al = 0x33;&nbsp; /* vector 0x33 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int386x( 0x21, &amp;r, &amp;r, &amp;s );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;mouse handler protected-mode address=&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;%x:%lx\n&quot;, s.es, r.x.ebx );</TT>
<BR><TT>#endif</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>DOS/32, Linux, RDOS, Netware
</DL>
<H2 ID="int86"> int86 </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;i86.h&gt;</TT>
<BR><TT>int int86( int inter_no,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const union REGS *in_regs,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; union REGS *out_regs );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> int86</TT> function causes the computer's central processor (CPU) to be interrupted with an interrupt whose number
is given by<B> inter_no</B>.&nbsp; Before the interrupt, the CPU registers are loaded from the structure located by<B> in_regs</B>.
&nbsp;Following the interrupt, the structure located by<B> out_regs</B> is filled with the contents of the CPU registers.
&nbsp;These structures may be located at the same location in memory.
<BR><BR>You should consult the technical documentation for the computer that you are using to determine the expected register
contents before and after the interrupt in question.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> int86</TT> function returns the value of the CPU AX register after the interrupt.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#bdos">bdos</A>, <A HREF="#int386">int386</A>, <A HREF="#int386x">int386x</A>, <A HREF="#int86x">int86x</A>, <A HREF="#intdos">intdos</A>,
<A HREF="#intdosx">intdosx</A>, <A HREF="#intr">intr</A>, <A HREF="#intrf">intrf</A>, <A HREF="#segread">segread</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>/*</TT>
<BR><TT> * This example clears the screen on DOS</TT>
<BR><TT> */</TT>
<BR><TT>#include &lt;i86.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; union REGS&nbsp; regs;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; regs.w.cx = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; regs.w.dx = 0x1850;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; regs.h.bh = 7;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; regs.w.ax = 0x0600;</TT>
<BR><TT>#if defined(__386__) &amp;&amp; defined(__DOS__)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int386( 0x10, &amp;regs, &amp;regs );</TT>
<BR><TT>#else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int86( 0x10, &amp;regs, &amp;regs );</TT>
<BR><TT>#endif</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>DOS/16, Windows, Win386, DOS/PM
</DL>
<H2 ID="int86x"> int86x </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;i86.h&gt;</TT>
<BR><TT>int int86x( int inter_no,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const union REGS *in_regs,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; union REGS *out_regs,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct SREGS *seg_regs );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> int86x</TT> function causes the computer's central processor (CPU) to be interrupted with an interrupt whose number
is given by<B> inter_no</B>.&nbsp; Before the interrupt, the CPU registers are loaded from the structure located by<B> in_regs</B>
and the DS and ES segment registers are loaded from the structure located by<B> seg_regs</B>.&nbsp; All of the segment registers
must contain valid values.&nbsp; Failure to do so will cause a segment violation when running in protect mode.&nbsp; If you
don't care about a particular segment register, then it can be set to 0 which will not cause a segment violation.&nbsp; The
function <TT> segread</TT> can be used to initialize<B> seg_regs</B> to their current values.
<BR><BR>Following the interrupt, the structure located by<B> out_regs</B> is filled with the contents of the CPU registers.
&nbsp;The<B> in_regs</B> and<B> out_regs</B> structures may be located at the same location in memory.&nbsp; The original
values of the DS and ES registers are restored.&nbsp; The structure<B> seg_regs</B> is updated with the values of the segment
registers following the interrupt.
<BR><BR>You should consult the technical documentation for the computer that you are using to determine the expected register
contents before and after the interrupt in question.
</DL>
<DL>
<DT>Returns:
<DD>The function returns the value of the CPU AX register after the interrupt.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#bdos">bdos</A>, <A HREF="#int386">int386</A>, <A HREF="#int386x">int386x</A>, <A HREF="#int86">int86</A>, <A HREF="#intdos">intdos</A>,
<A HREF="#intdosx">intdosx</A>, <A HREF="#intr">intr</A>, <A HREF="#intrf">intrf</A>, <A HREF="#segread">segread</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;i86.h&gt;</TT>
<BR><BR><TT>/* get current mouse interrupt handler address */</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; union REGS r;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct SREGS s;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; r.h.ah = 0x35;&nbsp; /* DOS get vector */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; r.h.al = 0x33;&nbsp; /* interrupt vector 0x33 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int86x( 0x21, &amp;r, &amp;r, &amp;s );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;mouse handler address=%4.4x:%4.4x\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s.es, r.w.bx );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>DOS/16, Windows, Win386, DOS/PM
</DL>
<H2 ID="intdos"> intdos </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><TT>int intdos( const union REGS *in_regs,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; union REGS *out_regs );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> intdos</TT> function causes the computer's central processor (CPU) to be interrupted with an interrupt number hexadecimal
21 (<TT>0x21</TT>), which is a request to invoke a specific DOS function.&nbsp; Before the interrupt, the CPU registers are
loaded from the structure located by<B> in_regs</B>.&nbsp; The AH register contains a number indicating the function requested.
&nbsp;Following the interrupt, the structure located by<B> out_regs</B> is filled with the contents of the CPU registers.
&nbsp;These structures may be located at the same location in memory.
<BR><BR>You should consult the technical documentation for the DOS operating system that you are using to determine the expected
register contents before and after the interrupt in question.
</DL>
<DL>
<DT>Returns:
<DD>The function returns the value of the AX (EAX in 386 library) register after the interrupt has completed.&nbsp; The CARRY
flag (when set, an error has occurred) is copied into the structure located by<B> out_regs</B>.&nbsp; When an error has occurred,
<TT> errno</TT> contains a value indicating the type of error that has been detected.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#bdos">bdos</A>, <A HREF="#int386">int386</A>, <A HREF="#int386x">int386x</A>, <A HREF="#int86">int86</A>, <A HREF="#int86x">int86x</A>,
<A HREF="#intdosx">intdosx</A>, <A HREF="#intr">intr</A>, <A HREF="#intrf">intrf</A>, <A HREF="#segread">segread</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><BR><TT>#define DISPLAY_OUTPUT&nbsp; 2</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; union REGS&nbsp; in_regs, out_regs;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; in_regs.h.ah = DISPLAY_OUTPUT;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; in_regs.h.al = 0;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; in_regs.w.dx = 'I';</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; rc = intdos( &amp;in_regs, &amp;out_regs );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; in_regs.w.dx = 'N';</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; rc = intdos( &amp;in_regs, &amp;out_regs );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; in_regs.w.dx = 'T';</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; rc = intdos( &amp;in_regs, &amp;out_regs );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; in_regs.w.dx = 'D';</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; rc = intdos( &amp;in_regs, &amp;out_regs );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; in_regs.w.dx = 'O';</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; rc = intdos( &amp;in_regs, &amp;out_regs );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; in_regs.w.dx = 'S';</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; rc = intdos( &amp;in_regs, &amp;out_regs );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>DOS
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, DOS/PM
</DL>
<H2 ID="intdosx"> intdosx </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><TT>int intdosx( const union REGS *in_regs,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; union REGS *out_regs,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct SREGS *seg_regs );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> intdosx</TT> function causes the computer's central processor (CPU) to be interrupted with an interrupt number hexadecimal
21 (<TT>0x21</TT>), which is a request to invoke a specific DOS function.&nbsp; Before the interrupt, the CPU registers are
loaded from the structure located by<B> in_regs</B> and the segment registers DS and ES are loaded from the structure located
by<B> seg_regs</B>.&nbsp; The AH register contains a number indicating the function requested.&nbsp; All of the segment registers
must contain valid values.&nbsp; Failure to do so will cause a segment violation when running in protect mode.&nbsp; If you
don't care about a particular segment register, then it can be set to 0 which will not cause a segment violation.&nbsp; The
function <TT> segread</TT> can be used to initialize<B> seg_regs</B> to their current values.
<BR><BR>Following the interrupt, the structure located by<B> out_regs</B> is filled with the contents of the CPU registers.
&nbsp;The<B> in_regs</B> and<B> out_regs</B> structures may be located at the same location in memory.&nbsp; The original
values for the DS and ES registers are restored.&nbsp; The structure<B> seg_regs</B> is updated with the values of the segment
registers following the interrupt.
<BR><BR>You should consult the technical documentation for the DOS operating system that you are using to determine the expected
register contents before and after the interrupt in question.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> intdosx</TT> function returns the value of the AX (EAX in 32-bit library) register after the interrupt has completed.
&nbsp;The CARRY flag (when set, an error has occurred) is copied into the structure located by<B> out_regs</B>.&nbsp; When
an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#bdos">bdos</A>, <A HREF="#int386">int386</A>, <A HREF="#int386x">int386x</A>, <A HREF="#int86">int86</A>, <A HREF="#int86x">int86x</A>,
<A HREF="#intdos">intdos</A>, <A HREF="#intr">intr</A>, <A HREF="#intrf">intrf</A>, <A HREF="#segread">segread</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><BR><TT>/* get current mouse interrupt handler address */</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; union REGS r;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct SREGS s;</TT>
<BR><BR><TT>#if defined(__386__)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; s.ds = s.es = s.fs = s.gs = FP_SEG( &amp;s );</TT>
<BR><TT>#endif</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; r.h.ah = 0x35;&nbsp; /* get vector */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; r.h.al = 0x33;&nbsp; /* vector 0x33 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; intdosx( &amp;r, &amp;r, &amp;s );</TT>
<BR><TT>#if defined(__386__)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;mouse handler address=%4.4x:%lx\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s.es, r.x.ebx );</TT>
<BR><TT>#else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;mouse handler address=%4.4x:%4.4x\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s.es, r.x.bx );</TT>
<BR><TT>#endif</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>DOS
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, DOS/PM
</DL>
<H2 ID="intr"> intr </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;i86.h&gt;</TT>
<BR><TT>void intr( int inter_no, union REGPACK *regs );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> intr</TT> functions cause the computer's central processor (CPU) to be interrupted with an interrupt whose number
is given by<B> inter_no</B>.&nbsp; Before the interrupt, the CPU registers are loaded from the structure located by<B> regs</B>.
&nbsp;Low 8-bit of the CPU flags are set to 0.
<BR><BR>All of the segment registers must contain valid values.&nbsp; Failure to do so will cause a segment violation when
running in protect mode.&nbsp; If you don't care about a particular segment register, then it can be set to 0 which will not
cause a segment violation.&nbsp; Following the interrupt, the structure located by<B> regs</B> is filled with the contents
of the CPU registers.
<BR><BR><TT>intr</TT> function is similar to the <TT> int86x</TT> function, except that only one structure is used for the
register values and that the BP (EBP in 386 library) register is included in the set of registers that are passed and saved.
<BR><BR>You should consult the technical documentation for the computer that you are using to determine the expected register
contents before and after the interrupt in question.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> intr</TT> function do not return a value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#bdos">bdos</A>, <A HREF="#int386">int386</A>, <A HREF="#int386x">int386x</A>, <A HREF="#int86">int86</A>, <A HREF="#int86x">int86x</A>,
<A HREF="#intdos">intdos</A>, <A HREF="#intdosx">intdosx</A>, <A HREF="#intrf">intrf</A>, <A HREF="#segread">segread</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>#include &lt;i86.h&gt;</TT>
<BR><BR><TT>void main() /* Print location of Break Key Vector */</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; union REGPACK regs;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; memset( &amp;regs, 0, sizeof(union REGPACK) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; regs.w.ax = 0x3523;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; intr( 0x21, &amp;regs );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Break Key vector is &quot;</TT>
<BR><TT>#if defined(__386__)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;%x:%lx\n&quot;, regs.w.es, regs.x.ebx );</TT>
<BR><TT>#else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;%x:%x\n&quot;, regs.w.es, regs.x.bx );</TT>
<BR><TT>#endif</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>Break Key vector is eef:13c</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Linux, RDOS, DOS/PM, Netware
</DL>
<H2 ID="intrf"> intrf </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;i86.h&gt;</TT>
<BR><TT>void intrf( int inter_no, union REGPACK *regs );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> intrf</TT> functions cause the computer's central processor (CPU) to be interrupted with an interrupt whose number
is given by<B> inter_no</B>.&nbsp; Before the interrupt, the CPU registers are loaded from the structure located by<B> regs</B>.
&nbsp;Low 8-bit of the CPU flags is set to the flags member of the structure<B> regs</B>.
<BR><BR>All of the segment registers must contain valid values.&nbsp; Failure to do so will cause a segment violation when
running in protect mode.&nbsp; If you don't care about a particular segment register, then it can be set to 0 which will not
cause a segment violation.&nbsp; Following the interrupt, the structure located by<B> regs</B> is filled with the contents
of the CPU registers.
<BR><BR><TT>intrf</TT> function is similar to the <TT> int86x</TT> function.&nbsp; Exception is that only one structure is
used for the register values and that the BP (EBP in 386 library) register is included in the set of registers that are passed
and saved and the CPU flags are set to flags member of the structure<B> regs</B>
<BR><BR>You should consult the technical documentation for the computer that you are using to determine the expected register
contents before and after the interrupt in question.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> intrf</TT> function do not return a value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#bdos">bdos</A>, <A HREF="#int386">int386</A>, <A HREF="#int386x">int386x</A>, <A HREF="#int86">int86</A>, <A HREF="#int86x">int86x</A>,
<A HREF="#intdos">intdos</A>, <A HREF="#intdosx">intdosx</A>, <A HREF="#intr">intr</A>, <A HREF="#segread">segread</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>#include &lt;i86.h&gt;</TT>
<BR><BR><TT>void main() /* Print location of Break Key Vector */</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; union REGPACK regs;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; memset( &amp;regs, 0, sizeof(union REGPACK) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; regs.w.ax = 0x3523;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; regs.w.flags = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; intrf( 0x21, &amp;regs );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Break Key vector is &quot;</TT>
<BR><TT>#if defined(__386__)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;%x:%lx\n&quot;, regs.w.es, regs.x.ebx );</TT>
<BR><TT>#else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;%x:%x\n&quot;, regs.w.es, regs.x.bx );</TT>
<BR><TT>#endif</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>Break Key vector is eef:13c</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Linux, RDOS, DOS/PM, Netware
</DL>
<H2 ID="isalnum"> isalnum, iswalnum </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;ctype.h&gt;</TT>
<BR><TT>int isalnum( int c );</TT>
<BR><TT>#include &lt;wctype.h&gt;</TT>
<BR><TT>int iswalnum( wint_t c );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> isalnum</TT> function tests if the argument<B> c</B> is an alphanumeric character ('a' to 'z', 'A' to 'Z', or '0'
to '9').&nbsp; An alphanumeric character is any character for which <TT> isalpha</TT> or <TT> isdigit</TT> is true.
<BR><BR>The<TT> iswalnum</TT> function is a wide-character version of<TT> isalnum</TT> that operates with wide-character argument.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> isalnum</TT> function returns zero if the argument is neither an alphabetic character (A-Z or a-z) nor a digit (0-9).
&nbsp;Otherwise, a non-zero value is returned.&nbsp; The<TT> iswalnum</TT> function returns a non-zero value if either <TT>
iswalpha</TT> or <TT> iswdigit</TT> is true for<B> c</B>.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#isalpha">isalpha</A>, <A HREF="#isblank">isblank</A>, <A HREF="#iscntrl">iscntrl</A>, <A HREF="#isdigit">isdigit</A>,
<A HREF="#isgraph">isgraph</A>, <A HREF="#isleadbyte">isleadbyte</A>, <A HREF="#islower">islower</A>, <A HREF="#isprint">isprint</A>,
<A HREF="#ispunct">ispunct</A>, <A HREF="#isspace">isspace</A>, <A HREF="#isupper">isupper</A>, <A HREF="#iswctype">iswctype</A>,
<A HREF="#isxdigit">isxdigit</A>, <A HREF="#tolower">tolower</A>, <A HREF="#toupper">toupper</A>, <A HREF="#towctrans">towctrans</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;ctype.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( isalnum( getchar() ) ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;is alpha-numeric\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>iswalnum is ISO C95
</DL>
<DL>
<DT>Systems:
<DD><TT> isalnum - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>iswalnum - All, Linux, RDOS, Netware</TT>
</DL>
<H2 ID="isalpha"> isalpha, iswalpha </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;ctype.h&gt;</TT>
<BR><TT>int isalpha( int c );</TT>
<BR><TT>#include &lt;wctype.h&gt;</TT>
<BR><TT>int iswalpha( wint_t c );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> isalpha</TT> function tests if the argument<B> c</B> is an alphabetic character ('a' to 'z' and 'A' to 'Z').&nbsp;
An alphabetic character is any character for which <TT> isupper</TT> or <TT> islower</TT> is true.
<BR><BR>The<TT> iswalpha</TT> function is a wide-character version of<TT> isalpha</TT> that operates with wide-character argument.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> isalpha</TT> function returns zero if the argument is not an alphabetic character (A-Z or a-z); otherwise, a non-zero
value is returned.&nbsp; The<TT> iswalpha</TT> function returns a non-zero value only for wide characters for which <TT> iswupper</TT>
or <TT> iswlower</TT> is true, or any wide character that is one of an implementation-defined set for which none of <TT> iswcntrl</TT>,
<TT> iswdigit</TT>, <TT> iswpunct</TT>, or <TT> iswspace</TT> is true.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#isalnum">isalnum</A>, <A HREF="#isblank">isblank</A>, <A HREF="#iscntrl">iscntrl</A>, <A HREF="#isdigit">isdigit</A>,
<A HREF="#isgraph">isgraph</A>, <A HREF="#isleadbyte">isleadbyte</A>, <A HREF="#islower">islower</A>, <A HREF="#isprint">isprint</A>,
<A HREF="#ispunct">ispunct</A>, <A HREF="#isspace">isspace</A>, <A HREF="#isupper">isupper</A>, <A HREF="#iswctype">iswctype</A>,
<A HREF="#isxdigit">isxdigit</A>, <A HREF="#tolower">tolower</A>, <A HREF="#toupper">toupper</A>, <A HREF="#towctrans">towctrans</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;ctype.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( isalpha( getchar() ) ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;is alphabetic\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>iswalpha is ISO C95
</DL>
<DL>
<DT>Systems:
<DD><TT> isalpha - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>iswalpha - All, Linux, RDOS, Netware</TT>
</DL>
<H2 ID="isascii"> isascii, __isascii, iswascii </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;ctype.h&gt;</TT>
<BR><TT>int isascii( int c );</TT>
<BR><TT>int __isascii( int c );</TT>
<BR><TT>#include &lt;wctype.h&gt;</TT>
<BR><TT>int iswascii( wint_t c );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> isascii</TT> function tests for a character in the range from 0 to 127.
<BR><BR>The<TT> __isascii</TT> function is identical to<TT> isascii</TT>.&nbsp; Use<TT> __isascii</TT> for ANSI naming conventions.
<BR><BR>The<TT> iswascii</TT> function is a wide-character version of<TT> isascii</TT> that operates with wide-character argument.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> isascii</TT> function returns a non-zero value when the character is in the range 0 to 127; otherwise, zero is returned.
&nbsp;The<TT> iswascii</TT> function returns a non-zero value when<B> c</B> is a wide-character representation of an ASCII
character.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#isalnum">isalnum</A>, <A HREF="#isalpha">isalpha</A>, <A HREF="#isblank">isblank</A>, <A HREF="#iscntrl">iscntrl</A>,
<A HREF="#isdigit">isdigit</A>, <A HREF="#isgraph">isgraph</A>, <A HREF="#isleadbyte">isleadbyte</A>, <A HREF="#islower">islower</A>,
<A HREF="#isprint">isprint</A>, <A HREF="#ispunct">ispunct</A>, <A HREF="#isspace">isspace</A>, <A HREF="#isupper">isupper</A>,
<A HREF="#iswctype">iswctype</A>, <A HREF="#isxdigit">isxdigit</A>, <A HREF="#tolower">tolower</A>, <A HREF="#toupper">toupper</A>,
<A HREF="#towctrans">towctrans</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;ctype.h&gt;</TT>
<BR><BR><TT>char chars[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'A',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x80,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'Z'</TT>
<BR><TT>};</TT>
<BR><BR><TT>#define SIZE sizeof( chars ) / sizeof( char )</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Char %c is %san ASCII character\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars[i],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( isascii( chars[i] ) )
? &quot;&quot; : &quot;not &quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>Char A is an ASCII character</TT>
<BR><TT>Char&nbsp;&nbsp; is not an ASCII character</TT>
<BR><TT>Char Z is an ASCII character</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
<BR><BR>__isascii conforms to ANSI naming conventions
</DL>
<DL>
<DT>Systems:
<DD><TT> isascii - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>__isascii - All, Linux, RDOS, Netware</TT>
<BR><TT>iswascii - All, Linux, RDOS, Netware</TT>
</DL>
<H2 ID="isatty"> isatty, _isatty </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;io.h&gt;</TT>
<BR><TT>int isatty( int handle );</TT>
<BR><TT>int _isatty( int handle );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> isatty</TT> function tests if the opened file or device referenced by the file handle<B> handle</B> is a character
device (for example, a console, printer or port).
<BR><BR>The<TT> _isatty</TT> function is identical to<TT> isatty</TT>.&nbsp; Use<TT> _isatty</TT> for ANSI naming conventions.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> isatty</TT> function returns zero if the device or file is not a character device; otherwise, a non-zero value is
returned.&nbsp; When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#open">open</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;io.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;stdin is a %stty\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( isatty( fileno( stdin ) ) )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ? &quot;&quot; : &quot;not &quot; );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>POSIX 1003.1
<BR><BR>_isatty conforms to ANSI naming conventions
</DL>
<DL>
<DT>Systems:
<DD><TT> isatty - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_isatty - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="isblank"> isblank, iswblank </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;ctype.h&gt;</TT>
<BR><TT>int isblank( int c );</TT>
<BR><TT>#include &lt;wctype.h&gt;</TT>
<BR><TT>int iswblank( wint_t c );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> isblank</TT> function tests for the following blank characters:
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Character
<DT>' '
<DD>space
<DT>'\t'
<DD>horizontal tab
</DL>
<BR>The<TT> iswblank</TT> function is a wide-character version of<TT> isblank</TT> that operates with wide-character argument.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> isblank</TT> function returns a non-zero character when the argument is one of the indicated blank characters.&nbsp;
The<TT> iswblank</TT> function returns a non-zero value when the argument is a wide character that corresponds to a standard
blank character or is one of an implementation-defined set of wide characters for which <TT> iswalnum</TT> is false.&nbsp;
Otherwise, zero is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#isalnum">isalnum</A>, <A HREF="#isalpha">isalpha</A>, <A HREF="#iscntrl">iscntrl</A>, <A HREF="#isdigit">isdigit</A>,
<A HREF="#isgraph">isgraph</A>, <A HREF="#isleadbyte">isleadbyte</A>, <A HREF="#islower">islower</A>, <A HREF="#isprint">isprint</A>,
<A HREF="#ispunct">ispunct</A>, <A HREF="#isspace">isspace</A>, <A HREF="#isupper">isupper</A>, <A HREF="#iswctype">iswctype</A>,
<A HREF="#isxdigit">isxdigit</A>, <A HREF="#tolower">tolower</A>, <A HREF="#toupper">toupper</A>, <A HREF="#towctrans">towctrans</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;ctype.h&gt;</TT>
<BR><BR><TT>char chars[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'A',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x09,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ' ',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x7d</TT>
<BR><TT>};</TT>
<BR><BR><TT>#define SIZE sizeof( chars ) / sizeof( char )</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Char %c is %sa blank character\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars[i],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( isblank( chars[i] ) ) ? &quot;&quot; : &quot;not
&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>Char A is not a blank character</TT>
<BR><TT>Char&nbsp;&nbsp;&nbsp;&nbsp; is a blank character</TT>
<BR><TT>Char&nbsp;&nbsp; is a blank character</TT>
<BR><TT>Char } is not a blank character</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C99
</DL>
<DL>
<DT>Systems:
<DD><TT> isblank - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>iswblank - All, Linux, RDOS, Netware</TT>
</DL>
<H2 ID="iscntrl"> iscntrl, iswcntrl </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;ctype.h&gt;</TT>
<BR><TT>int iscntrl( int c );</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>int iswcntrl( wint_t c );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> iscntrl</TT> function tests for any control character.&nbsp; A control character is any character whose value is from
0 through 31.
<BR><BR>The<TT> iswcntrl</TT> function is a wide-character version of<TT> iscntrl</TT> that operates with wide-character argument.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> iscntrl</TT> function returns a non-zero value when the argument is a control character.&nbsp; The<TT> iswcntrl</TT>
function returns a non-zero value when the argument is a control wide character.&nbsp; Otherwise, zero is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#isalnum">isalnum</A>, <A HREF="#isalpha">isalpha</A>, <A HREF="#isblank">isblank</A>, <A HREF="#isdigit">isdigit</A>,
<A HREF="#isgraph">isgraph</A>, <A HREF="#isleadbyte">isleadbyte</A>, <A HREF="#islower">islower</A>, <A HREF="#isprint">isprint</A>,
<A HREF="#ispunct">ispunct</A>, <A HREF="#isspace">isspace</A>, <A HREF="#isupper">isupper</A>, <A HREF="#iswctype">iswctype</A>,
<A HREF="#isxdigit">isxdigit</A>, <A HREF="#tolower">tolower</A>, <A HREF="#toupper">toupper</A>, <A HREF="#towctrans">towctrans</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;ctype.h&gt;</TT>
<BR><BR><TT>char chars[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'A',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x09,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'Z'</TT>
<BR><TT>};</TT>
<BR><BR><TT>#define SIZE sizeof( chars ) / sizeof( char )</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Char %c is %sa Control character\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars[i],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( iscntrl( chars[i] ) )
? &quot;&quot; : &quot;not &quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>Char A is not a Control character</TT>
<BR><TT>Char&nbsp;&nbsp;&nbsp;&nbsp; is a Control character</TT>
<BR><TT>Char Z is not a Control character</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>iswcntrl is ISO C95
</DL>
<DL>
<DT>Systems:
<DD><TT> iscntrl - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>iswcntrl - All, Linux, RDOS, Netware</TT>
</DL>
<H2 ID="iscsym"> iscsym, __iscsym, __iswcsym </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;ctype.h&gt;</TT>
<BR><TT>int iscsym( int c );</TT>
<BR><TT>int __iscsym( int c );</TT>
<BR><TT>#include &lt;wctype.h&gt;</TT>
<BR><TT>int __iswcsym( wint_t c );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> iscsym</TT> function tests for a letter, underscore or digit.
<BR><BR>The<TT> __iscsym</TT> function is identical to<TT> iscsym</TT>.&nbsp; Use<TT> __iscsym</TT> for ANSI naming conventions.
<BR><BR>The<TT> __iswcsym</TT> function is a wide-character version of<TT> iscsym</TT> that operates with wide-character argument.
</DL>
<DL>
<DT>Returns:
<DD>A non-zero value is returned when the character is a letter, underscore or digit; otherwise, zero is returned.&nbsp; The<TT>
__iswcsym</TT> function returns a non-zero value when<B> c</B> is a wide-character representation of a letter, underscore
or digit character.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#isalnum">isalnum</A>, <A HREF="#isalpha">isalpha</A>, <A HREF="#isblank">isblank</A>, <A HREF="#iscntrl">iscntrl</A>,
<A HREF="#isdigit">isdigit</A>, <A HREF="#isgraph">isgraph</A>, <A HREF="#isleadbyte">isleadbyte</A>, <A HREF="#islower">islower</A>,
<A HREF="#isprint">isprint</A>, <A HREF="#ispunct">ispunct</A>, <A HREF="#isspace">isspace</A>, <A HREF="#isupper">isupper</A>,
<A HREF="#iswctype">iswctype</A>, <A HREF="#isxdigit">isxdigit</A>, <A HREF="#tolower">tolower</A>, <A HREF="#toupper">toupper</A>,
<A HREF="#towctrans">towctrans</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;ctype.h&gt;</TT>
<BR><BR><TT>char chars[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'A',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x80,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '_',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '9',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '+'</TT>
<BR><TT>};</TT>
<BR><BR><TT>#define SIZE sizeof( chars ) / sizeof( char )</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Char %c is %sa C symbol character\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars[i],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( __iscsym( chars[i] )
) ? &quot;&quot; : &quot;not &quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>Char A is a C symbol character</TT>
<BR><TT>Char&nbsp;&nbsp; is not a C symbol character</TT>
<BR><TT>Char _ is a C symbol character</TT>
<BR><TT>Char 9 is a C symbol character</TT>
<BR><TT>Char + is not a C symbol character</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
<BR><BR>__iscsym conforms to ANSI naming conventions
</DL>
<DL>
<DT>Systems:
<DD><TT> iscsym - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>__iscsym - All, Linux, RDOS, Netware</TT>
<BR><TT>__iswcsym - All, Linux, RDOS, Netware</TT>
</DL>
<H2 ID="iscsymf"> iscsymf, __iscsymf, __iswcsymf </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;ctype.h&gt;</TT>
<BR><TT>int iscsymf( int c );</TT>
<BR><TT>int __iscsymf( int c );</TT>
<BR><TT>#include &lt;wctype.h&gt;</TT>
<BR><TT>int __iswcsymf( wint_t c );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> iscsymf</TT> function tests for a letter or underscore.
<BR><BR>The<TT> __iscsymf</TT> function is identical to<TT> iscsymf</TT>.&nbsp; Use<TT> __iscsymf</TT> for ANSI naming conventions.
<BR><BR>The<TT> __iswcsymf</TT> function is a wide-character version of<TT> iscsymf</TT> that operates with wide-character
argument.
</DL>
<DL>
<DT>Returns:
<DD>A non-zero value is returned when the character is a letter or underscore; otherwise, zero is returned.&nbsp; The<TT> __iswcsymf</TT>
function returns a non-zero value when<B> c</B> is a wide-character representation of a letter or underscore character.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#isalpha">isalpha</A>, <A HREF="#isalnum">isalnum</A>, <A HREF="#iscntrl">iscntrl</A>, <A HREF="#isdigit">isdigit</A>,
<A HREF="#isgraph">isgraph</A>, <A HREF="#islower">islower</A>, <A HREF="#isprint">isprint</A>, <A HREF="#ispunct">ispunct</A>,
<A HREF="#isspace">isspace</A>, <A HREF="#isupper">isupper</A>, <A HREF="#isxdigit">isxdigit</A>, <A HREF="#tolower">tolower</A>,
<A HREF="#toupper">toupper</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;ctype.h&gt;</TT>
<BR><BR><TT>char chars[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'A',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x80,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '_',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '9',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '+'</TT>
<BR><TT>};</TT>
<BR><BR><TT>#define SIZE sizeof( chars ) / sizeof( char )</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Char %c is %sa csymf character\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars[i],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( __iscsymf( chars[i] )
) ? &quot;&quot; : &quot;not &quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>Char A is a csymf character</TT>
<BR><TT>Char&nbsp;&nbsp; is not a csymf character</TT>
<BR><TT>Char _ is a csymf character</TT>
<BR><TT>Char 9 is not a csymf character</TT>
<BR><TT>Char + is not a csymf character</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
<BR><BR>__iscsymf conforms to ANSI naming conventions
</DL>
<DL>
<DT>Systems:
<DD><TT> iscsymf - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>__iscsymf - All, Linux, RDOS, Netware</TT>
<BR><TT>__iswcsymf - All, Linux, RDOS, Netware</TT>
</DL>
<H2 ID="isdigit"> isdigit, iswdigit </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;ctype.h&gt;</TT>
<BR><TT>int isdigit( int c );</TT>
<BR><TT>#include &lt;wctype.h&gt;</TT>
<BR><TT>int iswdigit( wint_t c );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> isdigit</TT> function tests for any decimal-digit character '0' through '9'.
<BR><BR>The<TT> iswdigit</TT> function is a wide-character version of<TT> isdigit</TT> that operates with wide-character argument.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> isdigit</TT> function returns a non-zero value when the argument is a decimal-digit character.&nbsp; The<TT> iswdigit</TT>
function returns a non-zero value when the argument is a wide character corresponding to a decimal-digit character.&nbsp;
Otherwise, zero is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#isalnum">isalnum</A>, <A HREF="#isalpha">isalpha</A>, <A HREF="#isblank">isblank</A>, <A HREF="#iscntrl">iscntrl</A>,
<A HREF="#isgraph">isgraph</A>, <A HREF="#isleadbyte">isleadbyte</A>, <A HREF="#islower">islower</A>, <A HREF="#isprint">isprint</A>,
<A HREF="#ispunct">ispunct</A>, <A HREF="#isspace">isspace</A>, <A HREF="#isupper">isupper</A>, <A HREF="#iswctype">iswctype</A>,
<A HREF="#isxdigit">isxdigit</A>, <A HREF="#tolower">tolower</A>, <A HREF="#toupper">toupper</A>, <A HREF="#towctrans">towctrans</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;ctype.h&gt;</TT>
<BR><BR><TT>char chars[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'A',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '5',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '$'</TT>
<BR><TT>};</TT>
<BR><BR><TT>#define SIZE sizeof( chars ) / sizeof( char )</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Char %c is %sa digit character\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars[i],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( isdigit( chars[i] ) )
? &quot;&quot; : &quot;not &quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>Char A is not a digit character</TT>
<BR><TT>Char 5 is a digit character</TT>
<BR><TT>Char $ is not a digit character</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>iswdigit is ISO C95
</DL>
<DL>
<DT>Systems:
<DD><TT> isdigit - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>iswdigit - All, Linux, RDOS, Netware</TT>
</DL>
<H2 ID="isfinite"> isfinite </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>int isfinite( x );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> isfinite</TT> macro determines whether its argument<B> x</B> has a finite value (zero, subnormal, or normal, and not
infinite or NaN).&nbsp; First, an argument represented in a format wider than its semantic type is converted to its semantic
type.&nbsp; Then determination is based on the type of the argument.
<BR><BR>The argument<B> x</B> must be an expression of real floating type.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> isfinite</TT> macro returns a nonzero value if and only if its argument has a finite value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#fpclassify">fpclassify</A>, <A HREF="#isinf">isinf</A>, <A HREF="#isnan">isnan</A>, <A HREF="#isnormal">isnormal</A>,
<A HREF="#signbit">signbit</A>, <A HREF="#_finite">_finite</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;zero %s a finite number\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isfinite( 0.0 ) ? &quot;is&quot; : &quot;is not&quot; );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>zero is a finite number</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="isgraph"> isgraph, iswgraph </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;ctype.h&gt;</TT>
<BR><TT>int isgraph( int c );</TT>
<BR><TT>#include &lt;wctype.h&gt;</TT>
<BR><TT>int iswgraph( wint_t c );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> isgraph</TT> function tests for any printable character except space (' ').&nbsp; The <TT> isprint</TT> function is
similar, except that the space character is also included in the character set being tested.
<BR><BR>The<TT> iswgraph</TT> function is a wide-character version of<TT> isgraph</TT> that operates with wide-character argument.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> isgraph</TT> function returns non-zero when the argument is a printable character (except a space).&nbsp; The<TT>
iswgraph</TT> function returns a non-zero value when the argument is a printable wide character (except a wide-character space).
&nbsp;Otherwise, zero is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#isalnum">isalnum</A>, <A HREF="#isalpha">isalpha</A>, <A HREF="#isblank">isblank</A>, <A HREF="#iscntrl">iscntrl</A>,
<A HREF="#isdigit">isdigit</A>, <A HREF="#isleadbyte">isleadbyte</A>, <A HREF="#islower">islower</A>, <A HREF="#isprint">isprint</A>,
<A HREF="#ispunct">ispunct</A>, <A HREF="#isspace">isspace</A>, <A HREF="#isupper">isupper</A>, <A HREF="#iswctype">iswctype</A>,
<A HREF="#isxdigit">isxdigit</A>, <A HREF="#tolower">tolower</A>, <A HREF="#toupper">toupper</A>, <A HREF="#towctrans">towctrans</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;ctype.h&gt;</TT>
<BR><BR><TT>char chars[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'A',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x09,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ' ',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x7d</TT>
<BR><TT>};</TT>
<BR><BR><TT>#define SIZE sizeof( chars ) / sizeof( char )</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Char %c is %sa printable character\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars[i],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( isgraph( chars[i] ) )
? &quot;&quot; : &quot;not &quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>Char A is a printable character</TT>
<BR><TT>Char&nbsp;&nbsp;&nbsp;&nbsp; is not a printable character</TT>
<BR><TT>Char&nbsp;&nbsp; is not a printable character</TT>
<BR><TT>Char } is a printable character</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>iswgraph is ISO C95
</DL>
<DL>
<DT>Systems:
<DD><TT> isgraph - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>iswgraph - All, Linux, RDOS, Netware</TT>
</DL>
<H2 ID="isinf"> isinf </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>int isinf( x );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> isinf</TT> macro determines whether its argument value is an infinity (positive or negative).&nbsp; First, an argument
represented in a format wider than its semantic type is converted to its semantic type.&nbsp; Then determination is based
on the type of the argument.
<BR><BR>The argument<B> x</B> must be an expression of real floating type.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> isinf</TT> macro returns a nonzero value if and only if its argument has an infinite value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#fpclassify">fpclassify</A>, <A HREF="#isfinite">isfinite</A>, <A HREF="#isnan">isnan</A>, <A HREF="#isnormal">isnormal</A>,
<A HREF="#signbit">signbit</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;zero %s an infinite number\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isinf( 0.0 ) ? &quot;is&quot; : &quot;is not&quot; );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>zero is not an infinite number</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="isleadbyte"> isleadbyte </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;ctype.h&gt;</TT>
<BR><TT>int isleadbyte( int ch );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> isleadbyte</TT> function tests if the argument<B> ch</B> is a valid first byte of a multibyte character in the current
code page.
<BR><BR>For example, in code page 932, a valid lead byte is any byte in the range 0x81 through 0x9F or 0xE0 through 0xFC.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> isleadbyte</TT> function returns a non-zero value when the argument is a valid lead byte.&nbsp; Otherwise, zero is
returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#isalnum">isalnum</A>, <A HREF="#isalpha">isalpha</A>, <A HREF="#isblank">isblank</A>, <A HREF="#iscntrl">iscntrl</A>,
<A HREF="#isdigit">isdigit</A>, <A HREF="#isgraph">isgraph</A>, <A HREF="#islower">islower</A>, <A HREF="#isprint">isprint</A>,
<A HREF="#ispunct">ispunct</A>, <A HREF="#isspace">isspace</A>, <A HREF="#isupper">isupper</A>, <A HREF="#iswctype">iswctype</A>,
<A HREF="#isxdigit">isxdigit</A>, <A HREF="#tolower">tolower</A>, <A HREF="#toupper">toupper</A>, <A HREF="#towctrans">towctrans</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;ctype.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><BR><TT>const unsigned char chars[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ' ',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '.',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '1',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'A',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x81,0x40, /* double-byte space */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x82,0x60, /* double-byte A */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x82,0xA6, /* double-byte Hiragana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x83,0x42, /* double-byte Katakana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana punctuation */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA6,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xDF,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xE0,0xA1, /* double-byte Kanji */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x00</TT>
<BR><TT>};</TT>
<BR><BR><TT>#define SIZE sizeof( chars ) / sizeof( char )</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%2.2x is %sa valid lead byte\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars[i],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( isleadbyte( chars[i] ) ) ? &quot;&quot; : &quot;not
&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>20 is not a valid lead byte</TT>
<BR><TT>2e is not a valid lead byte</TT>
<BR><TT>31 is not a valid lead byte</TT>
<BR><TT>41 is not a valid lead byte</TT>
<BR><TT>81 is a valid lead byte</TT>
<BR><TT>40 is not a valid lead byte</TT>
<BR><TT>82 is a valid lead byte</TT>
<BR><TT>60 is not a valid lead byte</TT>
<BR><TT>82 is a valid lead byte</TT>
<BR><TT>a6 is not a valid lead byte</TT>
<BR><TT>83 is a valid lead byte</TT>
<BR><TT>42 is not a valid lead byte</TT>
<BR><TT>a1 is not a valid lead byte</TT>
<BR><TT>a6 is not a valid lead byte</TT>
<BR><TT>df is not a valid lead byte</TT>
<BR><TT>e0 is a valid lead byte</TT>
<BR><TT>a1 is not a valid lead byte</TT>
<BR><TT>00 is not a valid lead byte</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS
</DL>
<H2 ID="islower"> islower, iswlower </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;ctype.h&gt;</TT>
<BR><TT>int islower( int c );</TT>
<BR><TT>#include &lt;wctype.h&gt;</TT>
<BR><TT>int iswlower( wint_t c );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> islower</TT> function tests for any lowercase letter 'a' through 'z'.
<BR><BR>The<TT> iswlower</TT> function is a wide-character version of<TT> islower</TT> that operates with wide-character argument.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> islower</TT> function returns a non-zero value when argument is a lowercase letter.&nbsp; The<TT> iswlower</TT> function
returns a non-zero value when the argument is a wide character that corresponds to a lowercase letter, or if it is one of
an implementation-defined set of wide characters for which none of <TT> iswcntrl</TT>, <TT> iswdigit</TT>, <TT> iswpunct</TT>,
or <TT> iswspace</TT> is true.&nbsp; Otherwise, zero is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#isalnum">isalnum</A>, <A HREF="#isalpha">isalpha</A>, <A HREF="#isblank">isblank</A>, <A HREF="#iscntrl">iscntrl</A>,
<A HREF="#isdigit">isdigit</A>, <A HREF="#isgraph">isgraph</A>, <A HREF="#isleadbyte">isleadbyte</A>, <A HREF="#isprint">isprint</A>,
<A HREF="#ispunct">ispunct</A>, <A HREF="#isspace">isspace</A>, <A HREF="#isupper">isupper</A>, <A HREF="#iswctype">iswctype</A>,
<A HREF="#isxdigit">isxdigit</A>, <A HREF="#tolower">tolower</A>, <A HREF="#toupper">toupper</A>, <A HREF="#towctrans">towctrans</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;ctype.h&gt;</TT>
<BR><BR><TT>char chars[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'A',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'a',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'z',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'Z'</TT>
<BR><TT>};</TT>
<BR><BR><TT>#define SIZE sizeof( chars ) / sizeof( char )</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Char %c is %sa lowercase character\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars[i],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( islower( chars[i] ) )
? &quot;&quot; : &quot;not &quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>Char A is not a lowercase character</TT>
<BR><TT>Char a is a lowercase character</TT>
<BR><TT>Char z is a lowercase character</TT>
<BR><TT>Char Z is not a lowercase character</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>iswlower is ISO C95
</DL>
<DL>
<DT>Systems:
<DD><TT> islower - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>iswlower - All, Linux, RDOS, Netware</TT>
</DL>
<H2 ID="_ismbbalnum"> _ismbbalnum </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><TT>int _ismbbalnum( unsigned int ch );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _ismbbalnum</TT> function tests if the argument<B> ch</B> satisfies the condition that one of <TT> isalnum</TT> or
<TT> _ismbbkalnum</TT> is true.
<BR><BR><B>Note:</B>&nbsp; The argument<B> ch</B> must represent a single-byte value (i.e., 0 &lt;=<B> ch</B> &lt;= 255 ).
&nbsp;Incorrect results occur if the argument is a double-byte character.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _ismbbalnum</TT> function returns a non-zero value if the argument satisfies the condition; otherwise a zero value
is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getmbcp">_getmbcp</A>, <A HREF="#_mbbtombc">_mbbtombc</A>, <A HREF="#_mbcjistojms">_mbcjistojms</A>, <A HREF="#_mbcjmstojis">_mbcjmstojis</A>,
<A HREF="#_mbctombb">_mbctombb</A>, <A HREF="#_ismbbalpha">_ismbbalpha</A>, <A HREF="#_ismbbgraph">_ismbbgraph</A>, <A HREF="#_ismbbkalnum">_ismbbkalnum</A>,
<A HREF="#_ismbbkalpha">_ismbbkalpha</A>, <A HREF="#_ismbbkana">_ismbbkana</A>, <A HREF="#_ismbbkprint">_ismbbkprint</A>,
<A HREF="#_ismbbkpunct">_ismbbkpunct</A>, <A HREF="#_ismbblead">_ismbblead</A>, <A HREF="#_ismbbprint">_ismbbprint</A>, <A HREF="#_ismbbpunct">_ismbbpunct</A>,
<A HREF="#_ismbbtrail">_ismbbtrail</A>, <A HREF="#_mbbtombc">_mbbtombc</A>, <A HREF="#_mbcjistojms">_mbcjistojms</A>, <A HREF="#_mbcjmstojis">_mbcjmstojis</A>,
<A HREF="#_mbctombb">_mbctombb</A>, <A HREF="#_mbbtype">_mbbtype</A>, <A HREF="#_setmbcp">_setmbcp</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><BR><TT>unsigned int chars[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ' ',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '.',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '1',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'A',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8140, /* double-byte space */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8260, /* double-byte A */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x82A6, /* double-byte Hiragana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8342, /* double-byte Katakana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA1,&nbsp;&nbsp; /* single-byte Katakana punctuation */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA6,&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xDF,&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xE0A1&nbsp; /* double-byte Kanji */</TT>
<BR><TT>};</TT>
<BR><BR><TT>#define SIZE sizeof( chars ) / sizeof( unsigned int )</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x is %sa single-byte alphanumeric\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot; or Katakana non-punctuation
character\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars[i],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( _ismbbalnum( chars[i] ) ) ? &quot;&quot; : &quot;not
&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>0x0020 is not a single-byte alphanumeric</TT>
<BR><TT> or Katakana non-punctuation character</TT>
<BR><TT>0x002e is not a single-byte alphanumeric</TT>
<BR><TT> or Katakana non-punctuation character</TT>
<BR><TT>0x0031 is a single-byte alphanumeric</TT>
<BR><TT> or Katakana non-punctuation character</TT>
<BR><TT>0x0041 is a single-byte alphanumeric</TT>
<BR><TT> or Katakana non-punctuation character</TT>
<BR><TT>0x8140 is not a single-byte alphanumeric</TT>
<BR><TT> or Katakana non-punctuation character</TT>
<BR><TT>0x8260 is not a single-byte alphanumeric</TT>
<BR><TT> or Katakana non-punctuation character</TT>
<BR><TT>0x82a6 is a single-byte alphanumeric</TT>
<BR><TT> or Katakana non-punctuation character</TT>
<BR><TT>0x8342 is a single-byte alphanumeric</TT>
<BR><TT> or Katakana non-punctuation character</TT>
<BR><TT>0x00a1 is not a single-byte alphanumeric</TT>
<BR><TT> or Katakana non-punctuation character</TT>
<BR><TT>0x00a6 is a single-byte alphanumeric</TT>
<BR><TT> or Katakana non-punctuation character</TT>
<BR><TT>0x00df is a single-byte alphanumeric</TT>
<BR><TT> or Katakana non-punctuation character</TT>
<BR><TT>0xe0a1 is not a single-byte alphanumeric</TT>
<BR><TT> or Katakana non-punctuation character</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS
</DL>
<H2 ID="_ismbbalpha"> _ismbbalpha </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><TT>int _ismbbalpha( unsigned int ch );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _ismbbalpha</TT> function tests if the argument<B> ch</B> satisfies the condition that one of <TT> isalpha</TT> or
<TT> _ismbbkalpha</TT> is true.
<BR><BR>For example, in code page 932,<TT> _ismbbalpha</TT> tests if the argument<B> ch</B> is a single-byte alphabetic character
(&quot;a&quot; to &quot;z&quot; or &quot;A&quot; to &quot;Z&quot;) or single-byte Katakana non-punctuation character.
<BR><BR><B>Note:</B>&nbsp; The argument<B> ch</B> must represent a single-byte value (i.e., 0 &lt;=<B> ch</B> &lt;= 255 ).
&nbsp;Incorrect results occur if the argument is a double-byte character.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _ismbbalpha</TT> function returns a non-zero value if the argument satisfies the condition; otherwise a zero value
is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getmbcp">_getmbcp</A>, <A HREF="#_mbbtombc">_mbbtombc</A>, <A HREF="#_mbcjistojms">_mbcjistojms</A>, <A HREF="#_mbcjmstojis">_mbcjmstojis</A>,
<A HREF="#_mbctombb">_mbctombb</A>, <A HREF="#_ismbbalnum">_ismbbalnum</A>, <A HREF="#_ismbbgraph">_ismbbgraph</A>, <A HREF="#_ismbbkalnum">_ismbbkalnum</A>,
<A HREF="#_ismbbkalpha">_ismbbkalpha</A>, <A HREF="#_ismbbkana">_ismbbkana</A>, <A HREF="#_ismbbkprint">_ismbbkprint</A>,
<A HREF="#_ismbbkpunct">_ismbbkpunct</A>, <A HREF="#_ismbblead">_ismbblead</A>, <A HREF="#_ismbbprint">_ismbbprint</A>, <A HREF="#_ismbbpunct">_ismbbpunct</A>,
<A HREF="#_ismbbtrail">_ismbbtrail</A>, <A HREF="#_mbbtombc">_mbbtombc</A>, <A HREF="#_mbcjistojms">_mbcjistojms</A>, <A HREF="#_mbcjmstojis">_mbcjmstojis</A>,
<A HREF="#_mbctombb">_mbctombb</A>, <A HREF="#_mbbtype">_mbbtype</A>, <A HREF="#_setmbcp">_setmbcp</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><BR><TT>unsigned int chars[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ' ',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '.',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '1',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'A',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8140, /* double-byte space */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8260, /* double-byte A */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x82A6, /* double-byte Hiragana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8342, /* double-byte Katakana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA1,&nbsp;&nbsp; /* single-byte Katakana punctuation */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA6,&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xDF,&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xE0A1&nbsp; /* double-byte Kanji */</TT>
<BR><TT>};</TT>
<BR><BR><TT>#define SIZE sizeof( chars ) / sizeof( unsigned int )</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x is %sa single-byte alphabetic\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot; or Katakana alphabetic character\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars[i],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( _ismbbalpha( chars[i] ) ) ? &quot;&quot; : &quot;not
&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>0x0020 is not a single-byte alphabetic</TT>
<BR><TT> or Katakana alphabetic character</TT>
<BR><TT>0x002e is not a single-byte alphabetic</TT>
<BR><TT> or Katakana alphabetic character</TT>
<BR><TT>0x0031 is not a single-byte alphabetic</TT>
<BR><TT> or Katakana alphabetic character</TT>
<BR><TT>0x0041 is a single-byte alphabetic</TT>
<BR><TT> or Katakana alphabetic character</TT>
<BR><TT>0x8140 is not a single-byte alphabetic</TT>
<BR><TT> or Katakana alphabetic character</TT>
<BR><TT>0x8260 is not a single-byte alphabetic</TT>
<BR><TT> or Katakana alphabetic character</TT>
<BR><TT>0x82a6 is a single-byte alphabetic</TT>
<BR><TT> or Katakana alphabetic character</TT>
<BR><TT>0x8342 is a single-byte alphabetic</TT>
<BR><TT> or Katakana alphabetic character</TT>
<BR><TT>0x00a1 is not a single-byte alphabetic</TT>
<BR><TT> or Katakana alphabetic character</TT>
<BR><TT>0x00a6 is a single-byte alphabetic</TT>
<BR><TT> or Katakana alphabetic character</TT>
<BR><TT>0x00df is a single-byte alphabetic</TT>
<BR><TT> or Katakana alphabetic character</TT>
<BR><TT>0xe0a1 is not a single-byte alphabetic</TT>
<BR><TT> or Katakana alphabetic character</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS
</DL>
<H2 ID="_ismbbgraph"> _ismbbgraph </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><TT>int _ismbbgraph( unsigned int ch );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _ismbbgraph</TT> function tests if the argument<B> ch</B> satisfies the condition that one of <TT> isgraph</TT> or
<TT> _ismbbkprint</TT> is true.
<BR><BR>For example, in code page 932,<TT> _ismbbgraph</TT> tests if the argument<B> ch</B> is a single-byte printable character
excluding space (&quot; &quot;) or single-byte Katakana character.
<BR><BR><B>Note:</B>&nbsp; The argument<B> ch</B> must represent a single-byte value (i.e., 0 &lt;=<B> ch</B> &lt;= 255 ).
&nbsp;Incorrect results occur if the argument is a double-byte character.&nbsp; This is shown by the example below.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _ismbbgraph</TT> function returns a non-zero value if the argument satisfies the condition; otherwise a zero value
is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getmbcp">_getmbcp</A>, <A HREF="#_mbbtombc">_mbbtombc</A>, <A HREF="#_mbcjistojms">_mbcjistojms</A>, <A HREF="#_mbcjmstojis">_mbcjmstojis</A>,
<A HREF="#_mbctombb">_mbctombb</A>, <A HREF="#_ismbbalnum">_ismbbalnum</A>, <A HREF="#_ismbbalpha">_ismbbalpha</A>, <A HREF="#_ismbbkalnum">_ismbbkalnum</A>,
<A HREF="#_ismbbkalpha">_ismbbkalpha</A>, <A HREF="#_ismbbkana">_ismbbkana</A>, <A HREF="#_ismbbkprint">_ismbbkprint</A>,
<A HREF="#_ismbbkpunct">_ismbbkpunct</A>, <A HREF="#_ismbblead">_ismbblead</A>, <A HREF="#_ismbbprint">_ismbbprint</A>, <A HREF="#_ismbbpunct">_ismbbpunct</A>,
<A HREF="#_ismbbtrail">_ismbbtrail</A>, <A HREF="#_mbbtombc">_mbbtombc</A>, <A HREF="#_mbcjistojms">_mbcjistojms</A>, <A HREF="#_mbcjmstojis">_mbcjmstojis</A>,
<A HREF="#_mbctombb">_mbctombb</A>, <A HREF="#_mbbtype">_mbbtype</A>, <A HREF="#_setmbcp">_setmbcp</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><BR><TT>unsigned int chars[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ' ',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '.',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '1',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'A',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8140, /* double-byte space */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8260, /* double-byte A */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x82A6, /* double-byte Hiragana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8342, /* double-byte Katakana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA1,&nbsp;&nbsp; /* single-byte Katakana punctuation */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA6,&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xDF,&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xE0A1&nbsp; /* double-byte Kanji */</TT>
<BR><TT>};</TT>
<BR><BR><TT>#define SIZE sizeof( chars ) / sizeof( unsigned int )</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x is %sa single-byte printable &quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;non-space character\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars[i],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( _ismbbgraph( chars[i] ) ) ? &quot;&quot; : &quot;not
&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>0x0020 is not a single-byte printable non-space character</TT>
<BR><TT>0x002e is a single-byte printable non-space character</TT>
<BR><TT>0x0031 is a single-byte printable non-space character</TT>
<BR><TT>0x0041 is a single-byte printable non-space character</TT>
<BR><TT>0x8140 is a single-byte printable non-space character</TT>
<BR><TT>0x8260 is a single-byte printable non-space character</TT>
<BR><TT>0x82a6 is a single-byte printable non-space character</TT>
<BR><TT>0x8342 is a single-byte printable non-space character</TT>
<BR><TT>0x00a1 is a single-byte printable non-space character</TT>
<BR><TT>0x00a6 is a single-byte printable non-space character</TT>
<BR><TT>0x00df is a single-byte printable non-space character</TT>
<BR><TT>0xe0a1 is a single-byte printable non-space character</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS
</DL>
<H2 ID="_ismbbkalnum"> _ismbbkalnum </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><TT>int _ismbbkalnum( unsigned int ch );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _ismbbkalnum</TT> function tests if the argument<B> ch</B> is a non-ASCII text symbol other than punctuation.
<BR><BR>For example, in code page 932,<TT> _ismbbkalnum</TT> tests for a single-byte Katakana character (excluding the Katakana
punctuation characters).&nbsp; Note that there are no Katakana digit characters.&nbsp; A single-byte Katakana non-punctuation
character is any character for which the following expression is true:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0xA6 &lt;= ch &lt;= 0xDF</TT>
<BR><BR><B>Note:</B>&nbsp; The argument<B> ch</B> must represent a single-byte value (i.e., 0 &lt;=<B> ch</B> &lt;= 255 ).
&nbsp;Incorrect results occur if the argument is a double-byte character.&nbsp; This is shown by the example below.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _ismbbkalnum</TT> function returns a non-zero value if the argument satisfies the condition; otherwise a zero value
is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getmbcp">_getmbcp</A>, <A HREF="#_mbbtombc">_mbbtombc</A>, <A HREF="#_mbcjistojms">_mbcjistojms</A>, <A HREF="#_mbcjmstojis">_mbcjmstojis</A>,
<A HREF="#_mbctombb">_mbctombb</A>, <A HREF="#_ismbbalnum">_ismbbalnum</A>, <A HREF="#_ismbbalpha">_ismbbalpha</A>, <A HREF="#_ismbbgraph">_ismbbgraph</A>,
<A HREF="#_ismbbkalpha">_ismbbkalpha</A>, <A HREF="#_ismbbkana">_ismbbkana</A>, <A HREF="#_ismbbkprint">_ismbbkprint</A>,
<A HREF="#_ismbbkpunct">_ismbbkpunct</A>, <A HREF="#_ismbblead">_ismbblead</A>, <A HREF="#_ismbbprint">_ismbbprint</A>, <A HREF="#_ismbbpunct">_ismbbpunct</A>,
<A HREF="#_ismbbtrail">_ismbbtrail</A>, <A HREF="#_mbbtombc">_mbbtombc</A>, <A HREF="#_mbcjistojms">_mbcjistojms</A>, <A HREF="#_mbcjmstojis">_mbcjmstojis</A>,
<A HREF="#_mbctombb">_mbctombb</A>, <A HREF="#_mbbtype">_mbbtype</A>, <A HREF="#_setmbcp">_setmbcp</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><BR><TT>unsigned int chars[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ' ',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '.',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '1',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'A',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8140, /* double-byte space */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8260, /* double-byte A */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x82A6, /* double-byte Hiragana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8342, /* double-byte Katakana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA1,&nbsp;&nbsp; /* single-byte Katakana punctuation */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA6,&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xDF,&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xE0A1&nbsp; /* double-byte Kanji */</TT>
<BR><TT>};</TT>
<BR><BR><TT>#define SIZE sizeof( chars ) / sizeof( unsigned int )</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x is %sa single-byte &quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;Katakana non-punctuation character\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars[i],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( _ismbbkalnum( chars[i] ) ) ? &quot;&quot; : &quot;not
&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>0x0020 is not a single-byte Katakana non-punctuation character</TT>
<BR><TT>0x002e is not a single-byte Katakana non-punctuation character</TT>
<BR><TT>0x0031 is not a single-byte Katakana non-punctuation character</TT>
<BR><TT>0x0041 is not a single-byte Katakana non-punctuation character</TT>
<BR><TT>0x8140 is not a single-byte Katakana non-punctuation character</TT>
<BR><TT>0x8260 is not a single-byte Katakana non-punctuation character</TT>
<BR><TT>0x82a6 is a single-byte Katakana non-punctuation character</TT>
<BR><TT>0x8342 is not a single-byte Katakana non-punctuation character</TT>
<BR><TT>0x00a1 is not a single-byte Katakana non-punctuation character</TT>
<BR><TT>0x00a6 is a single-byte Katakana non-punctuation character</TT>
<BR><TT>0x00df is a single-byte Katakana non-punctuation character</TT>
<BR><TT>0xe0a1 is not a single-byte Katakana non-punctuation character</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS
</DL>
<H2 ID="_ismbbkana"> _ismbbkana </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><TT>int _ismbbkana( unsigned int ch );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _ismbbkana</TT> function tests if the argument<B> ch</B> is a single-byte Katakana character.&nbsp; A single-byte
Katakana character is any character for which the following expression is true:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0xA1 &lt;= ch &lt;= 0xDF</TT>
<BR><BR><B>Note:</B>&nbsp; The argument<B> ch</B> must represent a single-byte value (i.e., 0 &lt;=<B> ch</B> &lt;= 255 ).
&nbsp;Incorrect results occur if the argument is a double-byte character.&nbsp; This is shown by the example below.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _ismbbkana</TT> function returns non-zero if the argument is a single-byte Katakana character; otherwise, a zero value
is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getmbcp">_getmbcp</A>, <A HREF="#_mbbtombc">_mbbtombc</A>, <A HREF="#_mbcjistojms">_mbcjistojms</A>, <A HREF="#_mbcjmstojis">_mbcjmstojis</A>,
<A HREF="#_mbctombb">_mbctombb</A>, <A HREF="#_ismbbalnum">_ismbbalnum</A>, <A HREF="#_ismbbalpha">_ismbbalpha</A>, <A HREF="#_ismbbgraph">_ismbbgraph</A>,
<A HREF="#_ismbbkalnum">_ismbbkalnum</A>, <A HREF="#_ismbbkalpha">_ismbbkalpha</A>, <A HREF="#_ismbbkprint">_ismbbkprint</A>,
<A HREF="#_ismbbkpunct">_ismbbkpunct</A>, <A HREF="#_ismbblead">_ismbblead</A>, <A HREF="#_ismbbprint">_ismbbprint</A>, <A HREF="#_ismbbpunct">_ismbbpunct</A>,
<A HREF="#_ismbbtrail">_ismbbtrail</A>, <A HREF="#_mbbtombc">_mbbtombc</A>, <A HREF="#_mbcjistojms">_mbcjistojms</A>, <A HREF="#_mbcjmstojis">_mbcjmstojis</A>,
<A HREF="#_mbctombb">_mbctombb</A>, <A HREF="#_mbbtype">_mbbtype</A>, <A HREF="#_setmbcp">_setmbcp</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><BR><TT>unsigned int chars[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ' ',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '.',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '1',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'A',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8140, /* double-byte space */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8260, /* double-byte A */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x82A6, /* double-byte Hiragana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8342, /* double-byte Katakana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA1,&nbsp;&nbsp; /* single-byte Katakana punctuation */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA6,&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xDF,&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xE0A1&nbsp; /* double-byte Kanji */</TT>
<BR><TT>};</TT>
<BR><BR><TT>#define SIZE sizeof( chars ) / sizeof( unsigned int )</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x is %sa single-byte &quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;Katakana character\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars[i],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( _ismbbkana( chars[i] ) ) ? &quot;&quot; : &quot;not
&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>0x0020 is not a single-byte Katakana character</TT>
<BR><TT>0x002e is not a single-byte Katakana character</TT>
<BR><TT>0x0031 is not a single-byte Katakana character</TT>
<BR><TT>0x0041 is not a single-byte Katakana character</TT>
<BR><TT>0x8140 is not a single-byte Katakana character</TT>
<BR><TT>0x8260 is not a single-byte Katakana character</TT>
<BR><TT>0x82a6 is a single-byte Katakana character</TT>
<BR><TT>0x8342 is not a single-byte Katakana character</TT>
<BR><TT>0x00a1 is a single-byte Katakana character</TT>
<BR><TT>0x00a6 is a single-byte Katakana character</TT>
<BR><TT>0x00df is a single-byte Katakana character</TT>
<BR><TT>0xe0a1 is a single-byte Katakana character</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS
</DL>
<H2 ID="_ismbbkalpha"> _ismbbkalpha </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><TT>int _ismbbkalpha( unsigned int ch );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _ismbbkalpha</TT> function tests if the argument<B> ch</B> is a non-ASCII text symbol other than digits or punctuation.
<BR><BR>For example, in code page 932,<TT> _ismbbkalpha</TT> tests for a single-byte Katakana character (excluding the Katakana
punctuation characters).&nbsp; Note that there are no Katakana digit characters.&nbsp; A single-byte Katakana non-punctuation
character is any character for which the following expression is true:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0xA6 &lt;= ch &lt;= 0xDF</TT>
<BR><BR><B>Note:</B>&nbsp; The argument<B> ch</B> must represent a single-byte value (i.e., 0 &lt;=<B> ch</B> &lt;= 255 ).
&nbsp;Incorrect results occur if the argument is a double-byte character.&nbsp; This is shown by the example below.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _ismbbkalpha</TT> function returns a non-zero value if the argument satisfies the condition; otherwise a zero value
is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getmbcp">_getmbcp</A>, <A HREF="#_mbbtombc">_mbbtombc</A>, <A HREF="#_mbcjistojms">_mbcjistojms</A>, <A HREF="#_mbcjmstojis">_mbcjmstojis</A>,
<A HREF="#_mbctombb">_mbctombb</A>, <A HREF="#_ismbbalnum">_ismbbalnum</A>, <A HREF="#_ismbbalpha">_ismbbalpha</A>, <A HREF="#_ismbbgraph">_ismbbgraph</A>,
<A HREF="#_ismbbkalnum">_ismbbkalnum</A>, <A HREF="#_ismbbkana">_ismbbkana</A>, <A HREF="#_ismbbkprint">_ismbbkprint</A>,
<A HREF="#_ismbbkpunct">_ismbbkpunct</A>, <A HREF="#_ismbblead">_ismbblead</A>, <A HREF="#_ismbbprint">_ismbbprint</A>, <A HREF="#_ismbbpunct">_ismbbpunct</A>,
<A HREF="#_ismbbtrail">_ismbbtrail</A>, <A HREF="#_mbbtombc">_mbbtombc</A>, <A HREF="#_mbcjistojms">_mbcjistojms</A>, <A HREF="#_mbcjmstojis">_mbcjmstojis</A>,
<A HREF="#_mbctombb">_mbctombb</A>, <A HREF="#_mbbtype">_mbbtype</A>, <A HREF="#_setmbcp">_setmbcp</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><BR><TT>unsigned int chars[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ' ',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '.',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '1',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'A',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8140, /* double-byte space */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8260, /* double-byte A */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x82A6, /* double-byte Hiragana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8342, /* double-byte Katakana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA1,&nbsp;&nbsp; /* single-byte Katakana punctuation */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA6,&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xDF,&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xE0A1&nbsp; /* double-byte Kanji */</TT>
<BR><TT>};</TT>
<BR><BR><TT>#define SIZE sizeof( chars ) / sizeof( unsigned int )</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x is %sa single-byte &quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;Katakana alphabetic character\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars[i],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( _ismbbkalpha( chars[i] ) ) ? &quot;&quot; : &quot;not
&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>0x0020 is not a single-byte Katakana alphabetic character</TT>
<BR><TT>0x002e is not a single-byte Katakana alphabetic character</TT>
<BR><TT>0x0031 is not a single-byte Katakana alphabetic character</TT>
<BR><TT>0x0041 is not a single-byte Katakana alphabetic character</TT>
<BR><TT>0x8140 is not a single-byte Katakana alphabetic character</TT>
<BR><TT>0x8260 is not a single-byte Katakana alphabetic character</TT>
<BR><TT>0x82a6 is a single-byte Katakana alphabetic character</TT>
<BR><TT>0x8342 is not a single-byte Katakana alphabetic character</TT>
<BR><TT>0x00a1 is not a single-byte Katakana alphabetic character</TT>
<BR><TT>0x00a6 is a single-byte Katakana alphabetic character</TT>
<BR><TT>0x00df is a single-byte Katakana alphabetic character</TT>
<BR><TT>0xe0a1 is not a single-byte Katakana alphabetic character</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS
</DL>
<H2 ID="_ismbbkprint"> _ismbbkprint </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><TT>int _ismbbkprint( unsigned int ch );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _ismbbkprint</TT> function tests if the argument<B> ch</B> is a non-ASCII text or non-ASCII punctuation symbol.
<BR><BR>For example, in code page 932,<TT> _ismbbkprint</TT> tests if the argument<B> ch</B> is a single-byte Katakana character.
&nbsp;A single-byte Katakana character is any character for which the following expression is true:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0xA1 &lt;= ch &lt;= 0xDF</TT>
<BR><BR><B>Note:</B>&nbsp; The argument<B> ch</B> must represent a single-byte value (i.e., 0 &lt;=<B> ch</B> &lt;= 255 ).
&nbsp;Incorrect results occur if the argument is a double-byte character.&nbsp; This is shown by the example below.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _ismbbkprint</TT> function returns a non-zero value if the argument satisfies the condition; otherwise a zero value
is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getmbcp">_getmbcp</A>, <A HREF="#_mbbtombc">_mbbtombc</A>, <A HREF="#_mbcjistojms">_mbcjistojms</A>, <A HREF="#_mbcjmstojis">_mbcjmstojis</A>,
<A HREF="#_mbctombb">_mbctombb</A>, <A HREF="#_ismbbalnum">_ismbbalnum</A>, <A HREF="#_ismbbalpha">_ismbbalpha</A>, <A HREF="#_ismbbgraph">_ismbbgraph</A>,
<A HREF="#_ismbbkalnum">_ismbbkalnum</A>, <A HREF="#_ismbbkalpha">_ismbbkalpha</A>, <A HREF="#_ismbbkana">_ismbbkana</A>,
<A HREF="#_ismbbkpunct">_ismbbkpunct</A>, <A HREF="#_ismbblead">_ismbblead</A>, <A HREF="#_ismbbprint">_ismbbprint</A>, <A HREF="#_ismbbpunct">_ismbbpunct</A>,
<A HREF="#_ismbbtrail">_ismbbtrail</A>, <A HREF="#_mbbtombc">_mbbtombc</A>, <A HREF="#_mbcjistojms">_mbcjistojms</A>, <A HREF="#_mbcjmstojis">_mbcjmstojis</A>,
<A HREF="#_mbctombb">_mbctombb</A>, <A HREF="#_mbbtype">_mbbtype</A>, <A HREF="#_setmbcp">_setmbcp</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><BR><TT>unsigned int chars[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ' ',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '.',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '1',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'A',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8140, /* double-byte space */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8260, /* double-byte A */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x82A6, /* double-byte Hiragana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8342, /* double-byte Katakana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA1,&nbsp;&nbsp; /* single-byte Katakana punctuation */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA6,&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xDF,&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xE0A1&nbsp; /* double-byte Kanji */</TT>
<BR><TT>};</TT>
<BR><BR><TT>#define SIZE sizeof( chars ) / sizeof( unsigned int )</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x is %sa single-byte &quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;Katakana printable character\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars[i],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( _ismbbkprint( chars[i] ) ) ? &quot;&quot; : &quot;not
&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>0x0020 is not a single-byte Katakana printable character</TT>
<BR><TT>0x002e is not a single-byte Katakana printable character</TT>
<BR><TT>0x0031 is not a single-byte Katakana printable character</TT>
<BR><TT>0x0041 is not a single-byte Katakana printable character</TT>
<BR><TT>0x8140 is not a single-byte Katakana printable character</TT>
<BR><TT>0x8260 is not a single-byte Katakana printable character</TT>
<BR><TT>0x82a6 is a single-byte Katakana printable character</TT>
<BR><TT>0x8342 is not a single-byte Katakana printable character</TT>
<BR><TT>0x00a1 is a single-byte Katakana printable character</TT>
<BR><TT>0x00a6 is a single-byte Katakana printable character</TT>
<BR><TT>0x00df is a single-byte Katakana printable character</TT>
<BR><TT>0xe0a1 is a single-byte Katakana printable character</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS
</DL>
<H2 ID="_ismbbkpunct"> _ismbbkpunct </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><TT>int _ismbbkpunct( unsigned int ch );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _ismbbkpunct</TT> function tests if the argument<B> ch</B> is a non-ASCII punctuation character.
<BR><BR>For example, in code page 932,<TT> _ismbbkpunct</TT> tests if the argument<B> ch</B> is a single-byte Katakana punctuation
character.&nbsp; A single-byte Katakana punctuation character is any character for which the following expression is true:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0xA1 &lt;= ch &lt;= 0xA5</TT>
<BR><BR><B>Note:</B>&nbsp; The argument<B> ch</B> must represent a single-byte value (i.e., 0 &lt;=<B> ch</B> &lt;= 255 ).
&nbsp;Incorrect results occur if the argument is a double-byte character.&nbsp; This is shown by the example below.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _ismbbkpunct</TT> function returns a non-zero value if the argument satisfies the condition; otherwise a zero value
is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getmbcp">_getmbcp</A>, <A HREF="#_mbbtombc">_mbbtombc</A>, <A HREF="#_mbcjistojms">_mbcjistojms</A>, <A HREF="#_mbcjmstojis">_mbcjmstojis</A>,
<A HREF="#_mbctombb">_mbctombb</A>, <A HREF="#_ismbbalnum">_ismbbalnum</A>, <A HREF="#_ismbbalpha">_ismbbalpha</A>, <A HREF="#_ismbbgraph">_ismbbgraph</A>,
<A HREF="#_ismbbkalnum">_ismbbkalnum</A>, <A HREF="#_ismbbkalpha">_ismbbkalpha</A>, <A HREF="#_ismbbkana">_ismbbkana</A>,
<A HREF="#_ismbbkprint">_ismbbkprint</A>, <A HREF="#_ismbblead">_ismbblead</A>, <A HREF="#_ismbbprint">_ismbbprint</A>, <A HREF="#_ismbbpunct">_ismbbpunct</A>,
<A HREF="#_ismbbtrail">_ismbbtrail</A>, <A HREF="#_mbbtombc">_mbbtombc</A>, <A HREF="#_mbcjistojms">_mbcjistojms</A>, <A HREF="#_mbcjmstojis">_mbcjmstojis</A>,
<A HREF="#_mbctombb">_mbctombb</A>, <A HREF="#_mbbtype">_mbbtype</A>, <A HREF="#_setmbcp">_setmbcp</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><BR><TT>unsigned int chars[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ' ',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '.',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '1',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'A',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8140, /* double-byte space */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8260, /* double-byte A */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x82A6, /* double-byte Hiragana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8342, /* double-byte Katakana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA1,&nbsp;&nbsp; /* single-byte Katakana punctuation */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA6,&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xDF,&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xE0A1&nbsp; /* double-byte Kanji */</TT>
<BR><TT>};</TT>
<BR><BR><TT>#define SIZE sizeof( chars ) / sizeof( unsigned int )</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x is %sa single-byte &quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;Katakana punctuation character\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars[i],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( _ismbbkpunct( chars[i] ) ) ? &quot;&quot; : &quot;not
&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>0x0020 is not a single-byte Katakana punctuation character</TT>
<BR><TT>0x002e is not a single-byte Katakana punctuation character</TT>
<BR><TT>0x0031 is not a single-byte Katakana punctuation character</TT>
<BR><TT>0x0041 is not a single-byte Katakana punctuation character</TT>
<BR><TT>0x8140 is not a single-byte Katakana punctuation character</TT>
<BR><TT>0x8260 is not a single-byte Katakana punctuation character</TT>
<BR><TT>0x82a6 is not a single-byte Katakana punctuation character</TT>
<BR><TT>0x8342 is not a single-byte Katakana punctuation character</TT>
<BR><TT>0x00a1 is a single-byte Katakana punctuation character</TT>
<BR><TT>0x00a6 is not a single-byte Katakana punctuation character</TT>
<BR><TT>0x00df is not a single-byte Katakana punctuation character</TT>
<BR><TT>0xe0a1 is a single-byte Katakana punctuation character</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS
</DL>
<H2 ID="_ismbblead"> _ismbblead </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><TT>int _ismbblead( unsigned int ch );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _ismbblead</TT> function tests if the argument<B> ch</B> is a valid first byte of a multibyte character.
<BR><BR>For example, in code page 932, valid ranges are 0x81 through 0x9F and 0xE0 through 0xFC.
<BR><BR><B>Note:</B>&nbsp; The argument<B> ch</B> must represent a single-byte value (i.e., 0 &lt;=<B> ch</B> &lt;= 255 ).
&nbsp;Incorrect results occur if the argument is a double-byte character.
</DL>
<DL>
<DT>Returns:
<DD><TT> _ismbblead</TT> returns a non-zero value if the argument is valid as the first byte of a multibyte character; otherwise
zero is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getmbcp">_getmbcp</A>, <A HREF="#_mbbtombc">_mbbtombc</A>, <A HREF="#_mbcjistojms">_mbcjistojms</A>, <A HREF="#_mbcjmstojis">_mbcjmstojis</A>,
<A HREF="#_mbctombb">_mbctombb</A>, <A HREF="#_ismbbalnum">_ismbbalnum</A>, <A HREF="#_ismbbalpha">_ismbbalpha</A>, <A HREF="#_ismbbgraph">_ismbbgraph</A>,
<A HREF="#_ismbbkalnum">_ismbbkalnum</A>, <A HREF="#_ismbbkalpha">_ismbbkalpha</A>, <A HREF="#_ismbbkana">_ismbbkana</A>,
<A HREF="#_ismbbkprint">_ismbbkprint</A>, <A HREF="#_ismbbkpunct">_ismbbkpunct</A>, <A HREF="#_ismbbprint">_ismbbprint</A>,
<A HREF="#_ismbbpunct">_ismbbpunct</A>, <A HREF="#_ismbbtrail">_ismbbtrail</A>, <A HREF="#_mbbtombc">_mbbtombc</A>, <A HREF="#_mbcjistojms">_mbcjistojms</A>,
<A HREF="#_mbcjmstojis">_mbcjmstojis</A>, <A HREF="#_mbctombb">_mbctombb</A>, <A HREF="#_mbbtype">_mbbtype</A>, <A HREF="#_setmbcp">_setmbcp</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><BR><TT>unsigned int chars[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ' ',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '.',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '1',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'A',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8140, /* double-byte space */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8260, /* double-byte A */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x82A6, /* double-byte Hiragana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8342, /* double-byte Katakana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA1,&nbsp;&nbsp; /* single-byte Katakana punctuation */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA6,&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xDF,&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xE0A1&nbsp; /* double-byte Kanji */</TT>
<BR><TT>};</TT>
<BR><BR><TT>#define SIZE sizeof( chars ) / sizeof( unsigned int )</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x does %shave a valid first byte\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars[i],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( _ismbblead( chars[i]&gt;&gt;8 ) ) ? &quot;&quot;
: &quot;not &quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>0x0020 does not have a valid first byte</TT>
<BR><TT>0x002e does not have a valid first byte</TT>
<BR><TT>0x0031 does not have a valid first byte</TT>
<BR><TT>0x0041 does not have a valid first byte</TT>
<BR><TT>0x8140 does have a valid first byte</TT>
<BR><TT>0x8260 does have a valid first byte</TT>
<BR><TT>0x82a6 does have a valid first byte</TT>
<BR><TT>0x8342 does have a valid first byte</TT>
<BR><TT>0x00a1 does not have a valid first byte</TT>
<BR><TT>0x00a6 does not have a valid first byte</TT>
<BR><TT>0x00df does not have a valid first byte</TT>
<BR><TT>0xe0a1 does have a valid first byte</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, Linux, RDOS
</DL>
<H2 ID="_ismbbprint"> _ismbbprint </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><TT>int _ismbbprint( unsigned int ch );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _ismbbprint</TT> function tests if the argument<B> ch</B> is a single-byte printable character including space (&quot;
&quot;).
<BR><BR>For example, in code page 932,<TT> _ismbbprint</TT> tests if the argument<B> ch</B> is a single-byte printable character
including space (&quot; &quot;) or a single-byte Katakana character.&nbsp; These are any characters for which the following
expression is true:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; isprint(ch) || _ismbbkprint(ch)</TT>
<BR><BR><B>Note:</B>&nbsp; The argument<B> ch</B> must represent a single-byte value (i.e., 0 &lt;=<B> ch</B> &lt;= 255 ).
&nbsp;Incorrect results occur if the argument is a double-byte character.&nbsp; This is shown by the example below.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _ismbbprint</TT> function returns a non-zero value if the argument satisfies the condition; otherwise a zero value
is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getmbcp">_getmbcp</A>, <A HREF="#_mbbtombc">_mbbtombc</A>, <A HREF="#_mbcjistojms">_mbcjistojms</A>, <A HREF="#_mbcjmstojis">_mbcjmstojis</A>,
<A HREF="#_mbctombb">_mbctombb</A>, <A HREF="#_ismbbalnum">_ismbbalnum</A>, <A HREF="#_ismbbalpha">_ismbbalpha</A>, <A HREF="#_ismbbgraph">_ismbbgraph</A>,
<A HREF="#_ismbbkalnum">_ismbbkalnum</A>, <A HREF="#_ismbbkalpha">_ismbbkalpha</A>, <A HREF="#_ismbbkana">_ismbbkana</A>,
<A HREF="#_ismbbkprint">_ismbbkprint</A>, <A HREF="#_ismbbkpunct">_ismbbkpunct</A>, <A HREF="#_ismbblead">_ismbblead</A>,
<A HREF="#_ismbbpunct">_ismbbpunct</A>, <A HREF="#_ismbbtrail">_ismbbtrail</A>, <A HREF="#_mbbtombc">_mbbtombc</A>, <A HREF="#_mbcjistojms">_mbcjistojms</A>,
<A HREF="#_mbcjmstojis">_mbcjmstojis</A>, <A HREF="#_mbctombb">_mbctombb</A>, <A HREF="#_mbbtype">_mbbtype</A>, <A HREF="#_setmbcp">_setmbcp</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><BR><TT>unsigned int chars[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x0D,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '.',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '1',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'A',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8140, /* double-byte space */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8260, /* double-byte A */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x82A6, /* double-byte Hiragana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8342, /* double-byte Katakana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA1,&nbsp;&nbsp; /* single-byte Katakana punctuation */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA6,&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xDF,&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xE0A1&nbsp; /* double-byte Kanji */</TT>
<BR><TT>};</TT>
<BR><BR><TT>#define SIZE sizeof( chars ) / sizeof( unsigned int )</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x is %sa single-byte &quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;printable character\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars[i],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( _ismbbprint( chars[i] ) ) ? &quot;&quot; : &quot;not
&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>0x000d is not a single-byte printable character</TT>
<BR><TT>0x002e is a single-byte printable character</TT>
<BR><TT>0x0031 is a single-byte printable character</TT>
<BR><TT>0x0041 is a single-byte printable character</TT>
<BR><TT>0x8140 is a single-byte printable character</TT>
<BR><TT>0x8260 is a single-byte printable character</TT>
<BR><TT>0x82a6 is a single-byte printable character</TT>
<BR><TT>0x8342 is a single-byte printable character</TT>
<BR><TT>0x00a1 is a single-byte printable character</TT>
<BR><TT>0x00a6 is a single-byte printable character</TT>
<BR><TT>0x00df is a single-byte printable character</TT>
<BR><TT>0xe0a1 is a single-byte printable character</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS
</DL>
<H2 ID="_ismbbpunct"> _ismbbpunct </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><TT>int _ismbbpunct( unsigned int ch );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _ismbbpunct</TT> function tests if the argument<B> ch</B> is a single-byte punctuation character.
<BR><BR>For example, in code page 932,<TT> _ismbbpunct</TT> tests if the argument<B> ch</B> is a single-byte punctuation character
or a single-byte Katakana punctuation character.&nbsp; These are any characters for which the following expression is true:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ispunct(ch) || _ismbbkpunct(ch)</TT>
<BR><BR><B>Note:</B>&nbsp; The argument<B> ch</B> must represent a single-byte value (i.e., 0 &lt;=<B> ch</B> &lt;= 255 ).
&nbsp;Incorrect results occur if the argument is a double-byte character.&nbsp; This is shown by the example below.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _ismbbpunct</TT> function returns a non-zero value if the argument satisfies the condition; otherwise a zero value
is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getmbcp">_getmbcp</A>, <A HREF="#_mbbtombc">_mbbtombc</A>, <A HREF="#_mbcjistojms">_mbcjistojms</A>, <A HREF="#_mbcjmstojis">_mbcjmstojis</A>,
<A HREF="#_mbctombb">_mbctombb</A>, <A HREF="#_ismbbalnum">_ismbbalnum</A>, <A HREF="#_ismbbalpha">_ismbbalpha</A>, <A HREF="#_ismbbgraph">_ismbbgraph</A>,
<A HREF="#_ismbbkalnum">_ismbbkalnum</A>, <A HREF="#_ismbbkalpha">_ismbbkalpha</A>, <A HREF="#_ismbbkana">_ismbbkana</A>,
<A HREF="#_ismbbkprint">_ismbbkprint</A>, <A HREF="#_ismbbkpunct">_ismbbkpunct</A>, <A HREF="#_ismbblead">_ismbblead</A>,
<A HREF="#_ismbbprint">_ismbbprint</A>, <A HREF="#_ismbbtrail">_ismbbtrail</A>, <A HREF="#_mbbtombc">_mbbtombc</A>, <A HREF="#_mbcjistojms">_mbcjistojms</A>,
<A HREF="#_mbcjmstojis">_mbcjmstojis</A>, <A HREF="#_mbctombb">_mbctombb</A>, <A HREF="#_mbbtype">_mbbtype</A>, <A HREF="#_setmbcp">_setmbcp</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><BR><TT>unsigned int chars[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ' ',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '.',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '1',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'A',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8140, /* double-byte space */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8260, /* double-byte A */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x82A6, /* double-byte Hiragana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8342, /* double-byte Katakana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA1,&nbsp;&nbsp; /* single-byte Katakana punctuation */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA6,&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xDF,&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xE0A1&nbsp; /* double-byte Kanji */</TT>
<BR><TT>};</TT>
<BR><BR><TT>#define SIZE sizeof( chars ) / sizeof( unsigned int )</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x is %sa single-byte &quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;punctuation character\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars[i],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( _ismbbpunct( chars[i] ) ) ? &quot;&quot; : &quot;not
&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>0x0020 is not a single-byte punctuation character</TT>
<BR><TT>0x002e is a single-byte punctuation character</TT>
<BR><TT>0x0031 is not a single-byte punctuation character</TT>
<BR><TT>0x0041 is not a single-byte punctuation character</TT>
<BR><TT>0x8140 is a single-byte punctuation character</TT>
<BR><TT>0x8260 is a single-byte punctuation character</TT>
<BR><TT>0x82a6 is not a single-byte punctuation character</TT>
<BR><TT>0x8342 is not a single-byte punctuation character</TT>
<BR><TT>0x00a1 is a single-byte punctuation character</TT>
<BR><TT>0x00a6 is not a single-byte punctuation character</TT>
<BR><TT>0x00df is not a single-byte punctuation character</TT>
<BR><TT>0xe0a1 is a single-byte punctuation character</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS
</DL>
<H2 ID="_ismbbtrail"> _ismbbtrail </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>int _ismbbtrail( unsigned int ch );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _ismbbtrail</TT> function tests if<B> ch</B> is a valid second byte of a multibyte character.
<BR><BR>For example, in code page 932, valid ranges are 0x40 through 0x7E and 0x80 through 0xFC.
<BR><BR><B>Note:</B>&nbsp; Only the least significant (trailing) byte of the argument<B> ch</B> is tested.&nbsp; If the argument
is a double-byte character, the leading byte is ignored and may be invalid.&nbsp; This is shown by the example below.
</DL>
<DL>
<DT>Returns:
<DD><TT> _ismbbtrail</TT> returns a non-zero value if the argument is valid as the second byte of a multibyte character; otherwise
zero is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getmbcp">_getmbcp</A>, <A HREF="#_mbbtombc">_mbbtombc</A>, <A HREF="#_mbcjistojms">_mbcjistojms</A>, <A HREF="#_mbcjmstojis">_mbcjmstojis</A>,
<A HREF="#_mbctombb">_mbctombb</A>, <A HREF="#_ismbbalnum">_ismbbalnum</A>, <A HREF="#_ismbbalpha">_ismbbalpha</A>, <A HREF="#_ismbbgraph">_ismbbgraph</A>,
<A HREF="#_ismbbkalnum">_ismbbkalnum</A>, <A HREF="#_ismbbkalpha">_ismbbkalpha</A>, <A HREF="#_ismbbkana">_ismbbkana</A>,
<A HREF="#_ismbbkprint">_ismbbkprint</A>, <A HREF="#_ismbbkpunct">_ismbbkpunct</A>, <A HREF="#_ismbblead">_ismbblead</A>,
<A HREF="#_ismbbprint">_ismbbprint</A>, <A HREF="#_ismbbpunct">_ismbbpunct</A>, <A HREF="#_mbbtombc">_mbbtombc</A>, <A HREF="#_mbcjistojms">_mbcjistojms</A>,
<A HREF="#_mbcjmstojis">_mbcjmstojis</A>, <A HREF="#_mbctombb">_mbctombb</A>, <A HREF="#_mbbtype">_mbbtype</A>, <A HREF="#_setmbcp">_setmbcp</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><BR><TT>unsigned int chars[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ' ',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '.',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '1',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'A',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8140, /* double-byte space */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8260, /* double-byte A */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x82A6, /* double-byte Hiragana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8342, /* double-byte Katakana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA1,&nbsp;&nbsp; /* single-byte Katakana punctuation */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA6,&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xDF,&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xE0A1&nbsp; /* double-byte Kanji */</TT>
<BR><TT>};</TT>
<BR><BR><TT>#define SIZE sizeof( chars ) / sizeof( unsigned int )</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x does %shave a valid second byte\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars[i],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( _ismbbtrail(chars[i]&amp;0xff) ) ? &quot;&quot;
: &quot;not &quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>0x0020 does not have a valid second byte</TT>
<BR><TT>0x002e does not have a valid second byte</TT>
<BR><TT>0x0031 does not have a valid second byte</TT>
<BR><TT>0x0041 does have a valid second byte</TT>
<BR><TT>0x8140 does have a valid second byte</TT>
<BR><TT>0x8260 does have a valid second byte</TT>
<BR><TT>0x82a6 does have a valid second byte</TT>
<BR><TT>0x8342 does have a valid second byte</TT>
<BR><TT>0x00a1 does have a valid second byte</TT>
<BR><TT>0x00a6 does have a valid second byte</TT>
<BR><TT>0x00df does have a valid second byte</TT>
<BR><TT>0xe0a1 does have a valid second byte</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS
</DL>
<H2 ID="_ismbcalnum"> _ismbcalnum </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>int _ismbcalnum( unsigned int ch );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _ismbcalnum</TT> function tests if the multibyte character argument<B> ch</B> is an alphanumeric character.&nbsp;
For example, in code page 932, 'A' through 'Z', 'a' through 'z', or '0' through '9' and its corresponding double-byte versions
are alphanumeric (among others).&nbsp; An alphanumeric character is any character for which <TT> _ismbcalpha</TT> or <TT>
_ismbcdigit</TT> is true.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _ismbcalnum</TT> function returns zero if the argument is not an alphanumeric character; otherwise, a non-zero value
is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getmbcp">_getmbcp</A>, <A HREF="#_ismbcalpha">_ismbcalpha</A>, <A HREF="#_ismbccntrl">_ismbccntrl</A>, <A HREF="#_ismbcdigit">_ismbcdigit</A>,
<A HREF="#_ismbcgraph">_ismbcgraph</A>, <A HREF="#_ismbchira">_ismbchira</A>, <A HREF="#_ismbckata">_ismbckata</A>, <A HREF="#_ismbcl0">_ismbcl0</A>,
<A HREF="#_ismbcl1">_ismbcl1</A>, <A HREF="#_ismbcl2">_ismbcl2</A>, <A HREF="#_ismbclegal">_ismbclegal</A>, <A HREF="#_ismbclower">_ismbclower</A>,
<A HREF="#_ismbcprint">_ismbcprint</A>, <A HREF="#_ismbcpunct">_ismbcpunct</A>, <A HREF="#_ismbcspace">_ismbcspace</A>, <A HREF="#_ismbcsymbol">_ismbcsymbol</A>,
<A HREF="#_ismbcupper">_ismbcupper</A>, <A HREF="#_ismbcxdigit">_ismbcxdigit</A>, <A HREF="#_mbbtype">_mbbtype</A>, <A HREF="#_setmbcp">_setmbcp</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><BR><TT>unsigned int chars[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '.',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '1',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'A',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8143, /* double-byte , */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8254, /* double-byte 5 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8260, /* double-byte A */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8279, /* double-byte Z */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8281, /* double-byte a */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x829A, /* double-byte z */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x829F, /* double-byte Hiragana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8340, /* double-byte Katakana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x837F, /* illegal double-byte character */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x889E, /* double-byte L0 character */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x889F, /* double-byte L1 character */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x989F, /* double-byte L2 character */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA6&nbsp;&nbsp;&nbsp; /* single-byte Katakana */</TT>
<BR><TT>};</TT>
<BR><BR><TT>#define SIZE sizeof( chars ) / sizeof( unsigned int )</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x is %sa valid &quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;multibyte alphanumeric character\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars[i],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( _ismbcalnum( chars[i] ) ) ? &quot;&quot; : &quot;not
&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>0x002e is not a valid multibyte alphanumeric character</TT>
<BR><TT>0x0031 is a valid multibyte alphanumeric character</TT>
<BR><TT>0x0041 is a valid multibyte alphanumeric character</TT>
<BR><TT>0x8143 is not a valid multibyte alphanumeric character</TT>
<BR><TT>0x8254 is a valid multibyte alphanumeric character</TT>
<BR><TT>0x8260 is a valid multibyte alphanumeric character</TT>
<BR><TT>0x8279 is a valid multibyte alphanumeric character</TT>
<BR><TT>0x8281 is a valid multibyte alphanumeric character</TT>
<BR><TT>0x829a is a valid multibyte alphanumeric character</TT>
<BR><TT>0x829f is a valid multibyte alphanumeric character</TT>
<BR><TT>0x8340 is a valid multibyte alphanumeric character</TT>
<BR><TT>0x837f is not a valid multibyte alphanumeric character</TT>
<BR><TT>0x889e is not a valid multibyte alphanumeric character</TT>
<BR><TT>0x889f is a valid multibyte alphanumeric character</TT>
<BR><TT>0x989f is a valid multibyte alphanumeric character</TT>
<BR><TT>0x00a6 is a valid multibyte alphanumeric character</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS
</DL>
<H2 ID="_ismbcalpha"> _ismbcalpha </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>int _ismbcalpha( unsigned int ch );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _ismbcalpha</TT> function tests if the multibyte character argument<B> ch</B> is an alphabetic character.&nbsp; For
example, in code page 932, 'A' through 'Z' or 'a' through 'z' and its corresponding double-byte versions and the Katakana
letters (0xA6 through 0xDF) are alphabetic.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _ismbcalpha</TT> function returns zero if the argument is not an alphabetic character; otherwise, a non-zero value
is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getmbcp">_getmbcp</A>, <A HREF="#_ismbcalnum">_ismbcalnum</A>, <A HREF="#_ismbccntrl">_ismbccntrl</A>, <A HREF="#_ismbcdigit">_ismbcdigit</A>,
<A HREF="#_ismbcgraph">_ismbcgraph</A>, <A HREF="#_ismbchira">_ismbchira</A>, <A HREF="#_ismbckata">_ismbckata</A>, <A HREF="#_ismbcl0">_ismbcl0</A>,
<A HREF="#_ismbcl1">_ismbcl1</A>, <A HREF="#_ismbcl2">_ismbcl2</A>, <A HREF="#_ismbclegal">_ismbclegal</A>, <A HREF="#_ismbclower">_ismbclower</A>,
<A HREF="#_ismbcprint">_ismbcprint</A>, <A HREF="#_ismbcpunct">_ismbcpunct</A>, <A HREF="#_ismbcspace">_ismbcspace</A>, <A HREF="#_ismbcsymbol">_ismbcsymbol</A>,
<A HREF="#_ismbcupper">_ismbcupper</A>, <A HREF="#_ismbcxdigit">_ismbcxdigit</A>, <A HREF="#_mbbtype">_mbbtype</A>, <A HREF="#_setmbcp">_setmbcp</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><BR><TT>unsigned int chars[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '.',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '1',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'A',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8143, /* double-byte , */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8254, /* double-byte 5 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8260, /* double-byte A */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8279, /* double-byte Z */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8281, /* double-byte a */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x829A, /* double-byte z */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x829F, /* double-byte Hiragana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8340, /* double-byte Katakana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x837F, /* illegal double-byte character */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x889E, /* double-byte L0 character */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x889F, /* double-byte L1 character */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x989F, /* double-byte L2 character */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA6&nbsp;&nbsp;&nbsp; /* single-byte Katakana */</TT>
<BR><TT>};</TT>
<BR><BR><TT>#define SIZE sizeof( chars ) / sizeof( unsigned int )</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x is %sa valid &quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;multibyte alphabetic character\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars[i],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( _ismbcalpha( chars[i] ) ) ? &quot;&quot; : &quot;not
&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>0x002e is not a valid multibyte alphabetic character</TT>
<BR><TT>0x0031 is not a valid multibyte alphabetic character</TT>
<BR><TT>0x0041 is a valid multibyte alphabetic character</TT>
<BR><TT>0x8143 is not a valid multibyte alphabetic character</TT>
<BR><TT>0x8254 is not a valid multibyte alphabetic character</TT>
<BR><TT>0x8260 is a valid multibyte alphabetic character</TT>
<BR><TT>0x8279 is a valid multibyte alphabetic character</TT>
<BR><TT>0x8281 is a valid multibyte alphabetic character</TT>
<BR><TT>0x829a is a valid multibyte alphabetic character</TT>
<BR><TT>0x829f is a valid multibyte alphabetic character</TT>
<BR><TT>0x8340 is a valid multibyte alphabetic character</TT>
<BR><TT>0x837f is not a valid multibyte alphabetic character</TT>
<BR><TT>0x889e is not a valid multibyte alphabetic character</TT>
<BR><TT>0x889f is a valid multibyte alphabetic character</TT>
<BR><TT>0x989f is a valid multibyte alphabetic character</TT>
<BR><TT>0x00a6 is a valid multibyte alphabetic character</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS
</DL>
<H2 ID="_ismbccntrl"> _ismbccntrl </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>int _ismbccntrl( unsigned int ch );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _ismbccntrl</TT> function tests for any multibyte control character.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _ismbccntrl</TT> function returns a non-zero value when the argument is a member of this set of characters; otherwise,
zero is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getmbcp">_getmbcp</A>, <A HREF="#_ismbcalnum">_ismbcalnum</A>, <A HREF="#_ismbcalpha">_ismbcalpha</A>, <A HREF="#_ismbcdigit">_ismbcdigit</A>,
<A HREF="#_ismbcgraph">_ismbcgraph</A>, <A HREF="#_ismbchira">_ismbchira</A>, <A HREF="#_ismbckata">_ismbckata</A>, <A HREF="#_ismbcl0">_ismbcl0</A>,
<A HREF="#_ismbcl1">_ismbcl1</A>, <A HREF="#_ismbcl2">_ismbcl2</A>, <A HREF="#_ismbclegal">_ismbclegal</A>, <A HREF="#_ismbclower">_ismbclower</A>,
<A HREF="#_ismbcprint">_ismbcprint</A>, <A HREF="#_ismbcpunct">_ismbcpunct</A>, <A HREF="#_ismbcspace">_ismbcspace</A>, <A HREF="#_ismbcsymbol">_ismbcsymbol</A>,
<A HREF="#_ismbcupper">_ismbcupper</A>, <A HREF="#_ismbcxdigit">_ismbcxdigit</A>, <A HREF="#_mbbtype">_mbbtype</A>, <A HREF="#_setmbcp">_setmbcp</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><BR><TT>unsigned int chars[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x0D,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '.',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ' ',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '1',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'A',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8140, /* double-byte space */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8143, /* double-byte , */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8254, /* double-byte 5 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8260, /* double-byte A */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8279, /* double-byte Z */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8281, /* double-byte a */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x829A, /* double-byte z */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x989F, /* double-byte L2 character */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA6</TT>
<BR><TT>};</TT>
<BR><BR><TT>#define SIZE sizeof( chars ) / sizeof( unsigned int )</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x is %sa valid &quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;multibyte control character\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars[i],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( _ismbccntrl( chars[i] ) ) ? &quot;&quot; : &quot;not
&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>0x000d is a valid multibyte control character</TT>
<BR><TT>0x002e is not a valid multibyte control character</TT>
<BR><TT>0x0020 is not a valid multibyte control character</TT>
<BR><TT>0x0031 is not a valid multibyte control character</TT>
<BR><TT>0x0041 is not a valid multibyte control character</TT>
<BR><TT>0x8140 is a valid multibyte control character</TT>
<BR><TT>0x8143 is a valid multibyte control character</TT>
<BR><TT>0x8254 is not a valid multibyte control character</TT>
<BR><TT>0x8260 is not a valid multibyte control character</TT>
<BR><TT>0x8279 is not a valid multibyte control character</TT>
<BR><TT>0x8281 is not a valid multibyte control character</TT>
<BR><TT>0x829a is not a valid multibyte control character</TT>
<BR><TT>0x989f is not a valid multibyte control character</TT>
<BR><TT>0x00a6 is not a valid multibyte control character</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS
</DL>
<H2 ID="_ismbcdigit"> _ismbcdigit </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>int _ismbcdigit( unsigned int ch );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _ismbcdigit</TT> function tests for any multibyte decimal-digit character '0' through '9'.&nbsp; In code page 932,
this includes the corresponding double-byte versions of these characters.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _ismbcdigit</TT> function returns a non-zero value when the argument is a decimal-digit character.&nbsp; Otherwise,
zero is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getmbcp">_getmbcp</A>, <A HREF="#_ismbcalnum">_ismbcalnum</A>, <A HREF="#_ismbcalpha">_ismbcalpha</A>, <A HREF="#_ismbccntrl">_ismbccntrl</A>,
<A HREF="#_ismbcgraph">_ismbcgraph</A>, <A HREF="#_ismbchira">_ismbchira</A>, <A HREF="#_ismbckata">_ismbckata</A>, <A HREF="#_ismbcl0">_ismbcl0</A>,
<A HREF="#_ismbcl1">_ismbcl1</A>, <A HREF="#_ismbcl2">_ismbcl2</A>, <A HREF="#_ismbclegal">_ismbclegal</A>, <A HREF="#_ismbclower">_ismbclower</A>,
<A HREF="#_ismbcprint">_ismbcprint</A>, <A HREF="#_ismbcpunct">_ismbcpunct</A>, <A HREF="#_ismbcspace">_ismbcspace</A>, <A HREF="#_ismbcsymbol">_ismbcsymbol</A>,
<A HREF="#_ismbcupper">_ismbcupper</A>, <A HREF="#_ismbcxdigit">_ismbcxdigit</A>, <A HREF="#_mbbtype">_mbbtype</A>, <A HREF="#_setmbcp">_setmbcp</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><BR><TT>unsigned int chars[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '.',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '1',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'A',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8143, /* double-byte , */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8183, /* double-byte &lt; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8254, /* double-byte 5 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8277, /* double-byte X */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA6</TT>
<BR><TT>};</TT>
<BR><BR><TT>#define SIZE sizeof( chars ) / sizeof( unsigned int )</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x is %sa valid &quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;multibyte digit character\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars[i],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( _ismbcdigit( chars[i] ) ) ? &quot;&quot; : &quot;not
&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>0x002e is not a valid multibyte digit character</TT>
<BR><TT>0x0031 is a valid multibyte digit character</TT>
<BR><TT>0x0041 is not a valid multibyte digit character</TT>
<BR><TT>0x8143 is not a valid multibyte digit character</TT>
<BR><TT>0x8183 is not a valid multibyte digit character</TT>
<BR><TT>0x8254 is a valid multibyte digit character</TT>
<BR><TT>0x8277 is not a valid multibyte digit character</TT>
<BR><TT>0x00a6 is not a valid multibyte digit character</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS
</DL>
<H2 ID="_ismbcgraph"> _ismbcgraph </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>int _ismbcgraph( unsigned int ch );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _ismbcgraph</TT> function tests for any printable multibyte character except space (' ').&nbsp; The <TT> _ismbcprint</TT>
function is similar, except that the space character is also included in the character set being tested.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _ismbcgraph</TT> function returns a non-zero value when the argument is a member of this set of characters; otherwise,
zero is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getmbcp">_getmbcp</A>, <A HREF="#_ismbcalnum">_ismbcalnum</A>, <A HREF="#_ismbcalpha">_ismbcalpha</A>, <A HREF="#_ismbccntrl">_ismbccntrl</A>,
<A HREF="#_ismbcdigit">_ismbcdigit</A>, <A HREF="#_ismbchira">_ismbchira</A>, <A HREF="#_ismbckata">_ismbckata</A>, <A HREF="#_ismbcl0">_ismbcl0</A>,
<A HREF="#_ismbcl1">_ismbcl1</A>, <A HREF="#_ismbcl2">_ismbcl2</A>, <A HREF="#_ismbclegal">_ismbclegal</A>, <A HREF="#_ismbclower">_ismbclower</A>,
<A HREF="#_ismbcprint">_ismbcprint</A>, <A HREF="#_ismbcpunct">_ismbcpunct</A>, <A HREF="#_ismbcspace">_ismbcspace</A>, <A HREF="#_ismbcsymbol">_ismbcsymbol</A>,
<A HREF="#_ismbcupper">_ismbcupper</A>, <A HREF="#_ismbcxdigit">_ismbcxdigit</A>, <A HREF="#_mbbtype">_mbbtype</A>, <A HREF="#_setmbcp">_setmbcp</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><BR><TT>unsigned int chars[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '.',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ' ',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '1',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'A',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8140, /* double-byte space */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8143, /* double-byte , */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8254, /* double-byte 5 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8260, /* double-byte A */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8279, /* double-byte Z */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8281, /* double-byte a */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x829A, /* double-byte z */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x989F, /* double-byte L2 character */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA6</TT>
<BR><TT>};</TT>
<BR><BR><TT>#define SIZE sizeof( chars ) / sizeof( unsigned int )</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x is %sa valid &quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;multibyte graph character\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars[i],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( _ismbcgraph( chars[i] ) ) ? &quot;&quot; : &quot;not
&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>0x002e is a valid multibyte graph character</TT>
<BR><TT>0x0020 is not a valid multibyte graph character</TT>
<BR><TT>0x0031 is a valid multibyte graph character</TT>
<BR><TT>0x0041 is a valid multibyte graph character</TT>
<BR><TT>0x8140 is not a valid multibyte graph character</TT>
<BR><TT>0x8143 is a valid multibyte graph character</TT>
<BR><TT>0x8254 is a valid multibyte graph character</TT>
<BR><TT>0x8260 is a valid multibyte graph character</TT>
<BR><TT>0x8279 is a valid multibyte graph character</TT>
<BR><TT>0x8281 is a valid multibyte graph character</TT>
<BR><TT>0x829a is a valid multibyte graph character</TT>
<BR><TT>0x989f is a valid multibyte graph character</TT>
<BR><TT>0x00a6 is a valid multibyte graph character</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS
</DL>
<H2 ID="_ismbchira"> _ismbchira </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>int _ismbchira( unsigned int ch );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _ismbchira</TT> function tests for a double-byte Hiragana character.&nbsp; A double-byte Hiragana character is any
character for which the following expression is true:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0x829F &lt;= ch &lt;= 0x82F1</TT>
<BR><BR><B>Note:</B>&nbsp; The Japanese double-byte character set includes Kanji, Hiragana, and Katakana characters - both
alphabetic and numeric.&nbsp; Kanji is the ideogram character set of the Japanese character set.&nbsp; Hiragana and Katakana
are two types of phonetic character sets of the Japanese character set.&nbsp; The Hiragana code set includes 83 characters
and the Katakana code set includes 86 characters.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _ismbchira</TT> function returns a non-zero value when the argument is a member of this set of characters; otherwise,
zero is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getmbcp">_getmbcp</A>, <A HREF="#_ismbcalnum">_ismbcalnum</A>, <A HREF="#_ismbcalpha">_ismbcalpha</A>, <A HREF="#_ismbccntrl">_ismbccntrl</A>,
<A HREF="#_ismbcdigit">_ismbcdigit</A>, <A HREF="#_ismbcgraph">_ismbcgraph</A>, <A HREF="#_ismbckata">_ismbckata</A>, <A HREF="#_ismbcl0">_ismbcl0</A>,
<A HREF="#_ismbcl1">_ismbcl1</A>, <A HREF="#_ismbcl2">_ismbcl2</A>, <A HREF="#_ismbclegal">_ismbclegal</A>, <A HREF="#_ismbclower">_ismbclower</A>,
<A HREF="#_ismbcprint">_ismbcprint</A>, <A HREF="#_ismbcpunct">_ismbcpunct</A>, <A HREF="#_ismbcspace">_ismbcspace</A>, <A HREF="#_ismbcsymbol">_ismbcsymbol</A>,
<A HREF="#_ismbcupper">_ismbcupper</A>, <A HREF="#_ismbcxdigit">_ismbcxdigit</A>, <A HREF="#_mbbtype">_mbbtype</A>, <A HREF="#_setmbcp">_setmbcp</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><BR><TT>unsigned int chars[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'A',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8140, /* double-byte space */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8143, /* double-byte , */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8260, /* double-byte A */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x829F, /* double-byte Hiragana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8340, /* double-byte Katakana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x837F, /* illegal double-byte character */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x989F, /* double-byte L2 character */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA6&nbsp;&nbsp;&nbsp; /* single-byte Katakana */</TT>
<BR><TT>};</TT>
<BR><BR><TT>#define SIZE sizeof( chars ) / sizeof( unsigned int )</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x is %sa valid &quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;Hiragana character\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars[i],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( _ismbchira( chars[i] ) ) ? &quot;&quot; : &quot;not
&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>0x0041 is not a valid Hiragana character</TT>
<BR><TT>0x8140 is not a valid Hiragana character</TT>
<BR><TT>0x8143 is not a valid Hiragana character</TT>
<BR><TT>0x8260 is not a valid Hiragana character</TT>
<BR><TT>0x829f is a valid Hiragana character</TT>
<BR><TT>0x8340 is not a valid Hiragana character</TT>
<BR><TT>0x837f is not a valid Hiragana character</TT>
<BR><TT>0x989f is not a valid Hiragana character</TT>
<BR><TT>0x00a6 is not a valid Hiragana character</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS
</DL>
<H2 ID="_ismbckata"> _ismbckata </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>int _ismbckata( unsigned int ch );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _ismbckata</TT> function tests for a double-byte Katakana character.&nbsp; A double-byte Katakana character is any
character for which the following expression is true:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0x8340 &lt;= ch &lt;= 0x8396&nbsp; &amp;&amp;&nbsp; ch != 0x837F</TT>
<BR><BR><B>Note:</B>&nbsp; The Japanese double-byte character set includes Kanji, Hiragana, and Katakana characters - both
alphabetic and numeric.&nbsp; Kanji is the ideogram character set of the Japanese character set.&nbsp; Hiragana and Katakana
are two types of phonetic character sets of the Japanese character set.&nbsp; The Hiragana code set includes 83 characters
and the Katakana code set includes 86 characters.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _ismbckata</TT> function returns a non-zero value when the argument is a member of this set of characters; otherwise,
zero is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getmbcp">_getmbcp</A>, <A HREF="#_ismbcalnum">_ismbcalnum</A>, <A HREF="#_ismbcalpha">_ismbcalpha</A>, <A HREF="#_ismbccntrl">_ismbccntrl</A>,
<A HREF="#_ismbcdigit">_ismbcdigit</A>, <A HREF="#_ismbcgraph">_ismbcgraph</A>, <A HREF="#_ismbchira">_ismbchira</A>, <A HREF="#_ismbcl0">_ismbcl0</A>,
<A HREF="#_ismbcl1">_ismbcl1</A>, <A HREF="#_ismbcl2">_ismbcl2</A>, <A HREF="#_ismbclegal">_ismbclegal</A>, <A HREF="#_ismbclower">_ismbclower</A>,
<A HREF="#_ismbcprint">_ismbcprint</A>, <A HREF="#_ismbcpunct">_ismbcpunct</A>, <A HREF="#_ismbcspace">_ismbcspace</A>, <A HREF="#_ismbcsymbol">_ismbcsymbol</A>,
<A HREF="#_ismbcupper">_ismbcupper</A>, <A HREF="#_ismbcxdigit">_ismbcxdigit</A>, <A HREF="#_mbbtype">_mbbtype</A>, <A HREF="#_setmbcp">_setmbcp</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><BR><TT>unsigned int chars[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'A',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8140, /* double-byte space */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8143, /* double-byte , */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8260, /* double-byte A */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x829F, /* double-byte Hiragana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8340, /* double-byte Katakana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x837F, /* illegal double-byte character */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x989F, /* double-byte L2 character */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA6&nbsp;&nbsp;&nbsp; /* single-byte Katakana */</TT>
<BR><TT>};</TT>
<BR><BR><TT>#define SIZE sizeof( chars ) / sizeof( unsigned int )</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x is %sa valid &quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;Katakana character\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars[i],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( _ismbckata( chars[i] ) ) ? &quot;&quot; : &quot;not
&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>0x0041 is not a valid Katakana character</TT>
<BR><TT>0x8140 is not a valid Katakana character</TT>
<BR><TT>0x8143 is not a valid Katakana character</TT>
<BR><TT>0x8260 is not a valid Katakana character</TT>
<BR><TT>0x829f is not a valid Katakana character</TT>
<BR><TT>0x8340 is a valid Katakana character</TT>
<BR><TT>0x837f is not a valid Katakana character</TT>
<BR><TT>0x989f is not a valid Katakana character</TT>
<BR><TT>0x00a6 is not a valid Katakana character</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS
</DL>
<H2 ID="_ismbcl0"> _ismbcl0 </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>int _ismbcl0( unsigned int ch );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _ismbcl0</TT> function tests if the argument<B> ch</B> is in the set of double-byte characters that include Hiragana,
Katakana, punctuation symbols, graphical symbols, Roman and Cyrillic alphabets, etc.&nbsp; Double-byte Kanji characters are
not in this set.&nbsp; These are any characters for which the following expression is true:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0x8140 &lt;= ch &lt;= 0x889E&nbsp; &amp;&amp;&nbsp; ch != 0x837F</TT>
<BR><BR>The<TT> _ismbcl0</TT> function tests if the argument is a valid double-byte character (i.e., it checks that the lower
byte is not in the ranges 0x00 - 0x3F, 0x7F, or 0xFD - 0xFF).
<BR><BR><B>Note:</B>&nbsp; The Japanese double-byte character set includes Kanji, Hiragana, and Katakana characters - both
alphabetic and numeric.&nbsp; Kanji is the ideogram character set of the Japanese character set.&nbsp; Hiragana and Katakana
are two types of phonetic character sets of the Japanese character set.&nbsp; The Hiragana code set includes 83 characters
and the Katakana code set includes 86 characters.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _ismbcl0</TT> function returns a non-zero value when the argument is a member of this set of characters; otherwise,
zero is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getmbcp">_getmbcp</A>, <A HREF="#_ismbcalnum">_ismbcalnum</A>, <A HREF="#_ismbcalpha">_ismbcalpha</A>, <A HREF="#_ismbccntrl">_ismbccntrl</A>,
<A HREF="#_ismbcdigit">_ismbcdigit</A>, <A HREF="#_ismbcgraph">_ismbcgraph</A>, <A HREF="#_ismbchira">_ismbchira</A>, <A HREF="#_ismbckata">_ismbckata</A>,
<A HREF="#_ismbcl1">_ismbcl1</A>, <A HREF="#_ismbcl2">_ismbcl2</A>, <A HREF="#_ismbclegal">_ismbclegal</A>, <A HREF="#_ismbclower">_ismbclower</A>,
<A HREF="#_ismbcprint">_ismbcprint</A>, <A HREF="#_ismbcpunct">_ismbcpunct</A>, <A HREF="#_ismbcspace">_ismbcspace</A>, <A HREF="#_ismbcsymbol">_ismbcsymbol</A>,
<A HREF="#_ismbcupper">_ismbcupper</A>, <A HREF="#_ismbcxdigit">_ismbcxdigit</A>, <A HREF="#_mbbtype">_mbbtype</A>, <A HREF="#_setmbcp">_setmbcp</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><BR><TT>unsigned int chars[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'A',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8140, /* double-byte space */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8143, /* double-byte , */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8260, /* double-byte A */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x829F, /* double-byte Hiragana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8340, /* double-byte Katakana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x837F, /* illegal double-byte character */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x889E, /* double-byte L0 character */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x889F, /* double-byte L1 character */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x989F, /* double-byte L2 character */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA6&nbsp;&nbsp;&nbsp; /* single-byte Katakana */</TT>
<BR><TT>};</TT>
<BR><BR><TT>#define SIZE sizeof( chars ) / sizeof( unsigned int )</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x is %sa valid &quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;JIS L0 character\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars[i],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( _ismbcl0( chars[i] ) ) ? &quot;&quot; : &quot;not
&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>0x0041 is not a valid JIS L0 character</TT>
<BR><TT>0x8140 is a valid JIS L0 character</TT>
<BR><TT>0x8143 is a valid JIS L0 character</TT>
<BR><TT>0x8260 is a valid JIS L0 character</TT>
<BR><TT>0x829f is a valid JIS L0 character</TT>
<BR><TT>0x8340 is a valid JIS L0 character</TT>
<BR><TT>0x837f is not a valid JIS L0 character</TT>
<BR><TT>0x889e is a valid JIS L0 character</TT>
<BR><TT>0x889f is not a valid JIS L0 character</TT>
<BR><TT>0x989f is not a valid JIS L0 character</TT>
<BR><TT>0x00a6 is not a valid JIS L0 character</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS
</DL>
<H2 ID="_ismbcl1"> _ismbcl1 </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>int _ismbcl1( unsigned int ch );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _ismbcl1</TT> function tests if the argument<B> ch</B> is a JIS (Japan Industrial Standard) level 1 double-byte character
code.&nbsp; These are any valid double-byte characters for which the following expression is true:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0x889F &lt;= ch &lt;= 0x9872</TT>
<BR><BR>The<TT> _ismbcl1</TT> function tests if the argument is a valid double-byte character (i.e., it checks that the lower
byte is not in the ranges 0x00 - 0x3F, 0x7F, or 0xFD - 0xFF).
<BR><BR><B>Note:</B>&nbsp; JIS establishes two levels of the Kanji double-byte character set.&nbsp; One is called double-byte
Kanji code set level 1 and the other is called double-byte Kanji code set level 2.&nbsp; Usually Japanese personal computers
have font ROM/RAM support for both levels.
<BR><BR>Valid double-byte characters are those in which the first byte falls in the range 0x81 - 0x9F or 0xE0 - 0xFC and whose
second byte falls in the range 0x40 - 0x7E or 0x80 - 0xFC.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _ismbcl1</TT> function returns a non-zero value when the argument is a member of this set of characters; otherwise,
zero is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getmbcp">_getmbcp</A>, <A HREF="#_ismbcalnum">_ismbcalnum</A>, <A HREF="#_ismbcalpha">_ismbcalpha</A>, <A HREF="#_ismbccntrl">_ismbccntrl</A>,
<A HREF="#_ismbcdigit">_ismbcdigit</A>, <A HREF="#_ismbcgraph">_ismbcgraph</A>, <A HREF="#_ismbchira">_ismbchira</A>, <A HREF="#_ismbckata">_ismbckata</A>,
<A HREF="#_ismbcl0">_ismbcl0</A>, <A HREF="#_ismbcl2">_ismbcl2</A>, <A HREF="#_ismbclegal">_ismbclegal</A>, <A HREF="#_ismbclower">_ismbclower</A>,
<A HREF="#_ismbcprint">_ismbcprint</A>, <A HREF="#_ismbcpunct">_ismbcpunct</A>, <A HREF="#_ismbcspace">_ismbcspace</A>, <A HREF="#_ismbcsymbol">_ismbcsymbol</A>,
<A HREF="#_ismbcupper">_ismbcupper</A>, <A HREF="#_ismbcxdigit">_ismbcxdigit</A>, <A HREF="#_mbbtype">_mbbtype</A>, <A HREF="#_setmbcp">_setmbcp</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><BR><TT>unsigned int chars[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'A',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8140, /* double-byte space */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8143, /* double-byte , */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8260, /* double-byte A */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x829F, /* double-byte Hiragana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8340, /* double-byte Katakana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x837F, /* illegal double-byte character */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x889E, /* double-byte L0 character */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x889F, /* double-byte L1 character */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x989F, /* double-byte L2 character */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA6&nbsp;&nbsp;&nbsp; /* single-byte Katakana */</TT>
<BR><TT>};</TT>
<BR><BR><TT>#define SIZE sizeof( chars ) / sizeof( unsigned int )</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x is %sa valid &quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;JIS L1 character\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars[i],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( _ismbcl1( chars[i] ) ) ? &quot;&quot; : &quot;not
&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>0x0041 is not a valid JIS L1 character</TT>
<BR><TT>0x8140 is not a valid JIS L1 character</TT>
<BR><TT>0x8143 is not a valid JIS L1 character</TT>
<BR><TT>0x8260 is not a valid JIS L1 character</TT>
<BR><TT>0x829f is not a valid JIS L1 character</TT>
<BR><TT>0x8340 is not a valid JIS L1 character</TT>
<BR><TT>0x837f is not a valid JIS L1 character</TT>
<BR><TT>0x889e is not a valid JIS L1 character</TT>
<BR><TT>0x889f is a valid JIS L1 character</TT>
<BR><TT>0x989f is not a valid JIS L1 character</TT>
<BR><TT>0x00a6 is not a valid JIS L1 character</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS
</DL>
<H2 ID="_ismbcl2"> _ismbcl2 </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>int _ismbcl2( unsigned int ch );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _ismbcl2</TT> function tests if the argument<B> ch</B> is a JIS (Japan Industrial Standard) level 2 double-byte character
code.&nbsp; These are any valid double-byte characters for which the following expression is true:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0x989F &lt;= ch &lt;= 0xEA9E</TT>
<BR><BR>The<TT> _ismbcl2</TT> function tests if the argument is a valid double-byte character (i.e., it checks that the lower
byte is not in the ranges 0x00 - 0x3F, 0x7F, or 0xFD - 0xFF).
<BR><BR><B>Note:</B>&nbsp; JIS establishes two levels of the Kanji double-byte character set.&nbsp; One is called double-byte
Kanji code set level 1 and the other is called double-byte Kanji code set level 2.&nbsp; Usually Japanese personal computers
have font ROM/RAM support for both levels.
<BR><BR>Valid double-byte characters are those in which the first byte falls in the range 0x81 - 0x9F or 0xE0 - 0xFC and whose
second byte falls in the range 0x40 - 0x7E or 0x80 - 0xFC.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _ismbcl2</TT> function returns a non-zero value when the argument is a member of this set of characters; otherwise,
zero is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getmbcp">_getmbcp</A>, <A HREF="#_ismbcalnum">_ismbcalnum</A>, <A HREF="#_ismbcalpha">_ismbcalpha</A>, <A HREF="#_ismbccntrl">_ismbccntrl</A>,
<A HREF="#_ismbcdigit">_ismbcdigit</A>, <A HREF="#_ismbcgraph">_ismbcgraph</A>, <A HREF="#_ismbchira">_ismbchira</A>, <A HREF="#_ismbckata">_ismbckata</A>,
<A HREF="#_ismbcl0">_ismbcl0</A>, <A HREF="#_ismbcl1">_ismbcl1</A>, <A HREF="#_ismbclegal">_ismbclegal</A>, <A HREF="#_ismbclower">_ismbclower</A>,
<A HREF="#_ismbcprint">_ismbcprint</A>, <A HREF="#_ismbcpunct">_ismbcpunct</A>, <A HREF="#_ismbcspace">_ismbcspace</A>, <A HREF="#_ismbcsymbol">_ismbcsymbol</A>,
<A HREF="#_ismbcupper">_ismbcupper</A>, <A HREF="#_ismbcxdigit">_ismbcxdigit</A>, <A HREF="#_mbbtype">_mbbtype</A>, <A HREF="#_setmbcp">_setmbcp</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><BR><TT>unsigned int chars[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'A',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8140, /* double-byte space */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8143, /* double-byte , */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8260, /* double-byte A */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x829F, /* double-byte Hiragana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8340, /* double-byte Katakana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x837F, /* illegal double-byte character */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x889E, /* double-byte L0 character */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x889F, /* double-byte L1 character */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x989F, /* double-byte L2 character */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xEA9E, /* double-byte L2 character */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA6&nbsp;&nbsp;&nbsp; /* single-byte Katakana */</TT>
<BR><TT>};</TT>
<BR><BR><TT>#define SIZE sizeof( chars ) / sizeof( unsigned int )</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x is %sa valid &quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;JIS L2 character\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars[i],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( _ismbcl2( chars[i] ) ) ? &quot;&quot; : &quot;not
&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>0x0041 is not a valid JIS L2 character</TT>
<BR><TT>0x8140 is not a valid JIS L2 character</TT>
<BR><TT>0x8143 is not a valid JIS L2 character</TT>
<BR><TT>0x8260 is not a valid JIS L2 character</TT>
<BR><TT>0x829f is not a valid JIS L2 character</TT>
<BR><TT>0x8340 is not a valid JIS L2 character</TT>
<BR><TT>0x837f is not a valid JIS L2 character</TT>
<BR><TT>0x889e is not a valid JIS L2 character</TT>
<BR><TT>0x889f is not a valid JIS L2 character</TT>
<BR><TT>0x989f is a valid JIS L2 character</TT>
<BR><TT>0xea9e is a valid JIS L2 character</TT>
<BR><TT>0x00a6 is not a valid JIS L2 character</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS
</DL>
<H2 ID="_ismbclegal"> _ismbclegal </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>int _ismbclegal( unsigned int dbch );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _ismbclegal</TT> function tests for a valid multibyte character.&nbsp; Multibyte characters include both single-byte
and double-byte characters.&nbsp; For example, in code page 932, a legal double-byte character is one in which the first byte
is within the ranges 0x81 - 0x9F or 0xE0 - 0xFC, while the second byte is within the ranges 0x40 - 0x7E or 0x80 - 0xFC.&nbsp;
This is summarized in the following diagram.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ 1st byte ]&nbsp;&nbsp;&nbsp; [ 2nd byte ]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x81-0x9F&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x40-0xFC</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; except 0x7F</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xE0-0xFC</TT>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _ismbclegal</TT> function returns a non-zero value when the argument is a member of this set of characters; otherwise,
zero is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getmbcp">_getmbcp</A>, <A HREF="#_ismbcalnum">_ismbcalnum</A>, <A HREF="#_ismbcalpha">_ismbcalpha</A>, <A HREF="#_ismbccntrl">_ismbccntrl</A>,
<A HREF="#_ismbcdigit">_ismbcdigit</A>, <A HREF="#_ismbcgraph">_ismbcgraph</A>, <A HREF="#_ismbchira">_ismbchira</A>, <A HREF="#_ismbckata">_ismbckata</A>,
<A HREF="#_ismbcl0">_ismbcl0</A>, <A HREF="#_ismbcl1">_ismbcl1</A>, <A HREF="#_ismbcl2">_ismbcl2</A>, <A HREF="#_ismbclower">_ismbclower</A>,
<A HREF="#_ismbcprint">_ismbcprint</A>, <A HREF="#_ismbcpunct">_ismbcpunct</A>, <A HREF="#_ismbcspace">_ismbcspace</A>, <A HREF="#_ismbcsymbol">_ismbcsymbol</A>,
<A HREF="#_ismbcupper">_ismbcupper</A>, <A HREF="#_ismbcxdigit">_ismbcxdigit</A>, <A HREF="#_mbbtype">_mbbtype</A>, <A HREF="#_setmbcp">_setmbcp</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><BR><TT>unsigned int chars[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'A',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8131, /* illegal double-byte character */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8140, /* double-byte space */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8143, /* double-byte , */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8260, /* double-byte A */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x829F, /* double-byte Hiragana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8340, /* double-byte Katakana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x837F, /* illegal double-byte character */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x889E, /* double-byte L0 character */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x889F, /* double-byte L1 character */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x989F, /* double-byte L2 character */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xEA9E, /* double-byte L2 character */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA6&nbsp;&nbsp;&nbsp; /* single-byte Katakana */</TT>
<BR><TT>};</TT>
<BR><BR><TT>#define SIZE sizeof( chars ) / sizeof( unsigned int )</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x is %sa legal &quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;double-byte character\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars[i],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( _ismbclegal( chars[i] ) ) ? &quot;&quot; : &quot;not
&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>0x0041 is not a legal double-byte character</TT>
<BR><TT>0x8131 is not a legal double-byte character</TT>
<BR><TT>0x8140 is a legal double-byte character</TT>
<BR><TT>0x8143 is a legal double-byte character</TT>
<BR><TT>0x8260 is a legal double-byte character</TT>
<BR><TT>0x829f is a legal double-byte character</TT>
<BR><TT>0x8340 is a legal double-byte character</TT>
<BR><TT>0x837f is not a legal double-byte character</TT>
<BR><TT>0x889e is a legal double-byte character</TT>
<BR><TT>0x889f is a legal double-byte character</TT>
<BR><TT>0x989f is a legal double-byte character</TT>
<BR><TT>0xea9e is a legal double-byte character</TT>
<BR><TT>0x00a6 is not a legal double-byte character</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS
</DL>
<H2 ID="_ismbclower"> _ismbclower </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>int _ismbclower( unsigned int ch );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _ismbclower</TT> function tests for a valid lowercase multibyte character.&nbsp; Multibyte characters include both
single-byte and double-byte characters.&nbsp; For example, in code page 932, a lowercase double-byte character is one for
which the following expression is true:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0x8281 &lt;= c &lt;= 0x829A</TT>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _ismbclower</TT> function returns a non-zero value when the argument is a member of this set of characters; otherwise,
zero is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getmbcp">_getmbcp</A>, <A HREF="#_ismbcalnum">_ismbcalnum</A>, <A HREF="#_ismbcalpha">_ismbcalpha</A>, <A HREF="#_ismbccntrl">_ismbccntrl</A>,
<A HREF="#_ismbcdigit">_ismbcdigit</A>, <A HREF="#_ismbcgraph">_ismbcgraph</A>, <A HREF="#_ismbchira">_ismbchira</A>, <A HREF="#_ismbckata">_ismbckata</A>,
<A HREF="#_ismbcl0">_ismbcl0</A>, <A HREF="#_ismbcl1">_ismbcl1</A>, <A HREF="#_ismbcl2">_ismbcl2</A>, <A HREF="#_ismbclegal">_ismbclegal</A>,
<A HREF="#_ismbcprint">_ismbcprint</A>, <A HREF="#_ismbcpunct">_ismbcpunct</A>, <A HREF="#_ismbcspace">_ismbcspace</A>, <A HREF="#_ismbcsymbol">_ismbcsymbol</A>,
<A HREF="#_ismbcupper">_ismbcupper</A>, <A HREF="#_ismbcxdigit">_ismbcxdigit</A>, <A HREF="#_mbbtype">_mbbtype</A>, <A HREF="#_setmbcp">_setmbcp</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><BR><TT>unsigned int chars[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '1',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'A',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'a',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8140, /* double-byte space */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8143, /* double-byte , */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8254, /* double-byte 5 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8260, /* double-byte A */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8279, /* double-byte Z */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8281, /* double-byte a */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x829A, /* double-byte z */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x989F, /* double-byte L2 character */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA6</TT>
<BR><TT>};</TT>
<BR><BR><TT>#define SIZE sizeof( chars ) / sizeof( unsigned int )</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x is %sa valid &quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;multibyte lowercase character\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars[i],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( _ismbclower( chars[i] ) ) ? &quot;&quot; : &quot;not
&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>0x0031 is not a valid multibyte lowercase character</TT>
<BR><TT>0x0041 is not a valid multibyte lowercase character</TT>
<BR><TT>0x0061 is a valid multibyte lowercase character</TT>
<BR><TT>0x8140 is not a valid multibyte lowercase character</TT>
<BR><TT>0x8143 is not a valid multibyte lowercase character</TT>
<BR><TT>0x8254 is not a valid multibyte lowercase character</TT>
<BR><TT>0x8260 is not a valid multibyte lowercase character</TT>
<BR><TT>0x8279 is not a valid multibyte lowercase character</TT>
<BR><TT>0x8281 is a valid multibyte lowercase character</TT>
<BR><TT>0x829a is a valid multibyte lowercase character</TT>
<BR><TT>0x989f is not a valid multibyte lowercase character</TT>
<BR><TT>0x00a6 is not a valid multibyte lowercase character</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS
</DL>
<H2 ID="_ismbcprint"> _ismbcprint </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>int _ismbcprint( unsigned int ch );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _ismbcprint</TT> function tests for any printable multibyte character including space (' ').&nbsp; The <TT> _ismbcgraph</TT>
function is similar, except that the space character is not included in the character set being tested.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _ismbcprint</TT> function returns a non-zero value when the argument is a member of this set of characters; otherwise,
zero is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getmbcp">_getmbcp</A>, <A HREF="#_ismbcalnum">_ismbcalnum</A>, <A HREF="#_ismbcalpha">_ismbcalpha</A>, <A HREF="#_ismbccntrl">_ismbccntrl</A>,
<A HREF="#_ismbcdigit">_ismbcdigit</A>, <A HREF="#_ismbcgraph">_ismbcgraph</A>, <A HREF="#_ismbchira">_ismbchira</A>, <A HREF="#_ismbckata">_ismbckata</A>,
<A HREF="#_ismbcl0">_ismbcl0</A>, <A HREF="#_ismbcl1">_ismbcl1</A>, <A HREF="#_ismbcl2">_ismbcl2</A>, <A HREF="#_ismbclegal">_ismbclegal</A>,
<A HREF="#_ismbclower">_ismbclower</A>, <A HREF="#_ismbcpunct">_ismbcpunct</A>, <A HREF="#_ismbcspace">_ismbcspace</A>, <A HREF="#_ismbcsymbol">_ismbcsymbol</A>,
<A HREF="#_ismbcupper">_ismbcupper</A>, <A HREF="#_ismbcxdigit">_ismbcxdigit</A>, <A HREF="#_mbbtype">_mbbtype</A>, <A HREF="#_setmbcp">_setmbcp</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><BR><TT>unsigned int chars[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '.',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ' ',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '1',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'A',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8140, /* double-byte space */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8143, /* double-byte , */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8254, /* double-byte 5 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8260, /* double-byte A */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8279, /* double-byte Z */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8281, /* double-byte a */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x829A, /* double-byte z */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x989F, /* double-byte L2 character */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA6</TT>
<BR><TT>};</TT>
<BR><BR><TT>#define SIZE sizeof( chars ) / sizeof( unsigned int )</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x is %sa valid &quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;multibyte print character\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars[i],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( _ismbcprint( chars[i] ) ) ? &quot;&quot; : &quot;not
&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>0x002e is a valid multibyte print character</TT>
<BR><TT>0x0020 is a valid multibyte print character</TT>
<BR><TT>0x0031 is a valid multibyte print character</TT>
<BR><TT>0x0041 is a valid multibyte print character</TT>
<BR><TT>0x8140 is a valid multibyte print character</TT>
<BR><TT>0x8143 is a valid multibyte print character</TT>
<BR><TT>0x8254 is a valid multibyte print character</TT>
<BR><TT>0x8260 is a valid multibyte print character</TT>
<BR><TT>0x8279 is a valid multibyte print character</TT>
<BR><TT>0x8281 is a valid multibyte print character</TT>
<BR><TT>0x829a is a valid multibyte print character</TT>
<BR><TT>0x989f is a valid multibyte print character</TT>
<BR><TT>0x00a6 is a valid multibyte print character</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS
</DL>
<H2 ID="_ismbcpunct"> _ismbcpunct </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>int _ismbcpunct( unsigned int ch );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _ismbcpunct</TT> function tests for any multibyte punctuation character.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _ismbcpunct</TT> function returns a non-zero value when the argument is a member of this set of characters; otherwise,
zero is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getmbcp">_getmbcp</A>, <A HREF="#_ismbcalnum">_ismbcalnum</A>, <A HREF="#_ismbcalpha">_ismbcalpha</A>, <A HREF="#_ismbccntrl">_ismbccntrl</A>,
<A HREF="#_ismbcdigit">_ismbcdigit</A>, <A HREF="#_ismbcgraph">_ismbcgraph</A>, <A HREF="#_ismbchira">_ismbchira</A>, <A HREF="#_ismbckata">_ismbckata</A>,
<A HREF="#_ismbcl0">_ismbcl0</A>, <A HREF="#_ismbcl1">_ismbcl1</A>, <A HREF="#_ismbcl2">_ismbcl2</A>, <A HREF="#_ismbclegal">_ismbclegal</A>,
<A HREF="#_ismbclower">_ismbclower</A>, <A HREF="#_ismbcprint">_ismbcprint</A>, <A HREF="#_ismbcspace">_ismbcspace</A>, <A HREF="#_ismbcsymbol">_ismbcsymbol</A>,
<A HREF="#_ismbcupper">_ismbcupper</A>, <A HREF="#_ismbcxdigit">_ismbcxdigit</A>, <A HREF="#_mbbtype">_mbbtype</A>, <A HREF="#_setmbcp">_setmbcp</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><BR><TT>unsigned int chars[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '.',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ' ',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '1',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'A',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8140, /* double-byte space */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8143, /* double-byte , */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8254, /* double-byte 5 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8260, /* double-byte A */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8279, /* double-byte Z */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8281, /* double-byte a */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x829A, /* double-byte z */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x989F, /* double-byte L2 character */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA1,&nbsp;&nbsp; /* single-byte Katakana punctuation */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA6&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>};</TT>
<BR><BR><TT>#define SIZE sizeof( chars ) / sizeof( unsigned int )</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x is %sa valid &quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;multibyte punctuation character\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars[i],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( _ismbcpunct( chars[i] ) ) ? &quot;&quot; : &quot;not
&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>0x002e is a valid multibyte punctuation character</TT>
<BR><TT>0x0020 is not a valid multibyte punctuation character</TT>
<BR><TT>0x0031 is not a valid multibyte punctuation character</TT>
<BR><TT>0x0041 is not a valid multibyte punctuation character</TT>
<BR><TT>0x8140 is not a valid multibyte punctuation character</TT>
<BR><TT>0x8143 is a valid multibyte punctuation character</TT>
<BR><TT>0x8254 is not a valid multibyte punctuation character</TT>
<BR><TT>0x8260 is not a valid multibyte punctuation character</TT>
<BR><TT>0x8279 is not a valid multibyte punctuation character</TT>
<BR><TT>0x8281 is not a valid multibyte punctuation character</TT>
<BR><TT>0x829a is not a valid multibyte punctuation character</TT>
<BR><TT>0x989f is not a valid multibyte punctuation character</TT>
<BR><TT>0x00a1 is a valid multibyte punctuation character</TT>
<BR><TT>0x00a6 is not a valid multibyte punctuation character</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS
</DL>
<H2 ID="_ismbcspace"> _ismbcspace </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>int _ismbcspace( unsigned int ch );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _ismbcspace</TT> function tests for any multibyte space character.&nbsp; Multibyte characters include both single-byte
and double-byte characters.&nbsp; For example, in code page 932, the double-byte space character is 0x8140.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _ismbcspace</TT> function returns a non-zero value when the argument is a member of this set of characters; otherwise,
zero is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getmbcp">_getmbcp</A>, <A HREF="#_ismbcalnum">_ismbcalnum</A>, <A HREF="#_ismbcalpha">_ismbcalpha</A>, <A HREF="#_ismbccntrl">_ismbccntrl</A>,
<A HREF="#_ismbcdigit">_ismbcdigit</A>, <A HREF="#_ismbcgraph">_ismbcgraph</A>, <A HREF="#_ismbchira">_ismbchira</A>, <A HREF="#_ismbckata">_ismbckata</A>,
<A HREF="#_ismbcl0">_ismbcl0</A>, <A HREF="#_ismbcl1">_ismbcl1</A>, <A HREF="#_ismbcl2">_ismbcl2</A>, <A HREF="#_ismbclegal">_ismbclegal</A>,
<A HREF="#_ismbclower">_ismbclower</A>, <A HREF="#_ismbcprint">_ismbcprint</A>, <A HREF="#_ismbcpunct">_ismbcpunct</A>, <A HREF="#_ismbcsymbol">_ismbcsymbol</A>,
<A HREF="#_ismbcupper">_ismbcupper</A>, <A HREF="#_ismbcxdigit">_ismbcxdigit</A>, <A HREF="#_mbbtype">_mbbtype</A>, <A HREF="#_setmbcp">_setmbcp</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><BR><TT>unsigned int chars[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x09,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '.',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ' ',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '1',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'A',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8140, /* double-byte space */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8143, /* double-byte , */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8254, /* double-byte 5 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8260, /* double-byte A */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8279, /* double-byte Z */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8281, /* double-byte a */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x829A, /* double-byte z */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x989F, /* double-byte L2 character */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA6</TT>
<BR><TT>};</TT>
<BR><BR><TT>#define SIZE sizeof( chars ) / sizeof( unsigned int )</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x is %sa valid &quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;multibyte space character\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars[i],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( _ismbcspace( chars[i] ) ) ? &quot;&quot; : &quot;not
&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>0x0009 is a valid multibyte space character</TT>
<BR><TT>0x002e is not a valid multibyte space character</TT>
<BR><TT>0x0020 is a valid multibyte space character</TT>
<BR><TT>0x0031 is not a valid multibyte space character</TT>
<BR><TT>0x0041 is not a valid multibyte space character</TT>
<BR><TT>0x8140 is a valid multibyte space character</TT>
<BR><TT>0x8143 is not a valid multibyte space character</TT>
<BR><TT>0x8254 is not a valid multibyte space character</TT>
<BR><TT>0x8260 is not a valid multibyte space character</TT>
<BR><TT>0x8279 is not a valid multibyte space character</TT>
<BR><TT>0x8281 is not a valid multibyte space character</TT>
<BR><TT>0x829a is not a valid multibyte space character</TT>
<BR><TT>0x989f is not a valid multibyte space character</TT>
<BR><TT>0x00a6 is not a valid multibyte space character</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS
</DL>
<H2 ID="_ismbcsymbol"> _ismbcsymbol </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>int _ismbcsymbol( unsigned int ch );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _ismbcsymbol</TT> function tests for a valid multibyte symbol character (punctuation and other special graphical symbols).
&nbsp;For example, in code page 932,<TT> _ismbcsymbol</TT> tests for a double-byte Kigou character and returns true if and
only if
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0x8141 &lt;= ch &lt;= 0x81AC&nbsp; &amp;&amp;&nbsp; ch != 0x817F</TT>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _ismbcsymbol</TT> function returns a non-zero value when the argument is a member of this set of characters; otherwise,
zero is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getmbcp">_getmbcp</A>, <A HREF="#_ismbcalnum">_ismbcalnum</A>, <A HREF="#_ismbcalpha">_ismbcalpha</A>, <A HREF="#_ismbccntrl">_ismbccntrl</A>,
<A HREF="#_ismbcdigit">_ismbcdigit</A>, <A HREF="#_ismbcgraph">_ismbcgraph</A>, <A HREF="#_ismbchira">_ismbchira</A>, <A HREF="#_ismbckata">_ismbckata</A>,
<A HREF="#_ismbcl0">_ismbcl0</A>, <A HREF="#_ismbcl1">_ismbcl1</A>, <A HREF="#_ismbcl2">_ismbcl2</A>, <A HREF="#_ismbclegal">_ismbclegal</A>,
<A HREF="#_ismbclower">_ismbclower</A>, <A HREF="#_ismbcprint">_ismbcprint</A>, <A HREF="#_ismbcpunct">_ismbcpunct</A>, <A HREF="#_ismbcspace">_ismbcspace</A>,
<A HREF="#_ismbcupper">_ismbcupper</A>, <A HREF="#_ismbcxdigit">_ismbcxdigit</A>, <A HREF="#_mbbtype">_mbbtype</A>, <A HREF="#_setmbcp">_setmbcp</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><BR><TT>unsigned int chars[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '.',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ' ',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '1',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'A',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8140, /* double-byte space */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8143, /* double-byte , */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8254, /* double-byte 5 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8260, /* double-byte A */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8279, /* double-byte Z */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8281, /* double-byte a */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x829A, /* double-byte z */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x989F, /* double-byte L2 character */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA6</TT>
<BR><TT>};</TT>
<BR><BR><TT>#define SIZE sizeof( chars ) / sizeof( unsigned int )</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x is %sa valid &quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;multibyte symbol character\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars[i],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( _ismbcsymbol( chars[i] ) ) ? &quot;&quot; : &quot;not
&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>0x002e is not a valid multibyte symbol character</TT>
<BR><TT>0x0020 is not a valid multibyte symbol character</TT>
<BR><TT>0x0031 is not a valid multibyte symbol character</TT>
<BR><TT>0x0041 is not a valid multibyte symbol character</TT>
<BR><TT>0x8140 is not a valid multibyte symbol character</TT>
<BR><TT>0x8143 is a valid multibyte symbol character</TT>
<BR><TT>0x8254 is not a valid multibyte symbol character</TT>
<BR><TT>0x8260 is not a valid multibyte symbol character</TT>
<BR><TT>0x8279 is not a valid multibyte symbol character</TT>
<BR><TT>0x8281 is not a valid multibyte symbol character</TT>
<BR><TT>0x829a is not a valid multibyte symbol character</TT>
<BR><TT>0x989f is not a valid multibyte symbol character</TT>
<BR><TT>0x00a6 is not a valid multibyte symbol character</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS
</DL>
<H2 ID="_ismbcupper"> _ismbcupper </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>int _ismbcupper( unsigned int ch );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _ismbcupper</TT> function tests for a valid uppercase multibyte character.&nbsp; Multibyte characters include both
single-byte and double-byte characters.&nbsp; For example, in code page 932, an uppercase double-byte character is one for
which the following expression is true:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0x8260 &lt;= c &lt;= 0x8279</TT>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _ismbcupper</TT> function returns a non-zero value when the argument is a member of this set of characters; otherwise,
zero is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getmbcp">_getmbcp</A>, <A HREF="#_ismbcalnum">_ismbcalnum</A>, <A HREF="#_ismbcalpha">_ismbcalpha</A>, <A HREF="#_ismbccntrl">_ismbccntrl</A>,
<A HREF="#_ismbcdigit">_ismbcdigit</A>, <A HREF="#_ismbcgraph">_ismbcgraph</A>, <A HREF="#_ismbchira">_ismbchira</A>, <A HREF="#_ismbckata">_ismbckata</A>,
<A HREF="#_ismbcl0">_ismbcl0</A>, <A HREF="#_ismbcl1">_ismbcl1</A>, <A HREF="#_ismbcl2">_ismbcl2</A>, <A HREF="#_ismbclegal">_ismbclegal</A>,
<A HREF="#_ismbclower">_ismbclower</A>, <A HREF="#_ismbcprint">_ismbcprint</A>, <A HREF="#_ismbcpunct">_ismbcpunct</A>, <A HREF="#_ismbcspace">_ismbcspace</A>,
<A HREF="#_ismbcsymbol">_ismbcsymbol</A>, <A HREF="#_ismbcxdigit">_ismbcxdigit</A>, <A HREF="#_mbbtype">_mbbtype</A>, <A HREF="#_setmbcp">_setmbcp</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><BR><TT>unsigned int chars[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '1',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'A',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'a',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8140, /* double-byte space */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8143, /* double-byte , */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8254, /* double-byte 5 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8260, /* double-byte A */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8279, /* double-byte Z */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8281, /* double-byte a */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x829A, /* double-byte z */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x989F, /* double-byte L2 character */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA6</TT>
<BR><TT>};</TT>
<BR><BR><TT>#define SIZE sizeof( chars ) / sizeof( unsigned int )</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x is %sa valid &quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;multibyte uppercase character\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars[i],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( _ismbcupper( chars[i] ) ) ? &quot;&quot; : &quot;not
&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>0x0031 is not a valid multibyte uppercase character</TT>
<BR><TT>0x0041 is a valid multibyte uppercase character</TT>
<BR><TT>0x0061 is not a valid multibyte uppercase character</TT>
<BR><TT>0x8140 is not a valid multibyte uppercase character</TT>
<BR><TT>0x8143 is not a valid multibyte uppercase character</TT>
<BR><TT>0x8254 is not a valid multibyte uppercase character</TT>
<BR><TT>0x8260 is a valid multibyte uppercase character</TT>
<BR><TT>0x8279 is a valid multibyte uppercase character</TT>
<BR><TT>0x8281 is not a valid multibyte uppercase character</TT>
<BR><TT>0x829a is not a valid multibyte uppercase character</TT>
<BR><TT>0x989f is not a valid multibyte uppercase character</TT>
<BR><TT>0x00a6 is not a valid multibyte uppercase character</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS
</DL>
<H2 ID="_ismbcxdigit"> _ismbcxdigit </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>int _ismbcxdigit( unsigned int ch );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _ismbcxdigit</TT> function tests for any multibyte hexadecimal-digit character '0' through '9' or 'A' through 'F'.
&nbsp;In code page 932, this includes the corresponding double-byte versions of these characters.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _ismbcxdigit</TT> function returns a non-zero value when the argument is a hexadecimal-digit character.&nbsp; Otherwise,
zero is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getmbcp">_getmbcp</A>, <A HREF="#_ismbcalnum">_ismbcalnum</A>, <A HREF="#_ismbcalpha">_ismbcalpha</A>, <A HREF="#_ismbccntrl">_ismbccntrl</A>,
<A HREF="#_ismbcdigit">_ismbcdigit</A>, <A HREF="#_ismbcgraph">_ismbcgraph</A>, <A HREF="#_ismbchira">_ismbchira</A>, <A HREF="#_ismbckata">_ismbckata</A>,
<A HREF="#_ismbcl0">_ismbcl0</A>, <A HREF="#_ismbcl1">_ismbcl1</A>, <A HREF="#_ismbcl2">_ismbcl2</A>, <A HREF="#_ismbclegal">_ismbclegal</A>,
<A HREF="#_ismbclower">_ismbclower</A>, <A HREF="#_ismbcprint">_ismbcprint</A>, <A HREF="#_ismbcpunct">_ismbcpunct</A>, <A HREF="#_ismbcspace">_ismbcspace</A>,
<A HREF="#_ismbcsymbol">_ismbcsymbol</A>, <A HREF="#_ismbcupper">_ismbcupper</A>, <A HREF="#_mbbtype">_mbbtype</A>, <A HREF="#_setmbcp">_setmbcp</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><BR><TT>unsigned int chars[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '.',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '1',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'A',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8143, /* double-byte &quot;,&quot; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8183, /* double-byte &quot;&lt;&quot; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8254, /* double-byte &quot;5&quot; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8265, /* double-byte &quot;F&quot; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA6</TT>
<BR><TT>};</TT>
<BR><BR><TT>#define SIZE sizeof( chars ) / sizeof( unsigned int )</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x is %sa valid &quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;multibyte hexadecimal digit character\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars[i],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( _ismbcxdigit( chars[i] ) ) ? &quot;&quot; : &quot;not
&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>0x002e is not a valid multibyte hexadecimal digit character</TT>
<BR><TT>0x0031 is a valid multibyte hexadecimal digit character</TT>
<BR><TT>0x0041 is a valid multibyte hexadecimal digit character</TT>
<BR><TT>0x8143 is not a valid multibyte hexadecimal digit character</TT>
<BR><TT>0x8183 is not a valid multibyte hexadecimal digit character</TT>
<BR><TT>0x8254 is a valid multibyte hexadecimal digit character</TT>
<BR><TT>0x8265 is a valid multibyte hexadecimal digit character</TT>
<BR><TT>0x00a6 is not a valid multibyte hexadecimal digit character</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS
</DL>
<H2 ID="isnan"> isnan </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>int isnan( x );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> isnan</TT> macro determines whether its argument<B> x</B> is a NaN.&nbsp; First, an argument represented in a format
wider than its semantic type is converted to its semantic type.&nbsp; Then determination is based on the type of the argument.
<BR><BR>The argument<B> x</B> must be an expression of real floating type.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> isnan</TT> macro returns a nonzero value if and only if its argument has a NaN value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#fpclassify">fpclassify</A>, <A HREF="#isfinite">isfinite</A>, <A HREF="#isinf">isinf</A>, <A HREF="#isnormal">isnormal</A>,
<A HREF="#signbit">signbit</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;NAN %s a NaN\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isnan( NAN ) ? &quot;is&quot; : &quot;is not&quot; );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>NAN is a NaN</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="isnormal"> isnormal </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>int isnormal( x );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> isnormal</TT> macro determines whether its argument value is normal (neither zero, subnormal, infinite, nor NaN).
&nbsp;First, an argument represented in a format wider than its semantic type is converted to its semantic type.&nbsp; Then
determination is based on the type of the argument.
<BR><BR>The argument<B> x</B> must be an expression of real floating type.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> isnormal</TT> macro returns a nonzero value if and only if its argument has a normal value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#fpclassify">fpclassify</A>, <A HREF="#isfinite">isfinite</A>, <A HREF="#isinf">isinf</A>, <A HREF="#isnan">isnan</A>,
<A HREF="#signbit">signbit</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;zero %s a normal number\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isnormal( 0.0 ) ? &quot;is&quot; : &quot;is not&quot; );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>zero is not a normal number</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="isprint"> isprint, iswprint </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;ctype.h&gt;</TT>
<BR><TT>int isprint( int c );</TT>
<BR><TT>#include &lt;wctype.h&gt;</TT>
<BR><TT>int iswprint( wint_t c );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> isprint</TT> function tests for any printable character including space (' ').&nbsp; The <TT> isgraph</TT> function
is similar, except that the space character is excluded from the character set being tested.
<BR><BR>The<TT> iswprint</TT> function is a wide-character version of<TT> isprint</TT> that operates with wide-character argument.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> isprint</TT> function returns a non-zero value when the argument is a printable character.&nbsp; The<TT> iswprint</TT>
function returns a non-zero value when the argument is a printable wide character.&nbsp; Otherwise, zero is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#isalnum">isalnum</A>, <A HREF="#isalpha">isalpha</A>, <A HREF="#isblank">isblank</A>, <A HREF="#iscntrl">iscntrl</A>,
<A HREF="#isdigit">isdigit</A>, <A HREF="#isgraph">isgraph</A>, <A HREF="#isleadbyte">isleadbyte</A>, <A HREF="#islower">islower</A>,
<A HREF="#ispunct">ispunct</A>, <A HREF="#isspace">isspace</A>, <A HREF="#isupper">isupper</A>, <A HREF="#iswctype">iswctype</A>,
<A HREF="#isxdigit">isxdigit</A>, <A HREF="#tolower">tolower</A>, <A HREF="#toupper">toupper</A>, <A HREF="#towctrans">towctrans</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;ctype.h&gt;</TT>
<BR><BR><TT>char chars[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'A',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x09,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ' ',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x7d</TT>
<BR><TT>};</TT>
<BR><BR><TT>#define SIZE sizeof( chars ) / sizeof( char )</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Char %c is %sa printable character\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars[i],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( isprint( chars[i] ) )
? &quot;&quot; : &quot;not &quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>Char A is a printable character</TT>
<BR><TT>Char&nbsp;&nbsp;&nbsp;&nbsp; is not a printable character</TT>
<BR><TT>Char&nbsp;&nbsp; is a printable character</TT>
<BR><TT>Char } is a printable character</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>iswprint is ISO C95
</DL>
<DL>
<DT>Systems:
<DD><TT> isprint - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>iswprint - All, Linux, RDOS, Netware</TT>
</DL>
<H2 ID="ispunct"> ispunct, iswpunct </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;ctype.h&gt;</TT>
<BR><TT>int ispunct( int c );</TT>
<BR><TT>#include &lt;wctype.h&gt;</TT>
<BR><TT>int iswpunct( wint_t c );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> ispunct</TT> function tests for any punctuation character such as a comma (,) or a period (.).
<BR><BR>The<TT> iswpunct</TT> function is a wide-character version of<TT> ispunct</TT> that operates with wide-character argument.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> ispunct</TT> function returns a non-zero value when the argument is a punctuation character.&nbsp; The<TT> iswpunct</TT>
function returns a non-zero value when the argument is a printable wide character that is neither the space wide character
nor a wide character for which <TT> iswalnum</TT> is true.&nbsp; Otherwise, zero is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#isalnum">isalnum</A>, <A HREF="#isalpha">isalpha</A>, <A HREF="#isblank">isblank</A>, <A HREF="#iscntrl">iscntrl</A>,
<A HREF="#isdigit">isdigit</A>, <A HREF="#isgraph">isgraph</A>, <A HREF="#isleadbyte">isleadbyte</A>, <A HREF="#islower">islower</A>,
<A HREF="#isprint">isprint</A>, <A HREF="#isspace">isspace</A>, <A HREF="#isupper">isupper</A>, <A HREF="#iswctype">iswctype</A>,
<A HREF="#isxdigit">isxdigit</A>, <A HREF="#tolower">tolower</A>, <A HREF="#toupper">toupper</A>, <A HREF="#towctrans">towctrans</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;ctype.h&gt;</TT>
<BR><BR><TT>char chars[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'A',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '!',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '.',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ',',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ':',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ';'</TT>
<BR><TT>};</TT>
<BR><BR><TT>#define SIZE sizeof( chars ) / sizeof( char )</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Char %c is %sa punctuation character\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars[i],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( ispunct( chars[i] ) )
? &quot;&quot; : &quot;not &quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>Char A is not a punctuation character</TT>
<BR><TT>Char ! is a punctuation character</TT>
<BR><TT>Char . is a punctuation character</TT>
<BR><TT>Char , is a punctuation character</TT>
<BR><TT>Char : is a punctuation character</TT>
<BR><TT>Char ; is a punctuation character</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>iswpunct is ISO C95
</DL>
<DL>
<DT>Systems:
<DD><TT> ispunct - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>iswpunct - All, Linux, RDOS, Netware</TT>
</DL>
<H2 ID="isspace"> isspace, iswspace </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;ctype.h&gt;</TT>
<BR><TT>int isspace( int c );</TT>
<BR><TT>#include &lt;wctype.h&gt;</TT>
<BR><TT>int iswspace( wint_t c );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> isspace</TT> function tests for the following white-space characters:
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Character
<DT>' '
<DD>space
<DT>'\f'
<DD>form feed
<DT>'\n'
<DD>new-line or linefeed
<DT>'\r'
<DD>carriage return
<DT>'\t'
<DD>horizontal tab
<DT>'\v'
<DD>vertical tab
</DL>
<BR>The<TT> iswspace</TT> function is a wide-character version of<TT> isspace</TT> that operates with wide-character argument.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> isspace</TT> function returns a non-zero character when the argument is one of the indicated white-space characters.
&nbsp;The<TT> iswspace</TT> function returns a non-zero value when the argument is a wide character that corresponds to a
standard white-space character or is one of an implementation-defined set of wide characters for which <TT> iswalnum</TT>
is false.&nbsp; Otherwise, zero is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#isalnum">isalnum</A>, <A HREF="#isalpha">isalpha</A>, <A HREF="#isblank">isblank</A>, <A HREF="#iscntrl">iscntrl</A>,
<A HREF="#isdigit">isdigit</A>, <A HREF="#isgraph">isgraph</A>, <A HREF="#isleadbyte">isleadbyte</A>, <A HREF="#islower">islower</A>,
<A HREF="#isprint">isprint</A>, <A HREF="#ispunct">ispunct</A>, <A HREF="#isupper">isupper</A>, <A HREF="#iswctype">iswctype</A>,
<A HREF="#isxdigit">isxdigit</A>, <A HREF="#tolower">tolower</A>, <A HREF="#toupper">toupper</A>, <A HREF="#towctrans">towctrans</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;ctype.h&gt;</TT>
<BR><BR><TT>char chars[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'A',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x09,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ' ',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x7d</TT>
<BR><TT>};</TT>
<BR><BR><TT>#define SIZE sizeof( chars ) / sizeof( char )</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Char %c is %sa space character\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars[i],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( isspace( chars[i] ) )
? &quot;&quot; : &quot;not &quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>Char A is not a space character</TT>
<BR><TT>Char&nbsp;&nbsp;&nbsp;&nbsp; is a space character</TT>
<BR><TT>Char&nbsp;&nbsp; is a space character</TT>
<BR><TT>Char } is not a space character</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>iswspace is ISO C95
</DL>
<DL>
<DT>Systems:
<DD><TT> isspace - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>iswspace - All, Linux, RDOS, Netware</TT>
</DL>
<H2 ID="isupper"> isupper, iswupper </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;ctype.h&gt;</TT>
<BR><TT>int isupper( int c );</TT>
<BR><TT>#include &lt;wctype.h&gt;</TT>
<BR><TT>int iswupper( wint_t c );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> isupper</TT> function tests for any uppercase letter 'A' through 'Z'.
<BR><BR>The<TT> iswupper</TT> function is a wide-character version of<TT> isupper</TT> that operates with wide-character argument.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> isupper</TT> function returns a non-zero value when the argument is an uppercase letter.&nbsp; The<TT> iswupper</TT>
function returns a non-zero value when the argument is a wide character that corresponds to an uppercase letter, or if it
is one of an implementation-defined set of wide characters for which none of <TT> iswcntrl</TT>, <TT> iswdigit</TT>, <TT>
iswpunct</TT>, or <TT> iswspace</TT> is true.&nbsp; Otherwise, zero is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#isalnum">isalnum</A>, <A HREF="#isalpha">isalpha</A>, <A HREF="#isblank">isblank</A>, <A HREF="#iscntrl">iscntrl</A>,
<A HREF="#isdigit">isdigit</A>, <A HREF="#isgraph">isgraph</A>, <A HREF="#isleadbyte">isleadbyte</A>, <A HREF="#islower">islower</A>,
<A HREF="#isprint">isprint</A>, <A HREF="#ispunct">ispunct</A>, <A HREF="#isspace">isspace</A>, <A HREF="#iswctype">iswctype</A>,
<A HREF="#isxdigit">isxdigit</A>, <A HREF="#tolower">tolower</A>, <A HREF="#toupper">toupper</A>, <A HREF="#towctrans">towctrans</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;ctype.h&gt;</TT>
<BR><BR><TT>char chars[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'A',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'a',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'z',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'Z'</TT>
<BR><TT>};</TT>
<BR><BR><TT>#define SIZE sizeof( chars ) / sizeof( char )</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Char %c is %san uppercase character\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars[i],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( isupper( chars[i] ) )
? &quot;&quot; : &quot;not &quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>Char A is an uppercase character</TT>
<BR><TT>Char a is not an uppercase character</TT>
<BR><TT>Char z is not an uppercase character</TT>
<BR><TT>Char Z is an uppercase character</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>iswupper is ISO C95
</DL>
<DL>
<DT>Systems:
<DD><TT> isupper - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>iswupper - All, Linux, RDOS, Netware</TT>
</DL>
<H2 ID="iswctype"> iswctype </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wctype.h&gt;</TT>
<BR><TT>int iswctype( wint_t wc, wctype_t desc );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> iswctype</TT> function determines whether the wide character<B> wc</B> has the property described by<B> desc</B>.
&nbsp;Valid values of<B> desc</B> are defined by the use of the <TT> wctype</TT> function.
<BR><BR>The twelve expressions listed below have a truth-value equivalent to a call to the wide character testing function
shown.
<DL>
<DT>Expression&nbsp;&nbsp;&nbsp;&nbsp; Equivalent
<DT>iswctype(wc, wctype(&quot;alnum&quot;))
<DD>iswalnum(wc)
<DT>iswctype(wc, wctype(&quot;alpha&quot;))
<DD>iswalpha(wc)
<DT>iswctype(wc, wctype(&quot;blank&quot;))
<DD>iswblank(wc)
<DT>iswctype(wc, wctype(&quot;cntrl&quot;))
<DD>iswcntrl(wc)
<DT>iswctype(wc, wctype(&quot;digit&quot;))
<DD>iswdigit(wc)
<DT>iswctype(wc, wctype(&quot;graph&quot;))
<DD>iswgraph(wc)
<DT>iswctype(wc, wctype(&quot;lower&quot;))
<DD>iswlower(wc)
<DT>iswctype(wc, wctype(&quot;print&quot;))
<DD>iswprint(wc)
<DT>iswctype(wc, wctype(&quot;punct&quot;))
<DD>iswpunct(wc)
<DT>iswctype(wc, wctype(&quot;space&quot;))
<DD>iswspace(wc)
<DT>iswctype(wc, wctype(&quot;upper&quot;))
<DD>iswupper(wc)
<DT>iswctype(wc, wctype(&quot;xdigit&quot;))
<DD>iswxdigit(wc)
</DL>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> iswctype</TT> function returns non-zero (true) if and only if the value of the wide character<B> wc</B> has the property
described by<B> desc</B>.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#isalnum">isalnum</A>, <A HREF="#isalpha">isalpha</A>, <A HREF="#isblank">isblank</A>, <A HREF="#iscntrl">iscntrl</A>,
<A HREF="#isdigit">isdigit</A>, <A HREF="#isgraph">isgraph</A>, <A HREF="#isleadbyte">isleadbyte</A>, <A HREF="#islower">islower</A>,
<A HREF="#isprint">isprint</A>, <A HREF="#ispunct">ispunct</A>, <A HREF="#isspace">isspace</A>, <A HREF="#isupper">isupper</A>,
<A HREF="#isxdigit">isxdigit</A>, <A HREF="#tolower">tolower</A>, <A HREF="#toupper">toupper</A>, <A HREF="#towctrans">towctrans</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;wctype.h&gt;</TT>
<BR><BR><TT>char *types[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; &quot;alnum&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; &quot;alpha&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; &quot;blank&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; &quot;cntrl&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; &quot;digit&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; &quot;graph&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; &quot;lower&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; &quot;print&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; &quot;punct&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; &quot;space&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; &quot;upper&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; &quot;xdigit&quot;</TT>
<BR><TT>};</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; i;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; wint_t&nbsp; wc = 'A';</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; 12; i++ )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( iswctype( wc, wctype( types[i] ) ) )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, types[i] );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>alnum</TT>
<BR><TT>alpha</TT>
<BR><TT>graph</TT>
<BR><TT>print</TT>
<BR><TT>upper</TT>
<BR><TT>xdigit</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C95
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS
</DL>
<H2 ID="isxdigit"> isxdigit, iswxdigit </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;ctype.h&gt;</TT>
<BR><TT>int isxdigit( int c );</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>int iswxdigit( wint_t c );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> isxdigit</TT> function tests for any hexadecimal-digit character.&nbsp; These characters are the digits ('0' through
'9') and the letters ('a' through 'f') and ('A' through 'F').
<BR><BR>The<TT> iswxdigit</TT> function is a wide-character version of<TT> isxdigit</TT> that operates with wide-character
argument.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> isxdigit</TT> function returns a non-zero value when the argument is a hexadecimal-digit character.&nbsp; The<TT>
iswxdigit</TT> function returns a non-zero value when the argument is a wide character that corresponds to a hexadecimal-digit
character.&nbsp; Otherwise, zero is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#isalnum">isalnum</A>, <A HREF="#isalpha">isalpha</A>, <A HREF="#isblank">isblank</A>, <A HREF="#iscntrl">iscntrl</A>,
<A HREF="#isdigit">isdigit</A>, <A HREF="#isgraph">isgraph</A>, <A HREF="#isleadbyte">isleadbyte</A>, <A HREF="#islower">islower</A>,
<A HREF="#isprint">isprint</A>, <A HREF="#ispunct">ispunct</A>, <A HREF="#isspace">isspace</A>, <A HREF="#isupper">isupper</A>,
<A HREF="#iswctype">iswctype</A>, <A HREF="#tolower">tolower</A>, <A HREF="#toupper">toupper</A>, <A HREF="#towctrans">towctrans</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;ctype.h&gt;</TT>
<BR><BR><TT>char chars[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'A',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '5',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '$'</TT>
<BR><TT>};</TT>
<BR><TT> .exmp break</TT>
<BR><TT>#define SIZE sizeof( chars ) / sizeof( char )</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Char %c is %sa hexadecimal digit&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot; character\n&quot;, chars[i],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( isxdigit( chars[i] ) ) ? &quot;&quot; : &quot;not
&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>Char A is a hexadecimal digit character</TT>
<BR><TT>Char 5 is a hexadecimal digit character</TT>
<BR><TT>Char $ is not a hexadecimal digit character</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>iswxdigit is ISO C95
</DL>
<DL>
<DT>Systems:
<DD><TT> isxdigit - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>iswxdigit - All, Linux, RDOS, Netware</TT>
</DL>
<H2 ID="itoa"> itoa, _itoa, _itow </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>char *itoa( int value, char *buffer, int radix );</TT>
<BR><TT>char *_itoa( int value, char *buffer, int radix );</TT>
<BR><TT>wchar_t *_itow( int value, wchar_t *buffer,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int radix );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> itoa</TT> function converts the binary integer<B> value</B> into the equivalent string in base<B> radix</B> notation
storing the result in the character array pointed to by<B> buffer</B>.&nbsp; A null character is appended to the result.&nbsp;
The size of<B> buffer</B> must be at least (8 * sizeof(int) + 1) bytes when converting values in base 2.&nbsp; That makes
the size 17 bytes on 16-bit machines, and 33 bytes on 32-bit machines.&nbsp; The value of<B> radix</B> must satisfy the condition:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 2 &lt;= radix &lt;= 36</TT>
<BR><BR>If<B> radix</B> is 10 and<B> value</B> is negative, then a minus sign is prepended to the result.
<BR><BR>The<TT> _itoa</TT> function is identical to<TT> itoa</TT>.&nbsp; Use<TT> _itoa</TT> for ANSI naming conventions.
<BR><BR>The<TT> _itow</TT> function is a wide-character version of<TT> itoa</TT>.&nbsp; It produces a wide-character string.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> itoa</TT> function returns the pointer to the result.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#atoi">atoi</A>, <A HREF="#atol">atol</A>, <A HREF="#atoll">atoll</A>, <A HREF="#ltoa">ltoa</A>, <A HREF="#lltoa">lltoa</A>,
<A HREF="#sscanf">sscanf</A>, <A HREF="#strtol">strtol</A>, <A HREF="#strtoll">strtoll</A>, <A HREF="#strtoul">strtoul</A>,
<A HREF="#strtoull">strtoull</A>, <A HREF="#strtoimax">strtoimax</A>, <A HREF="#strtoumax">strtoumax</A>, <A HREF="#ultoa">ultoa</A>,
<A HREF="#ulltoa">ulltoa</A>, <A HREF="#utoa">utoa</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char buffer[20];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int base;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; for( base = 2; base &lt;= 16; base = base + 2 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%2d %s\n&quot;, base,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; itoa( 12765, buffer, base
) );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT> 2 11000111011101</TT>
<BR><TT> 4 3013131</TT>
<BR><TT> 6 135033</TT>
<BR><TT> 8 30735</TT>
<BR><TT>10 12765</TT>
<BR><TT>12 7479</TT>
<BR><TT>14 491b</TT>
<BR><TT>16 31dd</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
<BR><BR>_itoa conforms to ANSI naming conventions
</DL>
<DL>
<DT>Systems:
<DD><TT> itoa - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_itoa - All, Linux, RDOS, Netware</TT>
<BR><TT>_itow - All, Linux, RDOS</TT>
</DL>
<H2 ID="kbhit"> kbhit, _kbhit </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>int kbhit( void );</TT>
<BR><TT>int _kbhit( void );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> kbhit</TT> function tests whether or not a keystroke is currently available.&nbsp; When one is available, the function
<TT> getch</TT> or <TT> getche</TT> may be used to obtain the keystroke in question.
<BR><BR>With a stand-alone program, the<TT> kbhit</TT> function may be called continuously until a keystroke is available.
<BR><BR>The<TT> _kbhit</TT> function is identical to<TT> kbhit</TT>.&nbsp; Use<TT> _kbhit</TT> for ANSI naming conventions.
</DL>
<DL>
<DT>Returns:
<DD>The kbhit function returns zero when no keystroke is available; otherwise, a non-zero value is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#getch">getch</A>, <A HREF="#getche">getche</A>, <A HREF="#putch">putch</A>, <A HREF="#ungetch">ungetch</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>/*</TT>
<BR><TT> * This program loops until a key is pressed</TT>
<BR><TT> * or a count is exceeded.</TT>
<BR><TT> */</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned long i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Program looping. Press any key.\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; 10000; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( kbhit() ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
<BR><BR>_kbhit conforms to ANSI naming conventions
</DL>
<DL>
<DT>Systems:
<DD><TT> kbhit - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_kbhit - All, RDOS, Netware</TT>
</DL>
<H2 ID="labs"> labs </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>long int labs( long int j );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> labs</TT> function returns the absolute value of its long-integer argument<B> j</B>.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> labs</TT> function returns the absolute value of its argument.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#abs">abs</A>, <A HREF="#llabs">llabs</A>, <A HREF="#imaxabs">imaxabs</A>, <A HREF="#fabs">fabs</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; long x, y;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; x = -50000L;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; y = labs( x );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;labs(%ld) = %ld\n&quot;, x, y );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>labs(-50000) = 50000</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C90
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="ldexp"> ldexp </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>double ldexp( double x, int exp );</TT>
</DL>
<DL>
<DT>Description:
<DD>The ldexp function multiplies a floating-point number by an integral power of 2.&nbsp; A range error may occur.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> ldexp</TT> function returns the value of<B> x</B> times 2 raised to the power<B> exp</B>.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#frexp">frexp</A>, <A HREF="#modf">modf</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; double value;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; value = ldexp( 4.7072345, 5 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, value );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>150.631504</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD>Math
</DL>
<H2 ID="ldiv"> ldiv </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>ldiv_t ldiv( long int numer, long int denom );</TT>
<BR><BR><TT>typedef struct {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; long int quot;&nbsp;&nbsp;&nbsp;&nbsp; /* quotient */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; long int rem;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* remainder */</TT>
<BR><TT>} ldiv_t;</TT>
</DL>
<DL>
<DT>Description:
<DD>The ldiv function calculates the quotient and remainder of the division of the numerator<B> numer</B> by the denominator<B>
denom</B>.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> ldiv</TT> function returns a structure of type <TT> ldiv_t</TT> that contains the fields <TT> quot</TT> and <TT> rem</TT>,
which are both of type<TT> long int.</TT>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#div">div</A>, <A HREF="#lldiv">lldiv</A>, <A HREF="#imaxdiv">imaxdiv</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>void print_time( long int ticks )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ldiv_t sec_ticks;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ldiv_t min_sec;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; sec_ticks = ldiv( ticks, 100L );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; min_sec&nbsp;&nbsp; = ldiv( sec_ticks.quot, 60L );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;It took %ld minutes and %ld seconds\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; min_sec.quot, min_sec.rem );</TT>
<BR><TT>}</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; print_time( 86712L );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>It took 14 minutes and 27 seconds</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C90
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="lfind"> lfind </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;search.h&gt;</TT>
<BR><TT>void *lfind( const void *key, /* object to search for&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const void *base,/* base of search data&nbsp;
&nbsp;*/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned *num,&nbsp;&nbsp; /* number of elements
&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned width,&nbsp; /* width of each element
*/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int (*compare)( const void *element1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const void *element2 ) );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> lfind</TT> function performs a linear search for the value<B> key</B> in the array of<B> num</B> elements pointed
to by<B> base</B>.&nbsp; Each element of the array is<B> width</B> bytes in size.&nbsp; The argument<B> compare</B> is a pointer
to a user-supplied routine that will be called by lfind to determine the relationship of an array element with the<B> key</B>.
&nbsp;One of the arguments to the<B> compare</B> function will be an array element, and the other will be<B> key</B>.
<BR><BR>The<B> compare</B> function should return 0 if<B> element1</B> is identical to<B> element2</B> and non-zero if the
elements are not identical.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> lfind</TT> function returns a pointer to the array element in<B> base</B> that matches<B> key</B> if it is found,
otherwise<TT> NULL</TT> is returned indicating that the<B> key</B> was not found.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#bsearch">bsearch</A>, <A HREF="#lsearch">lsearch</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>#include &lt;search.h&gt;</TT>
<BR><BR><TT>static const char *keywords[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;auto&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;break&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;case&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;char&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* . */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* . */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* . */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;while&quot;</TT>
<BR><TT>};</TT>
<BR><BR><TT>void main( int argc, const char *argv[] )</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned num = 5;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; extern int compare( const void *, const void * );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; if( argc &lt;= 1 ) exit( EXIT_FAILURE );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( lfind( &amp;argv[1], keywords, &amp;num, sizeof(char **),</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
compare ) == NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;'%s' is not a C keyword\n&quot;, argv[1] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit( EXIT_FAILURE );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;'%s' is a C keyword\n&quot;, argv[1] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit( EXIT_SUCCESS );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR><TT>int compare( const void *op1, const void *op2 )</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; const char **p1 = (const char **) op1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; const char **p2 = (const char **) op2;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; return( strcmp( *p1, *p2 ) );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="lgamma"> lgamma </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>double lgamma( double x );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> lgamma</TT> function returns the natural logarithm of the absolute value of the Gamma function of<B> x</B>.&nbsp;
The sign of the Gamma function after this function is called will be located in signgam.&nbsp; This function is not thread-safe
if the user is interested in the sign of Gamma, and <TT> lgamma_r</TT> should be used instead in multithreaded applications.
</DL>
<DL>
<DT>Returns:
<DD>If successful, the return value is the natural logarithm of the absolute value of the Gamma function computed for<B> x</B>.
&nbsp;When the argument is not-a-number, the function returns NAN.&nbsp; For arguments of the values positive or negative
infinity, the function returns positive or negative infinity respectively.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#lgamma_r">lgamma_r</A>, <A HREF="#tgamma">tgamma</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, lgamma( 2.0 ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, signgam );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>0.00000</TT>
<BR><TT>1</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C99
</DL>
<DL>
<DT>Systems:
<DD>Math
</DL>
<H2 ID="lgamma_r"> lgamma_r </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>double lgamma_r( double x, int *y );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> lgamma_r</TT> function returns the natural logarithm of the absolute value of the Gamma function of<B> x</B>.&nbsp;
The sign of the Gamma function will be returned in the location pointed to by<B> y</B>.
</DL>
<DL>
<DT>Returns:
<DD>If successful, the return value is the natural logarithm of the absolute value of the Gamma function computed for<B> x</B>.
&nbsp;When the argument is not-a-number, the function returns NAN.&nbsp; For arguments of the values positive or negative
infinity, the function returns positive or negative infinity respectively.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#lgamma">lgamma</A>, <A HREF="#tgamma">tgamma</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int i;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, lgamma_r( 2.0, &amp;i ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, i );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>0.00000</TT>
<BR><TT>1</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>Math
</DL>
<H2 ID="_lineto"> _lineto, _lineto_w </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>short _FAR _lineto( short x, short y );</TT>
<BR><BR><TT>short _FAR _lineto_w( double x, double y );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _lineto</TT> functions draw straight lines.&nbsp; The<TT> _lineto</TT> function uses the view coordinate system.&nbsp;
The<TT> _lineto_w</TT> function uses the window coordinate system.
<BR><BR>The line is drawn from the current position to the point at the coordinates<TT> (x,y).</TT>&nbsp; The point<TT> (x,y)</TT>
becomes the new current position.&nbsp; The line is drawn with the current plotting action using the current line style and
the current color.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _lineto</TT> functions return a non-zero value when the line was successfully drawn; otherwise, zero is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_moveto">_moveto</A>, <A HREF="#_setcolor">_setcolor</A>, <A HREF="#_setlinestyle">_setlinestyle</A>, <A HREF="#_setplotaction">_setplotaction</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _moveto( 100, 100 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _lineto( 540, 100 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _lineto( 320, 380 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _lineto( 100, 100 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><IMG SRC="eg_movto.bmp" ALIGN=MIDDLE>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD><TT> _lineto - DOS</TT>
<BR><BR><TT>_lineto_w - DOS</TT>
</DL>
<H2 ID="llabs"> llabs </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>long long int llabs( long long int j );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> llabs</TT> function returns the absolute value of its long long integer argument<B> j</B>.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> llabs</TT> function returns the absolute value of its argument.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#labs">labs</A>, <A HREF="#abs">abs</A>, <A HREF="#imaxabs">imaxabs</A>, <A HREF="#fabs">fabs</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; long long x, y;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; x = -5000000000;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; y = llabs( x );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;llabs(%lld) = %lld\n&quot;, x, y );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>llabs(-5000000000) = 5000000000</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C99
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="lldiv"> lldiv </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>lldiv_t lldiv( long long int numer,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long long int denom );</TT>
<BR><BR><TT>typedef struct {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; long long int quot; /* quotient */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; long long int rem;&nbsp; /* remainder */</TT>
<BR><TT>} lldiv_t;</TT>
</DL>
<DL>
<DT>Description:
<DD>The lldiv function calculates the quotient and remainder of the division of the numerator<B> numer</B> by the denominator<B>
denom</B>.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> lldiv</TT> function returns a structure of type <TT> lldiv_t</TT> that contains the fields <TT> quot</TT> and <TT>
rem</TT>, which are both of type<TT> long long int.</TT>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#ldiv">ldiv</A>, <A HREF="#div">div</A>, <A HREF="#imaxdiv">imaxdiv</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>void print_time( long long int ticks )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; lldiv_t sec_ticks;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; lldiv_t min_sec;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; sec_ticks = lldiv( ticks, 100 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; min_sec&nbsp;&nbsp; = lldiv( sec_ticks.quot, 60 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;It took %lld minutes and %lld seconds\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; min_sec.quot, min_sec.rem );</TT>
<BR><TT>}</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; print_time( 73495132 );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>It took 12249 minutes and 11 seconds</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C99
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="localeconv"> localeconv </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;locale.h&gt;</TT>
<BR><TT>struct lconv *localeconv( void );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> localeconv</TT> function sets the components of an object of type <TT> struct lconv</TT> with values appropriate for
the formatting of numeric quantities according to the current locale.&nbsp; The components of the <TT> struct lconv</TT> and
their meanings are as follows:
<DL>
<DT>Component&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>char *decimal_point
<DD>The decimal-point character used to format non-monetary quantities.
<DT>char *thousands_sep
<DD>The character used to separate groups of digits to the left of the decimal-point character in formatted non-monetary quantities.
<DT>char *grouping
<DD>A string whose elements indicate the size of each group of digits in formatted non-monetary quantities.
<DT>char *int_curr_symbol
<DD>The international currency symbol applicable to the current locale.&nbsp; The first three characters contain the alphabetic
international currency symbol in accordance with those specified in<B> ISO 4217 Codes for the Representation of Currency and
Funds.</B>&nbsp; The fourth character (immediately preceding the null character) is the character used to separate the international
currency symbol from the monetary quantity.
<DT>char *currency_symbol
<DD>The local currency symbol applicable to the current locale.
<DT>char *mon_decimal_point
<DD>The decimal-point character used to format monetary quantities.
<DT>char *mon_thousands_sep
<DD>The character used to separate groups of digits to the left of the decimal-point character in formatted monetary quantities.
<DT>char *mon_grouping
<DD>A string whose elements indicate the size of each group of digits in formatted monetary quantities.
<DT>char *positive_sign
<DD>The string used to indicate a nonnegative-valued monetary quantity.
<DT>char *negative_sign
<DD>The string used to indicate a negative-valued monetary quantity.
<DT>char int_frac_digits
<DD>The number of fractional digits (those to the right of the decimal-point) to be displayed in an internationally formatted
monetary quantity.
<DT>char frac_digits
<DD>The number of fractional digits (those to the right of the decimal-point) to be displayed in a formatted monetary quantity.
<DT>char p_cs_precedes
<DD>Set to 1 or 0 if the <TT> currency_symbol</TT> respectively precedes or follows the value for a nonnegative formatted monetary
quantity.
<DT>char p_sep_by_space
<DD>Set to 1 or 0 if the <TT> currency_symbol</TT> respectively is or is not separated by a space from the value for a nonnegative
formatted monetary quantity.
<DT>char n_cs_precedes
<DD>Set to 1 or 0 if the <TT> currency_symbol</TT> respectively precedes or follows the value for a negative formatted monetary
quantity.
<DT>char n_sep_by_space
<DD>Set to 1 or 0 if the <TT> currency_symbol</TT> respectively is or is not separated by a space from the value for a negative
formatted monetary quantity.
<DT>char p_sign_posn
<DD>The position of the <TT> positive_sign</TT> for a nonnegative formatted monetary quantity.
<DT>char n_sign_posn
<DD>The position of the <TT> positive_sign</TT> for a negative formatted monetary quantity.
</DL>
<BR>The elements of <TT> grouping</TT> and <TT> mon_grouping</TT> are interpreted according to the following:
<DL>
<DT>Value&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>CHAR_MAX
<DD>No further grouping is to be performed.
<DT>0
<DD>The previous element is to be repeatedly used for the remainder of the digits.
<DT>other
<DD>The value is the number of digits that comprise the current group.&nbsp; The next element is examined to determine the size
of the next group of digits to the left of the current group.
</DL>
<BR>The value of <TT> p_sign_posn</TT> and <TT> n_sign_posn</TT> is interpreted as follows:
<DL>
<DT>Value&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>0
<DD>Parentheses surround the quantity and <TT> currency_symbol</TT>.
<DT>1
<DD>The sign string precedes the quantity and <TT> currency_symbol</TT>.
<DT>2
<DD>The sign string follows the quantity and <TT> currency_symbol</TT>.
<DT>3
<DD>The sign string immediately precedes the quantity and <TT> currency_symbol</TT>.
<DT>4
<DD>The sign string immediately follows the quantity and <TT> currency_symbol</TT>.
</DL>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> localeconv</TT> function returns a pointer to the filled-in object.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#setlocale">setlocale</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;locale.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct lconv *lc;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; lc = localeconv();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;*decimal_point (%s)\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lc-&gt;decimal_point );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;*thousands_sep (%s)\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lc-&gt;thousands_sep );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;*int_curr_symbol (%s)\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lc-&gt;int_curr_symbol );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;*currency_symbol (%s)\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lc-&gt;currency_symbol );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;*mon_decimal_point (%s)\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lc-&gt;mon_decimal_point );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;*mon_thousands_sep (%s)\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lc-&gt;mon_thousands_sep );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;*mon_grouping (%s)\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lc-&gt;mon_grouping );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;*grouping (%s)\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lc-&gt;grouping );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;*positive_sign (%s)\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lc-&gt;positive_sign );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;*negative_sign (%s)\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lc-&gt;negative_sign );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;int_frac_digits (%d)\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lc-&gt;int_frac_digits );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;frac_digits (%d)\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lc-&gt;frac_digits );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;p_cs_precedes (%d)\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lc-&gt;p_cs_precedes );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;p_sep_by_space (%d)\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lc-&gt;p_sep_by_space );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;n_cs_precedes (%d)\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lc-&gt;n_cs_precedes );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;n_sep_by_space (%d)\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lc-&gt;n_sep_by_space );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;p_sign_posn (%d)\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lc-&gt;p_sign_posn );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;n_sign_posn (%d)\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lc-&gt;n_sign_posn );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="localtime"> localtime Functions </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;time.h&gt;</TT>
<BR><TT>struct tm * localtime( const time_t *timer );</TT>
<BR><TT>struct tm *_localtime( const time_t *timer,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; struct tm *tmbuf );</TT>
<BR><BR><TT>struct&nbsp; tm {</TT>
<BR><TT>&nbsp; int tm_sec;&nbsp;&nbsp; /* seconds after the minute -- [0,61] */</TT>
<BR><TT>&nbsp; int tm_min;&nbsp;&nbsp; /* minutes after the hour&nbsp;&nbsp; -- [0,59] */</TT>
<BR><TT>&nbsp; int tm_hour;&nbsp; /* hours after midnight&nbsp;&nbsp;&nbsp;&nbsp; -- [0,23] */</TT>
<BR><TT>&nbsp; int tm_mday;&nbsp; /* day of the month&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- [1,31] */</TT>
<BR><TT>&nbsp; int tm_mon;&nbsp;&nbsp; /* months since January&nbsp;&nbsp;&nbsp;&nbsp; -- [0,11] */</TT>
<BR><TT>&nbsp; int tm_year;&nbsp; /* years since 1900&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp; int tm_wday;&nbsp; /* days since Sunday&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- [0,6]&nbsp; */</TT>
<BR><TT>&nbsp; int tm_yday;&nbsp; /* days since January 1&nbsp;&nbsp;&nbsp;&nbsp; -- [0,365]*/</TT>
<BR><TT>&nbsp; int tm_isdst; /* Daylight Savings Time flag */</TT>
<BR><TT>};</TT>
</DL>
<DL>
<DT>Safer C:
<DD>The Safer C Library extension provides the <A HREF="#localtime_s">localtime_s</A> function which is a safer alternative to<TT>
localtime</TT> This newer<TT> localtime_s</TT> function is recommended to be used instead of the traditional &quot;unsafe&quot;<TT>
localtime</TT> function.
</DL>
<DL>
<DT>Description:
<DD>The<TT> localtime</TT> functions convert the calendar time pointed to by<B> timer</B> into a structure of type <TT> tm</TT>,
of time information, expressed as local time.&nbsp; Whenever<TT> localtime</TT> is called, the <TT> tzset</TT> function is
also called.
<BR><BR>The calendar time is usually obtained by using the <TT> time</TT> function.&nbsp; That time is Coordinated Universal
Time (UTC) (formerly known as Greenwich Mean Time (GMT)).
<BR><BR>The <TT> _localtime</TT> function places the converted time in the <TT> tm</TT> structure pointed to by<B> tmbuf</B>,
and the<TT> localtime</TT> function places the converted time in a static structure that is re-used each time<TT> localtime</TT>
is called.
<BR><BR>The time set on the computer with the DOS<TT> time</TT> command and the DOS<TT> date</TT> command reflects the local
time.&nbsp; The environment variable<TT> TZ</TT> is used to establish the time zone to which this local time applies.&nbsp;
See the section<B> The TZ Environment Variable</B> for a discussion of how to set the time zone.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> localtime</TT> functions return a pointer to a <TT> tm</TT> structure containing the time information.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#asctime">asctime</A> Functions, <A HREF="#asctime_s">asctime_s</A>, <A HREF="#clock">clock</A>, <A HREF="#ctime">ctime</A>
Functions, <A HREF="#ctime_s">ctime_s</A>, <A HREF="#difftime">difftime</A>, <A HREF="#gmtime">gmtime</A>, <A HREF="#gmtime_s">gmtime_s</A>,
<A HREF="#localtime_s">localtime_s</A>, <A HREF="#mktime">mktime</A>, <A HREF="#strftime">strftime</A>, <A HREF="#time">time</A>,
<A HREF="#tzset">tzset</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;time.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; time_t time_of_day;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; auto char buf[26];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; auto struct tm tmbuf;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; time_of_day = time( NULL );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _localtime( &amp;time_of_day, &amp;tmbuf );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;It is now: %s&quot;, _asctime( &amp;tmbuf, buf ) );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>It is now: Sat Mar 21 15:58:27 1987</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>_localtime is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> localtime - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_localtime - All, Linux, RDOS</TT>
</DL>
<H2 ID="localtime_s"> localtime_s </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__ 1</TT>
<BR><TT>#include &lt;time.h&gt;</TT>
<BR><TT>struct tm * localtime_s( const time_t * restrict timer,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; struct tm * restrict result);</TT>
<BR><BR><TT>struct&nbsp; tm {</TT>
<BR><TT>&nbsp; int tm_sec;&nbsp;&nbsp; /* seconds after the minute -- [0,61] */</TT>
<BR><TT>&nbsp; int tm_min;&nbsp;&nbsp; /* minutes after the hour&nbsp;&nbsp; -- [0,59] */</TT>
<BR><TT>&nbsp; int tm_hour;&nbsp; /* hours after midnight&nbsp;&nbsp;&nbsp;&nbsp; -- [0,23] */</TT>
<BR><TT>&nbsp; int tm_mday;&nbsp; /* day of the month&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- [1,31] */</TT>
<BR><TT>&nbsp; int tm_mon;&nbsp;&nbsp; /* months since January&nbsp;&nbsp;&nbsp;&nbsp; -- [0,11] */</TT>
<BR><TT>&nbsp; int tm_year;&nbsp; /* years since 1900&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp; int tm_wday;&nbsp; /* days since Sunday&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- [0,6]&nbsp; */</TT>
<BR><TT>&nbsp; int tm_yday;&nbsp; /* days since January 1&nbsp;&nbsp;&nbsp;&nbsp; -- [0,365]*/</TT>
<BR><TT>&nbsp; int tm_isdst; /* Daylight Savings Time flag */</TT>
<BR><TT>};</TT>
</DL>
<DL>
<DT>Constraints:
<DD>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<TT>
localtime_s</TT> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<BR><BR>Neither<B> timer</B> nor<B> result</B> shall be a null pointer.&nbsp; If there is a runtime-constraint violation,
there is no attempt to convert the time.
</DL>
<DL>
<DT>Description:
<DD>The<TT> localtime_s</TT> function converts the calendar time pointed to by<B> timer</B> into a broken-down time, expressed
as local time.&nbsp; The broken-down time is stored in the structure pointed to by<B> result</B>.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> localtime_s</TT> function returns<B> result</B>, or a null pointer if the specified time cannot be converted to local
time or there is a runtime-constraint violation.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#asctime">asctime</A> Functions, <A HREF="#asctime_s">asctime_s</A>, <A HREF="#clock">clock</A>, <A HREF="#ctime">ctime</A>
Functions, <A HREF="#ctime_s">ctime_s</A>, <A HREF="#difftime">difftime</A>, <A HREF="#gmtime">gmtime</A>, <A HREF="#gmtime_s">gmtime_s</A>,
<A HREF="#localtime">localtime</A>, <A HREF="#mktime">mktime</A>, <A HREF="#strftime">strftime</A>, <A HREF="#time">time</A>,
<A HREF="#tzset">tzset</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__ 1</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;time.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; time_t time_of_day;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; auto char buf[26];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; auto struct tm tmbuf;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; time_of_day = time( NULL );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; localtime_s( &amp;time_of_day, &amp;tmbuf );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; asctime_s( buf, sizeof( buf ), &amp;tmbuf );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;It is now: %s&quot;, buf );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>It is now: Mon Jan 30 15:28:33 2006</TT>
</DL>
<DL>
<DT>Classification:
<DD>TR 24731
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, Linux, RDOS, Netware
</DL>
<H2 ID="lock"> lock </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;io.h&gt;</TT>
<BR><TT>int lock( int handle,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long offset,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long nbytes );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> lock</TT> function locks<B> nbytes</B> amount of data in the file designated by<B> handle</B> starting at byte<B>
offset</B> in the file.&nbsp; This prevents other processes from reading or writing into the locked region until an <TT> unlock</TT>
has been done for this locked region of the file.
<BR><BR>Multiple regions of a file can be locked, but no overlapping regions are allowed.&nbsp; You cannot unlock multiple
regions in the same call, even if the regions are contiguous.&nbsp; All locked regions of a file should be unlocked before
closing a file or exiting the program.
<BR><BR>With DOS, locking is supported by version 3.0 or later.&nbsp; Note that<TT> SHARE.COM</TT> or<TT> SHARE.EXE</TT> must
be installed.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> lock</TT> function returns zero if successful, and -1 when an error occurs.&nbsp; When an error has occurred, <TT>
errno</TT> contains a value indicating the type of error that has been detected.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#locking">locking</A>, <A HREF="#open">open</A>, <A HREF="#sopen">sopen</A>, <A HREF="#unlock">unlock</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;fcntl.h&gt;</TT>
<BR><TT>#include &lt;io.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int handle;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char buffer[20];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; handle = open( &quot;file&quot;, O_RDWR | O_TEXT );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( handle != -1 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( lock( handle, 0L, 20L ) ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Lock failed\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; read( handle, buffer, 20 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* update the buffer here */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lseek( handle, 0L, SEEK_SET );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write( handle, buffer, 20 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unlock( handle, 0L, 20L );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close( handle );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>All, RDOS, Netware
</DL>
<H2 ID="locking"> locking, _locking </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;sys/locking.h&gt;</TT>
<BR><TT>int locking( int handle, int mode, long nbyte );</TT>
<BR><TT>int _locking( int handle, int mode, long nbyte );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> locking</TT> function locks or unlocks<B> nbyte</B> bytes of the file specified by<B> handle</B>.&nbsp; Locking a
region of a file prevents other processes from reading or writing the locked region until the region has been unlocked.&nbsp;
The locking and unlocking takes place at the current file position.&nbsp; The argument<B> mode</B> specifies the action to
be performed.&nbsp; The possible values for mode are:
<DL>
<DT>Mode&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>_LK_LOCK, LK_LOCK
<DD>Locks the specified region.&nbsp; The function will retry to lock the region after 1 second intervals until successful or
until 10 attempts have been made.
<DT>_LK_RLCK, LK_RLCK
<DD>Same action as <TT> _LK_LOCK</TT>.
<DT>_LK_NBLCK, LK_NBLCK
<DD>Non-blocking lock:&nbsp; makes only 1 attempt to lock the specified region.
<DT>_LK_NBRLCK, LK_NBRLCK
<DD>Same action as <TT> _LK_NBLCK</TT>.
<DT>_LK_UNLCK, LK_UNLCK
<DD>Unlocks the specified region.&nbsp; The region must have been previously locked.
</DL>
<BR>Multiple regions of a file can be locked, but no overlapping regions are allowed.&nbsp; You cannot unlock multiple regions
in the same call, even if the regions are contiguous.&nbsp; All locked regions of a file should be unlocked before closing
a file or exiting the program.
<BR><BR>With DOS, locking is supported by version 3.0 or later.&nbsp; Note that<TT> SHARE.COM</TT> or<TT> SHARE.EXE</TT> must
be installed.
<BR><BR>The<TT> _locking</TT> function is identical to<TT> locking</TT>.&nbsp; Use<TT> _locking</TT> for ANSI naming conventions.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> locking</TT> function returns zero if successful.&nbsp; Otherwise, it returns -1 and <TT> errno</TT> is set to indicate
the error.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>EACCES
<DD>Indicates a locking violation (file already locked or unlocked).
<DT>EBADF
<DD>Indicates an invalid file handle.
<DT>EDEADLOCK
<DD>Indicates a locking violation.&nbsp; This error is returned when<B> mode</B> is<TT> LK_LOCK</TT> or<TT> LK_RLCK</TT> and the
file cannot be locked after 10 attempts.
<DT>EINVAL
<DD>Indicates that an invalid argument was given to the function.
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#creat">creat</A>, <A HREF="#_dos_creat">_dos_creat</A>, <A HREF="#_dos_open">_dos_open</A>, <A HREF="#lock">lock</A>,
<A HREF="#open">open</A>, <A HREF="#sopen">sopen</A>, <A HREF="#unlock">unlock</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;sys/locking.h&gt;</TT>
<BR><TT>#include &lt;share.h&gt;</TT>
<BR><TT>#include &lt;fcntl.h&gt;</TT>
<BR><TT>#include &lt;io.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int handle;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned nbytes;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned long offset;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; auto char buffer[512];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; nbytes = 512;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; offset = 1024;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; handle = sopen( &quot;db.fil&quot;, O_RDWR, SH_DENYNO );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( handle != -1 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lseek( handle, offset, SEEK_SET );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; locking( handle, LK_LOCK, nbytes );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; read( handle, buffer, nbytes );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* update data in the buffer */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lseek( handle, offset, SEEK_SET );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write( handle, buffer, nbytes );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lseek( handle, offset, SEEK_SET );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; locking( handle, LK_UNLCK, nbytes );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close( handle );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
<BR><BR>_locking conforms to ANSI naming conventions
</DL>
<DL>
<DT>Systems:
<DD><TT> locking - All, Linux, RDOS</TT>
<BR><BR><TT>_locking - All, Linux, RDOS</TT>
</DL>
<H2 ID="log"> log </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>double log( double x );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> log</TT> function computes the natural logarithm (base e) of<B> x</B>.&nbsp; A domain error occurs if the argument
is negative.&nbsp; A range error occurs if the argument is zero.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> log</TT> function returns the natural logarithm of the argument.&nbsp; When the argument is outside the permissible
range, the <TT> matherr</TT> function is called.&nbsp; Unless the default <TT> matherr</TT> function is replaced, it will
set the global variable <TT> errno</TT> to <TT> EDOM</TT>, and print a &quot;DOMAIN error&quot; diagnostic message using the
<TT> stderr</TT> stream.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#exp">exp</A>, <A HREF="#log10">log10</A>, <A HREF="#log2">log2</A>, <A HREF="#pow">pow</A>, <A HREF="#matherr">matherr</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, log(.5) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>-0.693147</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD>Math
</DL>
<H2 ID="log10"> log10 </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>double log10( double x );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> log10</TT> function computes the logarithm (base 10) of<B> x</B>.&nbsp; A domain error occurs if the argument is negative.
&nbsp;A range error occurs if the argument is zero.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> log10</TT> function returns the logarithm (base 10) of the argument.&nbsp; When the argument is outside the permissible
range, the <TT> matherr</TT> function is called.&nbsp; Unless the default <TT> matherr</TT> function is replaced, it will
set the global variable <TT> errno</TT> to <TT> EDOM</TT>, and print a &quot;DOMAIN error&quot; diagnostic message using the
<TT> stderr</TT> stream.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#exp">exp</A>, <A HREF="#log">log</A>, <A HREF="#log2">log2</A>, <A HREF="#pow">pow</A>, <A HREF="#matherr">matherr</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, log10(.5) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>-0.301030</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD>Math
</DL>
<H2 ID="log1p"> log1p </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>double log1p( double x );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> log1p</TT> function computes the natural logarithm of one plus<B> x</B>.&nbsp; For small values of<B> x</B> this function
provides far better accuracy than using the <TT> log</TT> function directly.
</DL>
<DL>
<DT>Returns:
<DD>If successful, the return value is the logarithm of one plus<B> x</B>.&nbsp; When the argument is -1.0, the function returns
infinity.&nbsp; If the value of<B> x</B> is less than -1.0, the function returns NAN.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#log">log</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, log1p( 0.02 ) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>0.019803</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C99
</DL>
<DL>
<DT>Systems:
<DD>Math
</DL>
<H2 ID="log2"> log2 </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>double log2( double x );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> log2</TT> function computes the logarithm (base 2) of<B> x</B>.&nbsp; A domain error occurs if the argument is negative.
&nbsp;A range error occurs if the argument is zero.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> log2</TT> function returns the logarithm (base 2) of the argument.&nbsp; When the argument is outside the permissible
range, the <TT> matherr</TT> function is called.&nbsp; Unless the default <TT> matherr</TT> function is replaced, it will
set the global variable <TT> errno</TT> to <TT> EDOM</TT>, and print a &quot;DOMAIN error&quot; diagnostic message using the
<TT> stderr</TT> stream.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#exp">exp</A>, <A HREF="#log">log</A>, <A HREF="#log10">log10</A>, <A HREF="#pow">pow</A>, <A HREF="#matherr">matherr</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, log2(.25) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>-2.000000</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>Math
</DL>
<H2 ID="logb"> logb </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>double logb( double x );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> logb</TT> function returns the exponent portion of the argument<B> x</B> as a double.
</DL>
<DL>
<DT>Returns:
<DD>If successful, the return value is the exponent of<B> x</B>.&nbsp; When the argument is zero, the function returns infinity.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#ilogb">ilogb</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, logb( 1024.0 ) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>10.0000</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C99
</DL>
<DL>
<DT>Systems:
<DD>Math
</DL>
<H2 ID="longjmp"> longjmp </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;setjmp.h&gt;</TT>
<BR><TT>void longjmp( jmp_buf env, int return_value );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> longjmp</TT> function restores the environment saved by the most recent call to the <TT> setjmp</TT> function with
the corresponding <TT> jmp_buf</TT> argument.
<BR><BR>It is generally a bad idea to use<TT> longjmp</TT> to jump out of an interrupt function or a signal handler (unless
the signal was generated by the <TT> raise</TT> function).
</DL>
<DL>
<DT>Returns:
<DD>The<TT> longjmp</TT> function does not return to its caller.&nbsp; After the<TT> longjmp</TT> function restores the environment,
program execution continues as if the corresponding call to <TT> setjmp</TT> had just returned the value specified by<B> return_value</B>.
&nbsp;If the value of<B> return_value</B> is 0, the value returned is 1.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#setjmp">setjmp</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;setjmp.h&gt;</TT>
<BR><BR><TT>jmp_buf env;</TT>
<BR><BR><TT>rtn()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;about to longjmp\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; longjmp( env, 14 );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int ret_val = 293;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; if( 0 == ( ret_val = setjmp( env ) ) ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;after setjmp %d\n&quot;, ret_val );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rtn();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;back from rtn %d\n&quot;, ret_val );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;back from longjmp %d\n&quot;, ret_val );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>after setjmp 0</TT>
<BR><TT>about to longjmp</TT>
<BR><TT>back from longjmp 14</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="_lrotl"> _lrotl </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>unsigned long _lrotl( unsigned long value,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; unsigned int shift );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _lrotl</TT> function rotates the unsigned long integer, determined by<B> value</B>, to the left by the number of bits
specified in<B> shift</B>.
</DL>
<DL>
<DT>Returns:
<DD>The rotated value is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_lrotr">_lrotr</A>, <A HREF="#_rotl">_rotl</A>, <A HREF="#_rotr">_rotr</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>unsigned long mask = 0x12345678;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; mask = _lrotl( mask, 4 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%08lX\n&quot;, mask );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>23456781</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="_lrotr"> _lrotr </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>unsigned long _lrotr( unsigned long value,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; unsigned int shift );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _lrotr</TT> function rotates the unsigned long integer, determined by<B> value</B>, to the right by the number of
bits specified in<B> shift</B>.
</DL>
<DL>
<DT>Returns:
<DD>The rotated value is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_lrotl">_lrotl</A>, <A HREF="#_rotl">_rotl</A>, <A HREF="#_rotr">_rotr</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>unsigned long mask = 0x12345678;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; mask = _lrotr( mask, 4 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%08lX\n&quot;, mask );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>81234567</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="lsearch"> lsearch </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;search.h&gt;</TT>
<BR><TT>void *lsearch( const void *key, /* object to search for */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void *base,&nbsp;&nbsp;&nbsp;
&nbsp; /* base of search data&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned *num,&nbsp;&nbsp; /*
number of elements&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned width,&nbsp; /* width
of each element*/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int (*compare)( const void *element1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const void *element2 ) );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> lsearch</TT> function performs a linear search for the value<B> key</B> in the array of<B> num</B> elements pointed
to by<B> base</B>.&nbsp; Each element of the array is<B> width</B> bytes in size.&nbsp; The argument<B> compare</B> is a pointer
to a user-supplied routine that will be called by lsearch to determine the relationship of an array element with the<B> key</B>.
&nbsp;One of the arguments to the<B> compare</B> function will be an array element, and the other will be<B> key</B>.
<BR><BR>The<B> compare</B> function should return 0 if<B> element1</B> is identical to<B> element2</B> and non-zero if the
elements are not identical.
</DL>
<DL>
<DT>Returns:
<DD>If the<B> key</B> value is not found in the array, then it is added to the end of the array and the number of elements is
incremented.&nbsp; The<TT> lsearch</TT> function returns a pointer to the array element in<B> base</B> that matches<B> key</B>
if it is found, or the newly added key if it was not found.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#bsearch">bsearch</A>, <A HREF="#lfind">lfind</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>#include &lt;search.h&gt;</TT>
<BR><BR><TT>void main( int argc, const char *argv[] )</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int i;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned num = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char **array = (char **)calloc( argc, sizeof(char **) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; extern int compare( const void *, const void * );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; for( i = 1; i &lt; argc; ++i ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lsearch( &amp;argv[i], array, &amp;num, sizeof(char **),</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; compare );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; num; ++i ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, array[i] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR><TT>int compare( const void *op1, const void *op2 )</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; const char **p1 = (const char **) op1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; const char **p2 = (const char **) op2;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; return( strcmp( *p1, *p2 ) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR><TT>/* With input: one two one three four */</TT>
<BR><BR>produces the following:
<BR><BR><TT>one</TT>
<BR><TT>two</TT>
<BR><TT>three</TT>
<BR><TT>four</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="lseek"> lseek, _lseek, _lseeki64 </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;io.h&gt;</TT>
<BR><TT>off_t lseek( int handle, off_t offset, int origin );</TT>
<BR><TT>off_t _lseek( int handle, off_t offset, int origin );</TT>
<BR><TT>__int64 _lseeki64( int handle, __int64 offset, int origin );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> lseek</TT> function sets the current file position at the operating system level.&nbsp; The file is referenced using
the file handle<B> handle</B> returned by a successful execution of one of the <TT> creat</TT>, <TT> dup</TT>, <TT> dup2</TT>,
<TT> open</TT> or <TT> sopen</TT> functions.&nbsp; The value of<B> offset</B> is used as a relative offset from a file position
determined by the value of the argument<B> origin</B>.
<BR><BR>The new file position is determined in a manner dependent upon the value of<B> origin</B> which may have one of three
possible values (defined in the<TT> &lt;stdio.h&gt;</TT> header file):
<DL>
<DT>Origin&nbsp;&nbsp;&nbsp;&nbsp; Definition
<DT>SEEK_SET
<DD>The new file position is computed relative to the start of the file.&nbsp; The value of<B> offset</B> must not be negative.
<DT>SEEK_CUR
<DD>The new file position is computed relative to the current file position.&nbsp; The value of<B> offset</B> may be positive,
negative or zero.
<DT>SEEK_END
<DD>The new file position is computed relative to the end of the file.
</DL>
<BR>An error will occur if the requested file position is before the start of the file.
<BR><BR>The requested file position may be beyond the end of the file.&nbsp; On POSIX-conforming systems, if data is later
written at this point, subsequent reads of data in the gap will return bytes whose value is equal to zero until data is actually
written in the gap.&nbsp; On systems such DOS and OS/2 that are not POSIX-conforming, data that are read in the gap have arbitrary
values.
<BR><BR>Some versions of MS-DOS allow seeking to a negative offset, but it is not recommended since it is not supported by
other platforms and may not be supported in future versions of MS-DOS.
<BR><BR>The<TT> lseek</TT> function does not, in itself, extend the size of a file (see the description of the <TT> chsize</TT>
function).
<BR><BR>The<TT> _lseek</TT> function is identical to<TT> lseek</TT>.&nbsp; Use<TT> _lseek</TT> for ANSI naming conventions.
<BR><BR>The _lseeki64 function is identical to<TT> lseek</TT> except that it accepts a 64-bit value for the<B> offset</B>
argument.
<BR><BR>The<TT> lseek</TT> function can be used to obtain the current file position (the <TT> tell</TT> function is implemented
in terms of _strnextc).&nbsp; This value can then be used with the<TT> lseek</TT> function to reset the file position to that
point in the file:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; off_t file_posn;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int handle;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* get current file position */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; file_posn = lseek( handle, 0L, SEEK_CUR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* or */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; file_posn = tell( handle );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* return to previous file position */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; file_posn = lseek( handle, file_posn, SEEK_SET );</TT>
<BR><BR>If all records in the file are the same size, the position of the n'th record can be calculated and read, as illustrated
in the example included below.&nbsp; The function in this example assumes records are numbered starting with zero and that<B>
rec_size</B> contains the size of a record in the file (including the record-separator character).&nbsp; (including the carriage-return
character in text files).
</DL>
<DL>
<DT>Returns:
<DD>If successful, the current file position is returned in a system-dependent manner.&nbsp; A value of 0 indicates the start
of the file.
<BR><BR>If an error occurs in<TT> lseek</TT> (-1L) is returned.
<BR><BR>If an error occurs in _lseeki64, (-1I64) is returned.
<BR><BR>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>EBADF
<DD>The<B> handle</B> argument is not a valid file handle.
<DT>EINVAL
<DD>The<B> origin</B> argument is not a proper value, or the resulting file offset would be invalid.
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#chsize">chsize</A>, <A HREF="#close">close</A>, <A HREF="#creat">creat</A>, <A HREF="#dup">dup</A>, <A HREF="#dup2">dup2</A>,
<A HREF="#eof">eof</A>, <A HREF="#exec___">exec...</A>, <A HREF="#fdopen">fdopen</A>, <A HREF="#filelength">filelength</A>,
<A HREF="#fileno">fileno</A>, <A HREF="#fstat">fstat</A>, <A HREF="#_grow_handles">_grow_handles</A>, <A HREF="#isatty">isatty</A>,
<A HREF="#open">open</A>, <A HREF="#read">read</A>, <A HREF="#setmode">setmode</A>, <A HREF="#sopen">sopen</A>, <A HREF="#stat">stat</A>,
<A HREF="#tell">tell</A>, <A HREF="#write">write</A>, <A HREF="#umask">umask</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;fcntl.h&gt;</TT>
<BR><TT>#include &lt;io.h&gt;</TT>
<BR><BR><TT>int read_record( int&nbsp; handle,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long rec_numb,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp; rec_size,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *buffer )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( lseek( handle, rec_numb * rec_size, SEEK_SET )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; == -1L ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( -1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; return( read( handle, buffer, rec_size ) );</TT>
<BR><TT>}</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp; handle;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp; size_read;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char buffer[80];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; /* open a file for input */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; handle = open( &quot;file&quot;, O_RDONLY | O_TEXT );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( handle != -1 ) {</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* read a piece of the text */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_read =</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; read_record( handle, 1, 80, buffer );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* test for error */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( size_read == -1 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Error reading file\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%.80s\n&quot;, buffer );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* close the file */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close( handle );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>POSIX 1003.1
<BR><BR>_lseek conforms to ANSI naming conventions
<BR>_lseeki64 is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> lseek - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_lseek - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
<BR><TT>_lseeki64 - All, Linux</TT>
</DL>
<H2 ID="lltoa"> lltoa, _lltoa, _lltow </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>char *lltoa( long long int value,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *buffer,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int radix );</TT>
<BR><TT>char *_lltoa( long long int value,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *buffer,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int radix );</TT>
<BR><TT>wchar_t *_lltow( long long int value,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t *buffer,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int radix );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> lltoa</TT> function converts the binary integer<B> value</B> into the equivalent string in base<B> radix</B> notation
storing the result in the character array pointed to by<B> buffer</B>.&nbsp; A null character is appended to the result.&nbsp;
The size of<B> buffer</B> must be at least 65 bytes when converting values in base 2.&nbsp; The value of<B> radix</B> must
satisfy the condition:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 2 &lt;= radix &lt;= 36</TT>
<BR><BR>If<B> radix</B> is 10 and<B> value</B> is negative, then a minus sign is prepended to the result.
<BR><BR>The<TT> _lltoa</TT> function is identical to<TT> lltoa</TT>.&nbsp; Use<TT> _lltoa</TT> for ANSI naming conventions.
<BR><BR>The<TT> _lltow</TT> function is a wide-character version of<TT> lltoa</TT>.&nbsp; It produces a wide-character string.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> lltoa</TT> function returns a pointer to the result.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#atoi">atoi</A>, <A HREF="#atol">atol</A>, <A HREF="#atoll">atoll</A>, <A HREF="#itoa">itoa</A>, <A HREF="#ltoa">ltoa</A>,
<A HREF="#sscanf">sscanf</A>, <A HREF="#strtol">strtol</A>, <A HREF="#strtoll">strtoll</A>, <A HREF="#strtoul">strtoul</A>,
<A HREF="#strtoull">strtoull</A>, <A HREF="#strtoimax">strtoimax</A>, <A HREF="#strtoumax">strtoumax</A>, <A HREF="#ultoa">ultoa</A>,
<A HREF="#ulltoa">ulltoa</A>, <A HREF="#utoa">utoa</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>void print_value( long value )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int base;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char buffer[65];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; for( base = 2; base &lt;= 16; base = base + 2 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%2d %s\n&quot;, base,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lltoa( value, buffer, base
) );</TT>
<BR><TT>}</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; print_value( 1234098765LL );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT> 2 1001001100011101101101001001101</TT>
<BR><TT> 4 1021203231221031</TT>
<BR><TT> 6 322243004113</TT>
<BR><TT> 8 11143555115</TT>
<BR><TT>10 1234098765</TT>
<BR><TT>12 2a5369639</TT>
<BR><TT>14 b9c8863b</TT>
<BR><TT>16 498eda4d</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
<BR><BR>_lltoa conforms to ANSI naming conventions
</DL>
<DL>
<DT>Systems:
<DD><TT> lltoa - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_lltoa - All, Linux, RDOS, Netware</TT>
<BR><TT>_lltow - All, Linux, RDOS</TT>
</DL>
<H2 ID="ltoa"> ltoa, _ltoa, _ltow </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>char *ltoa( long int value,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *buffer,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int radix );</TT>
<BR><TT>char *_ltoa( long int value,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *buffer,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int radix );</TT>
<BR><TT>wchar_t *_ltow( long int value,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t *buffer,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int radix );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> ltoa</TT> function converts the binary integer<B> value</B> into the equivalent string in base<B> radix</B> notation
storing the result in the character array pointed to by<B> buffer</B>.&nbsp; A null character is appended to the result.&nbsp;
The size of<B> buffer</B> must be at least 33 bytes when converting values in base 2.&nbsp; The value of<B> radix</B> must
satisfy the condition:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 2 &lt;= radix &lt;= 36</TT>
<BR><BR>If<B> radix</B> is 10 and<B> value</B> is negative, then a minus sign is prepended to the result.
<BR><BR>The<TT> _ltoa</TT> function is identical to<TT> ltoa</TT>.&nbsp; Use<TT> _ltoa</TT> for ANSI naming conventions.
<BR><BR>The<TT> _ltow</TT> function is a wide-character version of<TT> ltoa</TT>.&nbsp; It produces a wide-character string.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> ltoa</TT> function returns a pointer to the result.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#atoi">atoi</A>, <A HREF="#atol">atol</A>, <A HREF="#atoll">atoll</A>, <A HREF="#itoa">itoa</A>, <A HREF="#lltoa">lltoa</A>,
<A HREF="#sscanf">sscanf</A>, <A HREF="#strtol">strtol</A>, <A HREF="#strtoll">strtoll</A>, <A HREF="#strtoul">strtoul</A>,
<A HREF="#strtoull">strtoull</A>, <A HREF="#strtoimax">strtoimax</A>, <A HREF="#strtoumax">strtoumax</A>, <A HREF="#ultoa">ultoa</A>,
<A HREF="#ulltoa">ulltoa</A>, <A HREF="#utoa">utoa</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>void print_value( long value )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int base;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char buffer[33];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; for( base = 2; base &lt;= 16; base = base + 2 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%2d %s\n&quot;, base,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ltoa( value, buffer, base
) );</TT>
<BR><TT>}</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; print_value( 12765L );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT> 2 11000111011101</TT>
<BR><TT> 4 3013131</TT>
<BR><TT> 6 135033</TT>
<BR><TT> 8 30735</TT>
<BR><TT>10 12765</TT>
<BR><TT>12 7479</TT>
<BR><TT>14 491b</TT>
<BR><TT>16 31dd</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
<BR><BR>_ltoa conforms to ANSI naming conventions
</DL>
<DL>
<DT>Systems:
<DD><TT> ltoa - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_ltoa - All, Linux, RDOS, Netware</TT>
<BR><TT>_ltow - All, Linux, RDOS</TT>
</DL>
<H2 ID="main"> main, wmain, WinMain, wWinMain </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>int main( void );</TT>
<BR><TT>int main( int argc, char *argv[] );</TT>
<BR><TT>int wmain( void );</TT>
<BR><TT>int wmain( int argc, wchar_t *argv[] );</TT>
<BR><TT>int PASCAL WinMain( HINSTANCE hInstance,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
HINSTANCE hPrevInstance,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
LPSTR lpszCmdLine,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
int nCmdShow );</TT>
<BR><TT>int PASCAL wWinMain( HINSTANCE hInstance,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;HINSTANCE hPrevInstance,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;wcharT *lpszCmdLine,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;int nCmdShow );</TT>
</DL>
<DL>
<DT>Description:
<DD><TT> main</TT> is a user-supplied function where program execution begins.&nbsp; The command line to the program is broken
into a sequence of tokens separated by blanks and are passed to<TT> main</TT> as an array of pointers to character strings
in the parameter<B> argv</B>.&nbsp; The number of arguments found is passed in the parameter<B> argc</B>.&nbsp; The first
element of<B> argv</B> will be a pointer to a character string containing the program name.&nbsp; The last element of the
array pointed to by<B> argv</B> will be a NULL pointer (i.e.<B>&nbsp; argv[argc]</B> will be<TT> NULL</TT>).&nbsp; Arguments
that contain blanks can be passed to<TT> main</TT> by enclosing them within double quote characters (which are removed from
that element in the<B> argv</B> vector.&nbsp; A literal double quote character can be passed by preceding it with a backslash.
&nbsp;A literal backslash followed by an enclosing double quote character can be passed as a pair of backslash characters
and a double quote character.
<DL>
<DT>Example:
<DD>
<BR><TT>echo &quot;he\&quot;l\lo world\\&quot;</TT>
</DL>
<BR>passes the single argument<B> he&quot;l\lo world\</B>
<BR>The command line arguments can also be obtained in its original format by using the <TT> getcmd</TT> function.
<BR><BR>Alternatively, the<TT> main</TT> function can be declared to return <TT> void</TT> (i.e., no return value).&nbsp;
In this case, you will not be able to return an exit code from main using a <TT> return</TT> statement but must use the <TT>
exit</TT> function to do so.
<BR><BR>The<TT> wmain</TT> function is a user-defined wide-character version of main that operates with wide-character strings.
&nbsp;If this function is present in the application, then it will be called by the run-time system startup code (and the<TT>
main</TT> function, if present, will not be called).
<BR><BR>As with<TT> main</TT> the<TT> wmain</TT> function can be declared to return <TT> void</TT> and the same considerations
will apply.
<BR><BR>The <TT> WinMain</TT> function is called by the system as the initial entry point for a Windows-based application.
&nbsp;The <TT> wWinMain</TT> function is a wide-character version of <TT> WinMain</TT>.
<DL>
<DT>Parameters&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>hInstance
<DD>Identifies the current instance of the application.
<DT>hPrevInstance
<DD>Identifies the previous instance of the application.&nbsp; For an application written for Win32, this parameter is always
NULL.
<DT>lpszCmdLine
<DD>Points to a null-terminated string specifying the command line for the application.
<DT>nCmdShow
<DD>Specifies how the window is to be shown.&nbsp; This parameter can be one of the following values:
<DL>
<DT>Value&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>SW_HIDE
<DD>Hides the window and activates another window.
<DT>SW_MINIMIZE
<DD>Minimizes the specified window and activates the top-level window in the system's list.
<DT>SW_RESTORE
<DD>Activates and displays a window.&nbsp; If the window is minimized or maximized, Windows restores it to its original size and
position (same as <TT> SW_SHOWNORMAL</TT>).
<DT>SW_SHOW
<DD>Activates a window and displays it in its current size and position.
<DT>SW_SHOWMAXIMIZED
<DD>Activates a window and displays it as a maximized window.
<DT>SW_SHOWMINIMIZED
<DD>Activates a window and displays it as an icon.
<DT>SW_SHOWMINNOACTIVE
<DD>Displays a window as an icon.&nbsp; The active window remains active.
<DT>SW_SHOWNA
<DD>Displays a window in its current state.&nbsp; The active window remains active.
<DT>SW_SHOWNOACTIVATE
<DD>Displays a window in its most recent size and position.&nbsp; The active window remains active.
<DT>SW_SHOWNORMAL
<DD>Activates and displays a window.&nbsp; If the window is minimized or maximized, Windows restores it to its original size and
position (same as <TT> SW_RESTORE</TT>).
</DL>
</DL>
<BR>The <TT> WinMain</TT> function initializes an application, and then performs a message retrieval-and-dispatch loop that
is the top-level control structure for the remainder of the application's execution.&nbsp; The loop terminates when a <TT>
WM_QUIT</TT> message is received.&nbsp; At that point, <TT> WinMain</TT> exits the application, returning the value passed
in the <TT> WM_QUIT</TT> message's <TT> wParam</TT> parameter.&nbsp; If <TT> WM_QUIT</TT> was received as a result of calling
<TT> PostQuitMessage</TT>, the value of <TT> wParam</TT> is the value of the <TT> PostQuitMessage</TT> function's <TT> nExitCode</TT>
parameter.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> main</TT> and<TT> wmain</TT> functions return an exit code to the calling program (usually the operating system).
<BR><BR>If the <TT> WinMain</TT> function terminates before entering the message loop, it should return 0.&nbsp; Otherwise,
it should terminate when it receives a <TT> WM_QUIT</TT> message and return the exit value contained in that message's <TT>
wParam</TT> parameter.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#abort">abort</A>, <A HREF="#atexit">atexit</A>, <A HREF="#_bgetcmd">_bgetcmd</A>, <A HREF="#exec___">exec...</A>,
<A HREF="#exit">exit</A>, <A HREF="#_Exit">_Exit</A>, <A HREF="#_exit">_exit</A>, <A HREF="#getcmd">getcmd</A>, <A HREF="#getenv">getenv</A>,
<A HREF="#onexit">onexit</A>, <A HREF="#putenv">putenv</A>, <A HREF="#spawn___">spawn...</A>, <A HREF="#system">system</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>int main( int argc, char *argv[] )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int i;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; argc; ++i ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;argv[%d] = %s\n&quot;, i, argv[i] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; return( 0 );</TT>
<BR><TT>}</TT>
<BR><TT>#ifdef _WIDE_</TT>
<BR><TT>int wmain( int wargc, wchar_t *wargv[] )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int i;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; wargc; ++i ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wprintf( L&quot;wargv[%d] = %s\n&quot;, i, wargv[i] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; return( 0 );</TT>
<BR><TT>}</TT>
<BR><TT>#endif</TT>
<BR><BR>produces the following:
<BR><BR><TT>argv[0] = C:\WATCOM\DEMO\MYPGM.EXE</TT>
<BR><TT>argv[1] = hhhhh</TT>
<BR><TT>argv[2] = another arg</TT>
<BR><BR>when the program<TT> mypgm</TT> is executed with the command
<BR><BR><TT>mypgm hhhhh&nbsp; &quot;another arg&quot;</TT>
<BR><BR>A sample Windows main program is shown below.
<BR><BR><TT>int PASCAL WinMain( HANDLE this_inst, HANDLE prev_inst,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
LPSTR cmdline, int cmdshow )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; MSG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; msg;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; if( !prev_inst ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( !FirstInstance( this_inst ) ) return( 0 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( !AnyInstance( this_inst, cmdshow ) ) return( 0 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /*</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetMessage returns FALSE when WM_QUIT is received</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; while( GetMessage( &amp;msg, NULL, NULL, NULL ) ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TranslateMessage( &amp;msg );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DispatchMessage( &amp;msg );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; return( msg.wParam );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>wmain is WATCOM
<BR>WinMain is WATCOM
<BR>wWinMain is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> main - All, Netware</TT>
<BR><BR><TT>wmain - Win32, OS/2-32</TT>
<BR><TT>WinMain - Windows, Win386, Win32</TT>
<BR><TT>wWinMain - Win32</TT>
</DL>
<H2 ID="_makepath"> _makepath, _wmakepath </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>void _makepath( char *path,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *drive,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *dir,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *fname,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *ext );</TT>
<BR><TT>void _wmakepath( wchar_t *path,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t
*drive,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t
*dir,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t
*fname,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t
*ext );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _makepath</TT> function constructs a full pathname from the components consisting of a drive letter, directory path,
file name and file name extension.&nbsp; The full pathname is placed in the buffer pointed to by the argument<B> path</B>.
<BR><BR>The<TT> _wmakepath</TT> function is a wide-character version of<TT> _makepath</TT> that operates with wide-character
strings.
<BR><BR>The maximum size required for each buffer is specified by the manifest constants <TT> _MAX_PATH</TT>, <TT> _MAX_DRIVE</TT>,
<TT> _MAX_DIR</TT>, <TT> _MAX_FNAME</TT>, and <TT> _MAX_EXT</TT> which are defined in<TT> &lt;stdlib.h&gt;.</TT>
<DL>
<DT>drive
<DD>The<B> drive</B> argument points to a buffer containing the drive letter (A, B, C, etc.) followed by an optional colon.&nbsp;
The<TT> _makepath</TT> function will automatically insert a colon in the full pathname if it is missing.&nbsp; If<B> drive</B>
is a NULL pointer or points to an empty string, no drive letter or colon will be placed in the full pathname.
<DT>dir
<DD>The<B> dir</B> argument points to a buffer containing just the pathname.&nbsp; Either forward slashes (/) or backslashes (\)
may be used.&nbsp; The trailing slash is optional.&nbsp; The<TT> _makepath</TT> function will automatically insert a trailing
slash in the full pathname if it is missing.&nbsp; If<B> dir</B> is a NULL pointer or points to an empty string, no slash
will be placed in the full pathname.
<DT>fname
<DD>The<B> fname</B> argument points to a buffer containing the base name of the file without any extension (suffix).
<DT>ext
<DD>The<B> ext</B> argument points to a buffer containing the filename extension or suffix.&nbsp; A leading period (.) is optional.
&nbsp;The<TT> _makepath</TT> routine will automatically insert a period in the full pathname if it is missing.&nbsp; If<B>
ext</B> is a NULL pointer or points to an empty string, no period will be placed in the full pathname.
</DL>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _makepath</TT> function returns no value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_fullpath">_fullpath</A>, <A HREF="#_splitpath">_splitpath</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char full_path[ _MAX_PATH ];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char drive[ _MAX_DRIVE ];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char dir[ _MAX_DIR ];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char fname[ _MAX_FNAME ];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char ext[ _MAX_EXT ];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _makepath(full_path,&quot;c&quot;,&quot;watcomc\\h\\&quot;,&quot;stdio&quot;,&quot;h&quot;);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Full path is: %s\n\n&quot;, full_path );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _splitpath( full_path, drive, dir, fname, ext );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Components after _splitpath\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;drive: %s\n&quot;, drive );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;dir:&nbsp;&nbsp; %s\n&quot;, dir );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;fname: %s\n&quot;, fname );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;ext:&nbsp;&nbsp; %s\n&quot;, ext );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>Full path is: c:watcomc\h\stdio.h</TT>
<BR><BR><TT>Components after _splitpath</TT>
<BR><TT>drive: c:</TT>
<BR><TT>dir:&nbsp;&nbsp; watcomc\h\</TT>
<BR><TT>fname: stdio</TT>
<BR><TT>ext:&nbsp;&nbsp; .h</TT>
<BR><BR>Note the use of two adjacent backslash characters (\) within character-string constants to signify a single backslash.
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> _makepath - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_wmakepath - All, Linux</TT>
</DL>
<H2 ID="malloc"> malloc Functions </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;&nbsp; For ISO C compatibility (malloc only)</TT>
<BR><TT>#include &lt;malloc.h&gt;&nbsp; Required for other function prototypes</TT>
<BR><TT>void *malloc( size_t size );</TT>
<BR><TT>void __based(void) *_bmalloc( __segment seg, size_t size );</TT>
<BR><TT>void __far&nbsp; *_fmalloc( size_t size );</TT>
<BR><TT>void __near *_nmalloc( size_t size );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> malloc</TT> functions allocate space for an object of<B> size</B> bytes.&nbsp; Nothing is allocated when the<B> size</B>
argument has a value of zero.
<BR><BR>Each function allocates memory from a particular heap, as listed below:
<DL>
<DT>Function&nbsp;&nbsp;&nbsp;&nbsp; Heap
<DT>malloc
<DD>Depends on data model of the program
<DT>_bmalloc
<DD>Based heap specified by<B> seg</B> value
<DT>_fmalloc
<DD>Far heap (outside the default data segment)
<DT>_nmalloc
<DD>Near heap (inside the default data segment)
</DL>
<BR>In a small data memory model, the<TT> malloc</TT> function is equivalent to the <TT> _nmalloc</TT> function; in a large
data memory model, the<TT> malloc</TT> function is equivalent to the <TT> _fmalloc</TT> function.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> malloc</TT> functions return a pointer to the start of the allocated memory.&nbsp; The malloc, <TT> _fmalloc</TT>
and <TT> _nmalloc</TT> functions return<TT> NULL</TT> if there is insufficient memory available or if the requested size is
zero.&nbsp; The <TT> _bmalloc</TT> function returns <TT> _NULLOFF</TT> if there is insufficient memory available or if the
requested size is zero.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#calloc">calloc</A> Functions, <A HREF="#_expand">_expand</A> Functions, <A HREF="#free">free</A> Functions, <A HREF="#halloc">halloc</A>,
<A HREF="#hfree">hfree</A>, <A HREF="#_msize">_msize</A> Functions, <A HREF="#realloc">realloc</A> Functions, <A HREF="#sbrk">sbrk</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char *buffer;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; buffer = (char *)malloc( 80 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( buffer != NULL ) {</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* body of program */</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; free( buffer );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>_bmalloc is WATCOM
<BR>_fmalloc is WATCOM
<BR>_nmalloc is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> malloc - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_bmalloc - DOS/16, Windows, OS/2 1.x(all)</TT>
<BR><TT>_fmalloc - DOS/16, Windows, OS/2 1.x(all)</TT>
<BR><TT>_nmalloc - DOS, Windows, Win386, Win32, OS/2 1.x, OS/2 1.x(MT), OS/2-32, Linux, RDOS</TT>
</DL>
<H2 ID="matherr"> matherr </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>int matherr( struct _exception *err_info );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> matherr</TT> function is invoked each time an error is detected by functions in the math library.&nbsp; The default<TT>
matherr</TT> function supplied in the library returns zero which causes an error message to be displayed upon <TT> stderr</TT>
and <TT> errno</TT> to be set with an appropriate error value.&nbsp; An alternative version of this function can be provided,
instead of the library version, in order that the error handling for mathematical errors can be handled by an application.
<BR><BR>A program may contain a user-written version of<TT> matherr</TT> to take any appropriate action when an error is detected.
&nbsp;When zero is returned, an error message will be printed upon <TT> stderr</TT> and <TT> errno</TT> will be set as was
the case with the default function.&nbsp; When a non-zero value is returned, no message is printed and <TT> errno</TT> is
not changed.&nbsp; The value<TT> err_info-&gt;retval</TT> is used as the return value for the function in which the error
was detected.
<BR><BR>The<TT> matherr</TT> function is passed a pointer to a structure of type<TT> struct _exception</TT> which contains
information about the error that has been detected:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct _exception</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; { int type;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* TYPE OF ERROR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *name;&nbsp;&nbsp;&nbsp; /* NAME OF FUNCTION&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double arg1;&nbsp;&nbsp; /* FIRST ARGUMENT TO FUNCTION&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double arg2;&nbsp;&nbsp; /* SECOND ARGUMENT TO FUNCTION&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double retval; /* DEFAULT RETURN VALUE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;*/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR>The<TT> type</TT> field will contain one of the following values:
<DL>
<DT>Value&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>DOMAIN
<DD>A domain error has occurred, such as<TT> sqrt(-1e0).</TT>
<DT>SING
<DD>A singularity will result, such as<TT> pow(0e0,-2).</TT>
<DT>OVERFLOW
<DD>An overflow will result, such as<TT> pow(10e0,100).</TT>
<DT>UNDERFLOW
<DD>An underflow will result, such as<TT> pow(10e0,-100).</TT>
<DT>TLOSS
<DD>Total loss of significance will result, such as<TT> exp(1000).</TT>
<DT>PLOSS
<DD>Partial loss of significance will result, such as<TT> sin(10e70).</TT>
</DL>
<BR>The<TT> name</TT> field points to a string containing the name of the function which detected the error.&nbsp; The fields<TT>
arg1</TT> and<TT> arg2</TT> (if required) give the values which caused the error.&nbsp; The field<TT> retval</TT> contains
the value which will be returned by the function.&nbsp; This value may be changed by a user-supplied version of the matherr
function.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> matherr</TT> function returns zero when an error message is to be printed and a non-zero value otherwise.
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><BR><TT>/* Demonstrate error routine in which negative */</TT>
<BR><TT>/* arguments to &quot;sqrt&quot; are treated as positive */</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%e\n&quot;, sqrt( -5e0 ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; exit( 0 );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR><TT>int matherr( struct _exception *err )</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( strcmp( err-&gt;name, &quot;sqrt&quot; ) == 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( err-&gt;type == DOMAIN ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err-&gt;retval = sqrt( -(err-&gt;arg1) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( 1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( 0 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; } else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( 0 );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>Math
</DL>
<H2 ID="max"> max </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>#define max(a,b)&nbsp; (((a) &gt; (b)) ? (a) : (b))</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> max</TT> macro will evaluate to be the greater of two values.&nbsp; It is implemented as follows.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define max(a,b)&nbsp; (((a) &gt; (b)) ? (a) : (b))</TT>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> max</TT> macro will evaluate to the larger of the two values passed.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#min">min</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int a;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; /*</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * The following line will set the variable &quot;a&quot; to 10</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * since 10 is greater than 1.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; a = max( 1, 10 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;The value is: %d\n&quot;, a );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="_mbbtombc"> _mbbtombc </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>unsigned int _mbbtombc( unsigned int ch );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _mbbtombc</TT> function returns the double-byte character equivalent to the single-byte character<B> ch</B>.&nbsp;
The single-byte character must be in the range 0x20 through 0x7E or 0xA1 through 0xDF.
<BR><BR><B>Note:</B>&nbsp; This function was called <TT> hantozen</TT> in earlier versions.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _mbbtombc</TT> function returns<B> ch</B> if there is no equivalent double-byte character; otherwise<TT> _mbbtombc</TT>
returns a double-byte character.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getmbcp">_getmbcp</A>, <A HREF="#_mbcjistojms">_mbcjistojms</A>, <A HREF="#_mbcjmstojis">_mbcjmstojis</A>, <A HREF="#_mbctombb">_mbctombb</A>,
<A HREF="#_ismbbalnum">_ismbbalnum</A>, <A HREF="#_ismbbalpha">_ismbbalpha</A>, <A HREF="#_ismbbgraph">_ismbbgraph</A>, <A HREF="#_ismbbkalnum">_ismbbkalnum</A>,
<A HREF="#_ismbbkalpha">_ismbbkalpha</A>, <A HREF="#_ismbbkana">_ismbbkana</A>, <A HREF="#_ismbbkprint">_ismbbkprint</A>,
<A HREF="#_ismbbkpunct">_ismbbkpunct</A>, <A HREF="#_ismbblead">_ismbblead</A>, <A HREF="#_ismbbprint">_ismbbprint</A>, <A HREF="#_ismbbpunct">_ismbbpunct</A>,
<A HREF="#_ismbbtrail">_ismbbtrail</A>, <A HREF="#_mbcjistojms">_mbcjistojms</A>, <A HREF="#_mbcjmstojis">_mbcjmstojis</A>,
<A HREF="#_mbctombb">_mbctombb</A>, <A HREF="#_mbbtype">_mbbtype</A>, <A HREF="#_setmbcp">_setmbcp</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><BR><TT>char alphabet[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</TT>
<BR><TT>};</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; c;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; sizeof( alphabet ) - 1; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c = _mbbtombc( alphabet[ i ] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%c%c&quot;, c&gt;&gt;8, c );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;\n&quot; );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>A B C D E F G H I J K L M N O P Q R S T U V W X Y Z</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS
</DL>
<H2 ID="_mbbtype"> _mbbtype </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt; (for manifest constants)</TT>
<BR><TT>int _mbbtype( unsigned char ch, int type );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _mbbtype</TT> function determines the type of a byte in a multibyte character.&nbsp; If the value of<B> type</B> is
any value except 1,<TT> _mbbtype</TT> tests for a valid single-byte or lead byte of a multibyte character.&nbsp; If the value
of<B> type</B> is 1,<TT> _mbbtype</TT> tests for a valid trail byte of a multibyte character.
<BR><BR><B>Note:</B>&nbsp; A similar function was called <TT> chkctype</TT> in earlier versions.
</DL>
<DL>
<DT>Returns:
<DD>If the value of<B> type</B> is not 1, the<TT> _mbbtype</TT> function returns one of the following values:
<DL>
<DT>_MBC_SINGLE
<DD>the character is a valid single-byte character (e.g., 0x20 - 0x7E, 0xA1 - 0xDF in code page 932)
<DT>_MBC_LEAD
<DD>the character is valid lead byte character (e.g., 0x81 - 0x9F, 0xE0 - 0xFC in code page 932)
<DT>_MBC_ILLEGAL
<DD>the character is an illegal character (e.g., any value except 0x20 - 0x7E, 0xA1 - 0xDF, 0x81 - 0x9F, 0xE0 - 0xFC in code page
932)
</DL>
<BR>If the value of<B> type</B> is 1, the<TT> _mbbtype</TT> function returns one of the following values:
<DL>
<DT>_MBC_TRAIL
<DD>the character is a valid trailing byte character (e.g., 0x40 - 0x7E, 0x80 - 0xFC in code page 932)
<DT>_MBC_ILLEGAL
<DD>the character is an illegal character (e.g., any character except a valid trailing byte character)
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getmbcp">_getmbcp</A>, <A HREF="#_ismbcalnum">_ismbcalnum</A>, <A HREF="#_ismbcalpha">_ismbcalpha</A>, <A HREF="#_ismbccntrl">_ismbccntrl</A>,
<A HREF="#_ismbcdigit">_ismbcdigit</A>, <A HREF="#_ismbcgraph">_ismbcgraph</A>, <A HREF="#_ismbchira">_ismbchira</A>, <A HREF="#_ismbckata">_ismbckata</A>,
<A HREF="#_ismbcl0">_ismbcl0</A>, <A HREF="#_ismbcl1">_ismbcl1</A>, <A HREF="#_ismbcl2">_ismbcl2</A>, <A HREF="#_ismbclegal">_ismbclegal</A>,
<A HREF="#_ismbclower">_ismbclower</A>, <A HREF="#_ismbcprint">_ismbcprint</A>, <A HREF="#_ismbcpunct">_ismbcpunct</A>, <A HREF="#_ismbcspace">_ismbcspace</A>,
<A HREF="#_ismbcsymbol">_ismbcsymbol</A>, <A HREF="#_ismbcupper">_ismbcupper</A>, <A HREF="#_ismbcxdigit">_ismbcxdigit</A>,
<A HREF="#_setmbcp">_setmbcp</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><BR><TT>const char *types[4] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; &quot;ILLEGAL&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; &quot;SINGLE&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; &quot;LEAD&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; &quot;TRAIL&quot;</TT>
<BR><TT>};</TT>
<BR><BR><TT>const unsigned char chars[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ' ',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '.',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '1',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'A',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x81,0x40, /* double-byte space */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x82,0x60, /* double-byte A */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x82,0xA6, /* double-byte Hiragana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x83,0x42, /* double-byte Katakana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana punctuation */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA6,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xDF,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xE0,0xA1, /* double-byte Kanji */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x00</TT>
<BR><TT>};</TT>
<BR><BR><TT>#define SIZE sizeof( chars ) / sizeof( unsigned char )</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; i, j, k;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; k = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j = _mbbtype( chars[i], k );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, types[ 1 + j ] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( j == _MBC_LEAD )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = 1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>SINGLE</TT>
<BR><TT>SINGLE</TT>
<BR><TT>SINGLE</TT>
<BR><TT>SINGLE</TT>
<BR><TT>LEAD</TT>
<BR><TT>TRAIL</TT>
<BR><TT>LEAD</TT>
<BR><TT>TRAIL</TT>
<BR><TT>LEAD</TT>
<BR><TT>TRAIL</TT>
<BR><TT>LEAD</TT>
<BR><TT>TRAIL</TT>
<BR><TT>SINGLE</TT>
<BR><TT>SINGLE</TT>
<BR><TT>SINGLE</TT>
<BR><TT>LEAD</TT>
<BR><TT>TRAIL</TT>
<BR><TT>ILLEGAL</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS
</DL>
<H2 ID="_mbccmp"> _mbccmp, _fmbccmp </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>int _mbccmp( const unsigned char *s1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char *s2 );</TT>
<BR><TT>int _fmbccmp( const unsigned char __far *s1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char __far *s2 );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _mbccmp</TT> function compares one multibyte character from<B> s1</B> to one multibyte character from<B> s2</B>.
<BR><BR>The<TT> _fmbccmp</TT> function is a data model independent form of the _mbccmp function that accepts far pointer arguments.
&nbsp;It is most useful in mixed memory model applications.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _mbccmp</TT> and<TT> _fmbccmp</TT> functions return the following values.
<DL>
<DT>Value&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>&lt; 0
<DD>multibyte character at<B> s1</B> less than multibyte character at<B> s2</B>
<DT>0
<DD>multibyte character at<B> s1</B> identical to multibyte character at<B> s2</B>
<DT>&gt; 0
<DD>multibyte character at<B> s1</B> greater than multibyte character at<B> s2</B>
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_mbccpy">_mbccpy</A>, <A HREF="#_mbcicmp">_mbcicmp</A>, <A HREF="#_mbcjistojms">_mbcjistojms</A>, <A HREF="#_mbcjmstojis">_mbcjmstojis</A>,
<A HREF="#_mbclen">_mbclen</A>, <A HREF="#_mbctohira">_mbctohira</A>, <A HREF="#_mbctokata">_mbctokata</A>, <A HREF="#_mbctolower">_mbctolower</A>,
<A HREF="#_mbctombb">_mbctombb</A>, <A HREF="#_mbctoupper">_mbctoupper</A>, <A HREF="#mblen">mblen</A>, <A HREF="#mbrlen">mbrlen</A>,
<A HREF="#mbrtowc">mbrtowc</A>, <A HREF="#mbsrtowcs">mbsrtowcs</A>, <A HREF="#mbsrtowcs_s">mbsrtowcs_s</A>, <A HREF="#mbstowcs">mbstowcs</A>,
<A HREF="#mbstowcs_s">mbstowcs_s</A>, <A HREF="#mbtowc">mbtowc</A>, <A HREF="#btowc">btowc</A>, <A HREF="#wcrtomb">wcrtomb</A>,
<A HREF="#wcrtomb_s">wcrtomb_s</A>, <A HREF="#wcsrtombs">wcsrtombs</A>, <A HREF="#wcsrtombs_s">wcsrtombs_s</A>, <A HREF="#wcstombs">wcstombs</A>,
<A HREF="#wcstombs_s">wcstombs_s</A>, <A HREF="#wctob">wctob</A>, <A HREF="#wctomb">wctomb</A>, <A HREF="#wctomb_s">wctomb_s</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><BR><TT>unsigned char mb1[2] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x81, 0x43</TT>
<BR><TT>};</TT>
<BR><BR><TT>unsigned char mb2[2] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x81, 0x42</TT>
<BR><TT>};</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; i = _mbccmp( mb1, mb2 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( i &lt; 0 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Less than\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; else if( i == 0 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Equal to\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Greater than\n&quot; );</TT>
<BR><BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>Greater than</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>_fmbccmp is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> _mbccmp - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
<BR><BR><TT>_fmbccmp - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="_mbccpy"> _mbccpy, _fmbccpy </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>void _mbccpy( unsigned char *dest,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char *ch );</TT>
<BR><TT>void _fmbccpy( unsigned char __far *dest,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char __far *ch
);</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _mbccpy</TT> function copies one multibyte character from<B> ch</B> to<B> dest</B>.
<BR><BR>The<TT> _fmbccpy</TT> function is a data model independent form of the _mbccpy function that accepts far pointer arguments.
&nbsp;It is most useful in mixed memory model applications.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _mbccpy</TT> function does not return a value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_mbccmp">_mbccmp</A>, <A HREF="#_mbcicmp">_mbcicmp</A>, <A HREF="#_mbcjistojms">_mbcjistojms</A>, <A HREF="#_mbcjmstojis">_mbcjmstojis</A>,
<A HREF="#_mbclen">_mbclen</A>, <A HREF="#_mbctohira">_mbctohira</A>, <A HREF="#_mbctokata">_mbctokata</A>, <A HREF="#_mbctolower">_mbctolower</A>,
<A HREF="#_mbctombb">_mbctombb</A>, <A HREF="#_mbctoupper">_mbctoupper</A>, <A HREF="#mblen">mblen</A>, <A HREF="#mbrlen">mbrlen</A>,
<A HREF="#mbrtowc">mbrtowc</A>, <A HREF="#mbsrtowcs">mbsrtowcs</A>, <A HREF="#mbsrtowcs_s">mbsrtowcs_s</A>, <A HREF="#mbstowcs">mbstowcs</A>,
<A HREF="#mbstowcs_s">mbstowcs_s</A>, <A HREF="#mbtowc">mbtowc</A>, <A HREF="#btowc">btowc</A>, <A HREF="#wcrtomb">wcrtomb</A>,
<A HREF="#wcrtomb_s">wcrtomb_s</A>, <A HREF="#wcsrtombs">wcsrtombs</A>, <A HREF="#wcsrtombs_s">wcsrtombs_s</A>, <A HREF="#wcstombs">wcstombs</A>,
<A HREF="#wcstombs_s">wcstombs_s</A>, <A HREF="#wctob">wctob</A>, <A HREF="#wctomb">wctomb</A>, <A HREF="#wctomb_s">wctomb_s</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><BR><TT>unsigned char mb1[2] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x00, 0x00</TT>
<BR><TT>};</TT>
<BR><BR><TT>unsigned char mb2[4] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x81, 0x42, 0x81, 0x41</TT>
<BR><TT>};</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x\n&quot;, mb1[0] &lt;&lt; 8 | mb1[1] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _mbccpy( mb1, mb2 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x\n&quot;, mb1[0] &lt;&lt; 8 | mb1[1] );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>&nbsp; 0000</TT>
<BR><TT>0x8142</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> _mbccpy - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, Linux, RDOS</TT>
<BR><BR><TT>_fmbccpy - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="_mbcicmp"> _mbcicmp, _fmbcicmp </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>int _mbcicmp( const unsigned char *s1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char *s2 );</TT>
<BR><TT>int _fmbcicmp( const unsigned char __far *s1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char __far *s2
);</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _mbcicmp</TT> function compares one multibyte character from<B> s1</B> to one multibyte character from<B> s2</B> using
a case-insensitive comparison.
<BR><BR>The<TT> _fmbcicmp</TT> function is a data model independent form of the _mbcicmp function that accepts far pointer
arguments.&nbsp; It is most useful in mixed memory model applications.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _mbcicmp</TT> and<TT> _fmbcicmp</TT> functions return the following values.
<DL>
<DT>Value&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>&lt; 0
<DD>multibyte character at<B> s1</B> less than multibyte character at<B> s2</B>
<DT>0
<DD>multibyte character at<B> s1</B> identical to multibyte character at<B> s2</B>
<DT>&gt; 0
<DD>multibyte character at<B> s1</B> greater than multibyte character at<B> s2</B>
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_mbccmp">_mbccmp</A>, <A HREF="#_mbccpy">_mbccpy</A>, <A HREF="#_mbcjistojms">_mbcjistojms</A>, <A HREF="#_mbcjmstojis">_mbcjmstojis</A>,
<A HREF="#_mbclen">_mbclen</A>, <A HREF="#_mbctohira">_mbctohira</A>, <A HREF="#_mbctokata">_mbctokata</A>, <A HREF="#_mbctolower">_mbctolower</A>,
<A HREF="#_mbctombb">_mbctombb</A>, <A HREF="#_mbctoupper">_mbctoupper</A>, <A HREF="#mblen">mblen</A>, <A HREF="#mbrlen">mbrlen</A>,
<A HREF="#mbrtowc">mbrtowc</A>, <A HREF="#mbsrtowcs">mbsrtowcs</A>, <A HREF="#mbsrtowcs_s">mbsrtowcs_s</A>, <A HREF="#mbstowcs">mbstowcs</A>,
<A HREF="#mbstowcs_s">mbstowcs_s</A>, <A HREF="#mbtowc">mbtowc</A>, <A HREF="#btowc">btowc</A>, <A HREF="#wcrtomb">wcrtomb</A>,
<A HREF="#wcrtomb_s">wcrtomb_s</A>, <A HREF="#wcsrtombs">wcsrtombs</A>, <A HREF="#wcsrtombs_s">wcsrtombs_s</A>, <A HREF="#wcstombs">wcstombs</A>,
<A HREF="#wcstombs_s">wcstombs_s</A>, <A HREF="#wctob">wctob</A>, <A HREF="#wctomb">wctomb</A>, <A HREF="#wctomb_s">wctomb_s</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><BR><TT>unsigned char mb1[2] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x41, 0x42</TT>
<BR><TT>};</TT>
<BR><BR><TT>unsigned char mb2[2] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x61, 0x43</TT>
<BR><TT>};</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; i = _mbcicmp( mb1, mb2 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( i &lt; 0 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Less than\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; else if( i == 0 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Equal to\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Greater than\n&quot; );</TT>
<BR><BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>Equal to</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> _mbcicmp - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
<BR><BR><TT>_fmbcicmp - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="_mbcjistojms"> _mbcjistojms </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>unsigned int _mbcjistojms( unsigned int ch );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _mbcjistojms</TT> converts a JIS character set code to a shift-JIS character set code.&nbsp; If the argument is out
of range,<TT> _mbcjistojms</TT> returns 0.&nbsp; Valid JIS double-byte characters are those in which the first and second
byte fall in the range 0x21 through 0x7E.&nbsp; This is summarized in the following diagram.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ 1st byte ]&nbsp;&nbsp;&nbsp; [ 2nd byte ]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x21-0x7E&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x21-0x7E</TT>
<BR><BR><B>Note:</B>&nbsp; The JIS character set code is a double-byte character set defined by JIS, the Japan Industrial
Standard Institutes.&nbsp; Shift-JIS is another double-byte character set.&nbsp; It is defined by Microsoft for personal computers
and is based on the JIS code.&nbsp; The first byte and the second byte of JIS codes can have values less than 0x80.&nbsp;
Microsoft has designed shift-JIS code so that it can be mixed in strings with single-byte alphanumeric codes.&nbsp; Thus the
double-byte shift-JIS codes are greater than or equal to 0x8140.
<BR><BR><B>Note:</B>&nbsp; This function was called <TT> jistojms</TT> in earlier versions.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _mbcjistojms</TT> function returns zero if the argument is not in the range; otherwise, the corresponding shift-JIS
code is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getmbcp">_getmbcp</A>, <A HREF="#_mbbtombc">_mbbtombc</A>, <A HREF="#_mbcjmstojis">_mbcjmstojis</A>, <A HREF="#_mbctombb">_mbctombb</A>,
<A HREF="#_ismbbalnum">_ismbbalnum</A>, <A HREF="#_ismbbalpha">_ismbbalpha</A>, <A HREF="#_ismbbgraph">_ismbbgraph</A>, <A HREF="#_ismbbkalnum">_ismbbkalnum</A>,
<A HREF="#_ismbbkalpha">_ismbbkalpha</A>, <A HREF="#_ismbbkana">_ismbbkana</A>, <A HREF="#_ismbbkprint">_ismbbkprint</A>,
<A HREF="#_ismbbkpunct">_ismbbkpunct</A>, <A HREF="#_ismbblead">_ismbblead</A>, <A HREF="#_ismbbprint">_ismbbprint</A>, <A HREF="#_ismbbpunct">_ismbbpunct</A>,
<A HREF="#_ismbbtrail">_ismbbtrail</A>, <A HREF="#_mbbtombc">_mbbtombc</A>, <A HREF="#_mbcjmstojis">_mbcjmstojis</A>, <A HREF="#_mbctombb">_mbctombb</A>,
<A HREF="#_mbbtype">_mbbtype</A>, <A HREF="#_setmbcp">_setmbcp</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned short c;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; c = _mbcjistojms( 0x2152 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x\n&quot;, c );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>0x8171</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS
</DL>
<H2 ID="_mbcjmstojis"> _mbcjmstojis </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>unsigned int _mbcjmstojis( unsigned int ch );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _mbcjmstojis</TT> converts a shift-JIS character set code to a JIS character set code.&nbsp; If the argument is out
of range,<TT> _mbcjmstojis</TT> returns 0.&nbsp; Valid shift-JIS double-byte characters are those in which the first byte
falls in the range 0x81 through 0x9F or 0xE0 through 0xFC and whose second byte falls in the range 0x40 through 0x7E or 0x80
through 0xFC.&nbsp; This is summarized in the following diagram.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ 1st byte ]&nbsp;&nbsp;&nbsp; [ 2nd byte ]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x81-0x9F&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x40-0xFC</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; except 0x7F</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xE0-0xFC</TT>
<BR><BR><B>Note:</B>&nbsp; The JIS character set code is a double-byte character set defined by JIS, the Japan Industrial
Standard Institutes.&nbsp; Shift-JIS is another double-byte character set.&nbsp; It is defined by Microsoft for personal computers
and is based on the JIS code.&nbsp; The first byte and the second byte of JIS codes can have values less than 0x80.&nbsp;
Microsoft has designed shift-JIS code so that it can be mixed in strings with single-byte alphanumeric codes.&nbsp; Thus the
double-byte shift-JIS codes are greater than or equal to 0x8140.
<BR><BR><B>Note:</B>&nbsp; This function was called <TT> jmstojis</TT> in earlier versions.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _mbcjmstojis</TT> function returns zero if the argument is not in the range; otherwise, the corresponding shift-JIS
code is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getmbcp">_getmbcp</A>, <A HREF="#_mbbtombc">_mbbtombc</A>, <A HREF="#_mbcjistojms">_mbcjistojms</A>, <A HREF="#_mbctombb">_mbctombb</A>,
<A HREF="#_ismbbalnum">_ismbbalnum</A>, <A HREF="#_ismbbalpha">_ismbbalpha</A>, <A HREF="#_ismbbgraph">_ismbbgraph</A>, <A HREF="#_ismbbkalnum">_ismbbkalnum</A>,
<A HREF="#_ismbbkalpha">_ismbbkalpha</A>, <A HREF="#_ismbbkana">_ismbbkana</A>, <A HREF="#_ismbbkprint">_ismbbkprint</A>,
<A HREF="#_ismbbkpunct">_ismbbkpunct</A>, <A HREF="#_ismbblead">_ismbblead</A>, <A HREF="#_ismbbprint">_ismbbprint</A>, <A HREF="#_ismbbpunct">_ismbbpunct</A>,
<A HREF="#_ismbbtrail">_ismbbtrail</A>, <A HREF="#_mbbtombc">_mbbtombc</A>, <A HREF="#_mbcjistojms">_mbcjistojms</A>, <A HREF="#_mbctombb">_mbctombb</A>,
<A HREF="#_mbbtype">_mbbtype</A>, <A HREF="#_setmbcp">_setmbcp</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned short c;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; c = _mbcjmstojis( 0x8171 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x\n&quot;, c );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>0x2152</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS
</DL>
<H2 ID="_mbclen"> _mbclen, _fmbclen </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>size_t _mbclen( const unsigned char *ch );</TT>
<BR><TT>size_t far _fmbclen( const unsigned char __far *ch );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _mbclen</TT> function determines the number of bytes comprising the multibyte character pointed to by<B> ch</B>.
<BR><BR>The<TT> _fmbclen</TT> function is a data model independent form of the _mbclen function that accepts far pointer arguments.
&nbsp;It is most useful in mixed memory model applications.
</DL>
<DL>
<DT>Returns:
<DD>If<B> ch</B> is a NULL pointer, the<TT> _mbclen</TT> function returns zero if multibyte character encodings do not have state-dependent
encoding, and non-zero otherwise.&nbsp; If<B> ch</B> is not a NULL pointer, the<TT> _mbclen</TT> function returns:
<DL>
<DT>Value&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>0
<DD>if<B> ch</B> points to the null character
<DT>1
<DD>if<B> ch</B> points to a single-byte character
<DT>2
<DD>if<B> ch</B> points to a double-byte character
<DT>-1
<DD>if<B> ch</B> does not point to a valid multibyte character
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_mbccmp">_mbccmp</A>, <A HREF="#_mbccpy">_mbccpy</A>, <A HREF="#_mbcicmp">_mbcicmp</A>, <A HREF="#_mbcjistojms">_mbcjistojms</A>,
<A HREF="#_mbcjmstojis">_mbcjmstojis</A>, <A HREF="#_mbctohira">_mbctohira</A>, <A HREF="#_mbctokata">_mbctokata</A>, <A HREF="#_mbctolower">_mbctolower</A>,
<A HREF="#_mbctombb">_mbctombb</A>, <A HREF="#_mbctoupper">_mbctoupper</A>, <A HREF="#mblen">mblen</A>, <A HREF="#mbrlen">mbrlen</A>,
<A HREF="#mbrtowc">mbrtowc</A>, <A HREF="#mbsrtowcs">mbsrtowcs</A>, <A HREF="#mbsrtowcs_s">mbsrtowcs_s</A>, <A HREF="#mbstowcs">mbstowcs</A>,
<A HREF="#mbstowcs_s">mbstowcs_s</A>, <A HREF="#mbtowc">mbtowc</A>, <A HREF="#btowc">btowc</A>, <A HREF="#wcrtomb">wcrtomb</A>,
<A HREF="#wcrtomb_s">wcrtomb_s</A>, <A HREF="#wcsrtombs">wcsrtombs</A>, <A HREF="#wcsrtombs_s">wcsrtombs_s</A>, <A HREF="#wcstombs">wcstombs</A>,
<A HREF="#wcstombs_s">wcstombs_s</A>, <A HREF="#wctob">wctob</A>, <A HREF="#wctomb">wctomb</A>, <A HREF="#wctomb_s">wctomb_s</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><BR><TT>unsigned char chars[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ' ',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '.',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '1',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'A',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x81,0x40, /* double-byte space */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x82,0x60, /* double-byte A */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x82,0xA6, /* double-byte Hiragana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x83,0x42, /* double-byte Katakana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana punctuation */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA6,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xDF,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xE0,0xA1, /* double-byte Kanji */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* null character */</TT>
<BR><TT>};</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; i, j;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; sizeof(chars); i += j ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j = _mbclen( &amp;chars[i] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%d bytes in character\n&quot;, j );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>1 bytes in character</TT>
<BR><TT>1 bytes in character</TT>
<BR><TT>1 bytes in character</TT>
<BR><TT>1 bytes in character</TT>
<BR><TT>2 bytes in character</TT>
<BR><TT>2 bytes in character</TT>
<BR><TT>2 bytes in character</TT>
<BR><TT>2 bytes in character</TT>
<BR><TT>1 bytes in character</TT>
<BR><TT>1 bytes in character</TT>
<BR><TT>1 bytes in character</TT>
<BR><TT>2 bytes in character</TT>
<BR><TT>1 bytes in character</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> _mbclen - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, Linux, RDOS</TT>
<BR><BR><TT>_fmbclen - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="_mbctolower"> _mbctolower </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>unsigned int _mbctolower( unsigned int c );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _mbctolower</TT> function converts an uppercase multibyte character to an equivalent lowercase multibyte character.
<BR><BR>For example, in code page 932, this includes the single-byte uppercase letters A-Z and the double-byte uppercase characters
such that:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0x8260 &lt;= c &lt;= 0x8279</TT>
<BR><BR><B>Note:</B>&nbsp; This function was called <TT> jtolower</TT> in earlier versions.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _mbctolower</TT> function returns the argument value if the argument is not a double-byte uppercase character; otherwise,
the equivalent lowercase character is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_mbccmp">_mbccmp</A>, <A HREF="#_mbccpy">_mbccpy</A>, <A HREF="#_mbcicmp">_mbcicmp</A>, <A HREF="#_mbcjistojms">_mbcjistojms</A>,
<A HREF="#_mbcjmstojis">_mbcjmstojis</A>, <A HREF="#_mbclen">_mbclen</A>, <A HREF="#_mbctohira">_mbctohira</A>, <A HREF="#_mbctokata">_mbctokata</A>,
<A HREF="#_mbctombb">_mbctombb</A>, <A HREF="#_mbctoupper">_mbctoupper</A>, <A HREF="#mblen">mblen</A>, <A HREF="#mbrlen">mbrlen</A>,
<A HREF="#mbrtowc">mbrtowc</A>, <A HREF="#mbsrtowcs">mbsrtowcs</A>, <A HREF="#mbsrtowcs_s">mbsrtowcs_s</A>, <A HREF="#mbstowcs">mbstowcs</A>,
<A HREF="#mbstowcs_s">mbstowcs_s</A>, <A HREF="#mbtowc">mbtowc</A>, <A HREF="#btowc">btowc</A>, <A HREF="#wcrtomb">wcrtomb</A>,
<A HREF="#wcrtomb_s">wcrtomb_s</A>, <A HREF="#wcsrtombs">wcsrtombs</A>, <A HREF="#wcsrtombs_s">wcsrtombs_s</A>, <A HREF="#wcstombs">wcstombs</A>,
<A HREF="#wcstombs_s">wcstombs_s</A>, <A HREF="#wctob">wctob</A>, <A HREF="#wctomb">wctomb</A>, <A HREF="#wctomb_s">wctomb_s</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><BR><TT>unsigned int chars[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'A',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte A */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'B',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte B */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'C',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte C */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'D',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte D */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'E',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte E */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8260,&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte A */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8261,&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte B */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8262,&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte C */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8263,&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte D */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8264&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte E */</TT>
<BR><TT>};</TT>
<BR><BR><TT>#define SIZE sizeof( chars ) / sizeof( unsigned int )</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned int c;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c = _mbctolower( chars[ i ] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( c &gt; 0xff )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%c%c&quot;, c&gt;&gt;8, c );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%c&quot;, c );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;\n&quot; );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>abcde a b c d e</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS
</DL>
<H2 ID="_mbctoupper"> _mbctoupper </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>unsigned int _mbctoupper( unsigned int c );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _mbctoupper</TT> function converts a lowercase multibyte character to an equivalent uppercase multibyte character.
<BR><BR>For example, in code page 932, this includes the single-byte lowercase letters a-z and the double-byte lowercase characters
such that:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0x8281 &lt;= c &lt;= 0x829A</TT>
<BR><BR><B>Note:</B>&nbsp; This function was called <TT> jtoupper</TT> in earlier versions.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _mbctoupper</TT> function returns the argument value if the argument is not a double-byte lowercase character; otherwise,
the equivalent uppercase character is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_mbccmp">_mbccmp</A>, <A HREF="#_mbccpy">_mbccpy</A>, <A HREF="#_mbcicmp">_mbcicmp</A>, <A HREF="#_mbcjistojms">_mbcjistojms</A>,
<A HREF="#_mbcjmstojis">_mbcjmstojis</A>, <A HREF="#_mbclen">_mbclen</A>, <A HREF="#_mbctohira">_mbctohira</A>, <A HREF="#_mbctokata">_mbctokata</A>,
<A HREF="#_mbctolower">_mbctolower</A>, <A HREF="#_mbctombb">_mbctombb</A>, <A HREF="#mblen">mblen</A>, <A HREF="#mbrlen">mbrlen</A>,
<A HREF="#mbrtowc">mbrtowc</A>, <A HREF="#mbsrtowcs">mbsrtowcs</A>, <A HREF="#mbsrtowcs_s">mbsrtowcs_s</A>, <A HREF="#mbstowcs">mbstowcs</A>,
<A HREF="#mbstowcs_s">mbstowcs_s</A>, <A HREF="#mbtowc">mbtowc</A>, <A HREF="#btowc">btowc</A>, <A HREF="#wcrtomb">wcrtomb</A>,
<A HREF="#wcrtomb_s">wcrtomb_s</A>, <A HREF="#wcsrtombs">wcsrtombs</A>, <A HREF="#wcsrtombs_s">wcsrtombs_s</A>, <A HREF="#wcstombs">wcstombs</A>,
<A HREF="#wcstombs_s">wcstombs_s</A>, <A HREF="#wctob">wctob</A>, <A HREF="#wctomb">wctomb</A>, <A HREF="#wctomb_s">wctomb_s</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><BR><TT>unsigned int chars[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'a',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte a */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'b',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte b */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'c',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte c */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'd',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte d */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'e',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte e */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8281,&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte a */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8282,&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte b */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8283,&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte c */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8284,&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte d */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8285&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte e */</TT>
<BR><TT>};</TT>
<BR><BR><TT>#define SIZE sizeof( chars ) / sizeof( unsigned int )</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned int c;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c = _mbctoupper( chars[ i ] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( c &gt; 0xff )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%c%c&quot;, c&gt;&gt;8, c );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%c&quot;, c );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;\n&quot; );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>ABCDE A B C D E</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS
</DL>
<H2 ID="_mbctohira"> _mbctohira </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>unsigned int _mbctohira( unsigned int ch );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _mbctohira</TT> converts a double-byte Katakana character to a Hiragana character.&nbsp; A double-byte Katakana character
is any character for which the following expression is true:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0x8340 &lt;= ch &lt;= 0x8396&nbsp; &amp;&amp;&nbsp; ch != 0x837F</TT>
<BR><BR>Any Katakana character whose value is less than 0x8393 is converted to Hiragana (there are 3 extra Katakana characters
that have no equivalent).
<BR><BR><B>Note:</B>&nbsp; The Japanese double-byte character set includes Kanji, Hiragana, and Katakana characters - both
alphabetic and numeric.&nbsp; Kanji is the ideogram character set of the Japanese character set.&nbsp; Hiragana and Katakana
are two types of phonetic character sets of the Japanese character set.&nbsp; The Hiragana code set includes 83 characters
and the Katakana code set includes 86 characters.
<BR><BR><B>Note:</B>&nbsp; This function was called <TT> jtohira</TT> in earlier versions.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _mbctohira</TT> function returns the argument value if the argument is not a double-byte Katakana character; otherwise,
the equivalent Hiragana character is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_mbccmp">_mbccmp</A>, <A HREF="#_mbccpy">_mbccpy</A>, <A HREF="#_mbcicmp">_mbcicmp</A>, <A HREF="#_mbcjistojms">_mbcjistojms</A>,
<A HREF="#_mbcjmstojis">_mbcjmstojis</A>, <A HREF="#_mbclen">_mbclen</A>, <A HREF="#_mbctokata">_mbctokata</A>, <A HREF="#_mbctolower">_mbctolower</A>,
<A HREF="#_mbctombb">_mbctombb</A>, <A HREF="#_mbctoupper">_mbctoupper</A>, <A HREF="#mblen">mblen</A>, <A HREF="#mbrlen">mbrlen</A>,
<A HREF="#mbrtowc">mbrtowc</A>, <A HREF="#mbsrtowcs">mbsrtowcs</A>, <A HREF="#mbsrtowcs_s">mbsrtowcs_s</A>, <A HREF="#mbstowcs">mbstowcs</A>,
<A HREF="#mbstowcs_s">mbstowcs_s</A>, <A HREF="#mbtowc">mbtowc</A>, <A HREF="#btowc">btowc</A>, <A HREF="#wcrtomb">wcrtomb</A>,
<A HREF="#wcrtomb_s">wcrtomb_s</A>, <A HREF="#wcsrtombs">wcsrtombs</A>, <A HREF="#wcsrtombs_s">wcsrtombs_s</A>, <A HREF="#wcstombs">wcstombs</A>,
<A HREF="#wcstombs_s">wcstombs_s</A>, <A HREF="#wctob">wctob</A>, <A HREF="#wctomb">wctomb</A>, <A HREF="#wctomb_s">wctomb_s</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><BR><TT>unsigned int chars[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8340,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8364,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x8396</TT>
<BR><TT>};</TT>
<BR><BR><TT>#define SIZE sizeof( chars ) / sizeof( unsigned int )</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x - %#6.4x\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars[ i ],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _mbctohira( chars[ i ] ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>0x8340 - 0x829f</TT>
<BR><TT>0x8364 - 0x82c3</TT>
<BR><TT>0x8396 - 0x8396</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS
</DL>
<H2 ID="_mbctokata"> _mbctokata </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>unsigned int _mbctokata( unsigned int ch );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _mbctokata</TT> converts a double-byte Hiragana character to a Katakana character.&nbsp; A double-byte Hiragana character
is any character for which the following expression is true:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0x829F &lt;= c &lt;= 0x82F1</TT>
<BR><BR><B>Note:</B>&nbsp; The Japanese double-byte character set includes Kanji, Hiragana, and Katakana characters - both
alphabetic and numeric.&nbsp; Kanji is the ideogram character set of the Japanese character set.&nbsp; Hiragana and Katakana
are two types of phonetic character sets of the Japanese character set.&nbsp; The Hiragana code set includes 83 characters
and the Katakana code set includes 86 characters.
<BR><BR><B>Note:</B>&nbsp; This function was called <TT> jtokata</TT> in earlier versions.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _mbctokata</TT> function returns the argument value if the argument is not a double-byte Hiragana character; otherwise,
the equivalent Katakana character is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_mbccmp">_mbccmp</A>, <A HREF="#_mbccpy">_mbccpy</A>, <A HREF="#_mbcicmp">_mbcicmp</A>, <A HREF="#_mbcjistojms">_mbcjistojms</A>,
<A HREF="#_mbcjmstojis">_mbcjmstojis</A>, <A HREF="#_mbclen">_mbclen</A>, <A HREF="#_mbctohira">_mbctohira</A>, <A HREF="#_mbctolower">_mbctolower</A>,
<A HREF="#_mbctombb">_mbctombb</A>, <A HREF="#_mbctoupper">_mbctoupper</A>, <A HREF="#mblen">mblen</A>, <A HREF="#mbrlen">mbrlen</A>,
<A HREF="#mbrtowc">mbrtowc</A>, <A HREF="#mbsrtowcs">mbsrtowcs</A>, <A HREF="#mbsrtowcs_s">mbsrtowcs_s</A>, <A HREF="#mbstowcs">mbstowcs</A>,
<A HREF="#mbstowcs_s">mbstowcs_s</A>, <A HREF="#mbtowc">mbtowc</A>, <A HREF="#btowc">btowc</A>, <A HREF="#wcrtomb">wcrtomb</A>,
<A HREF="#wcrtomb_s">wcrtomb_s</A>, <A HREF="#wcsrtombs">wcsrtombs</A>, <A HREF="#wcsrtombs_s">wcsrtombs_s</A>, <A HREF="#wcstombs">wcstombs</A>,
<A HREF="#wcstombs_s">wcstombs_s</A>, <A HREF="#wctob">wctob</A>, <A HREF="#wctomb">wctomb</A>, <A HREF="#wctomb_s">wctomb_s</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><BR><TT>unsigned int chars[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x829F,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x82B0,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x82F1</TT>
<BR><TT>};</TT>
<BR><BR><TT>#define SIZE sizeof( chars ) / sizeof( unsigned int )</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x - %#6.4x\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars[ i ],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _mbctokata( chars[ i ] ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>0x829f - 0x8340</TT>
<BR><TT>0x82b0 - 0x8351</TT>
<BR><TT>0x82f1 - 0x8393</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS
</DL>
<H2 ID="_mbctombb"> _mbctombb </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>unsigned int _mbctombb( unsigned int ch );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _mbctombb</TT> function returns the single-byte character equivalent to the double-byte character<B> ch</B>.&nbsp;
The single-byte character will be in the range 0x20 through 0x7E or 0xA1 through 0xDF.
<BR><BR><B>Note:</B>&nbsp; This function was called <TT> zentohan</TT> in earlier versions.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _mbctombb</TT> function returns<B> ch</B> if there is no equivalent single-byte character; otherwise<TT> _mbctombb</TT>
returns a single-byte character.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getmbcp">_getmbcp</A>, <A HREF="#_mbbtombc">_mbbtombc</A>, <A HREF="#_mbcjistojms">_mbcjistojms</A>, <A HREF="#_mbcjmstojis">_mbcjmstojis</A>,
<A HREF="#_ismbbalnum">_ismbbalnum</A>, <A HREF="#_ismbbalpha">_ismbbalpha</A>, <A HREF="#_ismbbgraph">_ismbbgraph</A>, <A HREF="#_ismbbkalnum">_ismbbkalnum</A>,
<A HREF="#_ismbbkalpha">_ismbbkalpha</A>, <A HREF="#_ismbbkana">_ismbbkana</A>, <A HREF="#_ismbbkprint">_ismbbkprint</A>,
<A HREF="#_ismbbkpunct">_ismbbkpunct</A>, <A HREF="#_ismbblead">_ismbblead</A>, <A HREF="#_ismbbprint">_ismbbprint</A>, <A HREF="#_ismbbpunct">_ismbbpunct</A>,
<A HREF="#_ismbbtrail">_ismbbtrail</A>, <A HREF="#_mbbtombc">_mbbtombc</A>, <A HREF="#_mbcjistojms">_mbcjistojms</A>, <A HREF="#_mbcjmstojis">_mbcjmstojis</A>,
<A HREF="#_mbbtype">_mbbtype</A>, <A HREF="#_setmbcp">_setmbcp</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><BR><TT>#define ZEN(x) 130*256+(x-1+32)</TT>
<BR><BR><TT>unsigned int alphabet[26] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ZEN('A'),ZEN('B'),ZEN('C'),ZEN('D'),ZEN('E'),</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ZEN('F'),ZEN('G'),ZEN('H'),ZEN('I'),ZEN('J'),</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ZEN('K'),ZEN('L'),ZEN('M'),ZEN('N'),ZEN('O'),</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ZEN('P'),ZEN('Q'),ZEN('R'),ZEN('S'),ZEN('T'),</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ZEN('U'),ZEN('V'),ZEN('W'),ZEN('X'),ZEN('Y'),</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ZEN('Z')</TT>
<BR><TT>};</TT>
<BR><BR><TT>#define SIZE sizeof( alphabet ) / sizeof( unsigned int )</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned int&nbsp;&nbsp;&nbsp; c;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c = _mbctombb( alphabet[ i ] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%c&quot;, c );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;\n&quot; );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>ABCDEFGHIJKLMNOPQRSTUVWXYZ</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS
</DL>
<H2 ID="_mbgetcode"> _mbgetcode, _fmbgetcode </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>unsigned char *_mbgetcode( unsigned char *mbstr,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int *dbchp );</TT>
<BR><TT>unsigned char far *_fmbgetcode( unsigned char far *mbstr,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int *dbchp );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _mbgetcode</TT> function places the next single- or double-byte character from the start of the Kanji string specified
by<B> mbstr</B> in the wide character pointed to by<B> dbchp</B>.&nbsp; If the second-half of a double-byte character is NULL,
then the returned wide character is NULL.
<BR><BR>The<TT> _fmbgetcode</TT> function is a code and data model independent form of the<TT> _mbgetcode</TT> function.&nbsp;
It accepts far pointer arguments and returns a far pointer.&nbsp; It is most useful in mixed memory model applications.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _mbgetcode</TT> function returns a pointer to the next character to be obtained from the string.&nbsp; If<B> mbstr</B>
points at a null character then<B> mbstr</B> is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_mbsnccnt">_mbsnccnt</A>, <A HREF="#_mbputchar">_mbputchar</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><BR><TT>unsigned char set[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; &quot;ab\x81\x41\x81\x42\cd\x81&quot;</TT>
<BR><TT>};</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned int c;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned char *str;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; str = set;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( ; *str != '\0'; ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; str = _mbgetcode( str, &amp;c );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Character code 0x%2.2x\n&quot;, c );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>Character code 0x61</TT>
<BR><TT>Character code 0x62</TT>
<BR><TT>Character code 0x8141</TT>
<BR><TT>Character code 0x8142</TT>
<BR><TT>Character code 0x63</TT>
<BR><TT>Character code 0x64</TT>
<BR><TT>Character code 0x00</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> _mbgetcode - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
<BR><BR><TT>_fmbgetcode - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="mblen"> mblen, _fmblen </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; or</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>int mblen( const char *s, size_t n );</TT>
<BR><TT>int _fmblen( const char __far *s, size_t n );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> mblen</TT> function determines the number of bytes comprising the multibyte character pointed to by<B> s</B>.&nbsp;
At most<B> n</B> bytes of the array pointed to by<B> s</B> will be examined.
<BR><BR>The<TT> _fmblen</TT> function is a data model independent form of the mblen function.&nbsp; It accepts far pointer
arguments and returns a far pointer.&nbsp; It is most useful in mixed memory model applications.
</DL>
<DL>
<DT>Returns:
<DD>If<B> s</B> is a NULL pointer, the<TT> mblen</TT> function returns zero if multibyte character encodings are not state dependent,
and non-zero otherwise.&nbsp; If<B> s</B> is not a NULL pointer, the<TT> mblen</TT> function returns:
<DL>
<DT>Value&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>0
<DD>if<B> s</B> points to the null character
<DT>len
<DD>the number of bytes that comprise the multibyte character (if the next<B> n</B> or fewer bytes form a valid multibyte character)
<DT>-1
<DD>if the next<B> n</B> bytes do not form a valid multibyte character
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_mbccmp">_mbccmp</A>, <A HREF="#_mbccpy">_mbccpy</A>, <A HREF="#_mbcicmp">_mbcicmp</A>, <A HREF="#_mbcjistojms">_mbcjistojms</A>,
<A HREF="#_mbcjmstojis">_mbcjmstojis</A>, <A HREF="#_mbclen">_mbclen</A>, <A HREF="#_mbctohira">_mbctohira</A>, <A HREF="#_mbctokata">_mbctokata</A>,
<A HREF="#_mbctolower">_mbctolower</A>, <A HREF="#_mbctombb">_mbctombb</A>, <A HREF="#_mbctoupper">_mbctoupper</A>, <A HREF="#mbrlen">mbrlen</A>,
<A HREF="#mbrtowc">mbrtowc</A>, <A HREF="#mbsrtowcs">mbsrtowcs</A>, <A HREF="#mbsrtowcs_s">mbsrtowcs_s</A>, <A HREF="#mbstowcs">mbstowcs</A>,
<A HREF="#mbstowcs_s">mbstowcs_s</A>, <A HREF="#mbtowc">mbtowc</A>, <A HREF="#btowc">btowc</A>, <A HREF="#wcrtomb">wcrtomb</A>,
<A HREF="#wcrtomb_s">wcrtomb_s</A>, <A HREF="#wcsrtombs">wcsrtombs</A>, <A HREF="#wcsrtombs_s">wcsrtombs_s</A>, <A HREF="#wcstombs">wcstombs</A>,
<A HREF="#wcstombs_s">wcstombs_s</A>, <A HREF="#wctob">wctob</A>, <A HREF="#wctomb">wctomb</A>, <A HREF="#wctomb_s">wctomb_s</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><BR><TT>const char chars[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ' ',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '.',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '1',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'A',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x81,0x40, /* double-byte space */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x82,0x60, /* double-byte A */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x82,0xA6, /* double-byte Hiragana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x83,0x42, /* double-byte Katakana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana punctuation */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA6,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xDF,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xE0,0xA1, /* double-byte Kanji */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x00</TT>
<BR><TT>};</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i, j, k;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Character encodings are %sstate dependent\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( mblen( NULL, MB_CUR_MAX ) ) ? &quot;&quot; :
&quot;not &quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; j = 1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; j &gt; 0; i += j ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j = mblen( &amp;chars[i], MB_CUR_MAX );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%d bytes in character &quot;, j );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( j == 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if ( j == 1 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = chars[i];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if( j == 2 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = chars[i]&lt;&lt;8 | chars[i+1];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;(%#6.4x)\n&quot;, k );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>Character encodings are not state dependent</TT>
<BR><TT>1 bytes in character (0x0020)</TT>
<BR><TT>1 bytes in character (0x002e)</TT>
<BR><TT>1 bytes in character (0x0031)</TT>
<BR><TT>1 bytes in character (0x0041)</TT>
<BR><TT>2 bytes in character (0x8140)</TT>
<BR><TT>2 bytes in character (0x8260)</TT>
<BR><TT>2 bytes in character (0x82a6)</TT>
<BR><TT>2 bytes in character (0x8342)</TT>
<BR><TT>1 bytes in character (0x00a1)</TT>
<BR><TT>1 bytes in character (0x00a6)</TT>
<BR><TT>1 bytes in character (0x00df)</TT>
<BR><TT>2 bytes in character (0xe0a1)</TT>
<BR><TT>0 bytes in character (&nbsp; 0000)</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>_fmblen is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> mblen - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_fmblen - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="_mbputchar"> _mbputchar, _fmbputchar </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>unsigned char *_mbputchar( unsigned char *mbstr,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int dbch );</TT>
<BR><TT>unsigned char far *_fmbputchar( unsigned char far *mbstr,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int dbch );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _mbputchar</TT> function places the next single- or double-byte character specified by<B> dbch</B> at the start of
the buffer specified by<B> mbstr</B>.
<BR><BR>The<TT> _fmbputchar</TT> function is a code and data model independent form of the<TT> _mbputchar</TT> function.&nbsp;
It accepts far pointer arguments and returns a far pointer.&nbsp; It is most useful in mixed memory model applications.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _mbputchar</TT> function returns a pointer to the next location in which to store a character.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_mbsnccnt">_mbsnccnt</A>, <A HREF="#_mbgetcode">_mbgetcode</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned int c;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned char *str1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned char *str2;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned char buf[30];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; str1 = &quot;ab\x82\x62\x82\x63\ef\x81\x66&quot;;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; str2 = buf;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; for( ; *str1 != '\0'; ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; str1 = _mbgetcode( str1, &amp;c );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; str2 = _mbputchar( str2, '&lt;' );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; str2 = _mbputchar( str2, c );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; str2 = _mbputchar( str2, '&gt;' );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; *str2 = '\0';</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, buf );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>&lt;a&gt;&lt;b&gt;&lt; C&gt;&lt; D&gt;&lt;e&gt;&lt;f&gt;&lt; G&gt;</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> _mbputchar - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
<BR><BR><TT>_fmbputchar - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="mbrlen"> mbrlen, _fmbrlen </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>int mbrlen( const char *s, size_t n, mbstate_t *ps );</TT>
<BR><TT>int _fmbrlen( const char far *s, size_t n, mbstate_t far *ps );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> mbrlen</TT> function determines the number of bytes comprising the multibyte character pointed to by<B> s</B>.&nbsp;
The<TT> mbrlen</TT> function is equivalent to the following call:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; mbrtowc((wchar_t *)0, s, n, ps != 0 ? ps : &amp;internal)</TT>
<BR><BR>where<TT> &amp;internal</TT> is the address of the internal <TT> mbstate_t</TT> object for the<TT> mbrlen</TT> function.
<BR><BR>The<TT> _fmbrlen</TT> function is a data model independent form of the mbrlen function that accepts far pointer arguments.
&nbsp;It is most useful in mixed memory model applications.
<BR><BR>The restartable multibyte/wide character conversion functions differ from the corresponding internal-state multibyte
character functions ( <TT> mblen</TT>, <TT> mbtowc</TT>, and <TT> wctomb</TT>) in that they have an extra argument,<B> ps</B>,
of type pointer to <TT> mbstate_t</TT> that points to an object that can completely describe the current conversion state
of the associated multibyte character sequence.&nbsp; If<B> ps</B> is a null pointer, each function uses its own internal
<TT> mbstate_t</TT> object instead.&nbsp; You are guaranteed that no other function in the library calls these functions with
a null pointer for<B> ps</B>, thereby ensuring the stability of the state.
<BR><BR>Also unlike their corresponding functions, the return value does not represent whether the encoding is state-dependent.
<BR><BR>If the encoding is state-dependent, on entry each function takes the described conversion state (either internal or
pointed to by<B> ps</B>) as current.&nbsp; The conversion state described by the pointed-to object is altered as needed to
track the shift state of the associated multibyte character sequence.&nbsp; For encodings without state dependency, the pointer
to the <TT> mbstate_t</TT> argument is ignored.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> mbrlen</TT> function returns a value between -2 and<B> n</B>, inclusive.&nbsp; The<TT> mbrlen</TT> function returns
the first of the following that applies:
<DL>
<DT>Value&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>0
<DD>if the next<B> n</B> or fewer bytes form the multibyte character that corresponds to the null wide character.
<DT>&gt;0
<DD>if the next<B> n</B> or fewer bytes form a valid multibyte character; the value returned is the number of bytes that constitute
that multibyte character.
<DT>-2
<DD>if the next<B> n</B> bytes form an incomplete (but potentially valid) multibyte character, and all<B> n</B> bytes have been
processed; it is unspecified whether this can occur when the value of<B> n</B> is less than that of the <TT> MB_CUR_MAX</TT>
macro.
<DT>-1
<DD>if an encoding error occurs (when the next<B> n</B> or fewer bytes do not form a complete and valid multibyte character);
the value of the macro <TT> EILSEQ</TT> will be stored in <TT> errno</TT>, but the conversion state will be unchanged.
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_mbccmp">_mbccmp</A>, <A HREF="#_mbccpy">_mbccpy</A>, <A HREF="#_mbcicmp">_mbcicmp</A>, <A HREF="#_mbcjistojms">_mbcjistojms</A>,
<A HREF="#_mbcjmstojis">_mbcjmstojis</A>, <A HREF="#_mbclen">_mbclen</A>, <A HREF="#_mbctohira">_mbctohira</A>, <A HREF="#_mbctokata">_mbctokata</A>,
<A HREF="#_mbctolower">_mbctolower</A>, <A HREF="#_mbctombb">_mbctombb</A>, <A HREF="#_mbctoupper">_mbctoupper</A>, <A HREF="#mblen">mblen</A>,
<A HREF="#mbrtowc">mbrtowc</A>, <A HREF="#mbsrtowcs">mbsrtowcs</A>, <A HREF="#mbsrtowcs_s">mbsrtowcs_s</A>, <A HREF="#mbstowcs">mbstowcs</A>,
<A HREF="#mbstowcs_s">mbstowcs_s</A>, <A HREF="#mbtowc">mbtowc</A>, <A HREF="#btowc">btowc</A>, <A HREF="#wcrtomb">wcrtomb</A>,
<A HREF="#wcrtomb_s">wcrtomb_s</A>, <A HREF="#wcsrtombs">wcsrtombs</A>, <A HREF="#wcsrtombs_s">wcsrtombs_s</A>, <A HREF="#wcstombs">wcstombs</A>,
<A HREF="#wcstombs_s">wcstombs_s</A>, <A HREF="#wctob">wctob</A>, <A HREF="#wctomb">wctomb</A>, <A HREF="#wctomb_s">wctomb_s</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><TT>#include &lt;errno.h&gt;</TT>
<BR><BR><TT>const char chars[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ' ',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '.',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '1',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'A',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x81,0x40, /* double-byte space */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x82,0x60, /* double-byte A */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x82,0xA6, /* double-byte Hiragana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x83,0x42, /* double-byte Katakana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana punctuation */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA6,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xDF,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xE0,0xA1, /* double-byte Kanji */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x00</TT>
<BR><TT>};</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i, j, k;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; j = 1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; j &gt; 0; i += j ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j = mbrlen( &amp;chars[i], MB_CUR_MAX, NULL );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%d bytes in character &quot;, j );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( errno == EILSEQ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot; - illegal multibyte character\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( j == 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if ( j == 1 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = chars[i];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if( j == 2 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = chars[i]&lt;&lt;8 | chars[i+1];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;(%#6.4x)\n&quot;, k );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>1 bytes in character (0x0020)</TT>
<BR><TT>1 bytes in character (0x002e)</TT>
<BR><TT>1 bytes in character (0x0031)</TT>
<BR><TT>1 bytes in character (0x0041)</TT>
<BR><TT>2 bytes in character (0x8140)</TT>
<BR><TT>2 bytes in character (0x8260)</TT>
<BR><TT>2 bytes in character (0x82a6)</TT>
<BR><TT>2 bytes in character (0x8342)</TT>
<BR><TT>1 bytes in character (0x00a1)</TT>
<BR><TT>1 bytes in character (0x00a6)</TT>
<BR><TT>1 bytes in character (0x00df)</TT>
<BR><TT>2 bytes in character (0xe0a1)</TT>
<BR><TT>0 bytes in character (&nbsp; 0000)</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C95
<BR><BR>_fmbrlen is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> mbrlen - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, Linux, RDOS</TT>
<BR><BR><TT>_fmbrlen - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="mbrtowc"> mbrtowc, _fmbrtowc </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>int mbrtowc( wchar_t *pwc, const char *s,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t n, mbstate_t *ps );</TT>
<BR><TT>int _fmbrtowc( wchar_t __far *pwc, const char __far *s,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t n, mbstate_t __far *ps
);</TT>
</DL>
<DL>
<DT>Description:
<DD>If<B> s</B> is a null pointer, the<TT> mbrtowc</TT> function determines the number of bytes necessary to enter the initial
shift state (zero if encodings are not state-dependent or if the initial conversion state is described).&nbsp; In this case,
the value of the<B> pwc</B> argument will be ignored, and the resulting state described will be the initial conversion state.
<BR><BR>If<B> s</B> is not a null pointer, the<TT> mbrtowc</TT> function determines the number of bytes that are contained
in the multibyte character (plus any leading shift sequences) pointed to by<B> s</B>, produces the value of the corresponding
wide character and then, if<B> pwc</B> is not a null pointer, stores that value in the object pointed to by<B> pwc</B>.&nbsp;
If the corresponding wide character is the null wide character, the resulting state described will be the initial conversion
state.
<BR><BR>The function is a data model independent form of the mbrtowc function that accepts far pointer arguments.&nbsp; It
is most useful in mixed memory model applications.
<BR><BR>The restartable multibyte/wide character conversion functions differ from the corresponding internal-state multibyte
character functions ( <TT> mblen</TT>, <TT> mbtowc</TT>, and <TT> wctomb</TT>) in that they have an extra argument,<B> ps</B>,
of type pointer to <TT> mbstate_t</TT> that points to an object that can completely describe the current conversion state
of the associated multibyte character sequence.&nbsp; If<B> ps</B> is a null pointer, each function uses its own internal
<TT> mbstate_t</TT> object instead.&nbsp; You are guaranteed that no other function in the library calls these functions with
a null pointer for<B> ps</B>, thereby ensuring the stability of the state.
<BR><BR>Also unlike their corresponding functions, the return value does not represent whether the encoding is state-dependent.
<BR><BR>If the encoding is state-dependent, on entry each function takes the described conversion state (either internal or
pointed to by<B> ps</B>) as current.&nbsp; The conversion state described by the pointed-to object is altered as needed to
track the shift state of the associated multibyte character sequence.&nbsp; For encodings without state dependency, the pointer
to the <TT> mbstate_t</TT> argument is ignored.
</DL>
<DL>
<DT>Returns:
<DD>If<B> s</B> is a null pointer, the<TT> mbrtowc</TT> function returns the number of bytes necessary to enter the initial shift
state.&nbsp; The value returned will not be greater than that of the <TT> MB_CUR_MAX</TT> macro.
<BR><BR>If<B> s</B> is not a null pointer, the<TT> mbrtowc</TT> function returns the first of the following that applies:
<DL>
<DT>Value&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>0
<DD>if the next<B> n</B> or fewer bytes form the multibyte character that corresponds to the null wide character.
<DT>&gt;0
<DD>if the next<B> n</B> or fewer bytes form a valid multibyte character; the value returned is the number of bytes that constitute
that multibyte character.
<DT>-2
<DD>if the next<B> n</B> bytes form an incomplete (but potentially valid) multibyte character, and all<B> n</B> bytes have been
processed; it is unspecified whether this can occur when the value of<B> n</B> is less than that of the <TT> MB_CUR_MAX</TT>
macro.
<DT>-1
<DD>if an encoding error occurs (when the next<B> n</B> or fewer bytes do not form a complete and valid multibyte character);
the value of the macro <TT> EILSEQ</TT> will be stored in <TT> errno</TT>, but the conversion state will be unchanged.
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_mbccmp">_mbccmp</A>, <A HREF="#_mbccpy">_mbccpy</A>, <A HREF="#_mbcicmp">_mbcicmp</A>, <A HREF="#_mbcjistojms">_mbcjistojms</A>,
<A HREF="#_mbcjmstojis">_mbcjmstojis</A>, <A HREF="#_mbclen">_mbclen</A>, <A HREF="#_mbctohira">_mbctohira</A>, <A HREF="#_mbctokata">_mbctokata</A>,
<A HREF="#_mbctolower">_mbctolower</A>, <A HREF="#_mbctombb">_mbctombb</A>, <A HREF="#_mbctoupper">_mbctoupper</A>, <A HREF="#mblen">mblen</A>,
<A HREF="#mbrlen">mbrlen</A>, <A HREF="#mbsrtowcs">mbsrtowcs</A>, <A HREF="#mbsrtowcs_s">mbsrtowcs_s</A>, <A HREF="#mbstowcs">mbstowcs</A>,
<A HREF="#mbstowcs_s">mbstowcs_s</A>, <A HREF="#mbtowc">mbtowc</A>, <A HREF="#btowc">btowc</A>, <A HREF="#wcrtomb">wcrtomb</A>,
<A HREF="#wcrtomb_s">wcrtomb_s</A>, <A HREF="#wcsrtombs">wcsrtombs</A>, <A HREF="#wcsrtombs_s">wcsrtombs_s</A>, <A HREF="#wcstombs">wcstombs</A>,
<A HREF="#wcstombs_s">wcstombs_s</A>, <A HREF="#wctob">wctob</A>, <A HREF="#wctomb">wctomb</A>, <A HREF="#wctomb_s">wctomb_s</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><TT>#include &lt;errno.h&gt;</TT>
<BR><BR><TT>const char chars[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ' ',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '.',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '1',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'A',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x81,0x40, /* double-byte space */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x82,0x60, /* double-byte A */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x82,0xA6, /* double-byte Hiragana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x83,0x42, /* double-byte Katakana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana punctuation */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA6,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xDF,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xE0,0xA1, /* double-byte Kanji */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x00</TT>
<BR><TT>};</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i, j, k;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; wchar_t&nbsp;&nbsp;&nbsp;&nbsp; pwc;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; i = mbrtowc( NULL, NULL, MB_CUR_MAX, NULL );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Number of bytes to enter &quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;initial shift state = %d\n&quot;, i );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; j = 1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; j &gt; 0; i += j ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j = mbrtowc( &amp;pwc, &amp;chars[i], MB_CUR_MAX, NULL );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%d bytes in character &quot;, j );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( errno == EILSEQ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot; - illegal multibyte character\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( j == 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if ( j == 1 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = chars[i];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if( j == 2 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = chars[i]&lt;&lt;8 | chars[i+1];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;(%#6.4x-&gt;%#6.4x)\n&quot;, k, pwc );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>Number of bytes to enter initial shift state = 0</TT>
<BR><TT>1 bytes in character (0x0020-&gt;0x0020)</TT>
<BR><TT>1 bytes in character (0x002e-&gt;0x002e)</TT>
<BR><TT>1 bytes in character (0x0031-&gt;0x0031)</TT>
<BR><TT>1 bytes in character (0x0041-&gt;0x0041)</TT>
<BR><TT>2 bytes in character (0x8140-&gt;0x3000)</TT>
<BR><TT>2 bytes in character (0x8260-&gt;0xff21)</TT>
<BR><TT>2 bytes in character (0x82a6-&gt;0x3048)</TT>
<BR><TT>2 bytes in character (0x8342-&gt;0x30a3)</TT>
<BR><TT>1 bytes in character (0x00a1-&gt;0xff61)</TT>
<BR><TT>1 bytes in character (0x00a6-&gt;0xff66)</TT>
<BR><TT>1 bytes in character (0x00df-&gt;0xff9f)</TT>
<BR><TT>2 bytes in character (0xe0a1-&gt;0x720d)</TT>
<BR><TT>0 bytes in character (&nbsp; 0000-&gt;&nbsp; 0000)</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C95
<BR><BR>_fmbrtowc is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> mbrtowc - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, Linux, RDOS</TT>
<BR><BR><TT>_fmbrtowc - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="_mbsbtype"> _mbsbtype, _fmbsbtype </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt; (for manifest constants)</TT>
<BR><TT>int _mbsbtype( const unsigned char *mbstr, int count );</TT>
<BR><TT>int _fmbsbtype( const unsigned char __far *mbstr,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int count );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _mbsbtype</TT> function determines the type of a byte in a multibyte character string.&nbsp; The function examines
only the byte at offset<B> count</B> in<B> mbstr</B>, ignoring invalid characters before the specified byte
<BR><BR><B>Note:</B>&nbsp; A similar function was called <TT> nthctype</TT> in earlier versions.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _mbsbtype</TT> function returns one of the following values:
<DL>
<DT>_MBC_SINGLE
<DD>the character is a valid single-byte character (e.g., 0x20 - 0x7E, 0xA1 - 0xDF in code page 932)
<DT>_MBC_LEAD
<DD>the character is a valid lead byte character (e.g., 0x81 - 0x9F, 0xE0 - 0xFC in code page 932)
<DT>_MBC_TRAIL
<DD>the character is a valid trailing byte character (e.g., 0x40 - 0x7E, 0x80 - 0xFC in code page 932)
<DT>_MBC_ILLEGAL
<DD>the character is an illegal character (e.g., any value except 0x20 - 0x7E, 0xA1 - 0xDF, 0x81 - 0x9F, 0xE0 - 0xFC in code page
932)
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getmbcp">_getmbcp</A>, <A HREF="#_ismbcalnum">_ismbcalnum</A>, <A HREF="#_ismbcalpha">_ismbcalpha</A>, <A HREF="#_ismbccntrl">_ismbccntrl</A>,
<A HREF="#_ismbcdigit">_ismbcdigit</A>, <A HREF="#_ismbcgraph">_ismbcgraph</A>, <A HREF="#_ismbchira">_ismbchira</A>, <A HREF="#_ismbckata">_ismbckata</A>,
<A HREF="#_ismbcl0">_ismbcl0</A>, <A HREF="#_ismbcl1">_ismbcl1</A>, <A HREF="#_ismbcl2">_ismbcl2</A>, <A HREF="#_ismbclegal">_ismbclegal</A>,
<A HREF="#_ismbclower">_ismbclower</A>, <A HREF="#_ismbcprint">_ismbcprint</A>, <A HREF="#_ismbcpunct">_ismbcpunct</A>, <A HREF="#_ismbcspace">_ismbcspace</A>,
<A HREF="#_ismbcsymbol">_ismbcsymbol</A>, <A HREF="#_ismbcupper">_ismbcupper</A>, <A HREF="#_ismbcxdigit">_ismbcxdigit</A>,
<A HREF="#_mbbtype">_mbbtype</A>, <A HREF="#_setmbcp">_setmbcp</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><BR><TT>const char *types[4] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; &quot;ILLEGAL&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; &quot;SINGLE&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; &quot;LEAD&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; &quot;TRAIL&quot;</TT>
<BR><TT>};</TT>
<BR><BR><TT>const unsigned char chars[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ' ',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '.',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '1',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'A',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x81,0x40, /* double-byte space */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x82,0x60, /* double-byte A */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x82,0xA6, /* double-byte Hiragana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x83,0x42, /* double-byte Katakana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana punctuation */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA6,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xDF,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xE0,0xA1, /* double-byte Kanji */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x00</TT>
<BR><TT>};</TT>
<BR><BR><TT>#define SIZE sizeof( chars ) / sizeof( unsigned char )</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, types[ 1+_mbsbtype( chars, i ) ] );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>SINGLE</TT>
<BR><TT>SINGLE</TT>
<BR><TT>SINGLE</TT>
<BR><TT>SINGLE</TT>
<BR><TT>LEAD</TT>
<BR><TT>TRAIL</TT>
<BR><TT>LEAD</TT>
<BR><TT>TRAIL</TT>
<BR><TT>LEAD</TT>
<BR><TT>TRAIL</TT>
<BR><TT>LEAD</TT>
<BR><TT>TRAIL</TT>
<BR><TT>SINGLE</TT>
<BR><TT>SINGLE</TT>
<BR><TT>SINGLE</TT>
<BR><TT>LEAD</TT>
<BR><TT>TRAIL</TT>
<BR><TT>ILLEGAL</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> _mbsbtype - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
<BR><BR><TT>_fmbsbtype - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="_mbsnbcat"> _mbsnbcat, _fmbsnbcat </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>unsigned char *_mbsnbcat( unsigned char *dst,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const unsigned char *src,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t n );</TT>
<BR><TT>unsigned char __far *_fmbsnbcat( unsigned char __far *dst,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char __far *src,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; size_t n );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _mbsnbcat</TT> function appends not more than<B> n</B> bytes of the string pointed to by<B> src</B> to the end of
the string pointed to by<B> dst</B>.&nbsp; If the byte immediately preceding the null character in<B> dst</B> is a lead byte,
the initial byte of<B> src</B> overwrites this lead byte.&nbsp; Otherwise, the initial byte of<B> src</B> overwrites the terminating
null character at the end of<B> dst</B>.&nbsp; If the last byte to be copied from<B> src</B> is a lead byte, the lead byte
is not copied and a null character replaces it in<B> dst</B>.&nbsp; In any case, a terminating null character is always appended
to the result.
<BR><BR>The<TT> _fmbsnbcat</TT> function is a data model independent form of the _mbsnbcat function.&nbsp; It accepts far
pointer arguments and returns a far pointer.&nbsp; It is most useful in mixed memory model applications.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _mbsnbcat</TT> function returns the value of<B> dst</B>.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_mbsnbcmp">_mbsnbcmp</A>, <A HREF="#_mbsnbcpy">_mbsnbcpy</A>, <A HREF="#_mbsnbset">_mbsnbset</A>, <A HREF="#_mbsnccnt">_mbsnccnt</A>,
<A HREF="#strncat">strncat</A>, <A HREF="#strcat">strcat</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><BR><TT>const unsigned char str1[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x81,0x40, /* double-byte space */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x82,0x60, /* double-byte A */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x00</TT>
<BR><TT>};</TT>
<BR><BR><TT>const unsigned char str2[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x81,0x40, /* double-byte space */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x82,0xA6, /* double-byte Hiragana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x83,0x42, /* double-byte Katakana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x00</TT>
<BR><TT>};</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned char&nbsp;&nbsp; big_string[10];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; memset( (char *) big_string, 0xee, 10 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; big_string[9] = 0x00;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Length of string = %d\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strlen( (char *) big_string ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; 10; i++ )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%2.2x &quot;, big_string[i] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;\n&quot; );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _mbsnset( big_string, 0x8145, 5 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; 10; i++ )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%2.2x &quot;, big_string[i] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;\n&quot; );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; big_string[0] = 0x00;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _mbsnbcat( big_string, str1, 3 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; 10; i++ )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%2.2x &quot;, big_string[i] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;\n&quot; );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; big_string[2] = 0x84;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; big_string[3] = 0x00;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; 10; i++ )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%2.2x &quot;, big_string[i] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;\n&quot; );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _mbsnbcat( big_string, str2, 5 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; 10; i++ )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%2.2x &quot;, big_string[i] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;\n&quot; );</TT>
<BR><BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>Length of string = 9</TT>
<BR><TT>ee ee ee ee ee ee ee ee ee 00</TT>
<BR><TT>81 45 81 45 81 45 81 45 20 00</TT>
<BR><TT>81 40 00 00 81 45 81 45 20 00</TT>
<BR><TT>81 40 84 00 81 45 81 45 20 00</TT>
<BR><TT>81 40 81 40 82 a6 00 00 20 00</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> _mbsnbcat - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
<BR><BR><TT>_fmbsnbcat - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="_mbsnbcmp"> _mbsnbcmp, _fmbsnbcmp </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>int _mbsnbcmp( const unsigned char *s1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char *s2,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t n );</TT>
<BR><TT>int _fmbsnbcmp( const unsigned char __far *s1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char __far
*s2,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t n );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _mbsnbcmp</TT> lexicographically compares not more than<B> n</B> bytes from the string pointed to by<B> s1</B> to
the string pointed to by<B> s2</B>.
<BR><BR>The<TT> _fmbsnbcmp</TT> function is a data model independent form of the _mbsnbcmp function that accepts far pointer
arguments.&nbsp; It is most useful in mixed memory model applications.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _mbsnbcmp</TT> function returns an integer less than, equal to, or greater than zero, indicating that the string pointed
to by<B> s1</B> is less than, equal to, or greater than the string pointed to by<B> s2</B>.<TT>&nbsp; _mbsnbcmp</TT> is similar
to <TT> _mbsncmp</TT>, except that<TT> _mbsnbcmp</TT> compares strings by bytes rather than by characters.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_mbsnbcat">_mbsnbcat</A>, <A HREF="#_mbsnbicmp">_mbsnbicmp</A>, <A HREF="#strncmp">strncmp</A>, <A HREF="#strnicmp">strnicmp</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><BR><TT>const unsigned char str1[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x81,0x40, /* double-byte space */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x82,0x60, /* double-byte A */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x00</TT>
<BR><TT>};</TT>
<BR><BR><TT>const unsigned char str2[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x81,0x40, /* double-byte space */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x82,0xA6, /* double-byte Hiragana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x83,0x42, /* double-byte Katakana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x00</TT>
<BR><TT>};</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, _mbsnbcmp( str1, str2, 3 ) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>0</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> _mbsnbcmp - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
<BR><BR><TT>_fmbsnbcmp - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="_mbsnbcnt"> _mbsnbcnt, _fmbsnbcnt, _strncnt, _wcsncnt </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>size_t _mbsnbcnt( const unsigned char *string, size_t n );</TT>
<BR><TT>size_t _fmbsnbcnt( const unsigned char __far *string,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t
n );</TT>
<BR><TT>#include &lt;tchar.h&gt;</TT>
<BR><TT>size_t _strncnt( const char *string, size_t n );</TT>
<BR><TT>size_t _wcsncnt( const wchar_t *string, size_t n ) {</TT>
</DL>
<DL>
<DT>Description:
<DD>The function counts the number of bytes in the first<B> n</B> multibyte characters of the string<B> string</B>.
<BR><BR><B>Note:</B>&nbsp; This function was called <TT> mtob</TT> in earlier versions.
<BR><BR>The function is a data model independent form of the _mbsnbcnt function that accepts far pointer arguments.&nbsp;
It is most useful in mixed memory model applications.
<BR><BR>The header file<TT> &lt;tchar.h&gt;</TT> defines the generic-text routine <TT> _tcsnbcnt</TT>.&nbsp; This macro maps
to if <TT> _MBCS</TT> has been defined, or to the<TT> _wcsncnt</TT> macro if <TT> _UNICODE</TT> has been defined.&nbsp; Otherwise
<TT> _tcsnbcnt</TT> maps to _mbsnbcnt.<TT>&nbsp; _mbsnbcnt</TT> and<TT> _wcsncnt</TT> are single-byte character string and
wide-character string versions of .&nbsp; The<TT> _mbsnbcnt</TT> and<TT> _wcsncnt</TT> macros are provided only for this mapping
and should not be used otherwise.
<BR><BR>The<TT> _mbsnbcnt</TT> function returns the number of characters (i.e.,<B> n</B>) in the first<B> n</B> bytes of the
single-byte string<B> string</B>.&nbsp; The<TT> _wcsncnt</TT> function returns the number of bytes (i.e., 2 *<B> n</B>) in
the first<B> n</B> wide characters of the wide-character string<B> string</B>.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _mbsnbcnt</TT> functions return the number of bytes in the string up to the specified number of characters or until
a null character is encountered.&nbsp; The null character is not included in the count.&nbsp; If the character preceding the
null character was a lead byte, the lead byte is not included in the count.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_mbsnbcat">_mbsnbcat</A>, <A HREF="#_mbsnccnt">_mbsnccnt</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><BR><TT>const unsigned char chars[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ' ',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '.',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '1',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'A',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x81,0x40, /* double-byte space */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x82,0x60, /* double-byte A */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x82,0xA6, /* double-byte Hiragana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x83,0x42, /* double-byte Katakana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana punctuation */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA6,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xDF,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xE0,0xA1, /* double-byte Kanji */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x00</TT>
<BR><TT>};</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%d bytes found\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _mbsnbcnt( chars, 10 ) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>14 bytes found</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> _mbsnbcnt - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
<BR><BR><TT>_fmbsnbcnt - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
<BR><TT>_strncnt - MACRO</TT>
<BR><TT>_wcsncnt - MACRO</TT>
</DL>
<H2 ID="_mbsnbcpy"> _mbsnbcpy, _fmbsnbcpy </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>unsigned char *_mbsnbcpy( unsigned char *dst,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const unsigned char *src,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
size_t n );</TT>
<BR><TT>unsigned char __far *_fmbsnbcpy( unsigned char __far *dst,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char __far *src,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t n );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _mbsnbcpy</TT> function copies no more than<B> n</B> bytes from the string pointed to by<B> src</B> into the array
pointed to by<B> dst</B>.&nbsp; Copying of overlapping objects is not guaranteed to work properly.
<BR><BR>If the string pointed to by<B> src</B> is shorter than<B> n</B> bytes, null characters are appended to the copy in
the array pointed to by<B> dst</B>, until<B> n</B> bytes in all have been written.&nbsp; If the string pointed to by<B> src</B>
is longer than<B> n</B> characters, then the result will not be terminated by a null character.
<BR><BR>The<TT> _fmbsnbcpy</TT> function is a data model independent form of the _mbsnbcpy function.&nbsp; It accepts far
pointer arguments and returns a far pointer.&nbsp; It is most useful in mixed memory model applications.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _mbsnbcpy</TT> function returns the value of<B> dst</B>.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#strcpy">strcpy</A>, <A HREF="#strdup">strdup</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><BR><TT>const unsigned char chars[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ' ',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '.',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '1',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'A',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x81,0x40, /* double-byte space */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x82,0x60, /* double-byte A */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x82,0xA6, /* double-byte Hiragana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x83,0x42, /* double-byte Katakana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana punctuation */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA6,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xDF,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xE0,0xA1, /* double-byte Kanji */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x00</TT>
<BR><TT>};</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned char&nbsp;&nbsp; chars2[20];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _mbsnset( chars2, 0xFF, 20 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _mbsnbcpy( chars2, chars, 11 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; 20; i++ )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%2.2x &quot;, chars2[i] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _mbsnbcpy( chars2, chars, 20 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; 20; i++ )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%2.2x &quot;, chars2[i] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;\n&quot; );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>20 2e 31 41 81 40 82 60 82 a6 83 ff ff ff ff ff ff ff ff ff</TT>
<BR><TT>20 2e 31 41 81 40 82 60 82 a6 83 42 a1 a6 df e0 a1 00 00 00</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> _mbsnbcpy - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
<BR><BR><TT>_fmbsnbcpy - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="_mbsnbicmp"> _mbsnbicmp, _fmbsnbicmp </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>int _mbsnbicmp( const unsigned char *s1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char *s2,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t n );</TT>
<BR><TT>int _fmbsnbicmp( const unsigned char __far *s1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char __far
*s2,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t n );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _mbsnbicmp</TT> lexicographically compares not more than<B> n</B> bytes from the string pointed to by<B> s1</B> to
the string pointed to by<B> s2</B>.&nbsp; The comparison is insensitive to case.
<BR><BR>The<TT> _fmbsnbicmp</TT> function is a data model independent form of the _mbsnbicmp function that accepts far pointer
arguments.&nbsp; It is most useful in mixed memory model applications.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _mbsnbicmp</TT> function returns an integer less than, equal to, or greater than zero, indicating that the string
pointed to by<B> s1</B> is less than, equal to, or greater than the string pointed to by<B> s2</B>.<TT>&nbsp; _mbsnbicmp</TT>
is similar to <TT> _mbsncmp</TT>, except that<TT> _mbsnbicmp</TT> compares strings by bytes rather than by characters.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_mbsnbcat">_mbsnbcat</A>, <A HREF="#_mbsnbcmp">_mbsnbcmp</A>, <A HREF="#strncmp">strncmp</A>, <A HREF="#strnicmp">strnicmp</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><BR><TT>const unsigned char str1[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x81,0x40, /* double-byte space */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x82,0x60, /* double-byte A */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x82,0x79, /* double-byte Z */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x00</TT>
<BR><TT>};</TT>
<BR><BR><TT>const unsigned char str2[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x81,0x40, /* double-byte space */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x82,0x81, /* double-byte a */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x82,0x9a, /* double-byte z */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x00</TT>
<BR><TT>};</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, _mbsnbicmp( str1, str2, 5 ) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>0</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> _mbsnbicmp - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
<BR><BR><TT>_fmbsnbicmp - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="_mbsnbset"> _mbsnbset, _fmbsnbset </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>unsigned char *_mbsnbset( unsigned char *str,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int fill,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t count );</TT>
<BR><TT>unsigned char __far *_fmbsnbset( unsigned char __far *str,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int fill,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t count );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _mbsnbset</TT> function fills the string<B> str</B> with the value of the argument<B> fill</B>.&nbsp; When the value
of<B> len</B> is greater than the length of the string, the entire string is filled.&nbsp; Otherwise, that number of characters
at the start of the string are set to the fill character.
<BR><BR><TT>_mbsnbset</TT> is similar to <TT> _mbsnset</TT>, except that it fills in<B> count</B> bytes rather than<B> count</B>
characters.&nbsp; If the number of bytes to be filled is odd and<B> fill</B> is a double-byte character, the partial byte
at the end is filled with an ASCII space character.
<BR><BR>The<TT> _fmbsnbset</TT> function is a data model independent form of the _mbsnbset function.&nbsp; It accepts far
pointer arguments and returns a far pointer.&nbsp; It is most useful in mixed memory model applications.
</DL>
<DL>
<DT>Returns:
<DD>The address of the original string<B> str</B> is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#strnset">strnset</A>, <A HREF="#strset">strset</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned char&nbsp;&nbsp; big_string[10];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; memset( (char *) big_string, 0xee, 10 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; big_string[9] = 0x00;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; 10; i++ )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%2.2x &quot;, big_string[i] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _mbsnbset( big_string, 0x8145, 5 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; 10; i++ )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%2.2x &quot;, big_string[i] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;\n&quot; );</TT>
<BR><BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>ee ee ee ee ee ee ee ee ee 00</TT>
<BR><TT>81 45 81 45 20 ee ee ee ee 00</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> _mbsnbset - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
<BR><BR><TT>_fmbsnbset - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="_mbsnccnt"> _mbsnccnt, _fmbsnccnt, _strncnt, _wcsncnt </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>size_t _mbsnccnt( const unsigned char *string, size_t n );</TT>
<BR><TT>size_t _fmbsnccnt( const unsigned char __far *string,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t
n );</TT>
<BR><TT>#include &lt;tchar.h&gt;</TT>
<BR><TT>size_t _strncnt( const char *string, size_t n );</TT>
<BR><TT>size_t _wcsncnt( const wchar_t *string, size_t n ) {</TT>
</DL>
<DL>
<DT>Description:
<DD>The function counts the number of multibyte characters in the first<B> n</B> bytes of the string<B> string</B>.&nbsp; If finds
a null byte as the second byte of a double-byte character, the first (lead) byte is not included in the count.
<BR><BR><B>Note:</B>&nbsp; This function was called <TT> btom</TT> in earlier versions.
<BR><BR>The function is a data model independent form of the _mbsnccnt function that accepts far pointer arguments.&nbsp;
It is most useful in mixed memory model applications.
<BR><BR>The header file<TT> &lt;tchar.h&gt;</TT> defines the generic-text routine <TT> _tcsnccnt</TT>.&nbsp; This macro maps
to if <TT> _MBCS</TT> has been defined, or to the<TT> _wcsncnt</TT> macro if <TT> _UNICODE</TT> has been defined.&nbsp; Otherwise
<TT> _tcsnccnt</TT> maps to _mbsnccnt.<TT>&nbsp; _mbsnccnt</TT> and<TT> _wcsncnt</TT> are single-byte character string and
wide-character string versions of .&nbsp; The<TT> _mbsnccnt</TT> and<TT> _wcsncnt</TT> macros are provided only for this mapping
and should not be used otherwise.
<BR><BR>The<TT> _mbsnccnt</TT> function returns the number of characters (i.e.,<B> n</B>) in the first<B> n</B> bytes of the
single-byte string<B> string</B>.&nbsp; The<TT> _wcsncnt</TT> function returns the number of bytes (i.e., 2 *<B> n</B>) in
the first<B> n</B> wide characters of the wide-character string<B> string</B>.
</DL>
<DL>
<DT>Returns:
<DD><TT> _mbsnccnt</TT> returns the number of characters from the beginning of the string to byte<B> n</B>.<TT>&nbsp; _wcsncnt</TT>
returns the number of wide characters from the beginning of the string to byte<B> n</B>.&nbsp; returns the number of multibyte
characters from the beginning of the string to byte<B> n</B>.&nbsp; If these functions find a null character before byte<B>
n</B>, they return the number of characters before the null character.&nbsp; If the string consists of fewer than<B> n</B>
characters, these functions return the number of characters in the string.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_mbsnbcat">_mbsnbcat</A>, <A HREF="#_mbsnbcnt">_mbsnbcnt</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><BR><TT>const unsigned char chars[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ' ',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '.',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '1',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'A',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x81,0x40, /* double-byte space */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x82,0x60, /* double-byte A */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x82,0xA6, /* double-byte Hiragana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x83,0x42, /* double-byte Katakana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana punctuation */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA6,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xDF,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xE0,0xA1, /* double-byte Kanji */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x00</TT>
<BR><TT>};</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%d characters found\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _mbsnccnt( chars, 10 ) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>7 characters found</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> _mbsnccnt - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
<BR><BR><TT>_fmbsnccnt - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
<BR><TT>_strncnt - MACRO</TT>
<BR><TT>_wcsncnt - MACRO</TT>
</DL>
<H2 ID="_mbsnextc"> _mbsnextc, _fmbsnextc, _strnextc, _wcsnextc </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>unsigned int _mbsnextc( const unsigned char *string );</TT>
<BR><TT>unsigned int _fmbsnextc(</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const unsigned char __far *string );</TT>
<BR><TT>#include &lt;tchar.h&gt;</TT>
<BR><TT>unsigned int _strnextc( const char *string );</TT>
<BR><TT>unsigned int _wcsnextc( const wchar_t *string ) {</TT>
</DL>
<DL>
<DT>Description:
<DD>The function returns the integer value of the next multibyte-character in<B> string</B>, without advancing the string pointer.
&nbsp;recognizes multibyte character sequences according to the multibyte code page currently in use.
<BR><BR>The header file<TT> &lt;tchar.h&gt;</TT> defines the generic-text routine <TT> _tcsnextc</TT>.&nbsp; This macro maps
to if <TT> _MBCS</TT> has been defined, or to<TT> _wcsnextc</TT> if <TT> _UNICODE</TT> has been defined.&nbsp; Otherwise <TT>
_tcsnextc</TT> maps to _mbsnextc.<TT>&nbsp; _mbsnextc</TT> and<TT> _wcsnextc</TT> are single-byte character string and wide-character
string versions of .<TT>&nbsp; _mbsnextc</TT> and<TT> _wcsnextc</TT> are provided only for this mapping and should not be
used otherwise.<TT>&nbsp; _mbsnextc</TT> returns the integer value of the next single-byte character in the string.<TT>&nbsp;
_wcsnextc</TT> returns the integer value of the next wide character in the string.
</DL>
<DL>
<DT>Returns:
<DD>These functions return the integer value of the next character (single-byte, wide, or multibyte) pointed to by<B> string</B>.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_strdec">_strdec</A>, <A HREF="#_strinc">_strinc</A>, <A HREF="#_strninc">_strninc</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><BR><TT>const unsigned char chars[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ' ',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '.',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '1',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'A',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x81,0x40, /* double-byte space */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x82,0x60, /* double-byte A */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x82,0xA6, /* double-byte Hiragana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x83,0x42, /* double-byte Katakana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana punctuation */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA6,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xDF,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xE0,0xA1, /* double-byte Kanji */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x00</TT>
<BR><TT>};</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x\n&quot;, _mbsnextc( &amp;chars[2] ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x\n&quot;, _mbsnextc( &amp;chars[4] ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x\n&quot;, _mbsnextc( &amp;chars[12] ) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>0x0031</TT>
<BR><TT>0x8140</TT>
<BR><TT>0x00a1</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> _mbsnextc - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
<BR><BR><TT>_fmbsnextc - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
<BR><TT>_strnextc - MACRO</TT>
<BR><TT>_wcsnextc - MACRO</TT>
</DL>
<H2 ID="mbsrtowcs"> mbsrtowcs, _fmbsrtowcs </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>size_t mbsrtowcs( wchar_t *dst,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char **src,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t len, mbstate_t *ps );</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>size_t _fmbsrtowcs( wchar_t __far *dst,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char __far * __far *src,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t len, mbstate_t __far *ps );</TT>
</DL>
<DL>
<DT>Safer C:
<DD>The Safer C Library extension provides the <A HREF="#mbsrtowcs_s">mbsrtowcs_s</A> function which is a safer alternative to<TT>
mbsrtowcs</TT> This newer<TT> mbsrtowcs_s</TT> function is recommended to be used instead of the traditional &quot;unsafe&quot;<TT>
mbsrtowcs</TT> function.
</DL>
<DL>
<DT>Description:
<DD>The<TT> mbsrtowcs</TT> function converts a sequence of multibyte characters that begins in the shift state described by<B>
ps</B> from the array indirectly pointed to by<B> src</B> into a sequence of corresponding wide characters, which, if<B> dst</B>
is not a null pointer, are then stored into the array pointed to by<B> dst</B>.&nbsp; Conversion continues up to and including
a terminating null character, but the terminating null wide character will not be stored.&nbsp; Conversion will stop earlier
in two cases:&nbsp; when a sequence of bytes is reached that does not form a valid multibyte character, or (if<B> dst</B>
is not a null pointer) when<B> len</B> codes have been stored into the array pointed to by<B> dst</B>.&nbsp; Each conversion
takes place as if by a call to the <TT> mbrtowc</TT> function.
<BR><BR>If<B> dst</B> is not a null pointer, the pointer object pointed to by<B> src</B> will be assigned either a null pointer
(if conversion stopped due to reaching a terminating null character) or the address just past the last multibyte character
converted.&nbsp; If conversion stopped due to reaching a terminating null character and if<B> dst</B> is not a null pointer,
the resulting state described will be the initial conversion state.
<BR><BR>The<TT> _fmbsrtowcs</TT> function is a data model independent form of the mbsrtowcs function that accepts far pointer
arguments.&nbsp; It is most useful in mixed memory model applications.
<BR><BR>The restartable multibyte/wide string conversion functions differ from the corresponding internal-state multibyte
string functions ( <TT> mbstowcs</TT> and <TT> wcstombs</TT>) in that they have an extra argument,<B> ps</B>, of type pointer
to <TT> mbstate_t</TT> that points to an object that can completely describe the current conversion state of the associated
multibyte character sequence.&nbsp; If<B> ps</B> is a null pointer, each function uses its own internal <TT> mbstate_t</TT>
object instead.&nbsp; You are guaranteed that no other function in the library calls these functions with a null pointer for<B>
ps</B>, thereby ensuring the stability of the state.
<BR><BR>Also unlike their corresponding functions, the conversion source argument,<B> src</B>, has a pointer-to-pointer type.
&nbsp;When the function is storing conversion results (that is, when<B> dst</B> is not a null pointer), the pointer object
pointed to by this argument will be updated to reflect the amount of the source processed by that invocation.
<BR><BR>If the encoding is state-dependent, on entry each function takes the described conversion state (either internal or
pointed to by<B> ps</B>) as current and then, if the destination pointer,<B> dst</B>, is not a null pointer, the conversion
state described by the pointed-to object is altered as needed to track the shift state of the associated multibyte character
sequence.&nbsp; For encodings without state dependency, the pointer to the <TT> mbstate_t</TT> argument is ignored.
</DL>
<DL>
<DT>Returns:
<DD>If the input string does not begin with a valid multibyte character, an encoding error occurs:&nbsp; The<TT> mbsrtowcs</TT>
function stores the value of the macro <TT> EILSEQ</TT> in <TT> errno</TT> and returns<TT> (size_t)-1,</TT> but the conversion
state will be unchanged.&nbsp; Otherwise, it returns the number of multibyte characters successfully converted, which is the
same as the number of array elements modified when<B> dst</B> is not a null pointer.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_mbccmp">_mbccmp</A>, <A HREF="#_mbccpy">_mbccpy</A>, <A HREF="#_mbcicmp">_mbcicmp</A>, <A HREF="#_mbcjistojms">_mbcjistojms</A>,
<A HREF="#_mbcjmstojis">_mbcjmstojis</A>, <A HREF="#_mbclen">_mbclen</A>, <A HREF="#_mbctohira">_mbctohira</A>, <A HREF="#_mbctokata">_mbctokata</A>,
<A HREF="#_mbctolower">_mbctolower</A>, <A HREF="#_mbctombb">_mbctombb</A>, <A HREF="#_mbctoupper">_mbctoupper</A>, <A HREF="#mblen">mblen</A>,
<A HREF="#mbrlen">mbrlen</A>, <A HREF="#mbrtowc">mbrtowc</A>, <A HREF="#mbsrtowcs_s">mbsrtowcs_s</A>, <A HREF="#mbstowcs">mbstowcs</A>,
<A HREF="#mbstowcs_s">mbstowcs_s</A>, <A HREF="#mbtowc">mbtowc</A>, <A HREF="#btowc">btowc</A>, <A HREF="#wcrtomb">wcrtomb</A>,
<A HREF="#wcrtomb_s">wcrtomb_s</A>, <A HREF="#wcsrtombs">wcsrtombs</A>, <A HREF="#wcsrtombs_s">wcsrtombs_s</A>, <A HREF="#wcstombs">wcstombs</A>,
<A HREF="#wcstombs_s">wcstombs_s</A>, <A HREF="#wctob">wctob</A>, <A HREF="#wctomb">wctomb</A>, <A HREF="#wctomb_s">wctomb_s</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><TT>#include &lt;errno.h&gt;</TT>
<BR><BR><TT>const char chars[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ' ',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '.',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '1',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'A',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x81,0x40, /* double-byte space */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x82,0x60, /* double-byte A */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x82,0xA6, /* double-byte Hiragana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x83,0x42, /* double-byte Katakana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana punctuation */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA6,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xDF,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xE0,0xA1, /* double-byte Kanji */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x00</TT>
<BR><TT>};</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; size_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elements;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; const char&nbsp; *src;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; wchar_t&nbsp;&nbsp;&nbsp;&nbsp; wc[50];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; mbstate_t&nbsp;&nbsp; pstate;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; src = chars;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; elements = mbsrtowcs( wc, &amp;src, 50, &amp;pstate );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( errno == EILSEQ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Error in multibyte character string\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; elements; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x\n&quot;, wc[i] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>0x0020</TT>
<BR><TT>0x002e</TT>
<BR><TT>0x0031</TT>
<BR><TT>0x0041</TT>
<BR><TT>0x3000</TT>
<BR><TT>0xff21</TT>
<BR><TT>0x3048</TT>
<BR><TT>0x30a3</TT>
<BR><TT>0xff61</TT>
<BR><TT>0xff66</TT>
<BR><TT>0xff9f</TT>
<BR><TT>0x720d</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C95
<BR><BR>_fmbsrtowcs is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> mbsrtowcs - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, Linux, RDOS</TT>
<BR><BR><TT>_fmbsrtowcs - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="mbsrtowcs_s"> mbsrtowcs_s, _fmbsrtowcs_s </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__&nbsp; 1</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>errno_t mbsrtowcs_s( size_t * restrict retval,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;wchar_t * restrict dst, rsize_t dstmax,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;const char ** restrict src, rsize_t len,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;mbstate_t * restrict ps);</TT>
<BR><TT>errno_t _fmbsrtowcs_s( size_t __far * restrict retval,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; wchar_t __far * restrict dst, rsize_t dstmax,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; const char __far * __far * restrict src, rsize_t len,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; mbstate_t __far * restrict ps);</TT>
</DL>
<DL>
<DT>Constraints:
<DD>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<TT>
mbsrtowcs_s</TT> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<BR><BR>None of<B> retval</B> ,<B> src</B> ,<B> *src</B> , or<B> ps</B> shall be null pointers.&nbsp; If<B> dst</B> is not
a null pointer, then neither<B> len</B> nor<B> dstmax</B> shall be greater than <TT> RSIZE_MAX</TT>.&nbsp; If<B> dst</B> is
a null pointer, then<B> dstmax</B> shall equal zero.&nbsp; If<B> dst</B> is not a null pointer, then<B> dstmax</B> shall not
equal zero.&nbsp; If<B> dst</B> is not a null pointer and<B> len</B> is not less than<B> dstmax</B> ,then a null character
shall occur within the first<B> dstmax</B> multibyte characters of the array pointed to by<B> *src</B>.
<BR><BR>If there is a runtime-constraint violation, then<TT> mbsrtowcs_s</TT> does the following.&nbsp; If<B> retval</B> is
not a null pointer, then<TT> mbsrtowcs_s</TT> sets<B> *retval</B> to (size_t)(-1).&nbsp; If<B> dst</B> is not a null pointer
and<B> dstmax</B> is greater than zero and less than <TT> RSIZE_MAX</TT> , then<TT> mbsrtowcs_s</TT> sets<B> dst[0]</B> to
the null wide character.
</DL>
<DL>
<DT>Description:
<DD>The<TT> mbsrtowcs_s</TT> function converts a sequence of multibyte characters that begins in the conversion state described
by the object pointed to by<B> ps</B>, from the array indirectly pointed to by<B> src</B> into a sequence of corresponding
wide characters.&nbsp; If<B> dst</B> is not a null pointer, the converted characters are stored into the array pointed to
by<B> dst</B>.&nbsp; Conversion continues up to and including a terminating null character, which is also stored.
<BR><BR>Conversion stops earlier in two cases:&nbsp; when a sequence of bytes is encountered that does not form a valid multibyte
character, or (if<B> dst</B> is not a null pointer) when<B> len</B> wide characters have been stored into the array pointed
to by<B> dst</B>.&nbsp; If<B> dst</B> is not a null pointer and no null wide character was stored into the array pointed to
by<B> dst</B>, then<B> dst[len]</B> is set to the null wide character.&nbsp; Each conversion takes place as if by a call to
the <TT> mbrtowc</TT> function.
<BR><BR>If<B> dst</B> is not a null pointer, the pointer object pointed to by<B> src</B> is assigned either a null pointer
(if conversion stopped due to reaching a terminating null character) or the address just past the last multibyte character
converted (if any).&nbsp; If conversion stopped due to reaching a terminating null character and if<B> dst</B> is not a null
pointer, the resulting state described is the initial conversion state.
<BR><BR>Regardless of whether<B> dst</B> is or is not a null pointer, if the input conversion encounters a sequence of bytes
that do not form a valid multibyte character, an encoding error occurs:&nbsp; the<TT> mbsrtowcs_s</TT> function stores the
value (size_t)(-1) into<B> *retval</B> and the conversion state is unspecified.&nbsp; Otherwise, the<TT> mbsrtowcs_s</TT>
function stores into<B> *retval</B> the number of multibyte characters successfully converted, not including the terminating
null character (if any).
<BR><BR>All elements following the terminating null wide character (if any) written by<TT> mbsrtowcs_s</TT> in the array of<B>
dstmax</B> wide characters pointed to by<B> dst</B> take unspecified values when<TT> mbsrtowcs_s</TT> returns.
<BR><BR>If copying takes place between objects that overlap, the objects take on unspecified values.
<BR><BR>The function is a data model independent form of the mbsrtowcs_s function that accepts far pointer arguments.&nbsp;
It is most useful in mixed memory model applications.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> mbsrtowcs_s</TT> function returns zero if there was no runtime-constraint violation.&nbsp; Otherwise, a non-zero value
is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_mbccmp">_mbccmp</A>, <A HREF="#_mbccpy">_mbccpy</A>, <A HREF="#_mbcicmp">_mbcicmp</A>, <A HREF="#_mbcjistojms">_mbcjistojms</A>,
<A HREF="#_mbcjmstojis">_mbcjmstojis</A>, <A HREF="#_mbclen">_mbclen</A>, <A HREF="#_mbctohira">_mbctohira</A>, <A HREF="#_mbctokata">_mbctokata</A>,
<A HREF="#_mbctolower">_mbctolower</A>, <A HREF="#_mbctombb">_mbctombb</A>, <A HREF="#_mbctoupper">_mbctoupper</A>, <A HREF="#mblen">mblen</A>,
<A HREF="#mbrlen">mbrlen</A>, <A HREF="#mbrtowc">mbrtowc</A>, <A HREF="#mbsrtowcs">mbsrtowcs</A>, <A HREF="#mbstowcs">mbstowcs</A>,
<A HREF="#mbstowcs_s">mbstowcs_s</A>, <A HREF="#mbtowc">mbtowc</A>, <A HREF="#btowc">btowc</A>, <A HREF="#wcrtomb">wcrtomb</A>,
<A HREF="#wcrtomb_s">wcrtomb_s</A>, <A HREF="#wcsrtombs">wcsrtombs</A>, <A HREF="#wcsrtombs_s">wcsrtombs_s</A>, <A HREF="#wcstombs">wcstombs</A>,
<A HREF="#wcstombs_s">wcstombs_s</A>, <A HREF="#wctob">wctob</A>, <A HREF="#wctomb">wctomb</A>, <A HREF="#wctomb_s">wctomb_s</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__&nbsp; 1</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><TT>#include &lt;errno.h&gt;</TT>
<BR><BR><TT>const char chars[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ' ',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '.',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '1',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'A',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x81,0x40, /* double-byte space */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x82,0x60, /* double-byte A */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x82,0xA6, /* double-byte Hiragana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x83,0x42, /* double-byte Katakana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana punctuation */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA6,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xDF,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xE0,0xA1, /* double-byte Kanji */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x00</TT>
<BR><TT>};</TT>
<BR><BR><TT>int main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; size_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; retval;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; const char&nbsp; *src;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; wchar_t&nbsp;&nbsp;&nbsp;&nbsp; wc[50];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; mbstate_t&nbsp;&nbsp; pstate;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; errno_t&nbsp;&nbsp;&nbsp;&nbsp; rc;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; src = chars;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; rc = mbsrtowcs( &amp;retval, wc, 50, &amp;src, sizeof(chars), &amp;pstate );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( rc != 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Error in multibyte character string\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; retval; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x\n&quot;, wc[i] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; return( 0 );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>TR 24731
<BR><BR>_fmbsrtowcs_s is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> mbsrtowcs_s - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, Linux, RDOS</TT>
<BR><BR><TT>_fmbsrtowcs_s - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="mbstowcs"> mbstowcs, _fmbstowcs </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>size_t mbstowcs( wchar_t *pwcs, const char *s, size_t n );</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>size_t _fmbstowcs( const wchar_t __far *pwcs,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char
__far *s,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t
n );</TT>
</DL>
<DL>
<DT>Safer C:
<DD>The Safer C Library extension provides the <A HREF="#mbstowcs_s">mbstowcs_s</A> function which is a safer alternative to<TT>
mbstowcs</TT> This newer<TT> mbstowcs_s</TT> function is recommended to be used instead of the traditional &quot;unsafe&quot;<TT>
mbstowcs</TT> function.
</DL>
<DL>
<DT>Description:
<DD>The<TT> mbstowcs</TT> function converts a sequence of multibyte characters pointed to by<B> s</B> into their corresponding
wide character codes and stores not more than<B> n</B> codes into the array pointed to by<B> pwcs</B>.&nbsp; The<TT> mbstowcs</TT>
function does not convert any multibyte characters beyond the null character.&nbsp; At most<B> n</B> elements of the array
pointed to by<B> pwcs</B> will be modified.
<BR><BR>The<TT> _fmbstowcs</TT> function is a data model independent form of the mbstowcs function that accepts far pointer
arguments.&nbsp; It is most useful in mixed memory model applications.
</DL>
<DL>
<DT>Returns:
<DD>If an invalid multibyte character is encountered, the<TT> mbstowcs</TT> function returns<TT> (size_t)-1.</TT>&nbsp; Otherwise,
the<TT> mbstowcs</TT> function returns the number of array elements modified, not including the terminating zero code if present.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#mbstowcs_s">mbstowcs_s</A>, <A HREF="#mblen">mblen</A>, <A HREF="#mbtowc">mbtowc</A>, <A HREF="#wctomb">wctomb</A>,
<A HREF="#wctomb_s">wctomb_s</A>, <A HREF="#wcstombs">wcstombs</A>, <A HREF="#wcstombs_s">wcstombs_s</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; *wc = &quot;string&quot;;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; wchar_t wbuffer[50];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; i, len;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; len = mbstowcs( wbuffer, wc, 50 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( len != -1 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wbuffer[len] = '\0';</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%s(%d)\n&quot;, wc, len );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; len; i++ )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;/%4.4x&quot;, wbuffer[i] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>string(6)</TT>
<BR><TT>/0073/0074/0072/0069/006e/0067</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C95
<BR><BR>_fmbstowcs is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> mbstowcs - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_fmbstowcs - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="mbstowcs_s"> mbstowcs_s, _fmbstowcs_s </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__&nbsp; 1</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>errno_t mbstowcs_s( size_t * restrict retval,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
wchar_t * restrict dst,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
rsize_t dstmax,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const char * restrict src, rsize_t len);</TT>
<BR><TT>errno_t _fmbstowcs_s( size_t __far * restrict retval,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
wchar_t __far * restrict dst,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
rsize_t dstmax,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const char __far * restrict src, rsize_t len);</TT>
</DL>
<DL>
<DT>Constraints:
<DD>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<TT>
mbstowcs_s</TT> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<BR><BR>Neither<B> retval</B> nor<B> src</B> shall be a null pointer.&nbsp; If<B> dst</B> is not a null pointer, then neither<B>
len</B> nor<B> dstmax</B> shall be greater than <TT> RSIZE_MAX</TT>.&nbsp; If<B> dst</B> is a null pointer, then<B> dstmax</B>
shall equal zero.&nbsp; If<B> dst</B> is not a null pointer, then<B> dstmax</B> shall not equal zero.&nbsp; If<B> dst</B>
is not a null pointer and<B> len</B> is not less than<B> dstmax</B>, then a null character shall occur within the first<B>
dstmax</B> multibyte characters of the array pointed to by<B> src</B>.
<BR><BR>If there is a runtime-constraint violation, then<TT> mbstowcs_s</TT> does the following.&nbsp; If<B> retval</B> is
not a null pointer, then<TT> mbstowcs_s</TT> sets<B> *retval</B> to (size_t)(-1).&nbsp; If<B> dst</B> is not a null pointer
and<B> dstmax</B> is greater than zero and less than <TT> RSIZE_MAX</TT>, then<TT> mbstowcs_s</TT> sets<B> dst[0]</B> to the
null wide character.
</DL>
<DL>
<DT>Description:
<DD>The<TT> mbstowcs_s</TT> function converts a sequence of multibyte characters that begins in the initial shift state from the
array pointed to by<B> src</B> into a sequence of corresponding wide characters.&nbsp; If<B> dst</B> is not a null pointer,
the converted characters are stored into the array pointed to by<B> dst</B>.
<BR><BR>Conversion continues up to and including a terminating null character, which is also stored.&nbsp; Conversion stops
earlier in two cases:&nbsp; when a sequence of bytes is encountered that does not form a valid multibyte character, or (if<B>
dst</B> is not a null pointer) when<B> len</B> wide characters have been stored into the array pointed to by<B> dst</B>.&nbsp;
If<B> dst</B> is not a null pointer and no null wide character was stored into the array pointed to by<B> dst</B>, then<B>
dst[len]</B> is set to the null wide character.&nbsp; Each conversion takes place as if by a call to the <TT> mbrtowc</TT>
function.
<BR><BR>Regardless of whether<B> dst</B> is or is not a null pointer, if the input conversion encounters a sequence of bytes
that do not form a valid multibyte character, an encoding error occurs:&nbsp; the<TT> mbstowcs_s</TT> function stores the
value (size_t)(-1) into<B> *retval</B>.&nbsp; Otherwise, the<TT> mbstowcs_s</TT> function stores into<B> *retval</B> the number
of multibyte characters successfully converted, not including the terminating null character (if any).
<BR><BR>All elements following the terminating null wide character (if any) written by<TT> mbstowcs_s</TT> in the array of<B>
dstmax</B> wide characters pointed to by<B> dst</B> take unspecified values when<TT> mbstowcs_s</TT> returns.
<BR><BR>If copying takes place between objects that overlap, the objects take on unspecified values.
<BR><BR>The function is a data model independent form of the mbstowcs_s function that accepts far pointer arguments.&nbsp;
It is most useful in mixed memory model applications.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> mbstowcs_s</TT> function returns zero if there was no runtime-constraint violation.&nbsp; Otherwise, a non-zero value
is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#mbstowcs">mbstowcs</A>, <A HREF="#mblen">mblen</A>, <A HREF="#mbtowc">mbtowc</A>, <A HREF="#wctomb">wctomb</A>,
<A HREF="#wctomb_s">wctomb_s</A>, <A HREF="#wcstombs">wcstombs</A>, <A HREF="#wcstombs_s">wcstombs_s</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__&nbsp; 1</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>int&nbsp; main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; *wc = &quot;string&quot;;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; wchar_t wbuffer[50];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; i;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; errno_t rc;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; size_t&nbsp; retval;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; rc = mbstowcs_s( &amp;retval, wbuffer, 50, wc, 10);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( rc == 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wbuffer[retval] = L'\0';</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%s(%d)\n&quot;, wc, retval );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; retval; i++ )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;/%4.4x&quot;, wbuffer[i] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; return( 0 );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>string(6)</TT>
<BR><TT>/0073/0074/0072/0069/006e/0067</TT>
</DL>
<DL>
<DT>Classification:
<DD>TR 24731
<BR><BR>_fmbstowcs_s is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> mbstowcs_s - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_fmbstowcs_s - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="_mbterm"> _mbterm, _fmbterm </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>int _mbterm( const unsigned char *ch );</TT>
<BR><TT>int _fmbterm( const unsigned char __far *ch );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _mbterm</TT> function determines if the next multibyte character in the string pointed to by<B> ch</B> is a null character
or a valid lead byte followed by a null character.
<BR><BR>The<TT> _fmbterm</TT> function is a data model independent form of the _mbterm function that accepts far pointer arguments.
&nbsp;It is most useful in mixed memory model applications.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _mbterm</TT> function returns 1 if the multibyte character pointed to by<B> ch</B> is a null character.&nbsp; The<TT>
_mbterm</TT> function returns 2 if the multibyte character pointed to by<B> ch</B> is a valid lead byte character followed
by a null character.&nbsp; Otherwise, the<TT> _mbterm</TT> function returns 0.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_mbccmp">_mbccmp</A>, <A HREF="#_mbccpy">_mbccpy</A>, <A HREF="#_mbcicmp">_mbcicmp</A>, <A HREF="#_mbcjistojms">_mbcjistojms</A>,
<A HREF="#_mbcjmstojis">_mbcjmstojis</A>, <A HREF="#_mbclen">_mbclen</A>, <A HREF="#_mbctohira">_mbctohira</A>, <A HREF="#_mbctokata">_mbctokata</A>,
<A HREF="#_mbctolower">_mbctolower</A>, <A HREF="#_mbctombb">_mbctombb</A>, <A HREF="#_mbctoupper">_mbctoupper</A>, <A HREF="#mblen">mblen</A>,
<A HREF="#mbrlen">mbrlen</A>, <A HREF="#mbrtowc">mbrtowc</A>, <A HREF="#mbsrtowcs">mbsrtowcs</A>, <A HREF="#mbsrtowcs_s">mbsrtowcs_s</A>,
<A HREF="#mbstowcs">mbstowcs</A>, <A HREF="#mbstowcs_s">mbstowcs_s</A>, <A HREF="#mbtowc">mbtowc</A>, <A HREF="#btowc">btowc</A>,
<A HREF="#wcrtomb">wcrtomb</A>, <A HREF="#wcrtomb_s">wcrtomb_s</A>, <A HREF="#wcsrtombs">wcsrtombs</A>, <A HREF="#wcsrtombs_s">wcsrtombs_s</A>,
<A HREF="#wcstombs">wcstombs</A>, <A HREF="#wcstombs_s">wcstombs_s</A>, <A HREF="#wctob">wctob</A>, <A HREF="#wctomb">wctomb</A>,
<A HREF="#wctomb_s">wctomb_s</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><BR><TT>const unsigned char chars[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ' ',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '.',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '1',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'A',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x81,0x40, /* double-byte space */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x82,0x00&nbsp; /* invalid double-byte */</TT>
<BR><TT>};</TT>
<BR><BR><TT>#define SIZE sizeof( chars ) / sizeof( unsigned char )</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;0x%2.2x %d\n&quot;, chars[i],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _mbterm( &amp;chars[i]
) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>0x20 0</TT>
<BR><TT>0x2e 0</TT>
<BR><TT>0x31 0</TT>
<BR><TT>0x41 0</TT>
<BR><TT>0x81 0</TT>
<BR><TT>0x40 0</TT>
<BR><TT>0x82 2</TT>
<BR><TT>0x00 1</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> _mbterm - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
<BR><BR><TT>_fmbterm - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="mbtowc"> mbtowc, _fmbtowc </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>int mbtowc( wchar_t *pwc, const char *s, size_t n );</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>int _fmbtowc( wchar_t __far *pwc,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char __far *s,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t n );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> mbtowc</TT> function converts a single multibyte character pointed to by<B> s</B> into the wide character code that
corresponds to that multibyte character.&nbsp; The code for the null character is zero.&nbsp; If the multibyte character is
valid and<B> pwc</B> is not a NULL pointer, the code is stored in the object pointed to by<B> pwc</B>.&nbsp; At most<B> n</B>
bytes of the array pointed to by<B> s</B> will be examined.
<BR><BR>The<TT> mbtowc</TT> function does not examine more than <TT> MB_CUR_MAX</TT> bytes.
<BR><BR>The function is a data model independent form of the mbtowc function that accepts far pointer arguments.&nbsp; It
is most useful in mixed memory model applications.
</DL>
<DL>
<DT>Returns:
<DD>If<B> s</B> is a NULL pointer, the<TT> mbtowc</TT> function returns zero if multibyte character encodings are not state dependent,
and non-zero otherwise.&nbsp; If<B> s</B> is not a NULL pointer, the<TT> mbtowc</TT> function returns:
<DL>
<DT>Value&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>0
<DD>if<B> s</B> points to the null character
<DT>len
<DD>the number of bytes that comprise the multibyte character (if the next<B> n</B> or fewer bytes form a valid multibyte character)
<DT>-1
<DD>if the next<B> n</B> bytes do not form a valid multibyte character
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#mblen">mblen</A>, <A HREF="#wctomb">wctomb</A>, <A HREF="#mbstowcs">mbstowcs</A>, <A HREF="#wcstombs">wcstombs</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; *wc = &quot;string&quot;;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; wchar_t wbuffer[10];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; i, len;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Character encodings are %sstate dependent\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( mbtowc( wbuffer, NULL, 0 ) )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ? &quot;&quot; : &quot;not &quot; );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; len = mbtowc( wbuffer, wc, MB_CUR_MAX );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; wbuffer[len] = '\0';</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s(%d)\n&quot;, wc, len );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; len; i++ )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;/%4.4x&quot;, wbuffer[i] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;\n&quot; );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>Character encodings are not state dependent</TT>
<BR><TT>string(1)</TT>
<BR><TT>/0073</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>_fmbtowc is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> mbtowc - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_fmbtowc - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="_mbvtop"> _mbvtop, _fmbvtop </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>unsigned char *_mbvtop( unsigned int ch,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; unsigned char *addr );</TT>
<BR><TT>unsigned char __far *_fmbvtop( unsigned int ch,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; unsigned char __far *addr );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _mbvtop</TT> function stores the multibyte character<B> ch</B> into the string pointed to by<B> addr</B>.
<BR><BR>The<TT> _fmbvtop</TT> function is a data model independent form of the _mbvtop function that accepts far pointer arguments.
&nbsp;It is most useful in mixed memory model applications.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _mbvtop</TT> function returns the value of the argument<B> addr</B>.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_mbccmp">_mbccmp</A>, <A HREF="#_mbccpy">_mbccpy</A>, <A HREF="#_mbcicmp">_mbcicmp</A>, <A HREF="#_mbcjistojms">_mbcjistojms</A>,
<A HREF="#_mbcjmstojis">_mbcjmstojis</A>, <A HREF="#_mbclen">_mbclen</A>, <A HREF="#_mbctohira">_mbctohira</A>, <A HREF="#_mbctokata">_mbctokata</A>,
<A HREF="#_mbctolower">_mbctolower</A>, <A HREF="#_mbctombb">_mbctombb</A>, <A HREF="#_mbctoupper">_mbctoupper</A>, <A HREF="#mblen">mblen</A>,
<A HREF="#mbrlen">mbrlen</A>, <A HREF="#mbrtowc">mbrtowc</A>, <A HREF="#mbsrtowcs">mbsrtowcs</A>, <A HREF="#mbsrtowcs_s">mbsrtowcs_s</A>,
<A HREF="#mbstowcs">mbstowcs</A>, <A HREF="#mbstowcs_s">mbstowcs_s</A>, <A HREF="#mbtowc">mbtowc</A>, <A HREF="#btowc">btowc</A>,
<A HREF="#wcrtomb">wcrtomb</A>, <A HREF="#wcrtomb_s">wcrtomb_s</A>, <A HREF="#wcsrtombs">wcsrtombs</A>, <A HREF="#wcsrtombs_s">wcsrtombs_s</A>,
<A HREF="#wcstombs">wcstombs</A>, <A HREF="#wcstombs_s">wcstombs_s</A>, <A HREF="#wctob">wctob</A>, <A HREF="#wctomb">wctomb</A>,
<A HREF="#wctomb_s">wctomb_s</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned char string[10];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned char *p;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; p = string;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _mbvtop( '.', p );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; p++;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _mbvtop( '1', p );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; p++;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _mbvtop( 'A', p );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; p++;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _mbvtop( 0x8140, p );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; p += 2;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _mbvtop( 0x8260, p );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; p += 2;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _mbvtop( 0x82A6, p );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; p += 2;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _mbvtop( '\0', p );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; 10; i++ )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%2.2x &quot;, string[i] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;\n&quot; );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>2e 31 41 81 40 82 60 82 a6 00</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> _mbvtop - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
<BR><BR><TT>_fmbvtop - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="_memavl"> _memavl </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;malloc.h&gt;</TT>
<BR><TT>size_t _memavl( void );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _memavl</TT> function returns the number of bytes of memory available for dynamic memory allocation in the near heap
(the default data segment).&nbsp; In the tiny, small and medium memory models, the default data segment is only extended as
needed to satisfy requests for memory allocation.&nbsp; Therefore, you will need to call <TT> _nheapgrow</TT> in these memory
models before calling<TT> _memavl</TT> in order to get a meaningful result.
<BR><BR>The number returned by<TT> _memavl</TT> may not represent a single contiguous block of memory.&nbsp; Use the <TT>
_memmax</TT> function to find the largest contiguous block of memory that can be allocated.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _memavl</TT> function returns the number of bytes of memory available for dynamic memory allocation in the near heap
(the default data segment).
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#calloc">calloc</A> Functions, <A HREF="#_freect">_freect</A>, <A HREF="#_memmax">_memmax</A>, <A HREF="#_heapgrow">_heapgrow</A>
Functions, <A HREF="#malloc">malloc</A> Functions, <A HREF="#realloc">realloc</A> Functions
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;malloc.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char *p;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char *fmt = &quot;Memory available = %u\n&quot;;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; printf( fmt, _memavl() );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _nheapgrow();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( fmt, _memavl() );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; p = (char *) malloc( 2000 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( fmt, _memavl() );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>Memory available = 0</TT>
<BR><TT>Memory available = 62732</TT>
<BR><TT>Memory available = 60730</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS
</DL>
<H2 ID="memccpy"> memccpy, _fmemccpy </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>void *memccpy( void *dest, const void *src,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int c, size_t cnt );</TT>
<BR><TT>void __far *_fmemccpy( void __far *dest,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; const void __far *src,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; int c, size_t cnt );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> memccpy</TT> function copies bytes from<B> src</B> to<B> dest</B> up to and including the first occurrence of the
character<B> c</B> or until<B> cnt</B> bytes have been copied, whichever comes first.
<BR><BR>The<TT> _fmemccpy</TT> function is a data model independent form of the memccpy function.&nbsp; It accepts far pointer
arguments and returns a far pointer.&nbsp; It is most useful in mixed memory model applications.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> memccpy</TT> function returns a pointer to the byte in<B> dest</B> following the character<B> c</B> if one is found
and copied, otherwise it returns NULL.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#memcpy">memcpy</A>, <A HREF="#memmove">memmove</A>, <A HREF="#memset">memset</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><BR><TT>char *msg = &quot;This is the string: not copied&quot;;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; auto char buffer[80];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; memset( buffer, '\0', 80 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; memccpy( buffer, msg, ':', 80 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, buffer );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>This is the string:</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> memccpy - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_fmemccpy - All, Linux, RDOS</TT>
</DL>
<H2 ID="memchr"> memchr, _fmemchr, wmemchr </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>void *memchr( const void *buf, int ch, size_t length );</TT>
<BR><TT>void __far *_fmemchr( const void __far *buf,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; int ch,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; size_t length );</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>wchar_t *wmemchr( const wchar_t *buf, wchar_t ch, size_t length );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> memchr</TT> function locates the first occurrence of<B> ch</B> (converted to an unsigned char) in the first<B> length</B>
characters of the object pointed to by<B> buf</B>.
<BR><BR>The<TT> _fmemchr</TT> function is a data model independent form of the memchr function.&nbsp; It accepts far pointer
arguments and returns a far pointer.&nbsp; It is most useful in mixed memory model applications.
<BR><BR>The<TT> wmemchr</TT> function is a wide-character version of<TT> memchr</TT> that operates with wide-character strings.
&nbsp;The argument<B> length</B> is interpreted to mean the number of wide characters.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> memchr</TT> function returns a pointer to the located character, or<TT> NULL</TT> if the character does not occur
in the object.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#memcmp">memcmp</A>, <A HREF="#memcpy">memcpy</A>, <A HREF="#memicmp">memicmp</A>, <A HREF="#memset">memset</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char buffer[80];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char *where;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; strcpy( buffer, &quot;video x-rays&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; where = (char *)memchr( buffer, 'x', 6 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( where == NULL )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;'x' not found\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, where );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; where = (char *)memchr( buffer, 'r', 9 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( where == NULL )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;'r' not found\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, where );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>_fmemchr is WATCOM
<BR>wmemchr is ISO C95
</DL>
<DL>
<DT>Systems:
<DD><TT> memchr - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_fmemchr - All, Linux, RDOS</TT>
<BR><TT>wmemchr - All, Linux</TT>
</DL>
<H2 ID="memcmp"> memcmp, _fmemcmp, wmemcmp </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>int memcmp( const void *s1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const void *s2,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t length );</TT>
<BR><TT>int _fmemcmp( const void __far *s1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const void __far *s2,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t length );</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>int wmemcmp( const wchar_t *s1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t *s2,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t length );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> memcmp</TT> function compares the first<B> length</B> characters of the object pointed to by<B> s1</B> to the object
pointed to by<B> s2</B>.
<BR><BR>The<TT> _fmemcmp</TT> function is a data model independent form of the memcmp function that accepts far pointer arguments.
&nbsp;It is most useful in mixed memory model applications.
<BR><BR>The<TT> wmemcmp</TT> function is a wide-character version of<TT> memcmp</TT> that operates with wide-character strings.
&nbsp;The argument<B> length</B> is interpreted to mean the number of wide characters.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> memcmp</TT> function returns an integer less than, equal to, or greater than zero, indicating that the object pointed
to by<B> s1</B> is less than, equal to, or greater than the object pointed to by<B> s2</B>.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#memchr">memchr</A>, <A HREF="#memcpy">memcpy</A>, <A HREF="#memicmp">memicmp</A>, <A HREF="#memset">memset</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; auto char buffer[80];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; strcpy( buffer, &quot;world&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( memcmp( buffer, &quot;Hello &quot;, 6 ) &lt; 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Less than\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>_fmemcmp is WATCOM
<BR>wmemcmp is ISO C95
</DL>
<DL>
<DT>Systems:
<DD><TT> memcmp - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_fmemcmp - All, Linux, RDOS</TT>
<BR><TT>wmemcmp - All, Linux</TT>
</DL>
<H2 ID="memcpy"> memcpy, _fmemcpy, wmemcpy </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>void *memcpy( void *dst,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const void *src,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t length );</TT>
<BR><TT>void __far *_fmemcpy( void __far *dst,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; const void __far *src,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; size_t length );</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>wchar_t *wmemcpy( wchar_t *dst,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t
*src,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t length
);</TT>
</DL>
<DL>
<DT>Safer C:
<DD>The Safer C Library extension provides the <A HREF="#memcpy_s">memcpy_s</A> function which is a safer alternative to<TT> memcpy</TT>
This newer<TT> memcpy_s</TT> function is recommended to be used instead of the traditional &quot;unsafe&quot;<TT> memcpy</TT>
function.
</DL>
<DL>
<DT>Description:
<DD>The<TT> memcpy</TT> function copies<B> length</B> characters from the buffer pointed to by<B> src</B> into the buffer pointed
to by<B> dst</B>.&nbsp; Copying of overlapping objects is not guaranteed to work properly.&nbsp; See the <TT> memmove</TT>
function if you wish to copy objects that overlap.
<BR><BR>The<TT> _fmemcpy</TT> function is a data model independent form of the memcpy function.&nbsp; It accepts far pointer
arguments and returns a far pointer.&nbsp; It is most useful in mixed memory model applications.
<BR><BR>The<TT> wmemcpy</TT> function is a wide-character version of<TT> memcpy</TT> that operates with wide-character strings.
&nbsp;The argument<B> length</B> is interpreted to mean the number of wide characters.
</DL>
<DL>
<DT>Returns:
<DD>The original value of<B> dst</B> is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#memchr">memchr</A>, <A HREF="#memcmp">memcmp</A>, <A HREF="#memicmp">memicmp</A>, <A HREF="#memmove">memmove</A>,
<A HREF="#memset">memset</A>, <A HREF="#memcpy_s">memcpy_s</A>, <A HREF="#memmove_s">memmove_s</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; auto char buffer[80];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; memcpy( buffer, &quot;Hello&quot;, 5 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; buffer[5] = '\0';</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, buffer );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>_fmemcpy is WATCOM
<BR>wmemcpy is ISO C95
</DL>
<DL>
<DT>Systems:
<DD><TT> memcpy - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_fmemcpy - All, Linux, RDOS</TT>
<BR><TT>wmemcpy - All, Linux</TT>
</DL>
<H2 ID="memcpy_s"> memcpy_s, wmemcpy_s </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__&nbsp; 1</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>errno_t memcpy_s( void * restrict s1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rsize_t s1max,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const void
* restrict s2,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rsize_t n );</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>errno_t wmemcpy_s( wchar_t * restrict s1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rsize_t
s1max,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const
wchar_t * restrict s2,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t
n );</TT>
</DL>
<DL>
<DT>Constraints:
<DD>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<TT>
memcpy_s</TT> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<BR><BR>Neither<B> s1</B> nor<B> s2</B> shall be a null pointer.&nbsp; Neither<B> s1max</B> nor<B> n</B> shall be greater
than <TT> RSIZE_MAX</TT>.<B>&nbsp; n</B> shall not be greater than<B> s1max</B>.&nbsp; Copying shall not take place between
objects that overlap.
<BR><BR>If there is a runtime-constraint violation, the<TT> memcpy_s</TT> function stores zeros in the first<B> s1max</B>
characters of the object pointed to by<B> s1</B> if<B> s1</B> is not a null pointer and<B> s1max</B> is not greater than <TT>
RSIZE_MAX</TT>.
</DL>
<DL>
<DT>Description:
<DD>The<TT> memcpy_s</TT> function copies<B> n</B> characters from the buffer pointed to by<B> s2</B> into the buffer pointed
to by<B> s1</B>.&nbsp; Copying between overlapping objects is not allowed.&nbsp; See the <TT> memmove_s</TT> function if you
wish to copy objects that overlap.
<BR><BR>The<TT> wmemcpy_s</TT> function is a wide-character version of<TT> memcpy_s</TT> that operates with wide-character
strings.&nbsp; The arguments<B> s1max</B> and<B> n</B> are interpreted to mean the number of wide characters.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> memcpy_s</TT> function returns zero if there was no runtime-constraint violation.&nbsp; Otherwise, a non-zero value
is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#memcpy">memcpy</A>, <A HREF="#memchr">memchr</A>, <A HREF="#memcmp">memcmp</A>, <A HREF="#memcpy">memcpy</A>, <A HREF="#memicmp">memicmp</A>,
<A HREF="#memmove">memmove</A>, <A HREF="#memset">memset</A>, <A HREF="#memmove_s">memmove_s</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__&nbsp; 1</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char buffer[80];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; memcpy_s( buffer, sizeof( buffer ), &quot;Hello&quot;, 5 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; buffer[5] = '\0';</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, buffer );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>TR 24731
</DL>
<DL>
<DT>Systems:
<DD><TT> memcpy_s - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>wmemcpy_s - All, Linux</TT>
</DL>
<H2 ID="memicmp"> memicmp, _memicmp, _fmemicmp </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>int memicmp( const void *s1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const void *s2,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t length );</TT>
<BR><TT>int _memicmp( const void *s1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const void *s2,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t length );</TT>
<BR><TT>int _fmemicmp( const void __far *s1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const void __far *s2,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t length );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> memicmp</TT> function compares, with case insensitivity (upper- and lowercase characters are equivalent), the first<B>
length</B> characters of the object pointed to by<B> s1</B> to the object pointed to by<B> s2</B>.
<BR><BR>The<TT> _fmemicmp</TT> function is a data model independent form of the memicmp function that accepts far pointer
arguments.&nbsp; It is most useful in mixed memory model applications.
<BR><BR>The<TT> _memicmp</TT> function is identical to<TT> memicmp</TT>.&nbsp; Use<TT> _memicmp</TT> for ANSI naming conventions.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> memicmp</TT> function returns an integer less than, equal to, or greater than zero, indicating that the object pointed
to by<B> s1</B> is less than, equal to, or greater than the object pointed to by<B> s2</B>.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#memchr">memchr</A>, <A HREF="#memcmp">memcmp</A>, <A HREF="#memcpy">memcpy</A>, <A HREF="#memset">memset</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char buffer[80];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; if( memicmp( buffer, &quot;Hello&quot;, 5 ) &lt; 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Less than\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
<BR><BR>_memicmp conforms to ANSI naming conventions
</DL>
<DL>
<DT>Systems:
<DD><TT> memicmp - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_memicmp - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, Linux, RDOS</TT>
<BR><TT>_fmemicmp - All, Linux, RDOS</TT>
</DL>
<H2 ID="_memmax"> _memmax </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;malloc.h&gt;</TT>
<BR><TT>size_t _memmax( void );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _memmax</TT> function returns the size of the largest contiguous block of memory available for dynamic memory allocation
in the near heap (the default data segment).&nbsp; In the tiny, small and medium memory models, the default data segment is
only extended as needed to satisfy requests for memory allocation.&nbsp; Therefore, you will need to call <TT> _nheapgrow</TT>
in these memory models before calling _memmax in order to get a meaningful result.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _memmax</TT> function returns the size of the largest contiguous block of memory available for dynamic memory allocation
in the near heap.&nbsp; If 0 is returned, then there is no more memory available in the near heap.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#calloc">calloc</A>, <A HREF="#_freect">_freect</A>, <A HREF="#_memavl">_memavl</A>, <A HREF="#_heapgrow">_heapgrow</A>,
<A HREF="#malloc">malloc</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;malloc.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char *p;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; size_t size;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; size = _memmax();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Maximum memory available is %u\n&quot;, size );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _nheapgrow();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; size = _memmax();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Maximum memory available is %u\n&quot;, size );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; p = (char *) _nmalloc( size );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; size = _memmax();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Maximum memory available is %u\n&quot;, size );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>Maximum memory available is 0</TT>
<BR><TT>Maximum memory available is 62700</TT>
<BR><TT>Maximum memory available is 0</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS
</DL>
<H2 ID="memmove"> memmove, _fmemmove, wmemmove </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>void *memmove( void *dst,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const void *src,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t length );</TT>
<BR><TT>void __far *_fmemmove( void __far *dst,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; const void __far *src,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; size_t length );</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>wchar_t *wmemmove( wchar_t *dst,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const
wchar_t *src,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t
length );</TT>
</DL>
<DL>
<DT>Safer C:
<DD>The Safer C Library extension provides the <A HREF="#memmove_s">memmove_s</A> function which is a safer alternative to<TT>
memmove</TT> This newer<TT> memmove_s</TT> function is recommended to be used instead of the traditional &quot;unsafe&quot;<TT>
memmove</TT> function.
</DL>
<DL>
<DT>Description:
<DD>The<TT> memmove</TT> function copies<B> length</B> characters from the buffer pointed to by<B> src</B> to the buffer pointed
to by<B> dst</B>.&nbsp; Copying of overlapping objects will take place properly.&nbsp; See the <TT> memcpy</TT> function to
copy objects that do not overlap.
<BR><BR>The<TT> _fmemmove</TT> function is a data model independent form of the memmove function.&nbsp; It accepts far pointer
arguments and returns a far pointer.&nbsp; It is most useful in mixed memory model applications.
<BR><BR>The<TT> wmemmove</TT> function is a wide-character version of<TT> memmove</TT> that operates with wide-character strings.
&nbsp;The argument<B> length</B> is interpreted to mean the number of wide characters.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> memmove</TT> function returns<B> dst</B>.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#memchr">memchr</A>, <A HREF="#memcmp">memcmp</A>, <A HREF="#memcpy">memcpy</A>, <A HREF="#memicmp">memicmp</A>,
<A HREF="#memset">memset</A>, <A HREF="#memmove_s">memmove_s</A>, <A HREF="#memcpy_s">memcpy_s</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char buffer[80];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; memmove( buffer + 1, buffer, 79 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; buffer[0] = '*';</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>_fmemmove is WATCOM
<BR>wmemmove is ISO C95
</DL>
<DL>
<DT>Systems:
<DD><TT> memmove - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_fmemmove - All, Linux, RDOS</TT>
<BR><TT>wmemmove - All, Linux</TT>
</DL>
<H2 ID="memmove_s"> memmove_s, wmemmove_s </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__&nbsp; 1</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>errno_t memmove_s( void * restrict s1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rsize_t
s1max,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const
void * restrict s2,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rsize_t
n );</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>errno_t wmemmove_s( wchar_t * restrict s1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
rsize_t s1max,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const wchar_t * restrict s2,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
size_t n );</TT>
</DL>
<DL>
<DT>Constraints:
<DD>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<TT>
memmove_s</TT> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<BR><BR>Neither<B> s1</B> nor<B> s2</B> shall be a null pointer.&nbsp; Neither<B> s1max</B> nor<B> n</B> shall be greater
than<B> RSIZE_MAX</B>.<B>&nbsp; n</B> shall not be greater than<B> s1max</B>.
<BR><BR>If there is a runtime-constraint violation, the<TT> memmove_s</TT> function stores zeros in the first<B> s1max</B>
characters of the object pointed to by<B> s1</B> if<B> s1</B> is not a null pointer and<B> s1max</B> is not greater than<B>
RSIZE_MAX</B>.
</DL>
<DL>
<DT>Description:
<DD>The<TT> memmove_s</TT> function copies<B> n</B> characters from the buffer pointed to by<B> s2</B> into the buffer pointed
to by<B> s1</B>.&nbsp; This copying takes place as if the<B> n</B> characters from the buffer pointed to by<B> s2</B> are
first copied into a temporary array of<B> n</B> characters that does not overlap the objects pointed to by<B> s1</B> or<B>
s2</B> ,and then the<B> n</B> characters from the temporary array are copied into the object pointed to by<B> s1</B>.
<BR><BR>See the<B> memcpy_s</B> function if you wish to copy objects that do not overlap.
<BR><BR>The<TT> wmemmove_s</TT> function is a wide-character version of<TT> memmove_s</TT> that operates with wide-character
strings.&nbsp; The arguments<B> s1max</B> and<B> n</B> are interpreted to mean the number of wide characters.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> memmove_s</TT> function returns zero if there was no runtime-constraint violation.&nbsp; Otherwise, a non-zero value
is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#memchr">memchr</A>, <A HREF="#memcmp">memcmp</A>, <A HREF="#memcpy">memcpy</A>, <A HREF="#memicmp">memicmp</A>,
<A HREF="#memmove">memmove</A>, <A HREF="#memset">memset</A>, <A HREF="#memcpy_s">memcpy_s</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__&nbsp; 1</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char buffer[80] = &quot;0123456789&quot;;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; memmove_s( buffer + 1, sizeof( buffer ), buffer, 79 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; buffer[0] = '*';</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( buffer );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>*0123456789</TT>
</DL>
<DL>
<DT>Classification:
<DD>TR 24731
</DL>
<DL>
<DT>Systems:
<DD><TT> memmove_s - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>wmemmove_s - All</TT>
</DL>
<H2 ID="_m_empty"> _m_empty </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><TT>void&nbsp; _m_empty(void);</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _m_empty</TT> function empties the multimedia state.&nbsp; The values in the Multimedia Tag Word (TW) are set to empty
(i.e., all ones).&nbsp; This will indicate that no Multimedia registers are in use.
<BR><BR>This function is useful for applications that mix floating-point (FP) instructions with multimedia instructions.&nbsp;
Intel maps the multimedia registers onto the floating-point registers.&nbsp; For this reason, you are discouraged from intermixing
MM code and FP code.&nbsp; The recommended way to write an application with FP instructions and MM instructions is:
<UL>
<LI>Split the FP code and MM code into two separate instruction streams such that each stream contains only instructions of
one type.
<LI>Do not rely on the contents of FP/MM registers across transitions from one stream to the other.
<LI>Leave the MM state empty at the end of an MM stream using the<TT> _m_empty</TT> function.
<LI>Similarly, leave the FP stack empty at the end of an FP stream.
</UL>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _m_empty</TT> function does not return a value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_m_from_int">_m_from_int</A>, <A HREF="#_m_to_int">_m_to_int</A>, <A HREF="#_m_packsswb">_m_packsswb</A>, <A HREF="#_m_paddb">_m_paddb</A>,
<A HREF="#_m_pand">_m_pand</A>, <A HREF="#_m_pcmpeqb">_m_pcmpeqb</A>, <A HREF="#_m_pmaddwd">_m_pmaddwd</A>, <A HREF="#_m_psllw">_m_psllw</A>,
<A HREF="#_m_psraw">_m_psraw</A>, <A HREF="#_m_psrlw">_m_psrlw</A>, <A HREF="#_m_psubb">_m_psubb</A>, <A HREF="#_m_punpckhbw">_m_punpckhbw</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><BR><TT>long featureflags( void );</TT>
<BR><BR><TT>#pragma aux featureflags = \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; &quot;.586&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; &quot;mov eax,1&quot;&nbsp;&nbsp;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; &quot;cpuid&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; &quot;mov eax,edx&quot;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; __modify [eax ebx ecx edx]</TT>
<BR><BR><TT>#define MM_EXTENSION 0x00800000</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( featureflags() &amp; MM_EXTENSION ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /*</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sequence of code that uses Multimedia functions</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; */</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _m_empty();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; /*</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sequence of code that uses floating-point</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="memset"> memset, _fmemset, wmemset </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>void *memset( void *dst, int c, size_t length );</TT>
<BR><TT>void __far *_fmemset( void __far *dst, int c,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; size_t length );</TT>
<BR><TT>wchar_t *wmemset( wchar_t *dst,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t c,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t length
);</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> memset</TT> function fills the first<B> length</B> characters of the object pointed to by<B> dst</B> with the value<B>
c</B>.
<BR><BR>The<TT> _fmemset</TT> function is a data model independent form of the memset function.&nbsp; It accepts far pointer
arguments and returns a far pointer.&nbsp; It is most useful in mixed memory model applications.
<BR><BR>The<TT> wmemset</TT> function is a wide-character version of<TT> memset</TT> that operates with wide-character strings.
&nbsp;The argument<B> length</B> is interpreted to mean the number of wide characters.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> memset</TT> function returns the pointer<B> dst</B>.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#memchr">memchr</A>, <A HREF="#memcmp">memcmp</A>, <A HREF="#memcpy">memcpy</A>, <A HREF="#memicmp">memicmp</A>,
<A HREF="#memmove">memmove</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char buffer[80];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; memset( buffer, '=', 80 );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>_fmemset is WATCOM
<BR>wmemset is ISO C95
</DL>
<DL>
<DT>Systems:
<DD><TT> memset - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_fmemset - All, Linux, RDOS</TT>
<BR><TT>wmemset - All, Linux</TT>
</DL>
<H2 ID="_m_from_int"> _m_from_int </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><TT>__m64 _m_from_int(int i);</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _m_from_int</TT> function forms a 64-bit MM value from an unsigned 32-bit integer value.
</DL>
<DL>
<DT>Returns:
<DD>The 64-bit result of loading MM0 with an unsigned 32-bit integer value is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_m_empty">_m_empty</A>, <A HREF="#_m_to_int">_m_to_int</A>, <A HREF="#_m_packsswb">_m_packsswb</A>, <A HREF="#_m_paddb">_m_paddb</A>,
<A HREF="#_m_pand">_m_pand</A>, <A HREF="#_m_empty">_m_empty</A>, <A HREF="#_m_pcmpeqb">_m_pcmpeqb</A>, <A HREF="#_m_pmaddwd">_m_pmaddwd</A>,
<A HREF="#_m_psllw">_m_psllw</A>, <A HREF="#_m_psraw">_m_psraw</A>, <A HREF="#_m_psrlw">_m_psrlw</A>, <A HREF="#_m_empty">_m_empty</A>,
<A HREF="#_m_psubb">_m_psubb</A>, <A HREF="#_m_punpckhbw">_m_punpckhbw</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><BR><TT>__m64&nbsp;&nbsp; a;</TT>
<BR><BR><TT>int&nbsp;&nbsp;&nbsp;&nbsp; k = 0xF1F2F3F4;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; a = _m_from_int( k );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;int=%8.8lx m=%8.8lx%8.8lx\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k, a._32[1], a._32[0] );</TT>
<BR><BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>int=f1f2f3f4 m=00000000f1f2f3f4</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="min"> min </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>#define min(a,b)&nbsp; (((a) &lt; (b)) ? (a) : (b))</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> min</TT> macro will evaluate to be the lesser of two values.&nbsp; It is implemented as follows.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define min(a,b)&nbsp; (((a) &lt; (b)) ? (a) : (b))</TT>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> min</TT> macro will evaluate to the smaller of the two values passed.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#max">max</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int a;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; /*</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * The following line will set the variable &quot;a&quot; to 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; * since 10 is greater than 1.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; a = min( 1, 10 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;The value is: %d\n&quot;, a );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="mkdir"> mkdir, _mkdir, _wmkdir </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;sys/types.h&gt;</TT>
<BR><TT>#include &lt;direct.h&gt;</TT>
<BR><TT>int mkdir( const char *path );</TT>
<BR><TT>int _mkdir( const char *path );</TT>
<BR><TT>int _wmkdir( const wchar_t *path );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> mkdir</TT> function creates a new subdirectory with name<B> path</B>.&nbsp; The<B> path</B> can be either relative
to the current working directory or it can be an absolute path name.
<BR><BR>The<TT> _mkdir</TT> function is identical to<TT> mkdir</TT>.&nbsp; Use<TT> _mkdir</TT> for ANSI naming conventions.
<BR><BR>The<TT> _wmkdir</TT> function is a wide-character version of<TT> mkdir</TT> that operates with wide-character strings.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> mkdir</TT> function returns zero if successful, and a non-zero value otherwise.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>EACCES
<DD>Search permission is denied for a component of<B> path</B> or write permission is denied on the parent directory of the directory
to be created.
<DT>EEXIST
<DD>The named file exists.
<DT>ENOENT
<DD>The specified<B> path</B> does not exist or<B> path</B> is an empty string.
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#chdir">chdir</A>, <A HREF="#chmod">chmod</A>, <A HREF="#getcwd">getcwd</A>, <A HREF="#rmdir">rmdir</A>, <A HREF="#stat">stat</A>,
<A HREF="#umask">umask</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR>To make a new directory called<TT> \watcom</TT> on drive<TT> C:</TT>
<BR><BR><TT>#include &lt;sys/types.h&gt;</TT>
<BR><TT>#include &lt;direct.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; mkdir( &quot;c:\\watcom&quot; );</TT>
<BR><TT>}</TT>
<BR><BR>Note the use of two adjacent backslash characters (\) within character-string constants to signify a single backslash.
</DL>
<DL>
<DT>Classification:
<DD>POSIX 1003.1
<BR><BR>_mkdir conforms to ANSI naming conventions
<BR>_wmkdir is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> mkdir - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_mkdir - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
<BR><TT>_wmkdir - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</TT>
</DL>
<H2 ID="MK_FP"> MK_FP </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;i86.h&gt;</TT>
<BR><TT>void __far *MK_FP( unsigned int segment,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned
int offset );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> MK_FP</TT> macro can be used to obtain the far pointer value given by the<B> segment</B> segment value and the<B>
offset</B> offset value.&nbsp; These values may be obtained by using the <TT> FP_SEG</TT> and <TT> FP_OFF</TT> macros.
</DL>
<DL>
<DT>Returns:
<DD>The macro returns a far pointer.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#FP_OFF">FP_OFF</A>, <A HREF="#FP_SEG">FP_SEG</A>, <A HREF="#segread">segread</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;i86.h&gt;</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned short __far *bios_prtr_port_1;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; bios_prtr_port_1 =</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (unsigned short __far *) MK_FP( 0x40, 0x8 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Port address is %x\n&quot;, *bios_prtr_port_1 );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="mkstemp"> mkstemp </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>int mkstemp( char *template );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> mkstemp</TT> function creates a file with unique name by modifying the<B> template</B> argument, and returns its file
handle open for reading and writing in binary mode.&nbsp; The use of<TT> mkstemp</TT> prevents any possible race condition
between testing whether the file exists and opening it for use.
<BR><BR>The string<B> template</B> has the form<TT> baseXXXXXX</TT> where<TT> base</TT> is the fixed part of the generated
filename and<TT> XXXXXX</TT> is the variable part of the generated filename.&nbsp; Each of the 6 X's is a placeholder for
a character supplied by mkstemp.&nbsp; Each placeholder character in<B> template</B> must be an uppercase &quot;X&quot;.<TT>
&nbsp;mkstemp</TT> preserves<TT> base</TT> and replaces the first of the 6 trailing X's with a unique sequence of alphanumeric
characters.&nbsp; The string<B> template</B> therefore must be writable.
<BR><BR><TT>mkstemp</TT> checks to see if a file with the generated name already exists and if so selects another name, until
it finds a file that doesn't exist.&nbsp; If it is unsuccessful at finding a name for a file that does not already exist or
is unable to create a file,<TT> mkstemp</TT> returns -1.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> mkstemp</TT> function returns a file handle.&nbsp; When an error occurs while creating the file, -1 is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#fopen">fopen</A>, <A HREF="#freopen">freopen</A>, <A HREF="#_mktemp">_mktemp</A>, <A HREF="#_tempnam">_tempnam</A>,
<A HREF="#tmpfile">tmpfile</A>, <A HREF="#tmpnam">tmpnam</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>#include &lt;unistd.h&gt;</TT>
<BR><BR><TT>#define TEMPLATE&nbsp;&nbsp;&nbsp; &quot;_tXXXXXX&quot;</TT>
<BR><TT>#define MAX_TEMPS&nbsp;&nbsp; 5</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; name[sizeof( TEMPLATE )];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; i;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; handles[MAX_TEMPS];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; MAX_TEMPS; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcpy( name, TEMPLATE );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handles[i] = mkstemp( name );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( handles[i] == -1 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Failed to create temporary file\n&quot;
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Created temporary file '%s'\n&quot;,
name );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; MAX_TEMPS; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( handles[i] != -1 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close( handles[i] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>POSIX
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, Netware
</DL>
<H2 ID="_mktemp"> _mktemp, _wmktemp </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;io.h&gt;</TT>
<BR><TT>char *_mktemp( char *template );</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>wchar_t *_wmktemp( wchar_t *template );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _mktemp</TT> function creates a unique filename by modifying the<B> template</B> argument.<TT>&nbsp; _mktemp</TT>
automatically handles multibyte-character string arguments as appropriate, recognizing multibyte-character sequences according
to the multibyte code page currently in use by the run-time system.
<BR><BR>The<TT> _wmktemp</TT> function is a wide-character version of<TT> _mktemp</TT> that operates with wide-character strings.
<BR><BR>The string<B> template</B> has the form<TT> baseXXXXXX</TT> where<TT> base</TT> is the fixed part of the generated
filename and<TT> XXXXXX</TT> is the variable part of the generated filename.&nbsp; Each of the 6 X's is a placeholder for
a character supplied by _mktemp.&nbsp; Each placeholder character in<B> template</B> must be an uppercase &quot;X&quot;.<TT>
&nbsp;_mktemp</TT> preserves<TT> base</TT> and replaces the first of the 6 trailing X's with a lowercase alphabetic character
(a-z).<TT>&nbsp; _mktemp</TT> replaces the following 5 trailing X's with a five-digit value; this value is a unique number
identifying the calling process or thread.
<BR><BR><TT>_mktemp</TT> checks to see if a file with the generated name already exists and if so selects another letter,
in succession, from &quot;a&quot; to &quot;z&quot; until it finds a file that doesn't exist.&nbsp; If it is unsuccessful at
finding a name for a file that does not already exist,<TT> _mktemp</TT> returns NULL.&nbsp; At most, 26 unique file names
can be returned to the calling process or thread.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _mktemp</TT> function returns a pointer to the modified<B> template</B>.&nbsp; The<TT> _mktemp</TT> function returns
NULL if<B> template</B> is badly formed or no more unique names can be created from the given template.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#fopen">fopen</A>, <A HREF="#freopen">freopen</A>, <A HREF="#mkstemp">mkstemp</A>, <A HREF="#_tempnam">_tempnam</A>,
<A HREF="#tmpfile">tmpfile</A>, <A HREF="#tmpnam">tmpnam</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>#include &lt;io.h&gt;</TT>
<BR><BR><TT>#define TMPLTE &quot;_tXXXXXX&quot;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char name[sizeof(TMPLTE)];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char *mknm;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int i;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FILE *fp;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; 30; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcpy( name, TMPLTE );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mknm = _mktemp( name );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( mknm == NULL )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Name is badly formed\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Name is %s\n&quot;, mknm );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fp = fopen( mknm, &quot;w&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( fp != NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf( fp, &quot;Name is %s\n&quot;, mknm );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( fp );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> _mktemp - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</TT>
<BR><BR><TT>_wmktemp - Win32</TT>
</DL>
<H2 ID="mktime"> mktime </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;time.h&gt;</TT>
<BR><TT>time_t mktime( struct tm *timeptr );</TT>
<BR><BR><TT>struct&nbsp; tm {</TT>
<BR><TT>&nbsp; int tm_sec;&nbsp;&nbsp; /* seconds after the minute -- [0,61] */</TT>
<BR><TT>&nbsp; int tm_min;&nbsp;&nbsp; /* minutes after the hour&nbsp;&nbsp; -- [0,59] */</TT>
<BR><TT>&nbsp; int tm_hour;&nbsp; /* hours after midnight&nbsp;&nbsp;&nbsp;&nbsp; -- [0,23] */</TT>
<BR><TT>&nbsp; int tm_mday;&nbsp; /* day of the month&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- [1,31] */</TT>
<BR><TT>&nbsp; int tm_mon;&nbsp;&nbsp; /* months since January&nbsp;&nbsp;&nbsp;&nbsp; -- [0,11] */</TT>
<BR><TT>&nbsp; int tm_year;&nbsp; /* years since 1900&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp; int tm_wday;&nbsp; /* days since Sunday&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- [0,6]&nbsp; */</TT>
<BR><TT>&nbsp; int tm_yday;&nbsp; /* days since January 1&nbsp;&nbsp;&nbsp;&nbsp; -- [0,365]*/</TT>
<BR><TT>&nbsp; int tm_isdst; /* Daylight Savings Time flag */</TT>
<BR><TT>};</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> mktime</TT> function converts the local time information in the structure pointed to by<B> timeptr</B> into a calendar
time (Coordinated Universal Time) with the same encoding used by the <TT> time</TT> function.&nbsp; The original values of
the fields <TT> tm_sec</TT>, <TT> tm_min</TT>, <TT> tm_hour</TT>, <TT> tm_mday</TT>, and <TT> tm_mon</TT> are not restricted
to ranges described for <TT> struct tm</TT>.&nbsp; If these fields are not in their proper ranges, they are adjusted so that
they are in the proper ranges.&nbsp; Values for the fields <TT> tm_wday</TT> and <TT> tm_yday</TT> are computed after all
the other fields have been adjusted.
<BR><BR>If the original value of <TT> tm_isdst</TT> is negative, this field is computed also.&nbsp; Otherwise, a value of
0 is treated as &quot;daylight savings time is not in effect&quot; and a positive value is treated as &quot;daylight savings
time is in effect&quot;.
<BR><BR>Whenever<TT> mktime</TT> is called, the <TT> tzset</TT> function is also called.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> mktime</TT> function returns the converted calendar time.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#asctime">asctime</A> Functions, <A HREF="#asctime_s">asctime_s</A>, <A HREF="#clock">clock</A>, <A HREF="#ctime">ctime</A>
Functions, <A HREF="#ctime_s">ctime_s</A>, <A HREF="#difftime">difftime</A>, <A HREF="#gmtime">gmtime</A>, <A HREF="#gmtime_s">gmtime_s</A>,
<A HREF="#localtime">localtime</A>, <A HREF="#localtime_s">localtime_s</A>, <A HREF="#strftime">strftime</A>, <A HREF="#time">time</A>,
<A HREF="#tzset">tzset</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;time.h&gt;</TT>
<BR><BR><TT>static const char *week_day[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; &quot;Sunday&quot;, &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;</TT>
<BR><TT>};</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct tm new_year;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; new_year.tm_year&nbsp; = 2001 - 1900;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; new_year.tm_mon&nbsp;&nbsp; = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; new_year.tm_mday&nbsp; = 1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; new_year.tm_hour&nbsp; = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; new_year.tm_min&nbsp;&nbsp; = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; new_year.tm_sec&nbsp;&nbsp; = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; new_year.tm_isdst = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; mktime( &amp;new_year );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;The 21st century began on a %s\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; week_day[ new_year.tm_wday ] );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>The 21st century began on a Monday</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="mlock"> mlock </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;sys/mman.h&gt;</TT>
<BR><TT>int mlock(void *address, size_t len)</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> mlock</TT> function causes memory located at<B> address</B> measuring<B> len</B> bytes to be held in physical memory
until unlocked or the process terminates.
</DL>
<DL>
<DT>Returns:
<DD>If successful, the function will return 0.&nbsp; Upon failure, the function will return -1, and errno will be set appropriately.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>EINVAL
<DD>The argument<B> address</B> is not a multiple of the page size or the<B> len</B> is zero or causes an overflow
<DT>ENOMEM
<DD>The arguments do not correspond to a region of the process's address space or the requested lock region exceeds an allowable
limit
<DT>EAGAIN
<DD>Some portion of the memory could not be locked
<DT>EPERM
<DD>The calling process lacks the approriate permissions
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#mlockall">mlockall</A>, <A HREF="#munlock">munlock</A>, <A HREF="#munlockall">munlockall</A>
</DL>
<DL>
<DT>Classification:
<DD>POSIX
</DL>
<DL>
<DT>Systems:
<DD>Linux
</DL>
<H2 ID="mlockall"> mlockall </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;sys/mman.h&gt;</TT>
<BR><TT>int mlockall(int flags)</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> mlockall</TT> function causes all memory in the current process's address space to reside in physical memory until
unlocked.&nbsp; The<B> flags</B> argument may be one or a combination of the following:
<DL>
<DT>MCL_CURRENT
<DD>Lock all pages currently mapped for the process
<DT>MCL_FUTURE
<DD>Lock all pages that may be mapped in the future for this process
</DL>
</DL>
<DL>
<DT>Returns:
<DD>If successful, the function will return 0.&nbsp; Upon failure, the function will return -1, and errno will be set appropriately.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>EINVAL
<DD>The argument<B> flags</B> is zero or invalid
<DT>ENOMEM
<DD>The amount of memory requested for locking exceeds an allowable limit
<DT>EAGAIN
<DD>Some portion of the memory could not be locked
<DT>EPERM
<DD>The calling process lacks the approriate permissions
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#mlock">mlock</A>, <A HREF="#munlock">munlock</A>, <A HREF="#munlockall">munlockall</A>
</DL>
<DL>
<DT>Classification:
<DD>POSIX
</DL>
<DL>
<DT>Systems:
<DD>Linux
</DL>
<H2 ID="mmap"> mmap </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;sys/mman.h&gt;</TT>
<BR><TT>void *mmap(void *address, size_t len, int prot, int flags, int fd, off_t offset)</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> mmap</TT> function creates a mapping of a file specified by<B> fd</B> and the process address space, allowing the
file to be accessed via the returned pointer.
<BR><BR>The argument<B> address</B> provides the kernel a &quot;suggestion&quot; as to where to locate the pointer returned
by this function.&nbsp; The argmuent<B> address</B> is normally set to NULL, however.
<BR><BR>The argument<B> len</B> specifies the number of bytes of the file to map.
<BR><BR>The<B> prot</B> argument specifies allowed access, being one of:
<DL>
<DT>PROT_READ
<DD>Data can be read
<DT>PROT_WRITE
<DD>Data can be written
<DT>PROT_EXEC
<DD>Data can be executed
<DT>PROT_NONE
<DD>No access allowed
</DL>
<BR>The<B> flags</B> argument specifies flags related to memory mapping, and may be one or a combination of the following:
<DL>
<DT>MAP_ANONYMOUS
<DD>Don't use an actual file, ignoring<B> fd</B> entirely
<DT>MAP_FIXED
<DD>Use<B> address</B> exactly
<DT>MAP_LOCKED
<DD>Lock the memory contents
<DT>MAP_NORESERVE
<DD>Memory for the file is not reserved in swap
<DT>MAP_POPULATE
<DD>Populate (prefault) page tables
<DT>MAP_PRIVATE
<DD>Changes to the file are private
<DT>MAP_SHARED
<DD>Share changes to the file
</DL>
<BR>An additional flag, MAP_ANON, is an alias for MAP_ANONYMOUS.
<BR>The argument<B> fd</B> is a file descriptor for mapping.&nbsp; It is ignored if MAP_ANONYMOUS is specified.
<BR><BR>The<B> offset</B> argument specifies the offset within the file or device to be mapped, in bytes, at which mapping
will start.
</DL>
<DL>
<DT>Returns:
<DD>If successful, the function will return a pointer to mapped file.&nbsp; Upon failure, the function will return MAP_FAILED,
and errno will be set appropriately.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>EINVAL
<DD>The value of<B> address</B> could not be read or the<B> len</B> is zero, or value of any argument was invalid
<DT>ENOMEM
<DD>Memory could not be allocated
<DT>EOVERFLOW
<DD>An overflow occurred due to the<B> len</B> value
<DT>EPERM
<DD>The memory could not be locked when requested
<DT>EACCES
<DD>Access was denied for the specified<B> fd</B> file descriptor
<DT>.ENODEV
<DD>Memory mapping is unavailable for the requested device
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#munmap">munmap</A>
</DL>
<DL>
<DT>Classification:
<DD>POSIX
</DL>
<DL>
<DT>Systems:
<DD>Linux
</DL>
<H2 ID="modf"> modf </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>double modf( double value, double *iptr );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> modf</TT> function breaks the argument<B> value</B> into integral and fractional parts, each of which has the same
sign as the argument.&nbsp; It stores the integral part as a<TT> double</TT> in the object pointed to by<B> iptr</B>.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> modf</TT> function returns the signed fractional part of<B> value</B>.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#frexp">frexp</A>, <A HREF="#ldexp">ldexp</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; double integral_value, fractional_part;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; fractional_part = modf( 4.5, &amp;integral_value );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%f %f\n&quot;, fractional_part, integral_value );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fractional_part = modf( -4.5, &amp;integral_value );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%f %f\n&quot;, fractional_part, integral_value );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>0.500000 4.000000</TT>
<BR><TT>-0.500000 -4.000000</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD>Math
</DL>
<H2 ID="movedata"> movedata </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>void movedata( unsigned int src_segment,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int src_offset,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int tgt_segment,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int tgt_offset,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t length );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> movedata</TT> function copies<B> length</B> bytes from the far pointer calculated as<TT> (src_segment:src_offset)</TT>
to a target location determined as a far pointer<TT> (tgt_segment:tgt_offset).</TT>
<BR><BR>Overlapping data may not be correctly copied.&nbsp; When the source and target areas may overlap, copy the areas one
character at a time.
<BR><BR>The function is useful to move data when the near address(es) of the source and/or target areas are not known.
</DL>
<DL>
<DT>Returns:
<DD>No value is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#FP_SEG">FP_SEG</A>, <A HREF="#FP_OFF">FP_OFF</A>, <A HREF="#memcpy">memcpy</A>, <A HREF="#segread">segread</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char buffer[14] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '*', 0x17, 'H', 0x17, 'e', 0x17, 'l', 0x17,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'l', 0x17, 'o', 0x17, '*', 0x17 };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; movedata( FP_SEG( buffer ),</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FP_OFF( buffer ),</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xB800,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x0720,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 14 );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="_moveto"> _moveto, _moveto_w </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>struct xycoord _FAR _moveto( short x, short y );</TT>
<BR><BR><TT>struct _wxycoord _FAR _moveto_w( double x, double y );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _moveto</TT> functions set the current output position for graphics.&nbsp; The<TT> _moveto</TT> function uses the
view coordinate system.&nbsp; The<TT> _moveto_w</TT> function uses the window coordinate system.
<BR><BR>The current output position is set to be the point at the coordinates<TT> (x,y).</TT>&nbsp; Nothing is drawn by the
function.&nbsp; The <TT> _lineto</TT> function uses the current output position as the starting point when a line is drawn.
<BR><BR>Note that the output position for graphics output differs from that for text output.&nbsp; The output position for
text output can be set by use of the <TT> _settextposition</TT> function.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _moveto</TT> functions return the previous value of the output position for graphics.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getcurrentposition">_getcurrentposition</A>, <A HREF="#_lineto">_lineto</A>, <A HREF="#_settextposition">_settextposition</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _moveto( 100, 100 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _lineto( 540, 100 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _lineto( 320, 380 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _lineto( 100, 100 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD><TT> _moveto - DOS</TT>
<BR><BR><TT>_moveto_w - DOS</TT>
</DL>
<H2 ID="_m_packssdw"> _m_packssdw </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><TT>__m64 _m_packssdw(__m64 *m1, __m64 *m2);</TT>
</DL>
<DL>
<DT>Description:
<DD>Convert signed packed double-words into signed packed words by packing (with signed saturation) the low-order words of the
signed double-word elements from<B> m1</B> and<B> m2</B> into the respective signed words of the result.&nbsp; If the signed
values in the word elements of<B> m1</B> and<B> m2</B> are smaller than 0x8000, the result elements are clamped to 0x8000.
&nbsp;If the signed values in the word elements of<B> m1</B> and<B> m2</B> are larger than 0x7fff, the result elements are
clamped to 0x7fff.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ---------------------&nbsp;&nbsp; ---------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; | w3 : w2 | w1 : w0 |&nbsp;&nbsp; | w3 : w2 | w1 : w0 |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ---------------------&nbsp;&nbsp; ---------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; `--------.`---.&nbsp;&nbsp;&nbsp;&nbsp; .---'.--------'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;
&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; V&nbsp;
&nbsp; V&nbsp;&nbsp;&nbsp;&nbsp; V&nbsp;&nbsp;&nbsp; V</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ---------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | w3 | w2 | w1 |
w0 |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ---------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; result</TT>
</DL>
<DL>
<DT>Returns:
<DD>The result of packing, with signed saturation, 32-bit signed double-words into 16-bit signed words is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_m_empty">_m_empty</A>, <A HREF="#_m_packsswb">_m_packsswb</A>, <A HREF="#_m_packuswb">_m_packuswb</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><BR><TT>#define AS_BYTES &quot;%2.2x %2.2x %2.2x %2.2x &quot; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;%2.2x %2.2x
%2.2x %2.2x&quot;</TT>
<BR><TT>#define AS_WORDS &quot;%4.4x %4.4x %4.4x %4.4x&quot;</TT>
<BR><TT>#define AS_DWORDS &quot;%8.8lx %8.8lx&quot;</TT>
<BR><BR><TT>__m64&nbsp;&nbsp; a;</TT>
<BR><TT>__m64&nbsp;&nbsp; b = { 0x0000567800001234 };</TT>
<BR><TT>__m64&nbsp;&nbsp; c = { 0xfffffffe00010101 };</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; a = _m_packssdw( b, c );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;m2=&quot;AS_DWORDS&quot; &quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m1=&quot;AS_DWORDS&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_WORDS&quot;\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._32[1], c._32[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._32[1], b._32[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._16[3], a._16[2], a._16[1], a._16[0] );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>m2=fffffffe 00010101 m1=00005678 00001234</TT>
<BR><TT>mm=fffe 7fff 5678 1234</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="_m_packsswb"> _m_packsswb </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><TT>__m64 _m_packsswb(__m64 *m1, __m64 *m2);</TT>
</DL>
<DL>
<DT>Description:
<DD>Convert signed packed words into signed packed bytes by packing (with signed saturation) the low-order bytes of the signed
word elements from<B> m1</B> and<B> m2</B> into the respective signed bytes of the result.&nbsp; If the signed values in the
word elements of<B> m1</B> and<B> m2</B> are smaller than 0x80, the result elements are clamped to 0x80.&nbsp; If the signed
values in the word elements of<B> m1</B> and<B> m2</B> are larger than 0x7f, the result elements are clamped to 0x7f.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m2&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -------------------------&nbsp; -------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |b7 b6|b5 b4|b3 b2|b1 b0|&nbsp; |b7 b6|b5 b4|b3 b2|b1 b0|</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -------------------------&nbsp; -------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;
&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;
&nbsp;|</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;
&nbsp;`--.&nbsp; .--'&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; `-----.&nbsp; |&nbsp;
|&nbsp; .-----'&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; `--------.&nbsp; |&nbsp; |&nbsp; |&nbsp; |&nbsp;
.--------'&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; `-----------.&nbsp; |&nbsp; |&nbsp; |&nbsp; |&nbsp; |&nbsp; |&nbsp; .-----------'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|&nbsp; |&nbsp; |&nbsp; |&nbsp; |&nbsp; |&nbsp; |&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
V&nbsp; V&nbsp; V&nbsp; V&nbsp; V&nbsp; V&nbsp; V&nbsp; V</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |b7|b6|b5|b4|b3|b2|b1|b0|</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; result</TT>
</DL>
<DL>
<DT>Returns:
<DD>The result of packing, with signed saturation, 16-bit signed words into 8-bit signed bytes is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_m_empty">_m_empty</A>, <A HREF="#_m_packssdw">_m_packssdw</A>, <A HREF="#_m_packuswb">_m_packuswb</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><BR><TT>#define AS_BYTES &quot;%2.2x %2.2x %2.2x %2.2x &quot; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;%2.2x %2.2x
%2.2x %2.2x&quot;</TT>
<BR><TT>#define AS_WORDS &quot;%4.4x %4.4x %4.4x %4.4x&quot;</TT>
<BR><TT>#define AS_DWORDS &quot;%8.8lx %8.8lx&quot;</TT>
<BR><BR><TT>__m64&nbsp;&nbsp; a;</TT>
<BR><TT>__m64&nbsp;&nbsp; b = { 0x0004000300020001 };</TT>
<BR><TT>__m64&nbsp;&nbsp; c = { 0xff7fff800080007f };</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; a = _m_packsswb( b, c );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;m2=&quot;AS_WORDS&quot; &quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m1=&quot;AS_WORDS&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_BYTES&quot;\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._16[3], c._16[2], c._16[1], c._16[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._16[3], b._16[2], b._16[1], b._16[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._8[7], a._8[6], a._8[5], a._8[4],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._8[3], a._8[2], a._8[1], a._8[0] );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>m2=ff7f ff80 0080 007f m1=0004 0003 0002 0001</TT>
<BR><TT>mm=80 80 7f 7f 04 03 02 01</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="_m_packuswb"> _m_packuswb </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><TT>__m64 _m_packuswb(__m64 *m1, __m64 *m2);</TT>
</DL>
<DL>
<DT>Description:
<DD>Convert signed packed words into unsigned packed bytes by packing (with unsigned saturation) the low-order bytes of the signed
word elements from<B> m1</B> and<B> m2</B> into the respective unsigned bytes of the result.&nbsp; If the signed values in
the word elements of<B> m1</B> and<B> m2</B> are too large to be represented in an unsigned byte, the result elements are
clamped to 0xff.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m2&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -------------------------&nbsp; -------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |b7 b6|b5 b4|b3 b2|b1 b0|&nbsp; |b7 b6|b5 b4|b3 b2|b1 b0|</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -------------------------&nbsp; -------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;
&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;
&nbsp;|</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;
&nbsp;`--.&nbsp; .--'&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; `-----.&nbsp; |&nbsp;
|&nbsp; .-----'&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; `--------.&nbsp; |&nbsp; |&nbsp; |&nbsp; |&nbsp;
.--------'&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; `-----------.&nbsp; |&nbsp; |&nbsp; |&nbsp; |&nbsp; |&nbsp; |&nbsp; .-----------'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|&nbsp; |&nbsp; |&nbsp; |&nbsp; |&nbsp; |&nbsp; |&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
V&nbsp; V&nbsp; V&nbsp; V&nbsp; V&nbsp; V&nbsp; V&nbsp; V</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |b7|b6|b5|b4|b3|b2|b1|b0|</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; result</TT>
</DL>
<DL>
<DT>Returns:
<DD>The result of packing, with unsigned saturation, 16-bit signed words into 8-bit unsigned bytes is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_m_empty">_m_empty</A>, <A HREF="#_m_packssdw">_m_packssdw</A>, <A HREF="#_m_packsswb">_m_packsswb</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><BR><TT>#define AS_BYTES &quot;%2.2x %2.2x %2.2x %2.2x &quot; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;%2.2x %2.2x
%2.2x %2.2x&quot;</TT>
<BR><TT>#define AS_WORDS &quot;%4.4x %4.4x %4.4x %4.4x&quot;</TT>
<BR><TT>#define AS_DWORDS &quot;%8.8lx %8.8lx&quot;</TT>
<BR><BR><TT>__m64&nbsp;&nbsp; a;</TT>
<BR><TT>__m64&nbsp;&nbsp; b = { 0x0004000300020001 };</TT>
<BR><TT>__m64&nbsp;&nbsp; c = { 0xff7fff800080007f };</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; a = _m_packuswb( b, c );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;m2=&quot;AS_WORDS&quot; &quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m1=&quot;AS_WORDS&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_BYTES&quot;\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._16[3], c._16[2], c._16[1], c._16[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._16[3], b._16[2], b._16[1], b._16[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._8[7], a._8[6], a._8[5], a._8[4],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._8[3], a._8[2], a._8[1], a._8[0] );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>m2=ff7f ff80 0080 007f m1=0004 0003 0002 0001</TT>
<BR><TT>mm=00 00 80 7f 04 03 02 01</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="_m_paddb"> _m_paddb </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><TT>__m64 _m_paddb(__m64 *m1, __m64 *m2);</TT>
</DL>
<DL>
<DT>Description:
<DD>The signed or unsigned 8-bit bytes of<B> m2</B> are added to the respective signed or unsigned 8-bit bytes of<B> m1</B> and
the result is stored in memory.&nbsp; If any result element does not fit into 8 bits (overflow), the lower 8 bits of the result
elements are stored (i.e., truncation takes place).
</DL>
<DL>
<DT>Returns:
<DD>The result of adding the packed bytes of two 64-bit multimedia values is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_m_empty">_m_empty</A>, <A HREF="#_m_paddd">_m_paddd</A>, <A HREF="#_m_paddsb">_m_paddsb</A>, <A HREF="#_m_paddsw">_m_paddsw</A>,
<A HREF="#_m_paddusb">_m_paddusb</A>, <A HREF="#_m_paddusw">_m_paddusw</A>, <A HREF="#_m_paddw">_m_paddw</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><BR><TT>#define AS_BYTES &quot;%2.2x %2.2x %2.2x %2.2x &quot; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;%2.2x %2.2x
%2.2x %2.2x&quot;</TT>
<BR><BR><TT>__m64&nbsp;&nbsp; a;</TT>
<BR><TT>__m64&nbsp;&nbsp; b = { 0x0123456789abcdef };</TT>
<BR><TT>__m64&nbsp;&nbsp; c = { 0xfedcba9876543210 };</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; a = _m_paddb( b, c );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_BYTES&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_BYTES&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_BYTES&quot;\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._8[7], b._8[6], b._8[5], b._8[4],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._8[3], b._8[2], b._8[1], b._8[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._8[7], c._8[6], c._8[5], c._8[4],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._8[3], c._8[2], c._8[1], c._8[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._8[7], a._8[6], a._8[5], a._8[4],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._8[3], a._8[2], a._8[1], a._8[0] );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>m1=01 23 45 67 89 ab cd ef</TT>
<BR><TT>m2=fe dc ba 98 76 54 32 10</TT>
<BR><TT>mm=ff ff ff ff ff ff ff ff</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="_m_paddd"> _m_paddd </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><TT>__m64 _m_paddd(__m64 *m1, __m64 *m2);</TT>
</DL>
<DL>
<DT>Description:
<DD>The signed or unsigned 32-bit double-words of<B> m2</B> are added to the respective signed or unsigned 32-bit double-words
of<B> m1</B> and the result is stored in memory.&nbsp; If any result element does not fit into 32 bits (overflow), the lower
32-bits of the result elements are stored (i.e., truncation takes place).
</DL>
<DL>
<DT>Returns:
<DD>The result of adding the packed double-words of two 64-bit multimedia values is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_m_empty">_m_empty</A>, <A HREF="#_m_paddb">_m_paddb</A>, <A HREF="#_m_paddsb">_m_paddsb</A>, <A HREF="#_m_paddsw">_m_paddsw</A>,
<A HREF="#_m_paddusb">_m_paddusb</A>, <A HREF="#_m_paddusw">_m_paddusw</A>, <A HREF="#_m_paddw">_m_paddw</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><BR><TT>#define AS_DWORDS &quot;%8.8lx %8.8lx&quot;</TT>
<BR><BR><TT>__m64&nbsp;&nbsp; a;</TT>
<BR><TT>__m64&nbsp;&nbsp; b = { 0x0123456789abcdef };</TT>
<BR><TT>__m64&nbsp;&nbsp; c = { 0xfedcba9876543210 };</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; a = _m_paddd( b, c );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_DWORDS&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_DWORDS&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_DWORDS&quot;\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._32[1], b._32[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._32[1], c._32[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._32[1], a._32[0] );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>m1=01234567 89abcdef</TT>
<BR><TT>m2=fedcba98 76543210</TT>
<BR><TT>mm=ffffffff ffffffff</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="_m_paddsb"> _m_paddsb </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><TT>__m64 _m_paddsb(__m64 *m1, __m64 *m2);</TT>
</DL>
<DL>
<DT>Description:
<DD>The signed 8-bit bytes of<B> m2</B> are added to the respective signed 8-bit bytes of<B> m1</B> and the result is stored in
memory.&nbsp; Saturation occurs when a result exceeds the range of a signed byte.&nbsp; In the case where a result is a byte
larger than 0x7f (overflow), it is clamped to 0x7f.&nbsp; In the case where a result is a byte smaller than 0x80 (underflow),
it is clamped to 0x80.
</DL>
<DL>
<DT>Returns:
<DD>The result of adding the packed signed bytes, with saturation, of two 64-bit multimedia values is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_m_empty">_m_empty</A>, <A HREF="#_m_paddb">_m_paddb</A>, <A HREF="#_m_paddd">_m_paddd</A>, <A HREF="#_m_paddsw">_m_paddsw</A>,
<A HREF="#_m_paddusb">_m_paddusb</A>, <A HREF="#_m_paddusw">_m_paddusw</A>, <A HREF="#_m_paddw">_m_paddw</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><BR><TT>#define AS_BYTES &quot;%2.2x %2.2x %2.2x %2.2x &quot; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;%2.2x %2.2x
%2.2x %2.2x&quot;</TT>
<BR><BR><TT>__m64&nbsp;&nbsp; a;</TT>
<BR><TT>__m64&nbsp;&nbsp; b = { 0x8aacceef02244668 };</TT>
<BR><TT>__m64&nbsp;&nbsp; c = { 0x76543211fedcba98 };</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; a = _m_paddsb( b, c );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_BYTES&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_BYTES&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_BYTES&quot;\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._8[7], b._8[6], b._8[5], b._8[4],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._8[3], b._8[2], b._8[1], b._8[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._8[7], c._8[6], c._8[5], c._8[4],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._8[3], c._8[2], c._8[1], c._8[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._8[7], a._8[6], a._8[5], a._8[4],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._8[3], a._8[2], a._8[1], a._8[0] );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>m1=8a ac ce ef 02 24 46 68</TT>
<BR><TT>m2=76 54 32 11 fe dc ba 98</TT>
<BR><TT>mm=00 00 00 00 00 00 00 00</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="_m_paddsw"> _m_paddsw </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><TT>__m64 _m_paddsw(__m64 *m1, __m64 *m2);</TT>
</DL>
<DL>
<DT>Description:
<DD>The signed 16-bit words of<B> m2</B> are added to the respective signed 16-bit words of<B> m1</B> and the result is stored
in memory.&nbsp; Saturation occurs when a result exceeds the range of a signed word.&nbsp; In the case where a result is a
word larger than 0x7fff (overflow), it is clamped to 0x7fff.&nbsp; In the case where a result is a word smaller than 0x8000
(underflow), it is clamped to 0x8000.
</DL>
<DL>
<DT>Returns:
<DD>The result of adding the packed signed words, with saturation, of two 64-bit multimedia values is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_m_empty">_m_empty</A>, <A HREF="#_m_paddb">_m_paddb</A>, <A HREF="#_m_paddd">_m_paddd</A>, <A HREF="#_m_paddsb">_m_paddsb</A>,
<A HREF="#_m_paddusb">_m_paddusb</A>, <A HREF="#_m_paddusw">_m_paddusw</A>, <A HREF="#_m_paddw">_m_paddw</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><BR><TT>#define AS_WORDS &quot;%4.4x %4.4x %4.4x %4.4x&quot;</TT>
<BR><BR><TT>__m64&nbsp;&nbsp; a;</TT>
<BR><TT>__m64&nbsp;&nbsp; b = { 0x8aacceef02244668 };</TT>
<BR><TT>__m64&nbsp;&nbsp; c = { 0x76543211fedcba98 };</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; a = _m_paddsw( b, c );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_WORDS&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_WORDS&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_WORDS&quot;\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._16[3], b._16[2], b._16[1], b._16[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._16[3], c._16[2], c._16[1], c._16[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._16[3], a._16[2], a._16[1], a._16[0] );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>m1=8aac ceef 0224 4668</TT>
<BR><TT>m2=7654 3211 fedc ba98</TT>
<BR><TT>mm=0100 0100 0100 0100</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="_m_paddusb"> _m_paddusb </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><TT>__m64 _m_paddusb(__m64 *m1, __m64 *m2);</TT>
</DL>
<DL>
<DT>Description:
<DD>The unsigned 8-bit bytes of<B> m2</B> are added to the respective unsigned 8-bit bytes of<B> m1</B> and the result is stored
in memory.&nbsp; Saturation occurs when a result exceeds the range of an unsigned byte.&nbsp; In the case where a result is
a byte larger than 0xff (overflow), it is clamped to 0xff.
</DL>
<DL>
<DT>Returns:
<DD>The result of adding the packed unsigned bytes, with saturation, of two 64-bit multimedia values is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_m_empty">_m_empty</A>, <A HREF="#_m_paddb">_m_paddb</A>, <A HREF="#_m_paddd">_m_paddd</A>, <A HREF="#_m_paddsb">_m_paddsb</A>,
<A HREF="#_m_paddsw">_m_paddsw</A>, <A HREF="#_m_paddusw">_m_paddusw</A>, <A HREF="#_m_paddw">_m_paddw</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><BR><TT>#define AS_BYTES &quot;%2.2x %2.2x %2.2x %2.2x &quot; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;%2.2x %2.2x
%2.2x %2.2x&quot;</TT>
<BR><BR><TT>__m64&nbsp;&nbsp; a;</TT>
<BR><TT>__m64&nbsp;&nbsp; b = { 0x8aacceef02244668 };</TT>
<BR><TT>__m64&nbsp;&nbsp; c = { 0x76543211fedcba98 };</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; a = _m_paddusb( b, c );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_BYTES&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_BYTES&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_BYTES&quot;\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._8[7], b._8[6], b._8[5], b._8[4],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._8[3], b._8[2], b._8[1], b._8[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._8[7], c._8[6], c._8[5], c._8[4],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._8[3], c._8[2], c._8[1], c._8[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._8[7], a._8[6], a._8[5], a._8[4],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._8[3], a._8[2], a._8[1], a._8[0] );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>m1=8a ac ce ef 02 24 46 68</TT>
<BR><TT>m2=76 54 32 11 fe dc ba 98</TT>
<BR><TT>mm=ff ff ff ff ff ff ff ff</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="_m_paddusw"> _m_paddusw </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><TT>__m64 _m_paddusw(__m64 *m1, __m64 *m2);</TT>
</DL>
<DL>
<DT>Description:
<DD>The unsigned 16-bit words of<B> m2</B> are added to the respective unsigned 16-bit words of<B> m1</B> and the result is stored
in memory.&nbsp; Saturation occurs when a result exceeds the range of an unsigned word.&nbsp; In the case where a result is
a word larger than 0xffff (overflow), it is clamped to 0xffff.
</DL>
<DL>
<DT>Returns:
<DD>The result of adding the packed unsigned words, with saturation, of two 64-bit multimedia values is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_m_empty">_m_empty</A>, <A HREF="#_m_paddb">_m_paddb</A>, <A HREF="#_m_paddd">_m_paddd</A>, <A HREF="#_m_paddsb">_m_paddsb</A>,
<A HREF="#_m_paddsw">_m_paddsw</A>, <A HREF="#_m_paddusb">_m_paddusb</A>, <A HREF="#_m_paddw">_m_paddw</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><BR><TT>#define AS_WORDS &quot;%4.4x %4.4x %4.4x %4.4x&quot;</TT>
<BR><BR><TT>__m64&nbsp;&nbsp; a;</TT>
<BR><TT>__m64&nbsp;&nbsp; b = { 0x8aacceef02244668 };</TT>
<BR><TT>__m64&nbsp;&nbsp; c = { 0x76543211fedcba98 };</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; a = _m_paddusw( b, c );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_WORDS&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_WORDS&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_WORDS&quot;\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._16[3], b._16[2], b._16[1], b._16[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._16[3], c._16[2], c._16[1], c._16[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._16[3], a._16[2], a._16[1], a._16[0] );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>m1=8aac ceef 0224 4668</TT>
<BR><TT>m2=7654 3211 fedc ba98</TT>
<BR><TT>mm=ffff ffff ffff ffff</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="_m_paddw"> _m_paddw </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><TT>__m64 _m_paddw(__m64 *m1, __m64 *m2);</TT>
</DL>
<DL>
<DT>Description:
<DD>The signed or unsigned 16-bit words of<B> m2</B> are added to the respective signed or unsigned 16-bit words of<B> m1</B>
and the result is stored in memory.&nbsp; If any result element does not fit into 16 bits (overflow), the lower 16 bits of
the result elements are stored (i.e., truncation takes place).
</DL>
<DL>
<DT>Returns:
<DD>The result of adding the packed words of two 64-bit multimedia values is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_m_empty">_m_empty</A>, <A HREF="#_m_paddb">_m_paddb</A>, <A HREF="#_m_paddd">_m_paddd</A>, <A HREF="#_m_paddsb">_m_paddsb</A>,
<A HREF="#_m_paddsw">_m_paddsw</A>, <A HREF="#_m_paddusb">_m_paddusb</A>, <A HREF="#_m_paddusw">_m_paddusw</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><BR><TT>#define AS_WORDS &quot;%4.4x %4.4x %4.4x %4.4x&quot;</TT>
<BR><BR><TT>__m64&nbsp;&nbsp; a;</TT>
<BR><TT>__m64&nbsp;&nbsp; b = { 0x0123456789abcdef };</TT>
<BR><TT>__m64&nbsp;&nbsp; c = { 0xfedcba9876543210 };</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; a = _m_paddw( b, c );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_WORDS&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_WORDS&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_WORDS&quot;\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._16[3], b._16[2], b._16[1], b._16[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._16[3], c._16[2], c._16[1], c._16[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._16[3], a._16[2], a._16[1], a._16[0] );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>m1=0123 4567 89ab cdef</TT>
<BR><TT>m2=fedc ba98 7654 3210</TT>
<BR><TT>mm=ffff ffff ffff ffff</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="_m_pand"> _m_pand </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><TT>__m64 _m_pand(__m64 *m1, __m64 *m2);</TT>
</DL>
<DL>
<DT>Description:
<DD>A bit-wise logical AND is performed between 64-bit multimedia operands<B> m1</B> and<B> m2</B> and the result is stored in
memory.
</DL>
<DL>
<DT>Returns:
<DD>The bit-wise logical AND of two 64-bit values is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_m_empty">_m_empty</A>, <A HREF="#_m_pandn">_m_pandn</A>, <A HREF="#_m_por">_m_por</A>, <A HREF="#_m_pxor">_m_pxor</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><BR><TT>#define AS_QWORD &quot;%16.16Lx&quot;</TT>
<BR><BR><TT>__m64&nbsp;&nbsp; a;</TT>
<BR><TT>__m64&nbsp;&nbsp; b = { 0x0123456789abcdef };</TT>
<BR><TT>__m64&nbsp;&nbsp; c = { 0xfedcba9876543210 };</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; a = _m_pand( b, c );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_QWORD&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_QWORD&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_QWORD&quot;\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b, c, a );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>m1=0123456789abcdef</TT>
<BR><TT>m2=fedcba9876543210</TT>
<BR><TT>mm=0000000000000000</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="_m_pandn"> _m_pandn </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><TT>__m64 _m_pandn(__m64 *m1, __m64 *m2);</TT>
</DL>
<DL>
<DT>Description:
<DD>A bit-wise logical AND is performed on the logical inversion of 64-bit multimedia operand<B> m1</B> and 64-bit multimedia
operand<B> m2</B> and the result is stored in memory.
</DL>
<DL>
<DT>Returns:
<DD>The bit-wise logical AND of an inverted 64-bit value and a non-inverted value is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_m_empty">_m_empty</A>, <A HREF="#_m_pand">_m_pand</A>, <A HREF="#_m_por">_m_por</A>, <A HREF="#_m_pxor">_m_pxor</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><BR><TT>#define AS_QWORD &quot;%16.16Lx&quot;</TT>
<BR><BR><TT>__m64&nbsp;&nbsp; a;</TT>
<BR><TT>__m64&nbsp;&nbsp; b = { 0x0123456789abcdef };</TT>
<BR><TT>__m64&nbsp;&nbsp; c = { 0xfedcba9876543210 };</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; a = _m_pandn( b, c );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_QWORD&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_QWORD&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_QWORD&quot;\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b, c, a );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>m1=0123456789abcdef</TT>
<BR><TT>m2=fedcba9876543210</TT>
<BR><TT>mm=fedcba9876543210</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="_m_pcmpeqb"> _m_pcmpeqb </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><TT>__m64 _m_pcmpeqb(__m64 *m1, __m64 *m2);</TT>
</DL>
<DL>
<DT>Description:
<DD>If the respective bytes of<B> m1</B> are equal to the respective bytes of<B> m2</B>, the respective bytes of the result are
set to all ones, otherwise they are set to all zeros.
</DL>
<DL>
<DT>Returns:
<DD>The result of comparing the packed bytes of two 64-bit multimedia values is returned as a sequence of bytes (0xff for equal,
0x00 for not equal).
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_m_empty">_m_empty</A>, <A HREF="#_m_pcmpeqd">_m_pcmpeqd</A>, <A HREF="#_m_pcmpeqw">_m_pcmpeqw</A>, <A HREF="#_m_pcmpgtb">_m_pcmpgtb</A>,
<A HREF="#_m_pcmpgtd">_m_pcmpgtd</A>, <A HREF="#_m_pcmpgtw">_m_pcmpgtw</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><BR><TT>#define AS_BYTES &quot;%2.2x %2.2x %2.2x %2.2x &quot; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;%2.2x %2.2x
%2.2x %2.2x&quot;</TT>
<BR><BR><TT>__m64&nbsp;&nbsp; a;</TT>
<BR><TT>__m64&nbsp;&nbsp; b = { 0x0004000300020001 };</TT>
<BR><TT>__m64&nbsp;&nbsp; c = { 0xff7fff800080007f };</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; a = _m_pcmpeqb( b, c );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_BYTES&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_BYTES&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_BYTES&quot;\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._8[7], b._8[6], b._8[5], b._8[4],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._8[3], b._8[2], b._8[1], b._8[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._8[7], c._8[6], c._8[5], c._8[4],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._8[3], c._8[2], c._8[1], c._8[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._8[7], a._8[6], a._8[5], a._8[4],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._8[3], a._8[2], a._8[1], a._8[0] );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>m1=00 04 00 03 00 02 00 01</TT>
<BR><TT>m2=ff 7f ff 80 00 80 00 7f</TT>
<BR><TT>mm=00 00 00 00 ff 00 ff 00</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="_m_pcmpeqd"> _m_pcmpeqd </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><TT>__m64 _m_pcmpeqd(__m64 *m1, __m64 *m2);</TT>
</DL>
<DL>
<DT>Description:
<DD>If the respective double-words of<B> m1</B> are equal to the respective double-words of<B> m2</B>, the respective double-words
of the result are set to all ones, otherwise they are set to all zeros.
</DL>
<DL>
<DT>Returns:
<DD>The result of comparing the 32-bit packed double-words of two 64-bit multimedia values is returned as a sequence of double-words
(0xffffffff for equal, 0x00000000 for not equal).
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_m_empty">_m_empty</A>, <A HREF="#_m_pcmpeqb">_m_pcmpeqb</A>, <A HREF="#_m_pcmpeqw">_m_pcmpeqw</A>, <A HREF="#_m_pcmpgtb">_m_pcmpgtb</A>,
<A HREF="#_m_pcmpgtd">_m_pcmpgtd</A>, <A HREF="#_m_pcmpgtw">_m_pcmpgtw</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><BR><TT>#define AS_DWORDS &quot;%8.8lx %8.8lx&quot;</TT>
<BR><BR><TT>__m64&nbsp;&nbsp; a;</TT>
<BR><TT>__m64&nbsp;&nbsp; b = { 0x0004000300020001 };</TT>
<BR><TT>__m64&nbsp;&nbsp; c = { 0x000400030002007f };</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; a = _m_pcmpeqd( b, c );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_DWORDS&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_DWORDS&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_DWORDS&quot;\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._32[1], b._32[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._32[1], c._32[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._32[1], a._32[0] );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>m1=00040003 00020001</TT>
<BR><TT>m2=00040003 0002007f</TT>
<BR><TT>mm=ffffffff 00000000</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="_m_pcmpeqw"> _m_pcmpeqw </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><TT>__m64 _m_pcmpeqw(__m64 *m1, __m64 *m2);</TT>
</DL>
<DL>
<DT>Description:
<DD>If the respective words of<B> m1</B> are equal to the respective words of<B> m2</B>, the respective words of the result are
set to all ones, otherwise they are set to all zeros.
</DL>
<DL>
<DT>Returns:
<DD>The result of comparing the packed words of two 64-bit multimedia values is returned as a sequence of words (0xffff for equal,
0x0000 for not equal).
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_m_empty">_m_empty</A>, <A HREF="#_m_pcmpeqb">_m_pcmpeqb</A>, <A HREF="#_m_pcmpeqd">_m_pcmpeqd</A>, <A HREF="#_m_pcmpgtb">_m_pcmpgtb</A>,
<A HREF="#_m_pcmpgtd">_m_pcmpgtd</A>, <A HREF="#_m_pcmpgtw">_m_pcmpgtw</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><BR><TT>#define AS_WORDS &quot;%4.4x %4.4x %4.4x %4.4x&quot;</TT>
<BR><BR><TT>__m64&nbsp;&nbsp; a;</TT>
<BR><TT>__m64&nbsp;&nbsp; b = { 0x0004000300020001 };</TT>
<BR><TT>__m64&nbsp;&nbsp; c = { 0x0004ff8000800001 };</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; a = _m_pcmpeqw( b, c );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_WORDS&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_WORDS&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_WORDS&quot;\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._16[3], b._16[2], b._16[1], b._16[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._16[3], c._16[2], c._16[1], c._16[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._16[3], a._16[2], a._16[1], a._16[0] );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>m1=0004 0003 0002 0001</TT>
<BR><TT>m2=0004 ff80 0080 0001</TT>
<BR><TT>mm=ffff 0000 0000 ffff</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="_m_pcmpgtb"> _m_pcmpgtb </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><TT>__m64 _m_pcmpgtb(__m64 *m1, __m64 *m2);</TT>
</DL>
<DL>
<DT>Description:
<DD>If the respective signed bytes of<B> m1</B> are greater than the respective signed bytes of<B> m2</B>, the respective bytes
of the result are set to all ones, otherwise they are set to all zeros.
</DL>
<DL>
<DT>Returns:
<DD>The result of comparing the packed signed bytes of two 64-bit multimedia values is returned as a sequence of bytes (0xff for
greater than, 0x00 for not greater than).
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_m_empty">_m_empty</A>, <A HREF="#_m_pcmpeqb">_m_pcmpeqb</A>, <A HREF="#_m_pcmpeqd">_m_pcmpeqd</A>, <A HREF="#_m_pcmpeqw">_m_pcmpeqw</A>,
<A HREF="#_m_pcmpgtd">_m_pcmpgtd</A>, <A HREF="#_m_pcmpgtw">_m_pcmpgtw</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><BR><TT>#define AS_BYTES &quot;%2.2x %2.2x %2.2x %2.2x &quot; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;%2.2x %2.2x
%2.2x %2.2x&quot;</TT>
<BR><BR><TT>__m64&nbsp;&nbsp; a;</TT>
<BR><TT>__m64&nbsp;&nbsp; b = { 0x0004000300020001 };</TT>
<BR><TT>__m64&nbsp;&nbsp; c = { 0xff7fff800080007f };</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; a = _m_pcmpgtb( b, c );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_BYTES&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_BYTES&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_BYTES&quot;\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._8[7], b._8[6], b._8[5], b._8[4],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._8[3], b._8[2], b._8[1], b._8[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._8[7], c._8[6], c._8[5], c._8[4],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._8[3], c._8[2], c._8[1], c._8[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._8[7], a._8[6], a._8[5], a._8[4],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._8[3], a._8[2], a._8[1], a._8[0] );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>m1=00 04 00 03 00 02 00 01</TT>
<BR><TT>m2=ff 7f ff 80 00 80 00 7f</TT>
<BR><TT>mm=ff 00 ff ff 00 ff 00 00</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="_m_pcmpgtd"> _m_pcmpgtd </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><TT>__m64 _m_pcmpgtd(__m64 *m1, __m64 *m2);</TT>
</DL>
<DL>
<DT>Description:
<DD>If the respective signed double-words of<B> m1</B> are greater than the respective signed double-words of<B> m2</B>, the respective
double-words of the result are set to all ones, otherwise they are set to all zeros.
</DL>
<DL>
<DT>Returns:
<DD>The result of comparing the 32-bit packed signed double-words of two 64-bit multimedia values is returned as a sequence of
double-words (0xffffffff for greater than, 0x00000000 for not greater than).
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_m_empty">_m_empty</A>, <A HREF="#_m_pcmpeqb">_m_pcmpeqb</A>, <A HREF="#_m_pcmpeqd">_m_pcmpeqd</A>, <A HREF="#_m_pcmpeqw">_m_pcmpeqw</A>,
<A HREF="#_m_pcmpgtb">_m_pcmpgtb</A>, <A HREF="#_m_pcmpgtw">_m_pcmpgtw</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><BR><TT>#define AS_DWORDS &quot;%8.8lx %8.8lx&quot;</TT>
<BR><BR><TT>__m64&nbsp;&nbsp; a;</TT>
<BR><TT>__m64&nbsp;&nbsp; b = { 0x0004000400020001 };</TT>
<BR><TT>__m64&nbsp;&nbsp; c = { 0x000400030080007f };</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; a = _m_pcmpgtd( b, c );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_DWORDS&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_DWORDS&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_DWORDS&quot;\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._32[1], b._32[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._32[1], c._32[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._32[1], a._32[0] );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>m1=00040004 00020001</TT>
<BR><TT>m2=00040003 0080007f</TT>
<BR><TT>mm=ffffffff 00000000</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="_m_pcmpgtw"> _m_pcmpgtw </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><TT>__m64 _m_pcmpgtw(__m64 *m1, __m64 *m2);</TT>
</DL>
<DL>
<DT>Description:
<DD>If the respective signed words of<B> m1</B> are greater than the respective signed words of<B> m2</B>, the respective words
of the result are set to all ones, otherwise they are set to all zeros.
</DL>
<DL>
<DT>Returns:
<DD>The result of comparing the 16-bit packed signed words of two 64-bit multimedia values is returned as a sequence of words
(0xffff for greater than, 0x0000 for not greater than).
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_m_empty">_m_empty</A>, <A HREF="#_m_pcmpeqb">_m_pcmpeqb</A>, <A HREF="#_m_pcmpeqd">_m_pcmpeqd</A>, <A HREF="#_m_pcmpeqw">_m_pcmpeqw</A>,
<A HREF="#_m_pcmpgtb">_m_pcmpgtb</A>, <A HREF="#_m_pcmpgtd">_m_pcmpgtd</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><BR><TT>#define AS_WORDS &quot;%4.4x %4.4x %4.4x %4.4x&quot;</TT>
<BR><BR><TT>__m64&nbsp;&nbsp; a;</TT>
<BR><TT>__m64&nbsp;&nbsp; b = { 0x0005000300020001 };</TT>
<BR><TT>__m64&nbsp;&nbsp; c = { 0x0004ff8000800001 };</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; a = _m_pcmpgtw( b, c );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_WORDS&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_WORDS&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_WORDS&quot;\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._16[3], b._16[2], b._16[1], b._16[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._16[3], c._16[2], c._16[1], c._16[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._16[3], a._16[2], a._16[1], a._16[0] );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>m1=0005 0003 0002 0001</TT>
<BR><TT>m2=0004 ff80 0080 0001</TT>
<BR><TT>mm=ffff ffff 0000 0000</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="_m_pmaddwd"> _m_pmaddwd </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><TT>__m64 _m_pmaddwd(__m64 *m1, __m64 *m2);</TT>
</DL>
<DL>
<DT>Description:
<DD>The signed 16-bit words of<B> m1</B> are multiplied with the respective signed 16-bit words of<B> m2</B>.&nbsp; The 32-bit
intermediate results are summed by pairs producing two 32-bit integers.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; MM[63-32] = M1[63-48] x M2[63-48]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + M1[47-32] x M2[47-32]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; MM[31-0]&nbsp; = M1[31-16] x M2[31-16]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + M1[15-0]&nbsp; x M2[15-0]</TT>
<BR><BR>In cases which overflow, the results are truncated.&nbsp; These two integers are packed into their respective elements
of the result.
</DL>
<DL>
<DT>Returns:
<DD>The result of multiplying the packed signed 16-bit words of two 64-bit multimedia values and adding the 32-bit results pairwise
is returned as packed double-words.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_m_empty">_m_empty</A>, <A HREF="#_m_pmulhw">_m_pmulhw</A>, <A HREF="#_m_pmullw">_m_pmullw</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><BR><TT>#define AS_WORDS &quot;%4.4x %4.4x %4.4x %4.4x&quot;</TT>
<BR><TT>#define AS_DWORDS &quot;%8.8lx %8.8lx&quot;</TT>
<BR><BR><TT>__m64&nbsp;&nbsp; a;</TT>
<BR><TT>__m64&nbsp;&nbsp; b = { 0x0000006000123456 };</TT>
<BR><TT>__m64&nbsp;&nbsp; c = { 0x0000000200010020 };</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; a = _m_pmaddwd( b, c );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_WORDS&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_WORDS&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_DWORDS&quot;\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._16[3], b._16[2], b._16[1], b._16[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._16[3], c._16[2], c._16[1], c._16[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._32[1], a._32[0] );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>m1=0000 0060 0012 3456</TT>
<BR><TT>m2=0000 0002 0001 0020</TT>
<BR><TT>mm=000000c0 00068ad2</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="_m_pmulhw"> _m_pmulhw </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><TT>__m64 _m_pmulhw(__m64 *m1, __m64 *m2);</TT>
</DL>
<DL>
<DT>Description:
<DD>The signed 16-bit words of<B> m1</B> are multiplied with the respective signed 16-bit words of<B> m2</B>.&nbsp; The high-order
16-bits of each result are placed in the respective elements of the result.
</DL>
<DL>
<DT>Returns:
<DD>The packed 16-bit words in<B> m1</B> are multiplied with the packed 16-bit words in<B> m2</B> and the high-order 16-bits of
the results are returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_m_empty">_m_empty</A>, <A HREF="#_m_pmaddwd">_m_pmaddwd</A>, <A HREF="#_m_pmullw">_m_pmullw</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><BR><TT>#define AS_WORDS &quot;%4.4x %4.4x %4.4x %4.4x&quot;</TT>
<BR><BR><TT>__m64&nbsp;&nbsp; a;</TT>
<BR><TT>__m64&nbsp;&nbsp; b = { 0x4000006000123456 };</TT>
<BR><TT>__m64&nbsp;&nbsp; c = { 0x0008000210000020 };</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; a = _m_pmulhw( b, c );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_WORDS&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_WORDS&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_WORDS&quot;\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._16[3], b._16[2], b._16[1], b._16[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._16[3], c._16[2], c._16[1], c._16[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._16[3], a._16[2], a._16[1], a._16[0] );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>m1=4000 0060 0012 3456</TT>
<BR><TT>m2=0008 0002 1000 0020</TT>
<BR><TT>mm=0002 0000 0001 0006</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="_m_pmullw"> _m_pmullw </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><TT>__m64 _m_pmullw(__m64 *m1, __m64 *m2);</TT>
</DL>
<DL>
<DT>Description:
<DD>The signed or unsigned 16-bit words of<B> m1</B> are multiplied with the respective signed or unsigned 16-bit words of<B>
m2</B>.&nbsp; The low-order 16-bits of each result are placed in the respective elements of the result.
</DL>
<DL>
<DT>Returns:
<DD>The packed 16-bit words in<B> m1</B> are multiplied with the packed 16-bit words in<B> m2</B> and the low-order 16-bits of
the results are returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_m_empty">_m_empty</A>, <A HREF="#_m_pmaddwd">_m_pmaddwd</A>, <A HREF="#_m_pmulhw">_m_pmulhw</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><BR><TT>#define AS_WORDS &quot;%4.4x %4.4x %4.4x %4.4x&quot;</TT>
<BR><BR><TT>__m64&nbsp;&nbsp; a;</TT>
<BR><TT>__m64&nbsp;&nbsp; b = { 0x4000006000123456 };</TT>
<BR><TT>__m64&nbsp;&nbsp; c = { 0x0008000210000020 };</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; a = _m_pmullw( b, c );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_WORDS&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_WORDS&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_WORDS&quot;\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._16[3], b._16[2], b._16[1], b._16[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._16[3], c._16[2], c._16[1], c._16[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._16[3], a._16[2], a._16[1], a._16[0] );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>m1=4000 0060 0012 3456</TT>
<BR><TT>m2=0008 0002 1000 0020</TT>
<BR><TT>mm=0000 00c0 2000 8ac0</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="_m_por"> _m_por </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><TT>__m64 _m_por(__m64 *m1, __m64 *m2);</TT>
</DL>
<DL>
<DT>Description:
<DD>A bit-wise logical OR is performed between 64-bit multimedia operands<B> m1</B> and<B> m2</B> and the result is stored in
memory.
</DL>
<DL>
<DT>Returns:
<DD>The bit-wise logical OR of two 64-bit values is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_m_empty">_m_empty</A>, <A HREF="#_m_pand">_m_pand</A>, <A HREF="#_m_pandn">_m_pandn</A>, <A HREF="#_m_pxor">_m_pxor</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><BR><TT>#define AS_QWORD &quot;%16.16Lx&quot;</TT>
<BR><BR><TT>__m64&nbsp;&nbsp; a;</TT>
<BR><TT>__m64&nbsp;&nbsp; b = { 0x0123456789abcdef };</TT>
<BR><TT>__m64&nbsp;&nbsp; c = { 0xfedcba9876543210 };</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; a = _m_por( b, c );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_QWORD&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_QWORD&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_QWORD&quot;\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b, c, a );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>m1=0123456789abcdef</TT>
<BR><TT>m2=fedcba9876543210</TT>
<BR><TT>mm=ffffffffffffffff</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="mprotect"> mprotect </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;sys/mman.h&gt;</TT>
<BR><TT>int mprotect(void *address, size_t len, int flags)</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> mprotect</TT> function writes changes the protections for the pages encompassing the memory mapping at<B> address</B>
and measuring<B> len</B> bytes based on the<B> flags</B> argument as specified.
<BR><BR>The<B> flags</B> argument may be one or a combination of the following:
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>PROT_NONE
<DD>No protections
<DT>PROT_READ
<DD>Read only
<DT>PROT_WRITE
<DD>Write only
<DT>PROT_EXEC
<DD>Allow execution
</DL>
<BR>The flags may be either exclusively <TT> PROT_NONE</TT> or a combination of one or more of the remaining three values.
</DL>
<DL>
<DT>Returns:
<DD>If successful, the function will return 0.&nbsp; Upon failure, the function will return -1, and errno will be set appropriately.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>EACCES
<DD>The value of<B> flags</B> violates a the permissions that a process has to the mapped data.
<DT>EAGAIN
<DD>Write access was requested when the memory was originally mapped with the <TT> MAP_PRIVATE</TT> flag and the system lacks
the resources to create a private page.
<DT>EINVAL
<DD>The argument<B> address</B> is not a multiple of the page size or the<B> flags</B> argument is invalid
<DT>ENOMEM
<DD>The arguments do not correspond to a region of the process's address space or exceed the process's address space
<DT>ENOTSUP
<DD>The specified combination of<B> flags</B> is not supported on the underlying system
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#mmap">mmap</A>
</DL>
<DL>
<DT>Classification:
<DD>POSIX
</DL>
<DL>
<DT>Systems:
<DD>Linux
</DL>
<H2 ID="_m_pslld"> _m_pslld </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><TT>__m64 _m_pslld(__m64 *m, __m64 *count);</TT>
</DL>
<DL>
<DT>Description:
<DD>The 32-bit double-words in<B> m</B> are each independently shifted to the left by the scalar shift count in<B> count</B>.
&nbsp;The low-order bits of each element are filled with zeros.&nbsp; The shift count is interpreted as unsigned.&nbsp; Shift
counts greater than 31 yield all zeros.
</DL>
<DL>
<DT>Returns:
<DD>Shift left each 32-bit double-word in<B> m</B> by an amount specified in<B> count</B> while shifting in zeros.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_m_empty">_m_empty</A>, <A HREF="#_m_pslldi">_m_pslldi</A>, <A HREF="#_m_psllq">_m_psllq</A>, <A HREF="#_m_psllqi">_m_psllqi</A>,
<A HREF="#_m_psllw">_m_psllw</A>, <A HREF="#_m_psllwi">_m_psllwi</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><BR><TT>#define AS_DWORDS &quot;%8.8lx %8.8lx&quot;</TT>
<BR><TT>#define AS_QWORD &quot;%16.16Lx&quot;</TT>
<BR><BR><TT>__m64&nbsp;&nbsp; a;</TT>
<BR><TT>__m64&nbsp;&nbsp; b = { 0x3f04800300020001 };</TT>
<BR><TT>__m64&nbsp;&nbsp; c = { 0x0000000000000002 };</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; a = _m_pslld( b, c );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_DWORDS&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_QWORD&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_DWORDS&quot;\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._32[1], b._32[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._32[1], a._32[0] );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>m1=3f048003 00020001</TT>
<BR><TT>m2=0000000000000002</TT>
<BR><TT>mm=fc12000c 00080004</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="_m_pslldi"> _m_pslldi </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><TT>__m64 _m_pslldi(__m64 *m, int count);</TT>
</DL>
<DL>
<DT>Description:
<DD>The 32-bit double-words in<B> m</B> are each independently shifted to the left by the scalar shift count in<B> count</B>.
&nbsp;The low-order bits of each element are filled with zeros.&nbsp; The shift count is interpreted as unsigned.&nbsp; Shift
counts greater than 31 yield all zeros.
</DL>
<DL>
<DT>Returns:
<DD>Shift left each 32-bit double-word in<B> m</B> by an amount specified in<B> count</B> while shifting in zeros.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_m_empty">_m_empty</A>, <A HREF="#_m_pslld">_m_pslld</A>, <A HREF="#_m_psllq">_m_psllq</A>, <A HREF="#_m_psllqi">_m_psllqi</A>,
<A HREF="#_m_psllw">_m_psllw</A>, <A HREF="#_m_psllwi">_m_psllwi</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><BR><TT>#define AS_DWORDS &quot;%8.8lx %8.8lx&quot;</TT>
<BR><BR><TT>__m64&nbsp;&nbsp; a;</TT>
<BR><TT>__m64&nbsp;&nbsp; b = { 0x3f04800300020001 };</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; a = _m_pslldi( b, 2 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;m =&quot;AS_DWORDS&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_DWORDS&quot;\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._32[1], b._32[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._32[1], a._32[0] );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>m =3f048003 00020001</TT>
<BR><TT>mm=fc12000c 00080004</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="_m_psllq"> _m_psllq </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><TT>__m64 _m_psllq(__m64 *m, __m64 *count);</TT>
</DL>
<DL>
<DT>Description:
<DD>The 64-bit quad-word in<B> m</B> is shifted to the left by the scalar shift count in<B> count</B>.&nbsp; The low-order bits
are filled with zeros.&nbsp; The shift count is interpreted as unsigned.&nbsp; Shift counts greater than 63 yield all zeros.
</DL>
<DL>
<DT>Returns:
<DD>Shift left the 64-bit quad-word in<B> m</B> by an amount specified in<B> count</B> while shifting in zeros.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_m_empty">_m_empty</A>, <A HREF="#_m_pslld">_m_pslld</A>, <A HREF="#_m_pslldi">_m_pslldi</A>, <A HREF="#_m_psllqi">_m_psllqi</A>,
<A HREF="#_m_psllw">_m_psllw</A>, <A HREF="#_m_psllwi">_m_psllwi</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><BR><TT>#define AS_QWORD &quot;%16.16Lx&quot;</TT>
<BR><BR><TT>__m64&nbsp;&nbsp; a;</TT>
<BR><TT>__m64&nbsp;&nbsp; b = { 0x3f04800300020001 };</TT>
<BR><TT>__m64&nbsp;&nbsp; c = { 0x0000000000000002 };</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; a = _m_psllq( b, c );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_QWORD&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_QWORD&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_QWORD&quot;\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b, c, a );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>m1=3f04800300020001</TT>
<BR><TT>m2=0000000000000002</TT>
<BR><TT>mm=fc12000c00080004</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="_m_psllqi"> _m_psllqi </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><TT>__m64 _m_psllqi(__m64 *m, int count);</TT>
</DL>
<DL>
<DT>Description:
<DD>The 64-bit quad-word in<B> m</B> is shifted to the left by the scalar shift count in<B> count</B>.&nbsp; The low-order bits
are filled with zeros.&nbsp; The shift count is interpreted as unsigned.&nbsp; Shift counts greater than 63 yield all zeros.
</DL>
<DL>
<DT>Returns:
<DD>Shift left the 64-bit quad-word in<B> m</B> by an amount specified in<B> count</B> while shifting in zeros.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_m_empty">_m_empty</A>, <A HREF="#_m_pslld">_m_pslld</A>, <A HREF="#_m_pslldi">_m_pslldi</A>, <A HREF="#_m_psllq">_m_psllq</A>,
<A HREF="#_m_psllw">_m_psllw</A>, <A HREF="#_m_psllwi">_m_psllwi</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><BR><TT>#define AS_QWORD &quot;%16.16Lx&quot;</TT>
<BR><BR><TT>__m64&nbsp;&nbsp; a;</TT>
<BR><TT>__m64&nbsp;&nbsp; b = { 0x3f04800300020001 };</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; a = _m_psllqi( b, 2 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;m =&quot;AS_QWORD&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_QWORD&quot;\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b, a );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>m =3f04800300020001</TT>
<BR><TT>mm=fc12000c00080004</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="_m_psllw"> _m_psllw </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><TT>__m64 _m_psllw(__m64 *m, __m64 *count);</TT>
</DL>
<DL>
<DT>Description:
<DD>The 16-bit words in<B> m</B> are each independently shifted to the left by the scalar shift count in<B> count</B>.&nbsp; The
low-order bits of each element are filled with zeros.&nbsp; The shift count is interpreted as unsigned.&nbsp; Shift counts
greater than 15 yield all zeros.
</DL>
<DL>
<DT>Returns:
<DD>Shift left each 16-bit word in<B> m</B> by an amount specified in<B> count</B> while shifting in zeros.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_m_empty">_m_empty</A>, <A HREF="#_m_pslld">_m_pslld</A>, <A HREF="#_m_pslldi">_m_pslldi</A>, <A HREF="#_m_psllq">_m_psllq</A>,
<A HREF="#_m_psllqi">_m_psllqi</A>, <A HREF="#_m_psllwi">_m_psllwi</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><BR><TT>#define AS_WORDS &quot;%4.4x %4.4x %4.4x %4.4x&quot;</TT>
<BR><TT>#define AS_QWORD &quot;%16.16Lx&quot;</TT>
<BR><BR><TT>__m64&nbsp;&nbsp; a;</TT>
<BR><TT>__m64&nbsp;&nbsp; b = { 0x3f04800300020001 };</TT>
<BR><TT>__m64&nbsp;&nbsp; c = { 0x0000000000000002 };</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; a = _m_psllw( b, c );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_WORDS&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_QWORD&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_WORDS&quot;\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._16[3], b._16[2], b._16[1], b._16[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._16[3], a._16[2], a._16[1], a._16[0] );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>m1=3f04 8003 0002 0001</TT>
<BR><TT>m2=0000000000000002</TT>
<BR><TT>mm=fc10 000c 0008 0004</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="_m_psllwi"> _m_psllwi </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><TT>__m64 _m_psllwi(__m64 *m, int count);</TT>
</DL>
<DL>
<DT>Description:
<DD>The 16-bit words in<B> m</B> are each independently shifted to the left by the scalar shift count in<B> count</B>.&nbsp; The
low-order bits of each element are filled with zeros.&nbsp; The shift count is interpreted as unsigned.&nbsp; Shift counts
greater than 15 yield all zeros.
</DL>
<DL>
<DT>Returns:
<DD>Shift left each 16-bit word in<B> m</B> by an amount specified in<B> count</B> while shifting in zeros.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_m_empty">_m_empty</A>, <A HREF="#_m_pslld">_m_pslld</A>, <A HREF="#_m_pslldi">_m_pslldi</A>, <A HREF="#_m_psllq">_m_psllq</A>,
<A HREF="#_m_psllqi">_m_psllqi</A>, <A HREF="#_m_psllw">_m_psllw</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><BR><TT>#define AS_WORDS &quot;%4.4x %4.4x %4.4x %4.4x&quot;</TT>
<BR><BR><TT>__m64&nbsp;&nbsp; a;</TT>
<BR><TT>__m64&nbsp;&nbsp; b = { 0x3f04800300020001 };</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; a = _m_psllwi( b, 2 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;m =&quot;AS_WORDS&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_WORDS&quot;\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._16[3], b._16[2], b._16[1], b._16[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._16[3], a._16[2], a._16[1], a._16[0] );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>m =3f04 8003 0002 0001</TT>
<BR><TT>mm=fc10 000c 0008 0004</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="_m_psrad"> _m_psrad </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><TT>__m64 _m_psrad(__m64 *m, __m64 *count);</TT>
</DL>
<DL>
<DT>Description:
<DD>The 32-bit signed double-words in<B> m</B> are each independently shifted to the right by the scalar shift count in<B> count</B>.
&nbsp;The high-order bits of each element are filled with the initial value of the sign bit of each element.&nbsp; The shift
count is interpreted as unsigned.&nbsp; Shift counts greater than 31 yield all ones or zeros depending on the initial value
of the sign bit.
</DL>
<DL>
<DT>Returns:
<DD>Shift right each 32-bit double-word in<B> m</B> by an amount specified in<B> count</B> while shifting in sign bits.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_m_empty">_m_empty</A>, <A HREF="#_m_psradi">_m_psradi</A>, <A HREF="#_m_psraw">_m_psraw</A>, <A HREF="#_m_psrawi">_m_psrawi</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><BR><TT>#define AS_DWORDS &quot;%8.8lx %8.8lx&quot;</TT>
<BR><TT>#define AS_QWORD &quot;%16.16Lx&quot;</TT>
<BR><BR><TT>__m64&nbsp;&nbsp; a;</TT>
<BR><TT>__m64&nbsp;&nbsp; b = { 0x3f04800300020001 };</TT>
<BR><TT>__m64&nbsp;&nbsp; c = { 0x0000000000000002 };</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; a = _m_psrad( b, c );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_DWORDS&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_QWORD&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_DWORDS&quot;\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._32[1], b._32[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._32[1], a._32[0] );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>m1=3f048003 00020001</TT>
<BR><TT>m2=0000000000000002</TT>
<BR><TT>mm=0fc12000 00008000</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="_m_psradi"> _m_psradi </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><TT>__m64 _m_psradi(__m64 *m, int count);</TT>
</DL>
<DL>
<DT>Description:
<DD>The 32-bit signed double-words in<B> m</B> are each independently shifted to the right by the scalar shift count in<B> count</B>.
&nbsp;The high-order bits of each element are filled with the initial value of the sign bit of each element.&nbsp; The shift
count is interpreted as unsigned.&nbsp; Shift counts greater than 31 yield all ones or zeros depending on the initial value
of the sign bit.
</DL>
<DL>
<DT>Returns:
<DD>Shift right each 32-bit double-word in<B> m</B> by an amount specified in<B> count</B> while shifting in sign bits.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_m_empty">_m_empty</A>, <A HREF="#_m_psrad">_m_psrad</A>, <A HREF="#_m_psraw">_m_psraw</A>, <A HREF="#_m_psrawi">_m_psrawi</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><BR><TT>#define AS_DWORDS &quot;%8.8lx %8.8lx&quot;</TT>
<BR><BR><TT>__m64&nbsp;&nbsp; a;</TT>
<BR><TT>__m64&nbsp;&nbsp; b = { 0x3f04800300020001 };</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; a = _m_psradi( b, 2 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;m =&quot;AS_DWORDS&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_DWORDS&quot;\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._32[1], b._32[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._32[1], a._32[0] );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>m =3f048003 00020001</TT>
<BR><TT>mm=0fc12000 00008000</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="_m_psraw"> _m_psraw </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><TT>__m64 _m_psraw(__m64 *m, __m64 *count);</TT>
</DL>
<DL>
<DT>Description:
<DD>The 16-bit signed words in<B> m</B> are each independently shifted to the right by the scalar shift count in<B> count</B>.
&nbsp;The high-order bits of each element are filled with the initial value of the sign bit of each element.&nbsp; The shift
count is interpreted as unsigned.&nbsp; Shift counts greater than 15 yield all ones or zeros depending on the initial value
of the sign bit.
</DL>
<DL>
<DT>Returns:
<DD>Shift right each 16-bit word in<B> m</B> by an amount specified in<B> count</B> while shifting in sign bits.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_m_empty">_m_empty</A>, <A HREF="#_m_psrad">_m_psrad</A>, <A HREF="#_m_psradi">_m_psradi</A>, <A HREF="#_m_psrawi">_m_psrawi</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><BR><TT>#define AS_WORDS &quot;%4.4x %4.4x %4.4x %4.4x&quot;</TT>
<BR><TT>#define AS_QWORD &quot;%16.16Lx&quot;</TT>
<BR><BR><TT>__m64&nbsp;&nbsp; a;</TT>
<BR><TT>__m64&nbsp;&nbsp; b = { 0x3f04800300040001 };</TT>
<BR><TT>__m64&nbsp;&nbsp; c = { 0x0000000000000002 };</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; a = _m_psraw( b, c );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_WORDS&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_QWORD&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_WORDS&quot;\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._16[3], b._16[2], b._16[1], b._16[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._16[3], a._16[2], a._16[1], a._16[0] );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>m1=3f04 8003 0004 0001</TT>
<BR><TT>m2=0000000000000002</TT>
<BR><TT>mm=0fc1 e000 0001 0000</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="_m_psrawi"> _m_psrawi </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><TT>__m64 _m_psrawi(__m64 *m, int count);</TT>
</DL>
<DL>
<DT>Description:
<DD>The 16-bit signed words in<B> m</B> are each independently shifted to the right by the scalar shift count in<B> count</B>.
&nbsp;The high-order bits of each element are filled with the initial value of the sign bit of each element.&nbsp; The shift
count is interpreted as unsigned.&nbsp; Shift counts greater than 15 yield all ones or zeros depending on the initial value
of the sign bit.
</DL>
<DL>
<DT>Returns:
<DD>Shift right each 16-bit word in<B> m</B> by an amount specified in<B> count</B> while shifting in sign bits.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_m_empty">_m_empty</A>, <A HREF="#_m_psrad">_m_psrad</A>, <A HREF="#_m_psradi">_m_psradi</A>, <A HREF="#_m_psraw">_m_psraw</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><BR><TT>#define AS_WORDS &quot;%4.4x %4.4x %4.4x %4.4x&quot;</TT>
<BR><BR><TT>__m64&nbsp;&nbsp; a;</TT>
<BR><TT>__m64&nbsp;&nbsp; b = { 0x3f04800300040001 };</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; a = _m_psrawi( b, 2 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;m =&quot;AS_WORDS&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_WORDS&quot;\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._16[3], b._16[2], b._16[1], b._16[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._16[3], a._16[2], a._16[1], a._16[0] );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>m =3f04 8003 0004 0001</TT>
<BR><TT>mm=0fc1 e000 0001 0000</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="_m_psrld"> _m_psrld </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><TT>__m64 _m_psrld(__m64 *m, __m64 *count);</TT>
</DL>
<DL>
<DT>Description:
<DD>The 32-bit double-words in<B> m</B> are each independently shifted to the right by the scalar shift count in<B> count</B>.
&nbsp;The high-order bits of each element are filled with zeros.&nbsp; The shift count is interpreted as unsigned.&nbsp; Shift
counts greater than 31 yield all zeros.
</DL>
<DL>
<DT>Returns:
<DD>Shift right each 32-bit double-word in<B> m</B> by an amount specified in<B> count</B> while shifting in zeros.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_m_empty">_m_empty</A>, <A HREF="#_m_psrldi">_m_psrldi</A>, <A HREF="#_m_psrlq">_m_psrlq</A>, <A HREF="#_m_psrlqi">_m_psrlqi</A>,
<A HREF="#_m_psrlw">_m_psrlw</A>, <A HREF="#_m_psrlwi">_m_psrlwi</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><BR><TT>#define AS_DWORDS &quot;%8.8lx %8.8lx&quot;</TT>
<BR><TT>#define AS_QWORD &quot;%16.16Lx&quot;</TT>
<BR><BR><TT>__m64&nbsp;&nbsp; a;</TT>
<BR><TT>__m64&nbsp;&nbsp; b = { 0x3f04800300020001 };</TT>
<BR><TT>__m64&nbsp;&nbsp; c = { 0x0000000000000002 };</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; a = _m_psrld( b, c );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_DWORDS&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_QWORD&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_DWORDS&quot;\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._32[1], b._32[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._32[1], a._32[0] );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>m1=3f048003 00020001</TT>
<BR><TT>m2=0000000000000002</TT>
<BR><TT>mm=0fc12000 00008000</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="_m_psrldi"> _m_psrldi </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><TT>__m64 _m_psrldi(__m64 *m, int count);</TT>
</DL>
<DL>
<DT>Description:
<DD>The 32-bit double-words in<B> m</B> are each independently shifted to the right by the scalar shift count in<B> count</B>.
&nbsp;The high-order bits of each element are filled with zeros.&nbsp; The shift count is interpreted as unsigned.&nbsp; Shift
counts greater than 31 yield all zeros.
</DL>
<DL>
<DT>Returns:
<DD>Shift right each 32-bit double-word in<B> m</B> by an amount specified in<B> count</B> while shifting in zeros.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_m_empty">_m_empty</A>, <A HREF="#_m_psrld">_m_psrld</A>, <A HREF="#_m_psrlq">_m_psrlq</A>, <A HREF="#_m_psrlqi">_m_psrlqi</A>,
<A HREF="#_m_psrlw">_m_psrlw</A>, <A HREF="#_m_psrlwi">_m_psrlwi</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><BR><TT>#define AS_DWORDS &quot;%8.8lx %8.8lx&quot;</TT>
<BR><BR><TT>__m64&nbsp;&nbsp; a;</TT>
<BR><TT>__m64&nbsp;&nbsp; b = { 0x3f04800300020001 };</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; a = _m_psrldi( b, 2 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;m =&quot;AS_DWORDS&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_DWORDS&quot;\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._32[1], b._32[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._32[1], a._32[0] );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>m =3f048003 00020001</TT>
<BR><TT>mm=0fc12000 00008000</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="_m_psrlq"> _m_psrlq </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><TT>__m64 _m_psrlq(__m64 *m, __m64 *count);</TT>
</DL>
<DL>
<DT>Description:
<DD>The 64-bit quad-word in<B> m</B> is shifted to the right by the scalar shift count in<B> count</B>.&nbsp; The high-order bits
are filled with zeros.&nbsp; The shift count is interpreted as unsigned.&nbsp; Shift counts greater than 63 yield all zeros.
</DL>
<DL>
<DT>Returns:
<DD>Shift right the 64-bit quad-word in<B> m</B> by an amount specified in<B> count</B> while shifting in zeros.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_m_empty">_m_empty</A>, <A HREF="#_m_psrld">_m_psrld</A>, <A HREF="#_m_psrldi">_m_psrldi</A>, <A HREF="#_m_psrlqi">_m_psrlqi</A>,
<A HREF="#_m_psrlw">_m_psrlw</A>, <A HREF="#_m_psrlwi">_m_psrlwi</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><BR><TT>#define AS_QWORD &quot;%16.16Lx&quot;</TT>
<BR><BR><TT>__m64&nbsp;&nbsp; a;</TT>
<BR><TT>__m64&nbsp;&nbsp; b = { 0x3f04800300020001 };</TT>
<BR><TT>__m64&nbsp;&nbsp; c = { 0x0000000000000002 };</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; a = _m_psrlq( b, c );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_QWORD&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_QWORD&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_QWORD&quot;\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b, c, a );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>m1=3f04800300020001</TT>
<BR><TT>m2=0000000000000002</TT>
<BR><TT>mm=0fc12000c0008000</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="_m_psrlqi"> _m_psrlqi </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><TT>__m64 _m_psrlqi(__m64 *m, int count);</TT>
</DL>
<DL>
<DT>Description:
<DD>The 64-bit quad-word in<B> m</B> is shifted to the right by the scalar shift count in<B> count</B>.&nbsp; The high-order bits
are filled with zeros.&nbsp; The shift count is interpreted as unsigned.&nbsp; Shift counts greater than 63 yield all zeros.
</DL>
<DL>
<DT>Returns:
<DD>Shift right the 64-bit quad-word in<B> m</B> by an amount specified in<B> count</B> while shifting in zeros.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_m_empty">_m_empty</A>, <A HREF="#_m_psrld">_m_psrld</A>, <A HREF="#_m_psrldi">_m_psrldi</A>, <A HREF="#_m_psrlq">_m_psrlq</A>,
<A HREF="#_m_psrlw">_m_psrlw</A>, <A HREF="#_m_psrlwi">_m_psrlwi</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><BR><TT>#define AS_QWORD &quot;%16.16Lx&quot;</TT>
<BR><BR><TT>__m64&nbsp;&nbsp; a;</TT>
<BR><TT>__m64&nbsp;&nbsp; b = { 0x3f04800300020001 };</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; a = _m_psrlqi( b, 2 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;m =&quot;AS_QWORD&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_QWORD&quot;\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b, a );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>m =3f04800300020001</TT>
<BR><TT>mm=0fc12000c0008000</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="_m_psrlw"> _m_psrlw </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><TT>__m64 _m_psrlw(__m64 *m, __m64 *count);</TT>
</DL>
<DL>
<DT>Description:
<DD>The 16-bit words in<B> m</B> are each independently shifted to the right by the scalar shift count in<B> count</B>.&nbsp;
The high-order bits of each element are filled with zeros.&nbsp; The shift count is interpreted as unsigned.&nbsp; Shift counts
greater than 15 yield all zeros.
</DL>
<DL>
<DT>Returns:
<DD>Shift right each 16-bit word in<B> m</B> by an amount specified in<B> count</B> while shifting in zeros.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_m_empty">_m_empty</A>, <A HREF="#_m_psrld">_m_psrld</A>, <A HREF="#_m_psrldi">_m_psrldi</A>, <A HREF="#_m_psrlq">_m_psrlq</A>,
<A HREF="#_m_psrlqi">_m_psrlqi</A>, <A HREF="#_m_psrlwi">_m_psrlwi</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><BR><TT>#define AS_WORDS &quot;%4.4x %4.4x %4.4x %4.4x&quot;</TT>
<BR><TT>#define AS_QWORD &quot;%16.16Lx&quot;</TT>
<BR><BR><TT>__m64&nbsp;&nbsp; a;</TT>
<BR><TT>__m64&nbsp;&nbsp; b = { 0x3f04800300040001 };</TT>
<BR><TT>__m64&nbsp;&nbsp; c = { 0x0000000000000002 };</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; a = _m_psrlw( b, c );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_WORDS&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_QWORD&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_WORDS&quot;\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._16[3], b._16[2], b._16[1], b._16[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._16[3], a._16[2], a._16[1], a._16[0] );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>m1=3f04 8003 0004 0001</TT>
<BR><TT>m2=0000000000000002</TT>
<BR><TT>mm=0fc1 2000 0001 0000</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="_m_psrlwi"> _m_psrlwi </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><TT>__m64 _m_psrlwi(__m64 *m, int count);</TT>
</DL>
<DL>
<DT>Description:
<DD>The 16-bit words in<B> m</B> are each independently shifted to the right by the scalar shift count in<B> count</B>.&nbsp;
The high-order bits of each element are filled with zeros.&nbsp; The shift count is interpreted as unsigned.&nbsp; Shift counts
greater than 15 yield all zeros.
</DL>
<DL>
<DT>Returns:
<DD>Shift right each 16-bit word in<B> m</B> by an amount specified in<B> count</B> while shifting in zeros.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_m_empty">_m_empty</A>, <A HREF="#_m_psrld">_m_psrld</A>, <A HREF="#_m_psrldi">_m_psrldi</A>, <A HREF="#_m_psrlq">_m_psrlq</A>,
<A HREF="#_m_psrlqi">_m_psrlqi</A>, <A HREF="#_m_psrlw">_m_psrlw</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><BR><TT>#define AS_WORDS &quot;%4.4x %4.4x %4.4x %4.4x&quot;</TT>
<BR><BR><TT>__m64&nbsp;&nbsp; a;</TT>
<BR><TT>__m64&nbsp;&nbsp; b = { 0x3f04800300040001 };</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; a = _m_psrlwi( b, 2 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;m =&quot;AS_WORDS&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_WORDS&quot;\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._16[3], b._16[2], b._16[1], b._16[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._16[3], a._16[2], a._16[1], a._16[0] );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>m =3f04 8003 0004 0001</TT>
<BR><TT>mm=0fc1 2000 0001 0000</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="_m_psubb"> _m_psubb </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><TT>__m64 _m_psubb(__m64 *m1, __m64 *m2);</TT>
</DL>
<DL>
<DT>Description:
<DD>The signed or unsigned 8-bit bytes of<B> m2</B> are subtracted from the respective signed or unsigned 8-bit bytes of<B> m1</B>
and the result is stored in memory.&nbsp; If any result element does not fit into 8 bits (underflow or overflow), the lower
8 bits of the result elements are stored (i.e., truncation takes place).
</DL>
<DL>
<DT>Returns:
<DD>The result of subtracting the packed bytes of one 64-bit multimedia value from another is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_m_empty">_m_empty</A>, <A HREF="#_m_psubd">_m_psubd</A>, <A HREF="#_m_psubsb">_m_psubsb</A>, <A HREF="#_m_psubsw">_m_psubsw</A>,
<A HREF="#_m_psubusb">_m_psubusb</A>, <A HREF="#_m_psubusw">_m_psubusw</A>, <A HREF="#_m_psubw">_m_psubw</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><BR><TT>#define AS_BYTES &quot;%2.2x %2.2x %2.2x %2.2x &quot; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;%2.2x %2.2x
%2.2x %2.2x&quot;</TT>
<BR><BR><TT>__m64&nbsp;&nbsp; a;</TT>
<BR><TT>__m64&nbsp;&nbsp; b = { 0x0123456789abcdef };</TT>
<BR><TT>__m64&nbsp;&nbsp; c = { 0xfedcba9876543210 };</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; a = _m_psubb( b, c );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_BYTES&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_BYTES&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_BYTES&quot;\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._8[7], b._8[6], b._8[5], b._8[4],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._8[3], b._8[2], b._8[1], b._8[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._8[7], c._8[6], c._8[5], c._8[4],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._8[3], c._8[2], c._8[1], c._8[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._8[7], a._8[6], a._8[5], a._8[4],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._8[3], a._8[2], a._8[1], a._8[0] );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>m1=01 23 45 67 89 ab cd ef</TT>
<BR><TT>m2=fe dc ba 98 76 54 32 10</TT>
<BR><TT>mm=03 47 8b cf 13 57 9b df</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="_m_psubd"> _m_psubd </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><TT>__m64 _m_psubd(__m64 *m1, __m64 *m2);</TT>
</DL>
<DL>
<DT>Description:
<DD>The signed or unsigned 32-bit double-words of<B> m2</B> are subtracted from the respective signed or unsigned 32-bit double-words
of<B> m1</B> and the result is stored in memory.&nbsp; If any result element does not fit into 32 bits (underflow or overflow),
the lower 32-bits of the result elements are stored (i.e., truncation takes place).
</DL>
<DL>
<DT>Returns:
<DD>The result of subtracting one set of packed double-words from a second set of packed double-words is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_m_empty">_m_empty</A>, <A HREF="#_m_psubb">_m_psubb</A>, <A HREF="#_m_psubsb">_m_psubsb</A>, <A HREF="#_m_psubsw">_m_psubsw</A>,
<A HREF="#_m_psubusb">_m_psubusb</A>, <A HREF="#_m_psubusw">_m_psubusw</A>, <A HREF="#_m_psubw">_m_psubw</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><BR><TT>#define AS_DWORDS &quot;%8.8lx %8.8lx&quot;</TT>
<BR><BR><TT>__m64&nbsp;&nbsp; a;</TT>
<BR><TT>__m64&nbsp;&nbsp; b = { 0x0123456789abcdef };</TT>
<BR><TT>__m64&nbsp;&nbsp; c = { 0xfedcba9876543210 };</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; a = _m_psubd( b, c );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_DWORDS&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_DWORDS&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_DWORDS&quot;\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._32[1], b._32[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._32[1], c._32[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._32[1], a._32[0] );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>m1=01234567 89abcdef</TT>
<BR><TT>m2=fedcba98 76543210</TT>
<BR><TT>mm=02468acf 13579bdf</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="_m_psubsb"> _m_psubsb </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><TT>__m64 _m_psubsb(__m64 *m1, __m64 *m2);</TT>
</DL>
<DL>
<DT>Description:
<DD>The signed 8-bit bytes of<B> m2</B> are subtracted from the respective signed 8-bit bytes of<B> m1</B> and the result is stored
in memory.&nbsp; Saturation occurs when a result exceeds the range of a signed byte.&nbsp; In the case where a result is a
byte larger than 0x7f (overflow), it is clamped to 0x7f.&nbsp; In the case where a result is a byte smaller than 0x80 (underflow),
it is clamped to 0x80.
</DL>
<DL>
<DT>Returns:
<DD>The result of subtracting the packed signed bytes, with saturation, of one 64-bit multimedia value from a second multimedia
value is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_m_empty">_m_empty</A>, <A HREF="#_m_psubb">_m_psubb</A>, <A HREF="#_m_psubd">_m_psubd</A>, <A HREF="#_m_psubsw">_m_psubsw</A>,
<A HREF="#_m_psubusb">_m_psubusb</A>, <A HREF="#_m_psubusw">_m_psubusw</A>, <A HREF="#_m_psubw">_m_psubw</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><BR><TT>#define AS_BYTES &quot;%2.2x %2.2x %2.2x %2.2x &quot; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;%2.2x %2.2x
%2.2x %2.2x&quot;</TT>
<BR><BR><TT>__m64&nbsp;&nbsp; a;</TT>
<BR><TT>__m64&nbsp;&nbsp; b = { 0x8aacceef02244668 };</TT>
<BR><TT>__m64&nbsp;&nbsp; c = { 0x76543211fedcba98 };</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; a = _m_psubsb( b, c );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_BYTES&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_BYTES&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_BYTES&quot;\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._8[7], b._8[6], b._8[5], b._8[4],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._8[3], b._8[2], b._8[1], b._8[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._8[7], c._8[6], c._8[5], c._8[4],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._8[3], c._8[2], c._8[1], c._8[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._8[7], a._8[6], a._8[5], a._8[4],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._8[3], a._8[2], a._8[1], a._8[0] );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>m1=8a ac ce ef 02 24 46 68</TT>
<BR><TT>m2=76 54 32 11 fe dc ba 98</TT>
<BR><TT>mm=80 80 9c de 04 48 7f 7f</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="_m_psubsw"> _m_psubsw </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><TT>__m64 _m_psubsw(__m64 *m1, __m64 *m2);</TT>
</DL>
<DL>
<DT>Description:
<DD>The signed 16-bit words of<B> m2</B> are subtracted from the respective signed 16-bit words of<B> m1</B> and the result is
stored in memory.&nbsp; Saturation occurs when a result exceeds the range of a signed word.&nbsp; In the case where a result
is a word larger than 0x7fff (overflow), it is clamped to 0x7fff.&nbsp; In the case where a result is a word smaller than
0x8000 (underflow), it is clamped to 0x8000.
</DL>
<DL>
<DT>Returns:
<DD>The result of subtracting the packed signed words, with saturation, of one 64-bit multimedia value from a second multimedia
value is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_m_empty">_m_empty</A>, <A HREF="#_m_psubb">_m_psubb</A>, <A HREF="#_m_psubd">_m_psubd</A>, <A HREF="#_m_psubsb">_m_psubsb</A>,
<A HREF="#_m_psubusb">_m_psubusb</A>, <A HREF="#_m_psubusw">_m_psubusw</A>, <A HREF="#_m_psubw">_m_psubw</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><BR><TT>#define AS_WORDS &quot;%4.4x %4.4x %4.4x %4.4x&quot;</TT>
<BR><BR><TT>__m64&nbsp;&nbsp; a;</TT>
<BR><TT>__m64&nbsp;&nbsp; b = { 0x8aacceef02244668 };</TT>
<BR><TT>__m64&nbsp;&nbsp; c = { 0x76543211fedcba98 };</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; a = _m_psubsw( b, c );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_WORDS&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_WORDS&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_WORDS&quot;\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._16[3], b._16[2], b._16[1], b._16[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._16[3], c._16[2], c._16[1], c._16[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._16[3], a._16[2], a._16[1], a._16[0] );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>m1=8aac ceef 0224 4668</TT>
<BR><TT>m2=7654 3211 fedc ba98</TT>
<BR><TT>mm=8000 9cde 0348 7fff</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="_m_psubusb"> _m_psubusb </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><TT>__m64 _m_psubusb(__m64 *m1, __m64 *m2);</TT>
</DL>
<DL>
<DT>Description:
<DD>The unsigned 8-bit bytes of<B> m2</B> are subtracted from the respective unsigned 8-bit bytes of<B> m1</B> and the result
is stored in memory.&nbsp; Saturation occurs when a result is less than zero.&nbsp; If a result is less than zero, it is clamped
to 0xff.
</DL>
<DL>
<DT>Returns:
<DD>The result of subtracting the packed unsigned bytes, with saturation, of one 64-bit multimedia value from a second multimedia
value is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_m_empty">_m_empty</A>, <A HREF="#_m_psubb">_m_psubb</A>, <A HREF="#_m_psubd">_m_psubd</A>, <A HREF="#_m_psubsb">_m_psubsb</A>,
<A HREF="#_m_psubsw">_m_psubsw</A>, <A HREF="#_m_psubusw">_m_psubusw</A>, <A HREF="#_m_psubw">_m_psubw</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><BR><TT>#define AS_BYTES &quot;%2.2x %2.2x %2.2x %2.2x &quot; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;%2.2x %2.2x
%2.2x %2.2x&quot;</TT>
<BR><BR><TT>__m64&nbsp;&nbsp; a;</TT>
<BR><TT>__m64&nbsp;&nbsp; b = { 0x8aacceef02244668 };</TT>
<BR><TT>__m64&nbsp;&nbsp; c = { 0x76543211fedcba98 };</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; a = _m_psubusb( b, c );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_BYTES&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_BYTES&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_BYTES&quot;\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._8[7], b._8[6], b._8[5], b._8[4],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._8[3], b._8[2], b._8[1], b._8[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._8[7], c._8[6], c._8[5], c._8[4],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._8[3], c._8[2], c._8[1], c._8[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._8[7], a._8[6], a._8[5], a._8[4],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._8[3], a._8[2], a._8[1], a._8[0] );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>m1=8a ac ce ef 02 24 46 68</TT>
<BR><TT>m2=76 54 32 11 fe dc ba 98</TT>
<BR><TT>mm=14 58 9c de 00 00 00 00</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="_m_psubusw"> _m_psubusw </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><TT>__m64 _m_psubusw(__m64 *m1, __m64 *m2);</TT>
</DL>
<DL>
<DT>Description:
<DD>The unsigned 16-bit words of<B> m2</B> are subtracted from the respective unsigned 16-bit words of<B> m1</B> and the result
is stored in memory.&nbsp; Saturation occurs when a result is less than zero.&nbsp; If a result is less than zero, it is clamped
to 0xffff.
</DL>
<DL>
<DT>Returns:
<DD>The result of subtracting the packed unsigned words, with saturation, of one 64-bit multimedia value from a second multimedia
value is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_m_empty">_m_empty</A>, <A HREF="#_m_psubb">_m_psubb</A>, <A HREF="#_m_psubd">_m_psubd</A>, <A HREF="#_m_psubsb">_m_psubsb</A>,
<A HREF="#_m_psubsw">_m_psubsw</A>, <A HREF="#_m_psubusb">_m_psubusb</A>, <A HREF="#_m_psubw">_m_psubw</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><BR><TT>#define AS_WORDS &quot;%4.4x %4.4x %4.4x %4.4x&quot;</TT>
<BR><BR><TT>__m64&nbsp;&nbsp; a;</TT>
<BR><TT>__m64&nbsp;&nbsp; b = { 0x8aacceef02244668 };</TT>
<BR><TT>__m64&nbsp;&nbsp; c = { 0x76543211fedcba98 };</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; a = _m_psubusw( b, c );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_WORDS&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_WORDS&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_WORDS&quot;\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._16[3], b._16[2], b._16[1], b._16[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._16[3], c._16[2], c._16[1], c._16[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._16[3], a._16[2], a._16[1], a._16[0] );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>m1=8aac ceef 0224 4668</TT>
<BR><TT>m2=7654 3211 fedc ba98</TT>
<BR><TT>mm=1458 9cde 0000 0000</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="_m_psubw"> _m_psubw </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><TT>__m64 _m_psubw(__m64 *m1, __m64 *m2);</TT>
</DL>
<DL>
<DT>Description:
<DD>The signed or unsigned 16-bit words of<B> m2</B> are subtracted from the respective signed or unsigned 16-bit words of<B>
m1</B> and the result is stored in memory.&nbsp; If any result element does not fit into 16 bits (underflow or overflow),
the lower 16 bits of the result elements are stored (i.e., truncation takes place).
</DL>
<DL>
<DT>Returns:
<DD>The result of subtracting the packed words of two 64-bit multimedia values is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_m_empty">_m_empty</A>, <A HREF="#_m_psubb">_m_psubb</A>, <A HREF="#_m_psubd">_m_psubd</A>, <A HREF="#_m_psubsb">_m_psubsb</A>,
<A HREF="#_m_psubsw">_m_psubsw</A>, <A HREF="#_m_psubusb">_m_psubusb</A>, <A HREF="#_m_psubusw">_m_psubusw</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><BR><TT>#define AS_WORDS &quot;%4.4x %4.4x %4.4x %4.4x&quot;</TT>
<BR><BR><TT>__m64&nbsp;&nbsp; a;</TT>
<BR><TT>__m64&nbsp;&nbsp; b = { 0x0123456789abcdef };</TT>
<BR><TT>__m64&nbsp;&nbsp; c = { 0xfedcba9876543210 };</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; a = _m_psubw( b, c );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_WORDS&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_WORDS&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_WORDS&quot;\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._16[3], b._16[2], b._16[1], b._16[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._16[3], c._16[2], c._16[1], c._16[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._16[3], a._16[2], a._16[1], a._16[0] );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>m1=0123 4567 89ab cdef</TT>
<BR><TT>m2=fedc ba98 7654 3210</TT>
<BR><TT>mm=0247 8acf 1357 9bdf</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="_m_punpckhbw"> _m_punpckhbw </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><TT>__m64 _m_punpckhbw(__m64 *m1, __m64 *m2);</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _m_punpckhbw</TT> function performs an interleaved unpack of the high-order data elements of<B> m1</B> and<B> m2</B>.
&nbsp;It ignores the low-order bytes.&nbsp; When unpacking from a memory operand, the full 64-bit operand is accessed from
memory but only the high-order 32 bits are utilized.&nbsp; By choosing<B> m1</B> or<B> m2</B> to be zero, an unpacking of
byte elements into word elements is performed.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m2&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -------------------------&nbsp; -------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |b7|b6|b5|b4|b3|b2|b1|b0|&nbsp; |b7|b6|b5|b4|b3|b2|b1|b0|</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -------------------------&nbsp; -------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; |&nbsp; |&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; |&nbsp; |&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; V&nbsp; V&nbsp; V&nbsp; V&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; V&nbsp; V&nbsp; V&nbsp; V</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b7 b5 b3 b1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; b6 b4 b2 b0</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |b7|b6|b5|b4|b3|b2|b1|b0|</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; result</TT>
</DL>
<DL>
<DT>Returns:
<DD>The result of the interleaved unpacking of the high-order bytes of two multimedia values is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_m_empty">_m_empty</A>, <A HREF="#_m_punpckhdq">_m_punpckhdq</A>, <A HREF="#_m_punpckhwd">_m_punpckhwd</A>, <A HREF="#_m_punpcklbw">_m_punpcklbw</A>,
<A HREF="#_m_punpckldq">_m_punpckldq</A>, <A HREF="#_m_punpcklwd">_m_punpcklwd</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><BR><TT>#define AS_BYTES &quot;%2.2x %2.2x %2.2x %2.2x &quot; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;%2.2x %2.2x
%2.2x %2.2x&quot;</TT>
<BR><BR><TT>__m64&nbsp;&nbsp; a;</TT>
<BR><TT>__m64&nbsp;&nbsp; b = { 0x0004000300020001 };</TT>
<BR><TT>__m64&nbsp;&nbsp; c = { 0xff7fff800080007f };</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; a = _m_punpckhbw( b, c );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;m2=&quot;AS_BYTES&quot; &quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m1=&quot;AS_BYTES&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_BYTES&quot;\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._8[7], c._8[6], c._8[5], c._8[4],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._8[3], c._8[2], c._8[1], c._8[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._8[7], b._8[6], b._8[5], b._8[4],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._8[3], b._8[2], b._8[1], b._8[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._8[7], a._8[6], a._8[5], a._8[4],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._8[3], a._8[2], a._8[1], a._8[0] );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>m2=ff 7f ff 80 00 80 00 7f m1=00 04 00 03 00 02 00 01</TT>
<BR><TT>mm=ff 00 7f 04 ff 00 80 03</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="_m_punpckhdq"> _m_punpckhdq </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><TT>__m64 _m_punpckhdq(__m64 *m1, __m64 *m2);</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _m_punpckhdq</TT> function performs an interleaved unpack of the high-order data elements of<B> m1</B> and<B> m2</B>.
&nbsp;It ignores the low-order double-words.&nbsp; When unpacking from a memory operand, the full 64-bit operand is accessed
from memory but only the high-order 32 bits are utilized.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m2&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -------------------------&nbsp; -------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; d1&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; d0&nbsp;&nbsp;&nbsp;
|&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; d1&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; d0&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -------------------------&nbsp; -------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; V&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; V</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d0</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;
&nbsp;&nbsp; d1&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; d0&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; result</TT>
</DL>
<DL>
<DT>Returns:
<DD>The result of the interleaved unpacking of the high-order double-words of two multimedia values is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_m_empty">_m_empty</A>, <A HREF="#_m_punpckhbw">_m_punpckhbw</A>, <A HREF="#_m_punpckhwd">_m_punpckhwd</A>, <A HREF="#_m_punpcklbw">_m_punpcklbw</A>,
<A HREF="#_m_punpckldq">_m_punpckldq</A>, <A HREF="#_m_punpcklwd">_m_punpcklwd</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><BR><TT>#define AS_DWORDS &quot;%8.8lx %8.8lx&quot;</TT>
<BR><BR><TT>__m64&nbsp;&nbsp; a;</TT>
<BR><TT>__m64&nbsp;&nbsp; b = { 0x0004000300020001 };</TT>
<BR><TT>__m64&nbsp;&nbsp; c = { 0xff7fff800080007f };</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; a = _m_punpckhdq( b, c );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;m2=&quot;AS_DWORDS&quot; &quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m1=&quot;AS_DWORDS&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_DWORDS&quot;\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._32[1], c._32[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._32[1], b._32[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._32[1], a._32[0] );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>m2=ff7fff80 0080007f m1=00040003 00020001</TT>
<BR><TT>mm=ff7fff80 00040003</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="_m_punpckhwd"> _m_punpckhwd </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><TT>__m64 _m_punpckhwd(__m64 *m1, __m64 *m2);</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _m_punpckhwd</TT> function performs an interleaved unpack of the high-order data elements of<B> m1</B> and<B> m2</B>.
&nbsp;It ignores the low-order words.&nbsp; When unpacking from a memory operand, the full 64-bit operand is accessed from
memory but only the high-order 32 bits are utilized.&nbsp; By choosing<B> m1</B> or<B> m2</B> to be zero, an unpacking of
word elements into double-word elements is performed.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m2&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -------------------------&nbsp; -------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; w3 |&nbsp; w2 |&nbsp; w1 |&nbsp; w0 |&nbsp; |&nbsp; w3 |&nbsp; w2 |&nbsp; w1 |&nbsp;
w0 |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -------------------------&nbsp; -------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; V&nbsp;&nbsp;&nbsp;&nbsp; V&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; V&nbsp;&nbsp;&nbsp; V</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; w3&nbsp;&nbsp;&nbsp; w1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; w2&nbsp;&nbsp;&nbsp; w0</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;
w3 |&nbsp; w2 |&nbsp; w1 |&nbsp; w0 |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; result</TT>
</DL>
<DL>
<DT>Returns:
<DD>The result of the interleaved unpacking of the high-order words of two multimedia values is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_m_empty">_m_empty</A>, <A HREF="#_m_punpckhbw">_m_punpckhbw</A>, <A HREF="#_m_punpckhdq">_m_punpckhdq</A>, <A HREF="#_m_punpcklbw">_m_punpcklbw</A>,
<A HREF="#_m_punpckldq">_m_punpckldq</A>, <A HREF="#_m_punpcklwd">_m_punpcklwd</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><BR><TT>#define AS_WORDS &quot;%4.4x %4.4x %4.4x %4.4x&quot;</TT>
<BR><BR><TT>__m64&nbsp;&nbsp; a;</TT>
<BR><TT>__m64&nbsp;&nbsp; b = { 0x0004000300020001 };</TT>
<BR><TT>__m64&nbsp;&nbsp; c = { 0xff7fff800080007f };</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; a = _m_punpckhwd( b, c );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;m2=&quot;AS_WORDS&quot; &quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m1=&quot;AS_WORDS&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_WORDS&quot;\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._16[3], c._16[2], c._16[1], c._16[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._16[3], b._16[2], b._16[1], b._16[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._16[3], a._16[2], a._16[1], a._16[0] );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>m2=ff7f ff80 0080 007f m1=0004 0003 0002 0001</TT>
<BR><TT>mm=ff7f 0004 ff80 0003</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="_m_punpcklbw"> _m_punpcklbw </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><TT>__m64 _m_punpcklbw(__m64 *m1, __m64 *m2);</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _m_punpcklbw</TT> function performs an interleaved unpack of the low-order data elements of<B> m1</B> and<B> m2</B>.
&nbsp;It ignores the high-order bytes.&nbsp; When unpacking from a memory operand, 32 bits are accessed and all are utilized
by the instruction.&nbsp; By choosing<B> m1</B> or<B> m2</B> to be zero, an unpacking of byte elements into word elements
is performed.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m2&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -------------------------&nbsp; -------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |b3|b2|b1|b0|&nbsp; |b7|b6|b5|b4|b3|b2|b1|b0|</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -------------------------&nbsp; -------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; |&nbsp;
|&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; |&nbsp;
|&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; V&nbsp; V&nbsp;
V&nbsp; V&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; V&nbsp; V&nbsp;
V&nbsp; V</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b7 b5 b3 b1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b6 b4 b2 b0</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |b7|b6|b5|b4|b3|b2|b1|b0|</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; result</TT>
</DL>
<DL>
<DT>Returns:
<DD>The result of the interleaved unpacking of the low-order bytes of two multimedia values is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_m_empty">_m_empty</A>, <A HREF="#_m_punpckhbw">_m_punpckhbw</A>, <A HREF="#_m_punpckhdq">_m_punpckhdq</A>, <A HREF="#_m_punpckhwd">_m_punpckhwd</A>,
<A HREF="#_m_punpckldq">_m_punpckldq</A>, <A HREF="#_m_punpcklwd">_m_punpcklwd</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><BR><TT>#define AS_BYTES &quot;%2.2x %2.2x %2.2x %2.2x &quot; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;%2.2x %2.2x
%2.2x %2.2x&quot;</TT>
<BR><BR><TT>__m64&nbsp;&nbsp; a;</TT>
<BR><TT>__m64&nbsp;&nbsp; b = { 0x000200013478bcf0 };</TT>
<BR><TT>__m64&nbsp;&nbsp; c = { 0x0080007f12569ade };</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; a = _m_punpcklbw( b, c );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;m2=&quot;AS_BYTES&quot; &quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m1=&quot;AS_BYTES&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_BYTES&quot;\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._8[7], c._8[6], c._8[5], c._8[4],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._8[3], c._8[2], c._8[1], c._8[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._8[7], b._8[6], b._8[5], b._8[4],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._8[3], b._8[2], b._8[1], b._8[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._8[7], a._8[6], a._8[5], a._8[4],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._8[3], a._8[2], a._8[1], a._8[0] );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>m2=00 80 00 7f 12 56 9a de m1=00 02 00 01 34 78 bc f0</TT>
<BR><TT>mm=12 34 56 78 9a bc de f0</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="_m_punpckldq"> _m_punpckldq </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><TT>__m64 _m_punpckldq(__m64 *m1, __m64 *m2);</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _m_punpckldq</TT> function performs an interleaved unpack of the low-order data elements of<B> m1</B> and<B> m2</B>.
&nbsp;It ignores the high-order double-words.&nbsp; When unpacking from a memory operand, 32 bits are accessed and all are
utilized by the instruction.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m2&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -------------------------&nbsp; -------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; d1&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; d0&nbsp;&nbsp;&nbsp;
|&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; d1&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; d0&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -------------------------&nbsp; -------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; V&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; V</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; d1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d0</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;
&nbsp;&nbsp; d1&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; d0&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; result</TT>
</DL>
<DL>
<DT>Returns:
<DD>The result of the interleaved unpacking of the low-order double-words of two multimedia values is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_m_empty">_m_empty</A>, <A HREF="#_m_punpckhbw">_m_punpckhbw</A>, <A HREF="#_m_punpckhdq">_m_punpckhdq</A>, <A HREF="#_m_punpckhwd">_m_punpckhwd</A>,
<A HREF="#_m_punpcklbw">_m_punpcklbw</A>, <A HREF="#_m_punpcklwd">_m_punpcklwd</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><BR><TT>#define AS_DWORDS &quot;%8.8lx %8.8lx&quot;</TT>
<BR><BR><TT>__m64&nbsp;&nbsp; a;</TT>
<BR><TT>__m64&nbsp;&nbsp; b = { 0x0004000300020001 };</TT>
<BR><TT>__m64&nbsp;&nbsp; c = { 0xff7fff800080007f };</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; a = _m_punpckldq( b, c );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;m2=&quot;AS_DWORDS&quot; &quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m1=&quot;AS_DWORDS&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_DWORDS&quot;\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._32[1], c._32[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._32[1], b._32[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._32[1], a._32[0] );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>m2=ff7fff80 0080007f m1=00040003 00020001</TT>
<BR><TT>mm=0080007f 00020001</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="_m_punpcklwd"> _m_punpcklwd </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><TT>__m64 _m_punpcklwd(__m64 *m1, __m64 *m2);</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _m_punpcklwd</TT> function performs an interleaved unpack of the low-order data elements of<B> m1</B> and<B> m2</B>.
&nbsp;It ignores the high-order words.&nbsp; When unpacking from a memory operand, 32 bits are accessed and all are utilized
by the instruction.&nbsp; By choosing<B> m1</B> or<B> m2</B> to be zero, an unpacking of word elements into double-word elements
is performed.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m2&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -------------------------&nbsp; -------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; w3 |&nbsp; w2 |&nbsp; w1 |&nbsp; w0 |&nbsp; |&nbsp; w3 |&nbsp; w2 |&nbsp; w1 |&nbsp;
w0 |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -------------------------&nbsp; -------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
V&nbsp;&nbsp;&nbsp;&nbsp; V&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; V&nbsp;&nbsp;&nbsp; V</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
w3&nbsp;&nbsp;&nbsp; w1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;w2&nbsp;&nbsp;&nbsp; w0</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;
w3 |&nbsp; w2 |&nbsp; w1 |&nbsp; w0 |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; result</TT>
</DL>
<DL>
<DT>Returns:
<DD>The result of the interleaved unpacking of the low-order words of two multimedia values is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_m_empty">_m_empty</A>, <A HREF="#_m_punpckhbw">_m_punpckhbw</A>, <A HREF="#_m_punpckhdq">_m_punpckhdq</A>, <A HREF="#_m_punpckhwd">_m_punpckhwd</A>,
<A HREF="#_m_punpcklbw">_m_punpcklbw</A>, <A HREF="#_m_punpckldq">_m_punpckldq</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><BR><TT>#define AS_WORDS &quot;%4.4x %4.4x %4.4x %4.4x&quot;</TT>
<BR><BR><TT>__m64&nbsp;&nbsp; a;</TT>
<BR><TT>__m64&nbsp;&nbsp; b = { 0x0004000300020001 };</TT>
<BR><TT>__m64&nbsp;&nbsp; c = { 0xff7fff800080007f };</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; a = _m_punpcklwd( b, c );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;m2=&quot;AS_WORDS&quot; &quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m1=&quot;AS_WORDS&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_WORDS&quot;\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._16[3], c._16[2], c._16[1], c._16[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._16[3], b._16[2], b._16[1], b._16[0],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._16[3], a._16[2], a._16[1], a._16[0] );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>m2=ff7f ff80 0080 007f m1=0004 0003 0002 0001</TT>
<BR><TT>mm=0080 0002 007f 0001</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="_m_pxor"> _m_pxor </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><TT>__m64 _m_pxor(__m64 *m1, __m64 *m2);</TT>
</DL>
<DL>
<DT>Description:
<DD>A bit-wise logical XOR is performed between 64-bit multimedia operands<B> m1</B> and<B> m2</B> and the result is stored in
memory.
</DL>
<DL>
<DT>Returns:
<DD>The bit-wise logical exclusive OR of two 64-bit values is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_m_empty">_m_empty</A>, <A HREF="#_m_pand">_m_pand</A>, <A HREF="#_m_pandn">_m_pandn</A>, <A HREF="#_m_por">_m_por</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><BR><TT>#define AS_QWORD &quot;%16.16Lx&quot;</TT>
<BR><BR><TT>__m64&nbsp;&nbsp; a;</TT>
<BR><TT>__m64&nbsp;&nbsp; b = { 0x0123456789abcdef };</TT>
<BR><TT>__m64&nbsp;&nbsp; c = { 0xfedcba9876543210 };</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; a = _m_pxor( b, c );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_QWORD&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_QWORD&quot;\n&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_QWORD&quot;\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b, c, a );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>m1=0123456789abcdef</TT>
<BR><TT>m2=fedcba9876543210</TT>
<BR><TT>mm=ffffffffffffffff</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="_msize"> _msize Functions </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;malloc.h&gt;</TT>
<BR><TT>size_t _msize( void *buffer );</TT>
<BR><TT>size_t _bmsize( __segment seg, void __based(void) *buffer );</TT>
<BR><TT>size_t _fmsize( void __far *buffer );</TT>
<BR><TT>size_t _nmsize( void __near *buffer );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _msize</TT> functions return the size of the memory block pointed to by<B> buffer</B> that was allocated by a call
to the appropriate version of the <TT> calloc</TT>, <TT> malloc</TT>, or <TT> realloc</TT> functions.
<BR><BR>You must use the correct<TT> _msize</TT> function as listed below depending on which heap the memory block belongs
to.
<DL>
<DT>Function&nbsp;&nbsp;&nbsp;&nbsp; Heap
<DT>_msize
<DD>Depends on data model of the program
<DT>_bmsize
<DD>Based heap specified by<B> seg</B> value
<DT>_fmsize
<DD>Far heap (outside the default data segment)
<DT>_nmsize
<DD>Near heap (inside the default data segment)
</DL>
<BR>In small data models (small and medium memory models),<TT> _msize</TT> maps to <TT> _nmsize</TT>.&nbsp; In large data
models (compact, large and huge memory models), _msize maps to <TT> _fmsize</TT>.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _msize</TT> functions return the size of the memory block pointed to by<B> buffer</B>.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#calloc">calloc</A> Functions, <A HREF="#_expand">_expand</A> Functions, <A HREF="#free">free</A> Functions, <A HREF="#halloc">halloc</A>,
<A HREF="#hfree">hfree</A>, <A HREF="#malloc">malloc</A> Functions, <A HREF="#realloc">realloc</A> Functions, <A HREF="#sbrk">sbrk</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;malloc.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; void *buffer;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; buffer = malloc( 999 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Size of block is %u bytes\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _msize( buffer ) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>Size of block is 1000 bytes</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> _msize - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_bmsize - DOS/16, Windows, OS/2 1.x(all)</TT>
<BR><TT>_fmsize - DOS/16, Windows, OS/2 1.x(all)</TT>
<BR><TT>_nmsize - DOS, Windows, Win386, Win32, OS/2 1.x, OS/2 1.x(MT), OS/2-32, Linux, RDOS</TT>
</DL>
<H2 ID="msync"> msync </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;sys/mman.h&gt;</TT>
<BR><TT>int msync(void *address, size_t len, int flags)</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> msync</TT> function writes all modified data to permanent storage corresponding to the memory mapping at<B> address</B>
measuring<B> len</B> bytes.
<BR><BR>The<B> flags</B> argument may be one or a combination of the following:
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>MS_ASYNC
<DD>Perform asynchronous writes
<DT>MS_SYNC
<DD>Perform synchronous writes
<DT>MS_INVALIDATE
<DD>Invalidate any cached data
</DL>
<BR>The flags <TT> MS_ASYNC</TT> and <TT> MS_SYNC</TT> may not be combined.
</DL>
<DL>
<DT>Returns:
<DD>If successful, the function will return 0.&nbsp; Upon failure, the function will return -1, and errno will be set appropriately.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>EINVAL
<DD>The argument<B> address</B> is not a multiple of the page size or the<B> flags</B> argument is invalid
<DT>ENOMEM
<DD>The arguments do not correspond to a region of the process's address space or exceed the process's address space
<DT>EBUSY
<DD>A portion of or all of the address space specified is currently locked
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#mlock">mlock</A>, <A HREF="#mlockall">mlockall</A>, <A HREF="#mmap">mmap</A>, <A HREF="#munlock">munlock</A>, <A HREF="#munlockall">munlockall</A>,
<A HREF="#munmap">munmap</A>
</DL>
<DL>
<DT>Classification:
<DD>POSIX
</DL>
<DL>
<DT>Systems:
<DD>Linux
</DL>
<H2 ID="_m_to_int"> _m_to_int </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><TT>int&nbsp;&nbsp; _m_to_int(__m64 *__m);</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _m_to_int</TT> function returns the low-order 32 bits of a multimedia value.
</DL>
<DL>
<DT>Returns:
<DD>The low-order 32 bits of a multimedia value are fetched and returned as the result.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_m_empty">_m_empty</A>, <A HREF="#_m_from_int">_m_from_int</A>, <A HREF="#_m_packsswb">_m_packsswb</A>, <A HREF="#_m_paddb">_m_paddb</A>,
<A HREF="#_m_pand">_m_pand</A>, <A HREF="#_m_empty">_m_empty</A>, <A HREF="#_m_pcmpeqb">_m_pcmpeqb</A>, <A HREF="#_m_pmaddwd">_m_pmaddwd</A>,
<A HREF="#_m_psllw">_m_psllw</A>, <A HREF="#_m_psraw">_m_psraw</A>, <A HREF="#_m_psrlw">_m_psrlw</A>, <A HREF="#_m_empty">_m_empty</A>,
<A HREF="#_m_psubb">_m_psubb</A>, <A HREF="#_m_punpckhbw">_m_punpckhbw</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mmintrin.h&gt;</TT>
<BR><BR><TT>__m64&nbsp;&nbsp; b = { 0x0123456789abcdef };</TT>
<BR><BR><TT>int&nbsp;&nbsp;&nbsp;&nbsp; j;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; j = _m_to_int( b );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;m=%16.16Lx int=%8.8lx\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b, j );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>m=0123456789abcdef int=89abcdef</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="munlock"> munlock </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;sys/mman.h&gt;</TT>
<BR><TT>int munlock(void *address, size_t len)</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> munlock</TT> function causes memory located at<B> address</B> measuring<B> len</B> bytes to be released regardless
of the number of prior calls to lock the referenced memory.
</DL>
<DL>
<DT>Returns:
<DD>If successful, the function will return 0.&nbsp; Upon failure, the function will return -1, and errno will be set appropriately.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>EINVAL
<DD>The argument<B> address</B> is not a multiple of the page size or the<B> len</B> is zero or causes an overflow
<DT>ENOMEM
<DD>The arguments do not correspond to a region of the process's address space
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#mlock">mlock</A>, <A HREF="#mlockall">mlockall</A>, <A HREF="#munlockall">munlockall</A>
</DL>
<DL>
<DT>Classification:
<DD>POSIX
</DL>
<DL>
<DT>Systems:
<DD>Linux
</DL>
<H2 ID="munlockall"> munlockall </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;sys/mman.h&gt;</TT>
<BR><TT>int munlockall( )</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> munlockall</TT> function unlocks all memory for a process.&nbsp; If, in the preceding call to <TT> mlockall</TT> function,
the flag <TT> MCL_FUTURE</TT> was specified, all future pages mapped for the process will also not be locked unless another
call to <TT> mlockall</TT> specifies such behavior.
</DL>
<DL>
<DT>Returns:
<DD>If successful, the function will return 0.&nbsp; Upon failure, the function will return -1, and errno will be set appropriately.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#mlock">mlock</A>, <A HREF="#mlockall">mlockall</A>, <A HREF="#munlock">munlock</A>
</DL>
<DL>
<DT>Classification:
<DD>POSIX
</DL>
<DL>
<DT>Systems:
<DD>Linux
</DL>
<H2 ID="munmap"> munmap </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;sys/mman.h&gt;</TT>
<BR><TT>int munmap(void *address, size_t len)</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> munmap</TT> function removes any mapping at the address<B> address</B> measuring<B> len</B> bytes from the process
address space.
</DL>
<DL>
<DT>Returns:
<DD>If successful, the function will return 0.&nbsp; Upon failure, the function will return -1, and errno will be set appropriately.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>EINVAL
<DD>Either one or both of the arguments was invalid.
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#mmap">mmap</A>
</DL>
<DL>
<DT>Classification:
<DD>POSIX
</DL>
<DL>
<DT>Systems:
<DD>Linux
</DL>
<H2 ID="nan"> nan </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>float nanf( const char *str );</TT>
<BR><TT>double nan( const char *str );</TT>
<BR><TT>long double nanl( const char *str );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> nan</TT> function returns not-a-number, or NAN.&nbsp; The argument<B> str</B> is ignored.
</DL>
<DL>
<DT>Returns:
<DD>The proper not-a-number value.
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, nan(&quot;&quot;) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>nan</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C99
</DL>
<DL>
<DT>Systems:
<DD>Math
</DL>
<H2 ID="nearbyint"> nearbyint </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>double nearbyint( double x );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> nearbyint</TT> function rounds the argument<B> x</B> to a nearby integer without the possibility of throwing an exception.
&nbsp;The direction of the rounding is determined by the current value of <TT> fegetround</TT>.
</DL>
<DL>
<DT>Returns:
<DD>The rounded value of<B> x</B>.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#fegetround">fegetround</A>, <A HREF="#fesetround">fesetround</A>, <A HREF="#rint">rint</A>, <A HREF="#round">round</A>,
<A HREF="#trunc">trunc</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fesetround(FE_TONEAREST);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, nearbyint( 1.2 ) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>1.000000</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C99
</DL>
<DL>
<DT>Systems:
<DD>Math
</DL>
<H2 ID="nextafter"> nextafter </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>double nextafter( double x, double y );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> nextafter</TT> function returns the next machine floating point number of<B> x</B> in the direction towards<B> y</B>.
</DL>
<DL>
<DT>Returns:
<DD>The next representable floating point value after or before<B> x</B> in the direction of<B> y</B>.
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, nextafter( 8.0, 9.0 ) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>8.000000</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C99
</DL>
<DL>
<DT>Systems:
<DD>Math
</DL>
<H2 ID="nl_langinfo"> nl_langinfo </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;langinfo.h&gt;</TT>
<BR><TT>char *nl_langinfo( int item );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> nl_langinfo</TT> function retrieves language information, purportedly based on the current locale.&nbsp; The<B> item</B>
argument specifies which language element to retrieve, and may be one of the following:
<DL>
<DT>Member&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>CODESET
<DD>The character encoding supported by this locale
<DT>D_T_FMT
<DD>The date and time format string
<DT>D_FMT
<DD>The date format string
<DT>T_FMT
<DD>The 24-hour time format string
<DT>T_FMT_AMPM
<DD>The 12-hour time format string
<DT>AM_STR
<DD>The string representing ante-meridiem time
<DT>PM_STR
<DD>The string representing post-meridiem time
<DT>DAY_1
<DD>The name of the first day of the week
<DT>DAY_2
<DD>The name of the second day of the week
<DT>DAY_3
<DD>The name of the third day of the week
<DT>DAY_4
<DD>The name of the fourth day of the week
<DT>DAY_5
<DD>The name of the fifth day of the week
<DT>DAY_6
<DD>The name of the sixth day of the week
<DT>DAY_7
<DD>The name of the seventh day of the week
<DT>ABDAY_1
<DD>The abbreviated name of the first day of the week
<DT>ABDAY_2
<DD>The abbreviated name of the second day of the week
<DT>ABDAY_3
<DD>The abbreviated name of the third day of the week
<DT>ABDAY_4
<DD>The abbreviated name of the fourth day of the week
<DT>ABDAY_5
<DD>The abbreviated name of the fifth day of the week
<DT>ABDAY_6
<DD>The abbreviated name of the sixth day of the week
<DT>ABDAY_7
<DD>The abbreviated name of the seventh day of the week
<DT>MON_1
<DD>The name of the first month of the year
<DT>MON_2
<DD>The name of the second month of the year
<DT>MON_3
<DD>The name of the third month of the year
<DT>MON_4
<DD>The name of the fourth month of the year
<DT>MON_5
<DD>The name of the fifth month of the year
<DT>MON_6
<DD>The name of the sixth month of the year
<DT>MON_7
<DD>The name of the seventh month of the year
<DT>MON_8
<DD>The name of the eighth month of the year
<DT>MON_9
<DD>The name of the ninth month of the year
<DT>MON_10
<DD>The name of the tenth month of the year
<DT>MON_11
<DD>The name of the eleventh month of the year
<DT>MON_12
<DD>The name of the twelfth month of the year
<DT>ABMON_1
<DD>The abbreviated name of the first month of the year
<DT>ABMON_2
<DD>The abbreviated name of the second month of the year
<DT>ABMON_3
<DD>The name of the third month of the year
<DT>ABMON_4
<DD>The abbreviated name of the fourth month of the year
<DT>ABMON_5
<DD>The abbreviated name of the fifth month of the year
<DT>ABMON_6
<DD>The abbreviated name of the sixth month of the year
<DT>ABMON_7
<DD>The abbreviated name of the seventh month of the year
<DT>ABMON_8
<DD>The abbreviated name of the eighth month of the year
<DT>ABMON_9
<DD>The abbreviated name of the ninth month of the year
<DT>ABMON_10
<DD>The abbreviated name of the tenth month of the year
<DT>ABMON_11
<DD>The abbreviated name of the eleventh month of the year
<DT>ABMON_12
<DD>The abbreviated name of the twelfth month of the year
<DT>RADIXCHAR
<DD>The radix character
<DT>THOUSEP
<DD>The separator for thousands
<DT>YESEXPR
<DD>The string for indicating affirmative responses
<DT>NOEXPR
<DD>The string for indicating negative responses
</DL>
<BR>In the default locale (C), some values may be U.S.A.-centric, specifically the RADIXCHAR and THOUSEP.&nbsp; Additionally,
names are in English presently.
</DL>
<DL>
<DT>Returns:
<DD>The function returns a pointer to a statically allocated string that must not be freed.&nbsp; If<B> item</B> is either unsupported
or unknown, an empty string will be returned.
</DL>
<DL>
<DT>Classification:
<DD>POSIX
</DL>
<DL>
<DT>Systems:
<DD>Linux
</DL>
<H2 ID="nosound"> nosound </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;i86.h&gt;</TT>
<BR><TT>void nosound( void );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> nosound</TT> function turns off the PC's speaker.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> nosound</TT> function has no return value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#delay">delay</A>, <A HREF="#sound">sound</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;i86.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; sound( 200 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; delay( 500 );&nbsp; /* delay for 1/2 second */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; nosound();</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386
</DL>
<H2 ID="offsetof"> offsetof </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stddef.h&gt;</TT>
<BR><TT>size_t offsetof( composite, name );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> offsetof</TT> macro returns the offset of the element<B> name</B> within the <TT> struct</TT> or <TT> union</TT><B>
composite</B>.&nbsp; This provides a portable method to determine the offset.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> offsetof</TT> function returns the offset of<B> name</B>.
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stddef.h&gt;</TT>
<BR><BR><TT>struct new_def</TT>
<BR><TT>{&nbsp; char *first;</TT>
<BR><TT>&nbsp;&nbsp; char second[10];</TT>
<BR><TT>&nbsp;&nbsp; int third;</TT>
<BR><TT>};</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;first:%d second:%d third:%d\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offsetof( struct new_def, first ),</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offsetof( struct new_def, second ),</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offsetof( struct new_def, third ) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR>In a small data model, the following would result:
<BR><BR><TT>first:0 second:2 third:12</TT>
<BR><BR>In a large data model, the following would result:
<BR><BR><TT>first:0 second:4 third:14</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="onexit"> onexit </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>onexit_t onexit( onexit_t func );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> onexit</TT> function is passed the address of function<B> func</B> to be called when the program terminates normally.
&nbsp;Successive calls to<TT> onexit</TT> create a list of functions that will be executed on a &quot;last-in, first-out&quot;
basis.&nbsp; No more than 32 functions can be registered with the<TT> onexit</TT> function.
<BR><BR>The functions have no parameters and do not return values.
<BR><BR>NOTE:&nbsp; The<TT> onexit</TT> function is not an ISO C function.&nbsp; The ISO C standard function <TT> atexit</TT>
does the same thing that<TT> onexit</TT> does and should be used instead of onexit where ISO C portability is concerned.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> onexit</TT> function returns<B> func</B> if the registration succeeds, NULL if it fails.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#abort">abort</A>, <A HREF="#atexit">atexit</A>, <A HREF="#exit">exit</A>, <A HREF="#_Exit">_Exit</A>, <A HREF="#_exit">_exit</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; extern void func1(void), func2(void), func3(void);</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; onexit( func1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; onexit( func2 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; onexit( func3 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Do this first.\n&quot; );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR><TT>void func1(void) { printf( &quot;last.\n&quot; ); }</TT>
<BR><TT>void func2(void) { printf( &quot;this &quot; ); }</TT>
<BR><TT>void func3(void) { printf( &quot;Do &quot; ); }</TT>
<BR><BR>produces the following:
<BR><BR><TT>Do this first.</TT>
<BR><TT>Do this last.</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="open"> open, _open, _wopen </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;sys/types.h&gt;</TT>
<BR><TT>#include &lt;sys/stat.h&gt;</TT>
<BR><TT>#include &lt;fcntl.h&gt;</TT>
<BR><TT>int open( const char *path, int access, ... );</TT>
<BR><TT>int _open( const char *path, int access, ... );</TT>
<BR><TT>int _wopen( const wchar_t *path, int access, ... );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> open</TT> function opens a file at the operating system level.&nbsp; The name of the file to be opened is given by<B>
path</B>.&nbsp; The file will be accessed according to the access mode specified by<B> access</B>.&nbsp; The optional argument
is the file permissions to be used when the <TT> O_CREAT</TT> flag is on in the<B> access</B> mode.
<BR><BR>The<TT> _open</TT> function is identical to<TT> open</TT>.&nbsp; Use<TT> _open</TT> for ANSI naming conventions.
<BR><BR>The<TT> _wopen</TT> function is identical to<TT> open</TT> except that it accepts a wide character string argument
for<B> path</B>.
<BR><BR>The access mode is established by a combination of the bits defined in the<TT> &lt;fcntl.h&gt;</TT> header file.&nbsp;
The following bits may be set:
<DL>
<DT>Mode&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>O_RDONLY
<DD>permit the file to be only read.
<DT>O_WRONLY
<DD>permit the file to be only written.
<DT>O_RDWR
<DD>permit the file to be both read and written.
<DT>O_APPEND
<DD>causes each record that is written to be written at the end of the file.
<DT>O_CREAT
<DD>has no effect when the file indicated by<B> filename</B> already exists; otherwise, the file is created;
<DT>O_TRUNC
<DD>causes the file to be truncated to contain no data when the file exists; has no effect when the file does not exist.
<DT>O_BINARY
<DD>causes the file to be opened in binary mode which means that data will be transmitted to and from the file unchanged.
<DT>O_TEXT
<DD>causes the file to be opened in text mode which means that carriage-return characters are written before any linefeed character
that is written and causes carriage-return characters to be removed when encountered during reads.
<DT>O_NOINHERIT
<DD>indicates that this file is not to be inherited by a child process.
<DT>O_EXCL
<DD>indicates that this file is to be opened for exclusive access.&nbsp; If the file exists and <TT> O_CREAT</TT> was also specified
then the open will fail (i.e., use <TT> O_EXCL</TT> to ensure that the file does not already exist).
</DL>
<BR>When neither <TT> O_TEXT</TT> nor <TT> O_BINARY</TT> are specified, the default value in the global variable <TT> _fmode</TT>
is used to set the file translation mode.&nbsp; When the program begins execution, this variable has a value of <TT> O_TEXT</TT>.
<BR><BR><TT> O_CREAT</TT> must be specified when the file does not exist and it is to be written.
<BR><BR>When the file is to be created (<TT> O_CREAT</TT> is specified), an additional argument must be passed which contains
the file permissions to be used for the new file.&nbsp; The access permissions for the file or directory are specified as
a combination of bits (defined in the<TT> &lt;sys/stat.h&gt;</TT> header file).
<BR><BR>The following bits define permissions for the owner.
<DL>
<DT>Permission&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>S_IRWXU
<DD>Read, write, execute/search
<DT>S_IRUSR
<DD>Read permission
<DT>S_IWUSR
<DD>Write permission
<DT>S_IXUSR
<DD>Execute/search permission
</DL>
<BR>The following bits define permissions for the group.
<DL>
<DT>Permission&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>S_IRWXG
<DD>Read, write, execute/search
<DT>S_IRGRP
<DD>Read permission
<DT>S_IWGRP
<DD>Write permission
<DT>S_IXGRP
<DD>Execute/search permission
</DL>
<BR>The following bits define permissions for others.
<DL>
<DT>Permission&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>S_IRWXO
<DD>Read, write, execute/search
<DT>S_IROTH
<DD>Read permission
<DT>S_IWOTH
<DD>Write permission
<DT>S_IXOTH
<DD>Execute/search permission
</DL>
<BR>The following bits define miscellaneous permissions used by other implementations.
<DL>
<DT>Permission&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>S_IREAD
<DD>is equivalent to S_IRUSR (read permission)
<DT>S_IWRITE
<DD>is equivalent to S_IWUSR (write permission)
<DT>S_IEXEC
<DD>is equivalent to S_IXUSR (execute/search permission)
</DL>
<BR>All files are readable with DOS; however, it is a good idea to set <TT> S_IREAD</TT> when read permission is intended
for the file.
<BR><BR>The<TT> open</TT> function applies the current file permission mask to the specified permissions (see <TT> umask</TT>).
</DL>
<DL>
<DT>Returns:
<DD>If successful,<TT> open</TT> returns a handle for the file.&nbsp; When an error occurs while opening the file, -1 is returned.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>EACCES
<DD>Access denied because<B> path</B> specifies a directory or a volume ID, or attempting to open a read-only file for writing
<DT>EMFILE
<DD>No more handles available (too many open files)
<DT>ENOENT
<DD>Path or file not found
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#chsize">chsize</A>, <A HREF="#close">close</A>, <A HREF="#creat">creat</A>, <A HREF="#dup">dup</A>, <A HREF="#dup2">dup2</A>,
<A HREF="#eof">eof</A>, <A HREF="#exec___">exec...</A>, <A HREF="#fdopen">fdopen</A>, <A HREF="#filelength">filelength</A>,
<A HREF="#fileno">fileno</A>, <A HREF="#fstat">fstat</A>, <A HREF="#_grow_handles">_grow_handles</A>, <A HREF="#isatty">isatty</A>,
<A HREF="#lseek">lseek</A>, <A HREF="#read">read</A>, <A HREF="#setmode">setmode</A>, <A HREF="#sopen">sopen</A>, <A HREF="#stat">stat</A>,
<A HREF="#tell">tell</A>, <A HREF="#write">write</A>, <A HREF="#umask">umask</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;sys/stat.h&gt;</TT>
<BR><TT>#include &lt;sys/types.h&gt;</TT>
<BR><TT>#include &lt;fcntl.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int handle;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* open a file for output&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* replace existing file if it exists&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; handle = open( &quot;file&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; O_WRONLY | O_CREAT | O_TRUNC,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S_IRUSR | S_IWUSR | S_IRGRP
| S_IWGRP );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; /* read a file which is assumed to exist&nbsp;&nbsp; */</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; handle = open( &quot;file&quot;, O_RDONLY );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; /* append to the end of an existing file&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* write a new file if file does not exist */</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; handle = open( &quot;file&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; O_WRONLY | O_CREAT | O_APPEND,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S_IRUSR | S_IWUSR | S_IRGRP
| S_IWGRP );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>POSIX 1003.1
<BR><BR>_open conforms to ANSI naming conventions
<BR>_wopen is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> open - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_open - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
<BR><TT>_wopen - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, Linux</TT>
</DL>
<H2 ID="opendir"> opendir, _wopendir </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;direct.h&gt;</TT>
<BR><TT>DIR *opendir( const char *dirname );</TT>
<BR><TT>WDIR *_wopendir( const wchar_t *dirname );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> opendir</TT> function is used in conjunction with the functions <TT> readdir</TT> and <TT> closedir</TT> to obtain
the list of file names contained in the directory specified by<B> dirname</B>.&nbsp; The path indicated by<B> dirname</B>
can be either relative to the current working directory or it can be an absolute path name.&nbsp; As an extension to POSIX,
the last part of<B> dirname</B> can contain the characters '?' and '*' for matching multiple files within a directory.
<BR><BR>The file<TT> &lt;direct.h&gt;</TT> contains definitions for the structure <TT> dirent</TT>.
<BR><BR><TT>#if defined(__OS2__) || defined(__NT__)</TT>
<BR><TT>#define NAME_MAX 255&nbsp;&nbsp;&nbsp; /* maximum for HPFS or NTFS */</TT>
<BR><TT>#else</TT>
<BR><TT>#define NAME_MAX&nbsp; 12&nbsp;&nbsp;&nbsp; /* 8 chars + '.' +&nbsp; 3 chars */</TT>
<BR><TT>#endif</TT>
<BR><BR><TT>struct dirent {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; d_dta[ 21 ];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* disk transfer
area */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; d_attr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;/* file's attribute */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned short int d_time;&nbsp; /* file's time */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned short int d_date;&nbsp; /* file's date */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; long&nbsp;&nbsp;&nbsp; d_size;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;/* file's size */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; d_name[ NAME_MAX + 1 ]; /* file's name */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned short d_ino;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* serial number */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; d_first;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* flag for 1st time */</TT>
<BR><TT>};</TT>
<BR>The file attribute field <TT> d_attr</TT> field is a set of bits representing the following attributes.
<BR><BR><TT>_A_RDONLY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Read-only file */</TT>
<BR><TT>_A_HIDDEN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Hidden file */</TT>
<BR><TT>_A_SYSTEM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* System file */</TT>
<BR><TT>_A_VOLID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Volume-ID entry (only MSFT knows) */</TT>
<BR><TT>_A_SUBDIR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Subdirectory */</TT>
<BR><TT>_A_ARCH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Archive file */</TT>
<BR>If the<TT> _A_RDONLY</TT> bit is off, then the file is read/write.
<BR><BR>The format of the <TT> d_time</TT> field is described by the following structure (this structure is not defined in
any Open Watcom header file).
<BR><BR><TT>typedef struct {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; twosecs : 5;&nbsp;&nbsp;&nbsp; /* seconds / 2 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; minutes : 6;&nbsp;&nbsp;&nbsp; /* minutes (0,59) */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; hours&nbsp;&nbsp; : 5;&nbsp;&nbsp;&nbsp; /* hours (0,23) */</TT>
<BR><TT>} ftime_t;</TT>
<BR>The format of the <TT> d_date</TT> field is described by the following structure (this structure is not defined in any
Open Watcom header file).
<BR><BR><TT>typedef struct {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; day&nbsp;&nbsp;&nbsp;&nbsp; : 5;&nbsp;&nbsp;&nbsp; /* day (1,31) */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; month&nbsp;&nbsp; : 4;&nbsp;&nbsp;&nbsp; /* month (1,12) */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; year&nbsp;&nbsp;&nbsp; : 7;&nbsp;&nbsp;&nbsp; /* 0 is 1980 */</TT>
<BR><TT>} fdate_t;</TT>
<BR>See the sample program below for an example of the use of these structures.
<BR><BR>More than one directory can be read at the same time using the <TT> opendir</TT>, <TT> readdir</TT>, and <TT> closedir</TT>
functions.
<BR><BR>The<TT> _wopendir</TT> function is identical to<TT> opendir</TT> except that it accepts a wide-character string argument
and returns a pointer to a <TT> _wdirent</TT> structure that can be used with the <TT> _wreaddir</TT> and <TT> _wclosedir</TT>
functions.
<BR><BR>The file<TT> &lt;direct.h&gt;</TT> contains definitions for the structure <TT> _wdirent</TT>.
<BR><BR><TT>struct _wdirent {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; d_dta[21];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* disk transfer area */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; d_attr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* file's attribute
*/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned short int d_time;/* file's time */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned short int d_date;/* file's date */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; long&nbsp;&nbsp;&nbsp; d_size;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* file's size */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; wchar_t d_name[NAME_MAX+1];/* file's name */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned short d_ino;&nbsp;&nbsp; /* serial number (not used) */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; d_first;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* flag for 1st time
*/</TT>
<BR><TT>};</TT>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> opendir</TT> function, if successful, returns a pointer to a structure required for subsequent calls to <TT> readdir</TT>
to retrieve the file names matching the pattern specified by<B> dirname</B>.&nbsp; The<TT> opendir</TT> function returns<TT>
NULL</TT> if<B> dirname</B> is not a valid pathname, or if there are no files matching<B> dirname</B>.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>EACCES
<DD>Search permission is denied for a component of<B> dirname</B> or read permission is denied for<B> dirname</B>.
<DT>ENOENT
<DD>The named directory does not exist.
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#closedir">closedir</A>, <A HREF="#_dos_find___">_dos_find...</A>, <A HREF="#readdir">readdir</A>, <A HREF="#rewinddir">rewinddir</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR>To get a list of files contained in the directory<TT> \watcom\h</TT> on your default disk:
<BR><BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;direct.h&gt;</TT>
<BR><BR><TT>typedef struct {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; twosecs : 5;&nbsp;&nbsp;&nbsp; /* seconds / 2 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; minutes : 6;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; hours&nbsp;&nbsp; : 5;</TT>
<BR><TT>} ftime_t;</TT>
<BR><BR><TT>typedef struct {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; day&nbsp;&nbsp;&nbsp;&nbsp; : 5;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; month&nbsp;&nbsp; : 4;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; year&nbsp;&nbsp;&nbsp; : 7;</TT>
<BR><TT>} fdate_t;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; DIR *dirp;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct dirent *direntp;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ftime_t *f_time;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fdate_t *f_date;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; dirp = opendir( &quot;\\watcom\\h&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( dirp != NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(;;) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; direntp = readdir( dirp );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( direntp == NULL ) break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f_time = (ftime_t *)&amp;direntp-&gt;d_time;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f_date = (fdate_t *)&amp;direntp-&gt;d_date;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%-12s %d/%2.2d/%2.2d &quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;%2.2d:%2.2d:%2.2d
\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; direntp-&gt;d_name,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f_date-&gt;year + 1980,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f_date-&gt;month,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f_date-&gt;day,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f_time-&gt;hours,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f_time-&gt;minutes,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f_time-&gt;twosecs * 2 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; closedir( dirp );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>Note the use of two adjacent backslash characters (\) within character-string constants to signify a single backslash.
</DL>
<DL>
<DT>Classification:
<DD>POSIX 1003.1
<BR><BR>_wopendir is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> opendir - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_wopendir - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</TT>
</DL>
<H2 ID="_open_osfhandle"> _open_osfhandle </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;io.h&gt;</TT>
<BR><TT>int _open_osfhandle( long osfhandle, int access );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _open_osfhandle</TT> function allocates a POSIX-level file handle and sets it to point to the operating system's internal
file handle specified by<B> osfhandle</B>.&nbsp; The value returned by <TT> _get_osfhandle</TT> can be used as an argument
to the<TT> _open_osfhandle</TT> function.
<BR><BR>The access mode is established by a combination of the bits defined in the<TT> &lt;fcntl.h&gt;</TT> header file.&nbsp;
The following bits may be set:
<DL>
<DT>Mode&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>O_RDONLY
<DD>permit the file to be only read.
<DT>O_WRONLY
<DD>permit the file to be only written.
<DT>O_RDWR
<DD>permit the file to be both read and written.
<DT>O_APPEND
<DD>causes each record that is written to be written at the end of the file.
<DT>O_CREAT
<DD>has no effect when the file indicated by<B> filename</B> already exists; otherwise, the file is created;
<DT>O_TRUNC
<DD>causes the file to be truncated to contain no data when the file exists; has no effect when the file does not exist.
<DT>O_BINARY
<DD>causes the file to be opened in binary mode which means that data will be transmitted to and from the file unchanged.
<DT>O_TEXT
<DD>causes the file to be opened in text mode which means that carriage-return characters are written before any linefeed character
that is written and causes carriage-return characters to be removed when encountered during reads.
<DT>O_NOINHERIT
<DD>indicates that this file is not to be inherited by a child process.
<DT>O_EXCL
<DD>indicates that this file is to be opened for exclusive access.&nbsp; If the file exists and <TT> O_CREAT</TT> was also specified
then the open will fail (i.e., use <TT> O_EXCL</TT> to ensure that the file does not already exist).
</DL>
<BR>When neither <TT> O_TEXT</TT> nor <TT> O_BINARY</TT> are specified, the default value in the global variable <TT> _fmode</TT>
is used to set the file translation mode.&nbsp; When the program begins execution, this variable has a value of <TT> O_TEXT</TT>.
<BR><BR><TT> O_CREAT</TT> must be specified when the file does not exist and it is to be written.
<BR><BR>When two or more manifest constants are used to form the<B> flags</B> argument, the constants are combined with the
bitwise-OR operator (|).
<BR><BR>The example below demonstrates the use of the <TT> _get_osfhandle</TT> and<TT> _open_osfhandle</TT> functions.&nbsp;
Note that the example shows how the <TT> dup2</TT> function can be used to obtain almost identical functionality.
<BR><BR>When the POSIX-level file handles associated with one OS file handle are closed, the first one closes successfully
but the others return an error (since the first call close the file and released the OS file handle).&nbsp; So it is important
to call <TT> close</TT> at the right time, i.e., after all I/O operations are completed to the file.
</DL>
<DL>
<DT>Returns:
<DD>If successful,<TT> _open_osfhandle</TT> returns a POSIX-style file handle.&nbsp; Otherwise, it returns -1.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#close">close</A>, <A HREF="#_dos_open">_dos_open</A>, <A HREF="#dup2">dup2</A>, <A HREF="#fdopen">fdopen</A>, <A HREF="#fopen">fopen</A>,
<A HREF="#freopen">freopen</A>, <A HREF="#_fsopen">_fsopen</A>, <A HREF="#_get_osfhandle">_get_osfhandle</A>, <A HREF="#_grow_handles">_grow_handles</A>,
<A HREF="#_hdopen">_hdopen</A>, <A HREF="#open">open</A>, <A HREF="#_os_handle">_os_handle</A>, <A HREF="#_popen">_popen</A>,
<A HREF="#sopen">sopen</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>#include &lt;io.h&gt;</TT>
<BR><TT>#include &lt;fcntl.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; long os_handle;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int fh1, fh2, rc;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; fh1 = open( &quot;file&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; O_WRONLY | O_CREAT | O_TRUNC
| O_BINARY,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S_IRUSR | S_IWUSR | S_IRGRP
| S_IWGRP );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( fh1 == -1 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Could not open output file\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit( EXIT_FAILURE );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;First POSIX handle %d\n&quot;, fh1 );</TT>
<BR><BR><TT>#if defined(USE_DUP2)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fh2 = 6;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( dup2( fh1, fh2 ) == -1 ) fh2 = -1;</TT>
<BR><TT>#else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; os_handle = _get_osfhandle( fh1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;OS Handle %ld\n&quot;, os_handle );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; fh2 = _open_osfhandle( os_handle, O_WRONLY |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; O_BINARY );</TT>
<BR><TT>#endif</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( fh2 == -1 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Could not open with second handle\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit( EXIT_FAILURE );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Second POSIX handle %d\n&quot;, fh2 );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; rc = write( fh2, &quot;trash\x0d\x0a&quot;, 7 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Write file using second handle %d\n&quot;, rc );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; rc = close( fh2 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Closing second handle %d\n&quot;, rc );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; rc = close( fh1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Closing first handle %d\n&quot;, rc );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, Netware
</DL>
<H2 ID="_os_handle"> _os_handle </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;io.h&gt;</TT>
<BR><TT>int _os_handle( int handle );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _os_handle</TT> function takes a POSIX-style file handle specified by<B> handle</B>.&nbsp; It returns the corresponding
operating system level handle.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _os_handle</TT> function returns the operating system handle that corresponds to the specified POSIX-style file handle.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#close">close</A>, <A HREF="#fdopen">fdopen</A>, <A HREF="#_get_osfhandle">_get_osfhandle</A>, <A HREF="#_hdopen">_hdopen</A>,
<A HREF="#open">open</A>, <A HREF="#_open_osfhandle">_open_osfhandle</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;io.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int handle;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FILE *fp;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; fp = fopen( &quot;file&quot;, &quot;r&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( fp != NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handle = _os_handle( fileno( fp ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( fp );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, Linux, Netware
</DL>
<H2 ID="_outgtext"> _outgtext </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>void _FAR _outgtext( char _FAR *text );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _outgtext</TT> function displays the character string indicated by the argument<B> text</B>.&nbsp; The string must
be terminated by a null character ('\0').
<BR><BR>The string is displayed starting at the current position (see the <TT> _moveto</TT> function) in the current color
and in the currently selected font (see the <TT> _setfont</TT> function).&nbsp; The current position is updated to follow
the displayed text.
<BR><BR>When no font has been previously selected with <TT> _setfont</TT>, a default font will be used.&nbsp; The default
font is an 8-by-8 bit-mapped font.
<BR><BR>The graphics library can display text in three different ways.
<OL>
<LI>The <TT> _outtext</TT> and <TT> _outmem</TT> functions can be used in any video mode.&nbsp; However, this variety of text
can be displayed in only one size.
<LI>The <TT> _grtext</TT> function displays text as a sequence of line segments, and can be drawn in different sizes, with
different orientations and alignments.
<LI>The <TT> _outgtext</TT> function displays text in the currently selected font.&nbsp; Both bit-mapped and vector fonts
are supported; the size and type of text depends on the fonts that are available.
</OL>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _outgtext</TT> function does not return a value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_registerfonts">_registerfonts</A>, <A HREF="#_unregisterfonts">_unregisterfonts</A>, <A HREF="#_setfont">_setfont</A>,
<A HREF="#_getfontinfo">_getfontinfo</A>, <A HREF="#_getgtextextent">_getgtextextent</A>, <A HREF="#_setgtextvector">_setgtextvector</A>,
<A HREF="#_getgtextvector">_getgtextvector</A>, <A HREF="#_outtext">_outtext</A>, <A HREF="#_outmem">_outmem</A>, <A HREF="#_grtext">_grtext</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int i, n;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char buf[ 10 ];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; n = _registerfonts( &quot;*.fon&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; n; ++i ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf( buf, &quot;n%d&quot;, i );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _setfont( buf );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _moveto( 100, 100 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _outgtext( &quot;WATCOM Graphics&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _clearscreen( _GCLEARSCREEN );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _unregisterfonts();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_outmem"> _outmem </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>void _FAR _outmem( char _FAR *text, short length );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _outmem</TT> function displays the character string indicated by the argument<B> text</B>.&nbsp; The argument<B> length</B>
specifies the number of characters to be displayed.&nbsp; Unlike the <TT> _outtext</TT> function,<TT> _outmem</TT> will display
the graphical representation of characters such as ASCII 10 and 0, instead of interpreting them as control characters.
<BR><BR>The text is displayed using the current text color (see the <TT> _settextcolor</TT> function), starting at the current
text position (see the <TT> _settextposition</TT> function).&nbsp; The text position is updated to follow the end of the displayed
text.
<BR><BR>The graphics library can display text in three different ways.
<OL>
<LI>The <TT> _outtext</TT> and <TT> _outmem</TT> functions can be used in any video mode.&nbsp; However, this variety of text
can be displayed in only one size.
<LI>The <TT> _grtext</TT> function displays text as a sequence of line segments, and can be drawn in different sizes, with
different orientations and alignments.
<LI>The <TT> _outgtext</TT> function displays text in the currently selected font.&nbsp; Both bit-mapped and vector fonts
are supported; the size and type of text depends on the fonts that are available.
</OL>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _outmem</TT> function does not return a value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_settextcolor">_settextcolor</A>, <A HREF="#_settextposition">_settextposition</A>, <A HREF="#_settextwindow">_settextwindow</A>,
<A HREF="#_grtext">_grtext</A>, <A HREF="#_outtext">_outtext</A>, <A HREF="#_outgtext">_outgtext</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int i;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char buf[ 1 ];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _clearscreen( _GCLEARSCREEN );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt;= 255; ++i ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _settextposition( 1 + i % 16,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 + 5 * ( i / 16 ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buf[ 0 ] = i;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _outmem( buf, 1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="outp"> outp </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>unsigned int outp( int port, int value );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> outp</TT> function writes one byte, determined by<B> value</B>, to the 80x86 hardware port whose number is given by<B>
port</B>.
<BR><BR>A hardware port is used to communicate with a device.&nbsp; One or two bytes can be read and/or written from each
port, depending upon the hardware.&nbsp; Consult the technical documentation for your computer to determine the port numbers
for a device and the expected usage of each port for a device.
</DL>
<DL>
<DT>Returns:
<DD>The value transmitted is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#inp">inp</A>, <A HREF="#inpd">inpd</A>, <A HREF="#inpw">inpw</A>, <A HREF="#outpd">outpd</A>, <A HREF="#outpw">outpw</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* turn off speaker */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; outp( 0x61, inp( 0x61 ) &amp; 0xFC );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="outpd"> outpd </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>unsigned long outpd( int port,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
unsigned long value );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> outpd</TT> function writes a double-word (four bytes), determined by<B> value</B>, to the 80x86 hardware port whose
number is given by<B> port</B>.
<BR><BR>A hardware port is used to communicate with a device.&nbsp; One or two bytes can be read and/or written from each
port, depending upon the hardware.&nbsp; Consult the technical documentation for your computer to determine the port numbers
for a device and the expected usage of each port for a device.
</DL>
<DL>
<DT>Returns:
<DD>The value transmitted is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#inp">inp</A>, <A HREF="#inpd">inpd</A>, <A HREF="#inpw">inpw</A>, <A HREF="#outp">outp</A>, <A HREF="#outpw">outpw</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#define DEVICE 34</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; outpd( DEVICE, 0x12345678 );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>DOS/32, Win386, Win32, OS/2-32, Linux, RDOS, Netware
</DL>
<H2 ID="outpw"> outpw </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>unsigned int outpw( int port,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
unsigned int value );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> outpw</TT> function writes a word (two bytes), determined by<B> value</B>, to the 80x86 hardware port whose number
is given by<B> port</B>.
<BR><BR>A hardware port is used to communicate with a device.&nbsp; One or two bytes can be read and/or written from each
port, depending upon the hardware.&nbsp; Consult the technical documentation for your computer to determine the port numbers
for a device and the expected usage of each port for a device.
</DL>
<DL>
<DT>Returns:
<DD>The value transmitted is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#inp">inp</A>, <A HREF="#inpd">inpd</A>, <A HREF="#inpw">inpw</A>, <A HREF="#outp">outp</A>, <A HREF="#outpd">outpd</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#define DEVICE 34</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; outpw( DEVICE, 0x1234 );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="_outtext"> _outtext </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>void _FAR _outtext( char _FAR *text );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _outtext</TT> function displays the character string indicated by the argument<B> text</B>.&nbsp; The string must
be terminated by a null character ('\0').&nbsp; When a line-feed character ('\n') is encountered in the string, the characters
following will be displayed on the next row of the screen.
<BR><BR>The text is displayed using the current text color (see the <TT> _settextcolor</TT> function), starting at the current
text position (see the <TT> _settextposition</TT> function).&nbsp; The text position is updated to follow the end of the displayed
text.
<BR><BR>The graphics library can display text in three different ways.
<OL>
<LI>The <TT> _outtext</TT> and <TT> _outmem</TT> functions can be used in any video mode.&nbsp; However, this variety of text
can be displayed in only one size.
<LI>The <TT> _grtext</TT> function displays text as a sequence of line segments, and can be drawn in different sizes, with
different orientations and alignments.
<LI>The <TT> _outgtext</TT> function displays text in the currently selected font.&nbsp; Both bit-mapped and vector fonts
are supported; the size and type of text depends on the fonts that are available.
</OL>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _outtext</TT> function does not return a value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_settextcolor">_settextcolor</A>, <A HREF="#_settextposition">_settextposition</A>, <A HREF="#_settextwindow">_settextwindow</A>,
<A HREF="#_grtext">_grtext</A>, <A HREF="#_outmem">_outmem</A>, <A HREF="#_outgtext">_outgtext</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _TEXTC80 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _settextposition( 10, 30 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _outtext( &quot;WATCOM Graphics&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="pclose"> pclose </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>int pclose( FILE *fp );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> pclose</TT> function closes the pipe associated with<B> fp</B> and waits for the subprocess created by <TT> popen</TT>
to terminate.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> pclose</TT> function returns the termination status of the command language interpreter.&nbsp; If an error occured,<TT>
pclose</TT> returns (-1) with <TT> errno</TT> set appropriately.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
<DL>
<DT><B><I>Constant</I></B>
<DD><B><I>Meaning</I></B>
<DT>EINTR
<DD>The<TT> pclose</TT> function was interrupted by a signal while waiting for the child process to terminate.
<DT>ECHILD
<DD>The<TT> pclose</TT> function was unable to obtain the termination status of the child process.
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#perror">perror</A>, <A HREF="#popen">popen</A>
</DL>
<DL>
<DT>Example:
<DD>See example provided with<TT> popen.</TT>
</DL>
<DL>
<DT>Classification:
<DD>POSIX 1003.1
</DL>
<DL>
<DT>Systems:
<DD>Linux
</DL>
<H2 ID="_pclose"> _pclose </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>int _pclose( FILE *fp );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _pclose</TT> function closes the pipe associated with<B> fp</B> and waits for the subprocess created by <TT> _popen</TT>
to terminate.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _pclose</TT> function returns the termination status of the command language interpreter.&nbsp; If an error occured,<TT>
_pclose</TT> returns (-1) with <TT> errno</TT> set appropriately.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
<DL>
<DT><B><I>Constant</I></B>
<DD><B><I>Meaning</I></B>
<DT>EINTR
<DD>The<TT> _pclose</TT> function was interrupted by a signal while waiting for the child process to terminate.
<DT>ECHILD
<DD>The<TT> _pclose</TT> function was unable to obtain the termination status of the child process.
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#perror">perror</A>, <A HREF="#_pipe">_pipe</A>, <A HREF="#_popen">_popen</A>
</DL>
<DL>
<DT>Example:
<DD>See example provided with<TT> _popen.</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>Win32, OS/2 1.x(all), OS/2-32, Linux
</DL>
<H2 ID="perror"> perror, _wperror </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>void perror( const char *prefix );</TT>
<BR><TT>void _wperror( const wchar_t *prefix );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> perror</TT> function prints, on the file designated by <TT> stderr</TT>, the error message corresponding to the error
number contained in <TT> errno</TT>.&nbsp; The<TT> perror</TT> function writes first the string pointed to by<B> prefix</B>
to stderr.&nbsp; This is followed by a colon (&quot;:&quot;), a space, the string returned by<TT> strerror(errno)</TT>, and
a newline character.
<BR><BR>The<TT> _wperror</TT> function is a wide-character version of<TT> perror</TT> that operates with wide-character strings.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> perror</TT> function returns no value.&nbsp; Because<TT> perror</TT> uses the <TT> fprintf</TT> function, <TT> errno</TT>
can be set when an error is detected during the execution of that function.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#clearerr">clearerr</A>, <A HREF="#feof">feof</A>, <A HREF="#ferror">ferror</A>, <A HREF="#strerror">strerror</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FILE *fp;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; fp = fopen( &quot;data.fil&quot;, &quot;r&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( fp == NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; perror( &quot;Unable to open file&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>_wperror is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> perror - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_wperror - All, Linux</TT>
</DL>
<H2 ID="_pg_analyzechart"> _pg_analyzechart, _pg_analyzechartms </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;pgchart.h&gt;</TT>
<BR><TT>short _FAR _pg_analyzechart( chartenv _FAR *env,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char _FAR * _FAR *cat,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float _FAR *values, short n );</TT>
<BR><BR><TT>short _FAR _pg_analyzechartms( chartenv _FAR *env,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char _FAR * _FAR *cat,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float _FAR *values,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short nseries,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short n, short dim,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char _FAR * _FAR *labels );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _pg_analyzechart</TT> functions analyze either a single-series or a multi-series bar, column or line chart.&nbsp;
These functions calculate default values for chart elements without actually displaying the chart.
<BR><BR>The<TT> _pg_analyzechart</TT> function analyzes a single-series bar, column or line chart.&nbsp; The chart environment
structure<B> env</B> is filled with default values based on the type of chart and the values of the<B> cat</B> and<B> values</B>
arguments.&nbsp; The arguments are the same as for the <TT> _pg_chart</TT> function.
<BR><BR>The<TT> _pg_analyzechartms</TT> function analyzes a multi-series bar, column or line chart.&nbsp; The chart environment
structure<B> env</B> is filled with default values based on the type of chart and the values of the<B> cat</B>,<B> values</B>
and<B> labels</B> arguments.&nbsp; The arguments are the same as for the <TT> _pg_chartms</TT> function.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _pg_analyzechart</TT> functions return zero if successful; otherwise, a non-zero value is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_pg_defaultchart">_pg_defaultchart</A>, <A HREF="#_pg_initchart">_pg_initchart</A>, <A HREF="#_pg_chart">_pg_chart</A>,
<A HREF="#_pg_chartpie">_pg_chartpie</A>, <A HREF="#_pg_chartscatter">_pg_chartscatter</A>, <A HREF="#_pg_analyzepie">_pg_analyzepie</A>,
<A HREF="#_pg_analyzescatter">_pg_analyzescatter</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>#include &lt;pgchart.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><BR><TT>#if defined ( __386__ )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; #define _FAR</TT>
<BR><TT>#else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; #define _FAR&nbsp;&nbsp;&nbsp; __far</TT>
<BR><TT>#endif</TT>
<BR><BR><TT>#define NUM_VALUES 4</TT>
<BR><BR><TT>char _FAR *categories[ NUM_VALUES ] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; &quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;</TT>
<BR><TT>};</TT>
<BR><BR><TT>float values[ NUM_VALUES ] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 20, 45, 30, 25</TT>
<BR><TT>};</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; chartenv env;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_initchart();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_defaultchart( &amp;env,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; _PG_COLUMNCHART, _PG_PLAINBARS );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; strcpy( env.maintitle.title, &quot;Column Chart&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_analyzechart( &amp;env,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; categories, values, NUM_VALUES );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* use manual scaling */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; env.yaxis.autoscale = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; env.yaxis.scalemin = 0.0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; env.yaxis.scalemax = 100.0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; env.yaxis.ticinterval = 25.0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_chart( &amp;env, categories, values, NUM_VALUES );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD><TT> _pg_analyzechart - DOS</TT>
<BR><BR><TT>_pg_analyzechartms - DOS</TT>
</DL>
<H2 ID="_pg_analyzepie"> _pg_analyzepie </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;pgchart.h&gt;</TT>
<BR><TT>short _FAR _pg_analyzepie( chartenv _FAR *env,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char _FAR * _FAR *cat,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float _FAR *values,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short _FAR *explode, short n );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _pg_analyzepie</TT> function analyzes a pie chart.&nbsp; This function calculates default values for chart elements
without actually displaying the chart.
<BR><BR>The chart environment structure<B> env</B> is filled with default values based on the values of the<B> cat</B>,<B>
values</B> and<B> explode</B> arguments.&nbsp; The arguments are the same as for the <TT> _pg_chartpie</TT> function.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _pg_analyzepie</TT> function returns zero if successful; otherwise, a non-zero value is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_pg_defaultchart">_pg_defaultchart</A>, <A HREF="#_pg_initchart">_pg_initchart</A>, <A HREF="#_pg_chart">_pg_chart</A>,
<A HREF="#_pg_chartpie">_pg_chartpie</A>, <A HREF="#_pg_chartscatter">_pg_chartscatter</A>, <A HREF="#_pg_analyzechart">_pg_analyzechart</A>,
<A HREF="#_pg_analyzescatter">_pg_analyzescatter</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>#include &lt;pgchart.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><BR><TT>#if defined ( __386__ )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; #define _FAR</TT>
<BR><TT>#else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; #define _FAR&nbsp;&nbsp;&nbsp; __far</TT>
<BR><TT>#endif</TT>
<BR><BR><TT>#define NUM_VALUES 4</TT>
<BR><BR><TT>char _FAR *categories[ NUM_VALUES ] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; &quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;</TT>
<BR><TT>};</TT>
<BR><BR><TT>float values[ NUM_VALUES ] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 20, 45, 30, 25</TT>
<BR><TT>};</TT>
<BR><BR><TT>short explode[ NUM_VALUES ] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 1, 0, 0, 0</TT>
<BR><TT>};</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; chartenv env;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_initchart();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_defaultchart( &amp;env,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; _PG_PIECHART, _PG_NOPERCENT );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; strcpy( env.maintitle.title, &quot;Pie Chart&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; env.legend.place = _PG_BOTTOM;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_analyzepie( &amp;env, categories,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
values, explode, NUM_VALUES );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* make legend window same width as data window */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; env.legend.autosize = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; env.legend.legendwindow.x1 = env.datawindow.x1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; env.legend.legendwindow.x2 = env.datawindow.x2;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_chartpie( &amp;env, categories,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; values, explode,
NUM_VALUES );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_pg_analyzescatter"> _pg_analyzescatter, _pg_analyzescatterms </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;pgchart.h&gt;</TT>
<BR><TT>short _FAR _pg_analyzescatter( chartenv _FAR *env,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float _FAR *x,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float _FAR *y, short n );</TT>
<BR><BR><TT>short _FAR _pg_analyzescatterms(</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; chartenv _FAR *env,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; float _FAR *x, float _FAR *y,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; short nseries, short n, short dim,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; char _FAR * _FAR *labels );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _pg_analyzescatter</TT> functions analyze either a single-series or a multi-series scatter chart.&nbsp; These functions
calculate default values for chart elements without actually displaying the chart.
<BR><BR>The<TT> _pg_analyzescatter</TT> function analyzes a single-series scatter chart.&nbsp; The chart environment structure<B>
env</B> is filled with default values based on the values of the<B> x</B> and<B> y</B> arguments.&nbsp; The arguments are
the same as for the <TT> _pg_chartscatter</TT> function.
<BR><BR>The<TT> _pg_analyzescatterms</TT> function analyzes a multi-series scatter chart.&nbsp; The chart environment structure<B>
env</B> is filled with default values based on the values of the<B> x</B>,<B> y</B> and<B> labels</B> arguments.&nbsp; The
arguments are the same as for the <TT> _pg_chartscatterms</TT> function.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _pg_analyzescatter</TT> functions return zero if successful; otherwise, a non-zero value is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_pg_defaultchart">_pg_defaultchart</A>, <A HREF="#_pg_initchart">_pg_initchart</A>, <A HREF="#_pg_chart">_pg_chart</A>,
<A HREF="#_pg_chartpie">_pg_chartpie</A>, <A HREF="#_pg_chartscatter">_pg_chartscatter</A>, <A HREF="#_pg_analyzechart">_pg_analyzechart</A>,
<A HREF="#_pg_analyzepie">_pg_analyzepie</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>#include &lt;pgchart.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><BR><TT>#if defined ( __386__ )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; #define _FAR</TT>
<BR><TT>#else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; #define _FAR&nbsp;&nbsp;&nbsp; __far</TT>
<BR><TT>#endif</TT>
<BR><BR><TT>#define NUM_VALUES 4</TT>
<BR><TT>#define NUM_SERIES 2</TT>
<BR><BR><TT>char _FAR *labels[ NUM_SERIES ] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; &quot;Jan&quot;, &quot;Feb&quot;</TT>
<BR><TT>};</TT>
<BR><BR><TT>float x[ NUM_SERIES ][ NUM_VALUES ] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 5, 15, 30, 40, 10, 20, 30, 45</TT>
<BR><TT>};</TT>
<BR><BR><TT>float y[ NUM_SERIES ][ NUM_VALUES ] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 10, 15, 30, 45, 40, 30, 15, 5</TT>
<BR><TT>};</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; chartenv env;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_initchart();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_defaultchart( &amp;env,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; _PG_SCATTERCHART, _PG_POINTANDLINE );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; strcpy( env.maintitle.title, &quot;Scatter Chart&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_analyzescatterms( &amp;env, x, y, NUM_SERIES,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NUM_VALUES, NUM_VALUES, labels );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* display x-axis labels with 2 decimal places */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; env.xaxis.autoscale = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; env.xaxis.ticdecimals = 2;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_chartscatterms( &amp;env, x, y, NUM_SERIES,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; NUM_VALUES, NUM_VALUES, labels );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD><TT> _pg_analyzescatter - DOS</TT>
<BR><BR><TT>_pg_analyzescatterms - DOS</TT>
</DL>
<H2 ID="_pg_chart"> _pg_chart, _pg_chartms </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;pgchart.h&gt;</TT>
<BR><TT>short _FAR _pg_chart( chartenv _FAR *env,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; char _FAR * _FAR *cat,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; float _FAR *values, short n );</TT>
<BR><BR><TT>short _FAR _pg_chartms( chartenv _FAR *env,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; char _FAR * _FAR *cat,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; float _FAR *values, short nseries,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; short n, short dim,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; char _FAR * _FAR *labels );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _pg_chart</TT> functions display either a single-series or a multi-series bar, column or line chart.&nbsp; The type
of chart displayed and other chart options are contained in the<B> env</B> argument.&nbsp; The argument<B> cat</B> is an array
of strings.&nbsp; These strings describe the categories against which the data in the<B> values</B> array is charted.
<BR><BR>The<TT> _pg_chart</TT> function displays a bar, column or line chart from the single series of data contained in the<B>
values</B> array.&nbsp; The argument<B> n</B> specifies the number of values to chart.
<BR><BR>The<TT> _pg_chartms</TT> function displays a multi-series bar, column or line chart.&nbsp; The argument<B> nseries</B>
specifies the number of series of data to chart.&nbsp; The argument<B> values</B> is assumed to be a two-dimensional array
defined as follows:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; float values[ nseries ][ dim ];</TT>
<BR><BR>The number of values used from each series is given by the argument<B> n</B>, where<B> n</B> is less than or equal
to<B> dim</B>.&nbsp; The argument<B> labels</B> is an array of strings.&nbsp; These strings describe each of the series and
are used in the chart legend.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _pg_chart</TT> functions return zero if successful; otherwise, a non-zero value is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_pg_defaultchart">_pg_defaultchart</A>, <A HREF="#_pg_initchart">_pg_initchart</A>, <A HREF="#_pg_chartpie">_pg_chartpie</A>,
<A HREF="#_pg_chartscatter">_pg_chartscatter</A>, <A HREF="#_pg_analyzechart">_pg_analyzechart</A>, <A HREF="#_pg_analyzepie">_pg_analyzepie</A>,
<A HREF="#_pg_analyzescatter">_pg_analyzescatter</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>#include &lt;pgchart.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><BR><TT>#if defined ( __386__ )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; #define _FAR</TT>
<BR><TT>#else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; #define _FAR&nbsp;&nbsp;&nbsp; __far</TT>
<BR><TT>#endif</TT>
<BR><BR><TT>#define NUM_VALUES 4</TT>
<BR><BR><TT>char _FAR *categories[ NUM_VALUES ] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; &quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;</TT>
<BR><TT>};</TT>
<BR><BR><TT>float values[ NUM_VALUES ] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 20, 45, 30, 25</TT>
<BR><TT>};</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; chartenv env;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_initchart();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_defaultchart( &amp;env,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; _PG_COLUMNCHART, _PG_PLAINBARS );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; strcpy( env.maintitle.title, &quot;Column Chart&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_chart( &amp;env, categories, values, NUM_VALUES );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><IMG SRC="eg_pgc.bmp" ALIGN=MIDDLE>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD><TT> _pg_chart - DOS</TT>
<BR><BR><TT>_pg_chartms - DOS</TT>
</DL>
<H2 ID="_pg_chartpie"> _pg_chartpie </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;pgchart.h&gt;</TT>
<BR><TT>short _FAR _pg_chartpie( chartenv _FAR *env,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; char _FAR * _FAR *cat,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; float _FAR *values,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; short _FAR *explode, short n );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _pg_chartpie</TT> function displays a pie chart.&nbsp; The chart is displayed using the options specified in the<B>
env</B> argument.
<BR><BR>The pie chart is created from the data contained in the<B> values</B> array.&nbsp; The argument<B> n</B> specifies
the number of values to chart.
<BR><BR>The argument<B> cat</B> is an array of strings.&nbsp; These strings describe each of the pie slices and are used in
the chart legend.&nbsp; The argument<B> explode</B> is an array of values corresponding to each of the pie slices.&nbsp; For
each non-zero element in the array, the corresponding pie slice is drawn &quot;exploded&quot;, or slightly offset from the
rest of the pie.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _pg_chartpie</TT> function returns zero if successful; otherwise, a non-zero value is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_pg_defaultchart">_pg_defaultchart</A>, <A HREF="#_pg_initchart">_pg_initchart</A>, <A HREF="#_pg_chart">_pg_chart</A>,
<A HREF="#_pg_chartscatter">_pg_chartscatter</A>, <A HREF="#_pg_analyzechart">_pg_analyzechart</A>, <A HREF="#_pg_analyzepie">_pg_analyzepie</A>,
<A HREF="#_pg_analyzescatter">_pg_analyzescatter</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>#include &lt;pgchart.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><BR><TT>#if defined ( __386__ )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; #define _FAR</TT>
<BR><TT>#else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; #define _FAR&nbsp;&nbsp;&nbsp; __far</TT>
<BR><TT>#endif</TT>
<BR><BR><TT>#define NUM_VALUES 4</TT>
<BR><BR><TT>char _FAR *categories[ NUM_VALUES ] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; &quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;</TT>
<BR><TT>};</TT>
<BR><BR><TT>float values[ NUM_VALUES ] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 20, 45, 30, 25</TT>
<BR><TT>};</TT>
<BR><BR><TT>short explode[ NUM_VALUES ] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 1, 0, 0, 0</TT>
<BR><TT>};</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; chartenv env;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_initchart();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_defaultchart( &amp;env,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; _PG_PIECHART, _PG_NOPERCENT );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; strcpy( env.maintitle.title, &quot;Pie Chart&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_chartpie( &amp;env, categories,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; values, explode,
NUM_VALUES );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><IMG SRC="eg_pgcp.bmp" ALIGN=MIDDLE>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_pg_chartscatter"> _pg_chartscatter, _pg_chartscatterms </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;pgchart.h&gt;</TT>
<BR><TT>short _FAR _pg_chartscatter( chartenv _FAR *env,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float _FAR *x,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float _FAR *y, short n );</TT>
<BR><BR><TT>short _FAR _pg_chartscatterms( chartenv _FAR *env,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float _FAR *x,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float _FAR *y,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short nseries,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short n, short dim,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char _FAR * _FAR *labels );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _pg_chartscatter</TT> functions display either a single-series or a multi-series scatter chart.&nbsp; The chart is
displayed using the options specified in the<B> env</B> argument.
<BR><BR>The<TT> _pg_chartscatter</TT> function displays a scatter chart from the single series of data contained in the arrays<B>
x</B> and<B> y</B>.&nbsp; The argument<B> n</B> specifies the number of values to chart.
<BR><BR>The<TT> _pg_chartscatterms</TT> function displays a multi-series scatter chart.&nbsp; The argument<B> nseries</B>
specifies the number of series of data to chart.&nbsp; The arguments<B> x</B> and<B> y</B> are assumed to be two-dimensional
arrays defined as follows:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; float x[ nseries ][ dim ];</TT>
<BR><BR>The number of values used from each series is given by the argument<B> n</B>, where<B> n</B> is less than or equal
to<B> dim</B>.&nbsp; The argument<B> labels</B> is an array of strings.&nbsp; These strings describe each of the series and
are used in the chart legend.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _pg_chartscatter</TT> functions return zero if successful; otherwise, a non-zero value is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_pg_defaultchart">_pg_defaultchart</A>, <A HREF="#_pg_initchart">_pg_initchart</A>, <A HREF="#_pg_chart">_pg_chart</A>,
<A HREF="#_pg_chartpie">_pg_chartpie</A>, <A HREF="#_pg_analyzechart">_pg_analyzechart</A>, <A HREF="#_pg_analyzepie">_pg_analyzepie</A>,
<A HREF="#_pg_analyzescatter">_pg_analyzescatter</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>#include &lt;pgchart.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><BR><TT>#if defined ( __386__ )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; #define _FAR</TT>
<BR><TT>#else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; #define _FAR&nbsp;&nbsp;&nbsp; __far</TT>
<BR><TT>#endif</TT>
<BR><BR><TT>#define NUM_VALUES 4</TT>
<BR><TT>#define NUM_SERIES 2</TT>
<BR><BR><TT>char _FAR *labels[ NUM_SERIES ] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; &quot;Jan&quot;, &quot;Feb&quot;</TT>
<BR><TT>};</TT>
<BR><BR><TT>float x[ NUM_SERIES ][ NUM_VALUES ] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 5, 15, 30, 40, 10, 20, 30, 45</TT>
<BR><TT>};</TT>
<BR><BR><TT>float y[ NUM_SERIES ][ NUM_VALUES ] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 10, 15, 30, 45, 40, 30, 15, 5</TT>
<BR><TT>};</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; chartenv env;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_initchart();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_defaultchart( &amp;env,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; _PG_SCATTERCHART, _PG_POINTANDLINE );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; strcpy( env.maintitle.title, &quot;Scatter Chart&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_chartscatterms( &amp;env, x, y, NUM_SERIES,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; NUM_VALUES, NUM_VALUES, labels );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><IMG SRC="eg_pgcs.bmp" ALIGN=MIDDLE>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD><TT> _pg_chartscatter - DOS</TT>
<BR><BR><TT>_pg_chartscatterms - DOS</TT>
</DL>
<H2 ID="_pg_defaultchart"> _pg_defaultchart </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;pgchart.h&gt;</TT>
<BR><TT>short _FAR _pg_defaultchart( chartenv _FAR *env,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short type, short style );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _pg_defaultchart</TT> function initializes the chart structure<B> env</B> to contain default values before a chart
is drawn.&nbsp; All values in the chart structure are initialized, including blanking of all titles.&nbsp; The chart type
in the structure is initialized to the value<B> type</B>, and the chart style is initialized to<B> style</B>.
<BR><BR>The argument<B> type</B> can have one of the following values:
<DL>
<DT>_PG_BARCHART
<DD>Bar chart (horizontal bars)
<DT>_PG_COLUMNCHART
<DD>Column chart (vertical bars)
<DT>_PG_LINECHART
<DD>Line chart
<DT>_PG_SCATTERCHART
<DD>Scatter chart
<DT>_PG_PIECHART
<DD>Pie chart
</DL>
<BR>Each type of chart can be drawn in one of two styles.&nbsp; For each chart type the argument<B> style</B> can have one
of the following values:&nbsp; uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Style 1&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Style 2</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Bar&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _PG_PLAINBARS
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _PG_STACKEDBARS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Column&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _PG_PLAINBARS&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _PG_STACKEDBARS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Line&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _PG_POINTANDLINE&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _PG_POINTONLY</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Scatter&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _PG_POINTANDLINE&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; _PG_POINTONLY</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Pie&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _PG_PERCENT&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _PG_NOPERCENT</TT>
<BR><BR>For single-series bar and column charts, the chart style is ignored.&nbsp; The &quot;plain&quot; (clustered) and &quot;stacked&quot;
styles only apply when there is more than one series of data.&nbsp; The &quot;percent&quot; style for pie charts causes percentages
to be displayed beside each of the pie slices.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _pg_defaultchart</TT> function returns zero if successful; otherwise, a non-zero value is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_pg_initchart">_pg_initchart</A>, <A HREF="#_pg_chart">_pg_chart</A>, <A HREF="#_pg_chartpie">_pg_chartpie</A>,
<A HREF="#_pg_chartscatter">_pg_chartscatter</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>#include &lt;pgchart.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><BR><TT>#if defined ( __386__ )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; #define _FAR</TT>
<BR><TT>#else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; #define _FAR&nbsp;&nbsp;&nbsp; __far</TT>
<BR><TT>#endif</TT>
<BR><BR><TT>#define NUM_VALUES 4</TT>
<BR><BR><TT>char _FAR *categories[ NUM_VALUES ] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; &quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;</TT>
<BR><TT>};</TT>
<BR><BR><TT>float values[ NUM_VALUES ] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 20, 45, 30, 25</TT>
<BR><TT>};</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; chartenv env;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_initchart();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_defaultchart( &amp;env,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; _PG_COLUMNCHART, _PG_PLAINBARS );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; strcpy( env.maintitle.title, &quot;Column Chart&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_chart( &amp;env, categories, values, NUM_VALUES );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_pg_getchardef"> _pg_getchardef </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;pgchart.h&gt;</TT>
<BR><TT>short _FAR _pg_getchardef( short ch,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char _FAR *def );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _pg_getchardef</TT> function retrieves the current bit-map definition for the character<B> ch</B>.&nbsp; The bit-map
is placed in the array<B> def</B>.&nbsp; The current font must be an 8-by-8 bit-mapped font.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _pg_getchardef</TT> function returns zero if successful; otherwise, a non-zero value is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_pg_defaultchart">_pg_defaultchart</A>, <A HREF="#_pg_initchart">_pg_initchart</A>, <A HREF="#_pg_chart">_pg_chart</A>,
<A HREF="#_pg_chartpie">_pg_chartpie</A>, <A HREF="#_pg_chartscatter">_pg_chartscatter</A>, <A HREF="#_pg_setchardef">_pg_setchardef</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>#include &lt;pgchart.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><BR><TT>#define NUM_VALUES 4</TT>
<BR><BR><TT>float x[ NUM_VALUES ] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 5, 25, 45, 65</TT>
<BR><TT>};</TT>
<BR><BR><TT>float y[ NUM_VALUES ] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 5, 45, 25, 65</TT>
<BR><TT>};</TT>
<BR><BR><TT>char diamond[ 8 ] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x10, 0x28, 0x44, 0x82, 0x44, 0x28, 0x10, 0x00</TT>
<BR><TT>};</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; chartenv env;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char old_def[ 8 ];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_initchart();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_defaultchart( &amp;env,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; _PG_SCATTERCHART, _PG_POINTANDLINE );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; strcpy( env.maintitle.title, &quot;Scatter Chart&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* change asterisk character to diamond */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_getchardef( '*', old_def );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_setchardef( '*', diamond );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_chartscatter( &amp;env, x, y, NUM_VALUES );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_setchardef( '*', old_def );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_pg_getpalette"> _pg_getpalette </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;pgchart.h&gt;</TT>
<BR><TT>short _FAR _pg_getpalette( paletteentry _FAR *pal );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _pg_getpalette</TT> function retrieves the internal palette of the presentation graphics system.&nbsp; The palette
controls the colors, line styles, fill patterns and plot characters used to display each series of data in a chart.
<BR><BR>The argument<B> pal</B> is an array of palette structures that will contain the palette.&nbsp; Each element of the
palette is a structure containing the following fields:
<DL>
<DT>color
<DD>color used to display series
<DT>style
<DD>line style used for line and scatter charts
<DT>fill
<DD>fill pattern used to fill interior of bar and pie sections
<DT>plotchar
<DD>character plotted on line and scatter charts
</DL>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _pg_getpalette</TT> function returns zero if successful; otherwise, a non-zero value is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_pg_defaultchart">_pg_defaultchart</A>, <A HREF="#_pg_initchart">_pg_initchart</A>, <A HREF="#_pg_chart">_pg_chart</A>,
<A HREF="#_pg_chartpie">_pg_chartpie</A>, <A HREF="#_pg_chartscatter">_pg_chartscatter</A>, <A HREF="#_pg_setpalette">_pg_setpalette</A>,
<A HREF="#_pg_resetpalette">_pg_resetpalette</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>#include &lt;pgchart.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><BR><TT>#if defined ( __386__ )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; #define _FAR</TT>
<BR><TT>#else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; #define _FAR&nbsp;&nbsp;&nbsp; __far</TT>
<BR><TT>#endif</TT>
<BR><BR><TT>#define NUM_VALUES 4</TT>
<BR><BR><TT>char _FAR *categories[ NUM_VALUES ] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; &quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;</TT>
<BR><TT>};</TT>
<BR><BR><TT>float values[ NUM_VALUES ] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 20, 45, 30, 25</TT>
<BR><TT>};</TT>
<BR><BR><TT>char bricks[ 8 ] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xff, 0x80, 0x80, 0x80, 0xff, 0x08, 0x08, 0x08</TT>
<BR><TT>};</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; chartenv env;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; palettetype pal;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_initchart();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_defaultchart( &amp;env,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; _PG_COLUMNCHART, _PG_PLAINBARS );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; strcpy( env.maintitle.title, &quot;Column Chart&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* get default palette and change 1st entry */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_getpalette( &amp;pal );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; pal[ 1 ].color = 12;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; memcpy( pal[ 1 ].fill, bricks, 8 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* use new palette */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_setpalette( &amp;pal );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_chart( &amp;env, categories, values, NUM_VALUES );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* reset palette to default */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_resetpalette();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_pg_getstyleset"> _pg_getstyleset </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;pgchart.h&gt;</TT>
<BR><TT>void _FAR _pg_getstyleset( unsigned short _FAR *style );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _pg_getstyleset</TT> function retrieves the internal style-set of the presentation graphics system.&nbsp; The style-set
is a set of line styles used for drawing window borders and grid-lines.&nbsp; The argument<B> style</B> is an array that will
contain the style-set.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _pg_getstyleset</TT> function does not return a value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_pg_defaultchart">_pg_defaultchart</A>, <A HREF="#_pg_initchart">_pg_initchart</A>, <A HREF="#_pg_chart">_pg_chart</A>,
<A HREF="#_pg_chartpie">_pg_chartpie</A>, <A HREF="#_pg_chartscatter">_pg_chartscatter</A>, <A HREF="#_pg_setstyleset">_pg_setstyleset</A>,
<A HREF="#_pg_resetstyleset">_pg_resetstyleset</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>#include &lt;pgchart.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><BR><TT>#if defined ( __386__ )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; #define _FAR</TT>
<BR><TT>#else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; #define _FAR&nbsp;&nbsp;&nbsp; __far</TT>
<BR><TT>#endif</TT>
<BR><BR><TT>#define NUM_VALUES 4</TT>
<BR><BR><TT>char _FAR *categories[ NUM_VALUES ] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; &quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;</TT>
<BR><TT>};</TT>
<BR><BR><TT>float values[ NUM_VALUES ] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 20, 45, 30, 25</TT>
<BR><TT>};</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; chartenv env;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; styleset style;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_initchart();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_defaultchart( &amp;env,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; _PG_COLUMNCHART, _PG_PLAINBARS );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; strcpy( env.maintitle.title, &quot;Column Chart&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* turn on yaxis grid, and use style 2 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; env.yaxis.grid = 1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; env.yaxis.gridstyle = 2;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* get default style-set and change entry 2 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_getstyleset( &amp;style );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; style[ 2 ] = 0x8888;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* use new style-set */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_setstyleset( &amp;style );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_chart( &amp;env, categories, values, NUM_VALUES );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* reset style-set to default */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_resetstyleset();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_pg_hlabelchart"> _pg_hlabelchart </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;pgchart.h&gt;</TT>
<BR><TT>short _FAR _pg_hlabelchart( chartenv _FAR *env,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short x, short y,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short color,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char _FAR *label );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _pg_hlabelchart</TT> function displays the text string<B> label</B> on the chart described by the<B> env</B> chart
structure.&nbsp; The string is displayed horizontally starting at the point<TT> (x,y),</TT> relative to the upper left corner
of the chart.&nbsp; The<B> color</B> specifies the palette color used to display the string.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _pg_hlabelchart</TT> function returns zero if successful; otherwise, a non-zero value is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_pg_defaultchart">_pg_defaultchart</A>, <A HREF="#_pg_initchart">_pg_initchart</A>, <A HREF="#_pg_chart">_pg_chart</A>,
<A HREF="#_pg_chartpie">_pg_chartpie</A>, <A HREF="#_pg_chartscatter">_pg_chartscatter</A>, <A HREF="#_pg_vlabelchart">_pg_vlabelchart</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>#include &lt;pgchart.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><BR><TT>#if defined ( __386__ )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; #define _FAR</TT>
<BR><TT>#else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; #define _FAR&nbsp;&nbsp;&nbsp; __far</TT>
<BR><TT>#endif</TT>
<BR><BR><TT>#define NUM_VALUES 4</TT>
<BR><BR><TT>char _FAR *categories[ NUM_VALUES ] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; &quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;</TT>
<BR><TT>};</TT>
<BR><BR><TT>float values[ NUM_VALUES ] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 20, 45, 30, 25</TT>
<BR><TT>};</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; chartenv env;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_initchart();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_defaultchart( &amp;env,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; _PG_COLUMNCHART, _PG_PLAINBARS );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; strcpy( env.maintitle.title, &quot;Column Chart&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_chart( &amp;env, categories, values, NUM_VALUES );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_hlabelchart( &amp;env, 64, 32, 1, &quot;Horizontal label&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_vlabelchart( &amp;env, 48, 32, 1, &quot;Vertical label&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_pg_initchart"> _pg_initchart </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;pgchart.h&gt;</TT>
<BR><TT>short _FAR _pg_initchart( void );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _pg_initchart</TT> function initializes the presentation graphics system.&nbsp; This includes initializing the internal
palette and style-set used when drawing charts.&nbsp; This function must be called before any of the other presentation graphics
functions.
<BR><BR>The initialization of the presentation graphics system requires that a valid graphics mode has been selected.&nbsp;
For this reason the <TT> _setvideomode</TT> function must be called before<TT> _pg_initchart</TT> is called.&nbsp; If a font
has been selected (with the <TT> _setfont</TT> function), that font will be used when text is displayed in a chart.&nbsp;
Font selection should also be done before initializing the presentation graphics system.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _pg_initchart</TT> function returns zero if successful; otherwise, a non-zero value is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_pg_defaultchart">_pg_defaultchart</A>, <A HREF="#_pg_chart">_pg_chart</A>, <A HREF="#_pg_chartpie">_pg_chartpie</A>,
<A HREF="#_pg_chartscatter">_pg_chartscatter</A>, <A HREF="#_setvideomode">_setvideomode</A>, <A HREF="#_setfont">_setfont</A>,
<A HREF="#_registerfonts">_registerfonts</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>#include &lt;pgchart.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><BR><TT>#if defined ( __386__ )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; #define _FAR</TT>
<BR><TT>#else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; #define _FAR&nbsp;&nbsp;&nbsp; __far</TT>
<BR><TT>#endif</TT>
<BR><BR><TT>#define NUM_VALUES 4</TT>
<BR><BR><TT>char _FAR *categories[ NUM_VALUES ] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; &quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;</TT>
<BR><TT>};</TT>
<BR><BR><TT>float values[ NUM_VALUES ] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 20, 45, 30, 25</TT>
<BR><TT>};</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; chartenv env;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_initchart();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_defaultchart( &amp;env,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; _PG_COLUMNCHART, _PG_PLAINBARS );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; strcpy( env.maintitle.title, &quot;Column Chart&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_chart( &amp;env, categories, values, NUM_VALUES );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_pg_resetpalette"> _pg_resetpalette </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;pgchart.h&gt;</TT>
<BR><TT>short _FAR _pg_resetpalette( void );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _pg_resetpalette</TT> function resets the internal palette of the presentation graphics system to default values.
&nbsp;The palette controls the colors, line styles, fill patterns and plot characters used to display each series of data
in a chart.&nbsp; The default palette chosen is dependent on the current video mode.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _pg_resetpalette</TT> function returns zero if successful; otherwise, a non-zero value is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_pg_defaultchart">_pg_defaultchart</A>, <A HREF="#_pg_initchart">_pg_initchart</A>, <A HREF="#_pg_chart">_pg_chart</A>,
<A HREF="#_pg_chartpie">_pg_chartpie</A>, <A HREF="#_pg_chartscatter">_pg_chartscatter</A>, <A HREF="#_pg_getpalette">_pg_getpalette</A>,
<A HREF="#_pg_setpalette">_pg_setpalette</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>#include &lt;pgchart.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><BR><TT>#if defined ( __386__ )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; #define _FAR</TT>
<BR><TT>#else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; #define _FAR&nbsp;&nbsp;&nbsp; __far</TT>
<BR><TT>#endif</TT>
<BR><BR><TT>#define NUM_VALUES 4</TT>
<BR><BR><TT>char _FAR *categories[ NUM_VALUES ] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; &quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;</TT>
<BR><TT>};</TT>
<BR><BR><TT>float values[ NUM_VALUES ] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 20, 45, 30, 25</TT>
<BR><TT>};</TT>
<BR><BR><TT>char bricks[ 8 ] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xff, 0x80, 0x80, 0x80, 0xff, 0x08, 0x08, 0x08</TT>
<BR><TT>};</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; chartenv env;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; palettetype pal;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_initchart();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_defaultchart( &amp;env,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; _PG_COLUMNCHART, _PG_PLAINBARS );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; strcpy( env.maintitle.title, &quot;Column Chart&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* get default palette and change 1st entry */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_getpalette( &amp;pal );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; pal[ 1 ].color = 12;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; memcpy( pal[ 1 ].fill, bricks, 8 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* use new palette */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_setpalette( &amp;pal );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_chart( &amp;env, categories, values, NUM_VALUES );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* reset palette to default */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_resetpalette();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_pg_resetstyleset"> _pg_resetstyleset </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;pgchart.h&gt;</TT>
<BR><TT>void _FAR _pg_resetstyleset( void );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _pg_resetstyleset</TT> function resets the internal style-set of the presentation graphics system to default values.
&nbsp;The style-set is a set of line styles used for drawing window borders and grid-lines.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _pg_resetstyleset</TT> function does not return a value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_pg_defaultchart">_pg_defaultchart</A>, <A HREF="#_pg_initchart">_pg_initchart</A>, <A HREF="#_pg_chart">_pg_chart</A>,
<A HREF="#_pg_chartpie">_pg_chartpie</A>, <A HREF="#_pg_chartscatter">_pg_chartscatter</A>, <A HREF="#_pg_getstyleset">_pg_getstyleset</A>,
<A HREF="#_pg_setstyleset">_pg_setstyleset</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>#include &lt;pgchart.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><BR><TT>#if defined ( __386__ )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; #define _FAR</TT>
<BR><TT>#else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; #define _FAR&nbsp;&nbsp;&nbsp; __far</TT>
<BR><TT>#endif</TT>
<BR><BR><TT>#define NUM_VALUES 4</TT>
<BR><BR><TT>char _FAR *categories[ NUM_VALUES ] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; &quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;</TT>
<BR><TT>};</TT>
<BR><BR><TT>float values[ NUM_VALUES ] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 20, 45, 30, 25</TT>
<BR><TT>};</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; chartenv env;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; styleset style;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_initchart();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_defaultchart( &amp;env,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; _PG_COLUMNCHART, _PG_PLAINBARS );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; strcpy( env.maintitle.title, &quot;Column Chart&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* turn on yaxis grid, and use style 2 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; env.yaxis.grid = 1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; env.yaxis.gridstyle = 2;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* get default style-set and change entry 2 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_getstyleset( &amp;style );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; style[ 2 ] = 0x8888;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* use new style-set */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_setstyleset( &amp;style );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_chart( &amp;env, categories, values, NUM_VALUES );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* reset style-set to default */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_resetstyleset();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_pg_setchardef"> _pg_setchardef </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;pgchart.h&gt;</TT>
<BR><TT>short _FAR _pg_setchardef( short ch,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char _FAR *def );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _pg_setchardef</TT> function sets the current bit-map definition for the character<B> ch</B>.&nbsp; The bit-map is
contained in the array<B> def</B>.&nbsp; The current font must be an 8-by-8 bit-mapped font.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _pg_setchardef</TT> function returns zero if successful; otherwise, a non-zero value is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_pg_defaultchart">_pg_defaultchart</A>, <A HREF="#_pg_initchart">_pg_initchart</A>, <A HREF="#_pg_chart">_pg_chart</A>,
<A HREF="#_pg_chartpie">_pg_chartpie</A>, <A HREF="#_pg_chartscatter">_pg_chartscatter</A>, <A HREF="#_pg_getchardef">_pg_getchardef</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>#include &lt;pgchart.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><BR><TT>#define NUM_VALUES 4</TT>
<BR><BR><TT>float x[ NUM_VALUES ] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 5, 25, 45, 65</TT>
<BR><TT>};</TT>
<BR><BR><TT>float y[ NUM_VALUES ] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 5, 45, 25, 65</TT>
<BR><TT>};</TT>
<BR><BR><TT>char diamond[ 8 ] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x10, 0x28, 0x44, 0x82, 0x44, 0x28, 0x10, 0x00</TT>
<BR><TT>};</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; chartenv env;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char old_def[ 8 ];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_initchart();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_defaultchart( &amp;env,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; _PG_SCATTERCHART, _PG_POINTANDLINE );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; strcpy( env.maintitle.title, &quot;Scatter Chart&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* change asterisk character to diamond */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_getchardef( '*', old_def );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_setchardef( '*', diamond );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_chartscatter( &amp;env, x, y, NUM_VALUES );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_setchardef( '*', old_def );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_pg_setpalette"> _pg_setpalette </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;pgchart.h&gt;</TT>
<BR><TT>short _FAR _pg_setpalette( paletteentry _FAR *pal );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _pg_setpalette</TT> function sets the internal palette of the presentation graphics system.&nbsp; The palette controls
the colors, line styles, fill patterns and plot characters used to display each series of data in a chart.
<BR><BR>The argument<B> pal</B> is an array of palette structures containing the new palette.&nbsp; Each element of the palette
is a structure containing the following fields:
<DL>
<DT>color
<DD>color used to display series
<DT>style
<DD>line style used for line and scatter charts
<DT>fill
<DD>fill pattern used to fill interior of bar and pie sections
<DT>plotchar
<DD>character plotted on line and scatter charts
</DL>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _pg_setpalette</TT> function returns zero if successful; otherwise, a non-zero value is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_pg_defaultchart">_pg_defaultchart</A>, <A HREF="#_pg_initchart">_pg_initchart</A>, <A HREF="#_pg_chart">_pg_chart</A>,
<A HREF="#_pg_chartpie">_pg_chartpie</A>, <A HREF="#_pg_chartscatter">_pg_chartscatter</A>, <A HREF="#_pg_getpalette">_pg_getpalette</A>,
<A HREF="#_pg_resetpalette">_pg_resetpalette</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>#include &lt;pgchart.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><BR><TT>#if defined ( __386__ )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; #define _FAR</TT>
<BR><TT>#else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; #define _FAR&nbsp;&nbsp;&nbsp; __far</TT>
<BR><TT>#endif</TT>
<BR><BR><TT>#define NUM_VALUES 4</TT>
<BR><BR><TT>char _FAR *categories[ NUM_VALUES ] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; &quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;</TT>
<BR><TT>};</TT>
<BR><BR><TT>float values[ NUM_VALUES ] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 20, 45, 30, 25</TT>
<BR><TT>};</TT>
<BR><BR><TT>char bricks[ 8 ] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xff, 0x80, 0x80, 0x80, 0xff, 0x08, 0x08, 0x08</TT>
<BR><TT>};</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; chartenv env;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; palettetype pal;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_initchart();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_defaultchart( &amp;env,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; _PG_COLUMNCHART, _PG_PLAINBARS );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; strcpy( env.maintitle.title, &quot;Column Chart&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* get default palette and change 1st entry */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_getpalette( &amp;pal );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; pal[ 1 ].color = 12;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; memcpy( pal[ 1 ].fill, bricks, 8 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* use new palette */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_setpalette( &amp;pal );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_chart( &amp;env, categories, values, NUM_VALUES );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* reset palette to default */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_resetpalette();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_pg_setstyleset"> _pg_setstyleset </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;pgchart.h&gt;</TT>
<BR><TT>void _FAR _pg_setstyleset( unsigned short _FAR *style );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _pg_setstyleset</TT> function retrieves the internal style-set of the presentation graphics system.&nbsp; The style-set
is a set of line styles used for drawing window borders and grid-lines.&nbsp; The argument<B> style</B> is an array containing
the new style-set.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _pg_setstyleset</TT> function does not return a value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_pg_defaultchart">_pg_defaultchart</A>, <A HREF="#_pg_initchart">_pg_initchart</A>, <A HREF="#_pg_chart">_pg_chart</A>,
<A HREF="#_pg_chartpie">_pg_chartpie</A>, <A HREF="#_pg_chartscatter">_pg_chartscatter</A>, <A HREF="#_pg_getstyleset">_pg_getstyleset</A>,
<A HREF="#_pg_resetstyleset">_pg_resetstyleset</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>#include &lt;pgchart.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><BR><TT>#if defined ( __386__ )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; #define _FAR</TT>
<BR><TT>#else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; #define _FAR&nbsp;&nbsp;&nbsp; __far</TT>
<BR><TT>#endif</TT>
<BR><BR><TT>#define NUM_VALUES 4</TT>
<BR><BR><TT>char _FAR *categories[ NUM_VALUES ] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; &quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;</TT>
<BR><TT>};</TT>
<BR><BR><TT>float values[ NUM_VALUES ] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 20, 45, 30, 25</TT>
<BR><TT>};</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; chartenv env;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; styleset style;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_initchart();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_defaultchart( &amp;env,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; _PG_COLUMNCHART, _PG_PLAINBARS );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; strcpy( env.maintitle.title, &quot;Column Chart&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* turn on yaxis grid, and use style 2 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; env.yaxis.grid = 1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; env.yaxis.gridstyle = 2;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* get default style-set and change entry 2 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_getstyleset( &amp;style );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; style[ 2 ] = 0x8888;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* use new style-set */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_setstyleset( &amp;style );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_chart( &amp;env, categories, values, NUM_VALUES );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* reset style-set to default */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_resetstyleset();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_pg_vlabelchart"> _pg_vlabelchart </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;pgchart.h&gt;</TT>
<BR><TT>short _FAR _pg_vlabelchart( chartenv _FAR *env,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short x, short y,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short color,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char _FAR *label );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _pg_vlabelchart</TT> function displays the text string<B> label</B> on the chart described by the<B> env</B> chart
structure.&nbsp; The string is displayed vertically starting at the point<TT> (x,y),</TT> relative to the upper left corner
of the chart.&nbsp; The<B> color</B> specifies the palette color used to display the string.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _pg_vlabelchart</TT> function returns zero if successful; otherwise, a non-zero value is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_pg_defaultchart">_pg_defaultchart</A>, <A HREF="#_pg_initchart">_pg_initchart</A>, <A HREF="#_pg_chart">_pg_chart</A>,
<A HREF="#_pg_chartpie">_pg_chartpie</A>, <A HREF="#_pg_chartscatter">_pg_chartscatter</A>, <A HREF="#_pg_hlabelchart">_pg_hlabelchart</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>#include &lt;pgchart.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><BR><TT>#if defined ( __386__ )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; #define _FAR</TT>
<BR><TT>#else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; #define _FAR&nbsp;&nbsp;&nbsp; __far</TT>
<BR><TT>#endif</TT>
<BR><BR><TT>#define NUM_VALUES 4</TT>
<BR><BR><TT>char _FAR *categories[ NUM_VALUES ] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; &quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;</TT>
<BR><TT>};</TT>
<BR><BR><TT>float values[ NUM_VALUES ] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 20, 45, 30, 25</TT>
<BR><TT>};</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; chartenv env;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_initchart();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_defaultchart( &amp;env,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; _PG_COLUMNCHART, _PG_PLAINBARS );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; strcpy( env.maintitle.title, &quot;Column Chart&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_chart( &amp;env, categories, values, NUM_VALUES );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_hlabelchart( &amp;env, 64, 32, 1, &quot;Horizontal label&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pg_vlabelchart( &amp;env, 48, 32, 1, &quot;Vertical label&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_pie"> _pie, _pie_w, _pie_wxy </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>short _FAR _pie( short fill, short x1, short y1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short x2, short y2,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short x3, short y3,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short x4, short y4 );</TT>
<BR><BR><TT>short _FAR _pie_w( short fill, double x1, double y1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double x2, double y2,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double x3, double y3,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double x4, double y4 );</TT>
<BR><BR><TT>short _FAR _pie_wxy( short fill,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;struct _wxycoord _FAR *p1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;struct _wxycoord _FAR *p2,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;struct _wxycoord _FAR *p3,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;struct _wxycoord _FAR *p4 );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _pie</TT> functions draw pie-shaped wedges.&nbsp; The<TT> _pie</TT> function uses the view coordinate system.&nbsp;
The<TT> _pie_w</TT> and<TT> _pie_wxy</TT> functions use the window coordinate system.
<BR><BR>The pie wedges are drawn by drawing an elliptical arc (in the way described for the <TT> _arc</TT> functions) and
then joining the center of the rectangle that contains the ellipse to the two endpoints of the arc.
<BR><BR>The elliptical arc is drawn with its center at the center of the rectangle established by the points<TT> (x1,y1)</TT>
and<TT> (x2,y2).</TT>&nbsp; The arc is a segment of the ellipse drawn within this bounding rectangle.&nbsp; The arc starts
at the point on this ellipse that intersects the vector from the centre of the ellipse to the point<TT> (x3,y3).</TT>&nbsp;
The arc ends at the point on this ellipse that intersects the vector from the centre of the ellipse to the point<TT> (x4,y4).</TT>
&nbsp;The arc is drawn in a counter-clockwise direction with the current plot action using the current color and the current
line style.
<BR><BR>The following picture illustrates the way in which the bounding rectangle and the vectors specifying the start and
end points are defined.
<BR><BR><IMG SRC="pic2.bmp" ALIGN=MIDDLE>
<BR>When the coordinates<TT> (x1,y1)</TT> and<TT> (x2,y2)</TT> establish a line or a point (this happens when one or more
of the x-coordinates or y-coordinates are equal), nothing is drawn.
<BR><BR>The argument<B> fill</B> determines whether the figure is filled in or has only its outline drawn.&nbsp; The argument
can have one of two values:
<DL>
<DT>_GFILLINTERIOR
<DD>fill the interior by writing pixels with the current plot action using the current color and the current fill mask
<DT>_GBORDER
<DD>leave the interior unchanged; draw the outline of the figure with the current plot action using the current color and line
style
</DL>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _pie</TT> functions return a non-zero value when the figure was successfully drawn; otherwise, zero is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_arc">_arc</A>, <A HREF="#_ellipse">_ellipse</A>, <A HREF="#_setcolor">_setcolor</A>, <A HREF="#_setfillmask">_setfillmask</A>,
<A HREF="#_setlinestyle">_setlinestyle</A>, <A HREF="#_setplotaction">_setplotaction</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pie( _GBORDER, 120, 90, 520, 390,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
140, 20, 190, 460 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><IMG SRC="eg_pie.bmp" ALIGN=MIDDLE>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD><TT> _pie - DOS</TT>
<BR><BR><TT>_pie_w - DOS</TT>
<BR><TT>_pie_wxy - DOS</TT>
</DL>
<H2 ID="_pipe"> _pipe </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;io.h&gt;</TT>
<BR><TT>int _pipe( int *phandles, unsigned psize, int textmode );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _pipe</TT> function creates a pipe (an unnamed FIFO) and places a file descriptor for the read end of the pipe in<B>
phandles[0]</B> and a file descriptor for the write end of the pipe in<B> phandles[1]</B>.&nbsp; Their integer values are
the two lowest available at the time of the<TT> _pipe</TT> function call.&nbsp; The <TT> O_NONBLOCK</TT> flag is cleared for
both file descriptors.&nbsp; (The <TT> fcntl</TT> call can be used to set the <TT> O_NONBLOCK</TT> flag.)
<BR><BR>Data can be written to file descriptor<B> phandles[1]</B> and read from file descriptor<B> phandles[0]</B>.&nbsp;
A read on file descriptor<B> phandles[0]</B> returns the data written to<B> phandles[1]</B> on a first-in-first-out (FIFO)
basis.
<BR><BR>This function is typically used to connect together standard utilities to act as filters, passing the write end of
the pipe to the data producing process as its <TT> STDOUT_FILENO</TT> and the read end of the pipe to the data consuming process
as its <TT> STDIN_FILENO</TT>.&nbsp; (either via the traditional fork/dup2/exec or the more efficient spawn calls).
<BR><BR>If successful,<TT> _pipe</TT> marks for update the<B> st_ftime, st_ctime, st_atime</B> and<B> st_mtime</B> fields
of the pipe for updating.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _pipe</TT> function returns zero on success.&nbsp; Otherwise, (-1) is returned and <TT> errno</TT> is set to indicate
the error.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.&nbsp; If
any of the following conditions occur, the<TT> _pipe</TT> function shall return (-1) and set <TT> errno</TT> to the corresponding
value:
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>EMFILE
<DD>The calling process does not have at least 2 unused file descriptors available.
<DT>ENFILE
<DD>The number of simultaneously open files in the system would exceed the configured limit.
<DT>ENOSPC
<DD>There is insufficient space available to allocate the pipe buffer.
<DT>EROFS
<DD>The pipe pathname space is a read-only filesystem.
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#open">open</A>, <A HREF="#_pclose">_pclose</A>, <A HREF="#perror">perror</A>, <A HREF="#_popen">_popen</A>, <A HREF="#read">read</A>,
<A HREF="#write">write</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>#include &lt;stddef.h&gt;</TT>
<BR><TT>#include &lt;fcntl.h&gt;</TT>
<BR><TT>#include &lt;io.h&gt;</TT>
<BR><TT>#include &lt;process.h&gt;</TT>
<BR><BR><TT>static int handles[2] = { 0, 0 };</TT>
<BR><TT>static int pid;</TT>
<BR><BR><TT>create_pipe()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( _pipe( (int *)&amp;handles, 2048, _O_BINARY ) == -1 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; perror( &quot;create_pipe&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit( EXIT_FAILURE );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
<BR><BR><TT>create_child( char *name )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char buff[10];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; itoa( handles[0], buff, 10 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; pid = spawnl( P_NOWAIT, name,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;_pipe&quot;,
buff, NULL );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; close( handles[0] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( pid == -1 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; perror( &quot;create_child&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close( handles[1] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit( EXIT_FAILURE );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
<BR><BR><TT>fill_pipe()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int i;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int rc;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; for( i = 1; i &lt;= 10; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Child, what is 5 times %d\n&quot;, i );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc = write( handles[1], &amp;i, sizeof( int ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( rc &lt; sizeof( int ) ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; perror( &quot;fill_pipe&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close( handles[1] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit( EXIT_FAILURE );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* indicate that we are done */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; i = -1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; write( handles[1], &amp;i, sizeof( int ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; close( handles[1] );</TT>
<BR><TT>}</TT>
<BR><BR><TT>empty_pipe( int in_pipe )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int i;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int amt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; for(;;) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; amt = read( in_pipe, &amp;i, sizeof( int ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( amt != sizeof( int ) || i == -1 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Parent, 5 times %d is %d\n&quot;, i, 5*i );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( amt == -1 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; perror( &quot;empty_pipe&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit( EXIT_FAILURE );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; close( in_pipe );</TT>
<BR><TT>}</TT>
<BR><BR><TT>void main( int argc, char *argv[] )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( argc &lt;= 1 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* we are the spawning process */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; create_pipe();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; create_child( argv[0] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fill_pipe();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* we are the spawned process */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; empty_pipe( atoi( argv[1] ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; exit( EXIT_SUCCESS );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>Child, what is 5 times 1</TT>
<BR><TT>Child, what is 5 times 2</TT>
<BR><TT>Parent, 5 times 1 is 5</TT>
<BR><TT>Parent, 5 times 2 is 10</TT>
<BR><TT>Child, what is 5 times 3</TT>
<BR><TT>Child, what is 5 times 4</TT>
<BR><TT>Parent, 5 times 3 is 15</TT>
<BR><TT>Parent, 5 times 4 is 20</TT>
<BR><TT>Child, what is 5 times 5</TT>
<BR><TT>Child, what is 5 times 6</TT>
<BR><TT>Parent, 5 times 5 is 25</TT>
<BR><TT>Parent, 5 times 6 is 30</TT>
<BR><TT>Child, what is 5 times 7</TT>
<BR><TT>Child, what is 5 times 8</TT>
<BR><TT>Parent, 5 times 7 is 35</TT>
<BR><TT>Parent, 5 times 8 is 40</TT>
<BR><TT>Child, what is 5 times 9</TT>
<BR><TT>Child, what is 5 times 10</TT>
<BR><TT>Parent, 5 times 9 is 45</TT>
<BR><TT>Parent, 5 times 10 is 50</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>Win32, OS/2 1.x(all), OS/2-32
</DL>
<H2 ID="_polygon"> _polygon, _polygon_w, _polygon_wxy </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>short _FAR _polygon( short fill, short numpts,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;struct xycoord _FAR *points );</TT>
<BR><BR><TT>short _FAR _polygon_w( short fill, short numpts,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; double _FAR *points );</TT>
<BR><BR><TT>short _FAR _polygon_wxy( short fill, short numpts,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; struct _wxycoord _FAR *points );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _polygon</TT> functions draw polygons.&nbsp; The<TT> _polygon</TT> function uses the view coordinate system.&nbsp;
The<TT> _polygon_w</TT> and<TT> _polygon_wxy</TT> functions use the window coordinate system.
<BR><BR>The polygon is defined as containing<B> numpts</B> points whose coordinates are given in the array<B> points</B>.
<BR><BR>The argument<B> fill</B> determines whether the polygon is filled in or has only its outline drawn.&nbsp; The argument
can have one of two values:
<DL>
<DT>_GFILLINTERIOR
<DD>fill the interior by writing pixels with the current plot action using the current color and the current fill mask
<DT>_GBORDER
<DD>leave the interior unchanged; draw the outline of the figure with the current plot action using the current color and line
style
</DL>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _polygon</TT> functions return a non-zero value when the polygon was successfully drawn; otherwise, zero is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_setcolor">_setcolor</A>, <A HREF="#_setfillmask">_setfillmask</A>, <A HREF="#_setlinestyle">_setlinestyle</A>,
<A HREF="#_setplotaction">_setplotaction</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><BR><TT>struct xycoord points[ 5 ] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 319, 140, 224, 209, 261, 320,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 378, 320, 415, 209</TT>
<BR><TT>};</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _polygon( _GBORDER, 5, points );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><IMG SRC="eg_polyg.bmp" ALIGN=MIDDLE>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD><TT> _polygon - DOS</TT>
<BR><BR><TT>_polygon_w - DOS</TT>
<BR><TT>_polygon_wxy - DOS</TT>
</DL>
<H2 ID="popen"> popen </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>FILE *popen( const char *command, const char *mode );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> popen</TT> function executes the command specified by<B> command</B> and creates a pipe between the calling process
and the executed command.
<BR><BR>Depending on the<B> mode</B> argument, the stream pointer returned may be used to read from or write to the pipe.
<BR><BR>The executed command has an environment the same as its parents.&nbsp; The command will be started as follows:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; execl(&quot;/bin/sh&quot;, &quot;sh&quot;, &quot;-c&quot;, command, (char *) NULL);</TT>
<BR><BR>The<B> mode</B> argument to<TT> popen</TT> is a string that specifies an I/O mode for the pipe.
<DL>
<DT>Mode&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>&quot;r&quot;
<DD>The calling process will read from the standard output of the child process using the stream pointer returned by<TT> popen</TT>
<DT>&quot;w&quot;
<DD>The calling process will write to the standard input of the child process using the stream pointer returned by<TT> popen</TT>
</DL>
<BR>A stream opened by<TT> popen</TT> should be closed by the <TT> pclose</TT> function.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> popen</TT> function returns a non-NULL stream pointer upon successful completion.&nbsp; If<TT> popen</TT> is unable
to create either the pipe or the subprocess, a<TT> NULL</TT> stream pointer is returned and <TT> errno</TT> is set appropriately.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
<DL>
<DT><B><I>Constant</I></B>
<DD><B><I>Meaning</I></B>
<DT>EINVAL
<DD>The<B> mode</B> argument is invalid.
</DL>
<BR><TT>popen</TT> may also set <TT> errno</TT> values as described by the <TT> pipe</TT> , <TT> fork</TT> , and <TT> execl</TT>
functions.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#pclose">pclose</A>, <A HREF="#exec___">exec...</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>/*</TT>
<BR><TT> * Executes the 'ls' command and prints all</TT>
<BR><TT> * its output preceded by an arrow.</TT>
<BR><TT> */</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>int main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FILE *fp;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char readbuf[256];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; fp = popen(&quot;ls&quot;, &quot;r&quot;);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if(fp == NULL) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;Failed to open pipe\n&quot;);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(1);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; while(fgets(readbuf, 256, fp))</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;-&gt; %s&quot;, readbuf);</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; pclose(fp);</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; return 0;</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>POSIX 1003.1
</DL>
<DL>
<DT>Systems:
<DD>Linux
</DL>
<H2 ID="_popen"> _popen, _wpopen </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>FILE *_popen( const char *command, const char *mode );</TT>
<BR><TT>FILE *_wpopen( const wchar_t *command, const wchar_t *mode );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _popen</TT> function executes the command specified by<B> command</B> and creates a pipe between the calling process
and the executed command.
<BR><BR>Depending on the<B> mode</B> argument, the stream pointer returned may be used to read from or write to the pipe.
<BR><BR>The executed command has an environment the same as its parents.&nbsp; The command will be started as follows:&nbsp;
spawnl(&lt;shell_path&gt;, &lt;shell&gt;, &quot;-c&quot;, command, (char *)NULL);
<BR><BR>where<TT> &lt;shell_path&gt;</TT> is an unspecified path for the shell utility and<TT> &lt;shell&gt;</TT> is one of
&quot;command.com&quot; (DOS, Windows 95) or &quot;cmd.exe&quot; (Windows NT/2000, OS/2).
<BR><BR>The<B> mode</B> argument to<TT> _popen</TT> is a string that specifies an I/O mode for the pipe.
<DL>
<DT>Mode&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>&quot;r&quot;
<DD>The calling process will read from the standard output of the child process using the stream pointer returned by<TT> _popen</TT>
<DT>&quot;w&quot;
<DD>The calling process will write to the standard input of the child process using the stream pointer returned by<TT> _popen</TT>
</DL>
<BR>The letter &quot;t&quot; may be added to any of the above modes to indicate that the file is (or must be) a text file
(i.e., CR/LF pairs are converted to newline characters).
<BR><BR>The letter &quot;b&quot; may be added to any of the above modes to indicate that the file is (or must be) a binary
file (an ISO C requirement for portability to systems that make a distinction between text and binary files).
<BR><BR>When default file translation is specified (i.e., no &quot;t&quot; or &quot;b&quot; is specified), the value of the
global variable <TT> _fmode</TT> establishes whether the file is to treated as a binary or a text file.&nbsp; Unless this
value is changed by the program, the default will be text mode.
<BR><BR>A stream opened by<TT> _popen</TT> should be closed by the <TT> _pclose</TT> function.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _popen</TT> function returns a non-NULL stream pointer upon successful completion.&nbsp; If<TT> _popen</TT> is unable
to create either the pipe or the subprocess, a<TT> NULL</TT> stream pointer is returned and <TT> errno</TT> is set appropriately.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
<DL>
<DT><B><I>Constant</I></B>
<DD><B><I>Meaning</I></B>
<DT>EINVAL
<DD>The<B> mode</B> argument is invalid.
</DL>
<BR><TT>_popen</TT> may also set <TT> errno</TT> values as described by the <TT> _pipe</TT> and <TT> spawnl</TT> functions.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_grow_handles">_grow_handles</A>, <A HREF="#_pclose">_pclose</A>, <A HREF="#perror">perror</A>, <A HREF="#_pipe">_pipe</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>/*</TT>
<BR><TT> * Executes a given program, converting all</TT>
<BR><TT> * output to upper case.</TT>
<BR><TT> */</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>#include &lt;ctype.h&gt;</TT>
<BR><BR><TT>char&nbsp;&nbsp; buffer[256];</TT>
<BR><BR><TT>void main( int argc, char **argv )</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp; i;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp; c;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FILE *f;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; for( i = 1; i &lt; argc; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcat( buffer, argv[i] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcat( buffer, &quot; &quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; if( ( f = _popen( buffer, &quot;r&quot; ) ) == NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; perror( &quot;_popen&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit( 1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; while( ( c = getc(f) ) != EOF ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( islower( c ) )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c = toupper( c );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; putchar( c );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _pclose( f );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> _popen - Win32, OS/2 1.x(all), OS/2-32, Linux</TT>
<BR><BR><TT>_wpopen - Win32, OS/2 1.x(all), OS/2-32</TT>
</DL>
<H2 ID="pow"> pow </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>double pow( double x, double y );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> pow</TT> function computes<B> x</B> raised to the power<B> y</B>.&nbsp; A domain error occurs if<B> x</B> is zero
and<B> y</B> is less than or equal to 0, or if<B> x</B> is negative and<B> y</B> is not an integer.&nbsp; A range error may
occur.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> pow</TT> function returns the value of<B> x</B> raised to the power<B> y</B>.&nbsp; When the argument is outside the
permissible range, the <TT> matherr</TT> function is called.&nbsp; Unless the default <TT> matherr</TT> function is replaced,
it will set the global variable <TT> errno</TT> to <TT> EDOM</TT>, and print a &quot;DOMAIN error&quot; diagnostic message
using the <TT> stderr</TT> stream.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#exp">exp</A>, <A HREF="#log">log</A>, <A HREF="#sqrt">sqrt</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, pow( 1.5, 2.5 ) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>2.755676</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD>Math
</DL>
<H2 ID="printf"> printf, wprintf </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>int printf( const char *format, ... );</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>int wprintf( const wchar_t *format, ... );</TT>
</DL>
<DL>
<DT>Safer C:
<DD>The Safer C Library extension provides the <A HREF="#printf_s">printf_s</A> function which is a safer alternative to<TT> printf</TT>
This newer<TT> printf_s</TT> function is recommended to be used instead of the traditional &quot;unsafe&quot;<TT> printf</TT>
function.
</DL>
<DL>
<DT>Description:
<DD>The<TT> printf</TT> function writes output to the file designated by <TT> stdout</TT> under control of the argument<B> format</B>.
&nbsp;The<B> format</B> string is described below.
<BR><BR>The<TT> wprintf</TT> function is a wide-character version of<TT> printf</TT>.&nbsp; It accepts a wide-character string
argument for<B> format</B> and produces wide character output.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> printf</TT> function returns the number of characters written, or a negative value if an output error occurred.
<BR><BR>The<TT> wprintf</TT> function returns the number of wide characters written, or a negative value if an output error
occurred.&nbsp; When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_bprintf">_bprintf</A>, <A HREF="#cprintf">cprintf</A>, <A HREF="#fprintf">fprintf</A>, <A HREF="#sprintf">sprintf</A>,
<A HREF="#_vbprintf">_vbprintf</A>, <A HREF="#vcprintf">vcprintf</A>, <A HREF="#vfprintf">vfprintf</A>, <A HREF="#vprintf">vprintf</A>,
<A HREF="#vsprintf">vsprintf</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char *weekday, *month;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; weekday = &quot;Saturday&quot;;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; month = &quot;April&quot;;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s, %s %d, %d\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; weekday, month, 18, 1987 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;f1 = %8.4f f2 = %10.2E x = %#08x i = %d\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 23.45,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3141.5926,
&nbsp; 0x1db,&nbsp;&nbsp;&nbsp;&nbsp; -1 );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>Saturday, April 18, 1987</TT>
<BR><TT>f1 =&nbsp; 23.4500 f2 =&nbsp; 3.14E+003 x = 0x0001db i = -1</TT>
</DL>
<DL>
<DT>Format Control String:
<DD>The format control string consists of<B> ordinary characters,</B> that are written exactly as they occur in the format string,
and<B> conversion specifiers,</B> that cause argument values to be written as they are encountered during the processing of
the format string.&nbsp; An ordinary character in the format string is any character, other than a percent character (%),
that is not part of a conversion specifier.&nbsp; A conversion specifier is a sequence of characters in the format string
that begins with a percent character (%) and is followed, in sequence, by the following:
<UL>
<LI>zero or more<B> format control flags</B> that can modify the final effect of the format directive;
<LI>an optional decimal integer, or an asterisk character ('*'), that specifies a<B> minimum field width</B> to be reserved
for the formatted item;
<LI>an optional<B> precision</B> specification in the form of a period character (.), followed by an optional decimal integer
or an asterisk character (*);
<LI>an optional<B> type length</B> specification:&nbsp; one of &quot;hh&quot;, &quot;h&quot;, &quot;l&quot;, &quot;ll&quot;,
&quot;j&quot;, &quot;z&quot;, &quot;t&quot;, &quot;L&quot;, &quot;I64&quot;, &quot;w&quot;, &quot;N&quot; or &quot;W&quot;;
and
<LI>a character that specifies the type of conversion to be performed:&nbsp; one of the characters &quot;bcCdeEfFgGinopsSuxX&quot;.
</UL>
<BR>The valid format control flags are:
<DL>
<DT>&quot;-&quot;
<DD>the formatted item is left-justified within the field; normally, items are right-justified
<DT>&quot;+&quot;
<DD>a signed, positive object will always start with a plus character (+); normally, only negative items begin with a sign
<DT>&quot; &quot;
<DD>a signed, positive object will always start with a space character; if both &quot;+&quot; and &quot; &quot; are specified,
&quot;+&quot; overrides &quot; &quot;
<DT>&quot;#&quot;
<DD>an alternate conversion form is used:
<UL>
<LI>for &quot;b&quot; (unsigned binary) and &quot;o&quot; (unsigned octal) conversions, the precision is incremented, if necessary,
so that the first digit is &quot;0&quot;.
<LI>for &quot;x&quot; or &quot;X&quot; (unsigned hexadecimal) conversions, a non-zero value is prepended with &quot;0x&quot;
or &quot;0X&quot; respectively.
<LI>for &quot;e&quot;, &quot;E&quot;, &quot;f&quot;, &quot;F&quot;, &quot;g&quot; or &quot;G&quot; (any floating-point) conversions,
the result always contains a decimal-point character, even if no digits follow it; normally, a decimal-point character appears
in the result only if there is a digit to follow it.
<LI>in addition to the preceding, for &quot;g&quot; or &quot;G&quot; conversions, trailing zeros are not removed from the
result.
</UL>
</DL>
<BR>If no field width is specified, or if the value that is given is less than the number of characters in the converted value
(subject to any precision value), a field of sufficient width to contain the converted value is used.&nbsp; If the converted
value has fewer characters than are specified by the field width, the value is padded on the left (or right, subject to the
left-justification flag) with spaces or zero characters (&quot;0&quot;).&nbsp; If the field width begins with &quot;0&quot;
and no precision is specified, the value is padded with zeros; otherwise the value is padded with spaces.&nbsp; If the field
width is &quot;*&quot;, a value of type<TT> int</TT> from the argument list is used (before a precision argument or a conversion
argument) as the minimum field width.&nbsp; A negative field width value is interpreted as a left-justification flag, followed
by a positive field width.
<BR><BR>As with the field width specifier, a precision specifier of &quot;*&quot; causes a value of type<TT> int</TT> from
the argument list to be used as the precision specifier.&nbsp; If no precision value is given, a precision of 0 is used.&nbsp;
The precision value affects the following conversions:
<UL>
<LI>For &quot;b&quot;, &quot;d&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;, &quot;x&quot; and &quot;X&quot; (integer)
conversions, the precision specifies the minimum number of digits to appear.
<LI>For &quot;e&quot;, &quot;E&quot;, &quot;f&quot; and &quot;F&quot; (fixed-precision, floating-point) conversions, the precision
specifies the number of digits to appear after the decimal-point character.
<LI>For &quot;g&quot; and &quot;G&quot; (variable-precision, floating-point) conversions, the precision specifies the maximum
number of significant digits to appear.
<LI>For &quot;s&quot; or &quot;S&quot; (string) conversions, the precision specifies the maximum number of characters to appear.
</UL>
<BR>A type length specifier affects the conversion as follows:
<UL>
<LI>&quot;hh&quot; causes a &quot;b&quot;, &quot;d&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;, &quot;x&quot; or &quot;X&quot;
(integer) format conversion to treat the argument as a<TT> signed char</TT> or<TT> unsigned char</TT> argument.&nbsp; Note
that, although the argument may have been promoted to an<TT> int</TT> as part of the function call, the value is converted
to the smaller type before it is formatted.
<LI>&quot;hh&quot; causes an &quot;n&quot; (converted length assignment) operation to assign the converted length to an object
of type<TT> signed char.</TT>
<LI>&quot;h&quot; causes a &quot;b&quot;, &quot;d&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;, &quot;x&quot; or &quot;X&quot;
(integer) format conversion to treat the argument as a<TT> short int</TT> or<TT> unsigned short int</TT> argument.&nbsp; Note
that, although the argument may have been promoted to an<TT> int</TT> as part of the function call, the value is converted
to the smaller type before it is formatted.
<LI>&quot;h&quot; causes an &quot;f&quot; format conversion to interpret a<TT> long</TT> argument as a fixed-point number
consisting of a 16-bit signed integer part and a 16-bit unsigned fractional part.&nbsp; The integer part is in the high 16
bits and the fractional part is in the low 16 bits.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct fixpt {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned short fraction; /* Intel architecture! */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signed short integral;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct fixpt foo1 =</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { 0x8000, 1234 }; /* represents 1234.5 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct fixpt foo2 =</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { 0x8000, -1 };&nbsp;&nbsp; /* represents -0.5 (-1+.5) */</TT>
<BR><BR>The value is formatted with the same rules as for floating-point values.&nbsp; This is a Open Watcom extension.
<LI>&quot;h&quot; causes an &quot;n&quot; (converted length assignment) operation to assign the converted length to an object
of type<TT> short int.</TT>
<LI>&quot;h&quot; causes an &quot;s&quot; operation to treat the argument string as an ASCII character string composed of
8-bit characters.
<BR><BR>For <TT> printf</TT> and related byte input/output functions, this specifier is redundant.&nbsp; For <TT> wprintf</TT>
and related wide character input/output functions, this specifier is required if the argument string is to be treated as an
8-bit ASCII character string; otherwise it will be treated as a wide character string.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; printf(&nbsp;&nbsp;&nbsp; &quot;%s%d&quot;, &quot;Num=&quot;, 12345 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; wprintf( L&quot;%hs%d&quot;, &quot;Num=&quot;, 12345 );</TT>
<LI>&quot;l&quot; causes a &quot;b&quot;, &quot;d&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;, &quot;x&quot; or &quot;X&quot;
(integer) conversion to process a<TT> long int</TT> or<TT> unsigned long int</TT> argument.
<LI>&quot;l&quot; causes an &quot;n&quot; (converted length assignment) operation to assign the converted length to an object
of type<TT> long int.</TT>
<LI>&quot;l&quot; or &quot;w&quot; cause an &quot;s&quot; operation to treat the argument string as a wide character string
(a string composed of characters of type <TT> wchar_t</TT>).
<BR><BR>For <TT> printf</TT> and related byte input/output functions, this specifier is required if the argument string is
to be treated as a wide character string; otherwise it will be treated as an 8-bit ASCII character string.&nbsp; For <TT>
wprintf</TT> and related wide character input/output functions, this specifier is redundant.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; printf(&nbsp; &quot;%ls%d&quot;, L&quot;Num=&quot;, 12345 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; wprintf( L&quot;%s%d&quot;, L&quot;Num=&quot;, 12345 );</TT>
<LI>&quot;ll&quot; causes a &quot;b&quot;, &quot;d&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;, &quot;x&quot; or &quot;X&quot;
(integer) conversion to process a<TT> long long</TT> or<TT> unsigned long long</TT> argument (e.g., %lld).
<LI>&quot;ll&quot; causes an &quot;n&quot; (converted length assignment) operation to assign the converted length to an object
of type<TT> long long int.</TT>
<LI>&quot;j&quot; causes a &quot;b&quot;, &quot;d&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;, &quot;x&quot; or &quot;X&quot;
(integer) conversion to process an<TT> intmax_t</TT> or<TT> uintmax_t</TT> argument.
<LI>&quot;j&quot; causes an &quot;n&quot; (converted length assignment) operation to assign the converted length to an object
of type<TT> intmax_t.</TT>
<LI>&quot;z&quot; causes a &quot;b&quot;, &quot;d&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;, &quot;x&quot; or &quot;X&quot;
(integer) conversion to process a<TT> size_t</TT> or the corresponding signed integer type argument.
<LI>&quot;z&quot; causes an &quot;n&quot; (converted length assignment) operation to assign the converted length to an object
of signed integer type corresponding to<TT> size_t.</TT>
<LI>&quot;t&quot; causes a &quot;b&quot;, &quot;d&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;, &quot;x&quot; or &quot;X&quot;
(integer) conversion to process a<TT> ptrdiff_t</TT> or the corresponding unsigned integer type argument.
<LI>&quot;t&quot; causes an &quot;n&quot; (converted length assignment) operation to assign the converted length to an object
of type<TT> ptrdiff_t.</TT>
<LI>&quot;I64&quot; causes a &quot;b&quot;, &quot;d&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;, &quot;x&quot; or &quot;X&quot;
(integer) conversion to process an<TT> __int64</TT> or<TT> unsigned __int64</TT> argument (e.g., %I64d).
<LI>&quot;L&quot; causes an &quot;e&quot;, &quot;E&quot;, &quot;f&quot;, &quot;F&quot;, &quot;g&quot;, &quot;G&quot; (double)
conversion to process a<TT> long double</TT> argument.
<LI>&quot;W&quot; causes the pointer associated with &quot;n&quot;, &quot;p&quot;, &quot;s&quot; conversions to be treated
as a far pointer.
<LI>&quot;N&quot; causes the pointer associated with &quot;n&quot;, &quot;p&quot;, &quot;s&quot; conversions to be treated
as a near pointer.
</UL>
<BR>The valid conversion type specifiers are:
<DL>
<DT>b
<DD>An argument of type<TT> int</TT> is converted to an unsigned binary notation and written to the output stream.&nbsp; The default
precision is 1, but if more digits are required, leading zeros are added.
<DT>c
<DD>An argument of type<TT> int</TT> is converted to a value of type<TT> char</TT> and the corresponding ASCII character code
is written to the output stream.
<DT>C
<DD>An argument of type<TT> wchar_t</TT> is converted to a multibyte character and written to the output stream.
<DT>d, i
<DD>An argument of type<TT> int</TT> is converted to a signed decimal notation and written to the output stream.&nbsp; The default
precision is 1, but if more digits are required, leading zeros are added.
<DT>e, E
<DD>An argument of type<TT> double</TT> is converted to a decimal notation in the form<TT> [-]d.ddde[+|-]ddd</TT> similar to FORTRAN
exponential (E) notation.&nbsp; The leading sign appears (subject to the format control flags) only if the argument is negative.
&nbsp;If the argument is non-zero, the digit before the decimal-point character is non-zero.&nbsp; The precision is used as
the number of digits following the decimal-point character.&nbsp; If the precision is not specified, a default precision of
six is used.&nbsp; If the precision is 0, the decimal-point character is suppressed.&nbsp; The value is rounded to the appropriate
number of digits.&nbsp; For &quot;E&quot; conversions, the exponent begins with the character &quot;E&quot; rather than &quot;e&quot;.
&nbsp;The exponent sign and a three-digit number (that indicates the power of ten by which the decimal fraction is multiplied)
are always produced.
<DT>f, F
<DD>An argument of type<TT> double</TT> is converted to a decimal notation in the form<TT> [-]ddd.ddd</TT> similar to FORTRAN
fixed-point (F) notation.&nbsp; The leading sign appears (subject to the format control flags) only if the argument is negative.
&nbsp;The precision is used as the number of digits following the decimal-point character.&nbsp; If the precision is not specified,
a default precision of six is used.&nbsp; If the precision is 0, the decimal-point character is suppressed, otherwise, at
least one digit is produced before the decimal-point character.&nbsp; The value is rounded to the appropriate number of digits.
<DT>g, G
<DD>An argument of type<TT> double</TT> is converted using either the &quot;f&quot; or &quot;e&quot; (or &quot;F&quot; or &quot;E&quot;,
for a &quot;G&quot; conversion) style of conversion depending on the value of the argument.&nbsp; In either case, the precision
specifies the number of significant digits that are contained in the result.&nbsp; &quot;e&quot; style conversion is used
only if the exponent from such a conversion would be less than -4 or greater than the precision.&nbsp; Trailing zeros are
removed from the result and a decimal-point character only appears if it is followed by a digit.
<DT>n
<DD>The number of characters that have been written to the output stream is assigned to the integer pointed to by the argument.
&nbsp;No output is produced.
<DT>o
<DD>An argument of type<TT> int</TT> is converted to an unsigned octal notation and written to the output stream.&nbsp; The default
precision is 1, but if more digits are required, leading zeros are added.
<DT>p, P
<DD>An argument of type<TT> void *</TT> is converted to a value of type<TT> int</TT> and the value is formatted as for a hexadecimal
(&quot;x&quot;) conversion.
<DT>s
<DD>Characters from the string specified by an argument of type<TT> char *</TT> or<TT> wchar_t *</TT>, up to, but not including
the terminating null character ('\0'), are written to the output stream.&nbsp; If a precision is specified, no more than that
many characters (bytes) are written (e.g., %.7s)
<BR><BR>For<TT> printf</TT> this specifier refers to an ASCII character string unless the &quot;l&quot; or &quot;w&quot; modifiers
are used to indicate a wide character string.
<BR><BR>For wprintf, this specifier refers to a wide character string unless the &quot;h&quot; modifier is used to indicate
an ASCII character string.&nbsp; *.
<DT>S
<DD>Characters from the string specified by an argument of type<TT> wchar_t *</TT>, up to, but not including the terminating null
wide character (L'\0'), are converted to multibyte characters and written to the output stream.&nbsp; If a precision is specified,
no more than that many characters (bytes) are written (e.g., %.7S)
<DT>u
<DD>An argument of type<TT> int</TT> is converted to an unsigned decimal notation and written to the output stream.&nbsp; The
default precision is 1, but if more digits are required, leading zeros are added.
<DT>x, X
<DD>An argument of type<TT> int</TT> is converted to an unsigned hexadecimal notation and written to the output stream.&nbsp;
The default precision is 1, but if more digits are required, leading zeros are added.&nbsp; Hexadecimal notation uses the
digits &quot;0&quot; through &quot;9&quot; and the characters &quot;a&quot; through &quot;f&quot; or &quot;A&quot; through
&quot;F&quot; for &quot;x&quot; or &quot;X&quot; conversions respectively, as the hexadecimal digits.&nbsp; Subject to the
alternate-form control flag, &quot;0x&quot; or &quot;0X&quot; is prepended to the output.
</DL>
<BR>Any other conversion type specifier character, including another percent character (%), is written to the output stream
with no special interpretation.
<BR><BR>The arguments must correspond with the conversion type specifiers, left to right in the string; otherwise, indeterminate
results will occur.
<BR><BR>If the value corresponding to a floating-point specifier is infinity, or not a number (NaN), then the output will
be &quot;inf&quot; or &quot;-inf&quot; for infinity, and &quot;nan&quot; or &quot;-nan&quot; for NaN's.&nbsp; If the conversion
specifier is an uppercase character (ie.&nbsp; &quot;E&quot;, &quot;F&quot;, or &quot;G&quot;), the output will be uppercase
as well (&quot;INF&quot;, &quot;NAN&quot;), otherwise the output will be lowercase as noted above.
<BR><BR>The pointer size specification (&quot;N&quot; or &quot;W&quot;) is only effective on platforms that use a segmented
memory model, although it is always recognized.
<BR><BR>For example, a specifier of the form<TT> &quot;%8.*f&quot;</TT> will define a field to be at least 8 characters wide,
and will get the next argument for the precision to be used in the conversion.
</DL>
<DL>
<DT>Classification:
<DD>ISO C (except for N, W pointer size modifiers and b, I64 specifiers)
<BR><BR>wprintf is ISO C95
</DL>
<DL>
<DT>Systems:
<DD><TT> printf - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>wprintf - All, Linux</TT>
</DL>
<H2 ID="printf_s"> printf_s, wprintf_s </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__ 1</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>int printf_s( const char * restrict format, ... );</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>int wprintf_s( const wchar_t * restrict format, ... );</TT>
</DL>
<DL>
<DT>Constraints:
<DD>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<TT>
printf_s</TT> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<BR><BR>The<B> format</B> argument shall not be a null pointer.&nbsp; The<TT> %n</TT> specifier (modified or not by flags,
field width, or precision) shall not appear in the string pointed to by<B> format</B>.&nbsp; Any argument to<TT> printf_s</TT>
corresponding to a<TT> %s</TT> specifier shall not be a null pointer.
<BR><BR>If there is a runtime-constraint violation, the<TT> printf_s</TT> function does not attempt to produce further output,
and it is unspecified to what extent<TT> printf_s</TT> produced output before discovering the runtime-constraint violation.
</DL>
<DL>
<DT>Description:
<DD>The<TT> printf_s</TT> function is equivalent to the <TT> printf</TT> function except for the explicit runtime-constraints
listed above.
<BR><BR>The<TT> wprintf_s</TT> function is a wide-character version of<TT> printf_s</TT>.&nbsp; It accepts a wide-character
string argument for<B> format</B> and produces wide character output.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> printf_s</TT> function returns the number of characters written, or a negative value if an output error or runtime-constraint
violation occurred.
<BR><BR>The<TT> wprintf_s</TT> function returns the number of wide characters written, or a negative value if an output error
or runtime-constraint violation occurred.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_bprintf">_bprintf</A>, <A HREF="#cprintf">cprintf</A>, <A HREF="#fprintf">fprintf</A>, <A HREF="#printf">printf</A>,
<A HREF="#sprintf">sprintf</A>, <A HREF="#_vbprintf">_vbprintf</A>, <A HREF="#vcprintf">vcprintf</A>, <A HREF="#vfprintf">vfprintf</A>,
<A HREF="#vprintf">vprintf</A>, <A HREF="#vsprintf">vsprintf</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__ 1</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char *weekday, *month;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; weekday = &quot;Saturday&quot;;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; month = &quot;April&quot;;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf_s( &quot;%s, %s %d, %d\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; weekday, month, 18, 1987 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf_s( &quot;f1 = %8.4f f2 = %10.2E x = %#08x i = %d\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 23.45, 3141.5926, 0x1db, -1 );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>Saturday, April 18, 1987</TT>
<BR><TT>f1 =&nbsp; 23.4500 f2 =&nbsp; 3.14E+003 x = 0x0001db i = -1</TT>
</DL>
<DL>
<DT>Classification:
<DD>TR 24731
</DL>
<DL>
<DT>Systems:
<DD><TT> printf_s - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>wprintf_s - All, Linux</TT>
</DL>
<H2 ID="putc"> putc, putwc </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>int putc( int c, FILE *fp );</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>wint_t putwc( wint_t c, FILE *fp );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> putc</TT> function is equivalent to <TT> fputc</TT>, except it may be implemented as a macro.&nbsp; The<TT> putc</TT>
function writes the character specified by the argument<B> c</B> to the output stream designated by<B> fp</B>.
<BR><BR>The<TT> putwc</TT> function is identical to<TT> putc</TT> except that it converts the wide character specified by<B>
c</B> to a multibyte character and writes it to the output stream.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> putc</TT> function returns the character written or, if a write error occurs, the error indicator is set and<TT> putc</TT>
returns <TT> EOF</TT>.
<BR><BR>The<TT> putwc</TT> function returns the wide character written or, if a write error occurs, the error indicator is
set and<TT> putwc</TT> returns <TT> WEOF</TT>.
<BR><BR>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#fopen">fopen</A>, <A HREF="#fputc">fputc</A>, <A HREF="#fputchar">fputchar</A>, <A HREF="#fputs">fputs</A>, <A HREF="#putchar">putchar</A>,
<A HREF="#puts">puts</A>, <A HREF="#ferror">ferror</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FILE *fp;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int c;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; fp = fopen( &quot;file&quot;, &quot;r&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( fp != NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( (c = fgetc( fp )) != EOF )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; putc( c, stdout );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( fp );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD><TT> putc - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>putwc - All, Linux</TT>
</DL>
<H2 ID="putch"> putch </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>int putch( int c );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> putch</TT> function writes the character specified by the argument<B> c</B> to the console.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> putch</TT> function returns the character written.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#getch">getch</A>, <A HREF="#getche">getche</A>, <A HREF="#kbhit">kbhit</A>, <A HREF="#ungetch">ungetch</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FILE *fp;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int c;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; fp = fopen( &quot;file&quot;, &quot;r&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if ( fp != NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( (c = fgetc( fp )) != EOF )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; putch( c );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fclose( fp );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="putchar"> putchar, putwchar </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>int putchar( int c );</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>wint_t putwchar( wint_t c );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> putchar</TT> function writes the character specified by the argument<B> c</B> to the output stream <TT> stdout</TT>.
<BR><BR>The function is equivalent to
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; fputc( c, stdout );</TT>
<BR><BR>The<TT> putwchar</TT> function is identical to<TT> putchar</TT> except that it converts the wide character specified
by<B> c</B> to a multibyte character and writes it to the output stream.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> putchar</TT> function returns the character written or, if a write error occurs, the error indicator is set and<TT>
putchar</TT> returns <TT> EOF</TT>.
<BR><BR>The<TT> putwchar</TT> function returns the wide character written or, if a write error occurs, the error indicator
is set and<TT> putwchar</TT> returns <TT> WEOF</TT>.
<BR><BR>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#fopen">fopen</A>, <A HREF="#fputc">fputc</A>, <A HREF="#fputchar">fputchar</A>, <A HREF="#fputs">fputs</A>, <A HREF="#putc">putc</A>,
<A HREF="#puts">puts</A>, <A HREF="#ferror">ferror</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FILE *fp;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int c;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; fp = fopen( &quot;file&quot;, &quot;r&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; c = fgetc( fp );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; while( c != EOF ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; putchar( c );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c = fgetc( fp );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fclose( fp );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>putwchar is ISO C95
</DL>
<DL>
<DT>Systems:
<DD><TT> putchar - All, Linux, Netware</TT>
<BR><BR><TT>putwchar - All, Linux</TT>
</DL>
<H2 ID="putenv"> putenv, _putenv, _wputenv </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>int putenv( const char *env_name );</TT>
<BR><TT>int _putenv( const char *env_name );</TT>
<BR><TT>int _wputenv( const wchar_t *env_name );</TT>
</DL>
<DL>
<DT>Description:
<DD>The environment list consists of a number of environment names, each of which has a value associated with it.&nbsp; Entries
can be added to the environment list with the DOS<TT> set</TT> command or with the<TT> putenv</TT> function.&nbsp; All entries
in the environment list can be displayed by using the DOS<TT> set</TT> command with no arguments.&nbsp; A program can obtain
the value for an environment variable by using the <TT> getenv</TT> function.
<BR><BR>When the value of<B> env_name</B> has the format
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env_name=value</TT>
<BR><BR>an environment name and its value is added to the environment list.&nbsp; When the value of<B> env_name</B> has the
format
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env_name=</TT>
<BR><BR>the environment name and value is removed from the environment list.
<BR><BR>The matching is case-insensitive; all lowercase letters are treated as if they were in upper case.
<BR><BR>The space into which environment names and their values are placed is limited.&nbsp; Consequently, the<TT> putenv</TT>
function can fail when there is insufficient space remaining to store an additional value.
<BR><BR>The<TT> _putenv</TT> function is identical to<TT> putenv</TT>.&nbsp; Use<TT> _putenv</TT> for ANSI naming conventions.
<BR><BR>The<TT> _wputenv</TT> function is a wide-character version of<TT> putenv</TT> the<B> env_name</B> argument to<TT>
_wputenv</TT> is a wide-character string.
<BR><BR><TT>putenv</TT> and<TT> _wputenv</TT> affect only the environment that is local to the current process; you cannot
use them to modify the command-level environment.&nbsp; That is, these functions operate only on data structures accessible
to the run-time library and not on the environment &quot;segment&quot; created for a process by the operating system.&nbsp;
When the current process terminates, the environment reverts to the level of the calling process (in most cases, the operating-system
level).&nbsp; However, the modified environment can be passed to any new processes created by _spawn, _exec, or system, and
these new processes get any new items added by<TT> putenv</TT> and _wputenv.
<BR><BR>With regard to environment entries, observe the following cautions:
<UL>
<LI>Do not change an environment entry directly; instead, use putenv or<TT> _wputenv</TT> to change it.&nbsp; To modify the
return value of<TT> putenv</TT> or<TT> _wputenv</TT> without affecting the environment table, use <TT> _strdup</TT> or <TT>
strcpy</TT> to make a copy of the string.
<LI>If the argument<B> env_name</B> is not a literal string, you should duplicate the string, since putenv does not copy the
value; for example,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; putenv( _strdup( buffer ) );</TT>
<LI>Never free a pointer to an environment entry, because the environment variable will then point to freed space.&nbsp; A
similar problem can occur if you pass<TT> putenv</TT> or<TT> _wputenv</TT> a pointer to a local variable, then exit the function
in which the variable is declared.
</UL>
<BR><TT>putenv</TT> use the global variable _environ to access the<TT> _wputenv</TT> use _wenviron.<TT>&nbsp; putenv</TT>
and<TT> _wputenv</TT> may change the value of _environ and _wenviron, thus<TT> putenv</TT> and<TT> _wputenv</TT> to global
variables, see _environ, _wenviron.
<BR><BR>To assign a string to a variable and place it in the environment list:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C&gt;SET INCLUDE=C:\WATCOM\H</TT>
<BR><BR>To see what variables are in the environment list, and their current assignments:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C&gt;SET</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; COMSPEC=C:\COMMAND.COM</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PATH=C:\;C:\WATCOM</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INCLUDE=C:\WATCOM\H</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C&gt;</TT>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> putenv</TT> function returns zero when it is successfully executed and returns -1 when it fails.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
<DL>
<DT>ENOMEM
<DD>Not enough memory to allocate a new environment string.
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#clearenv">clearenv</A>, <A HREF="#getenv">getenv</A>, <A HREF="#setenv">setenv</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR>The following gets the string currently assigned to <TT> INCLUDE</TT> and displays it, assigns a new value to it, gets
and displays it, and then removes the environment name and value.
<BR><BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char *path;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; path = getenv( &quot;INCLUDE&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( path != NULL )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;INCLUDE=%s\n&quot;, path );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( putenv( &quot;INCLUDE=mylib;yourlib&quot; ) != 0 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;putenv failed&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; path = getenv( &quot;INCLUDE&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( path != NULL )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;INCLUDE=%s\n&quot;, path );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( putenv( &quot;INCLUDE=&quot; ) != 0 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;putenv failed&quot; );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>INCLUDE=C:\WATCOM\H</TT>
<BR><TT>INCLUDE=mylib;yourlib</TT>
</DL>
<DL>
<DT>Classification:
<DD>POSIX 1003.1
<BR><BR>_putenv conforms to ANSI naming conventions
<BR>_wputenv is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> putenv - All, Linux, RDOS</TT>
<BR><BR><TT>_putenv - All, Linux, RDOS</TT>
<BR><TT>_wputenv - All, Linux</TT>
</DL>
<H2 ID="_putimage"> _putimage, _putimage_w </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>void _FAR _putimage( short x, short y,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;char _HUGE *image, short mode );</TT>
<BR><BR><TT>void _FAR _putimage_w( double x, double y,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; char _HUGE *image, short mode );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _putimage</TT> functions display the screen image indicated by the argument<B> image</B>.&nbsp; The<TT> _putimage</TT>
function uses the view coordinate system.&nbsp; The<TT> _putimage_w</TT> function uses the window coordinate system.
<BR><BR>The image is displayed upon the screen with its top left corner located at the point with coordinates<TT> (x,y).</TT>
&nbsp;The image was previously saved using the <TT> _getimage</TT> functions.&nbsp; The image is displayed in a rectangle
whose size is the size of the rectangular image saved by the <TT> _getimage</TT> functions.
<BR><BR>The image can be displayed in a number of ways, depending upon the value of the<B> mode</B> argument.&nbsp; This argument
can have the following values:
<DL>
<DT>_GPSET
<DD>replace the rectangle on the screen by the saved image
<DT>_GPRESET
<DD>replace the rectangle on the screen with the pixel values of the saved image inverted; this produces a negative image
<DT>_GAND
<DD>produce a new image on the screen by ANDing together the pixel values from the screen with those from the saved image
<DT>_GOR
<DD>produce a new image on the screen by ORing together the pixel values from the screen with those from the saved image
<DT>_GXOR
<DD>produce a new image on the screen by exclusive ORing together the pixel values from the screen with those from the saved image;
the original screen is restored by two successive calls to the _putimage function with this value, providing an efficient
method to produce animated effects
</DL>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _putimage</TT> functions do not return a value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getimage">_getimage</A>, <A HREF="#_imagesize">_imagesize</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>#include &lt;malloc.h&gt;</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char *buf;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int y;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _ellipse( _GFILLINTERIOR, 100, 100, 200, 200 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; buf = (char*) malloc(</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _imagesize(
100, 100, 201, 201 ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( buf != NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _getimage( 100, 100, 201, 201, buf );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _putimage( 260, 200, buf, _GPSET );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _putimage( 420, 100, buf, _GPSET );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( y = 100; y &lt; 300; ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _putimage( 420, y, buf, _GXOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y += 20;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _putimage( 420, y, buf, _GXOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; free( buf );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD><TT> _putimage - DOS</TT>
<BR><BR><TT>_putimage_w - DOS</TT>
</DL>
<H2 ID="puts"> puts, _putws </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>int puts( const char *buf );</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>int _putws( const wchar_t *bufs );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> puts</TT> function writes the character string pointed to by<B> buf</B> to the output stream designated by <TT> stdout</TT>,
and appends a new-line character to the output.&nbsp; The terminating null character is not written.
<BR><BR>The<TT> _putws</TT> function is identical to<TT> puts</TT> except that it converts the wide character string specified
by<B> buf</B> to a multibyte character string and writes it to the output stream.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> puts</TT> function returns <TT> EOF</TT> if an error occurs; otherwise, it returns a non-negative value (the number
of characters written including the new-line character).&nbsp; The<TT> _putws</TT> function returns <TT> EOF</TT> if a write
or encoding error occurs; otherwise, it returns a non-negative value (the number of characters written including the new-line
character).&nbsp; When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been
detected.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#fopen">fopen</A>, <A HREF="#fputc">fputc</A>, <A HREF="#fputchar">fputchar</A>, <A HREF="#fputs">fputs</A>, <A HREF="#putc">putc</A>,
<A HREF="#putchar">putchar</A>, <A HREF="#ferror">ferror</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FILE *fp;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char buffer[80];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; fp = freopen( &quot;file&quot;, &quot;r&quot;, stdin );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; while( gets( buffer ) != NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; puts( buffer );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fclose( fp );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>_putws is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> puts - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_putws - All, Linux</TT>
</DL>
<H2 ID="_putw"> _putw </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>int _putw( int binint, FILE *fp );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _putw</TT> function writes a binary value of type<B> int</B> to the current position of the stream<B> fp</B>.<TT>
&nbsp;_putw</TT> does not affect the alignment of items in the stream, nor does it assume any special alignment.
<BR><BR><TT>_putw</TT> is provided primarily for compatibility with previous libraries.&nbsp; Portability problems may occur
with<TT> _putw</TT> because the size of an<B> int</B> and the ordering of bytes within an<B> int</B> differ across systems.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _putw</TT> function returns the value written or, if a write error occurs, the error indicator is set and<TT> _putw</TT>
returns <TT> EOF</TT>.&nbsp; Since <TT> EOF</TT> is a legitimate value to write to<B> fp</B>, use <TT> ferror</TT> to verify
that an error has occurred.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#ferror">ferror</A>, <A HREF="#fopen">fopen</A>, <A HREF="#fputc">fputc</A>, <A HREF="#fputchar">fputchar</A>, <A HREF="#fputs">fputs</A>,
<A HREF="#putc">putc</A>, <A HREF="#putchar">putchar</A>, <A HREF="#puts">puts</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FILE *fp;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int c;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; fp = fopen( &quot;file&quot;, &quot;r&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( fp != NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( (c = _getw( fp )) != EOF )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _putw( c, stdout );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( fp );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="qsort"> qsort </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>void qsort( void *base,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t num,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t width,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int (*compar) ( const void *,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const void *) );</TT>
</DL>
<DL>
<DT>Safer C:
<DD>The Safer C Library extension provides the <A HREF="#qsort_s">qsort_s</A> function which is a safer alternative to<TT> qsort</TT>
This newer<TT> qsort_s</TT> function is recommended to be used instead of the traditional &quot;unsafe&quot;<TT> qsort</TT>
function.
</DL>
<DL>
<DT>Description:
<DD>The<TT> qsort</TT> function sorts an array of<B> num</B> elements, which is pointed to by<B> base</B>, using a modified version
of Sedgewick's Quicksort algorithm.&nbsp; Each element in the array is<B> width</B> bytes in size.&nbsp; The comparison function
pointed to by<B> compar</B> is called with two arguments that point to elements in the array.&nbsp; The comparison function
shall return an integer less than, equal to, or greater than zero if the first argument is less than, equal to, or greater
than the second argument.
<BR><BR>The version of the Quicksort algorithm that is employed was proposed by Jon Louis Bentley and M.&nbsp; Douglas McIlroy
in the article &quot;Engineering a sort function&quot; published in<B><I> Software -- Practice and Experience,</I></B> 23(11):1249-1265,
November 1993.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> qsort</TT> function returns no value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#qsort_s">qsort_s</A>, <A HREF="#bsearch">bsearch</A>, <A HREF="#bsearch_s">bsearch_s</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><BR><TT>char *CharVect[] = { &quot;last&quot;, &quot;middle&quot;, &quot;first&quot; };</TT>
<BR><BR><TT>int compare( const void *op1, const void *op2 )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; const char **p1 = (const char **) op1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; const char **p2 = (const char **) op2;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; return( strcmp( *p1, *p2 ) );</TT>
<BR><TT>}</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; qsort( CharVect, sizeof(CharVect)/sizeof(char *),</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sizeof(char *), compare );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s %s %s\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CharVect[0], CharVect[1], CharVect[2] );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>first last middle</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="qsort_s"> qsort_s </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__ 1</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>errno_t qsort_s( void *base,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rsize_t nmemb,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rsize_t size,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int (*compar)( const void *x, const void *y, void *context ),</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void *context );</TT>
</DL>
<DL>
<DT>Constraints:
<DD>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<TT>
qsort_s</TT> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<BR><BR>Neither<B> nmemb</B> nor<B> size</B> shall be greater than <TT> RSIZE_MAX</TT>.&nbsp; If<B> nmemb</B> is not equal
to zero, then neither<B> base</B> nor<B> compar</B> shall be a null pointer.&nbsp; If there is a runtime-constraint violation,
the<TT> qsort_s</TT> function does not sort the array.
</DL>
<DL>
<DT>Description:
<DD>The<TT> qsort_s</TT> function sorts an array of<B> nmemb</B> objects, the initial element of which is pointed to by<B> base</B>.
&nbsp;The size of each object is specified by<B> size</B>.&nbsp; The contents of the array are sorted into ascending order
according to a comparison function pointed to by<B> compar</B>, which is called with three arguments.&nbsp; The first two
point to the objects being compared.&nbsp; The function shall return an integer less than, equal to, or greater than zero
if the first argument is considered to be respectively less than, equal to, or greater than the second.&nbsp; The third argument
to the comparison function is the<B> context</B> argument passed to<TT> qsort_s</TT> The sole use of<B> context</B> by<TT>
qsort_s</TT> is to pass it to the comparison function.&nbsp; If two elements compare as equal, their relative order in the
resulting sorted array is unspecified.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> qsort_s</TT> function returns zero if there was no runtime-constraint violation.&nbsp; Otherwise, a non-zero value
is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#qsort">qsort</A>, <A HREF="#bsearch">bsearch</A>, <A HREF="#bsearch_s">bsearch_s</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__ 1</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><BR><TT>char *CharVect[] = { &quot;last&quot;, &quot;middle&quot;, &quot;first&quot; };</TT>
<BR><BR><TT>int compare( const void *op1, const void *op2, void *context )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; const char **p1 = (const char **) op1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; const char **p2 = (const char **) op2;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; return( strcmp( *p1, *p2 ) );</TT>
<BR><TT>}</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; void * context = NULL;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; qsort_s( CharVect, sizeof(CharVect)/sizeof(char *),</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sizeof(char *), compare, context );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s %s %s\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CharVect[0], CharVect[1], CharVect[2] );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>first last middle</TT>
</DL>
<DL>
<DT>Classification:
<DD>TR 24731
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="raise"> raise </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;signal.h&gt;</TT>
<BR><TT>int raise( int condition );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> raise</TT> function signals the exceptional condition indicated by the<B> condition</B> argument.&nbsp; The possible
conditions are defined in the<TT> &lt;signal.h&gt;</TT> header file and are documented with the <TT> signal</TT> function.
&nbsp;The <TT> signal</TT> function can be used to specify the action which is to take place when such a condition occurs.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> raise</TT> function returns zero when the condition is successfully raised and a non-zero value otherwise.&nbsp; There
may be no return of control following the function call if the action for that condition is to terminate the program or to
transfer control using the <TT> longjmp</TT> function.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#signal">signal</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>/*</TT>
<BR><TT> * This program waits until a SIGINT signal</TT>
<BR><TT> * is received.</TT>
<BR><TT> */</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;signal.h&gt;</TT>
<BR><BR><TT>sig_atomic_t signal_count;</TT>
<BR><TT>sig_atomic_t signal_number;</TT>
<BR><BR><TT>static void alarm_handler( int signum )</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ++signal_count;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; signal_number = signum;</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned long i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; signal_count = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; signal_number = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; signal( SIGINT, alarm_handler );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; printf(&quot;Signal will be auto-raised on iteration &quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;10000 or hit CTRL-C.\n&quot;);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf(&quot;Iteration:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; 100000; ++i )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;\b\b\b\b\b%*d&quot;, 5, i);</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( i == 10000 ) raise(SIGINT);</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( signal_count &gt; 0 ) break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; if( i == 100000 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;\nNo signal was raised.\n&quot;);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; } else if( i == 10000 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;\nSignal %d was raised by the &quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;raise() function.\n&quot;, signal_number);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;\nUser raised the signal.\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signal_number);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="rand"> rand </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>int rand( void );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> rand</TT> function computes a sequence of pseudo-random integers in the range 0 to <TT> RAND_MAX</TT> (32767).&nbsp;
The sequence can be started at different values by calling the <TT> srand</TT> function.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> rand</TT> function returns a pseudo-random integer.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#srand">srand</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; for( i=1; i &lt; 10; ++i ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, rand() );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="read"> read, _read </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;io.h&gt;</TT>
<BR><TT>int read( int handle, void *buffer, unsigned len );</TT>
<BR><TT>int _read( int handle, void *buffer, unsigned len );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> read</TT> function reads data at the operating system level.&nbsp; The number of bytes transmitted is given by<B>
len</B> and the data is transmitted starting at the address specified by<B> buffer</B>.
<BR><BR>The<B> handle</B> value is returned by the <TT> open</TT> function.&nbsp; The access mode must have included either
<TT> O_RDONLY</TT> or <TT> O_RDWR</TT> when the <TT> open</TT> function was invoked.&nbsp; The data is read starting at the
current file position for the file in question.&nbsp; This file position can be determined with the <TT> tell</TT> function
and can be set with the <TT> lseek</TT> function.
<BR><BR>When <TT> O_BINARY</TT> is included in the access mode, the data is transmitted unchanged.&nbsp; When <TT> O_TEXT</TT>
is included in the access mode, the data is transmitted with the extra carriage return character removed before each linefeed
character encountered in the original data.
<BR><BR>The<TT> _read</TT> function is identical to<TT> read</TT>.&nbsp; Use<TT> _read</TT> for ANSI naming conventions.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> read</TT> function returns the number of bytes of data transmitted from the file to the buffer (this does not include
any carriage-return characters that were removed during the transmission).&nbsp; Normally, this is the number given by the<B>
len</B> argument.&nbsp; When the end of the file is encountered before the read completes, the return value will be less than
the number of bytes requested.
<BR><BR>A value of -1 is returned when an input/output error is detected.&nbsp; When an error has occurred, <TT> errno</TT>
contains a value indicating the type of error that has been detected.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#close">close</A>, <A HREF="#creat">creat</A>, <A HREF="#fread">fread</A>, <A HREF="#open">open</A>, <A HREF="#write">write</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;fcntl.h&gt;</TT>
<BR><TT>#include &lt;io.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp; handle;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp; size_read;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char buffer[80];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; /* open a file for input&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; handle = open( &quot;file&quot;, O_RDONLY | O_TEXT );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( handle != -1 ) {</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* read the text&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_read = read( handle, buffer,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sizeof( buffer ) );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* test for error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( size_read == -1 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Error reading file\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* close the file&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close( handle );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>POSIX 1003.1
<BR><BR>_read conforms to ANSI naming conventions
</DL>
<DL>
<DT>Systems:
<DD><TT> read - All, RDOS, Netware</TT>
<BR><BR><TT>_read - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="readdir"> readdir, _wreaddir </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;direct.h&gt;</TT>
<BR><TT>struct dirent *readdir( DIR *dirp );</TT>
<BR><TT>struct _wdirent *_wreaddir( WDIR *dirp );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> readdir</TT> function obtains information about the next matching file name from the argument<B> dirp</B>.&nbsp; The
argument<B> dirp</B> is the value returned from the <TT> opendir</TT> function.&nbsp; The<TT> readdir</TT> function can be
called repeatedly to obtain the list of file names contained in the directory specified by the pathname given to <TT> opendir</TT>.
&nbsp;The function <TT> closedir</TT> must be called to close the directory and free the memory allocated by <TT> opendir</TT>.
<BR><BR>The file<TT> &lt;direct.h&gt;</TT> contains definitions for the structure <TT> dirent</TT>.
<BR><BR><TT>#if defined(__OS2__) || defined(__NT__)</TT>
<BR><TT>#define NAME_MAX 255&nbsp;&nbsp;&nbsp; /* maximum for HPFS or NTFS */</TT>
<BR><TT>#else</TT>
<BR><TT>#define NAME_MAX&nbsp; 12&nbsp;&nbsp;&nbsp; /* 8 chars + '.' +&nbsp; 3 chars */</TT>
<BR><TT>#endif</TT>
<BR><BR><TT>struct dirent {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; d_dta[ 21 ];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* disk transfer
area */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; d_attr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;/* file's attribute */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned short int d_time;&nbsp; /* file's time */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned short int d_date;&nbsp; /* file's date */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; long&nbsp;&nbsp;&nbsp; d_size;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;/* file's size */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; d_name[ NAME_MAX + 1 ]; /* file's name */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned short d_ino;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* serial number */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; d_first;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* flag for 1st time */</TT>
<BR><TT>};</TT>
<BR>The file attribute field <TT> d_attr</TT> field is a set of bits representing the following attributes.
<BR><BR><TT>_A_RDONLY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Read-only file */</TT>
<BR><TT>_A_HIDDEN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Hidden file */</TT>
<BR><TT>_A_SYSTEM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* System file */</TT>
<BR><TT>_A_VOLID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Volume-ID entry (only MSFT knows) */</TT>
<BR><TT>_A_SUBDIR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Subdirectory */</TT>
<BR><TT>_A_ARCH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Archive file */</TT>
<BR>If the<TT> _A_RDONLY</TT> bit is off, then the file is read/write.
<BR><BR>The format of the <TT> d_time</TT> field is described by the following structure (this structure is not defined in
any Open Watcom header file).
<BR><BR><TT>typedef struct {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; twosecs : 5;&nbsp;&nbsp;&nbsp; /* seconds / 2 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; minutes : 6;&nbsp;&nbsp;&nbsp; /* minutes (0,59) */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; hours&nbsp;&nbsp; : 5;&nbsp;&nbsp;&nbsp; /* hours (0,23) */</TT>
<BR><TT>} ftime_t;</TT>
<BR>The format of the <TT> d_date</TT> field is described by the following structure (this structure is not defined in any
Open Watcom header file).
<BR><BR><TT>typedef struct {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; day&nbsp;&nbsp;&nbsp;&nbsp; : 5;&nbsp;&nbsp;&nbsp; /* day (1,31) */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; month&nbsp;&nbsp; : 4;&nbsp;&nbsp;&nbsp; /* month (1,12) */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; year&nbsp;&nbsp;&nbsp; : 7;&nbsp;&nbsp;&nbsp; /* 0 is 1980 */</TT>
<BR><TT>} fdate_t;</TT>
<BR>See the sample program below for an example of the use of these structures.
<BR><BR>The<TT> _wreaddir</TT> function is identical to<TT> readdir</TT> except that it reads a directory of wide-character
filenames.
<BR><BR>The file<TT> &lt;direct.h&gt;</TT> contains definitions for the structure <TT> _wdirent</TT>.
<BR><BR><TT>struct _wdirent {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; d_dta[21];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* disk transfer area */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; d_attr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* file's attribute
*/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned short int d_time;/* file's time */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned short int d_date;/* file's date */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; long&nbsp;&nbsp;&nbsp; d_size;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* file's size */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; wchar_t d_name[NAME_MAX+1];/* file's name */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned short d_ino;&nbsp;&nbsp; /* serial number (not used) */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; d_first;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* flag for 1st time
*/</TT>
<BR><TT>};</TT>
</DL>
<DL>
<DT>Returns:
<DD>When successful,<TT> readdir</TT> returns a pointer to an object of type<B> struct dirent.</B>&nbsp; When an error occurs,<TT>
readdir</TT> returns the value<TT> NULL</TT> and <TT> errno</TT> is set to indicate the error.&nbsp; When the end of the directory
is encountered,<TT> readdir</TT> returns the value<TT> NULL</TT> and <TT> errno</TT> is unchanged.
<BR><BR>When successful,<TT> _wreaddir</TT> returns a pointer to an object of type<B> struct _wdirent.</B>&nbsp; When an error
occurs,<TT> _wreaddir</TT> returns the value<TT> NULL</TT> and <TT> errno</TT> is set to indicate the error.&nbsp; When the
end of the directory is encountered,<TT> _wreaddir</TT> returns the value<TT> NULL</TT> and <TT> errno</TT> is unchanged.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
<DL>
<DT>EBADF
<DD>The argument<B> dirp</B> does not refer to an open directory stream.
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#closedir">closedir</A>, <A HREF="#_dos_find___">_dos_find...</A>, <A HREF="#opendir">opendir</A>, <A HREF="#rewinddir">rewinddir</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR>To get a list of files contained in the directory<TT> \watcom\h</TT> on your default disk:
<BR><BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;direct.h&gt;</TT>
<BR><BR><TT>typedef struct {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; twosecs : 5;&nbsp;&nbsp;&nbsp; /* seconds / 2 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; minutes : 6;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; hours&nbsp;&nbsp; : 5;</TT>
<BR><TT>} ftime_t;</TT>
<BR><BR><TT>typedef struct {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; day&nbsp;&nbsp;&nbsp;&nbsp; : 5;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; month&nbsp;&nbsp; : 4;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; year&nbsp;&nbsp;&nbsp; : 7;</TT>
<BR><TT>} fdate_t;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; DIR *dirp;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct dirent *direntp;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ftime_t *f_time;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fdate_t *f_date;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; dirp = opendir( &quot;\\watcom\\h&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( dirp != NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(;;) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; direntp = readdir( dirp );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( direntp == NULL ) break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f_time = (ftime_t *)&amp;direntp-&gt;d_time;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f_date = (fdate_t *)&amp;direntp-&gt;d_date;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%-12s %d/%2.2d/%2.2d &quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;%2.2d:%2.2d:%2.2d
\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; direntp-&gt;d_name,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f_date-&gt;year + 1980,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f_date-&gt;month,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f_date-&gt;day,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f_time-&gt;hours,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f_time-&gt;minutes,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f_time-&gt;twosecs * 2 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; closedir( dirp );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>Note the use of two adjacent backslash characters (\) within character-string constants to signify a single backslash.
</DL>
<DL>
<DT>Classification:
<DD>POSIX 1003.1
<BR><BR>_wreaddir is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> readdir - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_wreaddir - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</TT>
</DL>
<H2 ID="realloc"> realloc Functions </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;&nbsp; For ISO C compatibility (realloc only)</TT>
<BR><TT>#include &lt;malloc.h&gt;&nbsp; Required for other function prototypes</TT>
<BR><TT>void * realloc( void *old_blk, size_t size );</TT>
<BR><TT>void __based(void) *_brealloc( __segment seg,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void __based(void) *old_blk,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t size );</TT>
<BR><TT>void __far&nbsp; *_frealloc( void __far&nbsp; *old_blk,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t size );</TT>
<BR><TT>void __near *_nrealloc( void __near *old_blk,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t size );</TT>
</DL>
<DL>
<DT>Description:
<DD>When the value of the<B> old_blk</B> argument is<TT> NULL,</TT> a new block of memory of<B> size</B> bytes is allocated.
<BR><BR>If the value of<B> size</B> is zero, the corresponding <TT> free</TT> function is called to release the memory pointed
to by<B> old_blk</B>.
<BR><BR>Otherwise, the<TT> realloc</TT> function re-allocates space for an object of<B> size</B> bytes by either:
<UL>
<LI>shrinking the allocated size of the allocated memory block<B> old_blk</B> when<B> size</B> is sufficiently smaller than
the size of<B> old_blk</B>.
<LI>extending the allocated size of the allocated memory block<B> old_blk</B> if there is a large enough block of unallocated
memory immediately following<B> old_blk</B>.
<LI>allocating a new block and copying the contents of<B> old_blk</B> to the new block.
</UL>
<BR>Because it is possible that a new block will be allocated, any pointers into the old memory should not be maintained.
&nbsp;These pointers will point to freed memory, with possible disastrous results, when a new block is allocated.
<BR><BR>The function returns<TT> NULL</TT> when the memory pointed to by<B> old_blk</B> cannot be re-allocated.&nbsp; In this
case, the memory pointed to by<B> old_blk</B> is not freed so care should be exercised to maintain a pointer to the old memory
block.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; buffer = (char *) realloc( buffer, 100 );</TT>
<BR><BR>In the above example,<TT> buffer</TT> will be set to<TT> NULL</TT> if the function fails and will no longer point
to the old memory block.&nbsp; If<TT> buffer</TT> was your only pointer to the memory block then you will have lost access
to this memory.
<BR><BR>Each function reallocates memory from a particular heap, as listed below:
<DL>
<DT>Function&nbsp;&nbsp;&nbsp;&nbsp; Heap
<DT>realloc
<DD>Depends on data model of the program
<DT>_brealloc
<DD>Based heap specified by<B> seg</B> value
<DT>_frealloc
<DD>Far heap (outside the default data segment)
<DT>_nrealloc
<DD>Near heap (inside the default data segment)
</DL>
<BR>In a small data memory model, the<TT> realloc</TT> function is equivalent to the <TT> _nrealloc</TT> function; in a large
data memory model, the<TT> realloc</TT> function is equivalent to the <TT> _frealloc</TT> function.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> realloc</TT> functions return a pointer to the start of the re-allocated memory.&nbsp; The return value is<TT> NULL</TT>
if there is insufficient memory available or if the value of the<B> size</B> argument is zero.&nbsp; The <TT> _brealloc</TT>
function returns <TT> _NULLOFF</TT> if there is insufficient memory available or if the requested size is zero.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#calloc">calloc</A> Functions, <A HREF="#_expand">_expand</A> Functions, <A HREF="#free">free</A> Functions, <A HREF="#halloc">halloc</A>,
<A HREF="#hfree">hfree</A>, <A HREF="#malloc">malloc</A> Functions, <A HREF="#_msize">_msize</A> Functions, <A HREF="#sbrk">sbrk</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>#include &lt;malloc.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char *buffer;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char *new_buffer;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; buffer = (char *) malloc( 80 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; new_buffer = (char *) realloc( buffer, 100 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( new_buffer == NULL ) {</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* not able to allocate larger buffer */</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buffer = new_buffer;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>_brealloc is WATCOM
<BR>_frealloc is WATCOM
<BR>_nrealloc is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> realloc - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_brealloc - DOS/16, Windows, OS/2 1.x(all)</TT>
<BR><TT>_frealloc - DOS/16, Windows, OS/2 1.x(all)</TT>
<BR><TT>_nrealloc - DOS, Windows, Win386, Win32, OS/2 1.x, OS/2 1.x(MT), OS/2-32, Linux, RDOS</TT>
</DL>
<H2 ID="_rectangle"> _rectangle, _rectangle_w, _rectangle_wxy </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>short _FAR _rectangle( short fill,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; short x1, short y1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; short x2, short y2 );</TT>
<BR><BR><TT>short _FAR _rectangle_w( short fill,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; double x1, double y1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; double x2, double y2 );</TT>
<BR><BR><TT>short _FAR _rectangle_wxy( short fill,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct _wxycoord _FAR *p1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct _wxycoord _FAR *p2 );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _rectangle</TT> functions draw rectangles.&nbsp; The<TT> _rectangle</TT> function uses the view coordinate system.
&nbsp;The<TT> _rectangle_w</TT> and<TT> _rectangle_wxy</TT> functions use the window coordinate system.
<BR><BR>The rectangle is defined with opposite corners established by the points<TT> (x1,y1)</TT> and<TT> (x2,y2).</TT>
<BR><BR>The argument<B> fill</B> determines whether the rectangle is filled in or has only its outline drawn.&nbsp; The argument
can have one of two values:
<DL>
<DT>_GFILLINTERIOR
<DD>fill the interior by writing pixels with the current plot action using the current color and the current fill mask
<DT>_GBORDER
<DD>leave the interior unchanged; draw the outline of the figure with the current plot action using the current color and line
style
</DL>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _rectangle</TT> functions return a non-zero value when the rectangle was successfully drawn; otherwise, zero is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_setcolor">_setcolor</A>, <A HREF="#_setfillmask">_setfillmask</A>, <A HREF="#_setlinestyle">_setlinestyle</A>,
<A HREF="#_setplotaction">_setplotaction</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _rectangle( _GBORDER, 100, 100, 540, 380 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><IMG SRC="eg_rect.bmp" ALIGN=MIDDLE>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD><TT> _rectangle - DOS</TT>
<BR><BR><TT>_rectangle_w - DOS</TT>
<BR><TT>_rectangle_wxy - DOS</TT>
</DL>
<H2 ID="_registerfonts"> _registerfonts </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>short _FAR _registerfonts( char _FAR *path );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _registerfonts</TT> function initializes the font graphics system.&nbsp; Fonts must be registered, and a font selected,
before text can be displayed with the <TT> _outgtext</TT> function.
<BR><BR>The argument<B> path</B> specifies the location of the font files.&nbsp; This argument is a file specification, and
can contain drive and directory components and may contain wildcard characters.&nbsp; The<TT> _registerfonts</TT> function
opens each of the font files specified and reads the font information.&nbsp; Memory is allocated to store the characteristics
of the font.&nbsp; These font characteristics are used by the <TT> _setfont</TT> function when selecting a font.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _registerfonts</TT> function returns the number of fonts that were registered if the function is successful; otherwise,
a negative number is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_unregisterfonts">_unregisterfonts</A>, <A HREF="#_setfont">_setfont</A>, <A HREF="#_getfontinfo">_getfontinfo</A>,
<A HREF="#_outgtext">_outgtext</A>, <A HREF="#_getgtextextent">_getgtextextent</A>, <A HREF="#_setgtextvector">_setgtextvector</A>,
<A HREF="#_getgtextvector">_getgtextvector</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int i, n;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char buf[ 10 ];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; n = _registerfonts( &quot;*.fon&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; n; ++i ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf( buf, &quot;n%d&quot;, i );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _setfont( buf );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _moveto( 100, 100 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _outgtext( &quot;WATCOM Graphics&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _clearscreen( _GCLEARSCREEN );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _unregisterfonts();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="remainder"> remainder </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>double remainder( double x, double y );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> remainder</TT> function computes remainder of the division of<B> x</B> by<B> y</B>.
</DL>
<DL>
<DT>Returns:
<DD>The remainder of the division of<B> x</B> by<B> y</B>.
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, remainder( 7.0, 2.0 ) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>1.00000</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C99
</DL>
<DL>
<DT>Systems:
<DD>Math
</DL>
<H2 ID="_remapallpalette"> _remapallpalette </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>short _FAR _remapallpalette( long _FAR *colors );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _remapallpalette</TT> function sets (or remaps) all of the colors in the palette.&nbsp; The color values in the palette
are replaced by the array of color values given by the argument<B> colors</B>.&nbsp; This function is supported in all video
modes, but only works with EGA, MCGA and VGA adapters.
<BR><BR>The array<B> colors</B> must contain at least as many elements as there are supported colors.&nbsp; The newly mapped
palette will cause the complete screen to change color wherever there is a pixel value of a changed color in the palette.
<BR><BR>The representation of colors depends upon the hardware being used.&nbsp; The number of colors in the palette can be
determined by using the <TT> _getvideoconfig</TT> function.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _remapallpalette</TT> function returns (-1) if the palette is remapped successfully and zero otherwise.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_remappalette">_remappalette</A>, <A HREF="#_getvideoconfig">_getvideoconfig</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><BR><TT>long colors[ 16 ] = {</TT>
<BR><TT>&nbsp;&nbsp; _BRIGHTWHITE, _YELLOW, _LIGHTMAGENTA, _LIGHTRED,</TT>
<BR><TT>&nbsp;&nbsp; _LIGHTCYAN, _LIGHTGREEN, _LIGHTBLUE, _GRAY, _WHITE,</TT>
<BR><TT>&nbsp;&nbsp; _BROWN, _MAGENTA, _RED, _CYAN, _GREEN, _BLUE, _BLACK,</TT>
<BR><TT>};</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int x, y;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( y = 0; y &lt; 4; ++y ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( x = 0; x &lt; 4; ++x ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _setcolor( x + 4 * y );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _rectangle( _GFILLINTERIOR,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
x * 160, y * 120,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
( x + 1 ) * 160, ( y + 1 ) * 120 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _remapallpalette( colors );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_remappalette"> _remappalette </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>long _FAR _remappalette( short pixval, long color );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _remappalette</TT> function sets (or remaps) the palette color<B> pixval</B> to be the color<B> color</B>.&nbsp; This
function is supported in all video modes, but only works with EGA, MCGA and VGA adapters.
<BR><BR>The argument<B> pixval</B> is an index in the color palette of the current video mode.&nbsp; The argument<B> color</B>
specifies the actual color displayed on the screen by pixels with pixel value<B> pixval</B>.&nbsp; Color values are selected
by specifying the red, green and blue intensities that make up the color.&nbsp; Each intensity can be in the range from 0
to 63, resulting in 262144 possible different colors.&nbsp; A given color value can be conveniently specified as a value of
type<TT> long.</TT>&nbsp; The color value is of the form<TT> 0x00bbggrr,</TT> where<TT> bb</TT> is the blue intensity,<TT>
gg</TT> is the green intensity and<TT> rr</TT> is the red intensity of the selected color.&nbsp; The file<TT> graph.h</TT>
defines constants containing the color intensities of each of the 16 default colors.
<BR><BR>The<TT> _remappalette</TT> function takes effect immediately.&nbsp; All pixels on the complete screen which have a
pixel value equal to the value of<B> pixval</B> will now have the color indicated by the argument<B> color</B>.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _remappalette</TT> function returns the previous color for the pixel value if the palette is remapped successfully;
otherwise, (-1) is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_remapallpalette">_remapallpalette</A>, <A HREF="#_setvideomode">_setvideomode</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><BR><TT>long colors[ 16 ] = {</TT>
<BR><TT>&nbsp;&nbsp; _BLACK, _BLUE, _GREEN, _CYAN,</TT>
<BR><TT>&nbsp;&nbsp; _RED, _MAGENTA, _BROWN, _WHITE,</TT>
<BR><TT>&nbsp;&nbsp; _GRAY, _LIGHTBLUE, _LIGHTGREEN, _LIGHTCYAN,</TT>
<BR><TT>&nbsp;&nbsp; _LIGHTRED, _LIGHTMAGENTA, _YELLOW, _BRIGHTWHITE</TT>
<BR><TT>};</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int col;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( col = 0; col &lt; 16; ++col ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _remappalette( 0, colors[ col ] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="remove"> remove, _wremove </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>int remove( const char *filename );</TT>
<BR><TT>int _wremove( const wchar_t *filename );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> remove</TT> function deletes the file whose name is the string pointed to by<B> filename</B>.
<BR><BR>The<TT> _wremove</TT> function is a wide-character version of<TT> remove</TT> that operates with wide-character strings.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> remove</TT> function returns zero if the operation succeeds, non-zero if it fails.&nbsp; When an error has occurred,
<TT> errno</TT> contains a value indicating the type of error that has been detected.
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; remove( &quot;vm.tmp&quot; );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>_wremove is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> remove - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_wremove - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</TT>
</DL>
<H2 ID="rename"> rename, _wrename </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>int rename( const char *old, const char *new );</TT>
<BR><TT>int _wrename( const wchar_t *old, const wchar_t *new );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> rename</TT> function causes the file whose name is indicated by the string<B> old</B> to be renamed to the name given
by the string<B> new</B>.
<BR><BR>The<TT> _wrename</TT> function is a wide-character version of<TT> rename</TT> that operates with wide-character strings.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> rename</TT> function returns zero if the operation succeeds, a non-zero value if it fails.&nbsp; When an error has
occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; rename( &quot;old.dat&quot;, &quot;new.dat&quot; );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>_wrename is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> rename - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_wrename - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</TT>
</DL>
<H2 ID="rewind"> rewind </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>void rewind( FILE *fp );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> rewind</TT> function sets the file position indicator for the stream indicated to by<B> fp</B> to the beginning of
the file.&nbsp; It is equivalent to
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fseek( fp, 0L, SEEK_SET );</TT>
<BR><BR>except that the error indicator for the stream is cleared.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> rewind</TT> function returns no value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#fopen">fopen</A>, <A HREF="#clearerr">clearerr</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>static assemble_pass( int passno )</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Pass %d\n&quot;, passno );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FILE *fp;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; if( (fp = fopen( &quot;program.asm&quot;, &quot;r&quot;)) != NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assemble_pass( 1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rewind( fp );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assemble_pass( 2 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( fp );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="rewinddir"> rewinddir, _wrewinddir </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;sys/types.h&gt;</TT>
<BR><TT>#include &lt;direct.h&gt;</TT>
<BR><TT>void rewinddir( DIR *dirp );</TT>
<BR><TT>void _wrewinddir( WDIR *dirp );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> rewinddir</TT> function resets the position of the directory stream to which<B> dirp</B> refers to the beginning of
the directory.&nbsp; It also causes the directory stream to refer to the current state of the corresponding directory, as
a call to <TT> opendir</TT> would have done.
<BR><BR>The<TT> _wrewinddir</TT> function is identical to<TT> rewinddir</TT> except that it rewinds a directory of wide-character
filenames opened by <TT> _wopendir</TT>.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> rewinddir</TT> function does not return a value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#closedir">closedir</A>, <A HREF="#_dos_find___">_dos_find...</A>, <A HREF="#opendir">opendir</A>, <A HREF="#readdir">readdir</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR>The following example lists all the files in a directory, creates a new file, and then relists the directory.
<BR><BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;sys/types.h&gt;</TT>
<BR><TT>#include &lt;sys/stat.h&gt;</TT>
<BR><TT>#include &lt;direct.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; DIR *dirp;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct dirent *direntp;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int handle;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; dirp = opendir( &quot;\\watcom\\h\\*.*&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( dirp != NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Old directory listing\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(;;) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; direntp = readdir( dirp );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( direntp == NULL )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, direntp-&gt;d_name );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handle = creat( &quot;\\watcom\\h\\file.new&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close( handle );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rewinddir( dirp );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;New directory listing\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(;;) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; direntp = readdir( dirp );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( direntp == NULL )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, direntp-&gt;d_name );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; closedir( dirp );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
<BR><BR>Note the use of two adjacent backslash characters (\) within character-string constants to signify a single backslash.
</DL>
<DL>
<DT>Classification:
<DD>POSIX 1003.1
<BR><BR>_wrewinddir is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> rewinddir - All, Linux, RDOS</TT>
<BR><BR><TT>_wrewinddir - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</TT>
</DL>
<H2 ID="rint"> rint </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>double rint( double x );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> rint</TT> function rounds the argument<B> x</B> to a nearby integer.&nbsp; The direction of the rounding is determined
by the current value of <TT> fegetround</TT>.&nbsp; If supported, this function will throw a floating point error if an overflow
occurs due to the current rounding mode.
</DL>
<DL>
<DT>Returns:
<DD>The rounded value of<B> x</B>.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#fegetround">fegetround</A>, <A HREF="#fesetround">fesetround</A>, <A HREF="#nearbyint">nearbyint</A>, <A HREF="#round">round</A>,
<A HREF="#trunc">trunc</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fesetround(FE_TONEAREST);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, rint( 1.2 ) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>1.000000</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C99
</DL>
<DL>
<DT>Systems:
<DD>Math
</DL>
<H2 ID="rmdir"> rmdir, _rmdir, _wrmdir </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;sys/types.h&gt;</TT>
<BR><TT>#include &lt;direct.h&gt;</TT>
<BR><TT>int rmdir( const char *path );</TT>
<BR><TT>int _rmdir( const char *path );</TT>
<BR><TT>int _wrmdir( const wchar_t *path );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> rmdir</TT> function removes (deletes) the specified directory.&nbsp; The directory must not contain any files or directories.
&nbsp;The<B> path</B> can be either relative to the current working directory or it can be an absolute path name.
<BR><BR>The<TT> _rmdir</TT> function is identical to<TT> rmdir</TT>.&nbsp; Use<TT> _rmdir</TT> for ANSI naming conventions.
<BR><BR>The<TT> _wrmdir</TT> function is a wide-character version of<TT> rmdir</TT> that operates with wide-character strings.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> rmdir</TT> function returns zero if successful and -1 otherwise.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#chdir">chdir</A>, <A HREF="#chmod">chmod</A>, <A HREF="#getcwd">getcwd</A>, <A HREF="#mkdir">mkdir</A>, <A HREF="#stat">stat</A>,
<A HREF="#umask">umask</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR>To remove the directory called<TT> \watcom</TT> on drive<TT> C:</TT>
<BR><BR><TT>#include &lt;sys/types.h&gt;</TT>
<BR><TT>#include &lt;direct.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; rmdir( &quot;c:\\watcom&quot; );</TT>
<BR><TT>}</TT>
<BR><BR>Note the use of two adjacent backslash characters (\) within character-string constants to signify a single backslash.
</DL>
<DL>
<DT>Classification:
<DD>POSIX 1003.1
<BR><BR>_rmdir conforms to ANSI naming conventions
<BR>_wrmdir is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> rmdir - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_rmdir - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
<BR><TT>_wrmdir - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</TT>
</DL>
<H2 ID="_rotl"> _rotl </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>unsigned int _rotl( unsigned int value,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
unsigned int shift );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _rotl</TT> function rotates the unsigned integer, determined by<B> value</B>, to the left by the number of bits specified
in<B> shift</B>.&nbsp; If you port an application using<TT> _rotl</TT> between a 16-bit and a 32-bit environment, you will
get different results because of the difference in the size of integers.
</DL>
<DL>
<DT>Returns:
<DD>The rotated value is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_lrotl">_lrotl</A>, <A HREF="#_lrotr">_lrotr</A>, <A HREF="#_rotr">_rotr</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>unsigned int mask = 0x0F00;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; mask = _rotl( mask, 4 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%04X\n&quot;, mask );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>F000</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="_rotr"> _rotr </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>unsigned int _rotr( unsigned int value,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
unsigned int shift );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _rotr</TT> function rotates the unsigned integer, determined by<B> value</B>, to the right by the number of bits specified
in<B> shift</B>.&nbsp; If you port an application using<TT> _rotr</TT> between a 16-bit and a 32-bit environment, you will
get different results because of the difference in the size of integers.
</DL>
<DL>
<DT>Returns:
<DD>The rotated value is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_lrotl">_lrotl</A>, <A HREF="#_lrotr">_lrotr</A>, <A HREF="#_rotl">_rotl</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>unsigned int mask = 0x1230;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; mask = _rotr( mask, 4 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%04X\n&quot;, mask );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>0123</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="round"> round </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>double round( double x );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> round</TT> function rounds the argument<B> x</B> to the nearest integer.&nbsp; Values halfway between integers always
rounded away from zero.
</DL>
<DL>
<DT>Returns:
<DD>The rounded value of<B> x</B>.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#nearbyint">nearbyint</A>, <A HREF="#rint">rint</A>, <A HREF="#trunc">trunc</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, round( 1.5 ) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>2.000000</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C99
</DL>
<DL>
<DT>Systems:
<DD>Math
</DL>
<H2 ID="sbrk"> sbrk </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>int brk( void __near *addr );</TT>
<BR><TT>void __near *sbrk( int increment );</TT>
</DL>
<DL>
<DT>Description:
<DD>Change data segment size, the &quot;break&quot; value.&nbsp; Under 16-bit DOS, Phar Lap's 386|DOS-Extender and Linux, the
data segment is grown contiguously.&nbsp; Under other systems, heap allocation is discontiguous.&nbsp; The &quot;break&quot;
value is the address of the first byte of unallocated memory.&nbsp; When a program starts execution, the break value is placed
following the code and constant data for the program.&nbsp; As memory is allocated, this pointer will advance when there is
no freed block large enough to satisfy an allocation request.&nbsp; The<TT> sbrk</TT> function can be used to set a new &quot;break&quot;
value for the program by adding the value of<B> increment</B> to the current break value.&nbsp; This increment may be positive
or negative.
<BR><BR>Under other systems, heap allocation is discontiguous.&nbsp; The<TT> sbrk</TT> function can only be used to allocate
additional discontiguous blocks of memory.&nbsp; The value of<B> increment</B> is used to determine the minimum size of the
block to be allocated and may not be zero or negative.&nbsp; The actual size of the block that is allocated is rounded up
to a multiple of 4K.
<BR><BR>The variable <TT> _amblksiz</TT> defined in<TT> &lt;stdlib.h&gt;</TT> contains the default increment by which the
&quot;break&quot; pointer for memory allocation will be advanced when there is no freed block large enough to satisfy a request
to allocate a block of memory.&nbsp; This value may be changed by a program at any time.
<BR><BR>Under 16-bit DOS, a new process started with one of the <TT> spawn...</TT>&nbsp; or <TT> exec...</TT>&nbsp; functions
is loaded following the break value.&nbsp; Consequently, decreasing the break value leaves more space available to the new
process.&nbsp; Similarly, for a resident program (a program which remains in memory while another program executes), increasing
the break value will leave more space available to be allocated by the resident program after other programs are loaded.
</DL>
<DL>
<DT>Returns:
<DD>If the call to<TT> sbrk</TT> succeeds, a pointer to the start of the new block of memory is returned.&nbsp; Under 16-bit DOS,
this corresponds to the old break value.&nbsp; If the call to<TT> sbrk</TT> fails, -1 is returned.&nbsp; When an error has
occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#calloc">calloc</A> Functions, <A HREF="#_expand">_expand</A> Functions, <A HREF="#free">free</A> Functions, <A HREF="#halloc">halloc</A>,
<A HREF="#hfree">hfree</A>, <A HREF="#malloc">malloc</A> Functions, <A HREF="#_msize">_msize</A> Functions, <A HREF="#realloc">realloc</A>
Functions
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>#if defined(M_I86)</TT>
<BR><TT>#define alloc( x, y ) sbrk( x ); y = sbrk( 0 );</TT>
<BR><TT>#else</TT>
<BR><TT>#define alloc( x, y ) y = sbrk( x );</TT>
<BR><TT>#endif</TT>
<BR><BR><TT>void main()</TT>
<BR><TT> {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; void *brk;</TT>
<BR><BR><TT>#if defined(M_I86)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; alloc( 0x0000, brk );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* calling printf will cause an allocation */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Original break value %p\n&quot;, brk );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Current amblksiz value %x\n&quot;, _amblksiz );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; alloc( 0x0000, brk );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;New break value after printf \t\t%p\n&quot;, brk );</TT>
<BR><TT>#endif</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; alloc( 0x3100, brk );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;New break value after sbrk( 0x3100 ) \t%p\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; brk );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; alloc( 0x0200, brk );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;New break value after sbrk( 0x0200 ) \t%p\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; brk );</TT>
<BR><TT>#if defined(M_I86)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; alloc( -0x0100, brk );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;New break value after sbrk( -0x0100 ) \t%p\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; brk );</TT>
<BR><TT>#endif</TT>
<BR><TT> }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Win32, OS/2 1.x, OS/2 1.x(MT), OS/2-32, Linux, RDOS
</DL>
<H2 ID="scalbn"> scalbn </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>double scalbn( double x, int y );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> scalbn</TT> function computes<B> x</B> *(2**<B> y</B> ) via exponent manipulation.
<BR><BR><TT>fmax( x - y, 0.0 );</TT>
</DL>
<DL>
<DT>Returns:
<DD>The value of<B> x</B> times two raised to<B> y</B>.
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, scalbn( 1.0, 3.0 ) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>8.000000</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C99
</DL>
<DL>
<DT>Systems:
<DD>Math
</DL>
<H2 ID="scanf"> scanf, wscanf </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>int scanf( const char *format, ... );</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>int wscanf( const wchar_t *format, ... );</TT>
</DL>
<DL>
<DT>Safer C:
<DD>The Safer C Library extension provides the <A HREF="#scanf_s">scanf_s</A> function which is a safer alternative to<TT> scanf</TT>
This newer<TT> scanf_s</TT> function is recommended to be used instead of the traditional &quot;unsafe&quot;<TT> scanf</TT>
function.
</DL>
<DL>
<DT>Description:
<DD>The<TT> scanf</TT> function scans input from the file designated by <TT> stdin</TT> under control of the argument<B> format</B>.
&nbsp;The<B> format</B> string is described below.&nbsp; Following the format string is the list of addresses of items to
receive values.
<BR><BR>The<TT> wscanf</TT> function is identical to<TT> scanf</TT> except that it accepts a wide-character string argument
for<B> format</B>.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> scanf</TT> function returns <TT> EOF</TT> if an input failure occured before any conversion.&nbsp; Otherwise, the
number of input arguments for which values were successfully scanned and stored is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#cscanf">cscanf</A>, <A HREF="#fscanf">fscanf</A>, <A HREF="#sscanf">sscanf</A>, <A HREF="#vcscanf">vcscanf</A>,
<A HREF="#vfscanf">vfscanf</A>, <A HREF="#vscanf">vscanf</A>, <A HREF="#vsscanf">vsscanf</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR>To scan a date in the form &quot;Saturday April 18 1987&quot;:
<BR><BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int day, year;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char weekday[10], month[10];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; scanf( &quot;%s %s %d %d&quot;, weekday, month, &amp;day, &amp;year );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Format Control String:
<DD>The format control string consists of zero or more<B> format directives</B> that specify acceptable input file data.&nbsp;
Subsequent arguments are pointers to various types of objects that are assigned values as the format string is processed.
<BR><BR>A format directive can be a sequence of one or more white-space characters, an<B> ordinary character,</B> or a<B>
conversion specifier.</B>&nbsp; An ordinary character in the format string is any character, other than a white-space character
or the percent character (%), that is not part of a conversion specifier.&nbsp; A conversion specifier is a sequence of characters
in the format string that begins with a percent character (%) and is followed, in sequence, by the following:
<UL>
<LI>an optional assignment suppression indicator:&nbsp; the asterisk character (*);
<LI>an optional decimal integer that specifies the<B> maximum field width</B> to be scanned for the conversion;
<LI>an optional<B> pointer-type</B> specification:&nbsp; one of &quot;N&quot; or &quot;W&quot;;
<LI>an optional<B> type length</B> specification:&nbsp; one of &quot;hh&quot;, &quot;h&quot;, &quot;l&quot;, &quot;ll&quot;,
&quot;j&quot;, &quot;z&quot;, &quot;t&quot;, &quot;L&quot; or &quot;I64&quot;;
<LI>a character that specifies the type of conversion to be performed:&nbsp; one of the characters &quot;cCdeEfFgGinopsSuxX[&quot;.
</UL>
<BR>As each format directive in the format string is processed, the directive may successfully complete, fail because of a
lack of input data, or fail because of a matching error as defined by the particular directive.&nbsp; If end-of-file is encountered
on the input data before any characters that match the current directive have been processed (other than leading white-space
where permitted), the directive fails for lack of data.&nbsp; If end-of-file occurs after a matching character has been processed,
the directive is completed (unless a matching error occurs), and the function returns without processing the next directive.
&nbsp;If a directive fails because of an input character mismatch, the character is left unread in the input stream.&nbsp;
Trailing white-space characters, including new-line characters, are not read unless matched by a directive.&nbsp; When a format
directive fails, or the end of the format string is encountered, the scanning is completed and the function returns.
<BR><BR>When one or more white-space characters (space &quot; &quot;, horizontal tab &quot;\t&quot;, vertical tab &quot;\v&quot;,
form feed &quot;\f&quot;, carriage return &quot;\r&quot;, new line or linefeed &quot;\n&quot;) occur in the format string,
input data up to the first non-white-space character is read, or until no more data remains.&nbsp; If no white-space characters
are found in the input data, the scanning is complete and the function returns.
<BR><BR>An ordinary character in the format string is expected to match the same character in the input stream.
<BR><BR>A conversion specifier in the format string is processed as follows:
<UL>
<LI>for conversion types other than &quot;[&quot;, &quot;c&quot;, &quot;C&quot; and &quot;n&quot;, leading white-space characters
are skipped
<LI>for conversion types other than &quot;n&quot;, all input characters, up to any specified maximum field length, that can
be matched by the conversion type are read and converted to the appropriate type of value; the character immediately following
the last character to be matched is left unread; if no characters are matched, the format directive fails
<LI>unless the assignment suppression indicator (&quot;*&quot;) was specified, the result of the conversion is assigned to
the object pointed to by the next unused argument (if assignment suppression was specified, no argument is skipped); the arguments
must correspond in number, type and order to the conversion specifiers in the format string
</UL>
<BR>A pointer-type specification is used to indicate the type of pointer used to locate the next argument to be scanned:
<DL>
<DT>W
<DD>pointer is a far pointer
<DT>N
<DD>pointer is a near pointer
</DL>
<BR>The pointer-type specification is only effective on platforms that use a segmented memory model, although it is always
recognized.
<BR><BR>The pointer type defaults to that used for data in the memory model for which the program has been compiled.
<BR><BR>A type length specifier affects the conversion as follows:
<UL>
<LI>&quot;hh&quot; causes a &quot;d&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot; or &quot;x&quot; (integer) conversion
to assign the converted value to an object of type<TT> signed char</TT> or<TT> unsigned char.</TT>
<LI>&quot;hh&quot; causes an &quot;n&quot; (read length assignment) operation to assign the number of characters that have
been read to an object of type<TT> signed char.</TT>
<LI>&quot;h&quot; causes a &quot;d&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot; or &quot;x&quot; (integer) conversion
to assign the converted value to an object of type<TT> short int</TT> or<TT> unsigned short int.</TT>
<LI>&quot;h&quot; causes an &quot;f&quot; conversion to assign a fixed-point number to an object of type<TT> long</TT> consisting
of a 16-bit signed integer part and a 16-bit unsigned fractional part.&nbsp; The integer part is in the high 16 bits and the
fractional part is in the low 16 bits.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct fixpt {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned short fraction; /* Intel architecture! */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signed short integral;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct fixpt foo1 =</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { 0x8000, 1234 }; /* represents 1234.5 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct fixpt foo2 =</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { 0x8000, -1 };&nbsp;&nbsp; /* represents -0.5 (-1+.5) */</TT>
<LI>&quot;h&quot; causes an &quot;n&quot; (read length assignment) operation to assign the number of characters that have
been read to an object of type<TT> short int.</TT>&nbsp; *.
<LI>&quot;h&quot; causes an &quot;s&quot; operation to convert the input string to an ASCII character string.&nbsp; For<TT>
scanf</TT> this specifier is redundant.&nbsp; For wscanf, this specifier is required if the wide character input string is
to be converted to an ASCII character string; otherwise it will not be converted.&nbsp; *.
<LI>&quot;l&quot; causes a &quot;d&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot; or &quot;x&quot; (integer) conversion
to assign the converted value to an object of type<TT> long int</TT> or<TT> unsigned long int.</TT>
<LI>&quot;l&quot; causes an &quot;n&quot; (read length assignment) operation to assign the number of characters that have
been read to an object of type<TT> long int.</TT>
<LI>&quot;l&quot; causes an &quot;e&quot;, &quot;f&quot; or &quot;g&quot; (floating-point) conversion to assign the converted
value to an object of type<TT> double.</TT>
<LI>&quot;l&quot; or &quot;w&quot; cause an &quot;s&quot; operation to convert the input string to a wide character string.
&nbsp;For<TT> scanf</TT> this specifier is required if the input ASCII string is to be converted to a wide character string;
otherwise it will not be converted.&nbsp; *.
<LI>&quot;ll&quot; causes a &quot;d&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot; or &quot;x&quot; (integer) conversion
to assign the converted value to an object of type<TT> long long</TT> or<TT> unsigned long long</TT> (e.g., %lld).
<LI>&quot;ll&quot; causes an &quot;n&quot; (read length assignment) operation to assign the number of characters that have
been read to an object of type<TT> long long int.</TT>
<LI>&quot;j&quot; causes a &quot;d&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot; or &quot;x&quot; (integer) conversion
to assign the converted value to an object of type<TT> intmax_t</TT> or<TT> uintmax_t.</TT>
<LI>&quot;j&quot; causes an &quot;n&quot; (read length assignment) operation to assign the number of characters that have
been read to an object of type<TT> intmax_t.</TT>
<LI>&quot;z&quot; causes a &quot;d&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot; or &quot;x&quot; (integer) conversion
to assign the converted value to an object of type<TT> size_t</TT> or the corresponding signed integer type.
<LI>&quot;z&quot; causes an &quot;n&quot; (read length assignment) operation to assign the number of characters that have
been read to an object of signed integer type corresponding to<TT> size_t.</TT>
<LI>&quot;t&quot; causes a &quot;d&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot; or &quot;x&quot; (integer) conversion
to assign the converted value to an object of type<TT> ptrdiff_t</TT> or the corresponding unsigned integer type.
<LI>&quot;t&quot; causes an &quot;n&quot; (read length assignment) operation to assign the number of characters that have
been read to an object of type<TT> ptrdiff_t.</TT>
<LI>&quot;I64&quot; causes a &quot;d&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot; or &quot;x&quot; (integer) conversion
to assign the converted value to an object of type<TT> __int64</TT> or<TT> unsigned __int64</TT> (e.g., %I64d).
<LI>&quot;L&quot; causes an &quot;e&quot;, &quot;f&quot; or &quot;g&quot; (floating-point) conversion to assign the converted
value to an object of type<TT> long double.</TT>
</UL>
<BR>The valid conversion type specifiers are:
<DL>
<DT>c
<DD>Any sequence of characters in the input stream of the length specified by the field width, or a single character if no field
width is specified, is matched.&nbsp; The argument is assumed to point to the first element of a character array of sufficient
size to contain the sequence, without a terminating null character ('\0').&nbsp; For a single character assignment, a pointer
to a single object of type<TT> char</TT> is sufficient.
<DT>C
<DD>A sequence of multibyte characters in the input stream is matched.&nbsp; Each multibyte character is converted to a wide character
of type<TT> wchar_t.</TT>&nbsp; The number of wide characters matched is specified by the field width (1 if no field width
is specified).&nbsp; The argument is assumed to point to the first element of an array of<TT> wchar_t</TT> of sufficient size
to contain the sequence.&nbsp; No terminating null wide character (L'\0') is added.&nbsp; For a single wide character assignment,
a pointer to a single object of type<TT> wchar_t</TT> is sufficient.
<DT>d
<DD>A decimal integer, consisting of an optional sign, followed by one or more decimal digits, is matched.&nbsp; The argument
is assumed to point to an object of type<TT> int.</TT>
<DT>e, f, g
<DD>A floating-point number, consisting of an optional sign (&quot;+&quot; or &quot;-&quot;), followed by one or more decimal
digits, optionally containing a decimal-point character, followed by an optional exponent of the form &quot;e&quot; or &quot;E&quot;,
an optional sign and one or more decimal digits, is matched.&nbsp; The exponent, if present, specifies the power of ten by
which the decimal fraction is multiplied.&nbsp; The argument is assumed to point to an object of type<TT> float.</TT>
<DT>i
<DD>An optional sign, followed by an octal, decimal or hexadecimal constant is matched.&nbsp; An octal constant consists of &quot;0&quot;
and zero or more octal digits.&nbsp; A decimal constant consists of a non-zero decimal digit and zero or more decimal digits.
&nbsp;A hexadecimal constant consists of the characters &quot;0x&quot; or &quot;0X&quot; followed by one or more (upper- or
lowercase) hexadecimal digits.&nbsp; The argument is assumed to point to an object of type<TT> int.</TT>
<DT>n
<DD>No input data is processed.&nbsp; Instead, the number of characters that have already been read is assigned to the object
of type<TT> unsigned int</TT> that is pointed to by the argument.&nbsp; The number of items that have been scanned and assigned
(the return value) is not affected by the &quot;n&quot; conversion type specifier.
<DT>o
<DD>An octal integer, consisting of an optional sign, followed by one or more (zero or non-zero) octal digits, is matched.&nbsp;
The argument is assumed to point to an object of type<TT> int.</TT>
<DT>p
<DD>A hexadecimal integer, as described for &quot;x&quot; conversions below, is matched.&nbsp; The converted value is further
converted to a value of type<TT> void*</TT> and then assigned to the object pointed to by the argument.
<DT>s
<DD>A sequence of non-white-space characters is matched.&nbsp; The argument is assumed to point to the first element of a character
array of sufficient size to contain the sequence and a terminating null character, which is added by the conversion operation.
<DT>S
<DD>A sequence of multibyte characters is matched.&nbsp; None of the multibyte characters in the sequence may be single byte white-space
characters.&nbsp; Each multibyte character is converted to a wide character.&nbsp; The argument is assumed to point to the
first element of an array of<TT> wchar_t</TT> of sufficient size to contain the sequence and a terminating null wide character,
which is added by the conversion operation.
<DT>u
<DD>An unsigned decimal integer, consisting of one or more decimal digits, is matched.&nbsp; The argument is assumed to point
to an object of type<TT> unsigned int.</TT>
<DT>x
<DD>A hexadecimal integer, consisting of an optional sign, followed by an optional prefix &quot;0x&quot; or &quot;0X&quot;, followed
by one or more (upper- or lowercase) hexadecimal digits, is matched.&nbsp; The argument is assumed to point to an object of
type<TT> int.</TT>
<DT>[c1c2...]
<DD>The longest, non-empty sequence of characters, consisting of any of the characters<TT> c1, c2, ...</TT>&nbsp; called the<B>
scanset,</B> in any order, is matched.<TT>&nbsp; c1</TT> cannot be the caret character ('^').&nbsp; If<TT> c1</TT> is &quot;]&quot;,
that character is considered to be part of the scanset and a second &quot;]&quot; is required to end the format directive.
&nbsp;The argument is assumed to point to the first element of a character array of sufficient size to contain the sequence
and a terminating null character, which is added by the conversion operation.
<DT>[^c1c2...]
<DD>The longest, non-empty sequence of characters, consisting of any characters<B> other than</B> the characters between the &quot;^&quot;
and &quot;]&quot;, is matched.&nbsp; As with the preceding conversion, if<TT> c1</TT> is &quot;]&quot;, it is considered to
be part of the scanset and a second &quot;]&quot; ends the format directive.&nbsp; The argument is assumed to point to the
first element of a character array of sufficient size to contain the sequence and a terminating null character, which is added
by the conversion operation.
<BR><BR>For example, the specification<TT> %[^\n]</TT> will match an entire input line up to but not including the newline
character.
</DL>
<BR>A conversion type specifier of &quot;%&quot; is treated as a single ordinary character that matches a single &quot;%&quot;
character in the input data.&nbsp; A conversion type specifier other than those listed above causes scanning to terminate
and the function to return.
<BR><BR>Conversion type specifiers &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;X&quot; have meaning identical to their
lowercase equivalents.
<BR><BR>The line
<BR><BR><TT>scanf( &quot;%s%*f%3hx%d&quot;, name, &amp;hexnum, &amp;decnum )</TT>
<BR><BR>with input
<BR><BR><TT>some_string 34.555e-3 abc1234</TT>
<BR><BR>will copy<TT> &quot;some_string&quot;</TT> into the array<TT> name,</TT> skip<TT> 34.555e-3</TT>, assign<TT> 0xabc</TT>
to<TT> hexnum</TT> and<TT> 1234</TT> to<TT> decnum.</TT>&nbsp; The return value will be 3.
<BR>The program
<BR><BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char string1[80], string2[80];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; scanf( &quot;%[abcdefghijklmnopqrstuvwxyz&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;ABCDEFGHIJKLMNOPQRSTUVWZ ]%*2s%[^\n]&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string1, string2 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n%s\n&quot;, string1, string2 );</TT>
<BR><TT>}</TT>
<BR><BR>with input
<BR><BR><TT>They may look alike, but they don't perform alike.</TT>
<BR><BR>will assign
<BR><BR><TT>&quot;They may look alike&quot;</TT>
<BR><BR>to<TT> string1,</TT> skip the comma (the<TT> &quot;%*2s&quot;</TT> will match only the comma; the following blank
terminates that field), and assign
<BR><BR><TT>&quot; but they don't perform alike.&quot;</TT>
<BR><BR>to<TT> string2.</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C90
<BR><BR>wscanf is ISO C95
<BR>The N, W pointer size modifiers and the I64 modifier are extensions to ISO C.
</DL>
<DL>
<DT>Systems:
<DD><TT> scanf - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>wscanf - All, Linux</TT>
</DL>
<H2 ID="scanf_s"> scanf_s, wscanf_s </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__ 1</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>int scanf_s( const char * restrict format, ... );</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>int wscanf_s( const wchar_t * restrict format, ... );</TT>
</DL>
<DL>
<DT>Constraints:
<DD>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<TT>
scanf_s</TT> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<BR><BR>The<B> format</B> argument shall not be a null pointer.&nbsp; Any argument indirected through in order to store converted
input shall not be a null pointer.
<BR><BR>If there is a runtime-constraint violation, the<TT> scanf_s</TT> function does not attempt to perform further input,
and it is unspecified to what extent<TT> scanf_s</TT> performed input before discovering the runtime-constraint violation.
</DL>
<DL>
<DT>Description:
<DD>The<TT> scanf_s</TT> function is equivalent to <TT> fscanf_s</TT> with the argument<B> stdin</B> interposed before the arguments
to scanf_s
<BR><BR>The<TT> wscanf_s</TT> function is identical to<TT> scanf_s</TT> except that it accepts a wide-character string argument
for<B> format</B>.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> scanf_s</TT> function returns <TT> EOF</TT> if an input failure occurred before any conversion or if there was a runtime-constraint
violation.&nbsp; Otherwise, the<TT> scanf_s</TT> function returns the number of input items successfully assigned, which can
be fewer than provided for, or even zero.
<BR><BR>When a file input error occurs, the <TT> errno</TT> global variable may be set.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#cscanf">cscanf</A>, <A HREF="#fscanf">fscanf</A>, <A HREF="#scanf">scanf</A>, <A HREF="#sscanf">sscanf</A>, <A HREF="#vcscanf">vcscanf</A>,
<A HREF="#vfscanf">vfscanf</A>, <A HREF="#vscanf">vscanf</A>, <A HREF="#vsscanf">vsscanf</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR>To scan a date in the form &quot;Friday August 13 2004&quot;:
<BR><BR><TT>#define __STDC_WANT_LIB_EXT1__ 1</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int day, year;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char weekday[10], month[10];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; scanf_s( &quot;%s %s %d %d&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; weekday, sizeof( weekday ),</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; month, sizeof( month ),</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;day, &amp;year );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>TR 24731
</DL>
<DL>
<DT>Systems:
<DD><TT> scanf_s - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>wscanf_s - All, Linux</TT>
</DL>
<H2 ID="sched_getparam"> sched_getparam </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;sched.h&gt;</TT>
<BR><TT>int sched_getparam(pid_t pid, struct sched_param *sp);</TT>
<BR><BR><TT>struct sched_param {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int sched_priority;</TT>
<BR><TT>};</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> sched_getparam</TT> function retrieves scheduling parameters for the process specified by<B> pid</B> and returns the
parameters in the memory pointed to by the<B> sp</B> argument.
<BR><BR>If<B> pid</B> is zero, the scheduling parameters for the calling process will be returned in the<B> sp</B> argument.
</DL>
<DL>
<DT>Returns:
<DD>If successful, the function will return zero.&nbsp; If the call fails, the return value is -1 and <TT> errno</TT> is appropriately
set.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>ESRCH
<DD>The process ID<B> pid</B> is invalid or could not be found
<DT>EPERM
<DD>The calling process does not have permission to access the parameters
<DT>EFAULT
<DD>The memory at<B> sp</B> could not be written successfully
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#sched_setparam">sched_setparam</A>
</DL>
<DL>
<DT>Classification:
<DD>POSIX
</DL>
<DL>
<DT>Systems:
<DD>Linux
</DL>
<H2 ID="sched_get_priority_max"> sched_get_priority_max </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;sched.h&gt;</TT>
<BR><TT>int sched_get_priority_max(pid_t pid, int policy);</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> sched_get_priority_max</TT> function returns the maximum priority for the scheduling policy specified by the<B> policy</B>
argument.
</DL>
<DL>
<DT>Returns:
<DD>If successful, the function will return the maximum priority allowed for the given scheduling policy.&nbsp; If the call fails,
the return value is -1 and <TT> errno</TT> is appropriately set.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>EINVAL
<DD>The value of<B> policy</B> does not represent a valid scheduling policy
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#sched_get_priority_min">sched_get_priority_min</A>
</DL>
<DL>
<DT>Classification:
<DD>POSIX
</DL>
<DL>
<DT>Systems:
<DD>Linux
</DL>
<H2 ID="sched_get_priority_min"> sched_get_priority_min </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;sched.h&gt;</TT>
<BR><TT>int sched_get_priority_min(pid_t pid, int policy);</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> sched_get_priority_min</TT> function returns the minimum priority for the scheduling policy specified by the<B> policy</B>
argument.
</DL>
<DL>
<DT>Returns:
<DD>If successful, the function will return the minimum priority allowed for the given scheduling policy.&nbsp; If the call fails,
the return value is -1 and <TT> errno</TT> is appropriately set.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>EINVAL
<DD>The value of<B> policy</B> does not represent a valid scheduling policy
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#sched_get_priority_max">sched_get_priority_max</A>
</DL>
<DL>
<DT>Classification:
<DD>POSIX
</DL>
<DL>
<DT>Systems:
<DD>Linux
</DL>
<H2 ID="sched_getscheduler"> sched_getscheduler </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;sched.h&gt;</TT>
<BR><TT>int sched_getscheduler(pid_t pid);</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> sched_getscheduler</TT> function retrieves scheduling policy for the process specified by the<B> pid</B> argument.
<BR><BR>If<B> pid</B> is zero, the policy for the calling process will be returned.
</DL>
<DL>
<DT>Returns:
<DD>If successful, the function will return the kernel's scheduling policy for the specified process.&nbsp; If the call fails,
the return value is -1 and <TT> errno</TT> is appropriately set.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>ESRCH
<DD>The process ID<B> pid</B> could not be found
<DT>EINVAL
<DD>The process ID<B> pid</B> is invalid
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#sched_setscheduler">sched_setscheduler</A>
</DL>
<DL>
<DT>Classification:
<DD>POSIX
</DL>
<DL>
<DT>Systems:
<DD>Linux
</DL>
<H2 ID="sched_rr_get_interval"> sched_rr_get_interval </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;sched.h&gt;</TT>
<BR><TT>#include &lt;time.h&gt;</TT>
<BR><TT>int sched_rr_get_interval(pid_t pid, struct timespec *ts);</TT>
<BR><BR><TT>struct timespec {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; time_t tv_sec;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; long tv_nsec;</TT>
<BR><TT>};</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> sched_rr_get_interval</TT> function retrieves the execution time limit for the process specified by the<B> pid</B>
argument.&nbsp; The memory pointed to by<B> ts</B> will be populated with this time limit if the call is successful.
<BR><BR>If<B> pid</B> is zero, the execution time limit for the calling process will be returned in the<B> ts</B> argument.
</DL>
<DL>
<DT>Returns:
<DD>If successful, the function will return zero.&nbsp; If the call fails, the return value is -1 and <TT> errno</TT> is appropriately
set.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>ESRCH
<DD>The process ID<B> pid</B> is invalid or could not be found
<DT>EPERM
<DD>The calling process does not have permission to access the parameters
<DT>EFAULT
<DD>The memory at<B> sp</B> could not be written successfully
</DL>
</DL>
<DL>
<DT>Classification:
<DD>POSIX
</DL>
<DL>
<DT>Systems:
<DD>Linux
</DL>
<H2 ID="sched_setparam"> sched_setparam </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;sched.h&gt;</TT>
<BR><TT>int sched_setparam(pid_t pid, const struct sched_param *sp);</TT>
<BR><BR><TT>struct sched_param {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int sched_priority;</TT>
<BR><TT>};</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> sched_setparam</TT> function sets the scheduling parameters for the process specified by the<B> pid</B> argument.
<BR><BR>If<B> pid</B> is zero, the scheduling parameters for the calling process will be set.
</DL>
<DL>
<DT>Returns:
<DD>If successful, the function will return zero.&nbsp; If the call fails, the return value is -1 and <TT> errno</TT> is appropriately
set.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>ESRCH
<DD>The process ID<B> pid</B> is invalid or could not be found
<DT>EINVAL
<DD>The value of<B> pid</B> or<B> sp</B> is invalid
<DT>EFAULT
<DD>The memory at<B> sp</B> could not be read
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#sched_getparam">sched_getparam</A>
</DL>
<DL>
<DT>Classification:
<DD>POSIX
</DL>
<DL>
<DT>Systems:
<DD>Linux
</DL>
<H2 ID="sched_setscheduler"> sched_setscheduler </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;sched.h&gt;</TT>
<BR><TT>int sched_setscheduler(pid_t pid, int policy,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; const struct sched_param *sp);</TT>
<BR><BR><TT>struct sched_param {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int sched_priority;</TT>
<BR><TT>};</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> sched_setscheduler</TT> function sets the scheduling policy and parameters for the process specified by the<B> pid</B>
argument.
<BR><BR>If<B> pid</B> is zero, the policy and parameters for the calling process will be set.
</DL>
<DL>
<DT>Returns:
<DD>If successful, the function will return the kernel's former scheduling policy for the specified process.&nbsp; If the call
fails, the return value is -1 and <TT> errno</TT> is appropriately set.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>ESRCH
<DD>The process ID<B> pid</B> could not be found
<DT>EINVAL
<DD>The process ID<B> pid</B> , policy value<B> policy</B> , or the pointer<B> sp</B> is invalid
<DT>EFAULT
<DD>The memory at<B> sp</B> could not be read
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#sched_getscheduler">sched_getscheduler</A>, <A HREF="#sched_setparam">sched_setparam</A>, <A HREF="#sched_getparam">sched_getparam</A>
</DL>
<DL>
<DT>Classification:
<DD>POSIX
</DL>
<DL>
<DT>Systems:
<DD>Linux
</DL>
<H2 ID="sched_yield"> sched_yield </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;sched.h&gt;</TT>
<BR><TT>int sched_yield( );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> sched_yield</TT> function causes the calling thread to yield the processor to other threads until the kernel assigns
it to be the current thread once again.
</DL>
<DL>
<DT>Returns:
<DD>If successful, the function will return zero.&nbsp; If the call fails, the return value is -1.
</DL>
<DL>
<DT>Classification:
<DD>POSIX
</DL>
<DL>
<DT>Systems:
<DD>Linux
</DL>
<H2 ID="_scrolltextwindow"> _scrolltextwindow </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>void _FAR _scrolltextwindow( short rows );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _scrolltextwindow</TT> function scrolls the lines in the current text window.&nbsp; A text window is defined with
the <TT> _settextwindow</TT> function.&nbsp; By default, the text window is the entire screen.
<BR><BR>The argument<B> rows</B> specifies the number of rows to scroll.&nbsp; A positive value means to scroll the text window
up or towards the top of the screen.&nbsp; A negative value means to scroll the text window down or towards the bottom of
the screen.&nbsp; Specifying a number of rows greater than the height of the text window is equivalent to clearing the text
window with the <TT> _clearscreen</TT> function.
<BR><BR>Two constants are defined that can be used with the<TT> _scrolltextwindow</TT> function:
<DL>
<DT>_GSCROLLUP
<DD>the contents of the text window are scrolled up (towards the top of the screen) by one row
<DT>_GSCROLLDOWN
<DD>the contents of the text window are scrolled down (towards the bottom of the screen) by one row
</DL>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _scrolltextwindow</TT> function does not return a value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_settextwindow">_settextwindow</A>, <A HREF="#_clearscreen">_clearscreen</A>, <A HREF="#_outtext">_outtext</A>,
<A HREF="#_outmem">_outmem</A>, <A HREF="#_settextposition">_settextposition</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int i;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char buf[ 80 ];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _TEXTC80 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _settextwindow( 5, 20, 20, 40 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 1; i &lt;= 10; ++i ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf( buf, &quot;Line %d\n&quot;, i );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _outtext( buf );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _scrolltextwindow( _GSCROLLDOWN );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _scrolltextwindow( _GSCROLLUP );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_searchenv"> _searchenv, _wsearchenv </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>void _searchenv( const char *name,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *env_var,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; char *pathname );</TT>
<BR><TT>void _wsearchenv( const wchar_t *name,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t
*env_var,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; wchar_t *pathname );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _searchenv</TT> function searches for the file specified by<B> name</B> in the list of directories assigned to the
environment variable specified by<B> env_var</B>.&nbsp; Common values for<B> env_var</B> are PATH, LIB and INCLUDE.
<BR><BR>The current directory is searched first to find the specified file.&nbsp; If the file is not found in the current
directory, each of the directories specified by the environment variable is searched.
<BR><BR>The full pathname is placed in the buffer pointed to by the argument<B> pathname</B>.&nbsp; If the specified file
cannot be found, then<B> pathname</B> will contain an empty string.
<BR><BR>The<TT> _wsearchenv</TT> function is a wide-character version of<TT> _searchenv</TT> that operates with wide-character
strings.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _searchenv</TT> function returns no value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#getenv">getenv</A>, <A HREF="#setenv">setenv</A>, <A HREF="#_splitpath">_splitpath</A>, <A HREF="#putenv">putenv</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>void display_help( FILE *fp )</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;display_help T.B.I.\n&quot; );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FILE *help_file;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char full_path[ _MAX_PATH ];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _searchenv( &quot;watcomc.hlp&quot;, &quot;PATH&quot;, full_path );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( full_path[0] == '\0' ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Unable to find help file\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; help_file = fopen( full_path, &quot;r&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; display_help( help_file );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( help_file );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> _searchenv - All, Linux, RDOS</TT>
<BR><BR><TT>_wsearchenv - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</TT>
</DL>
<H2 ID="segread"> segread </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;i86.h&gt;</TT>
<BR><TT>void segread( struct SREGS *seg_regs );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> segread</TT> function places the values of the segment registers into the structure located by<B> seg_regs</B>.
</DL>
<DL>
<DT>Returns:
<DD>No value is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#FP_OFF">FP_OFF</A>, <A HREF="#FP_SEG">FP_SEG</A>, <A HREF="#MK_FP">MK_FP</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;i86.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct SREGS sregs;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; segread( &amp;sregs );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Current value of CS is %04X\n&quot;, sregs.cs );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>All, RDOS, Netware
</DL>
<H2 ID="_selectpalette"> _selectpalette </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>short _FAR _selectpalette( short palnum );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _selectpalette</TT> function selects the palette indicated by the argument<B> palnum</B> from the color palettes available.
&nbsp;This function is only supported by the video modes<TT> _MRES4COLOR</TT> and<TT> _MRESNOCOLOR.</TT>
<BR><BR>Mode<TT> _MRES4COLOR</TT> supports four palettes of four colors.&nbsp; In each palette, color 0, the background color,
can be any of the 16 possible colors.&nbsp; The color values associated with the other three pixel values, (1, 2 and 3), are
determined by the selected palette.
<BR><BR>The following table outlines the available color palettes:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Palette&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Pixel
Values</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Number&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; green&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; red&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; brown</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp; cyan&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; magenta&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; white</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp; light green&nbsp;&nbsp;&nbsp;&nbsp; light red
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yellow</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp; light cyan&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; light
magenta&nbsp;&nbsp; bright white</TT>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _selectpalette</TT> function returns the number of the previously selected palette.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_setvideomode">_setvideomode</A>, <A HREF="#_getvideoconfig">_getvideoconfig</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int x, y, pal;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _MRES4COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( y = 0; y &lt; 2; ++y ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( x = 0; x &lt; 2; ++x ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _setcolor( x + 2 * y );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _rectangle( _GFILLINTERIOR,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
x * 160, y * 100,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
( x + 1 ) * 160, ( y + 1 ) * 100 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( pal = 0; pal &lt; 4; ++pal ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _selectpalette( pal );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="sem_destroy"> sem_destroy </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;semaphore.h&gt;</TT>
<BR><TT>int sem_destroy(sem_t *semaphore);</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> sem_destroy</TT> function destroys a semaphore pointed to by the<B> semaphore</B> argument.
</DL>
<DL>
<DT>Returns:
<DD>If successful, the function will return zero.&nbsp; If the call fails, the function returns -1 and <TT> errno</TT> is set
appropriately.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>EBUSY
<DD>The semaphore is currently unavailable.
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#sem_init">sem_init</A>, <A HREF="#sem_getvalue">sem_getvalue</A>, <A HREF="#sem_post">sem_post</A>, <A HREF="#sem_trywait">sem_trywait</A>,
<A HREF="#sem_wait">sem_wait</A>
</DL>
<DL>
<DT>Classification:
<DD>POSIX
</DL>
<DL>
<DT>Systems:
<DD>Linux
</DL>
<H2 ID="sem_getvalue"> sem_getvalue </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;semaphore.h&gt;</TT>
<BR><TT>int sem_getvalue(sem_t *semaphore, int *dest);</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> sem_getvalue</TT> function returns the current value of<B> semaphore</B> in the memory pointed to by the<B> dest</B>
pointer.
</DL>
<DL>
<DT>Returns:
<DD>If successful, the function will return zero.&nbsp; If the call fails, the function returns -1 and <TT> errno</TT> is set
appropriately.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>EINVAL
<DD>The pointer<B> value</B> is <TT> NULL</TT>
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#sem_destroy">sem_destroy</A>, <A HREF="#sem_init">sem_init</A>, <A HREF="#sem_post">sem_post</A>, <A HREF="#sem_trywait">sem_trywait</A>,
<A HREF="#sem_wait">sem_wait</A>
</DL>
<DL>
<DT>Classification:
<DD>POSIX
</DL>
<DL>
<DT>Systems:
<DD>Linux
</DL>
<H2 ID="sem_init"> sem_init </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;semaphore.h&gt;</TT>
<BR><TT>int sem_init(sem_t *semaphore, int flags, int value);</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> sem_init</TT> function initializes a semaphore pointed to by<B> semaphore</B> using<B> value</B> as its initial value.
&nbsp;On Open Watcom, the<B> flags</B> argument must be zero as this runtime does not currently support sharing semaphores
across processes.
</DL>
<DL>
<DT>Returns:
<DD>If successful, the function will return zero.&nbsp; If the call fails, the function returns -1 and <TT> errno</TT> is set
appropriately.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>EINVAL
<DD>The value of the<B> value</B> argument exceeds <TT> SEM_VALUE_MAX</TT>
<DT>ENOSYS
<DD>The value of<B> flags</B> was non-zero or semaphores are not supported on this CPU.
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#sem_destroy">sem_destroy</A>, <A HREF="#sem_getvalue">sem_getvalue</A>, <A HREF="#sem_post">sem_post</A>, <A HREF="#sem_trywait">sem_trywait</A>,
<A HREF="#sem_wait">sem_wait</A>
</DL>
<DL>
<DT>Classification:
<DD>POSIX
</DL>
<DL>
<DT>Systems:
<DD>Linux
</DL>
<H2 ID="sem_post"> sem_post </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;semaphore.h&gt;</TT>
<BR><TT>int sem_post(sem_t *semaphore);</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> sem_post</TT> function unlocks a semaphore pointed to by the<B> semaphore</B> argument.&nbsp; Unlocking releases the
semaphore and signals any waiting threads appropriately.
</DL>
<DL>
<DT>Returns:
<DD>If successful, the function will return zero.&nbsp; If the call fails, the function returns -1 and <TT> errno</TT> is set
appropriately.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>EINVAL
<DD>The pointer<B> semaphore</B> is <TT> NULL</TT>
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#sem_destroy">sem_destroy</A>, <A HREF="#sem_init">sem_init</A>, <A HREF="#sem_trywait">sem_trywait</A>, <A HREF="#sem_wait">sem_wait</A>
</DL>
<DL>
<DT>Classification:
<DD>POSIX
</DL>
<DL>
<DT>Systems:
<DD>Linux
</DL>
<H2 ID="sem_trywait"> sem_trywait </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;semaphore.h&gt;</TT>
<BR><TT>int sem_trywait(sem_t *semaphore);</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> sem_trywait</TT> function attempts to lock a semaphore pointed to by the<B> semaphore</B> argument, and returns immediately
regardless of success.
</DL>
<DL>
<DT>Returns:
<DD>If the semaphore was successfully locked, the function will return zero.&nbsp; If the call fails or the semaphore could not
be locked, the function returns -1 and <TT> errno</TT> is set appropriately.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>EINVAL
<DD>The pointer<B> semaphore</B> is <TT> NULL</TT>
<DT>EAGAIN
<DD>The semaphore is currently locked.
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#sem_destroy">sem_destroy</A>, <A HREF="#sem_getvalue">sem_getvalue</A>, <A HREF="#sem_init">sem_init</A>, <A HREF="#sem_post">sem_post</A>,
<A HREF="#sem_wait">sem_wait</A>
</DL>
<DL>
<DT>Classification:
<DD>POSIX
</DL>
<DL>
<DT>Systems:
<DD>Linux
</DL>
<H2 ID="sem_wait"> sem_wait </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;semaphore.h&gt;</TT>
<BR><TT>int sem_wait(sem_t *semaphore);</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> sem_wait</TT> function attempts to lock a semaphore pointed to by the<B> semaphore</B> argument, and blocks until
the semaphore is successfully locked.
</DL>
<DL>
<DT>Returns:
<DD>If the semaphore was successfully locked, the function will return zero.&nbsp; If the call fails or the semaphore could not
be locked, the function returns -1 and <TT> errno</TT> is set appropriately.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>EINVAL
<DD>The pointer<B> semaphore</B> is <TT> NULL</TT>
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#sem_destroy">sem_destroy</A>, <A HREF="#sem_getvalue">sem_getvalue</A>, <A HREF="#sem_init">sem_init</A>, <A HREF="#sem_post">sem_post</A>,
<A HREF="#sem_trywait">sem_trywait</A>
</DL>
<DL>
<DT>Classification:
<DD>POSIX
</DL>
<DL>
<DT>Systems:
<DD>Linux
</DL>
<H2 ID="set_constraint_handler_s"> set_constraint_handler_s </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__ 1</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>constraint_handler_t set_constraint_handler_s(</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; constraint_handler_t handler );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> set_constraint_handler_s</TT> function sets the runtime-constraint handler to be<B> handler</B>.&nbsp; The runtime-constraint
handler is the function called when a library function detect a runtime-constraint violation.&nbsp; Only the most recent handler
registered with<TT> set_constraint_handler_s</TT> is called when a runtime-constraint violation occurs.
<BR><BR>When the handler is called, it is passed the following arguments:
<OL>
<LI>A pointer to a character string describing the runtime-constraint violation.
<LI>A null pointer or a pointer to an implementation defined object.&nbsp; This implementation passes a null pointer.
<LI>If the function calling the handler has a return type declared as <TT> errno_t</TT>, the return value of the function
is passed.&nbsp; Otherwise, a positive value of type <TT> errno_t</TT> is passed.
</OL>
<BR>If no calls to the<TT> set_constraint_handler_s</TT> function have been made, a default constraint handler is used.&nbsp;
This handler will display an error message and abort the program.
<BR><BR>If the<B> handler</B> argument to<TT> set_constraint_handler_s</TT> is a null pointer, the default handler becomes
the current constraint handler.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> set_constraint_handler_s</TT> function returns a pointer to the previously registered handler.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#abort_handler_s">abort_handler_s</A>, <A HREF="#ignore_handler_s">ignore_handler_s</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__ 1</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>void my_handler( const char *msg, void *ptr, errno_t error )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fprintf( stderr, &quot;rt-constraint violation caught :&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fprintf( stderr, msg );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fprintf( stderr, &quot;\n&quot; );</TT>
<BR><TT>}</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; constraint_handler_t&nbsp;&nbsp;&nbsp; old_handler;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; old_handler = set_constraint_handler_s( my_handler );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( getenv_s( NULL, NULL, 0, NULL ) ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;getenv_s failed\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; set_constraint_handler_s( old_handler );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>rt-constraint violation caught: getenv_s, name == NULL.</TT>
<BR><TT>getenv_s failed</TT>
</DL>
<DL>
<DT>Classification:
<DD>TR 24731
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="_setactivepage"> _setactivepage </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>short _FAR _setactivepage( short pagenum );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _setactivepage</TT> function selects the page (in memory) to which graphics output is written.&nbsp; The page to be
selected is given by the<B> pagenum</B> argument.
<BR><BR>Only some combinations of video modes and hardware allow multiple pages of graphics to exist.&nbsp; When multiple
pages are supported, the active page may differ from the visual page.&nbsp; The graphics information in the visual page determines
what is displayed upon the screen.&nbsp; Animation may be accomplished by alternating the visual page.&nbsp; A graphics page
can be constructed without affecting the screen by setting the active page to be different than the visual page.
<BR><BR>The number of available video pages can be determined by using the <TT> _getvideoconfig</TT> function.&nbsp; The default
video page is 0.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _setactivepage</TT> function returns the number of the previous page when the active page is set successfully; otherwise,
a negative number is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getactivepage">_getactivepage</A>, <A HREF="#_setvisualpage">_setvisualpage</A>, <A HREF="#_getvisualpage">_getvisualpage</A>,
<A HREF="#_getvideoconfig">_getvideoconfig</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int old_apage;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int old_vpage;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _HRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; old_apage = _getactivepage();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; old_vpage = _getvisualpage();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* draw an ellipse on page 0 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setactivepage( 0 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvisualpage( 0 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _ellipse( _GFILLINTERIOR, 100, 50, 540, 150 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* draw a rectangle on page 1 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setactivepage( 1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _rectangle( _GFILLINTERIOR, 100, 50, 540, 150 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* display page 1 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvisualpage( 1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setactivepage( old_apage );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvisualpage( old_vpage );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_setbkcolor"> _setbkcolor </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>long _FAR _setbkcolor( long color );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _setbkcolor</TT> function sets the current background color to be that of the<B> color</B> argument.&nbsp; In text
modes, the background color controls the area behind each individual character.&nbsp; In graphics modes, the background refers
to the entire screen.&nbsp; The default background color is 0.
<BR><BR>When the current video mode is a graphics mode, any pixels with a zero pixel value will change to the color of the<B>
color</B> argument.&nbsp; When the current video mode is a text mode, nothing will immediately change; only subsequent output
is affected.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _setbkcolor</TT> function returns the previous background color.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getbkcolor">_getbkcolor</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><BR><TT>long colors[ 16 ] = {</TT>
<BR><TT>&nbsp;&nbsp; _BLACK, _BLUE, _GREEN, _CYAN,</TT>
<BR><TT>&nbsp;&nbsp; _RED, _MAGENTA, _BROWN, _WHITE,</TT>
<BR><TT>&nbsp;&nbsp; _GRAY, _LIGHTBLUE, _LIGHTGREEN, _LIGHTCYAN,</TT>
<BR><TT>&nbsp;&nbsp; _LIGHTRED, _LIGHTMAGENTA, _YELLOW, _BRIGHTWHITE</TT>
<BR><TT>};</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; long old_bk;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int bk;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; old_bk = _getbkcolor();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( bk = 0; bk &lt; 16; ++bk ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _setbkcolor( colors[ bk ] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setbkcolor( old_bk );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="setbuf"> setbuf </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>void setbuf( FILE *fp, char *buffer );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> setbuf</TT> function can be used to associate a buffer with the file designated by<B> fp</B>.&nbsp; If this function
is used, it must be called after the file has been opened and before it has been read or written.&nbsp; If the argument<B>
buffer</B> is<TT> NULL,</TT> then all input/output for the file<B> fp</B> will be completely unbuffered.&nbsp; If the argument<B>
buffer</B> is not<TT> NULL,</TT> then it must point to an array that is at least <TT> BUFSIZ</TT> characters in length, and
all input/output will be fully buffered.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> setbuf</TT> function returns no value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#fopen">fopen</A>, <A HREF="#setvbuf">setvbuf</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char *buffer;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FILE *fp;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; fp = fopen( &quot;file&quot;, &quot;r&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; buffer = (char *) malloc( BUFSIZ );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; setbuf( fp, buffer );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* . */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* . */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* . */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fclose( fp );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD>DOS/16, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, Linux, RDOS, Netware
</DL>
<H2 ID="_setcharsize"> _setcharsize, _setcharsize_w </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>void _FAR _setcharsize( short height, short width );</TT>
<BR><BR><TT>void _FAR _setcharsize_w( double height, double width );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _setcharsize</TT> functions set the character height and width to the values specified by the arguments<B> height</B>
and<B> width</B>.&nbsp; For the<TT> _setcharsize</TT> function, the arguments<B> height</B> and<B> width</B> represent a number
of pixels.&nbsp; For the<TT> _setcharsize_w</TT> function, the arguments<B> height</B> and<B> width</B> represent lengths
along the y-axis and x-axis in the window coordinate system.
<BR><BR>These sizes are used when displaying text with the <TT> _grtext</TT> function.&nbsp; The default character sizes are
dependent on the graphics mode selected, and can be determined by the <TT> _gettextsettings</TT> function.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _setcharsize</TT> functions do not return a value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_grtext">_grtext</A>, <A HREF="#_gettextsettings">_gettextsettings</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct textsettings ts;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _gettextsettings( &amp;ts );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _grtext( 100, 100, &quot;WATCOM&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setcharsize( 2 * ts.height, 2 * ts.width );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _grtext( 100, 300, &quot;Graphics&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setcharsize( ts.height, ts.width );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><IMG SRC="eg_getts.bmp" ALIGN=MIDDLE>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD><TT> _setcharsize - DOS</TT>
<BR><BR><TT>_setcharsize_w - DOS</TT>
</DL>
<H2 ID="_setcharspacing"> _setcharspacing, _setcharspacing_w </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>void _FAR _setcharspacing( short space );</TT>
<BR><BR><TT>void _FAR _setcharspacing_w( double space );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _setcharspacing</TT> functions set the current character spacing to have the value of the argument<B> space</B>.&nbsp;
For the<TT> _setcharspacing</TT> function,<B> space</B> represents a number of pixels.&nbsp; For the<TT> _setcharspacing_w</TT>
function,<B> space</B> represents a length along the x-axis in the window coordinate system.
<BR><BR>The character spacing specifies the additional space to leave between characters when a text string is displayed with
the <TT> _grtext</TT> function.&nbsp; A negative value can be specified to cause the characters to be drawn closer together.
&nbsp;The default value of the character spacing is 0.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _setcharspacing</TT> functions do not return a value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_grtext">_grtext</A>, <A HREF="#_gettextsettings">_gettextsettings</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _grtext( 100, 100, &quot;WATCOM&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setcharspacing( 20 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _grtext( 100, 300, &quot;Graphics&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><IMG SRC="eg_setcs.bmp" ALIGN=MIDDLE>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD><TT> _setcharspacing - DOS</TT>
<BR><BR><TT>_setcharspacing_w - DOS</TT>
</DL>
<H2 ID="_setcliprgn"> _setcliprgn </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>void _FAR _setcliprgn( short x1, short y1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; short x2, short y2 );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _setcliprgn</TT> function restricts the display of graphics output to the clipping region.&nbsp; This region is a
rectangle whose opposite corners are established by the physical points<TT> (x1,y1)</TT> and<TT> (x2,y2).</TT>
<BR><BR>The<TT> _setcliprgn</TT> function does not affect text output using the <TT> _outtext</TT> and <TT> _outmem</TT> functions.
&nbsp;To control the location of text output, see the <TT> _settextwindow</TT> function.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _setcliprgn</TT> function does not return a value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_settextwindow">_settextwindow</A>, <A HREF="#_setvieworg">_setvieworg</A>, <A HREF="#_setviewport">_setviewport</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; short x1, y1, x2, y2;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _getcliprgn( &amp;x1, &amp;y1, &amp;x2, &amp;y2 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setcliprgn( 130, 100, 510, 380 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _ellipse( _GBORDER, 120, 90, 520, 390 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setcliprgn( x1, y1, x2, y2 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_setcolor"> _setcolor </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>short _FAR _setcolor( short pixval );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _setcolor</TT> function sets the pixel value for the current color to be that indicated by the<B> pixval</B> argument.
&nbsp;The current color is only used by the functions that produce graphics output; text output with <TT> _outtext</TT> uses
the current text color (see the <TT> _settextcolor</TT> function).&nbsp; The default color value is one less than the maximum
number of colors in the current video mode.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _setcolor</TT> function returns the previous value of the current color.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getcolor">_getcolor</A>, <A HREF="#_settextcolor">_settextcolor</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int col, old_col;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; old_col = _getcolor();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( col = 0; col &lt; 16; ++col ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _setcolor( col );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _rectangle( _GFILLINTERIOR, 100, 100, 540, 380 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setcolor( old_col );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="setenv"> setenv, _setenv, _wsetenv </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;env.h&gt;</TT>
<BR><TT>int setenv( const char *name,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *newvalue,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int overwrite );</TT>
<BR><TT>int _setenv( const char *name,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *newvalue,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int overwrite );</TT>
<BR><TT>int _wsetenv( const wchar_t *name,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t *newvalue,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int overwrite );</TT>
</DL>
<DL>
<DT>Description:
<DD>The environment list consists of a number of environment names, each of which has a value associated with it.&nbsp; Entries
can be added to the environment list with the DOS<TT> set</TT> command or with the<TT> setenv</TT> function.&nbsp; All entries
in the environment list can be displayed by using the DOS<TT> set</TT> command with no arguments.&nbsp; A program can obtain
the value for an environment variable by using the <TT> getenv</TT> function.
<BR><BR>The<TT> setenv</TT> function searches the environment list for an entry of the form<B> name=value</B>.&nbsp; If no
such string is present,<TT> setenv</TT> adds an entry of the form<B> name=newvalue</B> to the environment list.&nbsp; Otherwise,
if the<B> overwrite</B> argument is non-zero,<TT> setenv</TT> either will change the existing value to<B> newvalue</B> or
will delete the string<B> name=value</B> and add the string<B> name=newvalue</B>.
<BR><BR>If the<B> newvalue</B> pointer is NULL, all strings of the form<B> name=value</B> in the environment list will be
deleted.
<BR><BR>The value of the pointer <TT> environ</TT> may change across a call to the<TT> setenv</TT> function.
<BR><BR>The<TT> setenv</TT> function will make copies of the strings associated with<B> name</B> and<B> newvalue</B>.
<BR><BR>The matching is case-insensitive; all lowercase letters are treated as if they were in upper case.
<BR><BR>Entries can also be added to the environment list with the DOS<TT> set</TT> command or with the <TT> putenv</TT> or<TT>
setenv</TT> functions.&nbsp; All entries in the environment list can be obtained by using the <TT> getenv</TT> function.
<BR><BR>To assign a string to a variable and place it in the environment list:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C&gt;SET INCLUDE=C:\WATCOM\H</TT>
<BR><BR>To see what variables are in the environment list, and their current assignments:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C&gt;SET</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; COMSPEC=C:\COMMAND.COM</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PATH=C:\;C:\WATCOM</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INCLUDE=C:\WATCOM\H</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C&gt;</TT>
<BR><BR>The<TT> _setenv</TT> function is identical to<TT> setenv</TT>.&nbsp; Use<TT> _setenv</TT> for ANSI naming conventions.
<BR><BR>The<TT> _wsetenv</TT> function is a wide-character version of<TT> setenv</TT> that operates with wide-character strings.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> setenv</TT> function returns zero upon successful completion.&nbsp; Otherwise, it will return a non-zero value and
set <TT> errno</TT> to indicate the error.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
<DL>
<DT>ENOMEM
<DD>Not enough memory to allocate a new environment string.
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#clearenv">clearenv</A>, <A HREF="#exec___">exec...</A>, <A HREF="#getenv">getenv</A>, <A HREF="#getenv_s">getenv_s</A>,
<A HREF="#putenv">putenv</A>, <A HREF="#_searchenv">_searchenv</A>, <A HREF="#spawn___">spawn...</A>, <A HREF="#system">system</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR>The following will change the string assigned to <TT> INCLUDE</TT> and then display the new string.
<BR><BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>#include &lt;env.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char *path;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; if( setenv( &quot;INCLUDE&quot;, &quot;D:\\WATCOM\\H&quot;, 1 ) == 0 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( (path = getenv( &quot;INCLUDE&quot; )) != NULL )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;INCLUDE=%s\n&quot;, path );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
<BR><BR>_setenv conforms to ANSI naming conventions
</DL>
<DL>
<DT>Systems:
<DD><TT> setenv - All, Linux, RDOS</TT>
<BR><BR><TT>_setenv - All, Linux, RDOS</TT>
<BR><TT>_wsetenv - All, Linux</TT>
</DL>
<H2 ID="_setfillmask"> _setfillmask </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>void _FAR _setfillmask( char _FAR *mask );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _setfillmask</TT> function sets the current fill mask to the value of the argument<B> mask</B>.&nbsp; When the value
of the<B> mask</B> argument is<TT> NULL,</TT> there will be no fill mask set.
<BR><BR>The fill mask is an eight-byte array which is interpreted as a square pattern (8 by 8) of 64 bits.&nbsp; Each bit
in the mask corresponds to a pixel.&nbsp; When a region is filled, each point in the region is mapped onto the fill mask.
&nbsp;When a bit from the mask is one, the pixel value of the corresponding point is set using the current plotting action
with the current color; when the bit is zero, the pixel value of that point is not affected.
<BR><BR>When the fill mask is not set, a fill operation will set all points in the fill region to have a pixel value of the
current color.&nbsp; By default, no fill mask is set.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _setfillmask</TT> function does not return a value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getfillmask">_getfillmask</A>, <A HREF="#_ellipse">_ellipse</A>, <A HREF="#_floodfill">_floodfill</A>, <A HREF="#_rectangle">_rectangle</A>,
<A HREF="#_polygon">_polygon</A>, <A HREF="#_pie">_pie</A>, <A HREF="#_setcolor">_setcolor</A>, <A HREF="#_setplotaction">_setplotaction</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><BR><TT>char old_mask[ 8 ];</TT>
<BR><TT>char new_mask[ 8 ] = { 0x81, 0x42, 0x24, 0x18,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; 0x18, 0x24, 0x42, 0x81 };</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _getfillmask( old_mask );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setfillmask( new_mask );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _rectangle( _GFILLINTERIOR, 100, 100, 540, 380 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setfillmask( old_mask );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><IMG SRC="eg_getfm.bmp" ALIGN=MIDDLE>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_setfont"> _setfont </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>short _FAR _setfont( char _FAR *opt );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _setfont</TT> function selects a font from the list of registered fonts (see the <TT> _registerfonts</TT> function).
&nbsp;The font selected becomes the current font and is used whenever text is displayed with the <TT> _outgtext</TT> function.
&nbsp;The function will fail if no fonts have been registered, or if a font cannot be found that matches the given characteristics.
<BR><BR>The argument<B> opt</B> is a string of characters specifying the characteristics of the desired font.&nbsp; These
characteristics determine which font is selected.&nbsp; The options may be separated by blanks and are not case-sensitive.
&nbsp;Any number of options may be specified and in any order.&nbsp; The available options are:
<DL>
<DT>hX
<DD>character height X (in pixels)
<DT>wX
<DD>character width X (in pixels)
<DT>f
<DD>choose a fixed-width font
<DT>p
<DD>choose a proportional-width font
<DT>r
<DD>choose a raster (bit-mapped) font
<DT>v
<DD>choose a vector font
<DT>b
<DD>choose the font that best matches the options
<DT>nX
<DD>choose font number X (the number of fonts is returned by the <TT> _registerfonts</TT> function)
<DT>t'facename'
<DD>choose a font with specified facename
</DL>
<BR>The facename option is specified as a &quot;t&quot; followed by a facename enclosed in single quotes.&nbsp; The available
facenames are:
<DL>
<DT>Courier
<DD>fixed-width raster font with serifs
<DT>Helv
<DD>proportional-width raster font without serifs
<DT>Tms Rmn
<DD>proportional-width raster font with serifs
<DT>Script
<DD>proportional-width vector font that appears similar to hand-writing
<DT>Modern
<DD>proportional-width vector font without serifs
<DT>Roman
<DD>proportional-width vector font with serifs
</DL>
<BR>When &quot;nX&quot; is specified to select a particular font, the other options are ignored.
<BR><BR>If the best fit option (&quot;b&quot;) is specified,<TT> _setfont</TT> will always be able to select a font.&nbsp;
The font chosen will be the one that best matches the options specified.&nbsp; The following precedence is given to the options
when selecting a font:
<OL>
<LI>Pixel height (higher precedence is given to heights less than the specified height)
<LI>Facename
<LI>Pixel width
<LI>Font type (fixed or proportional)
</OL>
<BR>When a pixel height or width does not match exactly and a vector font has been selected, the font will be stretched appropriately
to match the given size.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _setfont</TT> function returns zero if successful; otherwise, (-1) is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_registerfonts">_registerfonts</A>, <A HREF="#_unregisterfonts">_unregisterfonts</A>, <A HREF="#_getfontinfo">_getfontinfo</A>,
<A HREF="#_outgtext">_outgtext</A>, <A HREF="#_getgtextextent">_getgtextextent</A>, <A HREF="#_setgtextvector">_setgtextvector</A>,
<A HREF="#_getgtextvector">_getgtextvector</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int i, n;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char buf[ 10 ];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; n = _registerfonts( &quot;*.fon&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; n; ++i ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf( buf, &quot;n%d&quot;, i );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _setfont( buf );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _moveto( 100, 100 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _outgtext( &quot;WATCOM Graphics&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _clearscreen( _GCLEARSCREEN );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _unregisterfonts();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_setgtextvector"> _setgtextvector </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>struct xycoord _FAR _setgtextvector( short x, short y );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _setgtextvector</TT> function sets the orientation for text output used by the <TT> _outgtext</TT> function to the
vector specified by the arguments<TT> (x,y).</TT>&nbsp; Each of the arguments can have a value of -1, 0 or 1, allowing for
text to be displayed at any multiple of a 45-degree angle.&nbsp; The default text orientation, for normal left-to-right text,
is the vector<TT> (1,0).</TT>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _setgtextvector</TT> function returns, as an<TT> xycoord</TT> structure, the previous value of the text orientation
vector.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_registerfonts">_registerfonts</A>, <A HREF="#_unregisterfonts">_unregisterfonts</A>, <A HREF="#_setfont">_setfont</A>,
<A HREF="#_getfontinfo">_getfontinfo</A>, <A HREF="#_outgtext">_outgtext</A>, <A HREF="#_getgtextextent">_getgtextextent</A>,
<A HREF="#_getgtextvector">_getgtextvector</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct xycoord old_vec;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; old_vec = _getgtextvector();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setgtextvector( 0, -1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _moveto( 100, 100 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _outgtext( &quot;WATCOM Graphics&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setgtextvector( old_vec.xcoord, old_vec.ycoord );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="sethostent"> sethostent </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;netdb.h&gt;</TT>
<BR><TT>void sethostent( int stayopen );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> sethostent</TT> function opens the network host database at /etc/hosts and sets the position for reading to the first
entry.&nbsp; If the network host database is already open, the position is reset to the first entry.&nbsp; The<B> stayopen</B>
argument, if non-zero, will cause the database to remain open after subsequent calls to the <TT> gethostent</TT> function.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#gethostent">gethostent</A>, <A HREF="#endhostent">endhostent</A>
</DL>
<DL>
<DT>Classification:
<DD>POSIX
</DL>
<DL>
<DT>Systems:
<DD>Linux
</DL>
<H2 ID="setjmp"> setjmp </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;setjmp.h&gt;</TT>
<BR><TT>int setjmp( jmp_buf env );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> setjmp</TT> function saves its calling environment in its <TT> jmp_buf</TT> argument, for subsequent use by the <TT>
longjmp</TT> function.
<BR><BR>In some cases, error handling can be implemented by using<TT> setjmp</TT> to record the point to which a return will
occur following an error.&nbsp; When an error is detected in a called function, that function uses <TT> longjmp</TT> to jump
back to the recorded position.&nbsp; The original function which called<TT> setjmp</TT> must still be active (it cannot have
returned to the function which called it).
<BR><BR>Special care must be exercised to ensure that any side effects that are left undone (allocated memory, opened files,
etc.) are satisfactorily handled.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> setjmp</TT> function returns zero when it is initially called.&nbsp; The return value will be non-zero if the return
is the result of a call to the <TT> longjmp</TT> function.&nbsp; An<TT> if</TT> statement is often used to handle these two
returns.&nbsp; When the return value is zero, the initial call to setjmp has been made; when the return value is non-zero,
a return from a <TT> longjmp</TT> has just occurred.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#longjmp">longjmp</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;setjmp.h&gt;</TT>
<BR><BR><TT>jmp_buf env;</TT>
<BR><BR><TT>rtn()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;about to longjmp\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; longjmp( env, 14 );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int ret_val = 293;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; if( 0 == ( ret_val = setjmp( env ) ) ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;after setjmp %d\n&quot;, ret_val );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rtn();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;back from rtn %d\n&quot;, ret_val );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;back from longjmp %d\n&quot;, ret_val );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>after setjmp 0</TT>
<BR><TT>about to longjmp</TT>
<BR><TT>back from longjmp 14</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="_setlinestyle"> _setlinestyle </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>void _FAR _setlinestyle( unsigned short style );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _setlinestyle</TT> function sets the current line-style mask to the value of the<B> style</B> argument.
<BR><BR>The line-style mask determines the style by which lines and arcs are drawn.&nbsp; The mask is treated as an array
of 16 bits.&nbsp; As a line is drawn, a pixel at a time, the bits in this array are cyclically tested.&nbsp; When a bit in
the array is 1, the pixel value for the current point is set using the current color according to the current plotting action;
otherwise, the pixel value for the point is left unchanged.&nbsp; A solid line would result from a value of<TT> 0xFFFF</TT>
and a dashed line would result from a value of<TT> 0xF0F0</TT>
<BR><BR>The default line style mask is<TT> 0xFFFF</TT>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _setlinestyle</TT> function does not return a value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getlinestyle">_getlinestyle</A>, <A HREF="#_lineto">_lineto</A>, <A HREF="#_rectangle">_rectangle</A>, <A HREF="#_polygon">_polygon</A>,
<A HREF="#_setplotaction">_setplotaction</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><BR><TT>#define DASHED 0xf0f0</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned old_style;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; old_style = _getlinestyle();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setlinestyle( DASHED );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _rectangle( _GBORDER, 100, 100, 540, 380 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setlinestyle( old_style );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><IMG SRC="eg_getls.bmp" ALIGN=MIDDLE>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="setlocale"> setlocale, _wsetlocale </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;locale.h&gt;</TT>
<BR><TT>char *setlocale( int category, const char *locale );</TT>
<BR><TT>wchar_t *_wsetlocale( int category, const wchar_t *locale);</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> setlocale</TT> function selects a portion of a program's<B> locale</B> according to the category given by<B> category</B>
and the locale specified by<B> locale</B>.&nbsp; A<B> locale</B> affects the collating sequence (the order in which characters
compare with one another), the way in which certain character-handling functions operate, the decimal-point character that
is used in formatted input/output and string conversion, and the format and names used in the time string produced by the
<TT> strftime</TT> function.
<BR><BR>Potentially, there may be many such environments.&nbsp; Open Watcom C/C++ supports only the<TT> &quot;C&quot;</TT>
locale and so invoking this function will have no effect upon the behavior of a program at present.&nbsp; Specifying the<TT>
&quot;POSIX&quot;</TT> locale is supported for POSIX compatibility and equivalent to specifying the<TT> &quot;C&quot;</TT>
locale.
<BR><BR>The possible values for the argument<B> category</B> are as follows:
<DL>
<DT>Category&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>LC_ALL
<DD>select entire environment
<DT>LC_COLLATE
<DD>select collating sequence
<DT>LC_CTYPE
<DD>select the character-handling
<DT>LC_MONETARY
<DD>select monetary formatting information
<DT>LC_NUMERIC
<DD>select the numeric-format environment
<DT>LC_TIME
<DD>select the time-related environment
</DL>
<BR>At the start of a program, the equivalent of the following statement is executed.
<BR><BR><TT>&nbsp;&nbsp;&nbsp; setlocale( LC_ALL, &quot;C&quot; );</TT>
<BR>The<TT> _wsetlocale</TT> function is a wide-character version of<TT> setlocale</TT> that operates with wide-character
strings.
</DL>
<DL>
<DT>Returns:
<DD>If the selection is successful, a string is returned to indicate the locale that was in effect before the function was invoked;
otherwise, a<TT> NULL</TT> pointer is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#strcoll">strcoll</A>, <A HREF="#strftime">strftime</A>, <A HREF="#strxfrm">strxfrm</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>#include &lt;locale.h&gt;</TT>
<BR><BR><TT>char src[] = { &quot;A sample STRING&quot; };</TT>
<BR><TT>char dst[20];</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char *prev_locale;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; size_t len;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; /* set native locale */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; prev_locale = setlocale( LC_ALL, &quot;&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, prev_locale );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; len = strxfrm( dst, src, 20 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s (%u)\n&quot;, dst, len );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>C</TT>
<BR><TT>A sample STRING (15)</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>_wsetlocale is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> setlocale - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_wsetlocale - All, Linux</TT>
</DL>
<H2 ID="_set_matherr"> _set_matherr </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>void _set_matherr( int (*rtn)( struct _exception *err_info ) )</TT>
</DL>
<DL>
<DT>Description:
<DD>The default <TT> matherr</TT> function supplied in the library can be replaced so that the application can handle mathematical
errors.&nbsp; To do this, the<TT> _set_matherr</TT> function must be called with the address of the new mathematical error
handling routine.
<BR><BR><B><I>Note:</I></B>&nbsp; Under some systems, the default math error handler can be replaced by providing a user-written
function of the same name, <TT> matherr</TT>, and using linking strategies to replace the default handler.
<BR><BR>A program may contain a user-written version of <TT> matherr</TT> to take any appropriate action when an error is
detected.&nbsp; When zero is returned by the user-written routine, an error message will be printed upon <TT> stderr</TT>
and <TT> errno</TT> will be set as was the case with the default function.&nbsp; When a non-zero value is returned, no message
is printed and <TT> errno</TT> is not changed.&nbsp; The value<TT> err_info-&gt;retval</TT> is used as the return value for
the function in which the error was detected.
<BR><BR>When called, the user-written math error handler is passed a pointer to a structure of type<TT> struct _exception</TT>
which contains information about the error that has been detected:
<BR><BR><TT>struct _exception</TT>
<BR><TT>{ int type;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* TYPE OF ERROR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp; char *name;&nbsp;&nbsp;&nbsp; /* NAME OF FUNCTION&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; */</TT>
<BR><TT>&nbsp; double arg1;&nbsp;&nbsp; /* FIRST ARGUMENT TO FUNCTION&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp; double arg2;&nbsp;&nbsp; /* SECOND ARGUMENT TO FUNCTION&nbsp; */</TT>
<BR><TT>&nbsp; double retval; /* DEFAULT RETURN VALUE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>};</TT>
<BR><BR>The<TT> type</TT> field will contain one of the following values:
<DL>
<DT>Value&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>DOMAIN
<DD>A domain error has occurred, such as<TT> sqrt(-1e0).</TT>
<DT>SING
<DD>A singularity will result, such as<TT> pow(0e0,-2).</TT>
<DT>OVERFLOW
<DD>An overflow will result, such as<TT> pow(10e0,100).</TT>
<DT>UNDERFLOW
<DD>An underflow will result, such as<TT> pow(10e0,-100).</TT>
<DT>TLOSS
<DD>Total loss of significance will result, such as<TT> exp(1000).</TT>
<DT>PLOSS
<DD>Partial loss of significance will result, such as<TT> sin(10e70).</TT>
</DL>
<BR>The<TT> name</TT> field points to a string containing the name of the function which detected the error.&nbsp; The fields<TT>
arg1</TT> and<TT> arg2</TT> (if required) give the values which caused the error.&nbsp; The field<TT> retval</TT> contains
the value which will be returned by the function.&nbsp; This value may be changed by a user-supplied version of the _set_matherr
function.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _set_matherr</TT> function returns no value.
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><BR><TT>/* Demonstrate error routine in which negative */</TT>
<BR><TT>/* arguments to &quot;sqrt&quot; are treated as positive */</TT>
<BR><BR><TT>int my_matherr( struct _exception *err )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( strcmp( err-&gt;name, &quot;sqrt&quot; ) == 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( err-&gt;type == DOMAIN ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err-&gt;retval = sqrt( -(err-&gt;arg1) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( 1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( 0 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; } else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( 0 );</TT>
<BR><TT>}</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _set_matherr( &amp;my_matherr );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%e\n&quot;, sqrt( -5e0 ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; exit( 0 );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>Math
</DL>
<H2 ID="_setmbcp"> _setmbcp </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><TT>int _setmbcp( int codepage );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _setmbcp</TT> function sets the current code page number.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _setmbcp</TT> function returns zero if the code page is set successfully.&nbsp; If an invalid code page value is supplied
for<B> codepage</B>, the function returns -1 and the code page setting is unchanged.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getmbcp">_getmbcp</A>, <A HREF="#_mbbtombc">_mbbtombc</A>, <A HREF="#_mbcjistojms">_mbcjistojms</A>, <A HREF="#_mbcjmstojis">_mbcjmstojis</A>,
<A HREF="#_mbctombb">_mbctombb</A>, <A HREF="#_ismbbalnum">_ismbbalnum</A>, <A HREF="#_ismbbalpha">_ismbbalpha</A>, <A HREF="#_ismbbgraph">_ismbbgraph</A>,
<A HREF="#_ismbbkalnum">_ismbbkalnum</A>, <A HREF="#_ismbbkalpha">_ismbbkalpha</A>, <A HREF="#_ismbbkana">_ismbbkana</A>,
<A HREF="#_ismbbkprint">_ismbbkprint</A>, <A HREF="#_ismbbkpunct">_ismbbkpunct</A>, <A HREF="#_ismbblead">_ismbblead</A>,
<A HREF="#_ismbbprint">_ismbbprint</A>, <A HREF="#_ismbbpunct">_ismbbpunct</A>, <A HREF="#_ismbbtrail">_ismbbtrail</A>, <A HREF="#_mbbtombc">_mbbtombc</A>,
<A HREF="#_mbcjistojms">_mbcjistojms</A>, <A HREF="#_mbcjmstojis">_mbcjmstojis</A>, <A HREF="#_mbctombb">_mbctombb</A>, <A HREF="#_mbbtype">_mbbtype</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, _setmbcp( 932 ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, _getmbcp() );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>0</TT>
<BR><TT>932</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, Linux, RDOS
</DL>
<H2 ID="setmode"> setmode, _setmode </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;io.h&gt;</TT>
<BR><TT>#include &lt;fcntl.h&gt;</TT>
<BR><TT>int setmode( int handle, int mode );</TT>
<BR><TT>int _setmode( int handle, int mode );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> setmode</TT> function sets, at the operating system level, the translation mode to be the value of<B> mode</B> for
the file whose file handle is given by<B> handle</B>.&nbsp; The mode, defined in the<TT> &lt;fcntl.h&gt;</TT> header file,
can be one of:
<DL>
<DT>Mode&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>O_TEXT
<DD>On input, a carriage-return character that immediately precedes a linefeed character is removed from the data that is read.
&nbsp;On output, a carriage-return character is inserted before each linefeed character.
<DT>O_BINARY
<DD>Data is read or written unchanged.
</DL>
</DL>
<DL>
<DT>Returns:
<DD>If successful, the<TT> setmode</TT> function returns the previous mode that was set for the file; otherwise, -1 is returned.
&nbsp;When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#chsize">chsize</A>, <A HREF="#close">close</A>, <A HREF="#creat">creat</A>, <A HREF="#dup">dup</A>, <A HREF="#dup2">dup2</A>,
<A HREF="#eof">eof</A>, <A HREF="#exec___">exec...</A>, <A HREF="#fdopen">fdopen</A>, <A HREF="#filelength">filelength</A>,
<A HREF="#fileno">fileno</A>, <A HREF="#fstat">fstat</A>, <A HREF="#_grow_handles">_grow_handles</A>, <A HREF="#isatty">isatty</A>,
<A HREF="#lseek">lseek</A>, <A HREF="#open">open</A>, <A HREF="#read">read</A>, <A HREF="#sopen">sopen</A>, <A HREF="#stat">stat</A>,
<A HREF="#tell">tell</A>, <A HREF="#write">write</A>, <A HREF="#umask">umask</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;fcntl.h&gt;</TT>
<BR><TT>#include &lt;io.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FILE *fp;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; long count;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; fp = fopen( &quot;file&quot;, &quot;rb&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( fp != NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setmode( fileno( fp ), O_BINARY );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count = 0L;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( fgetc( fp ) != EOF ) ++count;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;File contains %lu characters\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( fp );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> setmode - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_setmode - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS, Netware</TT>
</DL>
<H2 ID="setnetent"> setnetent </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;netdb.h&gt;</TT>
<BR><TT>void setnetent( int stayopen );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> setnetent</TT> function opens or rewinds the network database for subsequent access by the <TT> getnetent</TT> function.
&nbsp;If<B> stayopen</B> is non-zero, the network database will remain open between calls to the <TT> getnetent</TT> function.
&nbsp;The database can be closed when <TT> endnetent</TT> is called.
<BR><BR>This function is not thread-safe.&nbsp; Other calls to this function or to other functions accessing the hostname
database may affect the return value from this function.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#getnetent">getnetent</A>, <A HREF="#endnetent">endnetent</A>, <A HREF="#getnetbyname">getnetbyname</A>, <A HREF="#getnetbyaddr">getnetbyaddr</A>
</DL>
<DL>
<DT>Classification:
<DD>POSIX
</DL>
<DL>
<DT>Systems:
<DD>Linux
</DL>
<H2 ID="set_new_handler"> set_new_handler, _set_new_handler </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;new.h&gt;</TT>
<BR><TT>PFV set_new_handler( PFV pNewHandler );</TT>
<BR><TT>PFU _set_new_handler( PFU pNewHandler );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> set_new_handler</TT> functions are used to transfer control to a user-defined error handler if the <TT> new</TT> operator
fails to allocate memory.&nbsp; The argument<B> pNewHandler</B> is the name of a function of type <TT> PFV</TT> or <TT> PFU</TT>.
<DL>
<DT>Type&nbsp;&nbsp;&nbsp;&nbsp; Description
<DT>PFV
<DD>Pointer to a function that returns <TT> void</TT> (i.e., returns nothing) and takes an argument of type <TT> void</TT> (i.e.,
takes no argument).
<DT>PFU
<DD>Pointer to a function that returns <TT> int</TT> and takes an argument of type <TT> unsigned</TT> which is the amount of space
to be allocated.
</DL>
<BR>In a multi-threaded environment, handlers are maintained separately for each process and thread.&nbsp; Each new process
lacks installed handlers.&nbsp; Each new thread gets a copy of its parent thread's new handlers.&nbsp; Thus, each process
and thread is in charge of its own free-store error handling.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> set_new_handler</TT> functions return a pointer to the previous error handler so that the previous error handler can
be reinstated at a later time.
<BR><BR>The error handler specified as the argument to<TT> _set_new_handler</TT> returns zero indicating that further attempts
to allocate memory should be halted or non-zero to indicate that an allocation request should be re-attempted.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_bfreeseg">_bfreeseg</A>, <A HREF="#_bheapseg">_bheapseg</A>, <A HREF="#calloc">calloc</A>, <A HREF="#free">free</A>,
<A HREF="#malloc">malloc</A>, <A HREF="#realloc">realloc</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;new.h&gt;</TT>
<BR><BR><TT>#if defined(__386__)</TT>
<BR><TT>const size_t MemBlock = 8192;</TT>
<BR><TT>#else</TT>
<BR><TT>const size_t MemBlock = 2048;</TT>
<BR><TT>#endif</TT>
<BR><BR><TT>/*</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; Pre-allocate a memory block for demonstration</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; purposes. The out-of-memory handler will return</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; it to the system so that &quot;new&quot; can use it.</TT>
<BR><TT>*/</TT>
<BR><BR><TT>long *failsafe = new long[MemBlock];</TT>
<BR><BR><TT>/*</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; Declare a customized function to handle memory</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; allocation failure.</TT>
<BR><TT>*/</TT>
<BR><BR><TT>int out_of_memory_handler( unsigned size )</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Allocation failed, &quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%u bytes not available.\n&quot;, size );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* Release pre-allocated memory if we can */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( failsafe == NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Halting allocation.\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Tell new to stop allocation attempts */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( 0 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete failsafe;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; failsafe = NULL;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Retrying allocation.\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Tell new to retry allocation attempt */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( 1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; /* Register existence of a new memory handler */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _set_new_handler( out_of_memory_handler );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; long *pmemdump = new long[MemBlock];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i=1 ; pmemdump != NULL; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pmemdump = new long[MemBlock];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( pmemdump != NULL )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Another block allocated %d\n&quot;, i );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> set_new_handler - All, Netware</TT>
<BR><BR><TT>_set_new_handler - All, Netware</TT>
</DL>
<H2 ID="_setpixel"> _setpixel, _setpixel_w </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>short _FAR _setpixel( short x, short y );</TT>
<BR><BR><TT>short _FAR _setpixel_w( double x, double y );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _setpixel</TT> function sets the pixel value of the point<TT> (x,y)</TT> using the current plotting action with the
current color.&nbsp; The<TT> _setpixel</TT> function uses the view coordinate system.&nbsp; The<TT> _setpixel_w</TT> function
uses the window coordinate system.
<BR><BR>A pixel value is associated with each point.&nbsp; The values range from 0 to the number of colors (less one) that
can be represented in the palette for the current video mode.&nbsp; The color displayed at the point is the color in the palette
corresponding to the pixel number.&nbsp; For example, a pixel value of 3 causes the fourth color in the palette to be displayed
at the point in question.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _setpixel</TT> functions return the previous value of the indicated pixel if the pixel value can be set; otherwise,
(-1) is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getpixel">_getpixel</A>, <A HREF="#_setcolor">_setcolor</A>, <A HREF="#_setplotaction">_setplotaction</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int x, y;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _rectangle( _GBORDER, 100, 100, 540, 380 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt;= 60000; ++i ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = 101 + rand() % 439;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y = 101 + rand() % 279;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _setcolor( _getpixel( x, y ) + 1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _setpixel( x, y );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD><TT> _setpixel - DOS</TT>
<BR><BR><TT>_setpixel_w - DOS</TT>
</DL>
<H2 ID="_setplotaction"> _setplotaction </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>short _FAR _setplotaction( short action );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _setplotaction</TT> function sets the current plotting action to the value of the<B> action</B> argument.
<BR><BR>The drawing functions cause pixels to be set with a pixel value.&nbsp; By default, the value to be set is obtained
by replacing the original pixel value with the supplied pixel value.&nbsp; Alternatively, the replaced value may be computed
as a function of the original and the supplied pixel values.
<BR><BR>The plotting action can have one of the following values:
<DL>
<DT>_GPSET
<DD>replace the original screen pixel value with the supplied pixel value
<DT>_GAND
<DD>replace the original screen pixel value with the<B> bitwise and</B> of the original pixel value and the supplied pixel value
<DT>_GOR
<DD>replace the original screen pixel value with the<B> bitwise or</B> of the original pixel value and the supplied pixel value
<DT>_GXOR
<DD>replace the original screen pixel value with the<B> bitwise exclusive-or</B> of the original pixel value and the supplied
pixel value.&nbsp; Performing this operation twice will restore the original screen contents, providing an efficient method
to produce animated effects.
</DL>
</DL>
<DL>
<DT>Returns:
<DD>The previous value of the plotting action is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getplotaction">_getplotaction</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int old_act;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; old_act = _getplotaction();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setplotaction( _GPSET );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _rectangle( _GFILLINTERIOR, 100, 100, 540, 380 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setplotaction( _GXOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _rectangle( _GFILLINTERIOR, 100, 100, 540, 380 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setplotaction( old_act );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="setprotoent"> setprotoent </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;netdb.h&gt;</TT>
<BR><TT>void setprotoent( int stayopen );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> setprotoent</TT> function opens or rewinds the protocol database to allow reading starting at the first entry.&nbsp;
If<B> stayopen</B> is non-zero, the database will remain open between subsequent calls to <TT> getprotoent</TT> until the
<TT> endprotoent</TT> function is called.
<BR><BR>This function is not thread-safe.&nbsp; Other calls to this function or to other functions accessing the protocol
database may affect the return value from this function.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#getprotoent">getprotoent</A>, <A HREF="#endprotoent">endprotoent</A>, <A HREF="#getprotobyname">getprotobyname</A>,
<A HREF="#getprotobynumber">getprotobynumber</A>
</DL>
<DL>
<DT>Classification:
<DD>POSIX
</DL>
<DL>
<DT>Systems:
<DD>Linux
</DL>
<H2 ID="setpwent"> setpwent </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;pwd.h&gt;</TT>
<BR><TT>void setpwent( void );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> setpwent</TT> function returns pointer for iterating over the system's password database to the first entry.&nbsp;
It is normally called prior to using any of the POSIX functions that access the password database to ensure starting at the
first entry.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#getpwent">getpwent</A>, <A HREF="#endpwent">endpwent</A>, <A HREF="#getpwnam">getpwnam</A>, <A HREF="#getpwuid">getpwuid</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR>The following program will print out each user and their user ID in the system's password database
<BR><BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;pwd.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct passwd *pw;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; setpwent();</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; while((pw = getpwent()) != NULL) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;User id %d is %s\n&quot;, (int)pw-&gt;pw_uid, pw-&gt;pw_name);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; endpwent();</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>POSIX
</DL>
<DL>
<DT>Systems:
<DD>Linux
</DL>
<H2 ID="setservent"> setservent </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;netdb.h&gt;</TT>
<BR><TT>void setservent( int stayopen );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> setservent</TT> function opens or rewinds the service database.&nbsp; If<B> stayopen</B> is non-zero, the database
will be kept open between calls to <TT> getservent</TT> until <TT> endservent</TT> is called to close the database.
<BR><BR>This function is not thread-safe.&nbsp; Other calls to this function or to other functions accessing the hostname
database may affect the return value from this function.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#getservent">getservent</A>, <A HREF="#endservent">endservent</A>, <A HREF="#getservbyname">getservbyname</A>, <A HREF="#getservbyport">getservbyport</A>
</DL>
<DL>
<DT>Classification:
<DD>POSIX
</DL>
<DL>
<DT>Systems:
<DD>Linux
</DL>
<H2 ID="_settextalign"> _settextalign </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>void _FAR _settextalign( short horiz, short vert );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _settextalign</TT> function sets the current text alignment to the values specified by the arguments<B> horiz</B>
and<B> vert</B>.&nbsp; When text is displayed with the <TT> _grtext</TT> function, it is aligned (justified) horizontally
and vertically about the given point according to the current text alignment settings.
<BR><BR>The horizontal component of the alignment can have one of the following values:
<DL>
<DT>_NORMAL
<DD>use the default horizontal alignment for the current setting of the text path
<DT>_LEFT
<DD>the text string is left justified at the given point
<DT>_CENTER
<DD>the text string is centred horizontally about the given point
<DT>_RIGHT
<DD>the text string is right justified at the given point
</DL>
<BR>The vertical component of the alignment can have one of the following values:
<DL>
<DT>_NORMAL
<DD>use the default vertical alignment for the current setting of the text path
<DT>_TOP
<DD>the top of the text string is aligned at the given point
<DT>_CAP
<DD>the cap line of the text string is aligned at the given point
<DT>_HALF
<DD>the text string is centred vertically about the given point
<DT>_BASE
<DD>the base line of the text string is aligned at the given point
<DT>_BOTTOM
<DD>the bottom of the text string is aligned at the given point
</DL>
<BR>The default is to use<TT> _LEFT</TT> alignment for the horizontal component unless the text path is<TT> _PATH_LEFT,</TT>
in which case<TT> _RIGHT</TT> alignment is used.&nbsp; The default value for the vertical component is<TT> _TOP</TT> unless
the text path is<TT> _PATH_UP,</TT> in which case<TT> _BOTTOM</TT> alignment is used.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _settextalign</TT> function does not return a value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_grtext">_grtext</A>, <A HREF="#_gettextsettings">_gettextsettings</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _grtext( 200, 100, &quot;WATCOM&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setpixel( 200, 100 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _settextalign( _CENTER, _HALF );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _grtext( 200, 200, &quot;Graphics&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setpixel( 200, 200 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><IMG SRC="eg_setta.bmp" ALIGN=MIDDLE>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_settextcolor"> _settextcolor </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>short _FAR _settextcolor( short pixval );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _settextcolor</TT> function sets the current text color to be the color indicated by the pixel value of the<B> pixval</B>
argument.&nbsp; This is the color value used for displaying text with the <TT> _outtext</TT> and <TT> _outmem</TT> functions.
&nbsp;Use the <TT> _setcolor</TT> function to change the color of graphics output.&nbsp; The default text color value is set
to 7 whenever a new video mode is selected.
<BR><BR>The pixel value<B> pixval</B> is a number in the range 0-31.&nbsp; Colors in the range 0-15 are displayed normally.
&nbsp;In text modes, blinking colors are specified by adding 16 to the normal color values.&nbsp; The following table specifies
the default colors in color text modes.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Pixel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Color&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Pixel
&nbsp;&nbsp;&nbsp;&nbsp; Color</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; value&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; value</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Black&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Gray</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Blue&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; 9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Light Blue</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Green&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; 10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Light Green</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Cyan&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; 11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Light Cyan</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Red&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; 12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Light Red</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Magenta&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Light Magenta</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Brown&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; 14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Yellow</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; White&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; 15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Bright White</TT>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _settextcolor</TT> function returns the pixel value of the previous text color.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_gettextcolor">_gettextcolor</A>, <A HREF="#_outtext">_outtext</A>, <A HREF="#_outmem">_outmem</A>, <A HREF="#_setcolor">_setcolor</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int old_col;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; long old_bk;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _TEXTC80 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; old_col = _gettextcolor();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; old_bk = _getbkcolor();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _settextcolor( 7 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setbkcolor( _BLUE );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _outtext( &quot; WATCOM \nGraphics&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _settextcolor( old_col );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setbkcolor( old_bk );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_settextcursor"> _settextcursor </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>short _FAR _settextcursor( short cursor );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _settextcursor</TT> function sets the attribute, or shape, of the cursor in text modes.&nbsp; The argument<B> cursor</B>
specifies the new cursor shape.&nbsp; The cursor shape is selected by specifying the top and bottom rows in the character
matrix.&nbsp; The high byte of<B> cursor</B> specifies the top row of the cursor; the low byte specifies the bottom row.
<BR><BR>Some typical values for<B> cursor</B> are:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Cursor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Shape</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0x0607&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; normal underline cursor</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0x0007&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; full block cursor</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0x0407&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; half-height block cursor</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0x2000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; no cursor</TT>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _settextcursor</TT> function returns the previous cursor shape when the shape is set successfully; otherwise, (-1)
is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_gettextcursor">_gettextcursor</A>, <A HREF="#_displaycursor">_displaycursor</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int old_shape;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; old_shape = _gettextcursor();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _settextcursor( 0x0007 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _outtext( &quot;\nBlock cursor&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _settextcursor( 0x0407 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _outtext( &quot;\nHalf height cursor&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _settextcursor( 0x2000 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _outtext( &quot;\nNo cursor&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _settextcursor( old_shape );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_settextorient"> _settextorient </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>void _FAR _settextorient( short vecx, short vecy );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _settextorient</TT> function sets the current text orientation to the vector specified by the arguments<TT> (vecx,vecy).</TT>
&nbsp;The text orientation specifies the direction of the base-line vector when a text string is displayed with the <TT> _grtext</TT>
function.&nbsp; The default text orientation, for normal left-to-right text, is the vector<TT> (1,0).</TT>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _settextorient</TT> function does not return a value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_grtext">_grtext</A>, <A HREF="#_gettextsettings">_gettextsettings</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _grtext( 200, 100, &quot;WATCOM&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _settextorient( 1, 1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _grtext( 200, 200, &quot;Graphics&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><IMG SRC="eg_setto.bmp" ALIGN=MIDDLE>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_settextpath"> _settextpath </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>void _FAR _settextpath( short path );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _settextpath</TT> function sets the current text path to have the value of the<B> path</B> argument.&nbsp; The text
path specifies the writing direction of the text displayed by the <TT> _grtext</TT> function.&nbsp; The argument can have
one of the following values:
<DL>
<DT>_PATH_RIGHT
<DD>subsequent characters are drawn to the right of the previous character
<DT>_PATH_LEFT
<DD>subsequent characters are drawn to the left of the previous character
<DT>_PATH_UP
<DD>subsequent characters are drawn above the previous character
<DT>_PATH_DOWN
<DD>subsequent characters are drawn below the previous character
</DL>
<BR>The default value of the text path is<TT> _PATH_RIGHT.</TT>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _settextpath</TT> function does not return a value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_grtext">_grtext</A>, <A HREF="#_gettextsettings">_gettextsettings</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _grtext( 200, 100, &quot;WATCOM&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _settextpath( _PATH_DOWN );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _grtext( 200, 200, &quot;Graphics&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><IMG SRC="eg_settx.bmp" ALIGN=MIDDLE>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_settextposition"> _settextposition </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>struct rccoord _FAR _settextposition( short row,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short col );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _settextposition</TT> function sets the current output position for text to be<TT> (row,col)</TT> where this position
is in terms of characters, not pixels.
<BR><BR>The text position is relative to the current text window.&nbsp; It defaults to the top left corner of the screen,<TT>
(1,1),</TT> when a new video mode is selected, or when a new text window is set.&nbsp; The position is updated as text is
drawn with the <TT> _outtext</TT> and <TT> _outmem</TT> functions.
<BR><BR>Note that the output position for graphics output differs from that for text output.&nbsp; The output position for
graphics output can be set by use of the <TT> _moveto</TT> function.
<BR><BR>Also note that output to the standard output file, <TT> stdout</TT>, is line buffered by default.&nbsp; It may be
necessary to flush the output stream using<TT> fflush( stdout )</TT> after a <TT> printf</TT> call if your output does not
contain a newline character.&nbsp; Mixing of calls to <TT> _outtext</TT> and <TT> printf</TT> may cause overlapped text since
<TT> _outtext</TT> uses the output position that was set by _settextposition.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _settextposition</TT> function returns, as an<TT> rccoord</TT> structure, the previous output position for text.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_gettextposition">_gettextposition</A>, <A HREF="#_outtext">_outtext</A>, <A HREF="#_outmem">_outmem</A>, <A HREF="#_settextwindow">_settextwindow</A>,
<A HREF="#_moveto">_moveto</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct rccoord old_pos;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _TEXTC80 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; old_pos = _gettextposition();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _settextposition( 10, 40 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _outtext( &quot;WATCOM Graphics&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _settextposition( old_pos.row, old_pos.col );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_settextrows"> _settextrows </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>short _FAR _settextrows( short rows );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _settextrows</TT> function selects the number of rows of text displayed on the screen.&nbsp; The number of rows is
specified by the argument<B> rows</B>.&nbsp; Computers equipped with EGA, MCGA and VGA adapters can support different numbers
of text rows.&nbsp; The number of rows that can be selected depends on the current video mode and the type of monitor attached.
<BR><BR>If the argument<B> rows</B> has the value<B> _MAXTEXTROWS</B>, the maximum number of text rows will be selected for
the current video mode and hardware configuration.&nbsp; In text modes the maximum number of rows is 43 for EGA adapters,
and 50 for MCGA and VGA adapters.&nbsp; Some graphics modes will support 43 rows for EGA adapters and 60 rows for MCGA and
VGA adapters.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _settextrows</TT> function returns the number of screen rows when the number of rows is set successfully; otherwise,
zero is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getvideoconfig">_getvideoconfig</A>, <A HREF="#_setvideomode">_setvideomode</A>, <A HREF="#_setvideomoderows">_setvideomoderows</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>int valid_rows[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 14, 25, 28, 30,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 34, 43, 50, 60</TT>
<BR><TT>};</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int i, j, rows;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char buf[ 80 ];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; 8; ++i ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rows = valid_rows[ i ];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( _settextrows( rows ) == rows ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( j = 1; j &lt;= rows; ++j ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf( buf, &quot;Line
%d&quot;, j );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _settextposition( j, 1
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _outtext( buf );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_settextwindow"> _settextwindow </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>void _FAR _settextwindow( short row1, short col1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short row2, short col2 );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _settextwindow</TT> function sets the text window to be the rectangle with a top left corner at<TT> (row1,col1)</TT>
and a bottom right corner at<TT> (row2,col2).</TT>&nbsp; These coordinates are in terms of characters not pixels.
<BR><BR>The initial text output position is<TT> (1,1).</TT>&nbsp; Subsequent text positions are reported (by the <TT> _gettextposition</TT>
function) and set (by the <TT> _outtext</TT>, <TT> _outmem</TT> and <TT> _settextposition</TT> functions) relative to this
rectangle.
<BR><BR>Text is displayed from the current output position for text proceeding along the current row and then downwards.&nbsp;
When the window is full, the lines scroll upwards one line and then text is displayed on the last line of the window.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _settextwindow</TT> function does not return a value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_gettextposition">_gettextposition</A>, <A HREF="#_outtext">_outtext</A>, <A HREF="#_outmem">_outmem</A>, <A HREF="#_settextposition">_settextposition</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int i;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; short r1, c1, r2, c2;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char buf[ 80 ];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _TEXTC80 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _gettextwindow( &amp;r1, &amp;c1, &amp;r2, &amp;c2 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _settextwindow( 5, 20, 20, 40 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 1; i &lt;= 20; ++i ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf( buf, &quot;Line %d\n&quot;, i );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _outtext( buf );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _settextwindow( r1, c1, r2, c2 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="setvbuf"> setvbuf </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>int setvbuf( FILE *fp,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *buf,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int mode,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t size );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> setvbuf</TT> function can be used to associate a buffer with the file designated by<B> fp</B>.&nbsp; If this function
is used, it must be called after the file has been opened and before it has been read or written.&nbsp; The argument<B> mode</B>
determines how the file<B> fp</B> will be buffered, as follows:
<DL>
<DT>Mode&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>_IOFBF
<DD>causes input/output to be fully buffered.
<DT>_IOLBF
<DD>causes output to be line buffered (the buffer will be flushed when a new-line character is written, when the buffer is full,
or when input is requested on a line buffered or unbuffered stream).
<DT>_IONBF
<DD>causes input/output to be completely unbuffered.
</DL>
<BR>If the argument<B> buf</B> is not<TT> NULL,</TT> the array to which it points will be used instead of an automatically
allocated buffer.&nbsp; The argument<B> size</B> specifies the size of the array.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> setvbuf</TT> function returns zero on success, or a non-zero value if an invalid value is given for<B> mode</B> or<B>
size</B>.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#fopen">fopen</A>, <A HREF="#setbuf">setbuf</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp; char *buf;</TT>
<BR><TT>&nbsp; FILE *fp;</TT>
<BR><BR><TT>&nbsp; fp = fopen( &quot;file&quot;, &quot;r&quot; );</TT>
<BR><TT>&nbsp; buf = (char *) malloc( 1024 );</TT>
<BR><TT>&nbsp; setvbuf( fp, buf, _IOFBF, 1024 );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="_setvideomode"> _setvideomode </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>short _FAR _setvideomode( short mode );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _setvideomode</TT> function sets the video mode according to the value of the<B> mode</B> argument.&nbsp; The value
of<B> mode</B> can be one of the following:&nbsp; uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 uindex=2
uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 uindex=2
uindex=2 uindex=2 uindex=2 
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Mode&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Type&nbsp;&nbsp;&nbsp; Size
&nbsp;&nbsp; Colors&nbsp;&nbsp;&nbsp; Adapter</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _MAXRESMODE&nbsp;&nbsp; (graphics mode with highest resolution)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _MAXCOLORMODE (graphics mode with most colors)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _DEFAULTMODE&nbsp; (restores screen to original mode)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXTBW40&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; M,T&nbsp;&nbsp;&nbsp; 40 x 25&nbsp;&nbsp;&nbsp; 16
&nbsp; MDPA,HGC,VGA,SVGA</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXTC40&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C,T&nbsp;&nbsp;&nbsp; 40 x 25&nbsp;&nbsp;&nbsp;
16&nbsp;&nbsp; CGA,EGA,MCGA,VGA,SVGA</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXTBW80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; M,T&nbsp;&nbsp;&nbsp; 80 x 25&nbsp;&nbsp;&nbsp; 16
&nbsp; MDPA,HGC,VGA,SVGA</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXTC80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C,T&nbsp;&nbsp;&nbsp; 80 x 25&nbsp;&nbsp;&nbsp;
16&nbsp;&nbsp; CGA,EGA,MCGA,VGA,SVGA</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _MRES4COLOR&nbsp;&nbsp;&nbsp; C,G&nbsp;&nbsp; 320 x 200&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp; CGA,EGA,MCGA,VGA,SVGA</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _MRESNOCOLOR&nbsp;&nbsp; C,G&nbsp;&nbsp; 320 x 200&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp; CGA,EGA,MCGA,VGA,SVGA</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _HRESBW&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C,G&nbsp;&nbsp; 640 x 200&nbsp;&nbsp;&nbsp;
2&nbsp;&nbsp; CGA,EGA,MCGA,VGA,SVGA</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXTMONO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; M,T&nbsp;&nbsp;&nbsp; 80 x 25&nbsp;&nbsp;&nbsp; 16
&nbsp; MDPA,HGC,VGA,SVGA</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _HERCMONO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; M,G&nbsp;&nbsp; 720 x 350&nbsp;&nbsp;&nbsp; 2&nbsp;
&nbsp;HGC</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _MRES16COLOR&nbsp;&nbsp; C,G&nbsp;&nbsp; 320 x 200&nbsp;&nbsp; 16&nbsp;&nbsp; EGA,VGA,SVGA</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _HRES16COLOR&nbsp;&nbsp; C,G&nbsp;&nbsp; 640 x 200&nbsp;&nbsp; 16&nbsp;&nbsp; EGA,VGA,SVGA</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _ERESNOCOLOR&nbsp;&nbsp; M,G&nbsp;&nbsp; 640 x 350&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp; EGA,VGA,SVGA</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _ERESCOLOR&nbsp;&nbsp;&nbsp;&nbsp; C,G&nbsp;&nbsp; 640 x 350&nbsp; 4/16&nbsp; EGA,VGA,SVGA</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _VRES2COLOR&nbsp;&nbsp;&nbsp; C,G&nbsp;&nbsp; 640 x 480&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp; MCGA,VGA,SVGA</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _VRES16COLOR&nbsp;&nbsp; C,G&nbsp;&nbsp; 640 x 480&nbsp;&nbsp; 16&nbsp;&nbsp; VGA,SVGA</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _MRES256COLOR&nbsp; C,G&nbsp;&nbsp; 320 x 200&nbsp; 256&nbsp;&nbsp; MCGA,VGA,SVGA</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _URES256COLOR&nbsp; C,G&nbsp;&nbsp; 640 x 400&nbsp; 256&nbsp;&nbsp; SVGA</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _VRES256COLOR&nbsp; C,G&nbsp;&nbsp; 640 x 480&nbsp; 256&nbsp;&nbsp; SVGA</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _SVRES16COLOR&nbsp; C,G&nbsp;&nbsp; 800 x 600&nbsp;&nbsp; 16&nbsp;&nbsp; SVGA</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _SVRES256COLOR C,G&nbsp;&nbsp; 800 x 600&nbsp; 256&nbsp;&nbsp; SVGA</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _XRES16COLOR&nbsp;&nbsp; C,G&nbsp; 1024 x 768&nbsp;&nbsp; 16&nbsp;&nbsp; SVGA</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _XRES256COLOR&nbsp; C,G&nbsp; 1024 x 768&nbsp; 256&nbsp;&nbsp; SVGA</TT>
<BR><BR>In the preceding table, the Type column contains the following letters:
<DL>
<DT>M
<DD>indicates monochrome; multiple colors are shades of grey
<DT>C
<DD>indicates color
<DT>G
<DD>indicates graphics mode; size is in pixels
<DT>T
<DD>indicates text mode; size is in columns and rows of characters
</DL>
<BR>The Adapter column contains the following codes:
<DL>
<DT>MDPA
<DD>IBM Monochrome Display/Printer Adapter
<DT>CGA
<DD>IBM Color Graphics Adapter
<DT>EGA
<DD>IBM Enhanced Graphics Adapter
<DT>VGA
<DD>IBM Video Graphics Array
<DT>MCGA
<DD>IBM Multi-Color Graphics Array
<DT>HGC
<DD>Hercules Graphics Adapter
<DT>SVGA
<DD>SuperVGA adapters
</DL>
<BR>The modes<TT> _MAXRESMODE</TT> and<TT> _MAXCOLORMODE</TT> will select from among the video modes supported by the current
graphics adapter the one that has the highest resolution or the greatest number of colors.&nbsp; The video mode will be selected
from the standard modes, not including the SuperVGA modes.
<BR><BR>Selecting a new video mode resets the current output positions for graphics and text to be the top left corner of
the screen.&nbsp; The background color is reset to black and the default color value is set to be one less than the number
of colors in the selected mode.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _setvideomode</TT> function returns the number of text rows when the new mode is successfully selected; otherwise,
zero is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getvideoconfig">_getvideoconfig</A>, <A HREF="#_settextrows">_settextrows</A>, <A HREF="#_setvideomoderows">_setvideomoderows</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int mode;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct videoconfig vc;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char buf[ 80 ];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _getvideoconfig( &amp;vc );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* select &quot;best&quot; video mode */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; switch( vc.adapter ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; case _VGA :</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; case _SVGA :</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode = _VRES16COLOR;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; case _MCGA :</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode = _MRES256COLOR;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; case _EGA :</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( vc.monitor == _MONO ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode = _ERESNOCOLOR;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode = _ERESCOLOR;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; case _CGA :</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode = _MRES4COLOR;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; case _HERCULES :</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode = _HERCMONO;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; default :</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; puts( &quot;No graphics adapter&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit( 1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( _setvideomode( mode ) ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _getvideoconfig( &amp;vc );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf( buf, &quot;%d x %d x %d\n&quot;, vc.numxpixels,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; vc.numypixels, vc.numcolors );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _outtext( buf );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_setvideomoderows"> _setvideomoderows </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>short _FAR _setvideomoderows( short mode, short rows );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _setvideomoderows</TT> function selects a video mode and the number of rows of text displayed on the screen.&nbsp;
The video mode is specified by the argument<B> mode</B> and is selected with the <TT> _setvideomode</TT> function.&nbsp; The
number of rows is specified by the argument<B> rows</B> and is selected with the <TT> _settextrows</TT> function.
<BR><BR>Computers equipped with EGA, MCGA and VGA adapters can support different numbers of text rows.&nbsp; The number of
rows that can be selected depends on the video mode and the type of monitor attached.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _setvideomoderows</TT> function returns the number of screen rows when the mode and number of rows are set successfully;
otherwise, zero is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getvideoconfig">_getvideoconfig</A>, <A HREF="#_setvideomode">_setvideomode</A>, <A HREF="#_settextrows">_settextrows</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int rows;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char buf[ 80 ];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; rows = _setvideomoderows( _TEXTC80, _MAXTEXTROWS );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( rows != 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf( buf, &quot;Number of rows is %d\n&quot;, rows );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _outtext( buf );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_setvieworg"> _setvieworg </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>struct xycoord _FAR _setvieworg( short x, short y );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _setvieworg</TT> function sets the origin of the view coordinate system,<TT> (0,0),</TT> to be located at the physical
point<TT> (x,y).</TT>&nbsp; This causes subsequently drawn images to be translated by the amount<TT> (x,y).</TT>
<BR><BR><B>Note:</B>&nbsp; In previous versions of the software, the<TT> _setvieworg</TT> function was called<TT> _setlogorg.</TT>
&nbsp;uindex=2 
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _setvieworg</TT> function returns, as an<TT> xycoord</TT> structure, the physical coordinates of the previous origin.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getviewcoord">_getviewcoord</A>, <A HREF="#_getphyscoord">_getphyscoord</A>, <A HREF="#_setcliprgn">_setcliprgn</A>,
<A HREF="#_setviewport">_setviewport</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvieworg( 320, 240 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _ellipse( _GBORDER, -200, -150, 200, 150 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_setviewport"> _setviewport </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>void _FAR _setviewport( short x1, short y1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; short x2, short y2 );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _setviewport</TT> function restricts the display of graphics output to the clipping region and then sets the origin
of the view coordinate system to be the top left corner of the region.&nbsp; This region is a rectangle whose opposite corners
are established by the physical points<TT> (x1,y1)</TT> and<TT> (x2,y2).</TT>
<BR><BR>The<TT> _setviewport</TT> function does not affect text output using the <TT> _outtext</TT> and <TT> _outmem</TT>
functions.&nbsp; To control the location of text output, see the <TT> _settextwindow</TT> function.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _setviewport</TT> function does not return a value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_setcliprgn">_setcliprgn</A>, <A HREF="#_setvieworg">_setvieworg</A>, <A HREF="#_settextwindow">_settextwindow</A>,
<A HREF="#_setwindow">_setwindow</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><BR><TT>#define XSIZE 380</TT>
<BR><TT>#define YSIZE 280</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setviewport( 130, 100, 130 + XSIZE, 100 + YSIZE );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _ellipse( _GBORDER, 0, 0, XSIZE, YSIZE );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_setvisualpage"> _setvisualpage </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>short _FAR _setvisualpage( short pagenum );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _setvisualpage</TT> function selects the page (in memory) from which graphics output is displayed.&nbsp; The page
to be selected is given by the<B> pagenum</B> argument.
<BR><BR>Only some combinations of video modes and hardware allow multiple pages of graphics to exist.&nbsp; When multiple
pages are supported, the active page may differ from the visual page.&nbsp; The graphics information in the visual page determines
what is displayed upon the screen.&nbsp; Animation may be accomplished by alternating the visual page.&nbsp; A graphics page
can be constructed without affecting the screen by setting the active page to be different than the visual page.
<BR><BR>The number of available video pages can be determined by using the <TT> _getvideoconfig</TT> function.&nbsp; The default
video page is 0.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _setvisualpage</TT> function returns the number of the previous page when the visual page is set successfully; otherwise,
a negative number is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_getvisualpage">_getvisualpage</A>, <A HREF="#_setactivepage">_setactivepage</A>, <A HREF="#_getactivepage">_getactivepage</A>,
<A HREF="#_getvideoconfig">_getvideoconfig</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int old_apage;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int old_vpage;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _HRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; old_apage = _getactivepage();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; old_vpage = _getvisualpage();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* draw an ellipse on page 0 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setactivepage( 0 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvisualpage( 0 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _ellipse( _GFILLINTERIOR, 100, 50, 540, 150 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* draw a rectangle on page 1 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setactivepage( 1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _rectangle( _GFILLINTERIOR, 100, 50, 540, 150 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* display page 1 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvisualpage( 1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setactivepage( old_apage );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvisualpage( old_vpage );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="_setwindow"> _setwindow </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>short _FAR _setwindow( short invert,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; double x1, double y1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; double x2, double y2 );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _setwindow</TT> function defines a window for the window coordinate system.&nbsp; Window coordinates are specified
as a user-defined range of values.&nbsp; This allows for consistent pictures regardless of the video mode.
<BR><BR>The window is defined as the region with opposite corners established by the points<TT> (x1,y1)</TT> and<TT> (x2,y2).</TT>
&nbsp;The argument<B> invert</B> specifies the direction of the y-axis.&nbsp; If the value is non-zero, the y values increase
from the bottom of the screen to the top, otherwise, the y values increase as you move down the screen.
<BR><BR>The window defined by the<TT> _setwindow</TT> function is displayed in the current viewport.&nbsp; A viewport is defined
by the <TT> _setviewport</TT> function.
<BR><BR>By default, the window coordinate system is defined with the point<TT> (0.0,0.0)</TT> located at the lower left corner
of the screen, and the point<TT> (1.0,1.0)</TT> at the upper right corner.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _setwindow</TT> function returns a non-zero value when the window is set successfully; otherwise, zero is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_setviewport">_setviewport</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _MAXRESMODE );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; draw_house( &quot;Default window&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setwindow( 1, -0.5, -0.5, 1.5, 1.5 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; draw_house( &quot;Larger window&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setwindow( 1, 0.0, 0.0, 0.5, 1.0 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; draw_house( &quot;Left side&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
<BR><BR><TT>draw_house( char *msg )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _clearscreen( _GCLEARSCREEN );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _outtext( msg );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _rectangle_w( _GBORDER, 0.2, 0.1, 0.8, 0.6 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _moveto_w( 0.1, 0.5 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _lineto_w( 0.5, 0.9 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _lineto_w( 0.9, 0.5 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _arc_w( 0.4, 0.5, 0.6, 0.3, 0.6, 0.4, 0.4, 0.4 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _rectangle_w( _GBORDER, 0.4, 0.1, 0.6, 0.4 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="signal"> signal </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;signal.h&gt;</TT>
<BR><TT>void ( *signal(int sig, void (*func)(int)) )( int );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> signal</TT> function is used to specify an action to take place when certain conditions are detected while a program
executes.&nbsp; These conditions are defined to be:
<DL>
<DT>Condition&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>SIGABRT
<DD>abnormal termination, such as caused by the <TT> abort</TT> function
<DT>SIGBREAK
<DD>an interactive attention (Ctrl+Break on keyboard) is signalled
<DT>SIGFPE
<DD>an erroneous floating-point operation occurs (such as division by zero, overflow and underflow)
<DT>SIGILL
<DD>illegal instruction encountered
<DT>SIGINT
<DD>an interactive attention (Ctrl+C on keyboard) is signalled
<DT>SIGSEGV
<DD>an illegal memory reference is detected
<DT>SIGTERM
<DD>a termination request is sent to the program
<DT>SIGUSR1
<DD>OS/2 process flag A via DosFlagProcess
<DT>SIGUSR2
<DD>OS/2 process flag B via DosFlagProcess
<DT>SIGUSR3
<DD>OS/2 process flag C via DosFlagProcess
</DL>
<BR>An action can be specified for each of the conditions, depending upon the value of the<B> func</B> argument:
<DL>
<DT>function
<DD>When<B> func</B> is a function name, that function will be called equivalently to the following code sequence.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* &quot;sig_no&quot; is condition being signalled */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signal( sig_no, SIG_DFL );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (*func)( sig_no );</TT>
<BR><BR>The<B> func</B> function may terminate the program by calling the <TT> exit</TT> or <TT> abort</TT> functions or call
the <TT> longjmp</TT> function.&nbsp; Because the next signal will be handled with default handling, the program must again
call<TT> signal</TT> if it is desired to handle the next condition of the type that has been signalled.
<BR><BR>After returning from the signal-catching function, the receiving process will resume execution at the point at which
it was interrupted.
<BR><BR>The signal catching function is described as follows:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void func( int sig_no )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* body of function */</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>Since signal-catching functions are invoked asynchronously with process execution, the type <TT> sig_atomic_t</TT>
may be used to define variables on which an atomic operation (e.g., incrementation, decrementation) may be performed.
<DT>SIG_DFL
<DD>This value causes the default action for the condition to occur.
<DT>SIG_IGN
<DD>This value causes the indicated condition to be ignored.
</DL>
<BR>When a condition is detected, it may be handled by a program, it may be ignored, or it may be handled by the usual default
action (often causing an error message to be printed upon the<TT> stderr</TT> stream followed by program termination).
<BR><BR>When the program begins execution, the equivalent of
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signal( SIGABRT, SIG_DFL );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signal( SIGFPE, SIG_DFL );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signal( SIGILL, SIG_DFL );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signal( SIGINT, SIG_DFL );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signal( SIGSEGV, SIG_DFL );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signal( SIGTERM, SIG_DFL );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signal( SIGBREAK, SIG_DFL );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signal( SIGUSR1, SIG_IGN );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signal( SIGUSR2, SIG_IGN );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signal( SIGUSR3, SIG_IGN );</TT>
<BR><BR>is executed.
<BR><BR>The <TT> SIGINT</TT> signal is generated by pressing the Ctrl+C or Ctrl+Break key combination on the keyboard.&nbsp;
Under DOS, if &quot;BREAK=ON&quot;, a signal will be delivered at the next DOS call; otherwise, if &quot;BREAK=OFF&quot;,
a signal will be delivered only at the next standard input/output DOS call.&nbsp; The <TT> BREAK</TT> setting is configured
in the<TT> CONFIG.SYS</TT> file.
<BR><BR>Under OS/2, the <TT> SIGBREAK</TT> signal can only be received if Ctrl+Break is pressed and the keyboard is in binary
(raw) mode.&nbsp; In ASCII (cooked) mode, which is the default, both Ctrl+C and Ctrl+Break combinations will raise the <TT>
SIGINT</TT> signal.
<BR><BR>A condition can be generated by a program using the <TT> raise</TT> function.
</DL>
<DL>
<DT>Returns:
<DD>A return value of <TT> SIG_ERR</TT> indicates that the request could not be handled, and <TT> errno</TT> is set to the value
<TT> EINVAL</TT>.
<BR><BR>Otherwise, the previous value of<B> func</B> for the indicated condition is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#raise">raise</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;signal.h&gt;</TT>
<BR><TT>#include &lt;i86.h&gt;</TT>
<BR><BR><TT>/* SIGINT Test */</TT>
<BR><BR><TT>sig_atomic_t signal_count;</TT>
<BR><TT>sig_atomic_t signal_number;</TT>
<BR><BR><TT>void MyIntHandler( int signo )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; signal_count++;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; signal_number = signo;</TT>
<BR><TT>}</TT>
<BR><BR><TT>void MyBreakHandler( int signo )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; signal_count++;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; signal_number = signo;</TT>
<BR><TT>}</TT>
<BR><BR><TT>int main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; signal_count = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; signal_number = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; signal( SIGINT, MyIntHandler );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; signal( SIGBREAK, MyBreakHandler );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Press Ctrl+C or Ctrl+Break\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; 50; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Iteration # %d\n&quot;, i );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delay( 500 ); /* sleep for 1/2 second */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( signal_count &gt; 0 ) break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;SIGINT count %d number %d\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
signal_count, signal_number );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; signal_count = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; signal_number = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; signal( SIGINT, SIG_DFL );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Default action */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; signal( SIGBREAK, SIG_DFL );&nbsp;&nbsp;&nbsp; /* Default action */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Default signal handling\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; 50; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Iteration # %d\n&quot;, i );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delay( 500 ); /* sleep for 1/2 second */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( signal_count &gt; 0 ) break; /* Won't happen */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; return( signal_count );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="signbit"> signbit </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>int signbit( x );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> signbit</TT> macro determines whether the sign of its argument value is negative.
<BR><BR>The argument<B> x</B> must be an expression of real floating type.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> signbit</TT> macro returns a nonzero value if and only if the sign of its argument has value is negative.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#fpclassify">fpclassify</A>, <A HREF="#isfinite">isfinite</A>, <A HREF="#isinf">isinf</A>, <A HREF="#isnan">isnan</A>,
<A HREF="#isnormal">isnormal</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;-4.5 %s negative\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signbit( -4.5 ) ? &quot;is&quot; : &quot;is not&quot; );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>-4.5 is negative</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="sin"> sin </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>double sin( double x );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> sin</TT> function computes the sine of<B> x</B> (measured in radians).&nbsp; A large magnitude argument may yield
a result with little or no significance.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> sin</TT> function returns the sine value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#acos">acos</A>, <A HREF="#asin">asin</A>, <A HREF="#atan">atan</A>, <A HREF="#atan2">atan2</A>, <A HREF="#cos">cos</A>,
<A HREF="#tan">tan</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, sin(.5) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>0.479426</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD>Math
</DL>
<H2 ID="sinh"> sinh </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>double sinh( double x );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> sinh</TT> function computes the hyperbolic sine of<B> x</B>.&nbsp; A range error occurs if the magnitude of<B> x</B>
is too large.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> sinh</TT> function returns the hyperbolic sine value.&nbsp; When the argument is outside the permissible range, the
<TT> matherr</TT> function is called.&nbsp; Unless the default <TT> matherr</TT> function is replaced, it will set the global
variable <TT> errno</TT> to <TT> ERANGE</TT>, and print a &quot;RANGE error&quot; diagnostic message using the <TT> stderr</TT>
stream.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#cosh">cosh</A>, <A HREF="#tanh">tanh</A>, <A HREF="#matherr">matherr</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, sinh(.5) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>0.521095</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD>Math
</DL>
<H2 ID="mbsinit"> mbsinit, sisinit </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>int mbsinit( const mbstate_t *ps );</TT>
<BR><TT>int sisinit( const mbstate_t *ps );</TT>
</DL>
<DL>
<DT>Description:
<DD>If<B> ps</B> is not a null pointer, the<TT> mbsinit</TT> function determines whether the pointed-to <TT> mbstate_t</TT> object
describes an initial conversion state.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> mbsinit</TT> function returns nonzero if<B> ps</B> is a null pointer or if the pointed-to object describes an initial
conversion state; otherwise, it returns zero.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_mbccmp">_mbccmp</A>, <A HREF="#_mbccpy">_mbccpy</A>, <A HREF="#_mbcicmp">_mbcicmp</A>, <A HREF="#_mbcjistojms">_mbcjistojms</A>,
<A HREF="#_mbcjmstojis">_mbcjmstojis</A>, <A HREF="#_mbclen">_mbclen</A>, <A HREF="#_mbctohira">_mbctohira</A>, <A HREF="#_mbctokata">_mbctokata</A>,
<A HREF="#_mbctolower">_mbctolower</A>, <A HREF="#_mbctombb">_mbctombb</A>, <A HREF="#_mbctoupper">_mbctoupper</A>, <A HREF="#mblen">mblen</A>,
<A HREF="#mbrlen">mbrlen</A>, <A HREF="#mbrtowc">mbrtowc</A>, <A HREF="#mbsrtowcs">mbsrtowcs</A>, <A HREF="#mbsrtowcs_s">mbsrtowcs_s</A>,
<A HREF="#mbstowcs">mbstowcs</A>, <A HREF="#mbstowcs_s">mbstowcs_s</A>, <A HREF="#mbtowc">mbtowc</A>, <A HREF="#btowc">btowc</A>,
<A HREF="#wcrtomb">wcrtomb</A>, <A HREF="#wcrtomb_s">wcrtomb_s</A>, <A HREF="#wcsrtombs">wcsrtombs</A>, <A HREF="#wcsrtombs_s">wcsrtombs_s</A>,
<A HREF="#wcstombs">wcstombs</A>, <A HREF="#wcstombs_s">wcstombs_s</A>, <A HREF="#wctob">wctob</A>, <A HREF="#wctomb">wctomb</A>,
<A HREF="#wctomb_s">wctomb_s</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><TT>#include &lt;errno.h&gt;</TT>
<BR><BR><TT>const char chars[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ' ',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '.',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '1',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'A',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x81,0x40, /* double-byte space */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x82,0x60, /* double-byte A */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x82,0xA6, /* double-byte Hiragana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x83,0x42, /* double-byte Katakana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana punctuation */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA6,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xDF,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xE0,0xA1, /* double-byte Kanji */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x00</TT>
<BR><TT>};</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i, j, k;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; wchar_t&nbsp;&nbsp;&nbsp;&nbsp; pwc;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; mbstate_t&nbsp;&nbsp; pstate = { 0 };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; j = 1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; j &gt; 0; i += j ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;We are %sin an initial conversion state\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mbsinit( &amp;pstate ) ? &quot;not
&quot; : &quot;&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j = mbrtowc( &amp;pwc, &amp;chars[i], MB_CUR_MAX, &amp;pstate );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%d bytes in character &quot;, j );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( errno == EILSEQ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot; - illegal multibyte character\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( j == 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if ( j == 1 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = chars[i];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if( j == 2 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = chars[i]&lt;&lt;8 | chars[i+1];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;(%#6.4x-&gt;%#6.4x)\n&quot;, k, pwc );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>We are in an initial conversion state</TT>
<BR><TT>1 bytes in character (0x0020-&gt;0x0020)</TT>
<BR><TT>We are in an initial conversion state</TT>
<BR><TT>1 bytes in character (0x002e-&gt;0x002e)</TT>
<BR><TT>We are in an initial conversion state</TT>
<BR><TT>1 bytes in character (0x0031-&gt;0x0031)</TT>
<BR><TT>We are in an initial conversion state</TT>
<BR><TT>1 bytes in character (0x0041-&gt;0x0041)</TT>
<BR><TT>We are in an initial conversion state</TT>
<BR><TT>2 bytes in character (0x8140-&gt;0x3000)</TT>
<BR><TT>We are in an initial conversion state</TT>
<BR><TT>2 bytes in character (0x8260-&gt;0xff21)</TT>
<BR><TT>We are in an initial conversion state</TT>
<BR><TT>2 bytes in character (0x82a6-&gt;0x3048)</TT>
<BR><TT>We are in an initial conversion state</TT>
<BR><TT>2 bytes in character (0x8342-&gt;0x30a3)</TT>
<BR><TT>We are in an initial conversion state</TT>
<BR><TT>1 bytes in character (0x00a1-&gt;0xff61)</TT>
<BR><TT>We are in an initial conversion state</TT>
<BR><TT>1 bytes in character (0x00a6-&gt;0xff66)</TT>
<BR><TT>We are in an initial conversion state</TT>
<BR><TT>1 bytes in character (0x00df-&gt;0xff9f)</TT>
<BR><TT>We are in an initial conversion state</TT>
<BR><TT>2 bytes in character (0xe0a1-&gt;0x720d)</TT>
<BR><TT>We are in an initial conversion state</TT>
<BR><TT>0 bytes in character (&nbsp; 0000-&gt;&nbsp; 0000)</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C95
<BR><BR>sisinit is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> mbsinit - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>sisinit - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="sleep"> sleep </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><TT>unsigned sleep( unsigned seconds );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> sleep</TT> function suspends execution by the specified number of<B> seconds</B>.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> sleep</TT> function always returns zero.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#delay">delay</A>, <A HREF="#timer_create">timer_create</A>, <A HREF="#timer_gettime">timer_gettime</A>, <A HREF="#timer_settime">timer_settime</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>/*</TT>
<BR><TT> * The following program sleeps for the</TT>
<BR><TT> * number of seconds specified in argv[1].</TT>
<BR><TT> */</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><BR><TT>void main( int argc, char *argv[] )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned seconds;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; seconds = (unsigned) strtol( argv[1], NULL, 0 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; sleep( seconds );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="_snprintf"> _snprintf, _snwprintf </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>int _snprintf( char *buf,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t count,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *format, ... );</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>int _snwprintf( wchar_t *buf,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t count,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t *format,
... );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _snprintf</TT> function is equivalent to the <TT> fprintf</TT> function, except that the argument<B> buf</B> specifies
a character array into which the generated output is placed, rather than to a file.&nbsp; The maximum number of characters
to store is specified by<B> count</B>.&nbsp; A null character is placed at the end of the generated character string if fewer
than<B> count</B> characters were stored.&nbsp; The<B> format</B> string is described under the description of the <TT> printf</TT>
function.
<BR><BR>The<TT> _snwprintf</TT> function is a wide-character version of<TT> _snprintf</TT>.&nbsp; It accepts a wide-character
string argument for<B> format</B> and produces wide character output.&nbsp; The argument<B> buf</B> specifies an array of
wide characters into which the generated output is to be written, rather than converted to multibyte characters and written
to a stream.&nbsp; The maximum number of wide characters to store is specified by<B> count</B>.&nbsp; A null wide character
is placed at the end of the generated wide character string if fewer than<B> count</B> wide characters were stored.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _snprintf</TT> function returns the number of characters written into the array, not counting the terminating null
character, or a negative value if more than<B> count</B> characters were requested to be generated.&nbsp; An error can occur
while converting a value for output.&nbsp; The<TT> _snwprintf</TT> function returns the number of wide characters written
into the array, not counting the terminating null wide character, or a negative value if more than<B> count</B> wide characters
were requested to be generated.&nbsp; When an error has occurred, <TT> errno</TT> contains a value indicating the type of
error that has been detected.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_bprintf">_bprintf</A>, <A HREF="#cprintf">cprintf</A>, <A HREF="#fprintf">fprintf</A>, <A HREF="#printf">printf</A>,
<A HREF="#sprintf">sprintf</A>, <A HREF="#_vbprintf">_vbprintf</A>, <A HREF="#vcprintf">vcprintf</A>, <A HREF="#vfprintf">vfprintf</A>,
<A HREF="#vprintf">vprintf</A>, <A HREF="#vsprintf">vsprintf</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>/* Create temporary file names using a counter */</TT>
<BR><BR><TT>char namebuf[13];</TT>
<BR><TT>int&nbsp; TempCount = 0;</TT>
<BR><BR><TT>char *make_temp_name()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _snprintf( namebuf, 13, &quot;ZZ%.6o.TMP&quot;, TempCount++ );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; return( namebuf );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FILE *tf1, *tf2;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; tf1 = fopen( make_temp_name(), &quot;w&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; tf2 = fopen( make_temp_name(), &quot;w&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fputs( &quot;temp file 1&quot;, tf1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fputs( &quot;temp file 2&quot;, tf2 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fclose( tf1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fclose( tf2 );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> _snprintf - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_snwprintf - All, Linux</TT>
</DL>
<H2 ID="snprintf"> snprintf, snwprintf </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>int snprintf( char *buf,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t count,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *format, ... );</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>int snwprintf( wchar_t *buf,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t count,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t *format, ... );</TT>
</DL>
<DL>
<DT>Safer C:
<DD>The Safer C Library extension provides the <A HREF="#snprintf_s">snprintf_s</A> function which is a safer alternative to<TT>
snprintf</TT> This newer<TT> snprintf_s</TT> function is recommended to be used instead of the traditional &quot;unsafe&quot;<TT>
snprintf</TT> function.
</DL>
<DL>
<DT>Description:
<DD>The<TT> snprintf</TT> function is equivalent to the <TT> fprintf</TT> function, except that the argument<B> buf</B> specifies
a character array into which the generated output is placed, rather than to a file.&nbsp; A null character is placed at the
end of the generated character string.&nbsp; The maximum number of characters to store, including a terminating null character,
is specified by<B> count</B>.&nbsp; The<B> format</B> string is described under the description of the <TT> printf</TT> function.
<BR><BR>The<TT> snwprintf</TT> function is a wide-character version of<TT> snprintf</TT>.&nbsp; It accepts a wide-character
string argument for<B> format</B> and produces wide character output.&nbsp; The argument<B> buf</B> specifies an array of
wide characters into which the generated output is to be written, rather than converted to multibyte characters and written
to a stream.&nbsp; The maximum number of wide characters to store, including a terminating null wide character, is specified
by<B> count</B>.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> snprintf</TT> function returns the number of characters that would have been written had<B> count</B> been sufficiently
large, not counting the terminating null character, or a negative value if an encoding error occurred.&nbsp; Thus, the null-terminated
output has been completely written if and only if the returned value is nonnegative and less than<B> count</B>.&nbsp; The<TT>
snwprintf</TT> function returns the number of wide characters that would have been written had<B> count</B> been sufficiently
large, not counting the terminating null wide character, or a negative value if an encoding error occurred.&nbsp; Thus, the
null-terminated output has been completely written if and only if the returned value is nonnegative and less than<B> count</B>.
&nbsp;When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_bprintf">_bprintf</A>, <A HREF="#cprintf">cprintf</A>, <A HREF="#fprintf">fprintf</A>, <A HREF="#printf">printf</A>,
<A HREF="#sprintf">sprintf</A>, <A HREF="#_vbprintf">_vbprintf</A>, <A HREF="#vcprintf">vcprintf</A>, <A HREF="#vfprintf">vfprintf</A>,
<A HREF="#vprintf">vprintf</A>, <A HREF="#vsprintf">vsprintf</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>/* Format output into a buffer after determining its size */</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; bufsize;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; *buffer;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; bufsize = snprintf( NULL, 0, &quot;%3d %P&quot;, 42, 42 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; buffer&nbsp; = malloc( bufsize + 1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; snprintf( buffer, bufsize + 1, &quot;%3d %P&quot;, 42, 42 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; free( buffer );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>snwprintf is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> snprintf - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>snwprintf - All, Linux</TT>
</DL>
<H2 ID="snprintf_s"> snprintf_s, snwprintf_s </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__ 1</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>int snprintf_s( char * restrict s, rsize_t n</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char * restrict format, ... );</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>int snwprintf_s( char * restrict s, rsize_t n,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t * restrict format, ... );</TT>
</DL>
<DL>
<DT>Constraints:
<DD>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<TT>
snprintf_s</TT> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<BR><BR>Neither<B> s</B> nor<B> format</B> shall be a null pointer.&nbsp; The<B> n</B> argument shall neither equal zero nor
be greater than<TT> RSIZE_MAX.</TT>&nbsp; The number of characters (including the trailing null) required for the result to
be written to the array pointed to by<B> s</B> shall not be greater than<B> n</B>.&nbsp; The<TT> %n</TT> specifier (modified
or not by flags, field width, or precision) shall not appear in the string pointed to by<B> format</B>.&nbsp; Any argument
to<TT> snprintf_s</TT> corresponding to a<TT> %s</TT> specifier shall not be a null pointer.&nbsp; No encoding error shall
occur.
<BR><BR>If there is a runtime-constraint violation, then if<B> s</B> is not a null pointer and<B> n</B> is greater than zero
and less than<TT> RSIZE_MAX,</TT> then the<TT> snprintf_s</TT> function sets<B> s[0]</B> to the null character.
</DL>
<DL>
<DT>Description:
<DD>The<TT> snprintf_s</TT> function is equivalent to the <TT> snprintf</TT> function except for the explicit runtime-constraints
listed above.
<BR><BR>The<TT> snprintf_s</TT> function, unlike <TT> sprintf_s</TT>, will truncate the result to fit within the array pointed
to by<B> s</B>.
<BR><BR>The<TT> snwprintf_s</TT> function is a wide-character version of<TT> snprintf_s</TT>.&nbsp; It accepts a wide-character
string argument for<B> format</B> and produces wide character output.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> snprintf_s</TT> function returns the number of characters that would have been written had<B> n</B> been sufficiently
large, not counting the terminating null character, or a negative value if a runtime-constraint violation occurred.&nbsp;
Thus, the null-terminated output has been completely written if and only if the returned value is nonnegative and less than<B>
n</B>.
<BR><BR>The<TT> snwprintf_s</TT> function returns the number of wide characters that would have been written had<B> n</B>
been sufficiently large, not counting the terminating wide null character, or a negative value if a runtime-constraint violation
occurred.&nbsp; Thus, the null-terminated output has been completely written if and only if the returned value is nonnegative
and less than<B> n</B>.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_bprintf">_bprintf</A>, <A HREF="#cprintf">cprintf</A>, <A HREF="#fprintf">fprintf</A>, <A HREF="#printf">printf</A>,
<A HREF="#sprintf">sprintf</A>, <A HREF="#_vbprintf">_vbprintf</A>, <A HREF="#vcprintf">vcprintf</A>, <A HREF="#vfprintf">vfprintf</A>,
<A HREF="#vprintf">vprintf</A>, <A HREF="#vsprintf">vsprintf</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__ 1</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>/* Format output into a buffer after determining its size */</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; bufsize;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; *buffer;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; bufsize = snprintf( NULL, 0, &quot;%3d %P&quot;, 42, 42 ) + 1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; buffer&nbsp; = malloc( bufsize );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; snprintf_s( buffer, bufsize, &quot;%3d %P&quot;, 42, 42 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; free( buffer );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>TR 24731
</DL>
<DL>
<DT>Systems:
<DD><TT> snprintf_s - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>snwprintf_s - All, Linux</TT>
</DL>
<H2 ID="sopen"> sopen, _sopen, _wsopen </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;io.h&gt;</TT>
<BR><TT>#include &lt;fcntl.h&gt;</TT>
<BR><TT>#include &lt;sys/stat.h&gt;</TT>
<BR><TT>#include &lt;sys/types.h&gt;</TT>
<BR><TT>#include &lt;share.h&gt;</TT>
<BR><TT>int sopen( const char *filename,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int access, int share, ... );</TT>
<BR><TT>int _sopen( const char *filename,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int access, int share, ... );</TT>
<BR><TT>int _wsopen( const wchar_t *filename,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int access, int share, ... );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> sopen</TT> function opens a file at the operating system level for shared access.&nbsp; The name of the file to be
opened is given by<B> filename</B>.&nbsp; The file will be accessed according to the access mode specified by<B> access</B>.
&nbsp;When the file is to be created, the optional argument must be given which establishes the future access permissions
for the file.&nbsp; Additionally, the sharing mode of the file is given by the<B> share</B> argument.&nbsp; The optional argument
is the file permissions to be used when <TT> O_CREAT</TT> flag is on in the<B> access</B> mode.
<BR><BR>The<TT> _sopen</TT> function is identical to<TT> sopen</TT>.&nbsp; Use<TT> _sopen</TT> for ANSI naming conventions.
<BR><BR>The<TT> _wsopen</TT> function is identical to<TT> sopen</TT> except that it accepts a wide character string argument.
<BR><BR>The access mode is established by a combination of the bits defined in the<TT> &lt;fcntl.h&gt;</TT> header file.&nbsp;
The following bits may be set:
<DL>
<DT>Mode&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>O_RDONLY
<DD>permit the file to be only read.
<DT>O_WRONLY
<DD>permit the file to be only written.
<DT>O_RDWR
<DD>permit the file to be both read and written.
<DT>O_APPEND
<DD>causes each record that is written to be written at the end of the file.
<DT>O_CREAT
<DD>has no effect when the file indicated by<B> filename</B> already exists; otherwise, the file is created;
<DT>O_TRUNC
<DD>causes the file to be truncated to contain no data when the file exists; has no effect when the file does not exist.
<DT>O_BINARY
<DD>causes the file to be opened in binary mode which means that data will be transmitted to and from the file unchanged.
<DT>O_TEXT
<DD>causes the file to be opened in text mode which means that carriage-return characters are written before any linefeed character
that is written and causes carriage-return characters to be removed when encountered during reads.
<DT>O_NOINHERIT
<DD>indicates that this file is not to be inherited by a child process.
<DT>O_EXCL
<DD>indicates that this file is to be opened for exclusive access.&nbsp; If the file exists and <TT> O_CREAT</TT> was also specified
then the open will fail (i.e., use <TT> O_EXCL</TT> to ensure that the file does not already exist).
</DL>
<BR>When neither <TT> O_TEXT</TT> nor <TT> O_BINARY</TT> are specified, the default value in the global variable <TT> _fmode</TT>
is used to set the file translation mode.&nbsp; When the program begins execution, this variable has a value of <TT> O_TEXT</TT>.
<BR><BR><TT> O_CREAT</TT> must be specified when the file does not exist and it is to be written.
<BR><BR>When the file is to be created (<TT> O_CREAT</TT> is specified), an additional argument must be passed which contains
the file permissions to be used for the new file.&nbsp; The access permissions for the file or directory are specified as
a combination of bits (defined in the<TT> &lt;sys/stat.h&gt;</TT> header file).
<BR><BR>The following bits define permissions for the owner.
<DL>
<DT>Permission&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>S_IRWXU
<DD>Read, write, execute/search
<DT>S_IRUSR
<DD>Read permission
<DT>S_IWUSR
<DD>Write permission
<DT>S_IXUSR
<DD>Execute/search permission
</DL>
<BR>The following bits define permissions for the group.
<DL>
<DT>Permission&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>S_IRWXG
<DD>Read, write, execute/search
<DT>S_IRGRP
<DD>Read permission
<DT>S_IWGRP
<DD>Write permission
<DT>S_IXGRP
<DD>Execute/search permission
</DL>
<BR>The following bits define permissions for others.
<DL>
<DT>Permission&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>S_IRWXO
<DD>Read, write, execute/search
<DT>S_IROTH
<DD>Read permission
<DT>S_IWOTH
<DD>Write permission
<DT>S_IXOTH
<DD>Execute/search permission
</DL>
<BR>The following bits define miscellaneous permissions used by other implementations.
<DL>
<DT>Permission&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>S_IREAD
<DD>is equivalent to S_IRUSR (read permission)
<DT>S_IWRITE
<DD>is equivalent to S_IWUSR (write permission)
<DT>S_IEXEC
<DD>is equivalent to S_IXUSR (execute/search permission)
</DL>
<BR>All files are readable with DOS; however, it is a good idea to set <TT> S_IREAD</TT> when read permission is intended
for the file.
<BR><BR>The<TT> sopen</TT> function applies the current file permission mask to the specified permissions (see <TT> umask</TT>).
<BR><BR>The shared access for the file,<B> share</B>, is established by a combination of bits defined in the<TT> &lt;share.h&gt;</TT>
header file.&nbsp; The following values may be set:
<DL>
<DT>Value&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>SH_COMPAT
<DD>Set compatibility mode.
<DT>SH_DENYRW
<DD>Prevent read or write access to the file.
<DT>SH_DENYWR
<DD>Prevent write access of the file.
<DT>SH_DENYRD
<DD>Prevent read access to the file.
<DT>SH_DENYNO
<DD>Permit both read and write access to the file.
</DL>
<BR>You should consult the technical documentation for the DOS system that you are using for more detailed information about
these sharing modes.
</DL>
<DL>
<DT>Returns:
<DD>If successful,<TT> sopen</TT> returns a handle for the file.&nbsp; When an error occurs while opening the file, -1 is returned.
&nbsp;When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>EACCES
<DD>Access denied because<B> path</B> specifies a directory or a volume ID, or sharing mode denied due to a conflicting open.
<DT>EMFILE
<DD>No more handles available (too many open files)
<DT>ENOENT
<DD>Path or file not found
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#chsize">chsize</A>, <A HREF="#close">close</A>, <A HREF="#creat">creat</A>, <A HREF="#dup">dup</A>, <A HREF="#dup2">dup2</A>,
<A HREF="#eof">eof</A>, <A HREF="#exec___">exec...</A>, <A HREF="#fdopen">fdopen</A>, <A HREF="#filelength">filelength</A>,
<A HREF="#fileno">fileno</A>, <A HREF="#fstat">fstat</A>, <A HREF="#_grow_handles">_grow_handles</A>, <A HREF="#isatty">isatty</A>,
<A HREF="#lseek">lseek</A>, <A HREF="#open">open</A>, <A HREF="#read">read</A>, <A HREF="#setmode">setmode</A>, <A HREF="#stat">stat</A>,
<A HREF="#tell">tell</A>, <A HREF="#write">write</A>, <A HREF="#umask">umask</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;sys/stat.h&gt;</TT>
<BR><TT>#include &lt;sys/types.h&gt;</TT>
<BR><TT>#include &lt;fcntl.h&gt;</TT>
<BR><TT>#include &lt;share.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int handle;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; /* open a file for output&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* replace existing file if it exists&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; handle = sopen( &quot;file&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; O_WRONLY | O_CREAT | O_TRUNC,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SH_DENYWR,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S_IRUSR | S_IWUSR | S_IRGRP
| S_IWGRP );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; /* read a file which is assumed to exist&nbsp;&nbsp; */</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; handle = sopen( &quot;file&quot;, O_RDONLY, SH_DENYWR );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; /* append to the end of an existing file&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* write a new file if file does not exist */</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; handle = sopen( &quot;file&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; O_WRONLY | O_CREAT | O_APPEND,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SH_DENYWR,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S_IRUSR | S_IWUSR | S_IRGRP
| S_IWGRP );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
<BR><BR>_sopen conforms to ANSI naming conventions
</DL>
<DL>
<DT>Systems:
<DD><TT> sopen - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_sopen - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
<BR><TT>_wsopen - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, Linux</TT>
</DL>
<H2 ID="sound"> sound </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;i86.h&gt;</TT>
<BR><TT>void sound( unsigned frequency );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> sound</TT> function turns on the PC's speaker at the specified<B> frequency</B>.&nbsp; The frequency is in Hertz (cycles
per second).&nbsp; The speaker can be turned off by calling the <TT> nosound</TT> function after an appropriate amount of
time.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> sound</TT> function has no return value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#delay">delay</A>, <A HREF="#nosound">nosound</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;i86.h&gt;</TT>
<BR><BR><TT>/*</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; The numbers in this table are the timer divisors</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; necessary to produce the pitch indicated in the</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; lowest octave that is supported by the &quot;sound&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; function.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; To raise the pitch by N octaves, simply divide the</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; number in the table by 2**N since a pitch which is</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; an octave above another has double the frequency of</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; the original pitch.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; The frequency obtained by these numbers is given by</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 1193180 / X where X is the number obtained in the</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; table.</TT>
<BR><TT>*/</TT>
<BR><BR><TT>unsigned short Notes[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 19327 ,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* C b&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 18242 ,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* C&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 17218 ,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* C #&nbsp;&nbsp; (
D b )&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16252 ,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* D&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 15340 ,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* D #&nbsp;&nbsp; (
E b )&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 14479 ,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* E&nbsp;&nbsp;&nbsp;
&nbsp;( F b )&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 13666 ,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* F&nbsp;&nbsp;&nbsp;
&nbsp;( E # )&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 12899 ,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* F #&nbsp;&nbsp; (
G b )&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 12175 ,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* G&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 11492 ,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* G #&nbsp;&nbsp; (
A b )&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10847 ,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* A&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10238 ,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* A #&nbsp;&nbsp; (
B b )&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 9664 ,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* B&nbsp;&nbsp;
&nbsp; ( C b )&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 9121 ,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* B #&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0</TT>
<BR><TT>};</TT>
<BR><BR><TT>#define FACTOR&nbsp; 1193180</TT>
<BR><TT>#define OCTAVE&nbsp; 4</TT>
<BR><BR><TT>void main()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* play the scale */</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int i;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; Notes[i]; ++i ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sound( FACTOR / (Notes[i] / (1 &lt;&lt; OCTAVE)) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delay( 200 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nosound();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386
</DL>
<H2 ID="spawn___"> spawn...&nbsp; Functions </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;process.h&gt;</TT>
<BR><TT>int spawnl(&nbsp;&nbsp; mode, path, arg0, arg1..., argn, NULL );</TT>
<BR><TT>int spawnle(&nbsp; mode, path, arg0, arg1..., argn, NULL, envp);</TT>
<BR><TT>int spawnlp(&nbsp; mode, file, arg0, arg1..., argn, NULL );</TT>
<BR><TT>int spawnlpe( mode, file, arg0, arg1..., argn, NULL, envp);</TT>
<BR><TT>int spawnv(&nbsp;&nbsp; mode, path, argv );</TT>
<BR><TT>int spawnve(&nbsp; mode, path, argv, envp );</TT>
<BR><TT>int spawnvp(&nbsp; mode, file, argv );</TT>
<BR><TT>int spawnvpe( mode, file, argv, envp );</TT>
<BR><TT>int _spawnl(&nbsp;&nbsp; mode, path, arg0, arg1..., argn, NULL );</TT>
<BR><TT>int _spawnle(&nbsp; mode, path, arg0, arg1..., argn, NULL, envp);</TT>
<BR><TT>int _spawnlp(&nbsp; mode, file, arg0, arg1..., argn, NULL );</TT>
<BR><TT>int _spawnlpe( mode, file, arg0, arg1..., argn, NULL, envp);</TT>
<BR><TT>int _spawnv(&nbsp;&nbsp; mode, path, argv );</TT>
<BR><TT>int _spawnve(&nbsp; mode, path, argv, envp );</TT>
<BR><TT>int _spawnvp(&nbsp; mode, file, argv );</TT>
<BR><TT>int _spawnvpe( mode, file, argv, envp );</TT>
<BR><TT>&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; /* mode for parent&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp; const char *path;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* file name incl.
path */</TT>
<BR><TT>&nbsp; const char *file;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* file name&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp; const char *arg0, ..., *argn; /* arguments&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
*/</TT>
<BR><TT>&nbsp; const char *const argv[];&nbsp;&nbsp;&nbsp;&nbsp; /* array of arguments&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp; const char *const envp[];&nbsp;&nbsp;&nbsp;&nbsp; /* environment strings&nbsp; */</TT>
<BR><TT>int _wspawnl(&nbsp;&nbsp; mode, path, arg0, arg1..., argn, NULL );</TT>
<BR><TT>int _wspawnle(&nbsp; mode, path, arg0, arg1..., argn, NULL, envp);</TT>
<BR><TT>int _wspawnlp(&nbsp; mode, file, arg0, arg1..., argn, NULL );</TT>
<BR><TT>int _wspawnlpe( mode, file, arg0, arg1..., argn, NULL, envp);</TT>
<BR><TT>int _wspawnv(&nbsp;&nbsp; mode, path, argv );</TT>
<BR><TT>int _wspawnve(&nbsp; mode, path, argv, envp );</TT>
<BR><TT>int _wspawnvp(&nbsp; mode, file, argv );</TT>
<BR><TT>int _wspawnvpe( mode, file, argv, envp );</TT>
<BR><TT>&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* mode for parent&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp; const wchar_t *path;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* file name incl.
path */</TT>
<BR><TT>&nbsp; const wchar_t *file;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* file name&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp; const wchar_t *arg0, ..., *argn; /* arguments&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
*/</TT>
<BR><TT>&nbsp; const wchar_t *const argv[];&nbsp;&nbsp;&nbsp;&nbsp; /* array of arguments&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp; const wchar_t *const envp[];&nbsp;&nbsp;&nbsp;&nbsp; /* environment strings&nbsp; */</TT>
</DL>
<DL>
<DT>Description:
<DD>The<B> spawn...</B>&nbsp; functions create and execute a new child process, named by<B> pgm</B>.&nbsp; The value of<B> mode</B>
determines how the program is loaded and how the invoking program will behave after the invoked program is initiated:
<DL>
<DT>Mode&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>P_WAIT
<DD>The invoked program is loaded into available memory, is executed, and then the original program resumes execution.&nbsp; This
option is supported under DOS, OS/2, Win32 and QNX.
<DT>P_NOWAIT
<DD>Causes the current program to execute concurrently with the new child process.&nbsp; This option is supported under OS/2,
Win32 and QNX.
<DT>P_NOWAITO
<DD>Causes the current program to execute concurrently with the new child process.&nbsp; This option is supported under OS/2,
Win32 and QNX.&nbsp; The <TT> wait</TT> and <TT> cwait</TT> functions cannot be used to obtain the exit code.
<DT>P_OVERLAY
<DD>The invoked program replaces the original program in memory and is executed.&nbsp; No return is made to the original program.
&nbsp;This option is supported under DOS (16-bit only), OS/2, Win32, and QNX.&nbsp; This is equivalent to calling the appropriate
<TT> exec...</TT>&nbsp; function.
<DT>P_DETACH
<DD>Launches the child process in the background without access to the keyboard or console.&nbsp; This option is supported under
only Windows NT.
</DL>
<BR>The program is located by using the following logic in sequence:
<OL>
<LI>An attempt is made to locate the program in the current working directory if no directory specification precedes the program
name; otherwise, an attempt is made in the specified directory.
<LI>If no file extension is given, an attempt is made to find the program name, in the directory indicated in the first point,
with<TT> .COM</TT> concatenated to the end of the program name.
<LI>If no file extension is given, an attempt is made to find the program name, in the directory indicated in the first point,
with<TT> .EXE</TT> concatenated to the end of the program name.
<LI>When no directory specification is given as part of the program name, the <TT> spawnlp</TT>, <TT> spawnlpe</TT>, <TT>
spawnvp</TT>, and <TT> spawnvpe</TT> functions will repeat the preceding three steps for each of the directories specified
by the <TT> PATH</TT> environment variable.&nbsp; The command
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; path c:\myapps;d:\lib\applns</TT>
<BR><BR>indicates that the two directories
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; c:\myapps</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; d:\lib\applns</TT>
<BR><BR>are to be searched.&nbsp; The DOS<TT> PATH</TT> command (without any directory specification) will cause the current
path definition to be displayed.
</OL>
<BR>An error is detected when the program cannot be found.
<BR><BR>Arguments are passed to the child process by supplying one or more pointers to character strings as arguments in the<B>
spawn...</B>&nbsp; call.&nbsp; These character strings are concatenated with spaces inserted to separate the arguments to
form one argument string for the child process.&nbsp; The length of this concatenated string must not exceed 128 bytes for
DOS systems.
<BR><BR>The arguments may be passed as a list of arguments (<TT> spawnl</TT>, <TT> spawnle</TT>, <TT> spawnlp</TT> and <TT>
spawnlpe</TT>) or as a vector of pointers (<TT> spawnv</TT>, <TT> spawnve</TT>, <TT> spawnvp</TT>, and <TT> spawnvpe</TT>).
&nbsp;At least one argument,<B> arg0</B> or<B> argv[0]</B>, must be passed to the child process.&nbsp; By convention, this
first argument is a pointer to the name of the program.
<BR><BR>If the arguments are passed as a list, there must be a<TT> NULL</TT> pointer to mark the end of the argument list.
&nbsp;Similarly, if a pointer to an argument vector is passed, the argument vector must be terminated by a<TT> NULL</TT> pointer.
<BR><BR>The environment for the invoked program is inherited from the parent process when you use the <TT> spawnl</TT>, <TT>
spawnlp</TT>, <TT> spawnv</TT> and <TT> spawnvp</TT> functions.&nbsp; The <TT> spawnle</TT>, <TT> spawnlpe</TT>, <TT> spawnve</TT>
and <TT> spawnvpe</TT> functions allow a different environment to be passed to the child process through the<B> envp</B> argument.
&nbsp;The argument<B> envp</B> is a pointer to an array of character pointers, each of which points to a string defining an
environment variable.&nbsp; The array is terminated with a<TT> NULL</TT> pointer.&nbsp; Each pointer locates a character string
of the form
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; variable=value</TT>
<BR><BR>that is used to define an environment variable.&nbsp; If the value of<B> envp</B> is<TT> NULL</TT>, then the child
process inherits the environment of the parent process.
<BR><BR>The environment is the collection of environment variables whose values that have been defined with the DOS<TT> SET</TT>
command or by the successful execution of the <TT> putenv</TT> function.&nbsp; A program may read these values with the <TT>
getenv</TT> function.
<BR><BR>The following example invokes &quot;myprog&quot; as if<TT> myprog ARG1 ARG2</TT> had been entered as a command to
DOS.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; spawnl( P_WAIT, &quot;myprog&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;myprog&quot;, &quot;ARG1&quot;, &quot;ARG2&quot;,
NULL );</TT>
<BR><BR>The program will be found if one of &quot;myprog.&quot;, &quot;myprog.com&quot;, or &quot;myprog.exe&quot; is found
in the current working directory.
<BR><BR>The following example includes a new environment for &quot;myprog&quot;.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char *env_list[] = { &quot;SOURCE=MYDATA&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;TARGET=OUTPUT&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;lines=65&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; spawnle( P_WAIT, &quot;myprog&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;myprog&quot;, &quot;ARG1&quot;, &quot;ARG2&quot;,
NULL,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env_list );</TT>
<BR><BR>The environment for the invoked program will consist of the three environment variables<TT> SOURCE, TARGET</TT> and<TT>
lines.</TT>
<BR><BR>The following example is another variation on the first example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char *arg_list[] = { &quot;myprog&quot;, &quot;ARG1&quot;, &quot;ARG2&quot;, NULL };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; spawnv( P_WAIT, &quot;myprog&quot;, arg_list );</TT>
<BR><BR>The<TT> _wspawn...</TT>&nbsp; functions are similar to their counterparts but operate on wide-character strings.
</DL>
<DL>
<DT>Returns:
<DD>When the value of<B> mode</B> is:
<DL>
<DT>Mode&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>P_WAIT
<DD>then the return value from<B> spawn...</B>&nbsp; is the exit status of the child process.
<DT>P_NOWAIT
<DD>then the return value from<B> spawn...</B>&nbsp; is the process ID (or process handle under Win32) of the child process.&nbsp;
To obtain the exit code for a process spawned with <TT> P_NOWAIT</TT>, you must call the <TT> wait</TT> (under OS/2 or QNX)
or <TT> cwait</TT> (under OS/2 or Win32) function specifying the process ID/handle.&nbsp; If the child process terminated
normally, then the low order byte of the returned status word will be set to 0, and the high order byte will contain the low
order byte of the return code that the child process passed to the <TT> DOSEXIT</TT> function.
<DT>P_NOWAITO
<DD>then the return value from<B> spawn...</B>&nbsp; is the process ID of the child process.&nbsp; The exit code cannot be obtained
for a process spawned with <TT> P_NOWAITO</TT>.
<DT>P_DETACH
<DD>then the return value from<B> spawn...</B>&nbsp; is zero (0) if successful.
</DL>
<BR>When an error is detected while invoking the indicated program, spawn...&nbsp; returns -1 and <TT> errno</TT> is set to
indicate the error.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>E2BIG
<DD>The argument list exceeds 128 bytes, or the space required for the environment information exceeds 32K.
<DT>EINVAL
<DD>The<B> mode</B> argument is invalid.
<DT>ENOENT
<DD>Path or file not found
<DT>ENOMEM
<DD>Not enough memory is available to execute the child process.
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#abort">abort</A>, <A HREF="#atexit">atexit</A>, <A HREF="#cwait">cwait</A>, <A HREF="#exec___">exec...</A>, <A HREF="#exit">exit</A>,
<A HREF="#_Exit">_Exit</A>, <A HREF="#_exit">_exit</A>, <A HREF="#getcmd">getcmd</A>, <A HREF="#getenv">getenv</A>, <A HREF="#main">main</A>,
<A HREF="#putenv">putenv</A>, <A HREF="#system">system</A>, <A HREF="#wait">wait</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>#include &lt;process.h&gt;</TT>
<BR><TT>#include &lt;errno.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; process_id;</TT>
<BR><TT>#if defined(__OS2__) || defined(__NT__)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; status, rc;</TT>
<BR><TT>#endif</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; process_id = spawnl( P_NOWAIT, &quot;child.exe&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; &quot;child&quot;, &quot;5&quot;, NULL );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( process_id == -1 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;spawn failed - %s\n&quot;, strerror( errno ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit( EXIT_FAILURE );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Process id = %d\n&quot;, process_id );</TT>
<BR><BR><TT>#if defined(__OS2__) || defined(__NT__)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; rc = cwait( &amp;status, process_id, WAIT_CHILD );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( rc == -1 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;wait failed - %s\n&quot;, strerror( errno ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;wait succeeded - %x\n&quot;, status );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch( status &amp; 0xff ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 0:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Normal termination exit code = %d\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
status &gt;&gt; 8 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 1:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Hard-error abort\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 2:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Trap operation\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 3:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;SIGTERM signal not intercepted\n&quot;
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Bogus return status\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>#endif</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;spawn completed\n&quot; );</TT>
<BR><TT>}</TT>
<BR><BR><TT>/*</TT>
<BR><TT>[child.c]</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>#include &lt;dos.h&gt;</TT>
<BR><BR><TT>void main( int argc, char *argv[] )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int delay;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; if( argc &lt;= 1 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit( EXIT_FAILURE );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; delay = atoi( argv[1] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;I am a child going to sleep &quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;for %d seconds\n&quot;, delay );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; sleep( delay );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;I am a child awakening\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; exit( 123 );</TT>
<BR><BR><TT>}</TT>
<BR><TT>*/</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
<BR><BR>_spawn...&nbsp; conforms to ANSI naming conventions
</DL>
<DL>
<DT>Systems:
<DD><TT> spawnl - DOS, Win32, OS/2 1.x(all), OS/2-32, Linux, RDOS</TT>
<BR><BR><TT>spawnle - DOS, Win32, OS/2 1.x(all), OS/2-32, Linux, RDOS</TT>
<BR><TT>spawnlp - DOS, Win32, OS/2 1.x(all), OS/2-32, Linux, RDOS, Netware</TT>
<BR><TT>spawnlpe - DOS, Win32, OS/2 1.x(all), OS/2-32, Linux, RDOS</TT>
<BR><TT>spawnv - DOS, Win32, OS/2 1.x(all), OS/2-32, Linux, RDOS</TT>
<BR><TT>spawnve - DOS, Win32, OS/2 1.x(all), OS/2-32, Linux, RDOS</TT>
<BR><TT>spawnvp - DOS, Win32, OS/2 1.x(all), OS/2-32, Linux, RDOS, Netware</TT>
<BR><TT>spawnvpe - DOS, Win32, OS/2 1.x(all), OS/2-32, Linux, RDOS</TT>
<BR><TT>_spawnl - DOS, Win32, OS/2 1.x(all), OS/2-32, Linux, RDOS</TT>
<BR><TT>_spawnle - DOS, Win32, OS/2 1.x(all), OS/2-32, Linux, RDOS</TT>
<BR><TT>_spawnlp - DOS, Win32, OS/2 1.x(all), OS/2-32, Linux, RDOS, Netware</TT>
<BR><TT>_spawnlpe - DOS, Win32, OS/2 1.x(all), OS/2-32, Linux, RDOS</TT>
<BR><TT>_spawnv - DOS, Win32, OS/2 1.x(all), OS/2-32, Linux, RDOS</TT>
<BR><TT>_spawnve - DOS, Win32, OS/2 1.x(all), OS/2-32, Linux, RDOS</TT>
<BR><TT>_spawnvp - DOS, Win32, OS/2 1.x(all), OS/2-32, Linux, RDOS, Netware</TT>
<BR><TT>_spawnvpe - DOS, Win32, OS/2 1.x(all), OS/2-32, Linux, RDOS</TT>
<BR><TT>_wspawnl - DOS, Win32, OS/2 1.x(all), OS/2-32</TT>
<BR><TT>_wspawnle - DOS, Win32, OS/2 1.x(all), OS/2-32</TT>
<BR><TT>_wspawnlp - DOS, Win32, OS/2 1.x(all), OS/2-32</TT>
<BR><TT>_wspawnlpe - DOS, Win32, OS/2 1.x(all), OS/2-32</TT>
<BR><TT>_wspawnv - DOS, Win32, OS/2 1.x(all), OS/2-32</TT>
<BR><TT>_wspawnve - DOS, Win32, OS/2 1.x(all), OS/2-32</TT>
<BR><TT>_wspawnvp - DOS, Win32, OS/2 1.x(all), OS/2-32</TT>
<BR><TT>_wspawnvpe - DOS, Win32, OS/2 1.x(all), OS/2-32</TT>
</DL>
<H2 ID="_splitpath"> _splitpath, _wsplitpath </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>void _splitpath( const char *path,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; char *drive,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; char *dir,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; char *fname,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; char *ext );</TT>
<BR><TT>void _wsplitpath( const wchar_t *path,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; wchar_t *drive,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; wchar_t *dir,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; wchar_t *fname,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; wchar_t *ext );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _splitpath</TT> function splits up a full pathname into four components consisting of a drive letter, directory path,
file name and file name extension.&nbsp; The argument<B> path</B> points to a buffer containing the full pathname to be split
up.
<BR><BR>The<TT> _wsplitpath</TT> function is a wide-character version of<TT> _splitpath</TT> that operates with wide-character
strings.
<BR><BR>The maximum size required for each buffer is specified by the manifest constants <TT> _MAX_PATH</TT>, <TT> _MAX_DRIVE</TT>
(or <TT> _MAX_VOLUME</TT> for Netware applications), <TT> _MAX_DIR</TT>, <TT> _MAX_FNAME</TT>, and <TT> _MAX_EXT</TT> which
are defined in<TT> &lt;stdlib.h&gt;.</TT>
<DL>
<DT>drive
<DD>The<B> drive</B> argument points to a buffer that will be filled in with the drive letter (e.g., A, B, C, etc.) followed by
a colon if a drive is specified in the full pathname (filled in by<TT> _splitpath</TT> ).
<BR><BR>For Netware applications, the<B> drive</B> argument points to a buffer that will be filled in with the volume identifier
(e.g., \\NAME_SPACE) if a volume is specified in the full pathname (filled in by<TT> _splitpath</TT> ).
<DT>dir
<DD>The<B> dir</B> argument points to a buffer that will be filled in with the pathname including the trailing slash.&nbsp; Either
forward slashes (/) or backslashes (\) may be used.
<DT>fname
<DD>The<B> fname</B> argument points to a buffer that will be filled in with the base name of the file without any extension (suffix)
if a file name is specified in the full pathname (filled in by<TT> _splitpath</TT> ).
<DT>ext
<DD>The<B> ext</B> argument points to a buffer that will be filled in with the filename extension (suffix) including the leading
period if an extension is specified in the full pathname (filled in by<TT> _splitpath</TT> ).
</DL>
<BR>The arguments<B> drive</B>,<B> dir</B>,<B> fname</B> and<B> ext</B> will not be filled in if they are NULL pointers.
<BR><BR>For each component of the full pathname that is not present, its corresponding buffer will be set to an empty string.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _splitpath</TT> function returns no value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_fullpath">_fullpath</A>, <A HREF="#_makepath">_makepath</A>, <A HREF="#_splitpath2">_splitpath2</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char full_path[ _MAX_PATH ];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char drive[ _MAX_DRIVE ];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char dir[ _MAX_DIR ];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char fname[ _MAX_FNAME ];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char ext[ _MAX_EXT ];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _makepath(full_path,&quot;c&quot;,&quot;watcomc\\h\\&quot;,&quot;stdio&quot;,&quot;h&quot;);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Full path is: %s\n\n&quot;, full_path );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _splitpath( full_path, drive, dir, fname, ext );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Components after _splitpath\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;drive: %s\n&quot;, drive );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;dir:&nbsp;&nbsp; %s\n&quot;, dir );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;fname: %s\n&quot;, fname );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;ext:&nbsp;&nbsp; %s\n&quot;, ext );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>Full path is: c:watcomc\h\stdio.h</TT>
<BR><BR><TT>Components after _splitpath</TT>
<BR><TT>drive: c:</TT>
<BR><TT>dir:&nbsp;&nbsp; watcomc\h\</TT>
<BR><TT>fname: stdio</TT>
<BR><TT>ext:&nbsp;&nbsp; .h</TT>
<BR><BR>Note the use of two adjacent backslash characters (\) within character-string constants to signify a single backslash.
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> _splitpath - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_wsplitpath - All, Linux</TT>
</DL>
<H2 ID="_splitpath2"> _splitpath2, _wsplitpath2 </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>void _splitpath2( const char *inp,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; char *outp,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; char **drive,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; char **dir,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; char **fname,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; char **ext );</TT>
<BR><TT>void _wsplitpath2( const wchar_t *inp,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; wchar_t *outp,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; wchar_t **drive,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; wchar_t **dir,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; wchar_t **fname,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; wchar_t **ext );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _splitpath2</TT> function splits up a full pathname into four components consisting of a drive letter, directory path,
file name and file name extension.
<DL>
<DT>inp
<DD>The argument<B> inp</B> points to a buffer containing the full pathname to be split up.
<DT>outp
<DD>The argument<B> outp</B> points to a buffer that will contain all the components of the path, each separated by a null character.
&nbsp;The maximum size required for this buffer is specified by the manifest constant <TT> _MAX_PATH2</TT> which is defined
in<TT> &lt;stdlib.h&gt;.</TT>
<DT>drive
<DD>The<B> drive</B> argument is the location that is to contain the pointer to the drive letter (e.g., A, B, C, etc.) followed
by a colon if a drive is specified in the full pathname (filled in by<TT> _splitpath2</TT> ).
<DT>dir
<DD>The<B> dir</B> argument is the location that is to contain the pointer to the directory path including the trailing slash
if a directory path is specified in the full pathname (filled in by<TT> _splitpath2</TT> ).&nbsp; Either forward slashes (/)
or backslashes (\) may be used.
<DT>fname
<DD>The<B> fname</B> argument is the location that is to contain the pointer to the base name of the file without any extension
(suffix) if a file name is specified in the full pathname (filled in by<TT> _splitpath2</TT> ).
<DT>ext
<DD>The<B> ext</B> argument is the location that is to contain the pointer to the filename extension (suffix) including the leading
period if an extension is specified in the full pathname (filled in by<TT> _splitpath2</TT> ).
</DL>
<BR>The arguments<B> drive</B>,<B> dir</B>,<B> fname</B> and<B> ext</B> will not be filled in if they are NULL pointers.
<BR><BR>For each component of the full pathname that is not present, its corresponding pointer will be set to point at a NULL
string ('\0').
<BR><BR>This function reduces the amount of memory space required when compared to the <TT> splitpath</TT> function.
<BR><BR>The<TT> _wsplitpath2</TT> function is a wide-character version of<TT> _splitpath2</TT> that operates with wide-character
strings.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _splitpath2</TT> function returns no value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_fullpath">_fullpath</A>, <A HREF="#_makepath">_makepath</A>, <A HREF="#_splitpath">_splitpath</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char full_path[ _MAX_PATH ];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char tmp_path[ _MAX_PATH2 ];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char *drive;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char *dir;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char *fname;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char *ext;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _makepath(full_path,&quot;c&quot;,&quot;watcomc\\h&quot;,&quot;stdio&quot;,&quot;h&quot;);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Full path is: %s\n\n&quot;, full_path );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _splitpath2( full_path, tmp_path,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;drive, &amp;dir,
&amp;fname, &amp;ext );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Components after _splitpath2\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;drive: %s\n&quot;, drive );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;dir:&nbsp;&nbsp; %s\n&quot;, dir );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;fname: %s\n&quot;, fname );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;ext:&nbsp;&nbsp; %s\n&quot;, ext );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>Full path is: c:watcomc\h\stdio.h</TT>
<BR><BR><TT>Components after _splitpath2</TT>
<BR><TT>drive: c:</TT>
<BR><TT>dir:&nbsp;&nbsp; watcomc\h\</TT>
<BR><TT>fname: stdio</TT>
<BR><TT>ext:&nbsp;&nbsp; .h</TT>
<BR><BR>Note the use of two adjacent backslash characters (\) within character-string constants to signify a single backslash.
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> _splitpath2 - All, Linux, RDOS</TT>
<BR><BR><TT>_wsplitpath2 - All, Linux</TT>
</DL>
<H2 ID="sprintf"> sprintf, swprintf </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>int sprintf( char *buf, const char *format, ... );</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>int swprintf( wchar_t *buf,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t n,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t *format, ... );</TT>
</DL>
<DL>
<DT>Safer C:
<DD>The Safer C Library extension provides the <A HREF="#sprintf_s">sprintf_s</A> function which is a safer alternative to<TT>
sprintf</TT> This newer<TT> sprintf_s</TT> function is recommended to be used instead of the traditional &quot;unsafe&quot;<TT>
sprintf</TT> function.
</DL>
<DL>
<DT>Description:
<DD>The<TT> sprintf</TT> function is equivalent to the <TT> fprintf</TT> function, except that the argument<B> buf</B> specifies
a character array into which the generated output is placed, rather than to a file.&nbsp; A null character is placed at the
end of the generated character string.&nbsp; The<B> format</B> string is described under the description of the <TT> printf</TT>
function.
<BR><BR>The<TT> swprintf</TT> function is a wide-character version of<TT> sprintf</TT>.&nbsp; It accepts a wide-character
string argument for<B> format</B> and produces wide character output.&nbsp; The argument<B> buf</B> specifies an array of
wide characters into which the generated output is to be written, rather than converted to multibyte characters and written
to a stream.&nbsp; The maximum number of wide characters to write, including a terminating null wide character, is specified
by<B> n</B>.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> sprintf</TT> function returns the number of characters written into the array, not counting the terminating null character.
&nbsp;An error can occur while converting a value for output.&nbsp; The<TT> swprintf</TT> function returns the number of wide
characters written into the array, not counting the terminating null wide character, or a negative value if<B> n</B> or more
wide characters were requested to be generated.&nbsp; When an error has occurred, <TT> errno</TT> contains a value indicating
the type of error that has been detected.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_bprintf">_bprintf</A>, <A HREF="#cprintf">cprintf</A>, <A HREF="#fprintf">fprintf</A>, <A HREF="#printf">printf</A>,
<A HREF="#_vbprintf">_vbprintf</A>, <A HREF="#vcprintf">vcprintf</A>, <A HREF="#vfprintf">vfprintf</A>, <A HREF="#vprintf">vprintf</A>,
<A HREF="#vsprintf">vsprintf</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>/* Create temporary file names using a counter */</TT>
<BR><BR><TT>char namebuf[13];</TT>
<BR><TT>int&nbsp; TempCount = 0;</TT>
<BR><BR><TT>char *make_temp_name( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; sprintf( namebuf, &quot;zz%.6o.tmp&quot;, TempCount++ );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; return( namebuf );</TT>
<BR><TT>}</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FILE *tf1, *tf2;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; tf1 = fopen( make_temp_name(), &quot;w&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; tf2 = fopen( make_temp_name(), &quot;w&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fputs( &quot;temp file 1&quot;, tf1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fputs( &quot;temp file 2&quot;, tf2 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fclose( tf1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fclose( tf2 );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>swprintf is ISO C95
</DL>
<DL>
<DT>Systems:
<DD><TT> sprintf - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>swprintf - All, Linux</TT>
</DL>
<H2 ID="sprintf_s"> sprintf_s, swprintf_s </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__ 1</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>int sprintf_s( char * restrict s, rsize_t n</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char * restrict format, ... );</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>int swprintf_s( char * restrict s, rsize_t n,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t * restrict format, ... );</TT>
</DL>
<DL>
<DT>Constraints:
<DD>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<TT>
sprintf_s</TT> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<BR><BR>Neither<B> s</B> nor<B> format</B> shall be a null pointer.&nbsp; The<B> n</B> argument shall neither equal zero nor
be greater than<TT> RSIZE_MAX.</TT>&nbsp; The number of characters (including the trailing null) required for the result to
be written to the array pointed to by<B> s</B> shall not be greater than<B> n</B>.&nbsp; The<TT> %n</TT> specifier (modified
or not by flags, field width, or precision) shall not appear in the string pointed to by<B> format</B>.&nbsp; Any argument
to<TT> sprintf_s</TT> corresponding to a<TT> %s</TT> specifier shall not be a null pointer.&nbsp; No encoding error shall
occur.
<BR><BR>If there is a runtime-constraint violation, then if<B> s</B> is not a null pointer and<B> n</B> is greater than zero
and less than<TT> RSIZE_MAX,</TT> then the<TT> sprintf_s</TT> function sets<B> s[0]</B> to the null character.
</DL>
<DL>
<DT>Description:
<DD>The<TT> sprintf_s</TT> function is equivalent to the <TT> sprintf</TT> function except for the explicit runtime-constraints
listed above.
<BR><BR>The<TT> sprintf_s</TT> function, unlike <TT> snprintf_s</TT>, treats a result too big for the array pointed to by<B>
s</B> as a runtime-constraint violation.
<BR><BR>The<TT> swprintf_s</TT> function is a wide-character version of<TT> sprintf_s</TT>.&nbsp; It accepts a wide-character
string argument for<B> format</B> and produces wide character output.
</DL>
<DL>
<DT>Returns:
<DD>If no runtime-constraint violation occurred, the<TT> sprintf_s</TT> function returns the number of characters written in the
array, not counting the terminating null character.&nbsp; If an encoding error occurred,<TT> sprintf_s</TT> returns a negative
value.&nbsp; If any other runtime-constraint violation occurred,<TT> sprintf_s</TT> returns zero.
<BR><BR>If no runtime-constraint violation occurred, the<TT> swprintf_s</TT> function returns the number of wide characters
written in the array, not counting the terminating null wide character.&nbsp; If an encoding error occurred or if<B> n</B>
or more wide characters are requested to be written,<TT> swprintf_s</TT> returns a negative value.&nbsp; If any other runtime-constraint
violation occurred,<TT> swprintf_s</TT> returns zero.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_bprintf">_bprintf</A>, <A HREF="#cprintf">cprintf</A>, <A HREF="#fprintf">fprintf</A>, <A HREF="#printf">printf</A>,
<A HREF="#sprintf">sprintf</A>, <A HREF="#_vbprintf">_vbprintf</A>, <A HREF="#vcprintf">vcprintf</A>, <A HREF="#vfprintf">vfprintf</A>,
<A HREF="#vprintf">vprintf</A>, <A HREF="#vsprintf">vsprintf</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__ 1</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>/* Create temporary file names using a counter */</TT>
<BR><BR><TT>char namebuf[13];</TT>
<BR><TT>int&nbsp; TempCount = 0;</TT>
<BR><BR><TT>char *make_temp_name( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; sprintf_s( namebuf, sizeof( namebuf ),</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;zz%.6o.tmp&quot;, TempCount++
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; return( namebuf );</TT>
<BR><TT>}</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FILE *tf1, *tf2;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; tf1 = fopen( make_temp_name(), &quot;w&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; tf2 = fopen( make_temp_name(), &quot;w&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fputs( &quot;temp file 1&quot;, tf1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fputs( &quot;temp file 2&quot;, tf2 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fclose( tf1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fclose( tf2 );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>TR 24731
</DL>
<DL>
<DT>Systems:
<DD><TT> sprintf_s - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>swprintf_s - All, Linux</TT>
</DL>
<H2 ID="sqrt"> sqrt </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>double sqrt( double x );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> sqrt</TT> function computes the non-negative square root of<B> x</B>.&nbsp; A domain error occurs if the argument
is negative.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> sqrt</TT> function returns the value of the square root.&nbsp; When the argument is outside the permissible range,
the <TT> matherr</TT> function is called.&nbsp; Unless the default <TT> matherr</TT> function is replaced, it will set the
global variable <TT> errno</TT> to <TT> EDOM</TT>, and print a &quot;DOMAIN error&quot; diagnostic message using the <TT>
stderr</TT> stream.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#exp">exp</A>, <A HREF="#log">log</A>, <A HREF="#pow">pow</A>, <A HREF="#matherr">matherr</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, sqrt(.5) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>0.707107</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD>Math
</DL>
<H2 ID="srand"> srand </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>void srand( unsigned int seed );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> srand</TT> function uses the argument<B> seed</B> to start a new sequence of pseudo-random integers to be returned
by subsequent calls to <TT> rand</TT>.&nbsp; A particular sequence of pseudo-random integers can be repeated by calling<TT>
srand</TT> with the same<B> seed</B> value.&nbsp; The default sequence of pseudo-random integers is selected with a<B> seed</B>
value of 1.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> srand</TT> function returns no value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#rand">rand</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; srand( 982 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 1; i &lt; 10; ++i ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, rand() );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; srand( 982 );&nbsp; /* start sequence over again */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 1; i &lt; 10; ++i ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, rand() );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="sscanf"> sscanf, swscanf </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>int sscanf( const char *in_string,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *format, ... );</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>int swscanf( const wchar_t *in_string,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t *format, ... );</TT>
</DL>
<DL>
<DT>Safer C:
<DD>The Safer C Library extension provides the <A HREF="#sscanf_s">sscanf_s</A> function which is a safer alternative to<TT> sscanf</TT>
This newer<TT> sscanf_s</TT> function is recommended to be used instead of the traditional &quot;unsafe&quot;<TT> sscanf</TT>
function.
</DL>
<DL>
<DT>Description:
<DD>The<TT> sscanf</TT> function scans input from the character string<B> in_string</B> under control of the argument<B> format</B>.
&nbsp;Following the format string is the list of addresses of items to receive values.
<BR><BR>The<B> format</B> string is described under the description of the <TT> scanf</TT> function.
<BR><BR>The<TT> swscanf</TT> function is identical to<TT> sscanf</TT> except that it accepts a wide-character string argument
for<B> format</B> and the input string<B> in_string</B> consists of wide characters.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> sscanf</TT> function returns <TT> EOF</TT> if the end of the input string was reached before any input conversion.
&nbsp;Otherwise, the number of input arguments for which values were successfully scanned and stored is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#cscanf">cscanf</A>, <A HREF="#fscanf">fscanf</A>, <A HREF="#scanf">scanf</A>, <A HREF="#vcscanf">vcscanf</A>, <A HREF="#vfscanf">vfscanf</A>,
<A HREF="#vscanf">vscanf</A>, <A HREF="#vsscanf">vsscanf</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>/* Scan a date in the form &quot;Saturday April 18 1987&quot; */</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int day, year;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char weekday[10], month[10];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; sscanf( &quot;Friday August 0014 1987&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;%s %s %d&nbsp; %d&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; weekday, month, &amp;day, &amp;year );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s %s %d %d\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; weekday, month, day, year );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>Friday August 14 1987</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C90
<BR><BR>swscanf is ISO C95
</DL>
<DL>
<DT>Systems:
<DD><TT> sscanf - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>swscanf - All, Linux</TT>
</DL>
<H2 ID="sscanf_s"> sscanf_s, swscanf_s </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__ 1</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>int sscanf_s( const char * restrict s,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char * restrict format, ... );</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>int swscanf_s( const wchar_t * restrict s,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t * restrict format,
... );</TT>
</DL>
<DL>
<DT>Constraints:
<DD>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<TT>
sscanf_s</TT> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<BR><BR>Neither<B> s</B> not<B> format</B> shall be a null pointer.&nbsp; Any argument indirected through in order to store
converted input shall not be a null pointer.
<BR><BR>If there is a runtime-constraint violation, the<TT> sscanf_s</TT> function does not attempt to perform further input,
and it is unspecified to what extent<TT> sscanf_s</TT> performed input before discovering the runtime-constraint violation.
</DL>
<DL>
<DT>Description:
<DD>The<TT> sscanf_s</TT> function is equivalent to <TT> fscanf_s</TT>, except that input is obtained from a string (specified
by the argument<B> s</B>) rather than from a stream.&nbsp; Reaching the end of the string is equivalent to encountering end-of-file
for the <TT> fscanf_s</TT> function.&nbsp; If copying takes place between objects that overlap, the objects take on unspecified
values.
<BR><BR>The<TT> swscanf_s</TT> function is identical to<TT> sscanf_s</TT> except that it accepts wide-character string arguments
for<B> s</B> and<B> format</B>.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> sscanf_s</TT> function returns <TT> EOF</TT> if an input failure occurred before any conversion or if there was a
runtime-constraint violation.&nbsp; Otherwise, the<TT> sscanf_s</TT> function returns the number of input items successfully
assigned, which can be fewer than provided for, or even zero.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#cscanf">cscanf</A>, <A HREF="#fscanf">fscanf</A>, <A HREF="#scanf">scanf</A>, <A HREF="#sscanf">sscanf</A>, <A HREF="#vcscanf">vcscanf</A>,
<A HREF="#vfscanf">vfscanf</A>, <A HREF="#vscanf">vscanf</A>, <A HREF="#vsscanf">vsscanf</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__ 1</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int day, year;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char weekday[10], month[10];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; sscanf_s( &quot;Friday August 0013 2004&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;%s %s %d&nbsp; %d&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; weekday, sizeof( weekday ),</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; month, sizeof( month ),</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;day, &amp;year );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf_s( &quot;%s %s %d %d\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; weekday, month, day, year );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>Friday August 13 2004</TT>
</DL>
<DL>
<DT>Classification:
<DD>TR 24731
</DL>
<DL>
<DT>Systems:
<DD><TT> sscanf_s - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>swscanf_s - All, Linux</TT>
</DL>
<H2 ID="stackavail"> stackavail, _stackavail </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;malloc.h&gt;</TT>
<BR><TT>size_t stackavail( void );</TT>
<BR><TT>size_t _stackavail( void );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> stackavail</TT> function returns the number of bytes currently available in the stack.&nbsp; This value is usually
used to determine an appropriate amount to allocate using alloca.
<BR><BR>The<TT> _stackavail</TT> function is identical to<TT> stackavail</TT>.&nbsp; Use<TT> _stackavail</TT> for ANSI naming
conventions.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> stackavail</TT> function returns the number of bytes currently available in the stack.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#alloca">alloca</A>, <A HREF="#calloc">calloc</A> Functions, <A HREF="#malloc">malloc</A> Functions
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>#include &lt;malloc.h&gt;</TT>
<BR><TT>#include &lt;fcntl.h&gt;</TT>
<BR><TT>#include &lt;io.h&gt;</TT>
<BR><BR><TT>long char_count( FILE *fp )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; *buffer;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; size_t&nbsp; bufsiz;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; long&nbsp;&nbsp;&nbsp; count;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* allocate half of stack for temp buffer */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; bufsiz = stackavail() &gt;&gt; 1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; buffer = (char *) alloca( bufsiz );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; setvbuf( fp, buffer, _IOFBF, bufsiz );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; count = 0L;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; while( fgetc( fp ) != EOF ) ++count;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; fclose( fp );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; return( count );</TT>
<BR><TT>}</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FILE&nbsp;&nbsp;&nbsp; *fp;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; fp = fopen( &quot;file&quot;, &quot;rb&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( fp != NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setmode( fileno( fp ), O_BINARY );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;File contains %lu characters\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char_count( fp ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( fp );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
<BR><BR>_stackavail conforms to ANSI naming conventions
</DL>
<DL>
<DT>Systems:
<DD><TT> stackavail - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_stackavail - All, Linux, RDOS, Netware</TT>
</DL>
<H2 ID="stat"> stat, _stat, _stati64, _wstat, _wstati64, lstat </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;sys/stat.h&gt;</TT>
<BR><TT>int stat( const char *path, struct stat *buf );</TT>
<BR><TT>int _stat( const char *path, struct _stat *buf );</TT>
<BR><TT>int _stati64( const char *path, struct _stati64 *buf );</TT>
<BR><TT>int _wstat( const wchar_t *path, struct _stat *buf );</TT>
<BR><TT>int _wstati64( const wchar_t *path, struct _stati64 *buf );</TT>
<BR><TT>int lstat( const char *path, struct stat *buf );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> stat</TT> functions obtain information about the file or directory referenced in<B> path</B>.&nbsp; This information
is placed in the structure located at the address indicated by<B> buf</B>.
<BR><BR>The file<TT> &lt;sys/stat.h&gt;</TT> contains definitions for the structure <TT> stat</TT>.
<DL>
<DT>Field&nbsp;&nbsp;&nbsp;&nbsp; Type/Meaning
<DT>st_dev
<DD>(dev_t) the disk drive the file resides on
<DT>st_ino
<DD>(ino_t) this inode's number (not used for DOS)
<DT>st_mode
<DD>(unsigned short) file mode
<DT>st_nlink
<DD>(short) number of hard links
<DT>st_uid
<DD>(unsigned long) user-id (always 'root' for DOS)
<DT>st_gid
<DD>(short) group-id (always 'root' for DOS)
<DT>st_rdev
<DD>(dev_t) this should be the device type but it is the same as st_dev for the time being
<DT>st_size
<DD>(off_t) total file size
<DT>st_atime
<DD>(time_t) this should be the file &quot;last accessed&quot; time if the file system supports it
<DT>st_mtime
<DD>(time_t) the file &quot;last modified&quot; time
<DT>st_ctime
<DD>(time_t) this should be the file &quot;last status change&quot; time if the file system supports it
<BR><BR><B>The following fields are Netware only:</B>
<DT>st_btime
<DD>(time_t) the file &quot;last archived&quot; time
<DT>st_attr
<DD>(unsigned long) the file's attributes
<DT>st_archivedID
<DD>(unsigned long) the user/object ID that last archived file
<DT>st_updatedID
<DD>(unsigned long) the user/object ID that last updated file
<DT>st_inheritedRightsMask
<DD>(unsigned short) the inherited rights mask
<DT>st_originatingNameSpace
<DD>(unsigned char) the originating name space
</DL>
<BR>The structure <TT> _stati64</TT> differs from <TT> stat</TT> in the following way:
<DL>
<DT>st_size
<DD>(__int64) total file size (as a 64-bit value)
</DL>
<BR>At least the following macros are defined in the<TT> &lt;sys/stat.h&gt;</TT> header file.
<DL>
<DT>Macro&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>S_ISFIFO(m)
<DD>Test for FIFO.
<DT>S_ISCHR(m)
<DD>Test for character special file.
<DT>S_ISDIR(m)
<DD>Test for directory file.
<DT>S_ISBLK(m)
<DD>Test for block special file.
<DT>S_ISREG(m)
<DD>Test for regular file.
</DL>
<BR>The value<B> m</B> supplied to the macros is the value of the <TT> st_mode</TT> field of a <TT> stat</TT> structure.&nbsp;
The macro evaluates to a non-zero value if the test is true and zero if the test is false.
<BR><BR>The following bits are encoded within the <TT> st_mode</TT> field of a <TT> stat</TT> structure.
<DL>
<DT>Mask&nbsp;&nbsp;&nbsp;&nbsp; Owner Permissions
<DT>S_IRWXU
<DD>Read, write, search (if a directory), or execute (otherwise)
<DT>S_IRUSR
<DD>Read permission bit
<DT>S_IWUSR
<DD>Write permission bit
<DT>S_IXUSR
<DD>Search/execute permission bit
<DT>S_IREAD
<DD>== <TT> S_IRUSR</TT> (for Microsoft compatibility)
<DT>S_IWRITE
<DD>== <TT> S_IWUSR</TT> (for Microsoft compatibility)
<DT>S_IEXEC
<DD>== <TT> S_IXUSR</TT> (for Microsoft compatibility)
</DL>
<BR><TT> S_IRWXU</TT> is the bitwise inclusive OR of <TT> S_IRUSR</TT>, <TT> S_IWUSR</TT>, and <TT> S_IXUSR</TT>.
<DL>
<DT>Mask&nbsp;&nbsp;&nbsp;&nbsp; Group Permissions (same as owner's on DOS, OS/2 or Windows)
<DT>S_IRWXG
<DD>Read, write, search (if a directory), or execute (otherwise)
<DT>S_IRGRP
<DD>Read permission bit
<DT>S_IWGRP
<DD>Write permission bit
<DT>S_IXGRP
<DD>Search/execute permission bit
</DL>
<BR><TT> S_IRWXG</TT> is the bitwise inclusive OR of <TT> S_IRGRP</TT>, <TT> S_IWGRP</TT>, and <TT> S_IXGRP</TT>.
<DL>
<DT>Mask&nbsp;&nbsp;&nbsp;&nbsp; Other Permissions (same as owner's on DOS, OS/2 or Windows)
<DT>S_IRWXO
<DD>Read, write, search (if a directory), or execute (otherwise)
<DT>S_IROTH
<DD>Read permission bit
<DT>S_IWOTH
<DD>Write permission bit
<DT>S_IXOTH
<DD>Search/execute permission bit
</DL>
<BR><TT> S_IRWXO</TT> is the bitwise inclusive OR of <TT> S_IROTH</TT>, <TT> S_IWOTH</TT>, and <TT> S_IXOTH</TT>.
<DL>
<DT>Mask&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>S_ISUID
<DD>(Not supported by DOS, OS/2 or Windows) Set user ID on execution.&nbsp; The process's effective user ID shall be set to that
of the owner of the file when the file is run as a program.&nbsp; On a regular file, this bit should be cleared on any write.
<DT>S_ISGID
<DD>(Not supported by DOS, OS/2 or Windows) Set group ID on execution.&nbsp; Set effective group ID on the process to the file's
group when the file is run as a program.&nbsp; On a regular file, this bit should be cleared on any write.
</DL>
<BR>The<TT> _stat</TT> function is identical to<TT> stat</TT>.&nbsp; Use<TT> _stat</TT> for ANSI naming conventions.
<BR><BR>The <TT> _stati64</TT>, <TT> _wstat</TT>, and <TT> _wstati64</TT> functions differ from<TT> stat</TT> in the type
of structure that they are asked to fill in.&nbsp; The <TT> _wstat</TT> and <TT> _wstati64</TT> functions deal with wide character
strings.&nbsp; The differences in the structures are described above.&nbsp; The <TT> lstat</TT> function is identical to<TT>
stat</TT> on non-UNIX platforms.
</DL>
<DL>
<DT>Returns:
<DD>All forms of the<TT> stat</TT> function return zero when the information is successfully obtained.&nbsp; Otherwise, -1 is
returned.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
<DL>
<DT>EACCES
<DD>Search permission is denied for a component of<B> path</B>.
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#fstat">fstat</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;sys/stat.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct stat buf;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; if( stat( &quot;file&quot;, &amp;buf ) != -1 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;File size = %d\n&quot;, buf.st_size );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>POSIX
<BR><BR>_stat conforms to ANSI naming conventions
<BR>_stati64 is WATCOM
<BR>_wstat is WATCOM
<BR>_wstati64 is WATCOM
<BR>lstat is POSIX
</DL>
<DL>
<DT>Systems:
<DD><TT> stat - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_stat - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
<BR><TT>_stati64 - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</TT>
<BR><TT>_wstat - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</TT>
<BR><TT>_wstati64 - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</TT>
<BR><TT>lstat - All, Linux, RDOS, Netware</TT>
</DL>
<H2 ID="_status87"> _status87 </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;float.h&gt;</TT>
<BR><TT>unsigned int _status87( void );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _status87</TT> function returns the floating-point status word which is used to record the status of 8087/80287/80387/80486
floating-point operations.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _status87</TT> function returns the floating-point status word which is used to record the status of 8087/80287/80387/80486
floating-point operations.&nbsp; The description of this status is found in the<TT> &lt;float.h&gt;</TT> header file.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_clear87">_clear87</A>, <A HREF="#_control87">_control87</A>, <A HREF="#_controlfp">_controlfp</A>, <A HREF="#_finite">_finite</A>,
<A HREF="#_fpreset">_fpreset</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;float.h&gt;</TT>
<BR><BR><TT>#define TEST_FPU(x,y) printf( &quot;\t%s &quot; y &quot;\n&quot;, \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((fp_status &amp; x) ?
&quot;&nbsp; &quot; : &quot;No&quot;) )</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned int fp_status;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; fp_status = _status87();</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;80x87 status\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; TEST_FPU( SW_INVALID, &quot;invalid operation&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; TEST_FPU( SW_DENORMAL, &quot;denormalized operand&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; TEST_FPU( SW_ZERODIVIDE, &quot;divide by zero&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; TEST_FPU( SW_OVERFLOW, &quot;overflow&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; TEST_FPU( SW_UNDERFLOW, &quot;underflow&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; TEST_FPU( SW_INEXACT, &quot;inexact result&quot; );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>Intel
</DL>
<DL>
<DT>Systems:
<DD>Math
</DL>
<H2 ID="strcasecmp"> strcasecmp </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;strings.h&gt;</TT>
<BR><TT>int strcasecmp( const char *s1, const char *s2 );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> strcasecmp</TT> function compares, with case insensitivity, the string pointed to by<B> s1</B> to the string pointed
to by<B> s2</B>.&nbsp; All uppercase characters from<B> s1</B> and<B> s2</B> are mapped to lowercase for the purposes of doing
the comparison.
<BR><BR>The<TT> strcasecmp</TT> function is identical to the <TT> stricmp</TT> function.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> strcasecmp</TT> function returns an integer less than, equal to, or greater than zero, indicating that the string
pointed to by<B> s1</B> is, ignoring case, less than, equal to, or greater than the string pointed to by<B> s2</B>.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#strcmp">strcmp</A>, <A HREF="#strcmpi">strcmpi</A>, <A HREF="#stricmp">stricmp</A>, <A HREF="#strncmp">strncmp</A>,
<A HREF="#strnicmp">strnicmp</A>, <A HREF="#strncasecmp">strncasecmp</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;strings.h&gt;</TT>
<BR><BR><TT>int main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strcasecmp( &quot;AbCDEF&quot;, &quot;abcdef&quot; ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strcasecmp( &quot;abcdef&quot;, &quot;ABC&quot;&nbsp;&nbsp;&nbsp; ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strcasecmp( &quot;abc&quot;,&nbsp;&nbsp;&nbsp; &quot;ABCdef&quot; ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strcasecmp( &quot;Abcdef&quot;, &quot;mnopqr&quot; ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strcasecmp( &quot;Mnopqr&quot;, &quot;abcdef&quot; ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; return( 0 );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>0</TT>
<BR><TT>100</TT>
<BR><TT>-100</TT>
<BR><TT>-12</TT>
<BR><TT>12</TT>
</DL>
<DL>
<DT>Classification:
<DD>POSIX
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="strcat"> strcat, _fstrcat, wcscat, _mbscat, _fmbscat </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>char *strcat( char *dst, const char *src );</TT>
<BR><TT>char __far *_fstrcat( char __far *dst,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; const char __far *src );</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>wchar_t *wcscat( wchar_t *dst, const wchar_t *src );</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>unsigned char *_mbscat( unsigned char *dst,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned
char *src );</TT>
<BR><TT>unsigned char __far *_fmbscat( unsigned char __far *dst,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char __far *src );</TT>
</DL>
<DL>
<DT>Safer C:
<DD>The Safer C Library extension provides the <A HREF="#strcat_s">strcat_s</A> function which is a safer alternative to<TT> strcat</TT>
This newer<TT> strcat_s</TT> function is recommended to be used instead of the traditional &quot;unsafe&quot;<TT> strcat</TT>
function.
</DL>
<DL>
<DT>Description:
<DD>The<TT> strcat</TT> function appends a copy of the string pointed to by<B> src</B> (including the terminating null character)
to the end of the string pointed to by<B> dst</B>.&nbsp; The first character of<B> src</B> overwrites the null character at
the end of<B> dst</B>.
<BR><BR>The<TT> _fstrcat</TT> function is a data model independent form of the strcat function.&nbsp; It accepts far pointer
arguments and returns a far pointer.&nbsp; It is most useful in mixed memory model applications.
<BR><BR>The<TT> wcscat</TT> function is a wide-character version of<TT> strcat</TT> that operates with wide-character strings.
<BR><BR>The<TT> _mbscat</TT> function is a multibyte character version of<TT> strcat</TT> that operates with multibyte character
strings.
</DL>
<DL>
<DT>Returns:
<DD>The value of<B> dst</B> is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#strncat">strncat</A>, <A HREF="#strcat_s">strcat_s</A>, <A HREF="#strncat_s">strncat_s</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char buffer[80];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; strcpy( buffer, &quot;Hello &quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; strcat( buffer, &quot;world&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, buffer );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>Hello world</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>_fstrcat is WATCOM
<BR>_mbscat is WATCOM
<BR>_fmbscat is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> strcat - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_fstrcat - All, Linux, RDOS</TT>
<BR><TT>wcscat - All, Linux</TT>
<BR><TT>_mbscat - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
<BR><TT>_fmbscat - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="strcat_s"> strcat_s, wcscat_s </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__&nbsp; 1</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>errno_t strcat_s( char * restrict s1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rsize_t s1max,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char
* restrict s2 );</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>errno_t wcscat_s( wchar_t * restrict s1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rsize_t s1max,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t
* restrict s2 );</TT>
</DL>
<DL>
<DT>Constraints:
<DD>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<TT>
strcat_s</TT> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<BR><BR>Let<B> m</B> denote the value<B> s1max - strnlen_s(s1, s1max)</B> upon entry to <TT> strcat_s</TT>.&nbsp; Neither<B>
s1</B> nor<B> s2</B> shall be a null pointer.<B>&nbsp; s1max</B> shall not be greater than <TT> RSIZE_MAX</TT>.<B>&nbsp; s1max</B>
shall not equal zero.<B>&nbsp; m</B> shall not equal zero.<B>&nbsp; m</B> shall be greater than<B> strnlen_s(s2, m)</B>.&nbsp;
Copying shall not take place between objects that overlap.
<BR><BR>If there is a runtime-constraint violation, then if<B> s1</B> is not a null pointer and<B> s1max</B> is greater than
zero and not greater than <TT> RSIZE_MAX</TT>, then <TT> strcat_s</TT> sets<B> s1[0]</B> to the null character.
</DL>
<DL>
<DT>Description:
<DD>The<TT> strcat_s</TT> function appends a copy of the string pointed to by<B> s2</B> (including the terminating null character)
to the end of the string pointed to by<B> s1</B>.&nbsp; The initial character from<B> s2</B> overwrites the null character
at the end of<B> s1</B>.&nbsp; All elements following the terminating null character (if any) written by<TT> strcat_s</TT>
in the array of<B> s1max</B> characters pointed to by<B> s1</B> take unspecified values when<TT> strcat_s</TT> returns.
<BR><BR>The<TT> wcscat_s</TT> function is a wide-character version of<TT> strcat_s</TT> that operates with wide-character
strings.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> strcat_s</TT> function returns zero if there was no runtime-constraint violation.&nbsp; Otherwise, a non-zero value
is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#strcat">strcat</A>, <A HREF="#strncat">strncat</A>, <A HREF="#strncat_s">strncat_s</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__&nbsp; 1</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char buffer[80];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; strcpy_s( buffer, sizeof( buffer ), &quot;Hello &quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; strcat_s( buffer, sizeof( buffer ), &quot;world&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, buffer );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>Hello world</TT>
</DL>
<DL>
<DT>Classification:
<DD>TR 24731
</DL>
<DL>
<DT>Systems:
<DD><TT> strcat_s - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>wcscat_s - All, Linux</TT>
</DL>
<H2 ID="strchr"> strchr, _fstrchr, wcschr, _mbschr, _fmbschr </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>char *strchr( const char *s, int c );</TT>
<BR><TT>char __far *_fstrchr( const char __far *s, int c );</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>wchar_t *wcschr( const wchar_t *s, wint_t c );</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>unsigned char *_mbschr( const unsigned char *s,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; unsigned int c );</TT>
<BR><TT>unsigned char __far *_fmbschr(</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char __far *s,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int c );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> strchr</TT> function locates the first occurrence of<B> c</B> (converted to a char) in the string pointed to by<B>
s</B>.&nbsp; The terminating null character is considered to be part of the string.
<BR><BR>The<TT> _fstrchr</TT> function is a data model independent form of the strchr function.&nbsp; It accepts far pointer
arguments and returns a far pointer.&nbsp; It is most useful in mixed memory model applications.
<BR><BR>The<TT> wcschr</TT> function is a wide-character version of<TT> strchr</TT> that operates with wide-character strings.
<BR><BR>The<TT> _mbschr</TT> function is a multibyte character version of<TT> strchr</TT> that operates with multibyte character
strings.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> strchr</TT> function returns a pointer to the located character, or<TT> NULL</TT> if the character does not occur
in the string.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#memchr">memchr</A>, <A HREF="#strcspn">strcspn</A>, <A HREF="#strrchr">strrchr</A>, <A HREF="#strspn">strspn</A>,
<A HREF="#strstr">strstr</A>, <A HREF="#strtok">strtok</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char buffer[80];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char *where;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; strcpy( buffer, &quot;video x-rays&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; where = strchr( buffer, 'x' );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( where == NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;'x' not found\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>_fstrchr is WATCOM
<BR>_mbschr is WATCOM
<BR>_fmbschr is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> strchr - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_fstrchr - All, Linux, RDOS</TT>
<BR><TT>wcschr - All, Linux</TT>
<BR><TT>_mbschr - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
<BR><TT>_fmbschr - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="strcmp"> strcmp, _fstrcmp, wcscmp, _mbscmp, _fmbscmp </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>int strcmp( const char *s1, const char *s2 );</TT>
<BR><TT>int _fstrcmp( const char __far *s1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char __far *s2 );</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>int wcscmp( const wchar_t *s1, const wchar_t *s2 );</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>int _mbscmp( const unsigned char *s1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char *s2 );</TT>
<BR><TT>int _fmbscmp( const unsigned char __far *s1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char __far *s2 );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> strcmp</TT> function compares the string pointed to by<B> s1</B> to the string pointed to by<B> s2</B>.
<BR><BR>The<TT> _fstrcmp</TT> function is a data model independent form of the strcmp function that accepts far pointer arguments.
&nbsp;It is most useful in mixed memory model applications.
<BR><BR>The<TT> wcscmp</TT> function is a wide-character version of<TT> strcmp</TT> that operates with wide-character strings.
<BR><BR>The<TT> _mbscmp</TT> function is a multibyte character version of<TT> strcmp</TT> that operates with multibyte character
strings.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> strcmp</TT> function returns an integer less than, equal to, or greater than zero, indicating that the string pointed
to by<B> s1</B> is less than, equal to, or greater than the string pointed to by<B> s2</B>.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#strcmpi">strcmpi</A>, <A HREF="#stricmp">stricmp</A>, <A HREF="#strncmp">strncmp</A>, <A HREF="#strnicmp">strnicmp</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strcmp( &quot;abcdef&quot;, &quot;abcdef&quot; ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strcmp( &quot;abcdef&quot;, &quot;abc&quot; ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strcmp( &quot;abc&quot;, &quot;abcdef&quot; ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strcmp( &quot;abcdef&quot;, &quot;mnopqr&quot; ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strcmp( &quot;mnopqr&quot;, &quot;abcdef&quot; ) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>0</TT>
<BR><TT>1</TT>
<BR><TT>-1</TT>
<BR><TT>-1</TT>
<BR><TT>1</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>_fstrcmp is WATCOM
<BR>_mbscmp is WATCOM
<BR>_fmbscmp is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> strcmp - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_fstrcmp - All, Linux, RDOS</TT>
<BR><TT>wcscmp - All, Linux</TT>
<BR><TT>_mbscmp - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
<BR><TT>_fmbscmp - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="strcmpi"> strcmpi, wcscmpi </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>int strcmpi( const char *s1, const char *s2 );</TT>
<BR><TT>int wcscmpi( const wchar_t *s1, const wchar_t *s2 );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> strcmpi</TT> function compares, with case insensitivity, the string pointed to by<B> s1</B> to the string pointed
to by<B> s2</B>.&nbsp; All uppercase characters from<B> s1</B> and<B> s2</B> are mapped to lowercase for the purposes of doing
the comparison.&nbsp; The<TT> strcmpi</TT> function is identical to the <TT> stricmp</TT> function.
<BR><BR>The<TT> wcscmpi</TT> function is a wide-character version of<TT> strcmpi</TT> that operates with wide-character strings.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> strcmpi</TT> function returns an integer less than, equal to, or greater than zero, indicating that the string pointed
to by<B> s1</B> is less than, equal to, or greater than the string pointed to by<B> s2</B>.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#strcmp">strcmp</A>, <A HREF="#stricmp">stricmp</A>, <A HREF="#strncmp">strncmp</A>, <A HREF="#strnicmp">strnicmp</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strcmpi( &quot;AbCDEF&quot;, &quot;abcdef&quot; ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strcmpi( &quot;abcdef&quot;, &quot;ABC&quot;&nbsp;&nbsp;&nbsp; ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strcmpi( &quot;abc&quot;,&nbsp;&nbsp;&nbsp; &quot;ABCdef&quot; ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strcmpi( &quot;Abcdef&quot;, &quot;mnopqr&quot; ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strcmpi( &quot;Mnopqr&quot;, &quot;abcdef&quot; ) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>0</TT>
<BR><TT>100</TT>
<BR><TT>-100</TT>
<BR><TT>-12</TT>
<BR><TT>12</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> strcmpi - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>wcscmpi - All, Linux</TT>
</DL>
<H2 ID="strcoll"> strcoll, wcscoll, _mbscoll </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>int strcoll( const char *s1, const char *s2 );</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>int wcscoll( const wchar_t *s1, const wchar_t *s2 );</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>int _mbscoll( const unsigned char *s1, const unsigned char *s2 );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> strcoll</TT> function compares the string pointed to by<B> s1</B> to the string pointed to by<B> s2</B>.&nbsp; The
comparison uses the collating sequence selected by the <TT> setlocale</TT> function.&nbsp; The function will be equivalent
to the <TT> strcmp</TT> function when the collating sequence is selected from the<TT> &quot;C&quot;</TT> locale.
<BR><BR>The<TT> wcscoll</TT> function is a wide-character version of<TT> strcoll</TT> that operates with wide-character strings.
<BR><BR>The<TT> _mbscoll</TT> function is a multibyte character version of<TT> strcoll</TT> that operates with multibyte character
strings.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> strcoll</TT> function returns an integer less than, equal to, or greater than zero, indicating that the string pointed
to by<B> s1</B> is less than, equal to, or greater than the string pointed to by<B> s2</B>, according to the collating sequence
selected.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#setlocale">setlocale</A>, <A HREF="#strcmp">strcmp</A>, <A HREF="#strncmp">strncmp</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><BR><TT>char buffer[80] = &quot;world&quot;;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( strcoll( buffer, &quot;Hello&quot; ) &lt; 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Less than\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>_mbscoll is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> strcoll - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>wcscoll - All, Linux</TT>
<BR><TT>_mbscoll - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="strcpy"> strcpy, _fstrcpy, wcscpy, _mbscpy, _fmbscpy </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>char *strcpy( char *dst, const char *src );</TT>
<BR><TT>char __far *_fstrcpy( char __far *dst,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; const char __far *src );</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>wchar_t *wcscpy( wchar_t *dst, const wchar_t *src );</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>int _mbscpy( unsigned char *dst,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char *src );</TT>
<BR><TT>int _fmbscpy( unsigned char __far *dst,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char __far *src );</TT>
</DL>
<DL>
<DT>Safer C:
<DD>The Safer C Library extension provides the <A HREF="#strcpy_s">strcpy_s</A> function which is a safer alternative to<TT> strcpy</TT>
This newer<TT> strcpy_s</TT> function is recommended to be used instead of the traditional &quot;unsafe&quot;<TT> strcpy</TT>
function.
</DL>
<DL>
<DT>Description:
<DD>The<TT> strcpy</TT> function copies the string pointed to by<B> src</B> (including the terminating null character) into the
array pointed to by<B> dst</B>.&nbsp; Copying of overlapping objects is not guaranteed to work properly.&nbsp; See the description
for the <TT> memmove</TT> function to copy objects that overlap.
<BR><BR>The<TT> _fstrcpy</TT> function is a data model independent form of the strcpy function.&nbsp; It accepts far pointer
arguments and returns a far pointer.&nbsp; It is most useful in mixed memory model applications.
<BR><BR>The<TT> wcscpy</TT> function is a wide-character version of<TT> strcpy</TT> that operates with wide-character strings.
<BR><BR>The<TT> _mbscpy</TT> function is a multibyte character version of<TT> strcpy</TT> that operates with multibyte character
strings.
</DL>
<DL>
<DT>Returns:
<DD>The value of<B> dst</B> is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#strdup">strdup</A>, <A HREF="#strncpy">strncpy</A>, <A HREF="#strcpy_s">strcpy_s</A>, <A HREF="#strncpy_s">strncpy_s</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; auto char buffer[80];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; strcpy( buffer, &quot;Hello &quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; strcat( buffer, &quot;world&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, buffer );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>Hello world</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>_fstrcpy is WATCOM
<BR>_mbscpy is WATCOM
<BR>_fmbscpy is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> strcpy - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_fstrcpy - All, Linux, RDOS</TT>
<BR><TT>wcscpy - All, Linux</TT>
<BR><TT>_mbscpy - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
<BR><TT>_fmbscpy - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="strcpy_s"> strcpy_s, wcscpy_s </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__&nbsp; 1</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>errno_t strcpy_s( char * restrict s1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rsize_t s1max,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char
* restrict s2 );</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>errno_t wcscpy_s( wchar_t * restrict s1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rsize_t s1max,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t
* restrict s2 );</TT>
</DL>
<DL>
<DT>Constraints:
<DD>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<TT>
strcpy_s</TT> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<BR><BR>Neither<B> s1</B> nor<B> s2</B> shall be a null pointer.<B>&nbsp; s1max</B> shall not be greater than <TT> RSIZE_MAX</TT>.<B>
&nbsp;s1max</B> shall not equal zero.<B>&nbsp; s1max</B> shall be greater than<B> strnlen_s(s2, s1max)</B>.&nbsp; Copying
shall not take place between objects that overlap.
<BR><BR>If there is a runtime-constraint violation, then if<B> s1</B> is not a null pointer and<B> s1max</B> is greater than
zero and not greater than <TT> RSIZE_MAX</TT> , then <TT> strcpy_s</TT> sets<B> s1[0]</B> to the null character.
</DL>
<DL>
<DT>Description:
<DD>The<TT> strcpy_s</TT> function copies the string pointed to by<B> s2</B> (including the terminating null character) into the
array pointed to by<B> s1</B>.&nbsp; All elements following the terminating null character (if any) written by<TT> strcpy_s</TT>
in the array of<B> s1max</B> characters pointed to by<B> s1</B> take unspecified values when<TT> strcpy_s</TT> returns.
<BR><BR>The<TT> wcscpy_s</TT> function is a wide-character version of<TT> strcpy_s</TT> that operates with wide-character
strings.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> strcpy_s</TT> function returns zero if there was no runtime-constraint violation.&nbsp; Otherwise, a non-zero value
is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#strcpy">strcpy</A>, <A HREF="#strdup">strdup</A>, <A HREF="#strncpy">strncpy</A>, <A HREF="#strncpy_s">strncpy_s</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__&nbsp; 1</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; auto char buffer[80];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; strcpy_s( buffer, sizeof( buffer ), &quot;Hello &quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; strcat_s( buffer, sizeof( buffer ), &quot;world&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, buffer );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>Hello world</TT>
</DL>
<DL>
<DT>Classification:
<DD>TR 24731
</DL>
<DL>
<DT>Systems:
<DD><TT> strcpy_s - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>wcscpy_s - All, Linux</TT>
</DL>
<H2 ID="strcspn"> strcspn, _fstrcspn, wcscspn, _mbscspn, _fmbscspn </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>size_t strcspn( const char *str,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *charset );</TT>
<BR><TT>size_t _fstrcspn( const char __far *str,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char
__far *charset );</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>size_t wcscspn( const wchar_t *str,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t *charset
);</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>size_t _mbscpsn( const unsigned char *str,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char
*charset );</TT>
<BR><TT>size_t _fmbscpsn( const unsigned char __far *str,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned
char __far *charset );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> strcspn</TT> function computes the length, in bytes, of the initial segment of the string pointed to by<B> str</B>
which consists entirely of characters<B> not</B> from the string pointed to by<B> charset</B>.&nbsp; The terminating null
character is not considered part of<B> str</B>.
<BR><BR>The<TT> _fstrcspn</TT> function is a data model independent form of the strcspn function that accepts far pointer
arguments.&nbsp; It is most useful in mixed memory model applications.
<BR><BR>The<TT> wcscspn</TT> function is a wide-character version of<TT> strcspn</TT> that operates with wide-character strings.
<BR><BR>The<TT> _mbscspn</TT> function is a multibyte character version of<TT> strcspn</TT> that operates with multibyte character
strings.
</DL>
<DL>
<DT>Returns:
<DD>The length, in bytes, of the initial segment is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#strspn">strspn</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strcspn( &quot;abcbcadef&quot;, &quot;cba&quot; ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strcspn( &quot;xxxbcadef&quot;, &quot;cba&quot; ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strcspn( &quot;123456789&quot;, &quot;cba&quot; ) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>0</TT>
<BR><TT>3</TT>
<BR><TT>9</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>_fstrcspn is WATCOM
<BR>_mbscspn is WATCOM
<BR>_fmbscspn is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> strcspn - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_fstrcspn - All, Linux, RDOS</TT>
<BR><TT>wcscspn - All, Linux</TT>
<BR><TT>_mbscspn - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
<BR><TT>_fmbscspn - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="_strdate"> _strdate, _wstrdate </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;time.h&gt;</TT>
<BR><TT>char *_strdate( char *datestr )</TT>
<BR><TT>wchar_t _wstrdate( wchar_t *datestr );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _strdate</TT> function copies the current date to the buffer pointed to by<B> datestr</B>.&nbsp; The date is formatted
as &quot;MM/DD/YY&quot; where &quot;MM&quot; is two digits representing the month, where &quot;DD&quot; is two digits representing
the day, and where &quot;YY&quot; is two digits representing the year.&nbsp; The buffer must be at least 9 bytes long.
<BR><BR>The<TT> _wstrdate</TT> function is a wide-character version of<TT> _strdate</TT> that operates with wide-character
strings.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _strdate</TT> function returns a pointer to the resulting text string<B> datestr</B>.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#asctime">asctime</A> Functions, <A HREF="#ctime">ctime</A> Functions, <A HREF="#gmtime">gmtime</A>, <A HREF="#localtime">localtime</A>,
<A HREF="#mktime">mktime</A>, <A HREF="#_strtime">_strtime</A>, <A HREF="#time">time</A>, <A HREF="#tzset">tzset</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;time.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char datebuff[9];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, _strdate( datebuff ) );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> _strdate - All, Linux, RDOS</TT>
<BR><BR><TT>_wstrdate - All, Linux</TT>
</DL>
<H2 ID="_strdec"> _strdec, _wcsdec, _mbsdec, _fmbsdec </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;tchar.h&gt;</TT>
<BR><TT>char *_strdec( const char *start, const char *current );</TT>
<BR><TT>wchar_t *_wcsdec( const wchar_t *start,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t
*current );</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>unsigned char *_mbsdec( const unsigned char *start,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; const unsigned char *current );</TT>
<BR><TT>unsigned char *_fmbsdec( const unsigned char __far *start,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;const unsigned char __far *current );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _strdec</TT> function returns a pointer to the previous character (single-byte, wide, or multibyte) in the string
pointed to by<B> start</B> which must precede<B> current</B>.&nbsp; The current character in the string is pointed to by<B>
current</B>.&nbsp; You must ensure that<B> current</B> does not point into the middle of a multibyte or wide character.
<BR><BR>The function is a data model independent form of the _strdec function that accepts far pointer arguments.&nbsp; It
is most useful in mixed memory model applications.
<BR><BR>The<TT> _wcsdec</TT> function is a wide-character version of<TT> _strdec</TT> that operates with wide-character strings.
<BR><BR>The<TT> _mbsdec</TT> function is a multibyte character version of<TT> _strdec</TT> that operates with multibyte character
strings.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _strdec</TT> function returns a pointer to the previous character (single-byte, wide, or multibyte depending on the
function used).
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_strinc">_strinc</A>, <A HREF="#_strninc">_strninc</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><BR><TT>const unsigned char chars[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ' ',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '.',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '1',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'A',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x81,0x40, /* double-byte space */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x82,0x60, /* double-byte A */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x82,0xA6, /* double-byte Hiragana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x83,0x42, /* double-byte Katakana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana punctuation */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA6,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xDF,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xE0,0xA1, /* double-byte Kanji */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x00</TT>
<BR><TT>};</TT>
<BR><BR><TT>#define SIZE sizeof( chars ) / sizeof( unsigned char )</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
j, k;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; const unsigned char *prev;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; prev = &amp;chars[ SIZE - 1 ];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; do {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prev = _mbsdec( chars, prev );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j = mblen( prev, MB_CUR_MAX );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( j == 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if ( j == 1 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = *prev;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if( j == 2 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = *(prev)&lt;&lt;8 | *(prev+1);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Previous character %#6.4x\n&quot;, k );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; } while( prev != chars );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>Previous character 0xe0a1</TT>
<BR><TT>Previous character 0x00df</TT>
<BR><TT>Previous character 0x00a6</TT>
<BR><TT>Previous character 0x00a1</TT>
<BR><TT>Previous character 0x8342</TT>
<BR><TT>Previous character 0x82a6</TT>
<BR><TT>Previous character 0x8260</TT>
<BR><TT>Previous character 0x8140</TT>
<BR><TT>Previous character 0x0041</TT>
<BR><TT>Previous character 0x0031</TT>
<BR><TT>Previous character 0x002e</TT>
<BR><TT>Previous character 0x0020</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> _strdec - MACRO</TT>
<BR><BR><TT>_wcsdec - MACRO</TT>
<BR><TT>_mbsdec - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
<BR><TT>_fmbsdec - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="strdup"> strdup, _strdup, _fstrdup, _wcsdup, _mbsdup, _fmbsdup </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>char *strdup( const char *src );</TT>
<BR><TT>char *_strdup( const char *src );</TT>
<BR><TT>char __far *_fstrdup( const char __far *src );</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>wchar_t *_wcsdup( const wchar_t *src );</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>unsigned char *_mbsdup( unsigned char *src );</TT>
<BR><TT>unsigned char __far *_fmbsdup( unsigned char __far *src );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> strdup</TT> function creates a duplicate copy of the string pointed to by<B> src</B> and returns a pointer to the
new copy.&nbsp; For<TT> strdup</TT> the memory for the new string is obtained by using the <TT> malloc</TT> function and can
be freed using the <TT> free</TT> function.&nbsp; For _fstrdup, the memory for the new string is obtained by using the <TT>
_fmalloc</TT> function and can be freed using the <TT> _ffree</TT> function.
<BR><BR>The<TT> _strdup</TT> function is identical to<TT> strdup</TT>.&nbsp; Use<TT> _strdup</TT> for ANSI naming conventions.
<BR><BR>The<TT> _fstrdup</TT> function is a data model independent form of the strdup function that accepts far pointer arguments.
&nbsp;It is most useful in mixed memory model applications.
<BR><BR>The<TT> _wcsdup</TT> function is a wide-character version of<TT> strdup</TT> that operates with wide-character strings.
<BR><BR>The<TT> _mbsdup</TT> function is a multibyte character version of<TT> strdup</TT> that operates with multibyte character
strings.
<BR><BR>The<TT> _fmbsdup</TT> function is a data model independent form of the _mbsdup function that accepts far pointer arguments.
&nbsp;It is most useful in mixed memory model applications.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> strdup</TT> function returns the pointer to the new copy of the string if successful, otherwise it returns<TT> NULL.</TT>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#free">free</A>, <A HREF="#malloc">malloc</A>, <A HREF="#strcpy">strcpy</A>, <A HREF="#strncpy">strncpy</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char *dup;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; dup = strdup( &quot;Make a copy&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, dup );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
<BR><BR>_strdup conforms to ANSI naming conventions
</DL>
<DL>
<DT>Systems:
<DD><TT> strdup - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_strdup - All, Linux, RDOS, Netware</TT>
<BR><TT>_fstrdup - All, Linux, RDOS</TT>
<BR><TT>_wcsdup - All, Linux, RDOS</TT>
<BR><TT>_mbsdup - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
<BR><TT>_fmbsdup - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="strerror"> strerror, wcserror </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>char *strerror( int errnum );</TT>
<BR><TT>wchar_t *wcserror( int errnum );</TT>
</DL>
<DL>
<DT>Safer C:
<DD>The Safer C Library extension provides the <A HREF="#strerror_s">strerror_s</A> function which is a safer alternative to<TT>
strerror</TT> This newer<TT> strerror_s</TT> function is recommended to be used instead of the traditional &quot;unsafe&quot;<TT>
strerror</TT> function.
</DL>
<DL>
<DT>Description:
<DD>The<TT> strerror</TT> function maps the error number contained in<B> errnum</B> to an error message.
<BR><BR>The<TT> wcserror</TT> function is a wide-character version of<TT> strerror</TT>.&nbsp; It produces a wide-character
string.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> strerror</TT> function returns a pointer to the error message.&nbsp; The array containing the error string should
not be modified by the program.&nbsp; This array may be overwritten by a subsequent call to the strerror function.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#clearerr">clearerr</A>, <A HREF="#feof">feof</A>, <A HREF="#ferror">ferror</A>, <A HREF="#perror">perror</A>, <A HREF="#strerror_s">strerror_s</A>,
<A HREF="#strerrorlen_s">strerrorlen_s</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>#include &lt;errno.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FILE *fp;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; fp = fopen( &quot;file.nam&quot;, &quot;r&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( fp == NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Unable to open file: %s\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strerror( errno )
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD><TT> strerror - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>wcserror - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, Linux</TT>
</DL>
<H2 ID="strerror_s"> strerror_s, wcserror_s </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__&nbsp; 1</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>errno_t strerror_s( char * s,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
rsize_t maxsize,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
errno_t errnum );</TT>
<BR><TT>errno_t wcserror_s( wchar_t * s,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
rsize_t maxsize,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
errno_t errnum );</TT>
</DL>
<DL>
<DT>Constraints:
<DD>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<TT>
strerror_s</TT> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<BR><BR><B>s</B> shall not be a null pointer.<B>&nbsp; maxsize</B> shall not be greater than <TT> RSIZE_MAX</TT>.<B>&nbsp;
maxsize</B> shall not equal zero.
<BR><BR>If there is a runtime-constraint violation, then the array (if any) pointed to by<B> s</B> is not modified.
</DL>
<DL>
<DT>Description:
<DD>The<TT> strerror_s</TT> function maps the number in<B> errnum</B> to a locale-specific message string.&nbsp; Typically,the
values for<B> errnum</B> come from errno, but<TT> strerror_s</TT> shall map any value of type int to a message.&nbsp; If the
length of the desired string is less than<B> maxsize</B>, then the string is copied to the array pointed to by<B> s</B>.&nbsp;
Otherwise, if<B> maxsize</B> is greater than zero, then<B> maxsize-1</B> characters are copied from the string to the array
pointed to by<B> s</B> and then<B> s[maxsize-1]</B> is set to the null character.&nbsp; Then, if<B> maxsize</B> is greater
than 3, then<B> s[maxsize-2], s[maxsize-3]</B>, and<B> s[maxsize-4]</B> are set to the character period (.).
<BR><BR>The<TT> wcserror_s</TT> function is a wide-character version of<TT> strerror_s</TT> that operates with wide-character
strings.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> strerror_s</TT> function returns zero if there was no runtime-constraint violation.&nbsp; Otherwise, a non-zero value
is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#clearerr">clearerr</A>, <A HREF="#feof">feof</A>, <A HREF="#ferror">ferror</A>, <A HREF="#perror">perror</A>, <A HREF="#strerror">strerror</A>,
<A HREF="#strerrorlen_s">strerrorlen_s</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__&nbsp; 1</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>#include &lt;errno.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FILE *fp;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char emsg[ 100 ];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; fp = fopen( &quot;file.nam&quot;, &quot;r&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( fp == NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strerror_s( emsg, sizeof( emsg ), errno );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Unable to open file: %s\n&quot;, emsg );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>TR 24731
</DL>
<DL>
<DT>Systems:
<DD><TT> strerror_s - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>wcserror_s - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, Linux</TT>
</DL>
<H2 ID="strerrorlen_s"> strerrorlen_s, wcserrorlen_s </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__&nbsp; 1</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>size_t strerrorlen_s( errno_t errnum );</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>size_t wcserrorlen_s( errno errnum );</TT>
</DL>
<DL>
<DT>Constraints:
<DD>None.
</DL>
<DL>
<DT>Description:
<DD>The<TT> strerrorlen_s</TT> function calculates the length of the (untruncated) locale-specific message string that the <TT>
strerror_s</TT> function maps to<B> errnum</B>.
<BR><BR>The<TT> wcserrorlen_s</TT> function is a wide-character version of<TT> strerrorlen_s</TT> that operates with wide-character
strings.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> strerrorlen_s</TT> function returns the number of characters (not including the null character) in the full message
string.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#strerror">strerror</A>, <A HREF="#strerror_s">strerror_s</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__&nbsp; 1</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>#include &lt;errno.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FILE&nbsp;&nbsp;&nbsp; *fp;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; emsg[ 100 ];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; size_t&nbsp; emsglen;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; fp = fopen( &quot;file.nam&quot;, &quot;r&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( fp == NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; emsglen = strerrorlen_s( errno );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Length of errormessage: %d\n&quot;, emsglen );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strerror_s( emsg, sizeof( emsg ), errno );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Unable to open file: %s\n&quot;, emsg );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>TR 24731
</DL>
<DL>
<DT>Systems:
<DD><TT> strerrorlen_s - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>wcserrorlen_s - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, Linux</TT>
</DL>
<H2 ID="strftime"> strftime, wcsftime, _wstrftime_ms </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;time.h&gt;</TT>
<BR><TT>size_t strftime( char *s,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t maxsize,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *format,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct tm *timeptr
);</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>size_t wcsftime( wchar_t *s,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t maxsize,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t *format,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct tm *timeptr
);</TT>
<BR><TT>#include &lt;time.h&gt;</TT>
<BR><TT>size_t _wstrftime_ms( wchar_t *s,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; size_t maxsize,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; const char *format,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; const struct tm *timeptr );</TT>
<BR><BR><TT>struct&nbsp; tm {</TT>
<BR><TT>&nbsp; int tm_sec;&nbsp;&nbsp; /* seconds after the minute -- [0,61] */</TT>
<BR><TT>&nbsp; int tm_min;&nbsp;&nbsp; /* minutes after the hour&nbsp;&nbsp; -- [0,59] */</TT>
<BR><TT>&nbsp; int tm_hour;&nbsp; /* hours after midnight&nbsp;&nbsp;&nbsp;&nbsp; -- [0,23] */</TT>
<BR><TT>&nbsp; int tm_mday;&nbsp; /* day of the month&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- [1,31] */</TT>
<BR><TT>&nbsp; int tm_mon;&nbsp;&nbsp; /* months since January&nbsp;&nbsp;&nbsp;&nbsp; -- [0,11] */</TT>
<BR><TT>&nbsp; int tm_year;&nbsp; /* years since 1900&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp; int tm_wday;&nbsp; /* days since Sunday&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- [0,6]&nbsp; */</TT>
<BR><TT>&nbsp; int tm_yday;&nbsp; /* days since January 1&nbsp;&nbsp;&nbsp;&nbsp; -- [0,365]*/</TT>
<BR><TT>&nbsp; int tm_isdst; /* Daylight Savings Time flag */</TT>
<BR><TT>};</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> strftime</TT> function formats the time in the argument<B> timeptr</B> into the array pointed to by the argument<B>
s</B> according to the<B> format</B> argument.
<BR><BR>The<TT> _wstrftime_ms</TT> function is a wide-character version of<TT> strftime</TT> that operates with wide-character
strings.
<BR><BR>The <TT> _wstrftime_ms</TT> function is identical to<TT> _wstrftime_ms</TT> except that the<B> format</B> is not a
wide-character string.
<BR><BR>The<B> format</B> string consists of zero or more directives and ordinary characters.&nbsp; A directive consists of
a '%' character followed by a character that determines the substitution that is to take place.&nbsp; All ordinary characters
are copied unchanged into the array.&nbsp; No more than<B> maxsize</B> characters are placed in the array.&nbsp; The format
directives %D, %h, %n, %r, %t, and %T are from POSIX.
<DL>
<DT>Directive&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>%a
<DD>locale's abbreviated weekday name
<DT>%A
<DD>locale's full weekday name
<DT>%b
<DD>locale's abbreviated month name
<DT>%B
<DD>locale's full month name
<DT>%c
<DD>locale's appropriate date and time representation
<DT>%C
<DD>is replaced by the year devided by 100 and truncated to an integer (00-99)
<DT>%d
<DD>day of the month as a decimal number (01-31)
<DT>%D
<DD>date in the format mm/dd/yy (POSIX)
<DT>%e
<DD>day of the month as a decimal number ( 1-31), a single digit is preceded by a blank
<DT>%F
<DD>is equivalent to '%Y-%m-%d' (the ISO 8601 date format)
<DT>%g
<DD>is replaced by the last 2 digits of the week-based year as a decimal number (00-99)
<DT>%G
<DD>is replaced by the week-based year as a decimal number (e.g.&nbsp; 2006)
<DT>%h
<DD>locale's abbreviated month name (POSIX)
<DT>%H
<DD>hour (24-hour clock) as a decimal number (00-23)
<DT>%I
<DD>hour (12-hour clock) as a decimal number (01-12)
<DT>%j
<DD>day of the year as a decimal number (001-366)
<DT>%m
<DD>month as a decimal number (01-12)
<DT>%M
<DD>minute as a decimal number (00-59)
<DT>%n
<DD>newline character (POSIX)
<DT>%p
<DD>locale's equivalent of either AM or PM
<DT>%r
<DD>12-hour clock time (01-12) using the AM/PM notation in the format HH:MM:SS (AM|PM) (POSIX)
<DT>%S
<DD>second as a decimal number (00-59)
<DT>%t
<DD>tab character (POSIX)
<DT>%T
<DD>24-hour clock time in the format HH:MM:SS (POSIX)
<DT>%u
<DD>is replaced by the ISO 8601 weekday as a decimal number (1-7), where Monday is 1
<DT>%U
<DD>week number of the year as a decimal number (00-52) where Sunday is the first day of the week
<DT>%V
<DD>is replaced by the ISO 8601 week number as a decimal number (01-53)
<DT>%w
<DD>weekday as a decimal number (0-6) where 0 is Sunday
<DT>%W
<DD>week number of the year as a decimal number (00-52) where Monday is the first day of the week
<DT>%x
<DD>locale's appropriate date representation
<DT>%X
<DD>locale's appropriate time representation
<DT>%y
<DD>year without century as a decimal number (00-99)
<DT>%Y
<DD>year with century as a decimal number
<DT>%z
<DD>offset from UTC in the ISO 8601 format '-0430' (meaning 4 hours 30 minutes behind UTC, west of Greenwich), or by no characters,
if no timezone is determinable
<DT>%Z
<DD>timezone name, or by no characters if no timezone exists
<DT>%%
<DD>character %
</DL>
<BR>When the<TT> %Z</TT> or<TT> %z</TT> directive is specified, the <TT> tzset</TT> function is called.
<BR><BR>% g, %G, %V give values according to the ISO 8601 week-based year.&nbsp; In this system, weeks begin on a monday and
week 1 of the year is the week that includes January 4th, which is also the week that includes the first Thursday of the year,
and is also the first week that contains at least four days in the year.&nbsp; If the first Monday of January is the 2nd,
3rd, or 4th, the preceding days are part of the last week of the preceding year; thus, for Saturday 2nd January 1999, %G is
replaced by 1998 and %V is replaced by 53.&nbsp; If december 29th, 30th, or 31st is a Monday, it and any following days are
part of week 1 of the following year.&nbsp; Thus, for Tuesday 30th December 1997, %G is replaced by 1998 and %V is replaced
by 01.
<BR><BR>The format modifiers E and O are ignored.&nbsp; (eg.&nbsp; %EY is the same as %Y)
</DL>
<DL>
<DT>Returns:
<DD>If the number of characters to be placed into the array is less than<B> maxsize</B>, the<TT> strftime</TT> function returns
the number of characters placed into the array pointed to by<B> s</B> not including the terminating null character.&nbsp;
Otherwise, zero is returned.&nbsp; When an error has occurred, <TT> errno</TT> contains a value indicating the type of error
that has been detected.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#setlocale">setlocale</A>, <A HREF="#asctime">asctime</A> Functions, <A HREF="#asctime_s">asctime_s</A>, <A HREF="#clock">clock</A>,
<A HREF="#ctime">ctime</A> Functions, <A HREF="#ctime_s">ctime_s</A>, <A HREF="#difftime">difftime</A>, <A HREF="#gmtime">gmtime</A>,
<A HREF="#gmtime_s">gmtime_s</A>, <A HREF="#localtime">localtime</A>, <A HREF="#localtime_s">localtime_s</A>, <A HREF="#mktime">mktime</A>,
<A HREF="#time">time</A>, <A HREF="#tzset">tzset</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;time.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; time_t time_of_day;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char buffer[ 80 ];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; time_of_day = time( NULL );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; strftime( buffer, 80, &quot;Today is %A %B %d, %Y&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; localtime( &amp;time_of_day )
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, buffer );</TT>
<BR><TT>&nbsp; }</TT>
<BR>produces the following:
<BR><BR><TT>Today is Friday December 25, 1987</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C, POSIX
<BR><BR>wcsftime is ISO C95
<BR>_wstrftime_ms is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> strftime - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>wcsftime - All, Linux</TT>
<BR><TT>_wstrftime_ms - All, Linux</TT>
</DL>
<H2 ID="stricmp"> stricmp, _stricmp, _fstricmp, _wcsicmp, _mbsicmp, _fmbsicmp </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>int stricmp( const char *s1, const char *s2 );</TT>
<BR><TT>int _stricmp( const char *s1, const char *s2 );</TT>
<BR><TT>int _fstricmp( const char __far *s1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char __far *s2 );</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>int _wcsicmp( const wchar_t *s1, const wchar_t *s2 );</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>int _mbsicmp( const unsigned char *s1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char *s2 );</TT>
<BR><TT>int _fmbsicmp( const unsigned char __far *s1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char __far *s2
);</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> stricmp</TT> function compares, with case insensitivity, the string pointed to by<B> s1</B> to the string pointed
to by<B> s2</B>.&nbsp; All uppercase characters from<B> s1</B> and<B> s2</B> are mapped to lowercase for the purposes of doing
the comparison.
<BR><BR>The<TT> _stricmp</TT> function is identical to<TT> stricmp</TT>.&nbsp; Use<TT> _stricmp</TT> for ANSI naming conventions.
<BR><BR>The<TT> _fstricmp</TT> function is a data model independent form of the stricmp function that accepts far pointer
arguments.&nbsp; It is most useful in mixed memory model applications.
<BR><BR>The<TT> _wcsicmp</TT> function is a wide-character version of<TT> stricmp</TT> that operates with wide-character strings.
<BR><BR>The<TT> _mbsicmp</TT> function is a multibyte character version of<TT> stricmp</TT> that operates with multibyte character
strings.
<BR><BR>The<TT> _fmbsicmp</TT> function is a data model independent form of the _mbsicmp function that accepts far pointer
arguments.&nbsp; It is most useful in mixed memory model applications.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> stricmp</TT> function returns an integer less than, equal to, or greater than zero, indicating that the string pointed
to by<B> s1</B> is less than, equal to, or greater than the string pointed to by<B> s2</B>.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#strcmp">strcmp</A>, <A HREF="#strcmpi">strcmpi</A>, <A HREF="#strncmp">strncmp</A>, <A HREF="#strnicmp">strnicmp</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, stricmp( &quot;AbCDEF&quot;, &quot;abcdef&quot; ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, stricmp( &quot;abcdef&quot;, &quot;ABC&quot;&nbsp;&nbsp;&nbsp; ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, stricmp( &quot;abc&quot;,&nbsp;&nbsp;&nbsp; &quot;ABCdef&quot; ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, stricmp( &quot;Abcdef&quot;, &quot;mnopqr&quot; ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, stricmp( &quot;Mnopqr&quot;, &quot;abcdef&quot; ) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>0</TT>
<BR><TT>100</TT>
<BR><TT>-100</TT>
<BR><TT>-12</TT>
<BR><TT>12</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
<BR><BR>_stricmp conforms to ANSI naming conventions
</DL>
<DL>
<DT>Systems:
<DD><TT> stricmp - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_stricmp - All, Linux, RDOS, Netware</TT>
<BR><TT>_fstricmp - All, Linux, RDOS</TT>
<BR><TT>_wcsicmp - All, Linux</TT>
<BR><TT>_mbsicmp - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
<BR><TT>_fmbsicmp - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="_stricoll"> _stricoll, _wcsicoll, _mbsicoll </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>int _stricoll( const char *s1, const char *s2 );</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>int _wcsicoll( const wchar_t *s1, const wchar_t *s2 );</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>int _mbsicoll( const unsigned char *s1, const unsigned char *s2 );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _stricoll</TT> function performs a case insensitive comparison of the string pointed to by<B> s1</B> to the string
pointed to by<B> s2</B>.&nbsp; The comparison uses the current code page which can be selected by the <TT> _setmbcp</TT> function.
<BR><BR>The<TT> _wcsicoll</TT> function is a wide-character version of<TT> _stricoll</TT> that operates with wide-character
strings.
<BR><BR>The<TT> _mbsicoll</TT> function is a multibyte character version of<TT> _stricoll</TT> that operates with multibyte
character strings.
</DL>
<DL>
<DT>Returns:
<DD>These functions return an integer less than, equal to, or greater than zero, indicating that the string pointed to by<B> s1</B>
is less than, equal to, or greater than the string pointed to by<B> s2</B>, according to the collating sequence selected.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_setmbcp">_setmbcp</A>, <A HREF="#strcoll">strcoll</A>, <A HREF="#stricmp">stricmp</A>, <A HREF="#strncmp">strncmp</A>,
<A HREF="#_strncoll">_strncoll</A>, <A HREF="#strnicmp">strnicmp</A>, <A HREF="#_strnicoll">_strnicoll</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><BR><TT>char buffer[80] = &quot;world&quot;;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int test;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; test = _stricoll( buffer, &quot;world2&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( test &lt; 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Less than\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; } else if( test == 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Equal\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Greater than\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> _stricoll - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_wcsicoll - All, Linux</TT>
<BR><TT>_mbsicoll - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="_strinc"> _strinc, _wcsinc, _mbsinc, _fmbsinc </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;tchar.h&gt;</TT>
<BR><TT>char *_strinc( const char *current );</TT>
<BR><TT>wchar_t *_wcsinc( const wchar_t *current );</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>unsigned char *_mbsinc( const unsigned char *current );</TT>
<BR><TT>unsigned char *_fmbsinc(</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const unsigned char __far *current );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _strinc</TT> function returns a pointer to the next character (single-byte, wide, or multibyte) in the string pointed
to by<B> current</B>.&nbsp; You must ensure that<B> current</B> does not point into the middle of a multibyte or wide character.
<BR><BR>The function is a data model independent form of the _strinc function that accepts far pointer arguments.&nbsp; It
is most useful in mixed memory model applications.
<BR><BR>The<TT> _wcsinc</TT> function is a wide-character version of<TT> _strinc</TT> that operates with wide-character strings.
<BR><BR>The<TT> _mbsinc</TT> function is a multibyte character version of<TT> _strinc</TT> that operates with multibyte character
strings.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _strinc</TT> function returns a pointer to the next character (single-byte, wide, or multibyte depending on the function
used).
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_strdec">_strdec</A>, <A HREF="#_strninc">_strninc</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><BR><TT>const unsigned char chars[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ' ',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '.',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '1',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'A',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x81,0x40, /* double-byte space */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x82,0x60, /* double-byte A */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x82,0xA6, /* double-byte Hiragana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x83,0x42, /* double-byte Katakana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana punctuation */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA6,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xDF,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xE0,0xA1, /* double-byte Kanji */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x00</TT>
<BR><TT>};</TT>
<BR><BR><TT>#define SIZE sizeof( chars ) / sizeof( unsigned char )</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
j, k;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; const unsigned char *next;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; next = chars;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; do {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; next = _mbsinc( next );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j = mblen( next, MB_CUR_MAX );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( j == 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if ( j == 1 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = *next;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if( j == 2 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = *(next)&lt;&lt;8 | *(next+1);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Next character %#6.4x\n&quot;, k );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; } while( next != &amp;chars[ SIZE - 1 ] );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>Next character 0x002e</TT>
<BR><TT>Next character 0x0031</TT>
<BR><TT>Next character 0x0041</TT>
<BR><TT>Next character 0x8140</TT>
<BR><TT>Next character 0x8260</TT>
<BR><TT>Next character 0x82a6</TT>
<BR><TT>Next character 0x8342</TT>
<BR><TT>Next character 0x00a1</TT>
<BR><TT>Next character 0x00a6</TT>
<BR><TT>Next character 0x00df</TT>
<BR><TT>Next character 0xe0a1</TT>
<BR><TT>Next character&nbsp;&nbsp; 0000</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> _strinc - MACRO</TT>
<BR><BR><TT>_wcsinc - MACRO</TT>
<BR><TT>_mbsinc - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, Linux, RDOS</TT>
<BR><TT>_fmbsinc - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="strlcat"> strlcat, wcslcat </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>size_t strlcat( char *dst, const char *src, size_t n );</TT>
<BR><TT>size_t *wcslcat( wchar_t *dst,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t *src,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t n );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> strlcat</TT> function appends characters of the string pointed to by<B> src</B> to the end of the string in a buffer
pointed to by<B> dst</B> that can hold up to<B> n</B> characters.&nbsp; The first character of<B> src</B> overwrites the null
character at the end of<B> dst</B>.&nbsp; A terminating null character is always appended to the result, unless<B> n</B> characters
of<B> dst</B> are scanned and no null character is found.
<BR><BR>The<TT> wcslcat</TT> function is a wide-character version of<TT> strlcat</TT> that operates with wide-character strings.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> strlcat</TT> function returns the total length of string it tried to create, that is the number of characters in both<B>
src</B> and<B> dst</B> strings, not counting the terminating null characters.&nbsp; If<B> n</B> characters of<B> dst</B> were
scanned without finding a null character,<B> n</B> is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#strlcpy">strlcpy</A>, <A HREF="#strncat">strncat</A>, <A HREF="#strcat">strcat</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><BR><TT>char buffer[80];</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; strcpy( buffer, &quot;Hello &quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; strlcat( buffer, &quot;world&quot;, 12 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, buffer );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; strlcat( buffer, &quot;*************&quot;, 16 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, buffer );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>Hello world</TT>
<BR><TT>Hello world****</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> strlcat - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>wcslcat - All, Linux</TT>
</DL>
<H2 ID="strlcpy"> strlcpy, wcslcpy </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>size_t strlcpy( char *dst,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *src,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t n );</TT>
<BR><TT>size_t wcslcpy( wchar_t *dst,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t *src,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t n );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> strlcpy</TT> function copies no more than<B> n</B> characters from the string pointed to by<B> src</B> into the array
pointed to by<B> dst</B>.&nbsp; Copying of overlapping objects is not guaranteed to work properly.&nbsp; See the <TT> memmove</TT>
function if you wish to copy objects that overlap.
<BR><BR>If the string pointed to by<B> src</B> is longer than<B> n</B> characters, then only<B> n</B> - 1 characters will
be copied and the result will be null terminated.
<BR><BR>The<TT> wcslcpy</TT> function is a wide-character version of<TT> strlcpy</TT> that operates with wide-character strings.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> strlcpy</TT> function returns the number of characters in the<B> src</B> string, not including the terminating null
character.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#strlcat">strlcat</A>, <A HREF="#strncpy">strncpy</A>, <A HREF="#strcpy">strcpy</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; buffer[10];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%d:'%s'\n&quot;, strlcpy( buffer,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;Buffer overflow&quot;, sizeof( buffer ) ), buffer );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>15:'Buffer ov'</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> strlcpy - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>wcslcpy - All, Linux</TT>
</DL>
<H2 ID="strlen"> strlen, _fstrlen, wcslen, _mbslen, _fmbslen </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>size_t strlen( const char *s );</TT>
<BR><TT>size_t _fstrlen( const char __far *s );</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>size_t wcslen( const wchar_t *s );</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>size_t _mbslen( const unsigned char *s );</TT>
<BR><TT>size_t _fmbslen( const unsigned char __far *s );</TT>
</DL>
<DL>
<DT>Safer C:
<DD>The Safer C Library extension provides the function which is a safer alternative to<TT> strlen</TT> This newer<TT> strlen_s</TT>
function is recommended to be used instead of the traditional &quot;unsafe&quot;<TT> strlen</TT> function.
</DL>
<DL>
<DT>Description:
<DD>The<TT> strlen</TT> function computes the length of the string pointed to by<B> s</B>.
<BR><BR>The<TT> _fstrlen</TT> function is a data model independent form of the strlen function that accepts far pointer arguments.
&nbsp;It is most useful in mixed memory model applications.
<BR><BR>The<TT> wcslen</TT> function is a wide-character version of<TT> strlen</TT> that operates with wide-character strings.
<BR><BR>The<TT> _mbslen</TT> function is a multibyte character version of<TT> strlen</TT> that operates with multibyte character
strings.
<BR><BR>The<TT> _fmbslen</TT> function is a data model independent form of the _mbslen function that accepts far pointer arguments.
&nbsp;It is most useful in mixed memory model applications.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> strlen</TT> function returns the number of characters that precede the terminating null character.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#strnlen_s">strnlen_s</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strlen( &quot;Howdy&quot; ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strlen( &quot;Hello world\n&quot; ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strlen( &quot;&quot; ) );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>5</TT>
<BR><TT>12</TT>
<BR><TT>0</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>_fstrlen is WATCOM
<BR>_mbslen is WATCOM
<BR>_fmbslen is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> strlen - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_fstrlen - All, Linux, RDOS</TT>
<BR><TT>wcslen - All, Linux</TT>
<BR><TT>_mbslen - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
<BR><TT>_fmbslen - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="strnlen_s"> strnlen_s, wcsnlen_s </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__&nbsp; 1</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>size_t strnlen_s( const char * s,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t maxsize
);</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>size_t wcsnlen_s( const wchar_t * s,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t maxsize
);</TT>
</DL>
<DL>
<DT>Constraints:
<DD>None.
</DL>
<DL>
<DT>Description:
<DD>The<TT> strnlen_s</TT> function calculates the length of the string pointed to by<B> s</B>.
<BR><BR>The<TT> wcsnlen_s</TT> function is a wide-character version of<TT> strnlen_s</TT> that operates with wide-character
strings.
</DL>
<DL>
<DT>Returns:
<DD>If<B> s</B> is a null pointer, then the<TT> strnlen_s</TT> function returns zero.&nbsp; Otherwise, the<TT> strnlen_s</TT>
function returns the number of characters that precede the terminating null character.&nbsp; If there is no null character
in the first<B> maxsize</B> characters of<B> s</B> then<TT> strnlen_s</TT> returns<B> maxsize</B>.&nbsp; At most the first<B>
maxsize</B> characters of<B> s</B> shall be accessed by strnlen_s
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#strlen">strlen</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__&nbsp; 1</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; buffer[ 30 ] = &quot;Hello world.&quot;;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; size_t&nbsp; len;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; len = strnlen_s( buffer, sizeof( buffer ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Length of text: %d\n&quot;, emsglen );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Text: %s\n&quot;, buffer );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>TR 24731
</DL>
<DL>
<DT>Systems:
<DD><TT> strnlen_s - All, RDOS, Netware</TT>
<BR><BR><TT>wcsnlen_s - All, Linux</TT>
</DL>
<H2 ID="strlwr"> strlwr, _strlwr, _fstrlwr, _wcslwr, _mbslwr, _fmbslwr </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>char *strlwr( char *s1 );</TT>
<BR><TT>char *_strlwr( char *s1 );</TT>
<BR><TT>char __far *_fstrlwr( char __far *s1 );</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>wchar_t *_wcslwr( wchar_t *s1 );</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>unsigned char *_mbslwr( unsigned char *s1 );</TT>
<BR><TT>unsigned char __far *_fmbslwr( unsigned char __far *s1 );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> strlwr</TT> function replaces the string<B> s1</B> with lowercase characters by invoking the <TT> tolower</TT> function
for each character in the string.
<BR><BR>The<TT> _strlwr</TT> function is identical to<TT> strlwr</TT>.&nbsp; Use<TT> _strlwr</TT> for ANSI naming conventions.
<BR><BR>The<TT> _fstrlwr</TT> function is a data model independent form of the strlwr function.&nbsp; It accepts far pointer
arguments and returns a far pointer.&nbsp; It is most useful in mixed memory model applications.
<BR><BR>The<TT> _wcslwr</TT> function is a wide-character version of<TT> strlwr</TT> that operates with wide-character strings.
<BR><BR>The<TT> _mbslwr</TT> function is a multibyte character version of<TT> strlwr</TT> that operates with multibyte character
strings.
<BR><BR>The<TT> _fmbslwr</TT> function is a data model independent form of the _mbslwr function that accepts far pointer arguments.
&nbsp;It is most useful in mixed memory model applications.
</DL>
<DL>
<DT>Returns:
<DD>The address of the original string<B> s1</B> is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#strupr">strupr</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><BR><TT>char source[] = { &quot;A mixed-case STRING&quot; };</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, source );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, strlwr( source ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, source );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>A mixed-case STRING</TT>
<BR><TT>a mixed-case string</TT>
<BR><TT>a mixed-case string</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
<BR><BR>_strlwr conforms to ANSI naming conventions
</DL>
<DL>
<DT>Systems:
<DD><TT> strlwr - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_strlwr - All, Linux, RDOS, Netware</TT>
<BR><TT>_fstrlwr - All, Linux, RDOS</TT>
<BR><TT>_wcslwr - All, Linux</TT>
<BR><TT>_mbslwr - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
<BR><TT>_fmbslwr - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="strncasecmp"> strncasecmp </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;strings.h&gt;</TT>
<BR><TT>int strncasecmp( const char *s1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *s2,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t len );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> strncasecmp</TT> function compares, without case sensitivity, the string pointed to by<B> s1</B> to the string pointed
to by<B> s2</B>, for at most<B> len</B> characters.
<BR><BR>The<TT> strncasecmp</TT> function is identical to the <TT> strnicmp</TT> function.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> strncasecmp</TT> function returns an integer less than, equal to, or greater than zero, indicating that the string
pointed to by<B> s1</B> is, ignoring case, less than, equal to, or greater than the string pointed to by<B> s2</B>.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#strnicmp">strnicmp</A>, <A HREF="#strcmp">strcmp</A>, <A HREF="#stricmp">stricmp</A>, <A HREF="#strncmp">strncmp</A>,
<A HREF="#strcasecmp">strcasecmp</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;strings.h&gt;</TT>
<BR><BR><TT>int main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strncasecmp( &quot;abcdef&quot;, &quot;ABCXXX&quot;, 10 ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strncasecmp( &quot;abcdef&quot;, &quot;ABCXXX&quot;,&nbsp; 6 ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strncasecmp( &quot;abcdef&quot;, &quot;ABCXXX&quot;,&nbsp; 3 ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strncasecmp( &quot;abcdef&quot;, &quot;ABCXXX&quot;,&nbsp; 0 ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; return( 0 );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>-20</TT>
<BR><TT>-20</TT>
<BR><TT>0</TT>
<BR><TT>0</TT>
</DL>
<DL>
<DT>Classification:
<DD>POSIX
</DL>
<DL>
<DT>Systems:
<DD>All, RDOS, Netware
</DL>
<H2 ID="strncat"> strncat, _fstrncat, wcsncat, _mbsncat, _fmbsncat </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>char *strncat( char *dst, const char *src, size_t n );</TT>
<BR><TT>char __far *_fstrncat( char __far *dst,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char __far
*src,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; size_t n );</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>wchar_t *wcsncat( wchar_t *dst,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t *src,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t n );</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>unsigned char *_mbsncat( unsigned char *dst,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const
unsigned char *src,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; size_t n );</TT>
<BR><TT>unsigned char __far *_fmbsncat( unsigned char __far *dst,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char __far *src,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t n );</TT>
</DL>
<DL>
<DT>Safer C:
<DD>The Safer C Library extension provides the <A HREF="#strncat_s">strncat_s</A> function which is a safer alternative to<TT>
strncat</TT> This newer<TT> strncat_s</TT> function is recommended to be used instead of the traditional &quot;unsafe&quot;<TT>
strncat</TT> function.
</DL>
<DL>
<DT>Description:
<DD>The<TT> strncat</TT> function appends not more than<B> n</B> characters of the string pointed to by<B> src</B> to the end
of the string pointed to by<B> dst</B>.&nbsp; The first character of<B> src</B> overwrites the null character at the end of<B>
dst</B>.&nbsp; A terminating null character is always appended to the result.
<BR><BR>The<TT> _fstrncat</TT> function is a data model independent form of the strncat function.&nbsp; It accepts far pointer
arguments and returns a far pointer.&nbsp; It is most useful in mixed memory model applications.
<BR><BR>The<TT> wcsncat</TT> function is a wide-character version of<TT> strncat</TT> that operates with wide-character strings.
<BR><BR>The<TT> _mbsncat</TT> function is a multibyte character version of<TT> strncat</TT> that operates with multibyte character
strings.
<BR><BR>The<TT> _fmbsncat</TT> function is a data model independent form of the _mbsncat function that accepts far pointer
arguments.&nbsp; It is most useful in mixed memory model applications.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> strncat</TT> function returns the value of<B> dst</B>.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#strcat">strcat</A>, <A HREF="#strlcat">strlcat</A>, <A HREF="#strncat_s">strncat_s</A>, <A HREF="#strcat_s">strcat_s</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><BR><TT>char buffer[80];</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; strcpy( buffer, &quot;Hello &quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; strncat( buffer, &quot;world&quot;, 8 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, buffer );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; strncat( buffer, &quot;*************&quot;, 4 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, buffer );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>Hello world</TT>
<BR><TT>Hello world****</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>_fstrncat is WATCOM
<BR>_mbsncat is WATCOM
<BR>_fmbsncat is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> strncat - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_fstrncat - All, Linux, RDOS</TT>
<BR><TT>wcsncat - All, Linux</TT>
<BR><TT>_mbsncat - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
<BR><TT>_fmbsncat - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="strncat_s"> strncat_s, wcsncat_s </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__&nbsp; 1</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>errno_t strncat_s( char * restrict s1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rsize_t
s1max,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const
char * restrict s2,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rsize_t
n )</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>errno_t wcsncat_s( wchar_t * restrict s1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rsize_t
s1max,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const
wchar_t * restrict s2,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rsize_t
n )</TT>
</DL>
<DL>
<DT>Constraints:
<DD>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<TT>
strncat_s</TT> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<BR><BR>Let<B> m</B> denote the value<B> s1max - strnlen_s(s1, s1max)</B> upon entry to strncat_s
<BR><BR>Neither<B> s1</B> nor<B> s2</B> shall be a null pointer.&nbsp; Neither<B> s1max</B> nor<B> n</B> shall be greater
than <TT> RSIZE_MAX</TT>.<B>&nbsp; s1max</B> shall not equal zero.<B>&nbsp; m</B> shall not equal zero.&nbsp; If<B> n</B>
is not less than<B> m, then m</B> shall be greater than<B> strnlen_s(s2, m)</B>.&nbsp; Copying shall not take place between
objects that overlap.
<BR><BR>If there is a runtime-constraint violation, then if<B> s1</B> is not a null pointer and<B> s1max</B> is greater than
zero and not greater than <TT> RSIZE_MAX</TT>, then<TT> strncat_s</TT> sets<B> s1[0]</B> to the null character.
</DL>
<DL>
<DT>Description:
<DD>The<TT> strncat_s</TT> function appends not more than<B> n</B> successive characters (characters that follow a null character
are not copied) from the array pointed to by<B> s2</B> to the end of the string pointed to by<B> s1</B>.&nbsp; The initial
character from<B> s2</B> overwrites the null character at the end of<B> s1</B>.&nbsp; If no null character was copied from<B>
s2,then s1[s1max-m+n]</B> is set to a null character.&nbsp; All elements following the terminating null character (if any)
written by<TT> strncat_s</TT> in the array of<B> s1max</B> characters pointed to by<B> s1</B> take unspecified values when<TT>
strncat_s</TT> returns.
<BR><BR>The<TT> wcsncat_s</TT> function is a wide-character version of<TT> strncat_s</TT> that operates with wide-character
strings.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> strncat_s</TT> function returns zero if there was no runtime-constraint violation.&nbsp; Otherwise, a non-zero value
is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#strncat">strncat</A>, <A HREF="#strcat">strcat</A>, <A HREF="#strlcat">strlcat</A>, <A HREF="#strcat_s">strcat_s</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__&nbsp; 1</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><BR><TT>char buffer[80];</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; strcpy( buffer, &quot;Hello &quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; strncat_s( buffer, sizeof( buffer ), &quot;world&quot;, 8 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, buffer );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; strncat( buffer, &quot;*************&quot;, 4 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, buffer );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>Hello world</TT>
<BR><TT>Hello world****</TT>
</DL>
<DL>
<DT>Classification:
<DD>TR 24731
</DL>
<DL>
<DT>Systems:
<DD><TT> strncat_s - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>wcsncat_s - All, Linux</TT>
</DL>
<H2 ID="strncmp"> strncmp, _fstrncmp, wcsncmp, _mbsncmp, _fmbsncmp </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>int strncmp( const char *s1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *s2,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t n );</TT>
<BR><TT>int _fstrncmp( const char __far *s1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char __far *s2,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t n );</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>int wcsncmp( const wchar_t *s1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t *s2,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t n );</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>int _mbsncmp( const unsigned char *s1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char *s2,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t n );</TT>
<BR><TT>int _fmbsncmp( const unsigned char __far *s1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char __far *s2,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t n );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> strncmp</TT> compares not more than<B> n</B> characters from the string pointed to by<B> s1</B> to the string pointed
to by<B> s2</B>.
<BR><BR>The<TT> _fstrncmp</TT> function is a data model independent form of the strncmp function that accepts far pointer
arguments.&nbsp; It is most useful in mixed memory model applications.
<BR><BR>The<TT> wcsncmp</TT> function is a wide-character version of<TT> strncmp</TT> that operates with wide-character strings.
<BR><BR>The<TT> _mbsncmp</TT> function is a multibyte character version of<TT> strncmp</TT> that operates with multibyte character
strings.
<BR><BR>The<TT> _fmbsncmp</TT> function is a data model independent form of the _mbsncmp function that accepts far pointer
arguments.&nbsp; It is most useful in mixed memory model applications.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> strncmp</TT> function returns an integer less than, equal to, or greater than zero, indicating that the string pointed
to by<B> s1</B> is less than, equal to, or greater than the string pointed to by<B> s2</B>.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#strcmp">strcmp</A>, <A HREF="#stricmp">stricmp</A>, <A HREF="#strnicmp">strnicmp</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strncmp( &quot;abcdef&quot;, &quot;abcDEF&quot;, 10 ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strncmp( &quot;abcdef&quot;, &quot;abcDEF&quot;,&nbsp; 6 ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strncmp( &quot;abcdef&quot;, &quot;abcDEF&quot;,&nbsp; 3 ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strncmp( &quot;abcdef&quot;, &quot;abcDEF&quot;,&nbsp; 0 ) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>1</TT>
<BR><TT>1</TT>
<BR><TT>0</TT>
<BR><TT>0</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>_fstrncmp is WATCOM
<BR>_mbsncmp is WATCOM
<BR>_fmbsncmp is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> strncmp - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_fstrncmp - All, Linux, RDOS</TT>
<BR><TT>wcsncmp - All, Linux</TT>
<BR><TT>_mbsncmp - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
<BR><TT>_fmbsncmp - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="_strncoll"> _strncoll, _wcsncoll, _mbsncoll </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>int _strncoll( const char *s1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *s2,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t count );</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>int _wcsncoll( const wchar_t *s1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t *s2,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t count );</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>int _mbsncoll( const unsigned char *s1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char *s2,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t count );</TT>
</DL>
<DL>
<DT>Description:
<DD>These functions compare the first<B> count</B> characters of the string pointed to by<B> s1</B> to the string pointed to by<B>
s2</B>.&nbsp; The comparison uses the current code page which can be selected by the <TT> _setmbcp</TT> function.
<BR><BR>The<TT> _wcsncoll</TT> function is a wide-character version of<TT> _strncoll</TT> that operates with wide-character
strings.
<BR><BR>The<TT> _mbsncoll</TT> function is a multibyte character version of<TT> _strncoll</TT> that operates with multibyte
character strings.
</DL>
<DL>
<DT>Returns:
<DD>These functions return an integer less than, equal to, or greater than zero, indicating that the string pointed to by<B> s1</B>
is less than, equal to, or greater than the string pointed to by<B> s2</B>, according to the collating sequence selected.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_setmbcp">_setmbcp</A>, <A HREF="#strcoll">strcoll</A>, <A HREF="#stricmp">stricmp</A>, <A HREF="#_stricoll">_stricoll</A>,
<A HREF="#strncmp">strncmp</A>, <A HREF="#strnicmp">strnicmp</A>, <A HREF="#_strnicoll">_strnicoll</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><BR><TT>char buffer[80] = &quot;world&quot;;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int test;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; test = _strncoll( buffer, &quot;world2&quot;, 5 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( test &lt; 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Less than\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; } else if( test == 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Equal\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Greater than\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> _strncoll - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_wcsncoll - All, Linux</TT>
<BR><TT>_mbsncoll - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="strncpy"> strncpy, _fstrncpy, wcsncpy, _mbsncpy, _fmbsncpy </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>char *strncpy( char *dst,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *src,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t n );</TT>
<BR><TT>char __far *_fstrncpy( char __far *dst,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; const char __far *src,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; size_t n );</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>wchar_t *wcsncpy( wchar_t *dst,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t
*src,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t n );</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>unsigned char *_mbsncpy( unsigned char *dst,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const
unsigned char *src,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; size_t n );</TT>
<BR><TT>unsigned char __far *_fmbsncpy( unsigned char __far *dst,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char __far *src,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t n );</TT>
</DL>
<DL>
<DT>Safer C:
<DD>The Safer C Library extension provides the <A HREF="#strncpy_s">strncpy_s</A> function which is a safer alternative to<TT>
strncpy</TT> This newer<TT> strncpy_s</TT> function is recommended to be used instead of the traditional &quot;unsafe&quot;<TT>
strncpy</TT> function.
</DL>
<DL>
<DT>Description:
<DD>The<TT> strncpy</TT> function copies no more than<B> n</B> characters from the string pointed to by<B> src</B> into the array
pointed to by<B> dst</B>.&nbsp; Copying of overlapping objects is not guaranteed to work properly.&nbsp; See the <TT> memmove</TT>
function if you wish to copy objects that overlap.
<BR><BR>If the string pointed to by<B> src</B> is shorter than<B> n</B> characters, null characters are appended to the copy
in the array pointed to by<B> dst</B>, until<B> n</B> characters in all have been written.&nbsp; If the string pointed to
by<B> src</B> is longer than<B> n</B> characters, then the result will not be terminated by a null character.
<BR><BR>The<TT> _fstrncpy</TT> function is a data model independent form of the strncpy function.&nbsp; It accepts far pointer
arguments and returns a far pointer.&nbsp; It is most useful in mixed memory model applications.
<BR><BR>The<TT> wcsncpy</TT> function is a wide-character version of<TT> strncpy</TT> that operates with wide-character strings.
<BR><BR>The<TT> _mbsncpy</TT> function is a multibyte character version of<TT> strncpy</TT> that operates with multibyte character
strings.
<BR><BR>The<TT> _fmbsncpy</TT> function is a data model independent form of the _mbsncpy function that accepts far pointer
arguments.&nbsp; It is most useful in mixed memory model applications.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> strncpy</TT> function returns the value of<B> dst</B>.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#strlcpy">strlcpy</A>, <A HREF="#strcpy">strcpy</A>, <A HREF="#strdup">strdup</A>, <A HREF="#strncpy_s">strncpy_s</A>,
<A HREF="#strcpy_s">strcpy_s</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char buffer[15];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, strncpy( buffer, &quot;abcdefg&quot;, 10 ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, strncpy( buffer, &quot;1234567&quot;,&nbsp; 6 ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, strncpy( buffer, &quot;abcdefg&quot;,&nbsp; 3 ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, strncpy( buffer, &quot;*******&quot;,&nbsp; 0 ) );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>abcdefg</TT>
<BR><TT>123456g</TT>
<BR><TT>abc456g</TT>
<BR><TT>abc456g</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>_fstrncpy is WATCOM
<BR>_mbsncpy is WATCOM
<BR>_fmbsncpy is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> strncpy - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_fstrncpy - All, Linux, RDOS</TT>
<BR><TT>wcsncpy - All, Linux</TT>
<BR><TT>_mbsncpy - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
<BR><TT>_fmbsncpy - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="strncpy_s"> strncpy_s, wcsncpy_s </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__&nbsp; 1</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>errno_t strncpy_s( char * restrict s1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rsize_t
s1max,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const
char * restrict s2,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rsize_t
n );</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>errno_t wcsncpy_s( wchar_t * restrict s1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rsize_t
s1max,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const
wchar_t * restrict s2,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rsize_t
n );</TT>
</DL>
<DL>
<DT>Constraints:
<DD>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<TT>
strncpy_s</TT> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<BR><BR>Neither<B> s1</B> nor<B> s2</B> shall be a null pointer.&nbsp; Neither<B> s1max</B> nor<B> n</B> shall be greater
than <TT> RSIZE_MAX</TT>.<B>&nbsp; s1max</B> shall not equal zero.&nbsp; If<B> n</B> is not less than<B> s1max</B>, then<B>
s1max</B> shall be greater than<B> strnlen_s(s2, s1max)</B>.
<BR><BR>Copying shall not take place between objects that overlap.
<BR><BR>If there is a runtime-constraint violation, then if<B> s1</B> is not a null pointer and<B> s1max</B> is greater than
zero and not greater than <TT> RSIZE_MAX</TT>, then <TT> strncpy_s</TT> sets<B> s1[0]</B> to the null character.
</DL>
<DL>
<DT>Description:
<DD>The<TT> strncpy_s</TT> function copies not more than<B> n</B> successive characters (characters that follow a null character
are not copied) from the array pointed to by<B> s2</B> to the array pointed to by<B> s1</B>.&nbsp; If no null character was
copied from<B> s2</B>, then<B> s1[n]</B> is set to a null character.
<BR><BR>All elements following the terminating null character (if any) written by <TT> strncpy_s</TT> in the array of<B> s1max</B>
characters pointed to by<B> s1</B> take unspecified values when <TT> strncpy_s</TT> returns.
<BR><BR>The<TT> wcsncpy_s</TT> function is a wide-character version of<TT> strncpy_s</TT> that operates with wide-character
strings.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> strncpy_s</TT> function returns zero if there was no runtime-constraint violation.&nbsp; Otherwise, a non-zero value
is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#strncpy">strncpy</A>, <A HREF="#strlcpy">strlcpy</A>, <A HREF="#strcpy">strcpy</A>, <A HREF="#strdup">strdup</A>,
<A HREF="#strcpy_s">strcpy_s</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__&nbsp; 1</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char buffer[15];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; strncpy_s( buffer, sizeof( buffer ), &quot;abcdefg&quot;, 10 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, buffer );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; strncpy_s( buffer, sizeof( buffer ), &quot;1234567&quot;,&nbsp; 6 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, buffer );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; strncpy_s( buffer, sizeof( buffer ), &quot;abcdefg&quot;,&nbsp; 3 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, buffer );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; strncpy_s( buffer, sizeof( buffer ), &quot;*******&quot;,&nbsp; 0 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, buffer );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>abcdefg</TT>
<BR><TT>123456</TT>
<BR><TT>abc</TT>
<BR><TT>(nothing)</TT>
</DL>
<DL>
<DT>Classification:
<DD>TR 24731
</DL>
<DL>
<DT>Systems:
<DD><TT> strncpy_s - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>wcsncpy_s - All, Linux</TT>
</DL>
<H2 ID="strnicmp"> strnicmp, _strnicmp, _fstrnicmp, _wcsnicmp, _mbsnicmp, _fmbsnicmp </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>int strnicmp( const char *s1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *s2,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t len );</TT>
<BR><TT>int _strnicmp( const char *s1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *s2,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t len );</TT>
<BR><TT>int _fstrnicmp( const char __far *s1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char __far *s2,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t len );</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>int _wcsnicmp( const wchar_t *s1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t *s2,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t len );</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>int _mbsnicmp( const unsigned char *s1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char *s2,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t n );</TT>
<BR><TT>int _fmbsnicmp( const unsigned char __far *s1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char __far
*s2,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t n );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> strnicmp</TT> function compares, without case sensitivity, the string pointed to by<B> s1</B> to the string pointed
to by<B> s2</B>, for at most<B> len</B> characters.
<BR><BR>The<TT> _strnicmp</TT> function is identical to<TT> strnicmp</TT>.&nbsp; Use<TT> _strnicmp</TT> for ANSI naming conventions.
<BR><BR>The<TT> _fstrnicmp</TT> function is a data model independent form of the strnicmp function that accepts far pointer
arguments.&nbsp; It is most useful in mixed memory model applications.
<BR><BR>The<TT> _wcsnicmp</TT> function is a wide-character version of<TT> strnicmp</TT> that operates with wide-character
strings.
<BR><BR>The<TT> _mbsnicmp</TT> function is a multibyte character version of<TT> strnicmp</TT> that operates with multibyte
character strings.
<BR><BR>The<TT> _fmbsnicmp</TT> function is a data model independent form of the _mbsnicmp function that accepts far pointer
arguments.&nbsp; It is most useful in mixed memory model applications.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> strnicmp</TT> function returns an integer less than, equal to, or greater than zero, indicating that the string pointed
to by<B> s1</B> is less than, equal to, or greater than the string pointed to by<B> s2</B>.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#strcmp">strcmp</A>, <A HREF="#stricmp">stricmp</A>, <A HREF="#strncmp">strncmp</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strnicmp( &quot;abcdef&quot;, &quot;ABCXXX&quot;, 10 ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strnicmp( &quot;abcdef&quot;, &quot;ABCXXX&quot;,&nbsp; 6 ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strnicmp( &quot;abcdef&quot;, &quot;ABCXXX&quot;,&nbsp; 3 ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strnicmp( &quot;abcdef&quot;, &quot;ABCXXX&quot;,&nbsp; 0 ) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>-20</TT>
<BR><TT>-20</TT>
<BR><TT>0</TT>
<BR><TT>0</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
<BR><BR>_strnicmp conforms to ANSI naming conventions
</DL>
<DL>
<DT>Systems:
<DD><TT> strnicmp - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_strnicmp - All, Linux, RDOS, Netware</TT>
<BR><TT>_fstrnicmp - All, Linux, RDOS</TT>
<BR><TT>_wcsnicmp - All, Linux</TT>
<BR><TT>_mbsnicmp - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
<BR><TT>_fmbsnicmp - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="_strnicoll"> _strnicoll, _wcsnicoll, _mbsnicoll </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>int _strnicoll( const char *s1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *s2,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t count );</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>int _wcsnicoll( const wchar_t *s1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t *s2,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t count );</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>int _mbsnicoll( const unsigned char *s1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char *s2,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t count );</TT>
</DL>
<DL>
<DT>Description:
<DD>These functions perform a case insensitive comparison of the first<B> count</B> characters of the string pointed to by<B>
s1</B> to the string pointed to by<B> s2</B>.&nbsp; The comparison uses the current code page which can be selected by the
<TT> _setmbcp</TT> function.
<BR><BR>The<TT> _wcsnicoll</TT> function is a wide-character version of<TT> _strnicoll</TT> that operates with wide-character
strings.
<BR><BR>The<TT> _mbsnicoll</TT> function is a multibyte character version of<TT> _strnicoll</TT> that operates with multibyte
character strings.
</DL>
<DL>
<DT>Returns:
<DD>These functions return an integer less than, equal to, or greater than zero, indicating that the string pointed to by<B> s1</B>
is less than, equal to, or greater than the string pointed to by<B> s2</B>, according to the collating sequence selected.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_setmbcp">_setmbcp</A>, <A HREF="#strcoll">strcoll</A>, <A HREF="#stricmp">stricmp</A>, <A HREF="#_stricoll">_stricoll</A>,
<A HREF="#strncmp">strncmp</A>, <A HREF="#_strncoll">_strncoll</A>, <A HREF="#strnicmp">strnicmp</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><BR><TT>char buffer[80] = &quot;world&quot;;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int test;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; test = _strnicoll( buffer, &quot;World2&quot;, 5 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( test &lt; 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Less than\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; } else if( test == 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Equal\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Greater than\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> _strnicoll - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_wcsnicoll - All, Linux</TT>
<BR><TT>_mbsnicoll - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="_strninc"> _strninc, _wcsninc, _mbsninc, _fmbsninc </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#ninclude &lt;tchar.h&gt;</TT>
<BR><TT>char *_strninc( const char *str, size_t count );</TT>
<BR><TT>wchar_t *_wcsninc( const wchar_t *str, size_t count );</TT>
<BR><TT>#ninclude &lt;mbstring.h&gt;</TT>
<BR><TT>unsigned char *_mbsninc( const unsigned char *str,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; size_t count );</TT>
<BR><TT>unsigned char __far *_fmbsninc(</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; const unsigned char __far *str,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; size_t count );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _mbsninc</TT> function increments<B> str</B> by<B> count</B> multibyte characters.<TT>&nbsp; _mbsninc</TT> recognizes
multibyte-character sequences according to the multibyte code page currently in use.&nbsp; The header file<TT> &lt;tchar.h&gt;</TT>
defines the generic-text routine <TT> _tcsninc</TT>.&nbsp; This macro maps to<TT> _mbsninc</TT> if <TT> _MBCS</TT> has been
defined, or to<TT> _wcsninc</TT> if <TT> _UNICODE</TT> has been defined.&nbsp; Otherwise <TT> _tcsninc</TT> maps to _strninc.<TT>
&nbsp;_strninc</TT> and<TT> _wcsninc</TT> are single-byte-character string and wide-character string versions of _mbsninc.<TT>
&nbsp;_wcsninc</TT> and<TT> _strninc</TT> are provided only for this mapping and should not be used otherwise.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _strninc</TT> function returns a pointer to<B> str</B> after it has been incremented by<B> count</B> characters or
<TT> NULL</TT> if<B> str</B> was <TT> NULL</TT>.&nbsp; If<B> count</B> exceeds the number of characters remaining in the string,
the result is undefined.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_strdec">_strdec</A>, <A HREF="#_strinc">_strinc</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#ninclude &lt;stdio.h&gt;</TT>
<BR><TT>#ninclude &lt;mbctype.h&gt;</TT>
<BR><TT>#ninclude &lt;mbstring.h&gt;</TT>
<BR><BR><TT>const unsigned char chars[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ' ',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '.',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '1',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'A',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x81,0x40, /* double-byte space */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x82,0x60, /* double-byte A */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x82,0xA6, /* double-byte Hiragana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x83,0x42, /* double-byte Katakana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana punctuation */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xA6,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xDF,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xE0,0xA1, /* double-byte Kanji */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x00</TT>
<BR><TT>};</TT>
<BR><BR><TT>#define SIZE sizeof( chars ) / sizeof( unsigned char )</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
j, k;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; const unsigned char *next;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; next = chars;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; do {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; next = _mbsninc( next, 1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j = mblen( next, MB_CUR_MAX );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( j == 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if ( j == 1 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = *next;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if( j == 2 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = *(next)&lt;&lt;8 | *(next+1);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Next character %#6.4x\n&quot;, k );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; } while( next != &amp;chars[ SIZE - 1 ] );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>Next character 0x002e</TT>
<BR><TT>Next character 0x0031</TT>
<BR><TT>Next character 0x0041</TT>
<BR><TT>Next character 0x8140</TT>
<BR><TT>Next character 0x8260</TT>
<BR><TT>Next character 0x82a6</TT>
<BR><TT>Next character 0x8342</TT>
<BR><TT>Next character 0x00a1</TT>
<BR><TT>Next character 0x00a6</TT>
<BR><TT>Next character 0x00df</TT>
<BR><TT>Next character 0xe0a1</TT>
<BR><TT>Next character&nbsp;&nbsp; 0000</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> _strninc - MACRO</TT>
<BR><BR><TT>_wcsninc - MACRO</TT>
<BR><TT>_mbsninc - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
<BR><TT>_fmbsninc - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="strnset"> strnset, _strnset, _fstrnset, _wcsnset, _mbsnset, _fmbsnset </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>char *strnset( char *str, int fill, size_t count );</TT>
<BR><TT>char *_strnset( char *str, int fill, size_t count );</TT>
<BR><TT>char __far *_fstrnset( char __far *str,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; int fill,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; size_t count );</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>wchar_t *_wcsnset( wchar_t *str, int fill, size_t count );</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>unsigned char *_mbsnset( unsigned char *str,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; unsigned int fill,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; size_t count );</TT>
<BR><TT>unsigned char __far *_fmbsnset( unsigned char __far *str,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int fill,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t count );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> strnset</TT> function fills the string<B> str</B> with the value of the argument<B> fill</B>, converted to be a character
value.&nbsp; When the value of<B> count</B> is greater than the length of the string, the entire string is filled.&nbsp; Otherwise,
that number of characters at the start of the string are set to the fill character.
<BR><BR>The<TT> _strnset</TT> function is identical to<TT> strnset</TT>.&nbsp; Use<TT> _strnset</TT> for ANSI naming conventions.
<BR><BR>The<TT> _fstrnset</TT> function is a data model independent form of the strnset function.&nbsp; It accepts far pointer
arguments and returns a far pointer.&nbsp; It is most useful in mixed memory model applications.
<BR><BR>The<TT> _wcsnset</TT> function is a wide-character version of<TT> strnset</TT> that operates with wide-character strings.
&nbsp;For _wcsnset, the value of<B> count</B> is the number of wide characters to fill.&nbsp; This is half the number of bytes.
<BR><BR>The<TT> _mbsnset</TT> function is a multibyte character version of<TT> strnset</TT> that operates with multibyte character
strings.
<BR><BR>The<TT> _fmbsnset</TT> function is a data model independent form of the _mbsnset function that accepts far pointer
arguments.&nbsp; It is most useful in mixed memory model applications.
<BR><BR>For _mbsnset, the value of<B> count</B> is the number of multibyte characters to fill.&nbsp; If the number of bytes
to be filled is odd and<B> fill</B> is a double-byte character, the partial byte at the end is filled with an ASCII space
character.
</DL>
<DL>
<DT>Returns:
<DD>The address of the original string<B> str</B> is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#strset">strset</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><BR><TT>char source[] = { &quot;A sample STRING&quot; };</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, source );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, strnset( source, '=', 100 ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, strnset( source, '*', 7 ) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>A sample STRING</TT>
<BR><TT>===============</TT>
<BR><TT>*******========</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
<BR><BR>_strnset conforms to ANSI naming conventions
</DL>
<DL>
<DT>Systems:
<DD><TT> strnset - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_strnset - All, Linux, RDOS, Netware</TT>
<BR><TT>_fstrnset - All, Linux, RDOS</TT>
<BR><TT>_wcsnset - All, Linux</TT>
<BR><TT>_mbsnset - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
<BR><TT>_fmbsnset - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="strpbrk"> strpbrk, _fstrpbrk, wcspbrk, _mbspbrk, _fmbspbrk </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>char *strpbrk( const char *str, const char *charset );</TT>
<BR><TT>char __far *_fstrpbrk( const char __far *str,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; const char __far *charset );</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>wchar_t *wcspbrk( const wchar_t *str,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t
*charset );</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>unsigned char *_mbspbrk( const unsigned char *str,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char *charset );</TT>
<BR><TT>unsigned char __far *_fmbspbrk(</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const unsigned char __far *str,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const unsigned char __far *charset );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> strpbrk</TT> function locates the first occurrence in the string pointed to by<B> str</B> of any character from the
string pointed to by<B> charset</B>.
<BR><BR>The<TT> _fstrpbrk</TT> function is a data model independent form of the strpbrk function.&nbsp; It accepts far pointer
arguments and returns a far pointer.&nbsp; It is most useful in mixed memory model applications.
<BR><BR>The<TT> wcspbrk</TT> function is a wide-character version of<TT> strpbrk</TT> that operates with wide-character strings.
<BR><BR>The<TT> _mbspbrk</TT> function is a multibyte character version of<TT> strpbrk</TT> that operates with multibyte character
strings.
<BR><BR>The<TT> _fmbspbrk</TT> function is a data model independent form of the _mbspbrk function that accepts far pointer
arguments.&nbsp; It is most useful in mixed memory model applications.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> strpbrk</TT> function returns a pointer to the located character, or<TT> NULL</TT> if no character from<B> charset</B>
occurs in<B> str</B>.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#strchr">strchr</A>, <A HREF="#strrchr">strrchr</A>, <A HREF="#strtok">strtok</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char *p = &quot;Find all vowels&quot;;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; while( p != NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, p );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p = strpbrk( p+1, &quot;aeiouAEIOU&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>Find all vowels</TT>
<BR><TT>ind all vowels</TT>
<BR><TT>all vowels</TT>
<BR><TT>owels</TT>
<BR><TT>els</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>_fstrpbrk is WATCOM
<BR>_mbspbrk is WATCOM
<BR>_fmbspbrk is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> strpbrk - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_fstrpbrk - All, Linux, RDOS</TT>
<BR><TT>wcspbrk - All, Linux</TT>
<BR><TT>_mbspbrk - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
<BR><TT>_fmbspbrk - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="strrchr"> strrchr, _fstrrchr, wcsrchr, _mbsrchr, _fmbsrchr </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>char *strrchr( const char *s, int c );</TT>
<BR><TT>char __far *_fstrrchr( const char __far *s, int c );</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>wchar_t *wcsrchr( const wchar_t *s, wint_t c );</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>unsigned char *_mbsrchr( const unsigned char *s,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; unsigned int c );</TT>
<BR><TT>unsigned char __far *_fmbsrchr(</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; const unsigned char __far *s,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; unsigned int c );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> strrchr</TT> function locates the last occurrence of<B> c</B> (converted to a char) in the string pointed to by<B>
s</B>.&nbsp; The terminating null character is considered to be part of the string.
<BR><BR>The<TT> _fstrrchr</TT> function is a data model independent form of the strrchr function.&nbsp; It accepts far pointer
arguments and returns a far pointer.&nbsp; It is most useful in mixed memory model applications.
<BR><BR>The<TT> wcsrchr</TT> function is a wide-character version of<TT> strrchr</TT> that operates with wide-character strings.
<BR><BR>The<TT> _mbsrchr</TT> function is a multibyte character version of<TT> strrchr</TT> that operates with multibyte character
strings.
<BR><BR>The<TT> _fmbsrchr</TT> function is a data model independent form of the _mbsrchr function that accepts far pointer
arguments.&nbsp; It is most useful in mixed memory model applications.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> strrchr</TT> function returns a pointer to the located character, or a NULL pointer if the character does not occur
in the string.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#strchr">strchr</A>, <A HREF="#strpbrk">strpbrk</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, strrchr( &quot;abcdeaaklmn&quot;, 'a' ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( strrchr( &quot;abcdeaaklmn&quot;, 'x' ) == NULL )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;NULL\n&quot; );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>aklmn</TT>
<BR><TT>NULL</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>_fstrrchr is WATCOM
<BR>_mbsrchr is WATCOM
<BR>_fmbsrchr is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> strrchr - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_fstrrchr - All, Linux, RDOS</TT>
<BR><TT>wcsrchr - All, Linux</TT>
<BR><TT>_mbsrchr - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
<BR><TT>_fmbsrchr - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="strrev"> strrev, _strrev, _fstrrev, _wcsrev, _mbsrev, _fmbsrev </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>char *strrev( char *s1 );</TT>
<BR><TT>char *_strrev( char *s1 );</TT>
<BR><TT>char __far *_fstrrev( char __far *s1 );</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>wchar_t *_wcsrev( wchar_t *s1 );</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>unsigned char *_mbsrev( unsigned char *s1 );</TT>
<BR><TT>unsigned char __far *_fmbsrev( unsigned char __far *s1 );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> strrev</TT> function replaces the string<B> s1</B> with a string whose characters are in the reverse order.
<BR><BR>The<TT> _strrev</TT> function is identical to<TT> strrev</TT>.&nbsp; Use<TT> _strrev</TT> for ANSI naming conventions.
<BR><BR>The<TT> _fstrrev</TT> function is a data model independent form of the strrev function.&nbsp; It accepts far pointer
arguments and returns a far pointer.&nbsp; It is most useful in mixed memory model applications.
<BR><BR>The<TT> _wcsrev</TT> function is a wide-character version of<TT> strrev</TT> that operates with wide-character strings.
<BR><BR>The<TT> _mbsrev</TT> function is a multibyte character version of<TT> strrev</TT> that operates with multibyte character
strings.
<BR><BR>The<TT> _fmbsrev</TT> function is a data model independent form of the _mbsrev function that accepts far pointer arguments.
&nbsp;It is most useful in mixed memory model applications.
</DL>
<DL>
<DT>Returns:
<DD>The address of the original string<B> s1</B> is returned.
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><BR><TT>char source[] = { &quot;A sample STRING&quot; };</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, source );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, strrev( source ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, strrev( source ) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>A sample STRING</TT>
<BR><TT>GNIRTS elpmas A</TT>
<BR><TT>A sample STRING</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
<BR><BR>_strrev conforms to ANSI naming conventions
</DL>
<DL>
<DT>Systems:
<DD><TT> strrev - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_strrev - All, Linux, RDOS, Netware</TT>
<BR><TT>_fstrrev - All, Linux, RDOS</TT>
<BR><TT>_wcsrev - All, Linux</TT>
<BR><TT>_mbsrev - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
<BR><TT>_fmbsrev - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="strset"> strset, _strset, _fstrset, _wcsset, _mbsset, _fmbsset </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>char *strset( char *s1, int fill );</TT>
<BR><TT>char *_strset( char *s1, int fill );</TT>
<BR><TT>char __far *_fstrset( char __far *s1, int fill );</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>wchar_t *_wcsset( wchar_t *s1, int fill );</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>unsigned char *_mbsset( unsigned char *s1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; unsigned int fill );</TT>
<BR><TT>unsigned char __far *_fmbsset( unsigned char __far *s1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int fill );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> strset</TT> function fills the string pointed to by<B> s1</B> with the character<B> fill</B>.&nbsp; The terminating
null character in the original string remains unchanged.
<BR><BR>The<TT> _strset</TT> function is identical to<TT> strset</TT>.&nbsp; Use<TT> _strset</TT> for ANSI naming conventions.
<BR><BR>The<TT> _fstrset</TT> function is a data model independent form of the strset function.&nbsp; It accepts far pointer
arguments and returns a far pointer.&nbsp; It is most useful in mixed memory model applications.
<BR><BR>The<TT> _wcsset</TT> function is a wide-character version of<TT> strset</TT> that operates with wide-character strings.
<BR><BR>The<TT> _mbsset</TT> function is a multibyte character version of<TT> strset</TT> that operates with multibyte character
strings.
<BR><BR>The<TT> _fmbsset</TT> function is a data model independent form of the _mbsset function that accepts far pointer arguments.
&nbsp;It is most useful in mixed memory model applications.
</DL>
<DL>
<DT>Returns:
<DD>The address of the original string<B> s1</B> is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#strnset">strnset</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><BR><TT>char source[] = { &quot;A sample STRING&quot; };</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, source );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, strset( source, '=' ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, strset( source, '*' ) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>A sample STRING</TT>
<BR><TT>===============</TT>
<BR><TT>***************</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
<BR><BR>_strset conforms to ANSI naming conventions
</DL>
<DL>
<DT>Systems:
<DD><TT> strset - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_strset - All, Linux, RDOS, Netware</TT>
<BR><TT>_fstrset - All, Linux, RDOS</TT>
<BR><TT>_wcsset - All, Linux</TT>
<BR><TT>_mbsset - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
<BR><TT>_fmbsset - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="strspn"> strspn, _fstrspn, wcsspn, _mbsspn, _fmbsspn </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>size_t strspn( const char *str,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *charset );</TT>
<BR><TT>size_t _fstrspn( const char __far *str,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char __far
*charset );</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>size_t wcsspn( const wchar_t *str,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t *charset );</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>size_t _mbsspn( const unsigned char *str,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char *charset
);</TT>
<BR><TT>size_t _fmbsspn( const unsigned char __far *str,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char
__far *charset );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> strspn</TT> function computes the length, in bytes, of the initial segment of the string pointed to by<B> str</B>
which consists of characters from the string pointed to by<B> charset</B>.&nbsp; The terminating null character is not considered
to be part of<B> charset</B>.
<BR><BR>The<TT> _fstrspn</TT> function is a data model independent form of the strspn function that accepts far pointer arguments.
&nbsp;It is most useful in mixed memory model applications.
<BR><BR>The<TT> wcsspn</TT> function is a wide-character version of<TT> strspn</TT> that operates with wide-character strings.
<BR><BR>The<TT> _mbsspn</TT> function is a multibyte character version of<TT> strspn</TT> that operates with multibyte character
strings.
<BR><BR>The<TT> _fmbsspn</TT> function is a data model independent form of the _mbsspn function that accepts far pointer arguments.
&nbsp;It is most useful in mixed memory model applications.
</DL>
<DL>
<DT>Returns:
<DD>The length, in bytes, of the initial segment is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#strcspn">strcspn</A>, <A HREF="#strspnp">strspnp</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strspn( &quot;out to lunch&quot;, &quot;aeiou&quot; ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strspn( &quot;out to lunch&quot;, &quot;xyz&quot; ) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>2</TT>
<BR><TT>0</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>_fstrspn is WATCOM
<BR>_mbsspn is WATCOM
<BR>_fmbsspn is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> strspn - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_fstrspn - All, Linux, RDOS</TT>
<BR><TT>wcsspn - All, Linux</TT>
<BR><TT>_mbsspn - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
<BR><TT>_fmbsspn - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="strspnp"> strspnp, _strspnp, _fstrspnp, _wcsspnp, _mbsspnp, _fmbsspnp </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>char *strspnp( const char *str,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *charset );</TT>
<BR><TT>char *_strspnp( const char *str,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *charset );</TT>
<BR><TT>char __far *_fstrspnp( const char __far *str,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; const char __far *charset );</TT>
<BR><TT>#include &lt;tchar.h&gt;</TT>
<BR><TT>wchar_t *_wcsspnp( const wchar_t *str,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const
wchar_t *charset );</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>unsigned char *_mbsspnp( const unsigned char *str,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char *charset );</TT>
<BR><TT>unsigned char __far *_fmbsspnp(</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const unsigned char __far *str,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const unsigned char __far *charset );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> strspnp</TT> function returns a pointer to the first character in<B> str</B> that does not belong to the set of characters
in<B> charset</B>.&nbsp; The terminating null character is not considered to be part of<B> charset</B>.
<BR><BR>The<TT> _strspnp</TT> function is identical to<TT> strspnp</TT>.&nbsp; Use<TT> _strspnp</TT> for ANSI naming conventions.
<BR><BR>The<TT> _fstrspnp</TT> function is a data model independent form of the strspnp function that accepts far pointer
arguments.&nbsp; It is most useful in mixed memory model applications.
<BR><BR>The<TT> _wcsspnp</TT> function is a wide-character version of<TT> strspnp</TT> that operates with wide-character strings.
<BR><BR>The<TT> _mbsspnp</TT> function is a multibyte character version of<TT> strspnp</TT> that operates with multibyte character
strings.
<BR><BR>The<TT> _fmbsspnp</TT> function is a data model independent form of the _mbsspnp function that accepts far pointer
arguments.&nbsp; It is most useful in mixed memory model applications.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> strspnp</TT> function returns<TT> NULL</TT> if<B> str</B> consists entirely of characters from<B> charset</B>.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#strcspn">strcspn</A>, <A HREF="#strspn">strspn</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, strspnp( &quot;out to lunch&quot;, &quot;aeiou&quot; ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, strspnp( &quot;out to lunch&quot;, &quot;xyz&quot; ) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>t to lunch</TT>
<BR><TT>out to lunch</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
<BR><BR>_strspnp conforms to ANSI naming conventions
</DL>
<DL>
<DT>Systems:
<DD><TT> strspnp - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_strspnp - All, Linux, RDOS, Netware</TT>
<BR><TT>_fstrspnp - All, Linux, RDOS</TT>
<BR><TT>_wcsspnp - All, Linux</TT>
<BR><TT>_mbsspnp - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
<BR><TT>_fmbsspnp - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="strstr"> strstr, _fstrstr, wcsstr, _mbsstr, _fmbsstr </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>char *strstr( const char *str,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *substr );</TT>
<BR><TT>char __far *_fstrstr( const char __far *str,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; const char __far *substr );</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>wchar_t *wcsstr( const wchar_t *str,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t *substr
);</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>unsigned char *_mbsstr( const unsigned char *str,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; const unsigned char *substr );</TT>
<BR><TT>unsigned char __far *_fmbsstr(</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const unsigned char __far *str,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const unsigned char __far *substr );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> strstr</TT> function locates the first occurrence in the string pointed to by<B> str</B> of the sequence of characters
(excluding the terminating null character) in the string pointed to by<B> substr</B>.
<BR><BR>The<TT> _fstrstr</TT> function is a data model independent form of the strstr function.&nbsp; It accepts far pointer
arguments and returns a far pointer.&nbsp; It is most useful in mixed memory model applications.
<BR><BR>The<TT> wcsstr</TT> function is a wide-character version of<TT> strstr</TT> that operates with wide-character strings.
<BR><BR>The<TT> _mbsstr</TT> function is a multibyte character version of<TT> strstr</TT> that operates with multibyte character
strings.
<BR><BR>The<TT> _fmbsstr</TT> function is a data model independent form of the _mbsstr function that accepts far pointer arguments.
&nbsp;It is most useful in mixed memory model applications.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> strstr</TT> function returns a pointer to the located string, or<TT> NULL</TT> if the string is not found.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#strcspn">strcspn</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, strstr(&quot;This is an example&quot;, &quot;is&quot;) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>is is an example</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>_fstrstr is WATCOM
<BR>wcsstr is ISO C95
<BR>_mbsstr is WATCOM
<BR>_fmbsstr is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> strstr - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_fstrstr - All, Linux, RDOS</TT>
<BR><TT>wcsstr - All, Linux</TT>
<BR><TT>_mbsstr - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
<BR><TT>_fmbsstr - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="_strtime"> _strtime, _wstrtime </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;time.h&gt;</TT>
<BR><TT>char *_strtime( char *timestr )</TT>
<BR><TT>wchar_t _wstrtime( wchar_t *timestr );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _strtime</TT> function copies the current time to the buffer pointed to by<B> timestr</B>.&nbsp; The time is formatted
as &quot;HH:MM:SS&quot; where &quot;HH&quot; is two digits representing the hour in 24-hour notation, where &quot;MM&quot;
is two digits representing the minutes past the hour, and where &quot;SS&quot; is two digits representing seconds.&nbsp; The
buffer must be at least 9 bytes long.
<BR><BR>The<TT> _wstrtime</TT> function is a wide-character version of<TT> _strtime</TT> that operates with wide-character
strings.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _strtime</TT> function returns a pointer to the resulting text string<B> timestr</B>.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#asctime">asctime</A> Functions, <A HREF="#ctime">ctime</A> Functions, <A HREF="#gmtime">gmtime</A>, <A HREF="#localtime">localtime</A>,
<A HREF="#mktime">mktime</A>, <A HREF="#_strdate">_strdate</A>, <A HREF="#time">time</A>, <A HREF="#tzset">tzset</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;time.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char timebuff[9];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, _strtime( timebuff ) );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> _strtime - All, Linux, RDOS</TT>
<BR><BR><TT>_wstrtime - All, Linux</TT>
</DL>
<H2 ID="strtod"> strtod, wcstod </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>double strtod( const char *ptr, char **endptr );</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>double wcstod( const wchar_t *ptr, wchar_t **endptr );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> strtod</TT> function converts the string pointed to by<B> ptr</B> to<TT> double</TT> representation.&nbsp; First,
it decompose the input string into three parts:&nbsp; an initial, possibly empty, sequence of white-space characters (as specified
by the<TT> isspace</TT> function), a subject sequence resembling a floating-point constant or representing an infinity or
NaN; and a final string of one or more unrecognized characters, including the terminating null character of the input string.
&nbsp;Then, it attempts to convert the subject sequence to a floating-point number, and return the result.
<BR><BR>The expected form of the subject sequence is an optional plus or minus sign, then one of the following:
<UL>
<LI>a decimal floating-point number
<LI>a hexadecimal floating-point number
<LI><TT> INF</TT> or<TT> INFINITY</TT>, ignoring case
<LI><TT> NAN</TT>, ignoring case, optionally followed by a sequence of digits and nondigits (upper- or lowercase characters
or underscore) enclosed in parentheses.
</UL>
<BR>The subject sequence is defined as the longest initial subsequence of the input string, starting with the first non-whitespace
character, that is of the expected form.&nbsp; The subject sequence contains no characters if the input string is not of the
expected form.
<BR><BR>A decimal floating-point number recognized by<TT> strtod</TT> (after optional sign was processed) is a string containing:
<UL>
<LI>a sequence of digits containing an optional decimal point,
<LI>an optional 'e' or 'E' followed by an optionally signed sequence of digits.
</UL>
<BR>A hexadecimal floating-point number recognized by<TT> strtod</TT> (after optional sign was processed) is a string containing:
<UL>
<LI>a<TT> 0X</TT> prefix, ignoring case,
<LI>a sequence of hexadecimal digits containing an optional decimal point,
<LI>an optional 'p' or 'P' followed by an optionally signed sequence of decimal digits.
</UL>
<BR>The subject sequence is defined as the longest initial subsequence of the input string, starting with the first non-white-space
character, that is of the expected form.&nbsp; The subject sequence contains no characters if the input string is not of the
expected form.
<BR><BR>If the subject sequence contains<TT> NAN</TT>, a NaN (with appropriate sign) will be returned; the optional digit-nondigit
sequence is ignored.&nbsp; If the subject sequence contains<TT> INF</TT>, the value of infinity (with appropriate sign) will
be returned.&nbsp; This case can be distinguished from overflow by checking <TT> errno</TT>.
<BR><BR>For a hexadecimal floating-point number, the optional exponent is binary (that is, denotes a power of two), not decimal.
<BR><BR>A pointer to the final string (following the subject sequence) will be stored in the object to which<B> endptr</B>
points if<B> endptr</B> is not<TT> NULL.</TT>&nbsp; By comparing the &quot;end&quot; pointer with<B> ptr</B>, it can be determined
how much of the string, if any, was scanned by the<TT> strtod</TT> function.
<BR><BR>The<TT> wcstod</TT> function is a wide-character version of<TT> strtod</TT> that operates with wide-character strings.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> strtod</TT> function returns the converted value, if any.&nbsp; If no conversion could be performed, zero is returned.
&nbsp;If the correct value would cause overflow, plus or minus <TT> HUGE_VAL</TT> is returned according to the sign, and <TT>
errno</TT> is set to <TT> ERANGE</TT>.&nbsp; If the correct value would cause underflow, then zero is returned, and <TT> errno</TT>
is set to <TT> ERANGE</TT>.&nbsp; Zero is returned when the input string cannot be converted.&nbsp; In this case, <TT> errno</TT>
is not set.&nbsp; When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been
detected.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#atof">atof</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; double pi;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; pi = strtod( &quot;3.141592653589793&quot;, NULL );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;pi=%17.15f\n&quot;,pi );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C90
</DL>
<DL>
<DT>Systems:
<DD><TT> strtod - Math</TT>
<BR><BR><TT>wcstod - Math</TT>
</DL>
<H2 ID="strtok"> strtok, strtok_r, _fstrtok, _fstrtok_r, wcstok, _mbstok, _mbstok_r, _fmbstok, _fmbstok_r </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>char *strtok( char *s1, const char *s2 );</TT>
<BR><TT>char *strtok_r( char *s1, const char *s2, char **p1 );</TT>
<BR><TT>char __far *_fstrtok( char __far *s1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; const char __far *s2 );</TT>
<BR><TT>char __far *_fstrtok_r( char __far *s1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; const char __far *s2,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; char __far **p1 );</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>wchar_t *wcstok( wchar_t *s1, const wchar_t *s2,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t **ptr );</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>unsigned char *_mbstok( unsigned char *s1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned
char *s2 );</TT>
<BR><TT>unsigned char *_mbstok_r( unsigned char *s1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned
char *s2,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char
**p1 );</TT>
<BR><TT>unsigned char __far *_fmbstok( unsigned char __far *s1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char __far *s2 );</TT>
<BR><TT>unsigned char __far *_fmbstok_r( unsigned char __far *s1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char __far *s2,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; unsigned char __far **p1 );</TT>
</DL>
<DL>
<DT>Safer C:
<DD>The Safer C Library extension provides the <A HREF="#strtok_s">strtok_s</A> function which is a safer alternative to<TT> strtok</TT>
This newer<TT> strtok_s</TT> function is recommended to be used instead of the traditional &quot;unsafe&quot;<TT> strtok</TT>
function.
</DL>
<DL>
<DT>Description:
<DD>The<TT> strtok</TT> function is used to break the string pointed to by<B> s1</B> into a sequence of tokens, each of which
is delimited by a character from the string pointed to by<B> s2</B>.&nbsp; The first call to<TT> strtok</TT> will return a
pointer to the first token in the string pointed to by<B> s1</B>.&nbsp; Subsequent calls to<TT> strtok</TT> must pass a NULL
pointer as the first argument, in order to get the next token in the string.&nbsp; The set of delimiters used in each of these
calls to<TT> strtok</TT> can be different from one call to the next.
<BR><BR>The first call in the sequence searches<B> s1</B> for the first character that is not contained in the current delimiter
string<B> s2</B>.&nbsp; If no such character is found, then there are no tokens in<B> s1</B> and the<TT> strtok</TT> function
returns a NULL pointer.&nbsp; If such a character is found, it is the start of the first token.
<BR><BR>The<TT> strtok</TT> function then searches from there for a character that is contained in the current delimiter string.
&nbsp;If no such character is found, the current token extends to the end of the string pointed to by<B> s1</B>.&nbsp; If
such a character is found, it is overwritten by a null character, which terminates the current token.&nbsp; The<TT> strtok</TT>
function saves a pointer to the following character, from which the next search for a token will start when the first argument
is a NULL pointer.
<BR><BR>Because<TT> strtok</TT> may modify the original string, that string should be duplicated if the string is to be re-used.
<BR><BR>The reentrant form of this function, <TT> strtok_r</TT> , also requires a pointer to a string pointer to be passed.
&nbsp;This pointer is used internally by the function for subsequent calls to perform tokenizing without relying on internal
state within the function.
<BR><BR>The<TT> _fstrtok</TT> function is a data model independent form of the strtok function.&nbsp; It accepts far pointer
arguments and returns a far pointer.&nbsp; It is most useful in mixed memory model applications.
<BR><BR>The<TT> wcstok</TT> function is a wide-character version of<TT> strtok</TT> that operates with wide-character strings.
&nbsp;The third argument<B> ptr</B> points to a caller-provided <TT> wchar_t</TT> pointer into which the<TT> wcstok</TT> function
stores information necessary for it to continue scanning the same wide string.
<BR><BR>On the first call in the sequence of calls to wcstok,<B> s1</B> points to a wide string.&nbsp; In subsequent calls
for the same string,<B> s1</B> must be NULL.&nbsp; If<B> s1</B> is NULL, the value pointed to by<B> ptr</B> matches that set
by the previous call to<TT> wcstok</TT> for the same wide string.&nbsp; Otherwise, the value of<B> ptr</B> is ignored.&nbsp;
The list of delimiters pointed to by<B> s2</B> may be different from one call to the next.&nbsp; The tokenization of<B> s1</B>
is similar to that for the<TT> strtok</TT> function.
<BR><BR>The<TT> _mbstok_r</TT> function is a multibyte character version of<TT> strtok</TT> that operates with multibyte character
strings.
<BR><BR>The<TT> _fmbstok_r</TT> function is a data model independent form of the _mbstok_r function that accepts far pointer
arguments.&nbsp; It is most useful in mixed memory model applications.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> strtok</TT> function returns a pointer to the first character of a token or<TT> NULL</TT> if there is no token found.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#strcspn">strcspn</A>, <A HREF="#strpbrk">strpbrk</A>, <A HREF="#strtok_s">strtok_s</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char *p;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char *buffer;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char *delims = { &quot; .,&quot; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; buffer = strdup( &quot;Find words, all of them.&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, buffer );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; p = strtok( buffer, delims );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; while( p != NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;word: %s\n&quot;, p );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p = strtok( NULL, delims );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, buffer );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>Find words, all of them.</TT>
<BR><TT>word: Find</TT>
<BR><TT>word: words</TT>
<BR><TT>word: all</TT>
<BR><TT>word: of</TT>
<BR><TT>word: them</TT>
<BR><TT>Find</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>strtok_r is WATCOM
<BR>_fstrtok is WATCOM
<BR>_fstrtok_r is WATCOM
<BR>wcstok is ISO C95
<BR>_mbstok is WATCOM
<BR>_mbstok_r is WATCOM
<BR>_fmbstok is WATCOM
<BR>_fmbstok_r is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> strtok - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>strtok_r - All, Linux, RDOS, Netware</TT>
<BR><TT>_fstrtok - All, Linux, RDOS</TT>
<BR><TT>_fstrtok_r - All, Linux, RDOS</TT>
<BR><TT>wcstok - All, Linux</TT>
<BR><TT>_mbstok - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
<BR><TT>_mbstok_r - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
<BR><TT>_fmbstok - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
<BR><TT>_fmbstok_r - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="strtok_s"> strtok_s, wcstok_s </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__ 1</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>char *strtok_s( char * restrict s1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rsize_t * restrict s1max,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char * restrict s2,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char ** restrict ptr);</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>wchar_t *wcstok_s( wchar_t * restrict s1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rsize_t
* restrict s1max,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const
wchar_t * restrict s2,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t
** restrict ptr);</TT>
</DL>
<DL>
<DT>Constraints:
<DD>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<TT>
strtok_s</TT> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<BR><BR>None of<B> s1max</B>,<B> s2</B>, or<B> ptr</B> shall be a null pointer.&nbsp; If<B> s1</B> is a null pointer,then<B>
*ptr</B> shall not be a null pointer.&nbsp; The value of<B> *s1max</B> shall not be greater than <TT> RSIZE_MAX</TT>.&nbsp;
The end of the token found shall occur within the first<B> *s1max</B> characters of<B> s1</B> for the first call, and shall
occur within the first<B> *s1max</B> characters of where searching resumes on subsequent calls.&nbsp; If there is a runtime-constraint
violation, the<TT> strtok_s</TT> function does not indirect through the<B> s1</B> or<B> s2</B> pointers, and does not store
a value in the object pointed to by<B> ptr</B>.
</DL>
<DL>
<DT>Description:
<DD>A sequence of calls to the<TT> strtok_s</TT> function breaks the string pointed to by<B> s1</B> into a sequence of tokens,
each of which is delimited by a character from the string pointed to by<B> s2</B>.&nbsp; The fourth argument points to a caller-provided
char pointer into which the<TT> strtok_s</TT> function stores information necessary for it to continue scanning the same string.
&nbsp;The first call in a sequence has a non-null first argument and<B> s1max</B> points to an object whose value is the number
of elements in the character array pointed to by the first argument.&nbsp; The first call stores an initial value in the object
pointed to by<B> ptr</B> and updates the value pointed to by<B> s1max</B> to reflect the number of elements that remain in
relation to<B> ptr</B>.&nbsp; Subsequent calls in the sequence have a null first argument and the objects pointed to by<B>
s1max</B> and<B> ptr</B> are required to have the values stored by the previous call in the sequence, which are then updated.
&nbsp;The separator string pointed to by<B> s2</B> may be different from call to call.&nbsp; The first call in the sequence
searches the string pointed to by<B> s1</B> for the first character that is not contained in the current separator string
pointed to by<B> s2</B>.&nbsp; If no such character is found, then there are no tokens in the string pointed to by<B> s1</B>
and the<TT> strtok_s</TT> function returns a null pointer.&nbsp; If such a character is found, it is the start of the first
token.&nbsp; The<TT> strtok_s</TT> function then searches from there for the first character in<B> s1</B> that is contained
in the current separator string.&nbsp; If no such character is found, the current token extends to the end of the string pointed
to by<B> s1</B>, and subsequent searches in the same string for a token return a null pointer.&nbsp; If such a character is
found, it is overwritten by a null character, which terminates the current token.&nbsp; In all cases, the<TT> strtok_s</TT>
function stores sufficient information in the pointer pointed to by<B> ptr</B> so that subsequent calls, with a null pointer
for<B> s1</B> and the unmodified pointer value for<B> ptr</B>, shall start searching
<BR>just past the element overwritten by a null character (if any).
<BR><BR>The<TT> wcstok_s</TT> function is a wide-character version of<TT> strtok_s</TT> that operates with wide-character
strings.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> strtok_s</TT> function returns a pointer to the first character of a token, or a null pointer if there is no token
or there is a runtime-constraint violation.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#strtok">strtok</A>, <A HREF="#strcspn">strcspn</A>, <A HREF="#strpbrk">strpbrk</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__ 1</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; *p;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; *buffer;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; *delims = { &quot; .,&quot; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; size_t&nbsp; buflen;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; *ptr;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; buffer = strdup( &quot;Find words, all of them.&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, buffer );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; buflen = strlen( buffer );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; p = strtok_s( buffer, &amp;buflen, delims, &amp;ptr );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; while( p != NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;word: %s\n&quot;, p );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p = strtok_s( NULL, &amp;buflen, delims, &amp;ptr );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, buffer );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>Find words, all of them.</TT>
<BR><TT>word: Find</TT>
<BR><TT>word: words</TT>
<BR><TT>word: all</TT>
<BR><TT>word: of</TT>
<BR><TT>word: them</TT>
<BR><TT>Find</TT>
</DL>
<DL>
<DT>Classification:
<DD>TR 24731
</DL>
<DL>
<DT>Systems:
<DD><TT> strtok_s - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>wcstok_s - All, Linux</TT>
</DL>
<H2 ID="strtol"> strtol, wcstol </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>long int strtol( const char *ptr,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char **endptr,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int base );</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>long int wcstol( const wchar_t *ptr,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t **endptr,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int base );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> strtol</TT> function converts the string pointed to by<B> ptr</B> to an object of type<TT> long int.</TT>&nbsp; The<TT>
strtol</TT> function recognizes a string containing:
<UL>
<LI>optional white space,
<LI>an optional plus or minus sign,
<LI>a sequence of digits and letters.
</UL>
<BR>The conversion ends at the first unrecognized character.&nbsp; A pointer to that character will be stored in the object
to which<B> endptr</B> points if<B> endptr</B> is not<TT> NULL.</TT>
<BR><BR>If<B> base</B> is zero, the first characters after the optional sign determine the base used for the conversion.&nbsp;
If the first characters are &quot;0x&quot; or &quot;0X&quot; the digits are treated as hexadecimal.&nbsp; If the first character
is '0', the digits are treated as octal.&nbsp; Otherwise the digits are treated as decimal.
<BR><BR>If<B> base</B> is not zero, it must have a value between 2 and 36.&nbsp; The letters a-z and A-Z represent the values
10 through 35.&nbsp; Only those letters whose designated values are less than<B> base</B> are permitted.&nbsp; If the value
of<B> base</B> is 16, the characters &quot;0x&quot; or &quot;0X&quot; may optionally precede the sequence of letters and digits.
<BR><BR>The<TT> wcstol</TT> function is a wide-character version of<TT> strtol</TT> that operates with wide-character strings.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> strtol</TT> function returns the converted value.&nbsp; If the correct value would cause overflow, <TT> LONG_MAX</TT>
or <TT> LONG_MIN</TT> is returned according to the sign, and <TT> errno</TT> is set to <TT> ERANGE</TT>.&nbsp; If<B> base</B>
is out of range, zero is returned and <TT> errno</TT> is set to <TT> EDOM</TT>.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#atoi">atoi</A>, <A HREF="#atol">atol</A>, <A HREF="#atoll">atoll</A>, <A HREF="#itoa">itoa</A>, <A HREF="#ltoa">ltoa</A>,
<A HREF="#lltoa">lltoa</A>, <A HREF="#sscanf">sscanf</A>, <A HREF="#strtoll">strtoll</A>, <A HREF="#strtoul">strtoul</A>,
<A HREF="#strtoull">strtoull</A>, <A HREF="#strtoimax">strtoimax</A>, <A HREF="#strtoumax">strtoumax</A>, <A HREF="#ultoa">ultoa</A>,
<A HREF="#ulltoa">ulltoa</A>, <A HREF="#utoa">utoa</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; long int v;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; v = strtol( &quot;12345678&quot;, NULL, 10 );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD><TT> strtol - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>wcstol - All, Linux, RDOS</TT>
</DL>
<H2 ID="strtoll"> strtoll, wcstoll </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>long long int strtoll( const char *ptr,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; char **endptr,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; int base );</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>long long int wcstoll( const wchar_t *ptr,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; wchar_t **endptr,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; int base );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> strtoll</TT> function converts the string pointed to by<B> ptr</B> to an object of type<TT> long long int.</TT>&nbsp;
The<TT> strtoll</TT> function recognizes a string containing:
<UL>
<LI>optional white space,
<LI>an optional plus or minus sign,
<LI>a sequence of digits and letters.
</UL>
<BR>The conversion ends at the first unrecognized character.&nbsp; A pointer to that character will be stored in the object
to which<B> endptr</B> points if<B> endptr</B> is not<TT> NULL.</TT>
<BR><BR>If<B> base</B> is zero, the first characters after the optional sign determine the base used for the conversion.&nbsp;
If the first characters are &quot;0x&quot; or &quot;0X&quot; the digits are treated as hexadecimal.&nbsp; If the first character
is '0', the digits are treated as octal.&nbsp; Otherwise the digits are treated as decimal.
<BR><BR>If<B> base</B> is not zero, it must have a value between 2 and 36.&nbsp; The letters a-z and A-Z represent the values
10 through 35.&nbsp; Only those letters whose designated values are less than<B> base</B> are permitted.&nbsp; If the value
of<B> base</B> is 16, the characters &quot;0x&quot; or &quot;0X&quot; may optionally precede the sequence of letters and digits.
<BR><BR>The<TT> wcstoll</TT> function is a wide-character version of<TT> strtoll</TT> that operates with wide-character strings.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> strtoll</TT> function returns the converted value.&nbsp; If the correct value would cause overflow, <TT> LLONG_MAX</TT>
or <TT> LLONG_MIN</TT> is returned according to the sign, and <TT> errno</TT> is set to <TT> ERANGE</TT>.&nbsp; If<B> base</B>
is out of range, zero is returned and <TT> errno</TT> is set to <TT> EDOM</TT>.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#atoi">atoi</A>, <A HREF="#atol">atol</A>, <A HREF="#atoll">atoll</A>, <A HREF="#itoa">itoa</A>, <A HREF="#ltoa">ltoa</A>,
<A HREF="#lltoa">lltoa</A>, <A HREF="#sscanf">sscanf</A>, <A HREF="#strtol">strtol</A>, <A HREF="#strtoul">strtoul</A>, <A HREF="#strtoull">strtoull</A>,
<A HREF="#strtoimax">strtoimax</A>, <A HREF="#strtoumax">strtoumax</A>, <A HREF="#ultoa">ultoa</A>, <A HREF="#ulltoa">ulltoa</A>,
<A HREF="#utoa">utoa</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; long long int v;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; v = strtol( &quot;12345678909876&quot;, NULL, 10 );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD><TT> strtoll - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>wcstoll - All, Linux, RDOS</TT>
</DL>
<H2 ID="strtoimax"> strtoimax, wcstoimax </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;inttypes.h&gt;</TT>
<BR><TT>intmax_t strtoimax( const char *ptr,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
char **endptr,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
int base );</TT>
<BR><TT>intmax_t wcstoimax( const wchar_t *ptr,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
wchar_t **endptr,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
int base );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> strtoimax</TT> function converts the string pointed to by<B> ptr</B> to an object of type<TT> intmax_t.</TT>&nbsp;
The<TT> strtoimax</TT> function recognizes a string containing:
<UL>
<LI>optional white space,
<LI>an optional plus or minus sign,
<LI>a sequence of digits and letters.
</UL>
<BR>The conversion ends at the first unrecognized character.&nbsp; A pointer to that character will be stored in the object
to which<B> endptr</B> points if<B> endptr</B> is not<TT> NULL.</TT>
<BR><BR>If<B> base</B> is zero, the first characters after the optional sign determine the base used for the conversion.&nbsp;
If the first characters are &quot;0x&quot; or &quot;0X&quot; the digits are treated as hexadecimal.&nbsp; If the first character
is '0', the digits are treated as octal.&nbsp; Otherwise the digits are treated as decimal.
<BR><BR>If<B> base</B> is not zero, it must have a value between 2 and 36.&nbsp; The letters a-z and A-Z represent the values
10 through 35.&nbsp; Only those letters whose designated values are less than<B> base</B> are permitted.&nbsp; If the value
of<B> base</B> is 16, the characters &quot;0x&quot; or &quot;0X&quot; may optionally precede the sequence of letters and digits.
<BR><BR>The<TT> wcstoimax</TT> function is a wide-character version of<TT> strtoimax</TT> that operates with wide-character
strings.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> strtoimax</TT> function returns the converted value.&nbsp; If the correct value would cause overflow, <TT> INTMAX_MAX</TT>
or <TT> INTMAX_MIN</TT> is returned according to the sign, and <TT> errno</TT> is set to <TT> ERANGE</TT>.&nbsp; If<B> base</B>
is out of range, zero is returned and <TT> errno</TT> is set to <TT> EDOM</TT>.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#atoi">atoi</A>, <A HREF="#atol">atol</A>, <A HREF="#atoll">atoll</A>, <A HREF="#itoa">itoa</A>, <A HREF="#ltoa">ltoa</A>,
<A HREF="#lltoa">lltoa</A>, <A HREF="#sscanf">sscanf</A>, <A HREF="#strtol">strtol</A>, <A HREF="#strtoll">strtoll</A>, <A HREF="#strtoul">strtoul</A>,
<A HREF="#strtoull">strtoull</A>, <A HREF="#strtoumax">strtoumax</A>, <A HREF="#ultoa">ultoa</A>, <A HREF="#ulltoa">ulltoa</A>,
<A HREF="#utoa">utoa</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;inttypes.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; intmax_t v;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; v = strtoimax( &quot;12345678909876&quot;, NULL, 10 );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD><TT> strtoimax - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>wcstoimax - All, Linux, RDOS</TT>
</DL>
<H2 ID="strtoul"> strtoul, wcstoul </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>unsigned long int strtoul( const char *ptr,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char **endptr,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int base );</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>unsigned long int wcstoul( const wchar_t *ptr,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t **endptr,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int base );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> strtoul</TT> function converts the string pointed to by<B> ptr</B> to an<TT> unsigned long.</TT>&nbsp; The function
recognizes a string containing optional white space, an optional sign (+ or -), followed by a sequence of digits and letters.
&nbsp;The conversion ends at the first unrecognized character.&nbsp; A pointer to that character will be stored in the object<B>
endptr</B> points to if<B> endptr</B> is not<TT> NULL.</TT>
<BR><BR>If<B> base</B> is zero, the first characters determine the base used for the conversion.&nbsp; If the first characters
are &quot;0x&quot; or &quot;0X&quot; the digits are treated as hexadecimal.&nbsp; If the first character is '0', the digits
are treated as octal.&nbsp; Otherwise the digits are treated as decimal.
<BR><BR>If<B> base</B> is not zero, it must have a value of between 2 and 36.&nbsp; The letters a-z and A-Z represent the
values 10 through 35.&nbsp; Only those letters whose designated values are less than<B> base</B> are permitted.&nbsp; If the
value of<B> base</B> is 16, the characters &quot;0x&quot; or &quot;0X&quot; may optionally precede the sequence of letters
and digits.
<BR><BR>If there is a leading minus sign in the string, the value is negated.
<BR><BR>The<TT> wcstoul</TT> function is a wide-character version of<TT> strtoul</TT> that operates with wide-character strings.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> strtoul</TT> function returns the converted value.&nbsp; If the correct value would cause overflow, <TT> ULONG_MAX</TT>
is returned and <TT> errno</TT> is set to <TT> ERANGE</TT>.&nbsp; If<B> base</B> is out of range, zero is returned and <TT>
errno</TT> is set to <TT> EDOM</TT>.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#atoi">atoi</A>, <A HREF="#atol">atol</A>, <A HREF="#atoll">atoll</A>, <A HREF="#itoa">itoa</A>, <A HREF="#ltoa">ltoa</A>,
<A HREF="#lltoa">lltoa</A>, <A HREF="#sscanf">sscanf</A>, <A HREF="#strtol">strtol</A>, <A HREF="#strtoll">strtoll</A>, <A HREF="#strtoull">strtoull</A>,
<A HREF="#strtoimax">strtoimax</A>, <A HREF="#strtoumax">strtoumax</A>, <A HREF="#ultoa">ultoa</A>, <A HREF="#ulltoa">ulltoa</A>,
<A HREF="#utoa">utoa</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned long int v;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; v = strtoul( &quot;12345678&quot;, NULL, 10 );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD><TT> strtoul - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>wcstoul - All, Linux, RDOS</TT>
</DL>
<H2 ID="strtoull"> strtoull, wcstoull </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>unsigned long long int strtoull( const char *ptr,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char **endptr,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int base );</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>unsigned long long int wcstoull( const wchar_t *ptr,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t **endptr,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int base );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> strtoull</TT> function converts the string pointed to by<B> ptr</B> to an<TT> unsigned long long.</TT>&nbsp; The function
recognizes a string containing optional white space, an optional sign (+ or -), followed by a sequence of digits and letters.
&nbsp;The conversion ends at the first unrecognized character.&nbsp; A pointer to that character will be stored in the object<B>
endptr</B> points to if<B> endptr</B> is not<TT> NULL.</TT>
<BR><BR>If<B> base</B> is zero, the first characters determine the base used for the conversion.&nbsp; If the first characters
are &quot;0x&quot; or &quot;0X&quot; the digits are treated as hexadecimal.&nbsp; If the first character is '0', the digits
are treated as octal.&nbsp; Otherwise the digits are treated as decimal.
<BR><BR>If<B> base</B> is not zero, it must have a value of between 2 and 36.&nbsp; The letters a-z and A-Z represent the
values 10 through 35.&nbsp; Only those letters whose designated values are less than<B> base</B> are permitted.&nbsp; If the
value of<B> base</B> is 16, the characters &quot;0x&quot; or &quot;0X&quot; may optionally precede the sequence of letters
and digits.
<BR><BR>If there is a leading minus sign in the string, the value is negated.
<BR><BR>The<TT> wcstoull</TT> function is a wide-character version of<TT> strtoull</TT> that operates with wide-character
strings.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> strtoull</TT> function returns the converted value.&nbsp; If the correct value would cause overflow, <TT> ULLONG_MAX</TT>
is returned and <TT> errno</TT> is set to <TT> ERANGE</TT>.&nbsp; If<B> base</B> is out of range, zero is returned and <TT>
errno</TT> is set to <TT> EDOM</TT>.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#atoi">atoi</A>, <A HREF="#atol">atol</A>, <A HREF="#atoll">atoll</A>, <A HREF="#itoa">itoa</A>, <A HREF="#ltoa">ltoa</A>,
<A HREF="#lltoa">lltoa</A>, <A HREF="#sscanf">sscanf</A>, <A HREF="#strtol">strtol</A>, <A HREF="#strtoll">strtoll</A>, <A HREF="#strtoul">strtoul</A>,
<A HREF="#strtoimax">strtoimax</A>, <A HREF="#strtoumax">strtoumax</A>, <A HREF="#ultoa">ultoa</A>, <A HREF="#ulltoa">ulltoa</A>,
<A HREF="#utoa">utoa</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned long long int v;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; v = strtoul( &quot;12345678909876&quot;, NULL, 10 );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD><TT> strtoull - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>wcstoull - All, Linux, RDOS</TT>
</DL>
<H2 ID="strtoumax"> strtoumax, wcstoumax </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;inttypes.h&gt;</TT>
<BR><TT>uintmax_t strtoumax( const char *ptr,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;char **endptr,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;int base );</TT>
<BR><TT>#include &lt;inttypes.h&gt;</TT>
<BR><TT>uintmax_t wcstoumax( const wchar_t *ptr,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;wchar_t **endptr,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;int base );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> strtoumax</TT> function converts the string pointed to by<B> ptr</B> to an<TT> uintmax_t.</TT>&nbsp; The function
recognizes a string containing optional white space, an optional sign (+ or -), followed by a sequence of digits and letters.
&nbsp;The conversion ends at the first unrecognized character.&nbsp; A pointer to that character will be stored in the object<B>
endptr</B> points to if<B> endptr</B> is not<TT> NULL.</TT>
<BR><BR>If<B> base</B> is zero, the first characters determine the base used for the conversion.&nbsp; If the first characters
are &quot;0x&quot; or &quot;0X&quot; the digits are treated as hexadecimal.&nbsp; If the first character is '0', the digits
are treated as octal.&nbsp; Otherwise the digits are treated as decimal.
<BR><BR>If<B> base</B> is not zero, it must have a value of between 2 and 36.&nbsp; The letters a-z and A-Z represent the
values 10 through 35.&nbsp; Only those letters whose designated values are less than<B> base</B> are permitted.&nbsp; If the
value of<B> base</B> is 16, the characters &quot;0x&quot; or &quot;0X&quot; may optionally precede the sequence of letters
and digits.
<BR><BR>If there is a leading minus sign in the string, the value is negated.
<BR><BR>The<TT> wcstoumax</TT> function is a wide-character version of<TT> strtoumax</TT> that operates with wide-character
strings.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> strtoumax</TT> function returns the converted value.&nbsp; If the correct value would cause overflow, <TT> UINTMAX_MAX</TT>
is returned and <TT> errno</TT> is set to <TT> ERANGE</TT>.&nbsp; If<B> base</B> is out of range, zero is returned and <TT>
errno</TT> is set to <TT> EDOM</TT>.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#atoi">atoi</A>, <A HREF="#atol">atol</A>, <A HREF="#atoll">atoll</A>, <A HREF="#itoa">itoa</A>, <A HREF="#ltoa">ltoa</A>,
<A HREF="#lltoa">lltoa</A>, <A HREF="#sscanf">sscanf</A>, <A HREF="#strtol">strtol</A>, <A HREF="#strtoll">strtoll</A>, <A HREF="#strtoul">strtoul</A>,
<A HREF="#strtoull">strtoull</A>, <A HREF="#strtoimax">strtoimax</A>, <A HREF="#ultoa">ultoa</A>, <A HREF="#ulltoa">ulltoa</A>,
<A HREF="#utoa">utoa</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;inttypes.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; uintmax_t v;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; v = strtoumax( &quot;12345678909876&quot;, NULL, 10 );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD><TT> strtoumax - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>wcstoumax - All, Linux, RDOS</TT>
</DL>
<H2 ID="strupr"> strupr, _strupr, _fstrupr, _wcsupr, _mbsupr, _fmbsupr </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>char *strupr( char *s );</TT>
<BR><TT>char *_strupr( char *s );</TT>
<BR><TT>char __far *_fstrupr( char __far *s );</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>wchar_t *_wcsupr( wchar_t *s );</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>unsigned char *_mbsupr( unsigned char *s );</TT>
<BR><TT>unsigned char __far *_fmbsupr( unsigned char __far *s );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> strupr</TT> function replaces the string<B> s</B> with uppercase characters by invoking the <TT> toupper</TT> function
for each character in the string.
<BR><BR>The<TT> _strupr</TT> function is identical to<TT> strupr</TT>.&nbsp; Use<TT> _strupr</TT> for ANSI naming conventions.
<BR><BR>The<TT> _fstrupr</TT> function is a data model independent form of the strupr function.&nbsp; It accepts far pointer
arguments and returns a far pointer.&nbsp; It is most useful in mixed memory model applications.
<BR><BR>The<TT> _wcsupr</TT> function is a wide-character version of<TT> strupr</TT> that operates with wide-character strings.
<BR><BR>The<TT> _mbsupr</TT> function is a multibyte character version of<TT> strupr</TT> that operates with multibyte character
strings.
</DL>
<DL>
<DT>Returns:
<DD>The address of the original string<B> s</B> is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#strlwr">strlwr</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><BR><TT>char source[] = { &quot;A mixed-case STRING&quot; };</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, source );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, strupr( source ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, source );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>A mixed-case STRING</TT>
<BR><TT>A MIXED-CASE STRING</TT>
<BR><TT>A MIXED-CASE STRING</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
<BR><BR>_strupr conforms to ANSI naming conventions
</DL>
<DL>
<DT>Systems:
<DD><TT> strupr - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_strupr - All, Linux, RDOS, Netware</TT>
<BR><TT>_fstrupr - All, Linux, RDOS</TT>
<BR><TT>_wcsupr - All, Linux</TT>
<BR><TT>_mbsupr - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
<BR><TT>_fmbsupr - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="strxfrm"> strxfrm, wcsxfrm </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>size_t strxfrm( char *dst,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *src,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t n );</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>size_t wcsxfrm( wchar_t *dst,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t *src,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t n );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> strxfrm</TT> function transforms, for no more than<B> n</B> characters, the string pointed to by<B> src</B> to the
buffer pointed to by<B> dst</B>.&nbsp; The transformation uses the collating sequence selected by the <TT> setlocale</TT>
function so that two transformed strings will compare identically (using the <TT> strncmp</TT> function) to a comparison of
the original two strings using the <TT> strcoll</TT> function.&nbsp; The function will be equivalent to the <TT> strncpy</TT>
function (except there is no padding of the<B> dst</B> argument with null characters when the argument<B> src</B> is shorter
than<B> n</B> characters) when the collating sequence is selected from the<TT> &quot;C&quot;</TT> locale.
<BR><BR>The<TT> wcsxfrm</TT> function is a wide-character version of<TT> strxfrm</TT> that operates with wide-character strings.
&nbsp;For wcsxfrm, after the string transformation, a call to <TT> wcscmp</TT> with the two transformed strings yields results
identical to those of a call to <TT> wcscoll</TT> applied to the original two strings.<TT>&nbsp; wcsxfrm</TT> and<TT> strxfrm</TT>
behave identically otherwise.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> strxfrm</TT> function returns the length of the transformed string.&nbsp; If this length is more than<B> n</B>, the
contents of the array pointed to by<B> dst</B> are indeterminate.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#setlocale">setlocale</A>, <A HREF="#strcoll">strcoll</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>#include &lt;locale.h&gt;</TT>
<BR><BR><TT>char src[] = { &quot;A sample STRING&quot; };</TT>
<BR><TT>char dst[20];</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; size_t len;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; setlocale( LC_ALL, &quot;C&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, src );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; len = strxfrm( dst, src, 20 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s (%u)\n&quot;, dst, len );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>A sample STRING</TT>
<BR><TT>A sample STRING (15)</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD><TT> strxfrm - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>wcsxfrm - All, Linux</TT>
</DL>
<H2 ID="swab"> swab </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>void swab( char *src, char *dest, int num );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> swab</TT> function copies<B> num</B> bytes (which should be even) from<B> src</B> to<B> dest</B> swapping every pair
of characters.&nbsp; This is useful for preparing binary data to be transferred to another machine that has a different byte
ordering.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> swab</TT> function has no return value.
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>char *msg = &quot;hTsim seasegi&nbsp; swspaep.d&quot;;</TT>
<BR><TT>#define NBYTES 24</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; auto char buffer[80];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, msg );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; memset( buffer, '\0', 80 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; swab( msg, buffer, NBYTES );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, buffer );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>hTsim seasegi&nbsp; swspaep.d</TT>
<BR><TT>This message is swapped.</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="sysconf"> sysconf </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;unistd.h&gt;</TT>
<BR><TT>long sysconf( int name );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> sysconf</TT> function retrieves a current system configuration parameter depending on the value of system information
from the kernel via the<B> name</B> passed.&nbsp; This implementation currently supports the following inputs:
<DL>
<DT>Member&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>_SC_ARG_MAX
<DD>The maximum number of arguments supported by<TT> execv</TT> and related arguments
<DT>_SC_CHILD_MAX
<DD>The maximum number of per-user child processes
<DT>_SC_CLK_TCK
<DD>The number of clock ticks per second
<DT>_SC_NGROUPS_MAX
<DD>The maximum number of groups to which a user may be a member
<DT>_SC_OPEN_MAX
<DD>The maximum number of file that may be opened by a user
<DT>_SC_JOB_CONTROL
<DD>If job control is supported, the value of 1 is returned
<DT>_SC_SAVED_IDS
<DD>If saved identifiers are supported, the value of 1 is returned
<DT>_SC_VERSION
<DD>The release year and month of the POSIX.1 standard attempting to be supported, in the format YYYYMM
<DT>_SC_STREAM_MAX
<DD>The maximum number of per-process streams supported
<DT>_SC_TZNAME_MAX
<DD>The maximum length of a time zone name
<DT>_SC_PAGESIZE
<DD>The size, in bytes, of one page of memory
<DT>_SC_NPROCESSORS_CONF
<DD>The number of processors currently configured on the system
<DT>_SC_NPROCESSORS_ONLN
<DD>The number of processors currently online and functioning on the system
<DT>_SC_PHYS_PAGES
<DD>The total number of physical pages of memory for the system
<DT>_SC_AVPHYS_PAGES
<DD>The available number of physical pages of memory for the system
<DT>_SC_REALTIME_SIGNALS
<DD>If real-time signals are supported, the value of 1 is returned
<DT>_SC_SOMAXCONN
<DD>For the socket <TT> listen</TT> function, retrieve the largest supported backlog of listen requests
</DL>
<BR>In this implementation, requesting either _SC_NPROCESSORS_CONF or _SC_NPROCESSORS_ONLN will return the same value.
<BR>Some inputs, specifically _SC_OPEN_MAX and _SC_CHILD_MAX, are configurable via calls to<TT> setrlimit</TT> and may change
between subsequent<TT> sysconf</TT> calls.
</DL>
<DL>
<DT>Returns:
<DD>If successful, the function will return zero.&nbsp; If the call fails, the return value is -1, and <TT> errno</TT> will be
set appropriately.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>EINVAL
<DD>The value of<B> name</B> is unsupported on this implementation
</DL>
</DL>
<DL>
<DT>Classification:
<DD>POSIX
</DL>
<DL>
<DT>Systems:
<DD>Linux
</DL>
<H2 ID="sysinfo"> sysinfo </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;sys/sysinfo.h&gt;</TT>
<BR><TT>int sysinfo( struct sysinfo *info );</TT>
<BR><BR><TT>struct sysinfo {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned long uptime;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned long loads[3];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned long totalram;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned long freeram;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned long sharedram;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned long bufferram;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned long totalswap;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned long freeswap;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned short procs, pad;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned long totalhigh;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned long freehigh;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unsigned mem_unit;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char __reserved[];</TT>
<BR><TT>};</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> sysinfo</TT> function retrieves system information from the kernel via the<B> info</B> structure.&nbsp; The members
of the structure are defined below:
<DL>
<DT>Member&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>uptime
<DD>The number of seconds since the system booted
<DT>loads
<DD>The 1 minute, 5 minute, and 15 minute load averages
<DT>totalram
<DD>The total usable amount of system memory in bytes
<DT>freeram
<DD>The amount of memory currently unused and unallocated
<DT>sharedram
<DD>The amount of memory currently being shared
<DT>bufferram
<DD>The amount of memory allocated to buffering
<DT>totalswap
<DD>The amount of swap space available in bytes
<DT>freeswap
<DD>The amount of unused swap space
<DT>procs
<DD>The amount of processes currently running
<DT>pad
<DD>Padding for alignment; can be ignored
<DT>totalhigh
<DD>Total amount of &quot;high&quot; memory
<DT>mem_unit
<DD>The memory unit size in bytes
</DL>
</DL>
<DL>
<DT>Returns:
<DD>If successful, the function will return zero.&nbsp; If the call fails, the return value is -1, and <TT> errno</TT> will be
set appropriately.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>EINVAL
<DD>The value of<B> info</B> is NULL
<DT>EFAULT
<DD>The value of<B> info</B> is invalid
</DL>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>Linux
</DL>
<H2 ID="system"> system, _wsystem </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>int system( const char *command );</TT>
<BR><TT>int _wsystem( const wchar_t *command );</TT>
</DL>
<DL>
<DT>Description:
<DD>If the value of<B> command</B> is<TT> NULL,</TT> then the<TT> system</TT> function determines whether or not a command processor
is present (&quot;COMMAND.COM&quot; in DOS and Windows 95/98 or &quot;CMD.EXE&quot; in OS/2 and Windows NT/2000).
<BR><BR>Otherwise, the<TT> system</TT> function invokes a copy of the command processor, and passes the string<B> command</B>
to it for processing.&nbsp; This function uses <TT> spawnl</TT> to load a copy of the command processor identified by the
<TT> COMSPEC</TT> environment variable.
<BR><BR>This means that any command that can be entered to DOS can be executed, including programs, DOS commands and batch
files.&nbsp; The <TT> exec...</TT>&nbsp; and <TT> spawn...</TT>&nbsp; functions can only cause programs to be executed.
<BR><BR>The<TT> _wsystem</TT> function is a wide-character version of<TT> system</TT> that operates with wide-character strings.
</DL>
<DL>
<DT>Returns:
<DD>If the value of<B> command</B> is<TT> NULL,</TT> then the<TT> system</TT> function returns zero if the command processor is
not present, a non-zero value if the command processor is present.&nbsp; Note that Microsoft Windows 3.x does not support
a command shell and so the<TT> system</TT> function always returns zero when<B> command</B> is<TT> NULL.</TT>
<BR><BR>Otherwise, the<TT> system</TT> function returns the result of invoking a copy of the command processor.&nbsp; A non-zero
value is returned if the command processor could not be loaded; otherwise, zero is returned.&nbsp; When an error has occurred,
<TT> errno</TT> contains a value indicating the type of error that has been detected.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#abort">abort</A>, <A HREF="#atexit">atexit</A>, <A HREF="#_bgetcmd">_bgetcmd</A>, <A HREF="#exec___">exec...</A>,
<A HREF="#exit">exit</A>, <A HREF="#_Exit">_Exit</A>, <A HREF="#_exit">_exit</A>, <A HREF="#getcmd">getcmd</A>, <A HREF="#getenv">getenv</A>,
<A HREF="#main">main</A>, <A HREF="#onexit">onexit</A>, <A HREF="#putenv">putenv</A>, <A HREF="#spawn___">spawn...</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int rc;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; rc = system( &quot;dir&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( rc != 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;shell could not be run\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C, POSIX 1003.2
<BR><BR>_wsystem is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> system - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_wsystem - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</TT>
</DL>
<H2 ID="tan"> tan </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>double tan( double x );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> tan</TT> function computes the tangent of<B> x</B> (measured in radians).&nbsp; A large magnitude argument may yield
a result with little or no significance.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> tan</TT> function returns the tangent value.&nbsp; When an error has occurred, <TT> errno</TT> contains a value indicating
the type of error that has been detected.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#atan">atan</A>, <A HREF="#atan2">atan2</A>, <A HREF="#cos">cos</A>, <A HREF="#sin">sin</A>, <A HREF="#tanh">tanh</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, tan(.5) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>0.546302</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD>Math
</DL>
<H2 ID="tanh"> tanh </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>double tanh( double x );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> tanh</TT> function computes the hyperbolic tangent of<B> x</B>.
<BR><BR>When the<B> x</B> argument is large, partial or total loss of significance may occur.&nbsp; The <TT> matherr</TT>
function will be invoked in this case.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> tanh</TT> function returns the hyperbolic tangent value.&nbsp; When an error has occurred, <TT> errno</TT> contains
a value indicating the type of error that has been detected.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#cosh">cosh</A>, <A HREF="#sinh">sinh</A>, <A HREF="#matherr">matherr</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, tanh(.5) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>0.462117</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD>Math
</DL>
<H2 ID="tell"> tell, _tell, _telli64 </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;io.h&gt;</TT>
<BR><TT>off_t tell( int handle );</TT>
<BR><TT>off_t _tell( int handle );</TT>
<BR><TT>__int64 _telli64( int handle );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> tell</TT> function reports the current file position at the operating system level.&nbsp; The<B> handle</B> value
is the file handle returned by a successful execution of the <TT> open</TT> function.
<BR><BR>The returned value may be used in conjunction with the <TT> lseek</TT> function to reset the current file position.
<BR><BR>The<TT> _tell</TT> function is identical to<TT> tell</TT>.&nbsp; Use<TT> _tell</TT> for ANSI naming conventions.
<BR><BR>The _telli64 function is similar to the<TT> tell</TT> function but returns a 64-bit file position.&nbsp; This value
may be used in conjunction with the <TT> _lseeki64</TT> function to reset the current file position.
</DL>
<DL>
<DT>Returns:
<DD>If an error occurs in<TT> tell</TT> (-1L) is returned.
<BR><BR>If an error occurs in _telli64, (-1I64) is returned.
<BR><BR>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
<BR><BR>Otherwise, the current file position is returned in a system-dependent manner.&nbsp; A value of 0 indicates the start
of the file.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#chsize">chsize</A>, <A HREF="#close">close</A>, <A HREF="#creat">creat</A>, <A HREF="#dup">dup</A>, <A HREF="#dup2">dup2</A>,
<A HREF="#eof">eof</A>, <A HREF="#exec___">exec...</A>, <A HREF="#fdopen">fdopen</A>, <A HREF="#filelength">filelength</A>,
<A HREF="#fileno">fileno</A>, <A HREF="#fstat">fstat</A>, <A HREF="#_grow_handles">_grow_handles</A>, <A HREF="#isatty">isatty</A>,
<A HREF="#lseek">lseek</A>, <A HREF="#open">open</A>, <A HREF="#read">read</A>, <A HREF="#setmode">setmode</A>, <A HREF="#sopen">sopen</A>,
<A HREF="#stat">stat</A>, <A HREF="#write">write</A>, <A HREF="#umask">umask</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;sys/stat.h&gt;</TT>
<BR><TT>#include &lt;io.h&gt;</TT>
<BR><TT>#include &lt;fcntl.h&gt;</TT>
<BR><BR><TT>char buffer[]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = { &quot;A text record to be written&quot; };</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int handle;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int size_written;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; /* open a file for output&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;*/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* replace existing file if it exists */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; handle = open( &quot;file&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; O_WRONLY | O_CREAT | O_TRUNC
| O_TEXT,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S_IRUSR | S_IWUSR | S_IRGRP
| S_IWGRP );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; if( handle != -1 ) {</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* print file position */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%ld\n&quot;, tell( handle ) );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* write the text */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_written = write( handle, buffer,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sizeof( buffer ) );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* print file position */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%ld\n&quot;, tell( handle ) );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* close the file */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close( handle );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>0</TT>
<BR><TT>28</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
<BR><BR>_tell conforms to ANSI naming conventions
</DL>
<DL>
<DT>Systems:
<DD><TT> tell - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_tell - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
<BR><TT>_telli64 - All, Linux</TT>
</DL>
<H2 ID="_tempnam"> _tempnam, _wtempnam </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>char *_tempnam( const char *dir, const char *prefix );</TT>
<BR><TT>wchar_t *_wtempnam( const wchar_t *dir, const wchar_t *prefix );</TT>
</DL>
<DL>
<DT>Description:
<DD><TT> _tempnam</TT> creates a temporary filename for use in another directory.&nbsp; This filename is different from that of
any existing file.&nbsp; The<B> prefix</B> argument is the prefix to the filename.<TT>&nbsp; _tempnam</TT> uses <TT> malloc</TT>
to allocate space for the filename; the program is responsible for freeing this space when it is no longer needed.<TT>&nbsp;
_tempnam</TT> looks for the file with the given name in the following directories, listed in order of precedence.
<DL>
<DT>Directory Used
<DD>Conditions
<DT>Directory specified by TMP
<DD>The <TT> TMP</TT> environment variable must be set and the directory specified by <TT> TMP</TT> must exist.
<DT>dir (function argument)
<DD>The <TT> TMP</TT> environment variable must not be set or the directory specified by <TT> TMP</TT> does not exist.
<DT>_P_tmpdir (_wP_tmpdir) in STDIO.H
<DD>The<B> dir</B> argument is NULL or<B> dir</B> is the name of a nonexistent directory.&nbsp; The <TT> _wP_tmpdir</TT> string
is used by _wtempnam.
<DT>Current working directory
<DD><TT> _tempnam</TT> uses the current working directory when <TT> _P_tmpdir</TT> does not exist.<TT>&nbsp; _wtempnam</TT> uses
the current working directory when <TT> _wP_tmpdir</TT> does not exist.
</DL>
<BR><TT>_tempnam</TT> automatically handles multibyte-character string arguments as appropriate, recognizing multibyte-character
sequences according to the OEM code page obtained from the operating system.
<BR><BR>The<TT> _wtempnam</TT> function is a wide-character version of<TT> _tempnam</TT>.&nbsp; It accepts a wide-character
string argument for<B> format</B> and produces wide character output.&nbsp; The<TT> _wtempnam</TT> function does not handle
multibyte-character strings.
<BR><BR>The function generates unique filenames for up to <TT> TMP_MAX</TT> calls.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _tempnam</TT> function returns a pointer to the name generated, unless it is impossible to create this name or the
name is not unique.&nbsp; If the name cannot be created or if a file with that name already exists,<TT> _tempnam</TT> returns
NULL.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#fopen">fopen</A>, <A HREF="#freopen">freopen</A>, <A HREF="#mkstemp">mkstemp</A>, <A HREF="#_mktemp">_mktemp</A>,
<A HREF="#tmpfile">tmpfile</A>, <A HREF="#tmpnam">tmpnam</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>/*</TT>
<BR><TT>&nbsp; Environment variable TMP=C:\WINDOWS\TEMP</TT>
<BR><TT>*/</TT>
<BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char *filename;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; FILE *fp;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; filename = _tempnam( &quot;D:\\TEMP&quot;, &quot;_T&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( filename == NULL )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Can't obtain temp file name\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Temp file name is %s\n&quot;, filename );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fp = fopen( filename, &quot;w+b&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* . */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* . */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* . */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( fp );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; remove( filename );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; free( filename );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>Temp file name is C:\WINDOWS\TEMP\_T1</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> _tempnam - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</TT>
<BR><BR><TT>_wtempnam - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</TT>
</DL>
<H2 ID="tgamma"> tgamma </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>double tgamma( double x );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> tgamma</TT> function returns the value of the Gamma function of<B> x</B>.
</DL>
<DL>
<DT>Returns:
<DD>If successful, the return value is the value of the Gamma function computed for<B> x</B>.&nbsp; When the argument is not-a-number
or negative infinity, the function returns NAN.&nbsp; If the argument is positive infinity, the function returns positive
infinity.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#lgamma">lgamma</A>, <A HREF="#lgamma_r">lgamma_r</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, tgamma( 4.0 ) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>6.00000</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C99
</DL>
<DL>
<DT>Systems:
<DD>Math
</DL>
<H2 ID="time"> time </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;time.h&gt;</TT>
<BR><TT>time_t time( time_t *tloc );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> time</TT> function determines the current calendar time and encodes it into the type <TT> time_t</TT>.
<BR><BR>The time represents the time since January 1, 1970 Coordinated Universal Time (UTC) (formerly known as Greenwich Mean
Time (GMT)).
<BR><BR>The time set on the computer with the DOS<TT> time</TT> command and the DOS<TT> date</TT> command reflects the local
time.&nbsp; The environment variable<TT> TZ</TT> is used to establish the time zone to which this local time applies.&nbsp;
See the section<B> The TZ Environment Variable</B> for a discussion of how to set the time zone.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> time</TT> function returns the current calendar time.&nbsp; If<B> tloc</B> is not<TT> NULL,</TT> the current calendar
time is also stored in the object pointed to by<B> tloc</B>.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#asctime">asctime</A> Functions, <A HREF="#asctime_s">asctime_s</A>, <A HREF="#clock">clock</A>, <A HREF="#ctime">ctime</A>
Functions, <A HREF="#ctime_s">ctime_s</A>, <A HREF="#difftime">difftime</A>, <A HREF="#gmtime">gmtime</A>, <A HREF="#gmtime_s">gmtime_s</A>,
<A HREF="#localtime">localtime</A>, <A HREF="#localtime_s">localtime_s</A>, <A HREF="#mktime">mktime</A>, <A HREF="#strftime">strftime</A>,
<A HREF="#tzset">tzset</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;time.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; time_t time_of_day;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; time_of_day = time( NULL );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;It is now: %s&quot;, ctime( &amp;time_of_day ) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>It is now: Fri Dec 25 15:58:42 1987</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C, POSIX 1003.1
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="timer_create"> timer_create </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;time.h&gt;</TT>
<BR><TT>int timer_create(clockid_t clockid, struct sigevent *evp, timer_t *timerid);</TT>
<BR><BR><TT>struct sigevent {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sigev_signo;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; union sigval sigev_value;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sigev_notify;</TT>
<BR><TT>};</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> timer_create</TT> function creates a new timer using the clock specified by<B> clockid</B> as supported by the underlying
operating system.&nbsp; The<B> evp</B> argument can be NULL or may specify a handler for when an event of interest occurs.
&nbsp;This implementation currently only supports responding using SIGEV_SIGNAL implementations.&nbsp; The pointer<B> timerid</B>
will contain the unique, per-process timer id if the call is successful.
</DL>
<DL>
<DT>Returns:
<DD>If successful, the function will return zero, and the<B> timerid</B> argument will contain the timer id.&nbsp; If the call
fails, the return value is -1, and <TT> errno</TT> will be set appropriately.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>EINVAL
<DD>The value of<B> timerid</B> is NULL or an invalid<B> clockid</B> is specified
<DT>EAGAIN
<DD>The system was unable to allocate resources for a new timer
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#timer_gettime">timer_gettime</A>, <A HREF="#timer_settime">timer_settime</A>, <A HREF="#timer_delete">timer_delete</A>,
<A HREF="#timer_getoverrun">timer_getoverrun</A>
</DL>
<DL>
<DT>Classification:
<DD>POSIX
</DL>
<DL>
<DT>Systems:
<DD>Linux
</DL>
<H2 ID="timer_delete"> timer_delete </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;time.h&gt;</TT>
<BR><TT>int timer_delete(timer_t timerid );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> timer_delete</TT> function disarms, if necessary, and deletes the timer<B> timerid</B> immediately.
</DL>
<DL>
<DT>Returns:
<DD>If successful, the function will return zero.&nbsp; If the call fails, the return value is -1, and <TT> errno</TT> will be
set appropriately.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>EINVAL
<DD>The value of<B> timerid</B> is NULL or invalid
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#timer_create">timer_create</A>, <A HREF="#timer_settime">timer_settime</A>, <A HREF="#timer_gettime">timer_gettime</A>
</DL>
<DL>
<DT>Classification:
<DD>POSIX
</DL>
<DL>
<DT>Systems:
<DD>Linux
</DL>
<H2 ID="timer_gettime"> timer_gettime </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;time.h&gt;</TT>
<BR><TT>int timer_gettime(timer_t timerid,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct itimerspec
*value );</TT>
<BR><BR><TT>struct timespec {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; time_t tv_sec;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; long tv_nsec;</TT>
<BR><TT>};</TT>
<BR><BR><TT>struct itimerspec {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct timespec it_interval;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct timespec it_value;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; notify_type;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; timer_type;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data;</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> timer_gettime</TT> function retrieves time remaining in the timer<B> timerid</B> until expiration.
</DL>
<DL>
<DT>Returns:
<DD>If successful, the function will return zero.&nbsp; If the call fails, the return value is -1, and <TT> errno</TT> will be
set appropriately.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>EINVAL
<DD>The value of<B> timerid</B> is NULL or invalid
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#timer_create">timer_create</A>, <A HREF="#timer_settime">timer_settime</A>, <A HREF="#timer_delete">timer_delete</A>,
<A HREF="#timer_getoverrun">timer_getoverrun</A>
</DL>
<DL>
<DT>Classification:
<DD>POSIX
</DL>
<DL>
<DT>Systems:
<DD>Linux
</DL>
<H2 ID="timer_settime"> timer_settime </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;time.h&gt;</TT>
<BR><TT>int timer_settime(timer_t timerid, int flags,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct itimerspec
*new_value,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct itimerspec
*old_value );</TT>
<BR><BR><TT>struct timespec {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; time_t tv_sec;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; long tv_nsec;</TT>
<BR><TT>};</TT>
<BR><BR><TT>struct itimerspec {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct timespec it_interval;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct timespec it_value;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; notify_type;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; timer_type;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data;</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> timer_settime</TT> function arms or resets the timer<B> timerid</B> using the interval and value specified in<B> new_value</B>
pointer.&nbsp; The previous interval and value is returned in the<B> oldvalue</B> pointer.
<BR><BR>The structure pointed to by the &quot;it_value&quot; member of<B> new_value</B> specifies the time in the future when
the timer will expire, and effectively arms the timer.&nbsp; If the it_value member of<B> new_value</B> specifies a time of
zero, the timer is disarmed.&nbsp; The structure pointed to by the &quot;it_interval&quot; member of<B> new_value</B> specifies
the interval after the initial timer expiration when the timer would repeat expiration.&nbsp; If the it_interval member's
components are set to zero, the timer will expire at the time specified by the &quot;it_value&quot; member of<B> new_value</B>
and the timer will not automatically rearm.
<BR><BR>The &quot;it_value&quot; member of<B> new_value</B> is regarded, by default, as a time relative to the system clock
at the time of the function call.&nbsp; If flags incorporates the TIMER_ABSTIME constant, the time in &quot;it_value&quot;
is regarded as an absolute system time as opposed to a time relative to calling this function.
</DL>
<DL>
<DT>Returns:
<DD>If successful, the function will return zero.&nbsp; If the call fails, the return value is -1, and <TT> errno</TT> will be
set appropriately.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>EINVAL
<DD>The value of<B> timerid</B> is NULL or invalid
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#timer_create">timer_create</A>, <A HREF="#timer_gettime">timer_gettime</A>, <A HREF="#timer_delete">timer_delete</A>,
<A HREF="#timer_getoverrun">timer_getoverrun</A>
</DL>
<DL>
<DT>Classification:
<DD>POSIX
</DL>
<DL>
<DT>Systems:
<DD>Linux
</DL>
<H2 ID="timer_getoverrun"> timer_getoverrun </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;time.h&gt;</TT>
<BR><TT>int timer_getoverrun( timer_t timerid );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> timer_getoverrun</TT> function returns the number of intervals for the given<B> timerid</B> since expiration.
</DL>
<DL>
<DT>Returns:
<DD>If successful, the function will return the number of elapsed intervals since the latest timer expiration.&nbsp; If the call
fails, the return value is -1, and <TT> errno</TT> will be set appropriately.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>EINVAL
<DD>The value of<B> timerid</B> is NULL or invalid
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#timer_create">timer_create</A>, <A HREF="#timer_settime">timer_settime</A>, <A HREF="#timer_delete">timer_delete</A>
</DL>
<DL>
<DT>Classification:
<DD>POSIX
</DL>
<DL>
<DT>Systems:
<DD>Linux
</DL>
<H2 ID="tmpfile"> tmpfile </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>FILE *tmpfile( void );</TT>
</DL>
<DL>
<DT>Safer C:
<DD>The Safer C Library extension provides the <A HREF="#tmpfile_s">tmpfile_s</A> function which is a safer alternative to<TT>
tmpfile</TT> This newer<TT> tmpfile_s</TT> function is recommended to be used instead of the traditional &quot;unsafe&quot;<TT>
tmpfile</TT> function.
</DL>
<DL>
<DT>Description:
<DD>The<TT> tmpfile</TT> function creates a temporary binary file that will automatically be removed when it is closed or at program
termination.&nbsp; The file is opened for update.&nbsp; For all systems except NetWare, the temporary file is located in the
path specified by one of the following environment variables, if one is defined.&nbsp; Otherwise, the current working directory
is used.&nbsp; They are listed in the order examined:&nbsp; <TT> TMP</TT>, <TT> TEMP</TT>, <TT> TMPDIR</TT>, and <TT> TEMPDIR</TT>.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> tmpfile</TT> function returns a pointer to the stream of the file that it created.&nbsp; If the file cannot be created,
the<TT> tmpfile</TT> function returns<TT> NULL.</TT>&nbsp; When an error has occurred, <TT> errno</TT> contains a value indicating
the type of error that has been detected.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#fopen">fopen</A>, <A HREF="#fopen_s">fopen_s</A>, <A HREF="#freopen">freopen</A>, <A HREF="#freopen_s">freopen_s</A>,
<A HREF="#mkstemp">mkstemp</A>, <A HREF="#_mktemp">_mktemp</A>, <A HREF="#_tempnam">_tempnam</A>, <A HREF="#tmpfile_s">tmpfile_s</A>,
<A HREF="#tmpnam">tmpnam</A>, <A HREF="#tmpnam_s">tmpnam_s</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>static FILE *TempFile;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; TempFile = tmpfile();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* . */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* . */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* . */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fclose( TempFile );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="tmpfile_s"> tmpfile_s </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__ 1</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>errno_t tmpfile_s( FILE * restrict * restrict streamptr);</TT>
</DL>
<DL>
<DT>Constraints:
<DD>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<TT>
tmpfile_s</TT> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<BR><BR><B>streamptr</B> shall not be a null pointer.&nbsp; If there is a runtime-constraint violation,<TT> tmpfile_s</TT>
does not attempt to create a file.
</DL>
<DL>
<DT>Description:
<DD>The<TT> tmpfile_s</TT> function creates a temporary binary file that is different from any other existing file and that will
automatically be removed when it is closed or at program termination.&nbsp; If the program terminates abnormally, whether
an open temporary file is removed is implementation-defined.&nbsp; The file is opened for update with &quot;wb+&quot; mode
with the meaning that mode has in the fopen_s function (including the mode's effect on exclusive access and file permissions).
&nbsp;If the file was created successfully, then the pointer to FILE pointed to by<B> streamptr</B> will be set to the pointer
to the object controlling the opened file.&nbsp; Otherwise, the pointer to FILE pointed to by<B> streamptr</B> will be set
to a null pointer.&nbsp; For all systems except NetWare, the temporary file is located in the path specified by one of the
following environment variables, if one is defined.&nbsp; Otherwise, the current working directory is used.&nbsp; They are
listed in the order examined:&nbsp; <TT> TMP</TT>, <TT> TEMP</TT>, <TT> TMPDIR</TT>, and <TT> TEMPDIR</TT>.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> tmpfile_s</TT> function returns zero if there was no runtime-constraint violation.&nbsp; Otherwise, a non-zero value
is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#fopen">fopen</A>, <A HREF="#fopen_s">fopen_s</A>, <A HREF="#freopen">freopen</A>, <A HREF="#freopen_s">freopen_s</A>,
<A HREF="#mkstemp">mkstemp</A>, <A HREF="#_mktemp">_mktemp</A>, <A HREF="#_tempnam">_tempnam</A>, <A HREF="#tmpfile">tmpfile</A>,
<A HREF="#tmpnam">tmpnam</A>, <A HREF="#tmpnam_s">tmpnam_s</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__ 1</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; errno_t rc;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FILE&nbsp;&nbsp;&nbsp; *TempFile;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; rc = tmpfile_s( &amp;TempFile );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( rc == 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* . */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* . */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* . */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( TempFile );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>TR 24731
</DL>
<DL>
<DT>Systems:
<DD>All, RDOS, Netware
</DL>
<H2 ID="tmpnam_s"> tmpnam_s, _wtmpnam_s </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__ 1</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>errno_t tmpnam_s( char * s, rsize_t maxsize );</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>errno_t _wtmpnam_s( wchar_t * s, rsize_t maxsize );</TT>
</DL>
<DL>
<DT>Constraints:
<DD>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<TT>
tmpnam_s</TT> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<BR><BR><B>s</B> shall not be a null pointer.<B>&nbsp; maxsize</B> shall be less than or equal to <TT> RSIZE_MAX</TT>.<B>
&nbsp;maxsize</B> shall be greater than the length of the generated file name string.
</DL>
<DL>
<DT>Description:
<DD>The<TT> tmpnam_s</TT> function generates a string that is a valid file name and that is not the same as the name of an existing
file.&nbsp; The function is potentially capable of generating <TT> TMP_MAX_S</TT> different strings, but any or all of them
may already be in use by existing files and thus not be suitable return values.&nbsp; The lengths of these strings shall be
less than the value of the <TT> L_tmpnam_s</TT> macro.&nbsp; The<TT> tmpnam_s</TT> function generates a different string each
time it is called.
<BR><BR>The<TT> _wtmpnam_s</TT> function is a wide-character version of<TT> tmpnam_s</TT>.&nbsp; It accepts a wide-character
string argument for<B> format</B> and produces wide character output.
</DL>
<DL>
<DT>Returns:
<DD>If no suitable string can be generated, or if there is a runtime-constraint violation, the<TT> tmpnam_s</TT> function writes
a null character to<B> s[0]</B> (only if<B> s</B> is not null and<B> maxsize</B> is greater than zero) and returns a non-zero
value.&nbsp; Otherwise, the<TT> tmpnam_s</TT> function writes the string in the array pointed to by<B> s</B> and returns zero.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#fopen">fopen</A>, <A HREF="#fopen_s">fopen_s</A>, <A HREF="#freopen">freopen</A>, <A HREF="#freopen_s">freopen_s</A>,
<A HREF="#mkstemp">mkstemp</A>, <A HREF="#_mktemp">_mktemp</A>, <A HREF="#_tempnam">_tempnam</A>, <A HREF="#tmpfile">tmpfile</A>,
<A HREF="#tmpfile_s">tmpfile_s</A>, <A HREF="#tmpnam">tmpnam</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__ 1</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; filename[ L_tmpnam_s ];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FILE&nbsp;&nbsp;&nbsp; *fp;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; errno_t rc;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; rc = tmpnam( filename, sizeof( filename ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( rc == 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fp = fopen( filename, &quot;w+b&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* . */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* . */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* . */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( fp );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; remove( filename );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>TR 24731
<BR><BR>_wtmpnam_s is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> tmpnam_s - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_wtmpnam_s - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</TT>
</DL>
<H2 ID="tmpnam"> tmpnam, _wtmpnam </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>char *tmpnam( char *buffer );</TT>
<BR><TT>wchar_t *_wtmpnam( wchar_t *buffer );</TT>
</DL>
<DL>
<DT>Safer C:
<DD>The Safer C Library extension provides the <A HREF="#tmpnam_s">tmpnam_s</A> function which is a safer alternative to<TT> tmpnam</TT>
This newer<TT> tmpnam_s</TT> function is recommended to be used instead of the traditional &quot;unsafe&quot;<TT> tmpnam</TT>
function.
</DL>
<DL>
<DT>Description:
<DD>The<TT> tmpnam</TT> function generates a unique string for use as a valid file name.
<BR><BR>The<TT> _wtmpnam</TT> function is a wide-character version of<TT> tmpnam</TT>.&nbsp; It accepts a wide-character string
argument for<B> format</B> and produces wide character output.&nbsp; An internal static buffer is used to construct the filename.
&nbsp;Subsequent calls to<TT> tmpnam</TT> reuse the internal buffer.
<BR><BR>The function generates unique filenames for up to <TT> TMP_MAX</TT> calls.
</DL>
<DL>
<DT>Returns:
<DD>If the argument<B> buffer</B> is a NULL pointer,<TT> tmpnam</TT> returns a pointer to an internal buffer containing the temporary
file name.&nbsp; If the argument<B> buffer</B> is not a NULL pointer,<TT> tmpnam</TT> copies the temporary file name from
the internal buffer to the specified buffer and returns a pointer to the specified buffer.&nbsp; It is assumed that the specified
buffer is an array of at least <TT> L_tmpnam</TT> characters.
<BR><BR>If the argument<B> buffer</B> is a NULL pointer, you may wish to duplicate the resulting string since subsequent calls
to<TT> tmpnam</TT> reuse the internal buffer.&nbsp; 
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char *name1, *name2;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; name1 = strdup( tmpnam( NULL ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; name2 = strdup( tmpnam( NULL ) );</TT>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#fopen">fopen</A>, <A HREF="#fopen_s">fopen_s</A>, <A HREF="#freopen">freopen</A>, <A HREF="#freopen_s">freopen_s</A>,
<A HREF="#mkstemp">mkstemp</A>, <A HREF="#_mktemp">_mktemp</A>, <A HREF="#_tempnam">_tempnam</A>, <A HREF="#tmpfile">tmpfile</A>,
<A HREF="#tmpfile_s">tmpfile_s</A>, <A HREF="#tmpnam_s">tmpnam_s</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char filename[ L_tmpnam ];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FILE *fp;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; tmpnam( filename );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fp = fopen( filename, &quot;w+b&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* . */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* . */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* . */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fclose( fp );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; remove( filename );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>_wtmpnam is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> tmpnam - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_wtmpnam - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</TT>
</DL>
<H2 ID="tolower"> tolower, _tolower, towlower </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;ctype.h&gt;</TT>
<BR><TT>int tolower( int c );</TT>
<BR><TT>int _tolower( int c );</TT>
<BR><TT>#include &lt;wctype.h&gt;</TT>
<BR><TT>wint_t towlower( wint_t c );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> tolower</TT> function converts<B> c</B> to a lowercase letter if<B> c</B> represents an uppercase letter.
<BR><BR>The<TT> _tolower</TT> function is a version of<TT> tolower</TT> to be used only when<B> c</B> is known to be uppercase.
<BR><BR>The<TT> towlower</TT> function is a wide-character version of<TT> tolower</TT> that operates with wide-character strings.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> tolower</TT> function returns the corresponding lowercase letter when the argument is an uppercase letter; otherwise,
the original character is returned.&nbsp; The<TT> towlower</TT> function returns the corresponding wide-character lowercase
letter when the argument is a wide-character uppercase letter; otherwise, the original wide character is returned.
<BR><BR>The result of<TT> _tolower</TT> is undefined if<B> c</B> is not an uppercase letter.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#isalnum">isalnum</A>, <A HREF="#isalpha">isalpha</A>, <A HREF="#isblank">isblank</A>, <A HREF="#iscntrl">iscntrl</A>,
<A HREF="#isdigit">isdigit</A>, <A HREF="#isgraph">isgraph</A>, <A HREF="#isleadbyte">isleadbyte</A>, <A HREF="#islower">islower</A>,
<A HREF="#isprint">isprint</A>, <A HREF="#ispunct">ispunct</A>, <A HREF="#isspace">isspace</A>, <A HREF="#isupper">isupper</A>,
<A HREF="#iswctype">iswctype</A>, <A HREF="#isxdigit">isxdigit</A>, <A HREF="#toupper">toupper</A>, <A HREF="#towctrans">towctrans</A>,
<A HREF="#strlwr">strlwr</A>, <A HREF="#strupr">strupr</A>, <A HREF="#toupper">toupper</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;ctype.h&gt;</TT>
<BR><BR><TT>char chars[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'A',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '5',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '$',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'Z'</TT>
<BR><TT>};</TT>
<BR><BR><TT>#define SIZE sizeof( chars ) / sizeof( char )</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%c &quot;, tolower( chars[ i ] ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;\n&quot; );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>a 5 $ z</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>_tolower is WATCOM
<BR>towlower is ISO C95
</DL>
<DL>
<DT>Systems:
<DD><TT> tolower - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_tolower - All, Linux, RDOS, Netware</TT>
<BR><TT>towlower - All, Linux, RDOS, Netware</TT>
</DL>
<H2 ID="toupper"> toupper, _toupper, towupper </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;ctype.h&gt;</TT>
<BR><TT>int toupper( int c );</TT>
<BR><TT>int _toupper( int c );</TT>
<BR><TT>#include &lt;wctype.h&gt;</TT>
<BR><TT>wint_t towupper( wint_t c );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> toupper</TT> function converts<B> c</B> to a uppercase letter if<B> c</B> represents a lowercase letter.
<BR><BR>The<TT> _toupper</TT> function is a version of<TT> toupper</TT> to be used only when<B> c</B> is known to be lowercase.
<BR><BR>The<TT> towupper</TT> function is a wide-character version of<TT> toupper</TT> that operates with wide-character strings.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> toupper</TT> function returns the corresponding uppercase letter when the argument is a lowercase letter; otherwise,
the original character is returned.&nbsp; The<TT> towupper</TT> function returns the corresponding wide-character uppercase
letter when the argument is a wide-character lowercase letter; otherwise, the original wide character is returned.
<BR><BR>The result of<TT> _toupper</TT> is undefined if<B> c</B> is not a lowercase letter.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#isalnum">isalnum</A>, <A HREF="#isalpha">isalpha</A>, <A HREF="#isblank">isblank</A>, <A HREF="#iscntrl">iscntrl</A>,
<A HREF="#isdigit">isdigit</A>, <A HREF="#isgraph">isgraph</A>, <A HREF="#isleadbyte">isleadbyte</A>, <A HREF="#islower">islower</A>,
<A HREF="#isprint">isprint</A>, <A HREF="#ispunct">ispunct</A>, <A HREF="#isspace">isspace</A>, <A HREF="#isupper">isupper</A>,
<A HREF="#iswctype">iswctype</A>, <A HREF="#isxdigit">isxdigit</A>, <A HREF="#tolower">tolower</A>, <A HREF="#towctrans">towctrans</A>,
<A HREF="#strlwr">strlwr</A>, <A HREF="#strupr">strupr</A>, <A HREF="#tolower">tolower</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;ctype.h&gt;</TT>
<BR><BR><TT>char chars[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'a',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '5',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; '$',</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 'z'</TT>
<BR><TT>};</TT>
<BR><BR><TT>#define SIZE sizeof( chars ) / sizeof( char )</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%c &quot;, toupper( chars[ i ] ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;\n&quot; );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>A 5 $ Z</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>_toupper is WATCOM
<BR>towupper is ISO C95
</DL>
<DL>
<DT>Systems:
<DD><TT> toupper - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_toupper - All, Linux, RDOS, Netware</TT>
<BR><TT>towupper - All, Linux, RDOS, Netware</TT>
</DL>
<H2 ID="towctrans"> towctrans </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wctype.h&gt;</TT>
<BR><TT>wint_t towctrans( wint_t wc, wctrans_t desc );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> towctrans</TT> function maps the wide character<B> wc</B> using the mapping described by<B> desc</B>.&nbsp; Valid
values of<B> desc</B> are defined by the use of the <TT> wctrans</TT> function.
<BR><BR>The two expressions listed below behave the same as a call to the wide character case mapping function shown.
<DL>
<DT>Expression&nbsp;&nbsp;&nbsp;&nbsp; Equivalent
<DT>towctrans(wc, wctrans(&quot;tolower&quot;))
<DD>towlower(wc)
<DT>towctrans(wc, wctrans(&quot;toupper&quot;))
<DD>towupper(wc)
</DL>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> towctrans</TT> function returns the mapped value of<B> wc</B> using the mapping described by<B> desc</B>.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#isalnum">isalnum</A>, <A HREF="#isalpha">isalpha</A>, <A HREF="#isblank">isblank</A>, <A HREF="#iscntrl">iscntrl</A>,
<A HREF="#isdigit">isdigit</A>, <A HREF="#isgraph">isgraph</A>, <A HREF="#isleadbyte">isleadbyte</A>, <A HREF="#islower">islower</A>,
<A HREF="#isprint">isprint</A>, <A HREF="#ispunct">ispunct</A>, <A HREF="#isspace">isspace</A>, <A HREF="#isupper">isupper</A>,
<A HREF="#iswctype">iswctype</A>, <A HREF="#isxdigit">isxdigit</A>, <A HREF="#tolower">tolower</A>, <A HREF="#toupper">toupper</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;wctype.h&gt;</TT>
<BR><BR><TT>char *translations[2] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; &quot;tolower&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; &quot;toupper&quot;</TT>
<BR><TT>};</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; i;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; wint_t&nbsp; wc = 'A';</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; wint_t&nbsp; twc;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; 2; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; twc = towctrans( wc, wctrans( translations[i] ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%s(%lc): %lc\n&quot;, translations[i], wc, twc );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>tolower(A): a</TT>
<BR><TT>toupper(A): A</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C95
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="trunc"> trunc </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><TT>double trunc( double x );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> trunc</TT> function truncates the argument<B> x</B> to the appropriate integer.&nbsp; The function is equivalent to
<TT> floor</TT> for positive numbers and <TT> ceil</TT> for negative numbers.
</DL>
<DL>
<DT>Returns:
<DD>The value of<B> x</B> without any fractional values.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#nearbyint">nearbyint</A>, <A HREF="#rint">rint</A>, <A HREF="#round">round</A>, <A HREF="#floor">floor</A>, <A HREF="#ceil">ceil</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;math.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, round( 1.5 ) );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>1.000000</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C99
</DL>
<DL>
<DT>Systems:
<DD>Math
</DL>
<H2 ID="ttyname"> ttyname, ttyname_r </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;unistd.h&gt;</TT>
<BR><TT>char *ttyname( int fd );</TT>
<BR><TT>int ttyname_r( int fd, char *buf, size_t buflen );</TT>
</DL>
<DL>
<DT>Description:
<DD>The POSIX-compliant<TT> ttyname</TT> function retrieves the name of a TTY as specified by the<B> fd</B> file descriptor, returning
a static pointer to the name.&nbsp; Subsequent calls may change the contents of the string pointed to by the original call
to<TT> ttyname</TT> , and the memory to which the return value points should not be freed.
<BR><BR>The <TT> ttyname_r</TT> function performs the same function as<TT> ttyname</TT> , but the name of the TTY is returned
in the<B> buf</B> argument.&nbsp; The argument<B> buflen</B> should specify the size of the<B> buf</B> argument.&nbsp; The
<TT> ttyname_r</TT> function is an Open Watcom extension commonly implemented in other standard libraries.
</DL>
<DL>
<DT>Returns:
<DD>Upon success, the<TT> ttyname</TT> function returns a pointer to statically allocated memory containing the name of the TTY.
&nbsp;Upon failure, the returned pointer will be <TT> NULL</TT> and <TT> errno</TT> will be set appropriately.
<BR><BR>Upon success, the <TT> ttyname_r</TT> function will return zero, and the<B> buf</B> argument will contain the name
of the TTY.&nbsp; Upon failure, the <TT> ttyname_r</TT> function will return the error code and set <TT> errno</TT> as well.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>ENOTTY
<DD>The value of<B> fd</B> does not refer to a TTY
<DT>EACCES
<DD>The user does not have permission to query the file descriptor
<DT>EBADFD
<DD>The file descriptor<B> fd</B> is invalid
<DT>ERANGE
<DD>The<B> buf</B> is not large enough to hold the result, or the file descriptor name exceeds <TT> POSIX_PATH_MAX</TT>
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#isatty">isatty</A>
</DL>
<DL>
<DT>Classification:
<DD>POSIX 1003.1
</DL>
<DL>
<DT>Systems:
<DD><TT> ttyname - Linux</TT>
<BR><BR><TT>ttyname_r - Linux</TT>
</DL>
<H2 ID="tzset"> tzset </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;time.h&gt;</TT>
<BR><TT>void tzset( void );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> tzset</TT> function sets the global variables <TT> daylight</TT>, <TT> timezone</TT> and <TT> tzname</TT> according
to the value of the <TT> TZ</TT> environment variable.&nbsp; The section<B> The TZ Environment Variable</B> describes how
to set this variable.
<BR><BR>Under Win32,<TT> tzset</TT> also uses operating system supplied time zone information.&nbsp; The <TT> TZ</TT> environment
variable can be used to override this information.
<BR><BR>The global variables have the following values after<TT> tzset</TT> is executed:
<DL>
<DT>daylight
<DD>Zero indicates that daylight saving time is not supported in the locale; a non-zero value indicates that daylight saving time
is supported in the locale.&nbsp; This variable is cleared/set after a call to the<TT> tzset</TT> function depending on whether
a daylight saving time abbreviation is specified in the <TT> TZ</TT> environment variable.
<DT>timezone
<DD>Contains the number of seconds that the local time zone is earlier than Coordinated Universal Time (UTC) (formerly known as
Greenwich Mean Time (GMT)).
<DT>tzname
<DD>Two-element array pointing to strings giving the abbreviations for the name of the time zone when standard and daylight saving
time are in effect.
</DL>
<BR>The time set on the computer with the DOS<TT> time</TT> command and the DOS<TT> date</TT> command reflects the local time.
&nbsp;The environment variable<TT> TZ</TT> is used to establish the time zone to which this local time applies.&nbsp; See
the section<B> The TZ Environment Variable</B> for a discussion of how to set the time zone.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> tzset</TT> function does not return a value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#ctime">ctime</A> Functions, <A HREF="#localtime">localtime</A>, <A HREF="#mktime">mktime</A>, <A HREF="#strftime">strftime</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;env.h&gt;</TT>
<BR><TT>#include &lt;time.h&gt;</TT>
<BR><BR><TT>void print_zone()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char *tz;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;TZ: %s\n&quot;, (tz = getenv( &quot;TZ&quot; ))</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
? tz : &quot;default EST5EDT&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;&nbsp; daylight: %d\n&quot;, daylight );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;&nbsp; timezone: %ld\n&quot;, timezone );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;&nbsp; time zone names: %s %s\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tzname[0], tzname[1] );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; print_zone();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; setenv( &quot;TZ&quot;, &quot;PST8PDT&quot;, 1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; tzset();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; print_zone();</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>TZ: default EST5EDT</TT>
<BR><TT>&nbsp; daylight: 1</TT>
<BR><TT>&nbsp; timezone: 18000</TT>
<BR><TT>&nbsp; time zone names: EST EDT</TT>
<BR><TT>TZ: PST8PDT</TT>
<BR><TT>&nbsp; daylight: 1</TT>
<BR><TT>&nbsp; timezone: 28800</TT>
<BR><TT>&nbsp; time zone names: PST PDT</TT>
</DL>
<DL>
<DT>Classification:
<DD>POSIX 1003.1
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="ulltoa"> ulltoa, _ulltoa, _ulltow </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>char *ulltoa( unsigned long long int value,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *buffer,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int radix );</TT>
<BR><TT>char *_ulltoa( unsigned long long int value,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *buffer,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int radix );</TT>
<BR><TT>wchar_t *_ulltow( unsigned long long int value,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t *buffer,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int radix );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> ulltoa</TT> function converts the unsigned binary integer<B> value</B> into the equivalent string in base<B> radix</B>
notation storing the result in the character array pointed to by<B> buffer</B>.&nbsp; A null character is appended to the
result.&nbsp; The size of<B> buffer</B> must be at least 65 bytes when converting values in base 2.&nbsp; The value of<B>
radix</B> must satisfy the condition:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 2 &lt;= radix &lt;= 36</TT>
<BR><BR>The<TT> _ulltoa</TT> function is identical to<TT> ulltoa</TT>.&nbsp; Use<TT> _ulltoa</TT> for ANSI naming conventions.
<BR><BR>The<TT> _ulltow</TT> function is a wide-character version of<TT> ulltoa</TT>.&nbsp; It produces a wide-character string.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> ulltoa</TT> function returns the pointer to the result.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#atoi">atoi</A>, <A HREF="#atol">atol</A>, <A HREF="#atoll">atoll</A>, <A HREF="#itoa">itoa</A>, <A HREF="#ltoa">ltoa</A>,
<A HREF="#lltoa">lltoa</A>, <A HREF="#sscanf">sscanf</A>, <A HREF="#strtol">strtol</A>, <A HREF="#strtoll">strtoll</A>, <A HREF="#strtoul">strtoul</A>,
<A HREF="#strtoull">strtoull</A>, <A HREF="#strtoimax">strtoimax</A>, <A HREF="#strtoumax">strtoumax</A>, <A HREF="#ultoa">ultoa</A>,
<A HREF="#utoa">utoa</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>void print_value( unsigned long long int value )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int base;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char buffer[65];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; for( base = 2; base &lt;= 16; base = base + 2 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%2d %s\n&quot;, base,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ultoa( value, buffer, base
) );</TT>
<BR><TT>}</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; print_value( (unsigned long long) 1234098765LL );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT> 2 1001001100011101101101001001101</TT>
<BR><TT> 4 1021203231221031</TT>
<BR><TT> 6 322243004113</TT>
<BR><TT> 8 11143555115</TT>
<BR><TT>10 1234098765</TT>
<BR><TT>12 2a5369639</TT>
<BR><TT>14 b9c8863b</TT>
<BR><TT>16 498eda4d</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
<BR><BR>_ulltoa conforms to ANSI naming conventions
</DL>
<DL>
<DT>Systems:
<DD><TT> ulltoa - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_ulltoa - All, Linux, RDOS, Netware</TT>
<BR><TT>_ulltow - All, Linux, RDOS</TT>
</DL>
<H2 ID="ultoa"> ultoa, _ultoa, _ultow </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>char *ultoa( unsigned long int value,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *buffer,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int radix );</TT>
<BR><TT>char *_ultoa( unsigned long int value,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *buffer,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int radix );</TT>
<BR><TT>wchar_t *_ultow( unsigned long int value,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t *buffer,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int radix );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> ultoa</TT> function converts the unsigned binary integer<B> value</B> into the equivalent string in base<B> radix</B>
notation storing the result in the character array pointed to by<B> buffer</B>.&nbsp; A null character is appended to the
result.&nbsp; The size of<B> buffer</B> must be at least 33 bytes when converting values in base 2.&nbsp; The value of<B>
radix</B> must satisfy the condition:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 2 &lt;= radix &lt;= 36</TT>
<BR><BR>The<TT> _ultoa</TT> function is identical to<TT> ultoa</TT>.&nbsp; Use<TT> _ultoa</TT> for ANSI naming conventions.
<BR><BR>The<TT> _ultow</TT> function is a wide-character version of<TT> ultoa</TT>.&nbsp; It produces a wide-character string.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> ultoa</TT> function returns the pointer to the result.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#atoi">atoi</A>, <A HREF="#atol">atol</A>, <A HREF="#atoll">atoll</A>, <A HREF="#itoa">itoa</A>, <A HREF="#ltoa">ltoa</A>,
<A HREF="#lltoa">lltoa</A>, <A HREF="#sscanf">sscanf</A>, <A HREF="#strtol">strtol</A>, <A HREF="#strtoll">strtoll</A>, <A HREF="#strtoul">strtoul</A>,
<A HREF="#strtoull">strtoull</A>, <A HREF="#strtoimax">strtoimax</A>, <A HREF="#strtoumax">strtoumax</A>, <A HREF="#ulltoa">ulltoa</A>,
<A HREF="#utoa">utoa</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>void print_value( unsigned long int value )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int base;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char buffer[33];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; for( base = 2; base &lt;= 16; base = base + 2 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%2d %s\n&quot;, base,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ultoa( value, buffer, base
) );</TT>
<BR><TT>}</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; print_value( (unsigned) 12765L );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT> 2 11000111011101</TT>
<BR><TT> 4 3013131</TT>
<BR><TT> 6 135033</TT>
<BR><TT> 8 30735</TT>
<BR><TT>10 12765</TT>
<BR><TT>12 7479</TT>
<BR><TT>14 491b</TT>
<BR><TT>16 31dd</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
<BR><BR>_ultoa conforms to ANSI naming conventions
</DL>
<DL>
<DT>Systems:
<DD><TT> ultoa - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_ultoa - All, Linux, RDOS, Netware</TT>
<BR><TT>_ultow - All, Linux, RDOS</TT>
</DL>
<H2 ID="umask"> umask, _umask </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;sys/types.h&gt;</TT>
<BR><TT>#include &lt;sys/stat.h&gt;</TT>
<BR><TT>#include &lt;fcntl.h&gt;</TT>
<BR><TT>#include &lt;io.h&gt;</TT>
<BR><TT>mode_t umask( mode_t cmask );</TT>
<BR><TT>mode_t _umask( mode_t cmask );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> umask</TT> function sets the process's file mode creation mask to<B> cmask</B>.&nbsp; The process's file mode creation
mask is used during <TT> creat</TT>, <TT> open</TT> or <TT> sopen</TT> to turn off permission bits in the<B> permission</B>
argument supplied.&nbsp; In other words, if a bit in the mask is on, then the corresponding bit in the file's requested permission
value is disallowed.
<BR><BR>The<TT> _umask</TT> function is identical to<TT> umask</TT>.&nbsp; Use<TT> _umask</TT> for ANSI naming conventions.
<BR><BR>The argument<B> cmask</B> is a constant expression involving the constants described below.&nbsp; The access permissions
for the file or directory are specified as a combination of bits (defined in the<TT> &lt;sys/stat.h&gt;</TT> header file).
<BR><BR>The following bits define permissions for the owner.
<DL>
<DT>Permission&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>S_IRWXU
<DD>Read, write, execute/search
<DT>S_IRUSR
<DD>Read permission
<DT>S_IWUSR
<DD>Write permission
<DT>S_IXUSR
<DD>Execute/search permission
</DL>
<BR>The following bits define permissions for the group.
<DL>
<DT>Permission&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>S_IRWXG
<DD>Read, write, execute/search
<DT>S_IRGRP
<DD>Read permission
<DT>S_IWGRP
<DD>Write permission
<DT>S_IXGRP
<DD>Execute/search permission
</DL>
<BR>The following bits define permissions for others.
<DL>
<DT>Permission&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>S_IRWXO
<DD>Read, write, execute/search
<DT>S_IROTH
<DD>Read permission
<DT>S_IWOTH
<DD>Write permission
<DT>S_IXOTH
<DD>Execute/search permission
</DL>
<BR>The following bits define miscellaneous permissions used by other implementations.
<DL>
<DT>Permission&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>S_IREAD
<DD>is equivalent to S_IRUSR (read permission)
<DT>S_IWRITE
<DD>is equivalent to S_IWUSR (write permission)
<DT>S_IEXEC
<DD>is equivalent to S_IXUSR (execute/search permission)
</DL>
<BR>For example, if <TT> S_IRUSR</TT> is specified, then reading is not allowed (i.e., the file is write only).&nbsp; If <TT>
S_IWUSR</TT> is specified, then writing is not allowed (i.e., the file is read only).
</DL>
<DL>
<DT>Returns:
<DD>The<TT> umask</TT> function returns the previous value of<B> cmask</B>.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#chmod">chmod</A>, <A HREF="#creat">creat</A>, <A HREF="#mkdir">mkdir</A>, <A HREF="#open">open</A>, <A HREF="#sopen">sopen</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;sys/types.h&gt;</TT>
<BR><TT>#include &lt;sys/stat.h&gt;</TT>
<BR><TT>#include &lt;fcntl.h&gt;</TT>
<BR><TT>#include &lt;io.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; mode_t old_mask;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; /* set mask to create read-only files */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; old_mask = umask( S_IWUSR | S_IWGRP | S_IWOTH |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; S_IXUSR | S_IXGRP | S_IXOTH );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>POSIX 1003.1
<BR><BR>_umask conforms to ANSI naming conventions
</DL>
<DL>
<DT>Systems:
<DD><TT> umask - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_umask - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="ungetc"> ungetc, ungetwc </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>int ungetc( int c, FILE *fp );</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>wint_t ungetwc( wint_t c, FILE *fp );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> ungetc</TT> function pushes the character specified by<B> c</B> back onto the input stream pointed to by<B> fp</B>.
&nbsp;This character will be returned by the next read on the stream.&nbsp; The pushed-back character will be discarded if
a call is made to the <TT> fflush</TT> function or to a file positioning function (<TT> fseek</TT>, <TT> fsetpos</TT> or <TT>
rewind</TT>) before the next read operation is performed.
<BR><BR>Only one character (the most recent one) of pushback is remembered.
<BR><BR>The<TT> ungetc</TT> function clears the end-of-file indicator, unless the value of<B> c</B> is <TT> EOF</TT>.
<BR><BR>The<TT> ungetwc</TT> function is identical to<TT> ungetc</TT> except that it pushes the wide character specified by<B>
c</B> back onto the input stream pointed to by<B> fp</B>.
<BR><BR>The<TT> ungetwc</TT> function clears the end-of-file indicator, unless the value of<B> c</B> is <TT> WEOF</TT>.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> ungetc</TT> function returns the character pushed back.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#fgetc">fgetc</A>, <A HREF="#fgetchar">fgetchar</A>, <A HREF="#fgets">fgets</A>, <A HREF="#fopen">fopen</A>, <A HREF="#getc">getc</A>,
<A HREF="#getchar">getchar</A>, <A HREF="#gets">gets</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;ctype.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; FILE *fp;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int c;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; long value;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; fp = fopen( &quot;file&quot;, &quot;r&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; value = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; c = fgetc( fp );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; while( isdigit(c) ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value = value*10 + c - '0';</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c = fgetc( fp );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ungetc( c, fp ); /* put last character back */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Value=%ld\n&quot;, value );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; fclose( fp );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD><TT> ungetc - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>ungetwc - All, Linux</TT>
</DL>
<H2 ID="ungetch"> ungetch </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>int ungetch( int c );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> ungetch</TT> function pushes the character specified by<B> c</B> back onto the input stream for the console.&nbsp;
This character will be returned by the next read from the console (with <TT> getch</TT> or <TT> getche</TT> functions) and
will be detected by the function <TT> kbhit</TT>.&nbsp; Only the last character returned in this way is remembered.
<BR><BR>The<TT> ungetch</TT> function clears the end-of-file indicator, unless the value of<B> c</B> is <TT> EOF</TT>.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> ungetch</TT> function returns the character pushed back.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#getch">getch</A>, <A HREF="#getche">getche</A>, <A HREF="#kbhit">kbhit</A>, <A HREF="#putch">putch</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;ctype.h&gt;</TT>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int c;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; long value;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; value = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; c = getche();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; while( isdigit( c ) ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value = value*10 + c - '0';</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c = getche();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; ungetch( c );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Value=%ld\n&quot;, value );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="unlink"> unlink, _unlink, _wunlink </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;io.h&gt;</TT>
<BR><TT>int unlink( const char *path );</TT>
<BR><TT>int _unlink( const char *path );</TT>
<BR><TT>int _wunlink( const wchar_t *path );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> unlink</TT> function deletes the file whose name is the string pointed to by<B> path</B>.&nbsp; This function is equivalent
to the <TT> remove</TT> function.
<BR><BR>The<TT> _unlink</TT> function is identical to<TT> unlink</TT>.&nbsp; Use<TT> _unlink</TT> for ANSI naming conventions.
<BR><BR>The<TT> _wunlink</TT> function is a wide-character version of<TT> unlink</TT> that operates with wide-character strings.
</DL>
<DL>
<DT>Returns:
<DD>The unlink function returns zero if the operation succeeds, non-zero if it fails.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#chdir">chdir</A>, <A HREF="#chmod">chmod</A>, <A HREF="#close">close</A>, <A HREF="#getcwd">getcwd</A>, <A HREF="#mkdir">mkdir</A>,
<A HREF="#open">open</A>, <A HREF="#remove">remove</A>, <A HREF="#rename">rename</A>, <A HREF="#rmdir">rmdir</A>, <A HREF="#stat">stat</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;io.h&gt;</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; unlink( &quot;vm.tmp&quot; );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>POSIX 1003.1
<BR><BR>_unlink conforms to ANSI naming conventions
<BR>_wunlink is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> unlink - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_unlink - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
<BR><TT>_wunlink - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</TT>
</DL>
<H2 ID="unlock"> unlock </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;io.h&gt;</TT>
<BR><TT>int unlock( int handle,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long offset,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long nbytes );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> unlock</TT> function unlocks<B> nbytes</B> amount of previously locked data in the file designated by<B> handle</B>
starting at byte<B> offset</B> in the file.&nbsp; This allows other processes to lock this region of the file.
<BR><BR>Multiple regions of a file can be locked, but no overlapping regions are allowed.&nbsp; You cannot unlock multiple
regions in the same call, even if the regions are contiguous.&nbsp; All locked regions of a file should be unlocked before
closing a file or exiting the program.
<BR><BR>With DOS, locking is supported by version 3.0 or later.&nbsp; Note that<TT> SHARE.COM</TT> or<TT> SHARE.EXE</TT> must
be installed.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> unlock</TT> function returns zero if successful, and -1 when an error occurs.&nbsp; When an error has occurred, <TT>
errno</TT> contains a value indicating the type of error that has been detected.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#lock">lock</A>, <A HREF="#locking">locking</A>, <A HREF="#open">open</A>, <A HREF="#sopen">sopen</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;fcntl.h&gt;</TT>
<BR><TT>#include &lt;io.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int handle;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char buffer[20];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; handle = open( &quot;file&quot;, O_RDWR | O_TEXT );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( handle != -1 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( lock( handle, 0L, 20L ) ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Lock failed\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; read( handle, buffer, 20 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* update the buffer here */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lseek( handle, 0L, SEEK_SET );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write( handle, buffer, 20 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unlock( handle, 0L, 20L );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close( handle );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>All, RDOS, Netware
</DL>
<H2 ID="_unregisterfonts"> _unregisterfonts </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>void _FAR _unregisterfonts( void );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _unregisterfonts</TT> function frees the memory previously allocated by the <TT> _registerfonts</TT> function.&nbsp;
The currently selected font is also unloaded.
<BR><BR>Attempting to use the <TT> _setfont</TT> function after calling<TT> _unregisterfonts</TT> will result in an error.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _unregisterfonts</TT> function does not return a value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_registerfonts">_registerfonts</A>, <A HREF="#_setfont">_setfont</A>, <A HREF="#_getfontinfo">_getfontinfo</A>,
<A HREF="#_outgtext">_outgtext</A>, <A HREF="#_getgtextextent">_getgtextextent</A>, <A HREF="#_setgtextvector">_setgtextvector</A>,
<A HREF="#_getgtextvector">_getgtextvector</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int i, n;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char buf[ 10 ];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; n = _registerfonts( &quot;*.fon&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; n; ++i ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf( buf, &quot;n%d&quot;, i );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _setfont( buf );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _moveto( 100, 100 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _outgtext( &quot;WATCOM Graphics&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _clearscreen( _GCLEARSCREEN );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _unregisterfonts();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="utime"> utime, _utime, _wutime </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;sys/utime.h&gt;</TT>
<BR><TT>int utime( const char *path,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct utimbuf *times );</TT>
<BR><TT>int _utime( const char *path,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct utimbuf *times );</TT>
<BR><TT>int _wutime( const wchar_t *path,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct utimbuf *times );</TT>
<BR><BR><TT>struct utimbuf {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp; actime;&nbsp;&nbsp;&nbsp; /* access time */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp; modtime;&nbsp;&nbsp; /* modification time */</TT>
<BR><TT>};</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> utime</TT> function records the access and modification times for the file identified by<B> path</B>.
<BR><BR>The<TT> _utime</TT> function is identical to<TT> utime</TT>.&nbsp; Use<TT> _utime</TT> for ANSI naming conventions.
<BR><BR>If the<B> times</B> argument is<TT> NULL</TT>, the access and modification times of the file or directory are set
to the current time.&nbsp; Write access to this file must be permitted for the time to be recorded.
<BR><BR>If the<B> times</B> argument is not<TT> NULL</TT>, it is interpreted as a pointer to a <TT> utimbuf</TT> structure
and the access and modification times of the file or directory are set to the values contained in the designated structure.
&nbsp;The access and modification times are taken from the <TT> actime</TT> and <TT> modtime</TT> fields in this structure.
<BR><BR>The<TT> _wutime</TT> function is identical to<TT> utime</TT> except that<B> path</B> points to a wide-character string.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> utime</TT> function returns zero when the time was successfully recorded.&nbsp; A value of -1 indicates an error occurred.
</DL>
<DL>
<DT>Errors:
<DD>When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>EACCES
<DD>Search permission is denied for a component of<B> path</B> or the<B> times</B> argument is<TT> NULL</TT> and the effective
user ID of the process does not match the owner of the file and write access is denied.
<DT>EINVAL
<DD>The date is before 1980 (DOS only).
<DT>EMFILE
<DD>There are too many open files.
<DT>ENOENT
<DD>The specified<B> path</B> does not exist or<B> path</B> is an empty string.
</DL>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;sys/utime.h&gt;</TT>
<BR><BR><TT>void main( int argc, char *argv[] )</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( (utime( argv[1], NULL ) != 0) &amp;&amp; (argc &gt; 1) ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Unable to set time for %s\n&quot;, argv[1] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>POSIX 1003.1
<BR><BR>_utime conforms to ANSI naming conventions
<BR>_wutime is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> utime - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_utime - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
<BR><TT>_wutime - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</TT>
</DL>
<H2 ID="utoa"> utoa, _utoa, _utow </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>char *utoa( unsigned int value,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *buffer,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int radix );</TT>
<BR><TT>char *_utoa( unsigned int value,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *buffer,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int radix );</TT>
<BR><TT>wchar_t *_utow( unsigned int value,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t *buffer,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int radix );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> utoa</TT> function converts the unsigned binary integer<B> value</B> into the equivalent string in base<B> radix</B>
notation storing the result in the character array pointed to by<B> buffer</B>.&nbsp; A null character is appended to the
result.&nbsp; The size of<B> buffer</B> must be at least (8 * sizeof(int) + 1) bytes when converting values in base 2.&nbsp;
That makes the size 17 bytes on 16-bit machines, and 33 bytes on 32-bit machines.&nbsp; The value of<B> radix</B> must satisfy
the condition:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 2 &lt;= radix &lt;= 36</TT>
<BR><BR>The<TT> _utoa</TT> function is identical to<TT> utoa</TT>.&nbsp; Use<TT> _utoa</TT> for ANSI naming conventions.
<BR><BR>The<TT> _utow</TT> function is a wide-character version of<TT> utoa</TT>.&nbsp; It produces a wide-character string.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> utoa</TT> function returns the pointer to the result.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#atoi">atoi</A>, <A HREF="#atol">atol</A>, <A HREF="#atoll">atoll</A>, <A HREF="#itoa">itoa</A>, <A HREF="#ltoa">ltoa</A>,
<A HREF="#lltoa">lltoa</A>, <A HREF="#sscanf">sscanf</A>, <A HREF="#strtol">strtol</A>, <A HREF="#strtoll">strtoll</A>, <A HREF="#strtoul">strtoul</A>,
<A HREF="#strtoull">strtoull</A>, <A HREF="#strtoimax">strtoimax</A>, <A HREF="#strtoumax">strtoumax</A>, <A HREF="#ultoa">ultoa</A>,
<A HREF="#ulltoa">ulltoa</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int base;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char buffer[18];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; for( base = 2; base &lt;= 16; base = base + 2 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%2d %s\n&quot;, base,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; utoa( (unsigned) 12765,
buffer, base ) );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT> 2 11000111011101</TT>
<BR><TT> 4 3013131</TT>
<BR><TT> 6 135033</TT>
<BR><TT> 8 30735</TT>
<BR><TT>10 12765</TT>
<BR><TT>12 7479</TT>
<BR><TT>14 491b</TT>
<BR><TT>16 31dd</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
<BR><BR>_utoa conforms to ANSI naming conventions
</DL>
<DL>
<DT>Systems:
<DD><TT> utoa - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_utoa - All, Linux, RDOS, Netware</TT>
<BR><TT>_utow - All, Linux, RDOS</TT>
</DL>
<H2 ID="va_arg"> va_arg </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdarg.h&gt;</TT>
<BR><TT>type va_arg( va_list param, type );</TT>
</DL>
<DL>
<DT>Description:
<DD><TT> va_arg</TT> is a macro that can be used to obtain the next argument in a list of variable arguments.&nbsp; It must be
used with the associated macros <TT> va_start</TT> and <TT> va_end</TT>.&nbsp; A sequence such as
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void example( char *dst, ... )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_list curr_arg;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int next_arg;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_start( curr_arg, dst );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; next_arg = va_arg( curr_arg, int );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><BR>causes<TT> next_arg</TT> to be assigned the value of the next variable argument.&nbsp; The argument<B> type</B> (which
is <TT> int</TT> in the example) is the type of the argument originally passed to the function.
<BR><BR>The macro <TT> va_start</TT> must be executed first in order to properly initialize the variable<TT> curr_arg</TT>
and the macro <TT> va_end</TT> should be executed after all arguments have been obtained.
<BR><BR>The data item<TT> curr_arg</TT> is of type <TT> va_list</TT> which contains the information to permit successive acquisitions
of the arguments.
</DL>
<DL>
<DT>Returns:
<DD>The macro returns the value of the next variable argument, according to type passed as the second parameter.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#va_end">va_end</A>, <A HREF="#va_start">va_start</A>, <A HREF="#vfprintf">vfprintf</A>, <A HREF="#vprintf">vprintf</A>,
<A HREF="#vsprintf">vsprintf</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdarg.h&gt;</TT>
<BR><BR><TT>static void test_fn(</TT>
<BR><TT>&nbsp; const char *msg,&nbsp;&nbsp; /* message to be printed&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp; const char *types, /* parameter types (i,s)&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp; ... )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* variable arguments&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; va_list&nbsp;&nbsp;&nbsp;&nbsp; argument;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arg_int;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *arg_string;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; const char&nbsp; *types_ptr;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; types_ptr = types;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;\n%s -- %s\n&quot;, msg, types );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; va_start( argument, types );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; while( *types_ptr != '\0' ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (*types_ptr == 'i') {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arg_int = va_arg( argument, int );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;integer: %d\n&quot;, arg_int );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if (*types_ptr == 's') {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arg_string = va_arg( argument, char * );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;string:&nbsp; %s\n&quot;, arg_string
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++types_ptr;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; va_end( argument );</TT>
<BR><TT>}</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;VA...TEST\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; test_fn( &quot;PARAMETERS: 1, \&quot;abc\&quot;, 546&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;isi&quot;, 1, &quot;abc&quot;, 546
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; test_fn( &quot;PARAMETERS: \&quot;def\&quot;, 789&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;si&quot;, &quot;def&quot;, 789 );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>VA...TEST</TT>
<BR><BR><TT>PARAMETERS: 1, &quot;abc&quot;, 546 -- isi</TT>
<BR><TT>integer: 1</TT>
<BR><TT>string:&nbsp; abc</TT>
<BR><TT>integer: 546</TT>
<BR><BR><TT>PARAMETERS: &quot;def&quot;, 789 -- si</TT>
<BR><TT>string:&nbsp; def</TT>
<BR><TT>integer: 789</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C90
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="va_end"> va_end </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdarg.h&gt;</TT>
<BR><TT>void va_end( va_list param );</TT>
</DL>
<DL>
<DT>Description:
<DD><TT> va_end</TT> is a macro used to complete the acquisition of arguments from a list of variable arguments.&nbsp; It must
be used with the associated macros <TT> va_start</TT> and <TT> va_arg</TT>.&nbsp; See the description for <TT> va_arg</TT>
for complete documentation on these macros.
</DL>
<DL>
<DT>Returns:
<DD>The macro does not return a value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#va_arg">va_arg</A>, <A HREF="#va_start">va_start</A>, <A HREF="#vfprintf">vfprintf</A>, <A HREF="#vprintf">vprintf</A>,
<A HREF="#vsprintf">vsprintf</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdarg.h&gt;</TT>
<BR><TT>#include &lt;time.h&gt;</TT>
<BR><BR><TT>#define ESCAPE 27</TT>
<BR><BR><TT>void tprintf( int row, int col, char *fmt, ... )</TT>
<BR><TT> {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; auto va_list ap;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char *p1, *p2;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; va_start( ap, fmt );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; p1 = va_arg( ap, char * );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; p2 = va_arg( ap, char * );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%c[%2.2d;%2.2dH&quot;, ESCAPE, row, col );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( fmt, p1, p2 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; va_end( ap );</TT>
<BR><TT> }</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct tm&nbsp; time_of_day;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp;&nbsp;&nbsp; ltime;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; auto char&nbsp; buf[26];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; time( &amp;ltime );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _localtime( &amp;ltime, &amp;time_of_day );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; tprintf( 12, 1, &quot;Date and time is: %s\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _asctime( &amp;time_of_day, buf ) );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="va_start"> va_start </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdarg.h&gt;</TT>
<BR><TT>void va_start( va_list param, previous );</TT>
</DL>
<DL>
<DT>Description:
<DD><TT> va_start</TT> is a macro used to start the acquisition of arguments from a list of variable arguments.&nbsp; The<B> param</B>
argument is used by the <TT> va_arg</TT> macro to locate the current acquired argument.&nbsp; The<B> previous</B> argument
is the argument that immediately precedes the<TT> &quot;...&quot;</TT> notation in the original function definition.&nbsp;
It must be used with the associated macros <TT> va_arg</TT> and <TT> va_end</TT>.&nbsp; See the description of <TT> va_arg</TT>
for complete documentation on these macros.
</DL>
<DL>
<DT>Returns:
<DD>The macro does not return a value.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#va_arg">va_arg</A>, <A HREF="#va_end">va_end</A>, <A HREF="#vfprintf">vfprintf</A>, <A HREF="#vprintf">vprintf</A>,
<A HREF="#vsprintf">vsprintf</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdarg.h&gt;</TT>
<BR><TT>#include &lt;time.h&gt;</TT>
<BR><BR><TT>#define ESCAPE 27</TT>
<BR><BR><TT>void tprintf( int row, int col, char *fmt, ... )</TT>
<BR><TT> {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; auto va_list ap;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char *p1, *p2;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; va_start( ap, fmt );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; p1 = va_arg( ap, char * );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; p2 = va_arg( ap, char * );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%c[%2.2d;%2.2dH&quot;, ESCAPE, row, col );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( fmt, p1, p2 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; va_end( ap );</TT>
<BR><TT> }</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct tm&nbsp; time_of_day;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp;&nbsp;&nbsp; ltime;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; auto char&nbsp; buf[26];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; time( &amp;ltime );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _localtime( &amp;ltime, &amp;time_of_day );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; tprintf( 12, 1, &quot;Date and time is: %s\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _asctime( &amp;time_of_day, buf ) );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD>MACRO
</DL>
<H2 ID="_vbprintf"> _vbprintf, _vbwprintf </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdarg.h&gt;</TT>
<BR><TT>int _vbprintf( char *buf, size_t bufsize,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *format, va_list arg
);</TT>
<BR><TT>int _vbwprintf( wchar_t *buf, size_t bufsize,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t *format,
va_list arg );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _vbprintf</TT> function formats data under control of the<B> format</B> control string and writes the result to<B>
buf</B>.&nbsp; The argument<B> bufsize</B> specifies the size of the character array<B> buf</B> into which the generated output
is placed.&nbsp; The<B> format</B> string is described under the description of the <TT> printf</TT> function.&nbsp; The<TT>
_vbprintf</TT> function is equivalent to the <TT> _bprintf</TT> function, with the variable argument list replaced with<B>
arg</B>, which has been initialized by the <TT> va_start</TT> macro.
<BR><BR>The<TT> _vbwprintf</TT> function is a wide-character version of<TT> _vbprintf</TT>.&nbsp; It accepts a wide-character
string argument for<B> format</B> and produces wide character output.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _vbprintf</TT> function returns the number of characters written, or a negative value if an output error occurred.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_bprintf">_bprintf</A>, <A HREF="#cprintf">cprintf</A>, <A HREF="#fprintf">fprintf</A>, <A HREF="#printf">printf</A>,
<A HREF="#sprintf">sprintf</A>, <A HREF="#va_arg">va_arg</A>, <A HREF="#va_end">va_end</A>, <A HREF="#va_start">va_start</A>,
<A HREF="#vcprintf">vcprintf</A>, <A HREF="#vfprintf">vfprintf</A>, <A HREF="#vprintf">vprintf</A>, <A HREF="#vsprintf">vsprintf</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR>The following shows the use of<TT> _vbprintf</TT> in a general error message routine.
<BR><BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdarg.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><BR><TT>char msgbuf[80];</TT>
<BR><BR><TT>char *fmtmsg( char *format, ... )</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; va_list arglist;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; va_start( arglist, format );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; strcpy( msgbuf, &quot;Error: &quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _vbprintf( &amp;msgbuf[7], 73, format, arglist );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; va_end( arglist );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; return( msgbuf );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char *msg;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; msg = fmtmsg( &quot;%s %d %s&quot;, &quot;Failed&quot;, 100, &quot;times&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, msg );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> _vbprintf - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_vbwprintf - All, Linux</TT>
</DL>
<H2 ID="vcprintf"> vcprintf </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;stdarg.h&gt;</TT>
<BR><TT>int vcprintf( const char *format, va_list arg );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> vcprintf</TT> function writes output directly to the console under control of the argument<B> format</B>.&nbsp; The
<TT> putch</TT> function is used to output characters to the console.&nbsp; The<B> format</B> string is described under the
description of the <TT> printf</TT> function.&nbsp; The<TT> vcprintf</TT> function is equivalent to the <TT> cprintf</TT>
function, with the variable argument list replaced with<B> arg</B>, which has been initialized by the <TT> va_start</TT> macro.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> vcprintf</TT> function returns the number of characters written, or a negative value if an output error occurred.
&nbsp;When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_bprintf">_bprintf</A>, <A HREF="#cprintf">cprintf</A>, <A HREF="#fprintf">fprintf</A>, <A HREF="#printf">printf</A>,
<A HREF="#sprintf">sprintf</A>, <A HREF="#va_arg">va_arg</A>, <A HREF="#va_end">va_end</A>, <A HREF="#va_start">va_start</A>,
<A HREF="#_vbprintf">_vbprintf</A>, <A HREF="#vfprintf">vfprintf</A>, <A HREF="#vprintf">vprintf</A>, <A HREF="#vsprintf">vsprintf</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;stdarg.h&gt;</TT>
<BR><TT>#include &lt;time.h&gt;</TT>
<BR><BR><TT>#define ESCAPE 27</TT>
<BR><BR><TT>void tprintf( int row, int col, char *format, ... )</TT>
<BR><TT> {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; auto va_list arglist;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; cprintf( &quot;%c[%2.2d;%2.2dH&quot;, ESCAPE, row, col );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; va_start( arglist, format );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; vcprintf( format, arglist );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; va_end( arglist );</TT>
<BR><TT> }</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; struct tm&nbsp; time_of_day;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp;&nbsp;&nbsp; ltime;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; auto char&nbsp; buf[26];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; time( &amp;ltime );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _localtime( &amp;ltime, &amp;time_of_day );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; tprintf( 12, 1, &quot;Date and time is: %s\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _asctime( &amp;time_of_day, buf ) );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="vcscanf"> vcscanf </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;stdarg.h&gt;</TT>
<BR><TT>int vcscanf( const char *format, va_list args )</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> vcscanf</TT> function scans input from the console under control of the argument<B> format</B>.&nbsp; The<TT> vcscanf</TT>
function uses the function <TT> getche</TT> to read characters from the console.&nbsp; The<B> format</B> string is described
under the description of the <TT> scanf</TT> function.
<BR><BR>The<TT> vcscanf</TT> function is equivalent to the <TT> cscanf</TT> function, with a variable argument list replaced
with<B> arg</B>, which has been initialized using the <TT> va_start</TT> macro.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> vcscanf</TT> function returns <TT> EOF</TT> when the scanning is terminated by reaching the end of the input stream.
&nbsp;Otherwise, the number of input arguments for which values were successfully scanned and stored is returned.&nbsp; When
a file input error occurs, the <TT> errno</TT> global variable may be set.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#cscanf">cscanf</A>, <A HREF="#fscanf">fscanf</A>, <A HREF="#scanf">scanf</A>, <A HREF="#sscanf">sscanf</A>, <A HREF="#va_arg">va_arg</A>,
<A HREF="#va_end">va_end</A>, <A HREF="#va_start">va_start</A>, <A HREF="#vfscanf">vfscanf</A>, <A HREF="#vscanf">vscanf</A>,
<A HREF="#vsscanf">vsscanf</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;stdarg.h&gt;</TT>
<BR><BR><TT>void cfind( char *format, ... )</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; va_list arglist;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; va_start( arglist, format );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; vcscanf( format, arglist );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; va_end( arglist );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int day, year;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char weekday[10], month[10];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; cfind( &quot;%s %s %d %d&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; weekday, month, &amp;day, &amp;year );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; cprintf( &quot;\n%s, %s %d, %d\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; weekday, month, day, year );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="vfprintf"> vfprintf, vfwprintf </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdarg.h&gt;</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>int vfprintf( FILE *fp,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *format,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_list arg );</TT>
<BR><TT>#include &lt;stdarg.h&gt;</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>int vfwprintf( FILE *fp,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t *format,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_list arg );</TT>
</DL>
<DL>
<DT>Safer C:
<DD>The Safer C Library extension provides the <A HREF="#vfprintf_s">vfprintf_s</A> function which is a safer alternative to<TT>
vfprintf</TT> This newer<TT> vfprintf_s</TT> function is recommended to be used instead of the traditional &quot;unsafe&quot;<TT>
vfprintf</TT> function.
</DL>
<DL>
<DT>Description:
<DD>The<TT> vfprintf</TT> function writes output to the file pointed to by<B> fp</B> under control of the argument<B> format</B>.
&nbsp;The<B> format</B> string is described under the description of the <TT> printf</TT> function.&nbsp; The<TT> vfprintf</TT>
function is equivalent to the <TT> fprintf</TT> function, with the variable argument list replaced with<B> arg</B>, which
has been initialized by the <TT> va_start</TT> macro.
<BR><BR>The<TT> vfwprintf</TT> function is a wide-character version of<TT> vfprintf</TT>.&nbsp; It accepts a wide-character
string argument for<B> format</B> and produces wide character output.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> vfprintf</TT> function returns the number of characters written, or a negative value if an output error occurred.
&nbsp;The<TT> vfwprintf</TT> function returns the number of wide characters written, or a negative value if an output error
occurred.&nbsp; When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_bprintf">_bprintf</A>, <A HREF="#cprintf">cprintf</A>, <A HREF="#fprintf">fprintf</A>, <A HREF="#printf">printf</A>,
<A HREF="#sprintf">sprintf</A>, <A HREF="#va_arg">va_arg</A>, <A HREF="#va_end">va_end</A>, <A HREF="#va_start">va_start</A>,
<A HREF="#_vbprintf">_vbprintf</A>, <A HREF="#vcprintf">vcprintf</A>, <A HREF="#vprintf">vprintf</A>, <A HREF="#vsprintf">vsprintf</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdarg.h&gt;</TT>
<BR><BR><TT>FILE *LogFile;</TT>
<BR><BR><TT>/* a general error routine */</TT>
<BR><BR><TT>void errmsg( char *format, ... )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; va_list arglist;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; fprintf( stderr, &quot;Error: &quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; va_start( arglist, format );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; vfprintf( stderr, format, arglist );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; va_end( arglist );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( LogFile != NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf( LogFile, &quot;Error: &quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_start( arglist, format );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vfprintf( LogFile, format, arglist );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_end( arglist );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; LogFile = fopen( &quot;error.log&quot;, &quot;w&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; errmsg( &quot;%s %d %s&quot;, &quot;Failed&quot;, 100, &quot;times&quot; );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>vfwprintf is ISO C95
</DL>
<DL>
<DT>Systems:
<DD><TT> vfprintf - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>vfwprintf - All, Linux</TT>
</DL>
<H2 ID="vfprintf_s"> vfprintf_s, vfwprintf_s </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__ 1</TT>
<BR><TT>#include &lt;stdarg.h&gt;</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>int vfprintf_s( FILE * restrict stream,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char * restrict format, va_list arg );</TT>
<BR><TT>#include &lt;stdarg.h&gt;</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>int vfwprintf_s( FILE * restrict stream,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t * restrict format, va_list prg );</TT>
</DL>
<DL>
<DT>Constraints:
<DD>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<TT>
vfprintf_s</TT> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<BR><BR>Neither<B> stream</B> nor<B> format</B> shall be a null pointer.&nbsp; The<TT> %n</TT> specifier (modified or not
by flags, field width, or precision) shall not appear in the string pointed to by<B> format</B>.&nbsp; Any argument to<TT>
vfprintf_s</TT> corresponding to a<TT> %s</TT> specifier shall not be a null pointer.
<BR><BR>If there is a runtime-constraint violation, the<TT> vfprintf_s</TT> function does not attempt to produce further output,
and it is unspecified to what extent<TT> vfprintf_s</TT> produced output before discovering the runtime-constraint violation.
</DL>
<DL>
<DT>Description:
<DD>The<TT> vfprintf_s</TT> function is equivalent to the <TT> vprintf</TT> function except for the explicit runtime-constraints
listed above.
<BR><BR>The<TT> vfwprintf_s</TT> function is a wide-character version of<TT> vfprintf_s</TT>.&nbsp; It accepts a wide-character
string argument for<B> format</B> and produces wide character output.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> vfprintf_s</TT> function returns the number of characters written, or a negative value if an output error or runtime-constraint
violation occurred.
<BR><BR>The<TT> vfwprintf_s</TT> function returns the number of wide characters written, or a negative value if an output
error or runtime-constraint violation occurred.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_bprintf">_bprintf</A>, <A HREF="#cprintf">cprintf</A>, <A HREF="#fprintf">fprintf</A>, <A HREF="#printf">printf</A>,
<A HREF="#sprintf">sprintf</A>, <A HREF="#_vbprintf">_vbprintf</A>, <A HREF="#vcprintf">vcprintf</A>, <A HREF="#vfprintf">vfprintf</A>,
<A HREF="#vprintf">vprintf</A>, <A HREF="#vsprintf">vsprintf</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__ 1</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdarg.h&gt;</TT>
<BR><BR><TT>FILE *LogFile;</TT>
<BR><BR><TT>/* a general error routine */</TT>
<BR><BR><TT>void errmsg( char *format, ... )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; va_list arglist;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; fprintf_s( stderr, &quot;Error: &quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; va_start( arglist, format );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; vfprintf_s( stderr, format, arglist );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; va_end( arglist );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( LogFile != NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf_s( LogFile, &quot;Error: &quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_start( arglist, format );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vfprintf_s( LogFile, format, arglist );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_end( arglist );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; errmsg( &quot;%s %d %s&quot;, &quot;Failed&quot;, 100, &quot;times&quot; );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>Error: Failed 100 times</TT>
</DL>
<DL>
<DT>Classification:
<DD>TR 24731
</DL>
<DL>
<DT>Systems:
<DD><TT> vfprintf_s - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>vfwprintf_s - All, Linux</TT>
</DL>
<H2 ID="vfscanf"> vfscanf, vfwscanf </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdarg.h&gt;</TT>
<BR><TT>int vfscanf( FILE *fp,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *format,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_list arg );</TT>
<BR><TT>int vfwscanf( FILE *fp,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t *format,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_list arg );</TT>
</DL>
<DL>
<DT>Safer C:
<DD>The Safer C Library extension provides the <A HREF="#vfscanf_s">vfscanf_s</A> function which is a safer alternative to<TT>
vfscanf</TT> This newer<TT> vfscanf_s</TT> function is recommended to be used instead of the traditional &quot;unsafe&quot;<TT>
vfscanf</TT> function.
</DL>
<DL>
<DT>Description:
<DD>The<TT> vfscanf</TT> function scans input from the file designated by<B> fp</B> under control of the argument<B> format</B>.
&nbsp;The<B> format</B> string is described under the description of the <TT> scanf</TT> function.
<BR><BR>The<TT> vfscanf</TT> function is equivalent to the <TT> fscanf</TT> function, with a variable argument list replaced
with<B> arg</B>, which has been initialized using the <TT> va_start</TT> macro.
<BR><BR>The<TT> vfwscanf</TT> function is a wide-character version of<TT> vfscanf</TT>.&nbsp; It accepts a wide-character
string argument for<B> format</B> and produces wide character output.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> vfscanf</TT> function returns <TT> EOF</TT> if an input failure occurred before any conversion.&nbsp; Otherwise, the
number of input arguments for which values were successfully scanned and stored is returned.&nbsp; When a file input error
occurs, the <TT> errno</TT> global variable may be set.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#cscanf">cscanf</A>, <A HREF="#fscanf">fscanf</A>, <A HREF="#scanf">scanf</A>, <A HREF="#sscanf">sscanf</A>, <A HREF="#va_arg">va_arg</A>,
<A HREF="#va_end">va_end</A>, <A HREF="#va_start">va_start</A>, <A HREF="#vcscanf">vcscanf</A>, <A HREF="#vscanf">vscanf</A>,
<A HREF="#vsscanf">vsscanf</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdarg.h&gt;</TT>
<BR><BR><TT>void ffind( FILE *fp, char *format, ... )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; va_list arglist;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; va_start( arglist, format );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; vfscanf( fp, format, arglist );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; va_end( arglist );</TT>
<BR><TT>}</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int day, year;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char weekday[10], month[10];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; ffind( stdin,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;%s %s %d %d&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; weekday, month, &amp;day, &amp;year );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;\n%s, %s %d, %d\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; weekday, month, day, year );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C99
</DL>
<DL>
<DT>Systems:
<DD><TT> vfscanf - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>vfwscanf - All, Linux</TT>
</DL>
<H2 ID="vfscanf_s"> vfscanf_s, vfwscanf_s </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__ 1</TT>
<BR><TT>#include &lt;stdarg.h&gt;</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>int vfscanf_s( FILE * restrict stream,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char * restrict format, va_list arg );</TT>
<BR><TT>#include &lt;stdarg.h&gt;</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>int vfwscanf_s( FILE * restrict stream,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t * restrict format, va_list arg );</TT>
</DL>
<DL>
<DT>Constraints:
<DD>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<TT>
vfscanf_s</TT> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<BR><BR>Neither<B> stream</B> nor<B> format</B> shall be a null pointer.&nbsp; Any argument indirected through in order to
store converted input shall not be a null pointer.
<BR><BR>If there is a runtime-constraint violation, the<TT> vfscanf_s</TT> function does not attempt to perform further input,
and it is unspecified to what extent<TT> vfscanf_s</TT> performed input before discovering the runtime-constraint violation.
</DL>
<DL>
<DT>Description:
<DD>The<TT> vfscanf_s</TT> function is equivalent to <TT> fscanf_s</TT>, with the variable argument list replaced by<B> arg</B>,
which shall have been initialized by the <TT> va_start</TT> macro (and possibly subsequent <TT> va_arg</TT> calls).&nbsp;
The<TT> vfscanf_s</TT> function does not invoke the <TT> va_end</TT> macro.
<BR><BR>The<TT> vfwscanf_s</TT> function is identical to<TT> vfscanf_s</TT> except that it accepts a wide-character string
argument for<B> format</B>.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> vfscanf_s</TT> function returns <TT> EOF</TT> if an input failure occurred before any conversion or if there was a
runtime-constraint violation.&nbsp; Otherwise, the<TT> vfscanf_s</TT> function returns the number of input items successfully
assigned, which can be fewer than provided for, or even zero.
<BR><BR>When a file input error occurs, the <TT> errno</TT> global variable may be set.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#cscanf">cscanf</A>, <A HREF="#fscanf">fscanf</A>, <A HREF="#scanf">scanf</A>, <A HREF="#sscanf">sscanf</A>, <A HREF="#va_arg">va_arg</A>,
<A HREF="#va_end">va_end</A>, <A HREF="#va_start">va_start</A>, <A HREF="#vcscanf">vcscanf</A>, <A HREF="#vfscanf">vfscanf</A>,
<A HREF="#vscanf">vscanf</A>, <A HREF="#vsscanf">vsscanf</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__ 1</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdarg.h&gt;</TT>
<BR><BR><TT>void ffind( FILE *fp, char *format, ... )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; va_list arglist;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; va_start( arglist, format );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; vfscanf_s( fp, format, arglist );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; va_end( arglist );</TT>
<BR><TT>}</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int day, year;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char weekday[10], month[10];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; ffind( stdin,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;%s %s %d %d&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; weekday, sizeof( weekday ),</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; month, sizeof( month ),</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;day, &amp;year );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf_s( &quot;\n%s, %s %d, %d\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; weekday, month, day, year );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>TR 24731
</DL>
<DL>
<DT>Systems:
<DD><TT> vfscanf_s - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>vfwscanf_s - All, Linux</TT>
</DL>
<H2 ID="vprintf"> vprintf, vwprintf </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdarg.h&gt;</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>int vprintf( const char *format, va_list arg );</TT>
<BR><TT>#include &lt;stdarg.h&gt;</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>int vwprintf( const wchar_t *format, va_list arg );</TT>
</DL>
<DL>
<DT>Safer C:
<DD>The Safer C Library extension provides the <A HREF="#vprintf_s">vprintf_s</A> function which is a safer alternative to<TT>
vprintf</TT> This newer<TT> vprintf_s</TT> function is recommended to be used instead of the traditional &quot;unsafe&quot;<TT>
vprintf</TT> function.
</DL>
<DL>
<DT>Description:
<DD>The<TT> vprintf</TT> function writes output to the file <TT> stdout</TT> under control of the argument<B> format</B>.&nbsp;
The<B> format</B> string is described under the description of the <TT> printf</TT> function.&nbsp; The<TT> vprintf</TT> function
is equivalent to the <TT> printf</TT> function, with the variable argument list replaced with<B> arg</B>, which has been initialized
by the <TT> va_start</TT> macro.
<BR><BR>The<TT> vwprintf</TT> function is a wide-character version of<TT> vprintf</TT>.&nbsp; It accepts a wide-character
string argument for<B> format</B> and produces wide character output.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> vprintf</TT> function returns the number of characters written, or a negative value if an output error occurred.&nbsp;
The<TT> vwprintf</TT> function returns the number of wide characters written, or a negative value if an output error occurred.
&nbsp;When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_bprintf">_bprintf</A>, <A HREF="#cprintf">cprintf</A>, <A HREF="#fprintf">fprintf</A>, <A HREF="#printf">printf</A>,
<A HREF="#sprintf">sprintf</A>, <A HREF="#va_arg">va_arg</A>, <A HREF="#va_end">va_end</A>, <A HREF="#va_start">va_start</A>,
<A HREF="#_vbprintf">_vbprintf</A>, <A HREF="#vcprintf">vcprintf</A>, <A HREF="#vfprintf">vfprintf</A>, <A HREF="#vsprintf">vsprintf</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR>The following shows the use of<TT> vprintf</TT> in a general error message routine.
<BR><BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdarg.h&gt;</TT>
<BR><BR><TT>void errmsg( char *format, ... )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; va_list arglist;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Error: &quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; va_start( arglist, format );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; vprintf( format, arglist );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; va_end( arglist );</TT>
<BR><TT>}</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; errmsg( &quot;%s %d %s&quot;, &quot;Failed&quot;, 100, &quot;times&quot; );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>Error: Failed 100 times</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>vwprintf is ISO C95
</DL>
<DL>
<DT>Systems:
<DD><TT> vprintf - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>vwprintf - All, Linux</TT>
</DL>
<H2 ID="vprintf_s"> vprintf_s, vwprintf_s </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__ 1</TT>
<BR><TT>#include &lt;stdarg.h&gt;</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>int vprintf_s( const char * restrict format, va_list arg );</TT>
<BR><TT>#include &lt;stdarg.h&gt;</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>int vwprintf_s( const wchar_t * restrict format, va_list prg );</TT>
</DL>
<DL>
<DT>Constraints:
<DD>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<TT>
vprintf_s</TT> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<BR><BR>The<B> format</B> argument shall not be a null pointer.&nbsp; The<TT> %n</TT> specifier (modified or not by flags,
field width, or precision) shall not appear in the string pointed to by<B> format</B>.&nbsp; Any argument to<TT> vprintf_s</TT>
corresponding to a<TT> %s</TT> specifier shall not be a null pointer.
<BR><BR>If there is a runtime-constraint violation, the<TT> vprintf_s</TT> function does not attempt to produce further output,
and it is unspecified to what extent<TT> vprintf_s</TT> produced output before discovering the runtime-constraint violation.
</DL>
<DL>
<DT>Description:
<DD>The<TT> vprintf_s</TT> function is equivalent to the <TT> vprintf</TT> function except for the explicit runtime-constraints
listed above.
<BR><BR>The<TT> vwprintf_s</TT> function is a wide-character version of<TT> vprintf_s</TT>.&nbsp; It accepts a wide-character
string argument for<B> format</B> and produces wide character output.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> vprintf_s</TT> function returns the number of characters written, or a negative value if an output error or runtime-constraint
violation occurred.
<BR><BR>The<TT> vwprintf_s</TT> function returns the number of wide characters written, or a negative value if an output error
or runtime-constraint violation occurred.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_bprintf">_bprintf</A>, <A HREF="#cprintf">cprintf</A>, <A HREF="#fprintf">fprintf</A>, <A HREF="#printf">printf</A>,
<A HREF="#sprintf">sprintf</A>, <A HREF="#_vbprintf">_vbprintf</A>, <A HREF="#vcprintf">vcprintf</A>, <A HREF="#vfprintf">vfprintf</A>,
<A HREF="#vprintf">vprintf</A>, <A HREF="#vsprintf">vsprintf</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__ 1</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdarg.h&gt;</TT>
<BR><BR><TT>void errmsg( char *format, ... )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; va_list arglist;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; printf_s( &quot;Error: &quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; va_start( arglist, format );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; vprintf_s( format, arglist );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; va_end( arglist );</TT>
<BR><TT>}</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; errmsg( &quot;%s %d %s&quot;, &quot;Failed&quot;, 100, &quot;times&quot; );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>Error: Failed 100 times</TT>
</DL>
<DL>
<DT>Classification:
<DD>TR 24731
</DL>
<DL>
<DT>Systems:
<DD><TT> vprintf_s - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>vwprintf_s - All, Linux</TT>
</DL>
<H2 ID="vscanf"> vscanf, vwscanf </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdarg.h&gt;</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>int vscanf( const char *format, va_list arg );</TT>
<BR><TT>#include &lt;stdarg.h&gt;</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>int vwscanf( const wchar_t *format, va_list arg );</TT>
</DL>
<DL>
<DT>Safer C:
<DD>The Safer C Library extension provides the <A HREF="#vscanf_s">vscanf_s</A> function which is a safer alternative to<TT> vscanf</TT>
This newer<TT> vscanf_s</TT> function is recommended to be used instead of the traditional &quot;unsafe&quot;<TT> vscanf</TT>
function.
</DL>
<DL>
<DT>Description:
<DD>The<TT> vscanf</TT> function scans input from the file designated by<B> stdin</B> under control of the argument<B> format</B>.
&nbsp;The<B> format</B> string is described under the description of the <TT> scanf</TT> function.
<BR><BR>The<TT> vscanf</TT> function is equivalent to the <TT> scanf</TT> function, with a variable argument list replaced
with<B> arg</B>, which has been initialized using the <TT> va_start</TT> macro.
<BR><BR>The<TT> vwscanf</TT> function is identical to<TT> vscanf</TT> except that it accepts a wide-character string argument
for<B> format</B>.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> vscanf</TT> function returns <TT> EOF</TT> if an input failure occurred before any conversion.&nbsp; values were successfully
scanned and stored is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#cscanf">cscanf</A>, <A HREF="#fscanf">fscanf</A>, <A HREF="#scanf">scanf</A>, <A HREF="#sscanf">sscanf</A>, <A HREF="#va_arg">va_arg</A>,
<A HREF="#va_end">va_end</A>, <A HREF="#va_start">va_start</A>, <A HREF="#vcscanf">vcscanf</A>, <A HREF="#vfscanf">vfscanf</A>,
<A HREF="#vsscanf">vsscanf</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdarg.h&gt;</TT>
<BR><BR><TT>void find( char *format, ... )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; va_list arglist;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; va_start( arglist, format );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; vscanf( format, arglist );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; va_end( arglist );</TT>
<BR><TT>}</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int day, year;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char weekday[10], month[10];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; find( &quot;%s %s %d %d&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; weekday, month, &amp;day, &amp;year );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;\n%s, %s %d, %d\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; weekday, month, day, year );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C99
</DL>
<DL>
<DT>Systems:
<DD><TT> vscanf - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>vwscanf - All, Linux</TT>
</DL>
<H2 ID="vscanf_s"> vscanf_s, vwscanf_s </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__ 1</TT>
<BR><TT>#include &lt;stdarg.h&gt;</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>int vscanf_s( const char * restrict format, va_list arg );</TT>
<BR><TT>#include &lt;stdarg.h&gt;</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>int vwscanf_s( const wchar_t * restrict format, va_list arg );</TT>
</DL>
<DL>
<DT>Constraints:
<DD>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<TT>
vscanf_s</TT> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<BR><BR>The argument<B> format</B> shall not be a null pointer.&nbsp; Any argument indirected through in order to store converted
input shall not be a null pointer.
<BR><BR>If there is a runtime-constraint violation, the<TT> vscanf_s</TT> function does not attempt to perform further input,
and it is unspecified to what extent<TT> vscanf_s</TT> performed input before discovering the runtime-constraint violation.
</DL>
<DL>
<DT>Description:
<DD>The<TT> vscanf_s</TT> function is equivalent to <TT> scanf_s</TT>, with the variable argument list replaced by<B> arg</B>,
which shall have been initialized by the <TT> va_start</TT> macro (and possibly subsequent <TT> va_arg</TT> calls).&nbsp;
The<TT> vscanf_s</TT> function does not invoke the <TT> va_end</TT> macro.
<BR><BR>The<TT> vwscanf_s</TT> function is identical to<TT> vscanf_s</TT> except that it accepts a wide-character string argument
for<B> format</B>.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> vscanf_s</TT> function returns <TT> EOF</TT> if an input failure occurred before any conversion or if there was a
runtime-constraint violation.&nbsp; Otherwise, the<TT> vscanf_s</TT> function returns the number of input items successfully
assigned, which can be fewer than provided for, or even zero.
<BR><BR>When a file input error occurs, the <TT> errno</TT> global variable may be set.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#cscanf">cscanf</A>, <A HREF="#fscanf">fscanf</A>, <A HREF="#scanf">scanf</A>, <A HREF="#sscanf">sscanf</A>, <A HREF="#va_arg">va_arg</A>,
<A HREF="#va_end">va_end</A>, <A HREF="#va_start">va_start</A>, <A HREF="#vcscanf">vcscanf</A>, <A HREF="#vfscanf">vfscanf</A>,
<A HREF="#vscanf">vscanf</A>, <A HREF="#vsscanf">vsscanf</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__ 1</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdarg.h&gt;</TT>
<BR><BR><TT>void find( char *format, ... )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; va_list arglist;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; va_start( arglist, format );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; vscanf_s( format, arglist );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; va_end( arglist );</TT>
<BR><TT>}</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int day, year;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char weekday[10], month[10];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; find( &quot;%s %s %d %d&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; weekday, sizeof( weekday ),</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; month, sizeof( month ),</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;day, &amp;year );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf_s( &quot;\n%s, %s %d, %d\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; weekday, month, day, year );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>TR 24731
</DL>
<DL>
<DT>Systems:
<DD><TT> vscanf_s - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>vwscanf_s - All, Linux</TT>
</DL>
<H2 ID="_vsnprintf"> _vsnprintf, _vsnwprintf </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdarg.h&gt;</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>int _vsnprintf( char *buf,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t count,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *format,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_list arg );</TT>
<BR><TT>#include &lt;stdarg.h&gt;</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>int _vsnwprintf( wchar_t *buf,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t count,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t *format,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_list arg );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _vsnprintf</TT> function formats data under control of the<B> format</B> control string and stores the result in<B>
buf</B>.&nbsp; The maximum number of characters to store is specified by<B> count</B>.&nbsp; A null character is placed at
the end of the generated character string if fewer than<B> count</B> characters were stored.&nbsp; The<B> format</B> string
is described under the description of the <TT> printf</TT> function.&nbsp; The<TT> _vsnprintf</TT> function is equivalent
to the <TT> _snprintf</TT> function, with the variable argument list replaced with<B> arg</B>, which has been initialized
by the <TT> va_start</TT> macro.
<BR><BR>The<TT> _vsnwprintf</TT> function is a wide-character version of<TT> _vsnprintf</TT>.&nbsp; It accepts a wide-character
string argument for<B> format</B> and produces wide character output.&nbsp; The argument<B> buf</B> specifies an array of
wide characters into which the generated output is to be written, rather than converted to multibyte characters and written
to a stream.&nbsp; The maximum number of wide characters to write is specified by<B> count</B>.&nbsp; A null wide character
is placed at the end of the generated wide character string if fewer than<B> count</B> wide characters were stored.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _vsnprintf</TT> function returns the number of characters written into the array, not counting the terminating null
character, or a negative value if more than<B> count</B> characters were requested to be generated.&nbsp; An error can occur
while converting a value for output.&nbsp; The<TT> _vsnwprintf</TT> function returns the number of wide characters written
into the array, not counting the terminating null wide character, or a negative value if more than<B> count</B> wide characters
were requested to be generated.&nbsp; When an error has occurred, <TT> errno</TT> contains a value indicating the type of
error that has been detected.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_bprintf">_bprintf</A>, <A HREF="#cprintf">cprintf</A>, <A HREF="#fprintf">fprintf</A>, <A HREF="#printf">printf</A>,
<A HREF="#sprintf">sprintf</A>, <A HREF="#va_arg">va_arg</A>, <A HREF="#va_end">va_end</A>, <A HREF="#va_start">va_start</A>,
<A HREF="#_vbprintf">_vbprintf</A>, <A HREF="#vcprintf">vcprintf</A>, <A HREF="#vfprintf">vfprintf</A>, <A HREF="#vprintf">vprintf</A>,
<A HREF="#vsprintf">vsprintf</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR>The following shows the use of<TT> _vsnprintf</TT> in a general error message routine.
<BR><BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdarg.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><BR><TT>char msgbuf[80];</TT>
<BR><BR><TT>char *fmtmsg( char *format, ... )</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; va_list arglist;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; va_start( arglist, format );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; strcpy( msgbuf, &quot;Error: &quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _vsnprintf( &amp;msgbuf[7], 80-7, format, arglist );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; va_end( arglist );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; return( msgbuf );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char *msg;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; msg = fmtmsg( &quot;%s %d %s&quot;, &quot;Failed&quot;, 100, &quot;times&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, msg );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> _vsnprintf - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_vsnwprintf - All, Linux</TT>
</DL>
<H2 ID="vsnprintf"> vsnprintf, vsnwprintf </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdarg.h&gt;</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>int vsnprintf( char *buf,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t count,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *format,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_list arg );</TT>
<BR><TT>#include &lt;stdarg.h&gt;</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>int vsnwprintf( wchar_t *buf,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t count,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t *format,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_list arg );</TT>
</DL>
<DL>
<DT>Safer C:
<DD>The Safer C Library extension provides the <A HREF="#vsnprintf_s">vsnprintf_s</A> function which is a safer alternative to<TT>
vsnprintf</TT> This newer<TT> vsnprintf_s</TT> function is recommended to be used instead of the traditional &quot;unsafe&quot;<TT>
vsnprintf</TT> function.
</DL>
<DL>
<DT>Description:
<DD>The<TT> vsnprintf</TT> function formats data under control of the<B> format</B> control string and stores the result in<B>
buf</B>.&nbsp; The maximum number of characters to store, including a terminating null character, is specified by<B> count</B>.
&nbsp;The<B> format</B> string is described under the description of the <TT> printf</TT> function.&nbsp; The<TT> vsnprintf</TT>
function is equivalent to the <TT> _snprintf</TT> function, with the variable argument list replaced with<B> arg</B>, which
has been initialized by the <TT> va_start</TT> macro.
<BR><BR>The<TT> vsnwprintf</TT> function is a wide-character version of<TT> vsnprintf</TT>.&nbsp; It accepts a wide-character
string argument for<B> format</B> and produces wide character output.&nbsp; The argument<B> buf</B> specifies an array of
wide characters into which the generated output is to be written, rather than converted to multibyte characters and written
to a stream.&nbsp; The maximum number of wide characters to write, including a terminating null wide character, is specified
by<B> count</B>.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> vsnprintf</TT> function returns the number of characters that would have been written had<B> count</B> been sufficiently
large, not counting the terminating null character, or a negative value if an encoding error occurred.&nbsp; Thus, the null-terminated
output has been completely written if and only if the returned value is nonnegative and less than<B> count</B>.&nbsp; The<TT>
vsnwprintf</TT> function returns the number of wide characters that would have been written had<B> count</B> been sufficiently
large, not counting the terminating null wide character, or a negative value if an encoding error occurred.&nbsp; Thus, the
null-terminated output has been completely written if and only if the returned value is nonnegative and less than<B> count</B>.
&nbsp;When an error has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_bprintf">_bprintf</A>, <A HREF="#cprintf">cprintf</A>, <A HREF="#fprintf">fprintf</A>, <A HREF="#printf">printf</A>,
<A HREF="#sprintf">sprintf</A>, <A HREF="#va_arg">va_arg</A>, <A HREF="#va_end">va_end</A>, <A HREF="#va_start">va_start</A>,
<A HREF="#_vbprintf">_vbprintf</A>, <A HREF="#vcprintf">vcprintf</A>, <A HREF="#vfprintf">vfprintf</A>, <A HREF="#vprintf">vprintf</A>,
<A HREF="#vsprintf">vsprintf</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR>The following shows the use of<TT> vsnprintf</TT> in a general error message routine.
<BR><BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>#include &lt;stdarg.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><BR><TT>char *fmtmsg( char *format, ... )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; *msgbuf;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; len;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; va_list arglist;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; va_start( arglist, format );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; len = vsnprintf( NULL, 0, format, arglist );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; va_end( arglist );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; len = len + 1 + 7;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; msgbuf = malloc( len );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; strcpy( msgbuf, &quot;Error: &quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; va_start( arglist, format );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; vsnprintf( &amp;msgbuf[7], len, format, arglist );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; va_end( arglist );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; return( msgbuf );</TT>
<BR><TT>}</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char *msg;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; msg = fmtmsg( &quot;%s %d %s&quot;, &quot;Failed&quot;, 100, &quot;times&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, msg );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; free( msg );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD><TT> vsnprintf - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>vsnwprintf - All, Linux</TT>
</DL>
<H2 ID="vsnprintf_s"> vsnprintf_s, vsnwprintf_s </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__ 1</TT>
<BR><TT>#include &lt;stdarg.h&gt;</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>int vsnprintf_s( char * restrict s, rsize_t n</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char * restrict format, va_list arg );</TT>
<BR><TT>#include &lt;stdarg.h&gt;</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>int vsnwprintf_s( char * restrict s, rsize_t n,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t * restrict format, va_list arg );</TT>
</DL>
<DL>
<DT>Constraints:
<DD>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<TT>
vsnprintf_s</TT> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<BR><BR>Neither<B> s</B> nor<B> format</B> shall be a null pointer.&nbsp; The<B> n</B> argument shall neither equal zero nor
be greater than<TT> RSIZE_MAX.</TT>&nbsp; The number of characters (including the trailing null) required for the result to
be written to the array pointed to by<B> s</B> shall not be greater than<B> n</B>.&nbsp; The<TT> %n</TT> specifier (modified
or not by flags, field width, or precision) shall not appear in the string pointed to by<B> format</B>.&nbsp; Any argument
to<TT> vsnprintf_s</TT> corresponding to a<TT> %s</TT> specifier shall not be a null pointer.&nbsp; No encoding error shall
occur.
<BR><BR>If there is a runtime-constraint violation, then if<B> s</B> is not a null pointer and<B> n</B> is greater than zero
and less than<TT> RSIZE_MAX,</TT> then the<TT> vsnprintf_s</TT> function sets<B> s[0]</B> to the null character.
</DL>
<DL>
<DT>Description:
<DD>The<TT> vsnprintf_s</TT> function is equivalent to the <TT> vsnprintf</TT> function except for the explicit runtime-constraints
listed above.
<BR><BR>The<TT> vsnprintf_s</TT> function, unlike <TT> vsprintf_s</TT>, will truncate the result to fit within the array pointed
to by<B> s</B>.
<BR><BR>The<TT> vsnwprintf_s</TT> function is a wide-character version of<TT> vsnprintf_s</TT>.&nbsp; It accepts a wide-character
string argument for<B> format</B> and produces wide character output.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> vsnprintf_s</TT> function returns the number of characters that would have been written had<B> n</B> been sufficiently
large, not counting the terminating null character, or a negative value if a runtime-constraint violation occurred.&nbsp;
Thus, the null-terminated output has been completely written if and only if the returned value is nonnegative and less than<B>
n</B>.
<BR><BR>The<TT> vsnprintf_s</TT> function returns the number of wide characters that would have been written had<B> n</B>
been sufficiently large, not counting the terminating wide null character, or a negative value if a runtime-constraint violation
occurred.&nbsp; Thus, the null-terminated output has been completely written if and only if the returned value is nonnegative
and less than<B> n</B>.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_bprintf">_bprintf</A>, <A HREF="#cprintf">cprintf</A>, <A HREF="#fprintf">fprintf</A>, <A HREF="#printf">printf</A>,
<A HREF="#sprintf">sprintf</A>, <A HREF="#_vbprintf">_vbprintf</A>, <A HREF="#vcprintf">vcprintf</A>, <A HREF="#vfprintf">vfprintf</A>,
<A HREF="#vprintf">vprintf</A>, <A HREF="#vsprintf">vsprintf</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR>The following shows the use of<TT> vsnprintf_s</TT> in a general error message routine.
<BR><BR><TT>#define __STDC_WANT_LIB_EXT1__ 1</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>#include &lt;stdarg.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><BR><TT>char *fmtmsg( char *format, ... )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; *msgbuf;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; len;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; va_list arglist;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; va_start( arglist, format );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; len = vsnprintf( NULL, 0, format, arglist );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; va_end( arglist );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; len = len + 1 + 7;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; msgbuf = malloc( len );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; strcpy( msgbuf, &quot;Error: &quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; va_start( arglist, format );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; vsnprintf_s( &amp;msgbuf[7], len, format, arglist );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; va_end( arglist );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; return( msgbuf );</TT>
<BR><TT>}</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char *msg;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; msg = fmtmsg( &quot;%s %d %s&quot;, &quot;Failed&quot;, 100, &quot;times&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf_s( &quot;%s\n&quot;, msg );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; free( msg );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>TR 24731
</DL>
<DL>
<DT>Systems:
<DD><TT> vsnprintf_s - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>vsnwprintf_s - All, Linux</TT>
</DL>
<H2 ID="vsprintf"> vsprintf, vswprintf </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdarg.h&gt;</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>int vsprintf( char *buf,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *format,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_list arg );</TT>
<BR><TT>#include &lt;stdarg.h&gt;</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>int vswprintf( wchar_t *buf,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t count,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t *format,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_list arg );</TT>
</DL>
<DL>
<DT>Safer C:
<DD>The Safer C Library extension provides the <A HREF="#vsprintf_s">vsprintf_s</A> function which is a safer alternative to<TT>
vsprintf</TT> This newer<TT> vsprintf_s</TT> function is recommended to be used instead of the traditional &quot;unsafe&quot;<TT>
vsprintf</TT> function.
</DL>
<DL>
<DT>Description:
<DD>The<TT> vsprintf</TT> function formats data under control of the<B> format</B> control string and writes the result to<B>
buf</B>.&nbsp; The<B> format</B> string is described under the description of the <TT> printf</TT> function.&nbsp; The<TT>
vsprintf</TT> function is equivalent to the <TT> sprintf</TT> function, with the variable argument list replaced with<B> arg</B>,
which has been initialized by the <TT> va_start</TT> macro.
<BR><BR>The<TT> vswprintf</TT> function is a wide-character version of<TT> vsprintf</TT>.&nbsp; It accepts a wide-character
string argument for<B> format</B> and produces wide character output.&nbsp; The argument<B> buf</B> specifies an array of
wide characters into which the generated output is to be written, rather than converted to multibyte characters and written
to a stream.&nbsp; The maximum number of wide characters to write, including a terminating null wide character, is specified
by<B> count</B>.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> vsprintf</TT> function returns the number of characters written, or a negative value if an output error occurred.
&nbsp;The<TT> vswprintf</TT> function returns the number of wide characters written into the array, not counting the terminating
null wide character, or a negative value if<B> count</B> or more wide characters were requested to be generated.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_bprintf">_bprintf</A>, <A HREF="#cprintf">cprintf</A>, <A HREF="#fprintf">fprintf</A>, <A HREF="#printf">printf</A>,
<A HREF="#sprintf">sprintf</A>, <A HREF="#va_arg">va_arg</A>, <A HREF="#va_end">va_end</A>, <A HREF="#va_start">va_start</A>,
<A HREF="#_vbprintf">_vbprintf</A>, <A HREF="#vcprintf">vcprintf</A>, <A HREF="#vfprintf">vfprintf</A>, <A HREF="#vprintf">vprintf</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR>The following shows the use of<TT> vsprintf</TT> in a general error message routine.
<BR><BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdarg.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><BR><TT>char msgbuf[80];</TT>
<BR><BR><TT>char *fmtmsg( char *format, ... )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; va_list arglist;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; va_start( arglist, format );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; strcpy( msgbuf, &quot;Error: &quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; vsprintf( &amp;msgbuf[7], format, arglist );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; va_end( arglist );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; return( msgbuf );</TT>
<BR><TT>}</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char *msg;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; msg = fmtmsg( &quot;%s %d %s&quot;, &quot;Failed&quot;, 100, &quot;times&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, msg );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>vswprintf is ISO C95
</DL>
<DL>
<DT>Systems:
<DD><TT> vsprintf - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>vswprintf - All, Linux</TT>
</DL>
<H2 ID="vsprintf_s"> vsprintf_s, vswprintf_s </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__ 1</TT>
<BR><TT>#include &lt;stdarg.h&gt;</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>int vsprintf_s( char * restrict s, rsize_t n</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char * restrict format, va_list arg );</TT>
<BR><TT>#include &lt;stdarg.h&gt;</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>int vswprintf_s( char * restrict s, rsize_t n,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t * restrict format, va_list arg );</TT>
</DL>
<DL>
<DT>Constraints:
<DD>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<TT>
vsprintf_s</TT> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<BR><BR>Neither<B> s</B> nor<B> format</B> shall be a null pointer.&nbsp; The<B> n</B> argument shall neither equal zero nor
be greater than<TT> RSIZE_MAX.</TT>&nbsp; The number of characters (including the trailing null) required for the result to
be written to the array pointed to by<B> s</B> shall not be greater than<B> n</B>.&nbsp; The<TT> %n</TT> specifier (modified
or not by flags, field width, or precision) shall not appear in the string pointed to by<B> format</B>.&nbsp; Any argument
to<TT> vsprintf_s</TT> corresponding to a<TT> %s</TT> specifier shall not be a null pointer.&nbsp; No encoding error shall
occur.
<BR><BR>If there is a runtime-constraint violation, then if<B> s</B> is not a null pointer and<B> n</B> is greater than zero
and less than<TT> RSIZE_MAX,</TT> then the<TT> vsprintf_s</TT> function sets<B> s[0]</B> to the null character.
</DL>
<DL>
<DT>Description:
<DD>The<TT> vsprintf_s</TT> function is equivalent to the <TT> vsprintf</TT> function except for the explicit runtime-constraints
listed above.
<BR><BR>The<TT> vsprintf_s</TT> function, unlike <TT> vsnprintf_s</TT>, treats a result too big for the array pointed to by<B>
s</B> as a runtime-constraint violation.
<BR><BR>The<TT> vswprintf_s</TT> function is a wide-character version of<TT> vsprintf_s</TT>.&nbsp; It accepts a wide-character
string argument for<B> format</B> and produces wide character output.
</DL>
<DL>
<DT>Returns:
<DD>If no runtime-constraint violation occurred, the<TT> vsprintf_s</TT> function returns the number of characters written in
the array, not counting the terminating null character.&nbsp; If an encoding error occurred,<TT> vsprintf_s</TT> returns a
negative value.&nbsp; If any other runtime-constraint violation occurred,<TT> vsprintf_s</TT> returns zero.
<BR><BR>If no runtime-constraint violation occurred, the<TT> vswprintf_s</TT> function returns the number of wide characters
written in the array, not counting the terminating null wide character.&nbsp; If an encoding error occurred or if<B> n</B>
or more wide characters are requested to be written,<TT> vswprintf_s</TT> returns a negative value.&nbsp; If any other runtime-constraint
violation occurred,<TT> vswprintf_s</TT> returns zero.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_bprintf">_bprintf</A>, <A HREF="#cprintf">cprintf</A>, <A HREF="#fprintf">fprintf</A>, <A HREF="#printf">printf</A>,
<A HREF="#sprintf">sprintf</A>, <A HREF="#_vbprintf">_vbprintf</A>, <A HREF="#vcprintf">vcprintf</A>, <A HREF="#vfprintf">vfprintf</A>,
<A HREF="#vprintf">vprintf</A>, <A HREF="#vsprintf">vsprintf</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR>The following shows the use of<TT> vsprintf_s</TT> in a general error message routine.
<BR><BR><TT>#define __STDC_WANT_LIB_EXT1__ 1</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdarg.h&gt;</TT>
<BR><TT>#include &lt;string.h&gt;</TT>
<BR><BR><TT>char msgbuf[80];</TT>
<BR><BR><TT>char *fmtmsg( char *format, ... )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; va_list arglist;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; va_start( arglist, format );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; strcpy_s( msgbuf, sizeof( buffer ), &quot;Error: &quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; vsprintf_s( &amp;msgbuf[7], sizeof( msgbuf ) - 7,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; format, arglist );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; va_end( arglist );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; return( msgbuf );</TT>
<BR><TT>}</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char *msg;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; msg = fmtmsg( &quot;%s %d %s&quot;, &quot;Failed&quot;, 100, &quot;times&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, msg );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>TR 24731
</DL>
<DL>
<DT>Systems:
<DD><TT> vsprintf_s - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>vswprintf_s - All, Linux</TT>
</DL>
<H2 ID="vsscanf"> vsscanf, vswscanf </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdarg.h&gt;</TT>
<BR><TT>int vsscanf( const char *in_string,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *format,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_list arg );</TT>
<BR><TT>int vswscanf( const wchar_t *in_string,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t *format,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_list arg );</TT>
</DL>
<DL>
<DT>Safer C:
<DD>The Safer C Library extension provides the <A HREF="#vsscanf_s">vsscanf_s</A> function which is a safer alternative to<TT>
vsscanf</TT> This newer<TT> vsscanf_s</TT> function is recommended to be used instead of the traditional &quot;unsafe&quot;<TT>
vsscanf</TT> function.
</DL>
<DL>
<DT>Description:
<DD>The<TT> vsscanf</TT> function scans input from the string designated by<B> in_string</B> under control of the argument<B>
format</B>.&nbsp; The<B> format</B> string is described under the description of the <TT> scanf</TT> function.
<BR><BR>The<TT> vsscanf</TT> function is equivalent to the <TT> sscanf</TT> function, with a variable argument list replaced
with<B> arg</B>, which has been initialized using the <TT> va_start</TT> macro.
<BR><BR>The<TT> vswscanf</TT> function is identical to<TT> vsscanf</TT> except that it accepts a wide-character string argument
for<B> format</B>.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> vsscanf</TT> function returns <TT> EOF</TT> if the end of the input string was reached before any conversion.&nbsp;
Otherwise, the number of input arguments for which values were successfully scanned and stored is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#cscanf">cscanf</A>, <A HREF="#fscanf">fscanf</A>, <A HREF="#scanf">scanf</A>, <A HREF="#sscanf">sscanf</A>, <A HREF="#va_arg">va_arg</A>,
<A HREF="#va_end">va_end</A>, <A HREF="#va_start">va_start</A>, <A HREF="#vcscanf">vcscanf</A>, <A HREF="#vfscanf">vfscanf</A>,
<A HREF="#vscanf">vscanf</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdarg.h&gt;</TT>
<BR><BR><TT>void sfind( char *string, char *format, ... )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; va_list arglist;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; va_start( arglist, format );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; vsscanf( string, format, arglist );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; va_end( arglist );</TT>
<BR><TT>}</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int day, year;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char weekday[10], month[10];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; sfind( &quot;Saturday April 18 1987&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;%s %s %d %d&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; weekday, month, &amp;day, &amp;year );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;\n%s, %s %d, %d\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; weekday, month, day, year );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C99
</DL>
<DL>
<DT>Systems:
<DD><TT> vsscanf - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>vswscanf - All, Linux</TT>
</DL>
<H2 ID="vsscanf_s"> vsscanf_s, vswscanf_s </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__ 1</TT>
<BR><TT>#include &lt;stdarg.h&gt;</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>int vsscanf_s( const char * restrict s,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char * restrict format,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_list arg );</TT>
<BR><TT>#include &lt;stdarg.h&gt;</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>int vswscanf_s( const wchar_t * restrict s,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t * restrict
format,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_list arg );</TT>
</DL>
<DL>
<DT>Constraints:
<DD>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<TT>
vsscanf_s</TT> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<BR><BR>Neither<B> s</B> not<B> format</B> shall be a null pointer.&nbsp; Any argument indirected through in order to store
converted input shall not be a null pointer.
<BR><BR>If there is a runtime-constraint violation, the<TT> vsscanf_s</TT> function does not attempt to perform further input,
and it is unspecified to what extent<TT> vsscanf_s</TT> performed input before discovering the runtime-constraint violation.
</DL>
<DL>
<DT>Description:
<DD>The<TT> vsscanf_s</TT> function is equivalent to <TT> sscanf_s</TT>, with the variable argument list replaced by<B> arg</B>,
which shall have been initialized by the <TT> va_start</TT> macro (and possibly subsequent <TT> va_arg</TT> calls).&nbsp;
The<TT> vsscanf_s</TT> function does not invoke the <TT> va_end</TT> macro.
<BR><BR>The<TT> vswscanf_s</TT> function is identical to<TT> vsscanf_s</TT> except that it accepts wide-character string arguments
for<B> s</B> and<B> format</B>.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> vsscanf_s</TT> function returns <TT> EOF</TT> if an input failure occurred before any conversion or if there was a
runtime-constraint violation.&nbsp; Otherwise, the<TT> vsscanf_s</TT> function returns the number of input items successfully
assigned, which can be fewer than provided for, or even zero.
<BR><BR>When a file input error occurs, the <TT> errno</TT> global variable may be set.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#cscanf">cscanf</A>, <A HREF="#fscanf">fscanf</A>, <A HREF="#scanf">scanf</A>, <A HREF="#sscanf">sscanf</A>, <A HREF="#va_arg">va_arg</A>,
<A HREF="#va_end">va_end</A>, <A HREF="#va_start">va_start</A>, <A HREF="#vcscanf">vcscanf</A>, <A HREF="#vfscanf">vfscanf</A>,
<A HREF="#vscanf">vscanf</A>, <A HREF="#vsscanf">vsscanf</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__ 1</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdarg.h&gt;</TT>
<BR><BR><TT>void sfind( char *string, char *format, ... )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; va_list arglist;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; va_start( arglist, format );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; vsscanf_s( string, format, arglist );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; va_end( arglist );</TT>
<BR><TT>}</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int day, year;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char weekday[10], month[10];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; sfind( &quot;Friday August 0013 2004&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;%s %s %d %d&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; weekday, sizeof( weekday ),</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; month, sizeof( month ),</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;day, &amp;year );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf_s( &quot;\n%s, %s %d, %d\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; weekday, month, day, year );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>Friday, August 13, 2004</TT>
</DL>
<DL>
<DT>Classification:
<DD>TR 24731
</DL>
<DL>
<DT>Systems:
<DD><TT> vsscanf_s - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>vswscanf_s - All, Linux</TT>
</DL>
<H2 ID="wait"> wait </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;process.h&gt;</TT>
<BR><TT>int wait( int *status );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> wait</TT> function suspends the calling process until any of the caller's immediate child processes terminate.
<BR><BR>Under Win32, there is no parent-child relationship amongst processes so the<TT> wait</TT> function cannot and does
not wait for child processes to terminate.&nbsp; To wait for any process, you must specify its process ID.&nbsp; For this
reason, the <TT> cwait</TT> function should be used (one of its arguments is a process ID).
<BR><BR>If<B> status</B> is not<TT> NULL,</TT> it points to a word that will be filled in with the termination status word
and return code of the terminated child process.
<BR><BR>If the child process terminated normally, then the low order byte of the status word will be set to 0, and the high
order byte will contain the low order byte of the return code that the child process passed to the <TT> DOSEXIT</TT> function.
&nbsp;The <TT> DOSEXIT</TT> function is called whenever <TT> main</TT> returns, or <TT> exit</TT> , or <TT> _Exit</TT> or
<TT> _exit</TT> are explicity called.
<BR><BR>If the child process did not terminate normally, then the high order byte of the status word will be set to 0, and
the low order byte will contain one of the following values:
<DL>
<DT>Value&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>1
<DD>Hard-error abort
<DT>2
<DD>Trap operation
<DT>3
<DD>SIGTERM signal not intercepted
</DL>
<DL>
<DT>Note:
<DD>This implementation of the status value follows the OS/2 model and differs from the Microsoft implementation.&nbsp; Under
Microsoft, the return code is returned in the low order byte and it is not possible to determine whether a return code of
1, 2, or 3 imply that the process terminated normally.&nbsp; For portability to Microsoft compilers, you should ensure that
the application that is waited on does not return one of these values.&nbsp; The following shows how to handle the status
value in a portable manner.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; cwait( &amp;status, process_id, WAIT_CHILD );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #if defined(__WATCOMC__)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; switch( status &amp; 0xff ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; case 0:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Normal termination exit code = %d\n&quot;, status &gt;&gt;
8 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; case 1:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Hard-error abort\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; case 2:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Trap operation\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; case 3:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;SIGTERM signal not intercepted\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; default:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Bogus return status\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #else if defined(_MSC_VER)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; switch( status &amp; 0xff ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; case 1:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Possible Hard-error abort\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; case 2:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Possible Trap operation\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; case 3:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Possible SIGTERM signal not intercepted\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; default:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Normal termination exit code = %d\n&quot;, status );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #endif</TT>
</DL>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> wait</TT> function returns the child's process ID if the child process terminated normally.&nbsp; Otherwise,<TT> wait</TT>
returns -1 and sets <TT> errno</TT> to one of the following values:
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>ECHILD
<DD>No child processes exist for the calling process.
<DT>EINTR
<DD>The child process terminated abnormally.
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#cwait">cwait</A>, <A HREF="#exit">exit</A>, <A HREF="#_Exit">_Exit</A>, <A HREF="#_exit">_exit</A>, <A HREF="#spawn___">spawn...</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>#include &lt;process.h&gt;</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; process_id, status;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; process_id = spawnl( P_NOWAIT, &quot;child.exe&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;child&quot;, &quot;parm&quot;,
NULL );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; wait( &amp;status );</TT>
<BR><TT>&nbsp; }</TT>
</DL>
<DL>
<DT>Classification:
<DD>WATCOM
</DL>
<DL>
<DT>Systems:
<DD>Win32, OS/2 1.x(all), OS/2-32, Linux
</DL>
<H2 ID="wcrtomb"> wcrtomb, _fwcrtomb </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>int wcrtomb( char *s, wchar_t wc, mbstate_t *ps );</TT>
<BR><TT>int _fwcrtomb( char __far *s, wchar_t wc, mbstate_t __far *ps );</TT>
</DL>
<DL>
<DT>Safer C:
<DD>The Safer C Library extension provides the <A HREF="#wcrtomb_s">wcrtomb_s</A> function which is a safer alternative to<TT>
wcrtomb</TT> This newer<TT> wcrtomb_s</TT> function is recommended to be used instead of the traditional &quot;unsafe&quot;<TT>
wcrtomb</TT> function.
</DL>
<DL>
<DT>Description:
<DD>If<B> s</B> is a null pointer, the<TT> wcrtomb</TT> function determines the number of bytes necessary to enter the initial
shift state (zero if encodings are not state-dependent or if the initial conversion state is described).&nbsp; The resulting
state described will be the initial conversion state.
<BR><BR>If<B> s</B> is not a null pointer, the<TT> wcrtomb</TT> function determines the number of bytes needed to represent
the multibyte character that corresponds to the wide character given by<B> wc</B> (including any shift sequences), and stores
the resulting bytes in the array whose first element is pointed to by<B> s</B>.&nbsp; At most <TT> MB_CUR_MAX</TT> bytes will
be stored.&nbsp; If<B> wc</B> is a null wide character, the resulting state described will be the initial conversion state.
<BR><BR>The<TT> _fwcrtomb</TT> function is a data model independent form of the wcrtomb function that accepts far pointer
arguments.&nbsp; It is most useful in mixed memory model applications.
<BR><BR>The restartable multibyte/wide character conversion functions differ from the corresponding internal-state multibyte
character functions ( <TT> mblen</TT>, <TT> mbtowc</TT>, and <TT> wctomb</TT>) in that they have an extra argument,<B> ps</B>,
of type pointer to <TT> mbstate_t</TT> that points to an object that can completely describe the current conversion state
of the associated multibyte character sequence.&nbsp; If<B> ps</B> is a null pointer, each function uses its own internal
<TT> mbstate_t</TT> object instead.&nbsp; You are guaranteed that no other function in the library calls these functions with
a null pointer for<B> ps</B>, thereby ensuring the stability of the state.
<BR><BR>Also unlike their corresponding functions, the return value does not represent whether the encoding is state-dependent.
<BR><BR>If the encoding is state-dependent, on entry each function takes the described conversion state (either internal or
pointed to by<B> ps</B>) as current.&nbsp; The conversion state described by the pointed-to object is altered as needed to
track the shift state of the associated multibyte character sequence.&nbsp; For encodings without state dependency, the pointer
to the <TT> mbstate_t</TT> argument is ignored.
</DL>
<DL>
<DT>Returns:
<DD>If<B> s</B> is a null pointer, the<TT> wcrtomb</TT> function returns the number of bytes necessary to enter the initial shift
state.&nbsp; The value returned will not be greater than that of the <TT> MB_CUR_MAX</TT> macro.
<BR><BR>If<B> s</B> is not a null pointer, the<TT> wcrtomb</TT> function returns the number of bytes stored in the array object
(including any shift sequences) when<B> wc</B> is a valid wide character; otherwise (when<B> wc</B> is not a valid wide character),
an encoding error occurs, the value of the macro <TT> EILSEQ</TT> will be stored in <TT> errno</TT> and -1 will be returned,
but the conversion state will be unchanged.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_mbccmp">_mbccmp</A>, <A HREF="#_mbccpy">_mbccpy</A>, <A HREF="#_mbcicmp">_mbcicmp</A>, <A HREF="#_mbcjistojms">_mbcjistojms</A>,
<A HREF="#_mbcjmstojis">_mbcjmstojis</A>, <A HREF="#_mbclen">_mbclen</A>, <A HREF="#_mbctohira">_mbctohira</A>, <A HREF="#_mbctokata">_mbctokata</A>,
<A HREF="#_mbctolower">_mbctolower</A>, <A HREF="#_mbctombb">_mbctombb</A>, <A HREF="#_mbctoupper">_mbctoupper</A>, <A HREF="#mblen">mblen</A>,
<A HREF="#mbrlen">mbrlen</A>, <A HREF="#mbrtowc">mbrtowc</A>, <A HREF="#mbsrtowcs">mbsrtowcs</A>, <A HREF="#mbsrtowcs_s">mbsrtowcs_s</A>,
<A HREF="#mbstowcs">mbstowcs</A>, <A HREF="#mbstowcs_s">mbstowcs_s</A>, <A HREF="#mbtowc">mbtowc</A>, <A HREF="#btowc">btowc</A>,
<A HREF="#wcrtomb_s">wcrtomb_s</A>, <A HREF="#wcsrtombs">wcsrtombs</A>, <A HREF="#wcsrtombs_s">wcsrtombs_s</A>, <A HREF="#wcstombs">wcstombs</A>,
<A HREF="#wcstombs_s">wcstombs_s</A>, <A HREF="#wctob">wctob</A>, <A HREF="#wctomb">wctomb</A>, <A HREF="#wctomb_s">wctomb_s</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><TT>#include &lt;errno.h&gt;</TT>
<BR><BR><TT>const wchar_t wc[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x0020,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x002e,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x0031,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x0041,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x3000,&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte space */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xff21,&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte A */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x3048,&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte Hiragana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x30a3,&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte Katakana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xff61,&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana punctuation */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xff66,&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xff9f,&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x720d,&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte Kanji */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x0000</TT>
<BR><TT>};</TT>
<BR><BR><TT>#define SIZE sizeof( wc ) / sizeof( wchar_t )</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i, j, k;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s[2];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; i = wcrtomb( NULL, 0, NULL );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Number of bytes to enter &quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;initial shift state = %d\n&quot;, i );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; j = 1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j = wcrtomb( s, wc[i], NULL );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%d bytes in character &quot;, j );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( errno == EILSEQ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot; - illegal wide character\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( j == 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if ( j == 1 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = s[0];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if( j == 2 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = s[0]&lt;&lt;8 | s[1];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;(%#6.4x-&gt;%#6.4x)\n&quot;, wc[i], k );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>Number of bytes to enter initial shift state = 0</TT>
<BR><TT>1 bytes in character (0x0020-&gt;0x0020)</TT>
<BR><TT>1 bytes in character (0x002e-&gt;0x002e)</TT>
<BR><TT>1 bytes in character (0x0031-&gt;0x0031)</TT>
<BR><TT>1 bytes in character (0x0041-&gt;0x0041)</TT>
<BR><TT>2 bytes in character (0x3000-&gt;0x8140)</TT>
<BR><TT>2 bytes in character (0xff21-&gt;0x8260)</TT>
<BR><TT>2 bytes in character (0x3048-&gt;0x82a6)</TT>
<BR><TT>2 bytes in character (0x30a3-&gt;0x8342)</TT>
<BR><TT>1 bytes in character (0xff61-&gt;0x00a1)</TT>
<BR><TT>1 bytes in character (0xff66-&gt;0x00a6)</TT>
<BR><TT>1 bytes in character (0xff9f-&gt;0x00df)</TT>
<BR><TT>2 bytes in character (0x720d-&gt;0xe0a1)</TT>
<BR><TT>1 bytes in character (&nbsp; 0000-&gt;0x0069)</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>_fwcrtomb is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> wcrtomb - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, Linux, RDOS</TT>
<BR><BR><TT>_fwcrtomb - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="wcrtomb_s"> wcrtomb_s, _fwcrtomb_s </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__&nbsp; 1</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>errno_t wcrtomb_s( size_t * restrict retval,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char
* restrict s, rsize_t smax,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t
wc, mbstate_t * restrict ps);</TT>
<BR><BR><TT>errno_t _wcrtomb_s( size_t __far * restrict retval,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char
__far * restrict s, rsize_t smax,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t
wc, mbstate_t __far * restrict ps);</TT>
</DL>
<DL>
<DT>Constraints:
<DD>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<TT>
wcrtomb_s</TT> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<BR><BR>Neither<B> retval</B> nor<B> ps</B> shall be a null pointer.&nbsp; If<B> s</B> is not a null pointer, then<B> smax</B>
shall not equal zero and shall not be greater than <TT> RSIZE_MAX</TT>.&nbsp; If<B> s</B> is not a null pointer, then<B> smax</B>
shall be not be less than the number of bytes to be stored in the array pointed to by<B> s</B>.&nbsp; If<B> s</B> is a null
pointer, then<B> smax</B> shall equal zero.
<BR><BR>If there is a runtime-constraint violation, then<TT> wcrtomb_s</TT> does the following.&nbsp; If<B> s</B> is not a
null pointer and<B> smax</B> is greater than zero and not greater than <TT> RSIZE_MAX</TT>, then<TT> wcrtomb_s</TT> sets<B>
s[0]</B> to the null character.&nbsp; If<B> retval</B> is not a null pointer, then <TT> wcrtomb_s</TT> sets<B> *retval</B>
to (size_t)(-1).
</DL>
<DL>
<DT>Description:
<DD>If<B> s</B> is a null pointer, the<TT> wcrtomb_s</TT> function is equivalent to the call
<BR><BR>wcrtomb_s(&amp;retval, buf, sizeof buf, L'\0', ps)
<BR>where<B> retval</B> and<B> buf</B> are internal variables of the appropriate types, and the size of<B> buf</B> is greater
than MB_CUR_MAX.
<BR>If<B> s</B> is not a null pointer, the<TT> wcrtomb_s</TT> function determines the number of bytes needed to represent
the multibyte character that corresponds to the wide character given by<B> wc</B> (including any shift sequences), and stores
the multibyte character representation in the array whose first element is pointed to by<B> s</B>.&nbsp; At most <TT> MB_CUR_MAX</TT>
bytes are stored.&nbsp; If<B> wc</B> is a null wide character, a null byte is stored, preceded by any shift sequence needed
to restore the initial shift state; the resulting state described is the initial conversion state.
<BR><BR>If<B> wc</B> does not correspond to a valid multibyte character, an encoding error occurs:&nbsp; the<TT> wcrtomb_s</TT>
function stores the value (size_t)(-1) into<B> *retval</B> and the conversion state is unspecified.&nbsp; Otherwise, the<TT>
wcrtomb_s</TT> function stores into<B> *retval</B> the number of bytes (including any shift sequences) stored in the array
pointed to by<B> s</B>.
<BR><BR>The function is a data model independent form of the wcrtomb_s function that accepts far pointer arguments.&nbsp;
It is most useful in mixed memory model applications.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> wcrtomb_s</TT> function returns zero if there was no runtime-constraint violation.&nbsp; Otherwise, a non-zero value
is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_mbccmp">_mbccmp</A>, <A HREF="#_mbccpy">_mbccpy</A>, <A HREF="#_mbcicmp">_mbcicmp</A>, <A HREF="#_mbcjistojms">_mbcjistojms</A>,
<A HREF="#_mbcjmstojis">_mbcjmstojis</A>, <A HREF="#_mbclen">_mbclen</A>, <A HREF="#_mbctohira">_mbctohira</A>, <A HREF="#_mbctokata">_mbctokata</A>,
<A HREF="#_mbctolower">_mbctolower</A>, <A HREF="#_mbctombb">_mbctombb</A>, <A HREF="#_mbctoupper">_mbctoupper</A>, <A HREF="#mblen">mblen</A>,
<A HREF="#mbrlen">mbrlen</A>, <A HREF="#mbrtowc">mbrtowc</A>, <A HREF="#mbsrtowcs">mbsrtowcs</A>, <A HREF="#mbsrtowcs_s">mbsrtowcs_s</A>,
<A HREF="#mbstowcs">mbstowcs</A>, <A HREF="#mbstowcs_s">mbstowcs_s</A>, <A HREF="#mbtowc">mbtowc</A>, <A HREF="#btowc">btowc</A>,
<A HREF="#wcrtomb">wcrtomb</A>, <A HREF="#wcsrtombs">wcsrtombs</A>, <A HREF="#wcsrtombs_s">wcsrtombs_s</A>, <A HREF="#wcstombs">wcstombs</A>,
<A HREF="#wcstombs_s">wcstombs_s</A>, <A HREF="#wctob">wctob</A>, <A HREF="#wctomb">wctomb</A>, <A HREF="#wctomb_s">wctomb_s</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__&nbsp; 1</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><TT>#include &lt;errno.h&gt;</TT>
<BR><BR><TT>const wchar_t wc[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x0020,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x002e,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x0031,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x0041,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x3000,&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte space */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xff21,&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte A */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x3048,&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte Hiragana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x30a3,&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte Katakana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xff61,&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana punctuation */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xff66,&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xff9f,&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x720d,&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte Kanji */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x0000</TT>
<BR><TT>};</TT>
<BR><BR><TT>#define SIZE sizeof( wc ) / sizeof( wchar_t )</TT>
<BR><BR><TT>int main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i, j, k;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s[2];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; errno_t&nbsp;&nbsp;&nbsp;&nbsp; rc;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; size_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; retval;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; mbstate_t&nbsp;&nbsp; state;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; j = 1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc = wcrtomb_s( &amp;retval, s, 2, wc[i], &amp;state );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( rc != 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot; - illegal wide character\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%d bytes in character &quot;, retval );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( retval == 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if ( retval == 1 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = s[0];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if( retval == 2 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = s[0]&lt;&lt;8 | s[1];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;(%#6.4x-&gt;%#6.4x)\n&quot;, wc[i], k );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; return( 0 );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>1 bytes in character (0x0020-&gt;0x0020)</TT>
<BR><TT>1 bytes in character (0x002e-&gt;0x002e)</TT>
<BR><TT>1 bytes in character (0x0031-&gt;0x0031)</TT>
<BR><TT>1 bytes in character (0x0041-&gt;0x0041)</TT>
<BR><TT>2 bytes in character (0x3000-&gt;0x8140)</TT>
<BR><TT>2 bytes in character (0xff21-&gt;0x8260)</TT>
<BR><TT>2 bytes in character (0x3048-&gt;0x82a6)</TT>
<BR><TT>2 bytes in character (0x30a3-&gt;0x8342)</TT>
<BR><TT>1 bytes in character (0xff61-&gt;0x00a1)</TT>
<BR><TT>1 bytes in character (0xff66-&gt;0x00a6)</TT>
<BR><TT>1 bytes in character (0xff9f-&gt;0x00df)</TT>
<BR><TT>2 bytes in character (0x720d-&gt;0xe0a1)</TT>
<BR><TT>1 bytes in character (&nbsp; 0000-&gt;0x0069)</TT>
</DL>
<DL>
<DT>Classification:
<DD>TR 24731
<BR><BR>_fwcrtomb_s is s WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> wcrtomb_s - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, Linux, RDOS</TT>
<BR><BR><TT>_fwcrtomb_s - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="wcsrtombs"> wcsrtombs, _fwcsrtombs </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>size_t wcsrtombs( char *dst,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t **src,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t n, mbstate_t *ps );</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>size_t _fwcsrtombs( char __far *dst,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t __far * __far *src,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t n, mbstate_t __far *ps );</TT>
</DL>
<DL>
<DT>Safer C:
<DD>The Safer C Library extension provides the <A HREF="#wcsrtombs_s">wcsrtombs_s</A> function which is a safer alternative to<TT>
wcsrtombs</TT> This newer<TT> wcsrtombs_s</TT> function is recommended to be used instead of the traditional &quot;unsafe&quot;<TT>
wcsrtombs</TT> function.
</DL>
<DL>
<DT>Description:
<DD>The<TT> wcsrtombs</TT> function converts a sequence of wide characters from the array indirectly pointed to by<B> src</B>
into a sequence of corresponding multibyte characters that begins in the shift state described by<B> ps</B>, which, if<B>
dst</B> is not a null pointer, are then stored into the array pointed to by<B> dst</B>.&nbsp; Conversion continues up to and
including a terminating null wide character, but the terminating null character (byte) will not be stored.&nbsp; Conversion
will stop earlier in two cases:&nbsp; when a code is reached that does not correspond to a valid multibyte character, or (if<B>
dst</B> is not a null pointer) when the next multibyte character would exceed the limit of<B> len</B> total bytes to be stored
into the array pointed to by<B> dst</B>.&nbsp; Each conversion takes place as if by a call to the <TT> wcrtomb</TT> function.
<BR><BR>If<B> dst</B> is not a null pointer, the pointer object pointed to by<B> src</B> will be assigned either a null pointer
(if conversion stopped due to reaching a terminating null wide character) or the address just past the last wide character
converted.&nbsp; If conversion stopped due to reaching a terminating null wide character and if<B> dst</B> is not a null pointer,
the resulting state described will be the initial conversion state.
<BR><BR>The<TT> _fwcsrtombs</TT> function is a data model independent form of the wcsrtombs function that accepts far pointer
arguments.&nbsp; It is most useful in mixed memory model applications.
<BR><BR>The restartable multibyte/wide string conversion functions differ from the corresponding internal-state multibyte
string functions ( <TT> mbstowcs</TT> and <TT> wcstombs</TT>) in that they have an extra argument,<B> ps</B>, of type pointer
to <TT> mbstate_t</TT> that points to an object that can completely describe the current conversion state of the associated
multibyte character sequence.&nbsp; If<B> ps</B> is a null pointer, each function uses its own internal <TT> mbstate_t</TT>
object instead.&nbsp; You are guaranteed that no other function in the library calls these functions with a null pointer for<B>
ps</B>, thereby ensuring the stability of the state.
<BR><BR>Also unlike their corresponding functions, the conversion source argument,<B> src</B>, has a pointer-to-pointer type.
&nbsp;When the function is storing conversion results (that is, when<B> dst</B> is not a null pointer), the pointer object
pointed to by this argument will be updated to reflect the amount of the source processed by that invocation.
<BR><BR>If the encoding is state-dependent, on entry each function takes the described conversion state (either internal or
pointed to by<B> ps</B>) as current and then, if the destination pointer,<B> dst</B>, is not a null pointer, the conversion
state described by the pointed-to object is altered as needed to track the shift state of the associated multibyte character
sequence.&nbsp; For encodings without state dependency, the pointer to the <TT> mbstate_t</TT> argument is ignored.
</DL>
<DL>
<DT>Returns:
<DD>If the first code is not a valid wide character, an encoding error occurs:&nbsp; The<TT> wcsrtombs</TT> function stores the
value of the macro <TT> EILSEQ</TT> in <TT> errno</TT> and returns<TT> (size_t)-1,</TT> but the conversion state will be unchanged.
&nbsp;Otherwise, it returns the number of bytes in the resulting multibyte characters sequence, which is the same as the number
of array elements modified when<B> dst</B> is not a null pointer.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_mbccmp">_mbccmp</A>, <A HREF="#_mbccpy">_mbccpy</A>, <A HREF="#_mbcicmp">_mbcicmp</A>, <A HREF="#_mbcjistojms">_mbcjistojms</A>,
<A HREF="#_mbcjmstojis">_mbcjmstojis</A>, <A HREF="#_mbclen">_mbclen</A>, <A HREF="#_mbctohira">_mbctohira</A>, <A HREF="#_mbctokata">_mbctokata</A>,
<A HREF="#_mbctolower">_mbctolower</A>, <A HREF="#_mbctombb">_mbctombb</A>, <A HREF="#_mbctoupper">_mbctoupper</A>, <A HREF="#mblen">mblen</A>,
<A HREF="#mbrlen">mbrlen</A>, <A HREF="#mbrtowc">mbrtowc</A>, <A HREF="#mbsrtowcs">mbsrtowcs</A>, <A HREF="#mbsrtowcs_s">mbsrtowcs_s</A>,
<A HREF="#mbstowcs">mbstowcs</A>, <A HREF="#mbstowcs_s">mbstowcs_s</A>, <A HREF="#mbtowc">mbtowc</A>, <A HREF="#btowc">btowc</A>,
<A HREF="#wcrtomb">wcrtomb</A>, <A HREF="#wcrtomb_s">wcrtomb_s</A>, <A HREF="#wcsrtombs_s">wcsrtombs_s</A>, <A HREF="#wcstombs">wcstombs</A>,
<A HREF="#wcstombs_s">wcstombs_s</A>, <A HREF="#wctob">wctob</A>, <A HREF="#wctomb">wctomb</A>, <A HREF="#wctomb_s">wctomb_s</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><TT>#include &lt;errno.h&gt;</TT>
<BR><BR><TT>const wchar_t wc[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x0020,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x002e,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x0031,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x0041,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x3000,&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte space */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xff21,&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte A */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x3048,&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte Hiragana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x30a3,&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte Katakana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xff61,&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana punctuation */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xff66,&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xff9f,&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x720d,&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte Kanji */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x0000</TT>
<BR><TT>};</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; size_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elements;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; const wchar_t&nbsp;&nbsp; *src;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mb[50];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; mbstate_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pstate;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; src = wc;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; elements = wcsrtombs( mb, &amp;src, 50, &amp;pstate );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( errno == EILSEQ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Error in wide character string\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; elements; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;0x%2.2x\n&quot;, mb[i] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>0x20</TT>
<BR><TT>0x2e</TT>
<BR><TT>0x31</TT>
<BR><TT>0x41</TT>
<BR><TT>0x81</TT>
<BR><TT>0x40</TT>
<BR><TT>0x82</TT>
<BR><TT>0x60</TT>
<BR><TT>0x82</TT>
<BR><TT>0xa6</TT>
<BR><TT>0x83</TT>
<BR><TT>0x42</TT>
<BR><TT>0xa1</TT>
<BR><TT>0xa6</TT>
<BR><TT>0xdf</TT>
<BR><TT>0xe0</TT>
<BR><TT>0xa1</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>_fwcsrtombs is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> wcsrtombs - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, Linux, RDOS</TT>
<BR><BR><TT>_fwcsrtombs - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="wcsrtombs_s"> wcsrtombs_s, _fwcsrtombs_s </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__ 1</TT>
<BR><TT>errno_t wcsrtombs_s( size_t * restrict retval,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;char * restrict dst,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;rsize_t dstmax,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;const wchar_t ** restrict src,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;rsize_t len,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;mbstate_t * restrict ps);</TT>
<BR><TT>errno_t _fwcsrtombs_s( size_t __far * restrict retval,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; char __far * restrict dst,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; rsize_t dstmax,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; const wchar_t __far * __far * restrict src,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; rsize_t len,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; mbstate_t __far * restrict ps);</TT>
</DL>
<DL>
<DT>Constraints:
<DD>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<TT>
wcsrtombs_s</TT> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<BR><BR>None of<B> retval</B>,<B> src</B>,<B> *src</B>, or<B> ps</B> shall be null pointers.&nbsp; If<B> dst</B> is not a
null pointer, then neither<B> len</B> nor<B> dstmax</B> shall be greater than <TT> RSIZE_MAX</TT>.&nbsp; If<B> dst</B> is
a null pointer, then<B> dstmax</B> shall equal zero.&nbsp; If<B> dst</B> is not a null pointer,then<B> dstmax</B> shall not
equal zero.&nbsp; If<B> dst</B> is not a null pointer and<B> len</B> is not less than<B> dstmax</B>, then the conversion shall
have been stopped (see below) because a terminating null wide character was reached or because an encoding error occurred.
<BR><BR>If there is a runtime-constraint violation, then<TT> wcsrtombs_s</TT> does the following.&nbsp; If<B> retval</B> is
not a null pointer,then<TT> wcsrtombs_s</TT> sets<B> *retval</B> to (size_t)(-1).&nbsp; If<B> dst</B> is not a null pointer
and<B> dstmax</B> is greater than zero and less than <TT> RSIZE_MAX</TT>, then<TT> wcsrtombs_s</TT> sets<B> dst[0]</B> to
the null character.
</DL>
<DL>
<DT>Description:
<DD>The<TT> wcsrtombs_s</TT> function converts a sequence of wide characters from the array indirectly pointed to by<B> src</B>
into a sequence of corresponding multibyte characters that begins in the conversion state described by the object pointed
to by<B> ps</B>.&nbsp; If<B> dst</B> is not a null pointer, the converted characters are then stored into the array pointed
to by<B> dst</B>.&nbsp; Conversion continues up to and including a terminating null wide character, which is also stored.
<BR><BR>Conversion stops earlier in two cases:
<UL>
<LI>when a wide character is reached that does not correspond to a valid multibyte character;
<LI>(if<B> dst</B> is not a null pointer) when the next multibyte character would exceed the limit of n total bytes to be
stored into the array pointed to by<B> dst</B>.&nbsp; If the wide character being converted is the null wide character, then
n is the lesser of<B> len</B> or<B> dstmax</B>.&nbsp; Otherwise, n is the lesser of<B> len</B> or<B> dstmax-1</B>.
</UL>
<BR>If the conversion stops without converting a null wide character and<B> dst</B> is not a null pointer, then a null character
is stored into the array pointed to by<B> dst</B> immediately following any multibyte characters already stored.&nbsp; Each
conversion takes place as if by a call to the <TT> wcrtomb</TT> function.
<BR><BR>If<B> dst</B> is not a null pointer, the pointer object pointed to by<B> src</B> is assigned either a null pointer
(if conversion stopped due to reaching a terminating null wide character) or the address just past the last wide character
converted (if any).&nbsp; If conversion stopped due to reaching a terminating null wide character, the resulting state described
is the initial conversion state.
<BR><BR>Regardless of whether<B> dst</B> is or is not a null pointer, if the input conversion encounters a wide character
that does not correspond to a valid multibyte character, an encoding error occurs:&nbsp; the<TT> wcsrtombs_s</TT> function
stores the value (size_t)(-1) into<B> *retval</B> and the conversion state is unspecified.&nbsp; Otherwise, the<TT> wcsrtombs_s</TT>
function stores into<B> *retval</B> the number of bytes in the resulting multibyte character sequence, not including the terminating
null character (if any).
<BR><BR>All elements following the terminating null character (if any) written by wcsrtombs_s in the array of<B> dstmax</B>
elements pointed to by<B> dst</B> take unspecified values when<TT> wcsrtombs_s</TT> returns.
<BR><BR>If copying takes place between objects that overlap, the objects take on unspecified values.
<BR><BR>The function is a data model independent form of the wcsrtombs_s function that accepts far pointer arguments.&nbsp;
It is most useful in mixed memory model applications.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> wcsrtombs_s</TT> function returns zero if there was no runtime-constraint violation.&nbsp; Otherwise, a non-zero value
is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_mbccmp">_mbccmp</A>, <A HREF="#_mbccpy">_mbccpy</A>, <A HREF="#_mbcicmp">_mbcicmp</A>, <A HREF="#_mbcjistojms">_mbcjistojms</A>,
<A HREF="#_mbcjmstojis">_mbcjmstojis</A>, <A HREF="#_mbclen">_mbclen</A>, <A HREF="#_mbctohira">_mbctohira</A>, <A HREF="#_mbctokata">_mbctokata</A>,
<A HREF="#_mbctolower">_mbctolower</A>, <A HREF="#_mbctombb">_mbctombb</A>, <A HREF="#_mbctoupper">_mbctoupper</A>, <A HREF="#mblen">mblen</A>,
<A HREF="#mbrlen">mbrlen</A>, <A HREF="#mbrtowc">mbrtowc</A>, <A HREF="#mbsrtowcs">mbsrtowcs</A>, <A HREF="#mbsrtowcs_s">mbsrtowcs_s</A>,
<A HREF="#mbstowcs">mbstowcs</A>, <A HREF="#mbstowcs_s">mbstowcs_s</A>, <A HREF="#mbtowc">mbtowc</A>, <A HREF="#btowc">btowc</A>,
<A HREF="#wcrtomb">wcrtomb</A>, <A HREF="#wcrtomb_s">wcrtomb_s</A>, <A HREF="#wcsrtombs">wcsrtombs</A>, <A HREF="#wcstombs">wcstombs</A>,
<A HREF="#wcstombs_s">wcstombs_s</A>, <A HREF="#wctob">wctob</A>, <A HREF="#wctomb">wctomb</A>, <A HREF="#wctomb_s">wctomb_s</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__ 1</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><TT>#include &lt;errno.h&gt;</TT>
<BR><BR><TT>const wchar_t wc[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x0020,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x002e,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x0031,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x0041,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x3000,&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte space */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xff21,&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte A */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x3048,&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte Hiragana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x30a3,&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte Katakana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xff61,&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana punctuation */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xff66,&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xff9f,&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x720d,&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte Kanji */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x0000</TT>
<BR><TT>};</TT>
<BR><BR><TT>int main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; size_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; retval;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; const wchar_t&nbsp;&nbsp; *src;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mb[50];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; mbstate_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pstate;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; errno_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; src = wc;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; rc = wcsrtombs_s( &amp;retval, mb, 50, &amp;src, sizeof(wc), &amp;pstate );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( rc != 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Error in wide character string\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; retval; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;0x%2.2x\n&quot;, mb[i] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; return( rc );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>0x20</TT>
<BR><TT>0x2e</TT>
<BR><TT>0x31</TT>
<BR><TT>0x41</TT>
<BR><TT>0x81</TT>
<BR><TT>0x40</TT>
<BR><TT>0x82</TT>
<BR><TT>0x60</TT>
<BR><TT>0x82</TT>
<BR><TT>0xa6</TT>
<BR><TT>0x83</TT>
<BR><TT>0x42</TT>
<BR><TT>0xa1</TT>
<BR><TT>0xa6</TT>
<BR><TT>0xdf</TT>
<BR><TT>0xe0</TT>
<BR><TT>0xa1</TT>
</DL>
<DL>
<DT>Classification:
<DD>TR 24731
<BR><BR>_fwcsrtombs_s is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> wcsrtombs_s - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, Linux, RDOS</TT>
<BR><BR><TT>_fwcsrtombs_s - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="wcstombs"> wcstombs, _fwcstombs </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>size_t wcstombs( char *s, const wchar_t *pwcs, size_t n );</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>size_t _fwcstombs( char __far *s,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const
wchar_t __far *pwcs,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t
n );</TT>
</DL>
<DL>
<DT>Safer C:
<DD>The Safer C Library extension provides the <A HREF="#wcstombs_s">wcstombs_s</A> function which is a safer alternative to<TT>
wcstombs</TT> This newer<TT> wcstombs_s</TT> function is recommended to be used instead of the traditional &quot;unsafe&quot;<TT>
wcstombs</TT> function.
</DL>
<DL>
<DT>Description:
<DD>The<TT> wcstombs</TT> function converts a sequence of wide character codes from the array pointed to by<B> pwcs</B> into a
sequence of multibyte characters and stores them in the array pointed to by<B> s</B>.&nbsp; The<TT> wcstombs</TT> function
stops if a multibyte character would exceed the limit of<B> n</B> total bytes, or if the null character is stored.&nbsp; At
most<B> n</B> bytes of the array pointed to by<B> s</B> will be modified.
<BR><BR>The<TT> _fwcstombs</TT> function is a data model independent form of the wcstombs function that accepts far pointer
arguments.&nbsp; It is most useful in mixed memory model applications.
</DL>
<DL>
<DT>Returns:
<DD>If an invalid multibyte character is encountered, the<TT> wcstombs</TT> function returns<TT> (size_t)-1.</TT>&nbsp; Otherwise,
the<TT> wcstombs</TT> function returns the number of array elements modified, not including the terminating zero code if present.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#wcstombs_s">wcstombs_s</A>, <A HREF="#mblen">mblen</A>, <A HREF="#mbtowc">mbtowc</A>, <A HREF="#mbstowcs">mbstowcs</A>,
<A HREF="#mbstowcs_s">mbstowcs_s</A>, <A HREF="#wctomb">wctomb</A>, <A HREF="#wctomb_s">wctomb_s</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>wchar_t wbuffer[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x0073,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x0074,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x0072,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x0069,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x006e,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x0067,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x0000</TT>
<BR><TT>&nbsp; };</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; mbsbuffer[50];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; i, len;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; len = wcstombs( mbsbuffer, wbuffer, 50 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( len != -1 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; len; i++ )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;/%4.4x&quot;, wbuffer[i] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mbsbuffer[len] = '\0';</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%s(%d)\n&quot;, mbsbuffer, len );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>/0073/0074/0072/0069/006e/0067</TT>
<BR><TT>string(6)</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>_fwcstombs is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> wcstombs - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_fwcstombs - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="wcstombs_s"> wcstombs_s, _fwcstombs_s </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__ 1</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>errno_t wcstombs_s( size_t * restrict retval,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
char * restrict dst,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
rsize_t dstmax,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const wchar_t * restrict src,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
rsize_t len);</TT>
<BR><BR><TT>errno_t _fwcstombs_s( size_t __far * restrict retval,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; char __far * restrict dst,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; rsize_t dstmax,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; const wchar_t __far * restrict src,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; rsize_t len);</TT>
</DL>
<DL>
<DT>Constraints:
<DD>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<TT>
wcstombs_s</TT> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<BR><BR>Neither<B> retval</B> nor<B> src</B> shall be a null pointer.&nbsp; If<B> dst</B> is not a null pointer, then neither<B>
len</B> nor<B> dstmax</B> shall be greater than <TT> RSIZE_MAX</TT>.&nbsp; If<B> dst</B> is a null pointer, then<B> dstmax</B>
shall equal zero.&nbsp; If<B> dst</B> is not a null pointer,then<B> dstmax</B> shall not equal zero.&nbsp; If<B> dst</B> is
not a null pointer and<B> len</B> is not less than<B> dstmax</B>, then the conversion shall have been stopped (see below)
because a terminating null wide character was reached or because an encoding error occurred.
<BR><BR>If there is a runtime-constraint violation, then<TT> wcstombs_s</TT> does the following.&nbsp; If<B> retval</B> is
not a null pointer,then<TT> wcstombs_s</TT> sets<B> *retval</B> to (size_t)(-1).&nbsp; If<B> dst</B> is not a null pointer
and<B> dstmax</B> is greater than zero and less than <TT> RSIZE_MAX</TT>, then<TT> wcstombs_s</TT> sets<B> dst[0]</B> to the
null character.
</DL>
<DL>
<DT>Description:
<DD>The<TT> wcstombs_s</TT> function converts a sequence of wide characters from the array pointed to by<B> src</B> into a sequence
of corresponding multibyte characters that begins in the initial shift state.&nbsp; If<B> dst</B> is not a null pointer,the
converted characters are then stored into the array pointed to by<B> dst</B>.&nbsp; Conversion continues up to and including
a terminating null wide character, which is also stored.
<BR><BR>Conversion stops earlier in two cases:
<BR><BR>when a wide character is reached that does not correspond to a valid multibyte character;
<BR>(if<B> dst</B> is not a null pointer) when the next multibyte character would exceed the limit of<B> n</B> total bytes
to be stored into the array pointed to by<B> dst</B>.&nbsp; If the wide character being converted is the null wide character,
then<B> n</B> is the lesser of<B> len</B> or<B> dstmax</B>.&nbsp; Otherwise,<B> n</B> is the lesser of<B> len</B> or<B> dstmax-1</B>.
<BR>If the conversion stops without converting a null wide character and<B> dst</B> is not a null pointer, then a null character
is stored into the array pointed to by<B> dst</B> immediately following any multibyte characters already stored.&nbsp; Each
conversion takes place as if by a call to the wcrtomb function.
<BR><BR>Regardless of whether<B> dst</B> is or is not a null pointer, if the input conversion encounters a wide character
that does not correspond to a valid multibyte character, an encoding error occurs:&nbsp; the<TT> wcstombs_s</TT> function
stores the value (size_t)(-1) into<B> *retval</B>.&nbsp; Otherwise, the<TT> wcstombs_s</TT> function stores into<B> *retval</B>
the number of bytes in the resulting multibyte character sequence, not including the terminating null character (if any).
<BR><BR>All elements following the terminating null character (if any) written by wcstombs_s in the array of<B> dstmax</B>
elements pointed to by<B> dst</B> take unspecified values when<TT> wcstombs_s</TT> returns.
<BR><BR>If copying takes place between objects that overlap, the objects take on unspecified values.
<BR><BR>The function is a data model independent form of the wcstombs_s function that accepts far pointer arguments.&nbsp;
It is most useful in mixed memory model applications.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> wcstombs_s</TT> function returns zero if there was no runtime-constraint violation.&nbsp; Otherwise, a non-zero value
is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#wcstombs">wcstombs</A>, <A HREF="#mblen">mblen</A>, <A HREF="#mbtowc">mbtowc</A>, <A HREF="#mbstowcs">mbstowcs</A>,
<A HREF="#mbstowcs_s">mbstowcs_s</A>, <A HREF="#wctomb">wctomb</A>, <A HREF="#wctomb_s">wctomb_s</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__ 1</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>wchar_t wbuffer[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x0073,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x0074,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x0072,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x0069,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x006e,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x0067,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x0073,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x0074,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x0072,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x0069,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x006e,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x0067,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x0000</TT>
<BR><TT>&nbsp; };</TT>
<BR><BR><TT>int main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; mbsbuffer[50];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; i;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; size_t&nbsp; retval;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; errno_t rc;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; rc = wcstombs_s( &amp;retval, mbsbuffer, 50, wbuffer, sizeof( wbuffer ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( rc == 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; retval; i++ )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;/%4.4x&quot;, wbuffer[i] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mbsbuffer[retval] = '\0';</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%s(%d)\n&quot;, mbsbuffer, retval );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; return( rc );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>/0073/0074/0072/0069/006e/0067</TT>
<BR><TT>string(6)</TT>
</DL>
<DL>
<DT>Classification:
<DD>TR 24731
<BR><BR>_fwcstombs_s is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> wcstombs_s - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_fwcstombs_s - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="wctob"> wctob </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>int wctob( wint_t wc );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> wctob</TT> function determines whether<B> wc</B> corresponds to a member of the extended character set whose multibyte
character representation is as a single byte when in the initial shift state.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> wctob</TT> function returns <TT> EOF</TT> if<B> wc</B> does not correspond to a multibyte character with length one;
otherwise, it returns the single byte representation.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_mbccmp">_mbccmp</A>, <A HREF="#_mbccpy">_mbccpy</A>, <A HREF="#_mbcicmp">_mbcicmp</A>, <A HREF="#_mbcjistojms">_mbcjistojms</A>,
<A HREF="#_mbcjmstojis">_mbcjmstojis</A>, <A HREF="#_mbclen">_mbclen</A>, <A HREF="#_mbctohira">_mbctohira</A>, <A HREF="#_mbctokata">_mbctokata</A>,
<A HREF="#_mbctolower">_mbctolower</A>, <A HREF="#_mbctombb">_mbctombb</A>, <A HREF="#_mbctoupper">_mbctoupper</A>, <A HREF="#mblen">mblen</A>,
<A HREF="#mbrlen">mbrlen</A>, <A HREF="#mbrtowc">mbrtowc</A>, <A HREF="#mbsrtowcs">mbsrtowcs</A>, <A HREF="#mbsrtowcs_s">mbsrtowcs_s</A>,
<A HREF="#mbstowcs">mbstowcs</A>, <A HREF="#mbstowcs_s">mbstowcs_s</A>, <A HREF="#mbtowc">mbtowc</A>, <A HREF="#btowc">btowc</A>,
<A HREF="#wcrtomb">wcrtomb</A>, <A HREF="#wcrtomb_s">wcrtomb_s</A>, <A HREF="#wcsrtombs">wcsrtombs</A>, <A HREF="#wcsrtombs_s">wcsrtombs_s</A>,
<A HREF="#wcstombs">wcstombs</A>, <A HREF="#wcstombs_s">wcstombs_s</A>, <A HREF="#wctomb">wctomb</A>, <A HREF="#wctomb_s">wctomb_s</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><TT>#include &lt;mbctype.h&gt;</TT>
<BR><BR><TT>const wint_t wc[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x0020,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x002e,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x0031,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x0041,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x3000,&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte space */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xff21,&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte A */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x3048,&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte Hiragana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x30a3,&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte Katakana */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xff61,&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana punctuation */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xff66,&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0xff9f,&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x720d,&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte Kanji */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; 0x0000</TT>
<BR><TT>};</TT>
<BR><BR><TT>#define SIZE sizeof( wc ) / sizeof( wchar_t )</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i, j;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j = wctob( wc[i] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( j == EOF ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x EOF\n&quot;, wc[i] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x-&gt;%#6.4x\n&quot;, wc[i], j );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>0x0020-&gt;0x0020</TT>
<BR><TT>0x002e-&gt;0x002e</TT>
<BR><TT>0x0031-&gt;0x0031</TT>
<BR><TT>0x0041-&gt;0x0041</TT>
<BR><TT>0x3000 EOF</TT>
<BR><TT>0xff21 EOF</TT>
<BR><TT>0x3048 EOF</TT>
<BR><TT>0x30a3 EOF</TT>
<BR><TT>0xff61-&gt;0x00a1</TT>
<BR><TT>0xff66-&gt;0x00a6</TT>
<BR><TT>0xff9f-&gt;0x00df</TT>
<BR><TT>0x720d EOF</TT>
<BR><TT>&nbsp; 0000-&gt;0x0000</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
</DL>
<DL>
<DT>Systems:
<DD>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS
</DL>
<H2 ID="wctomb"> wctomb, _fwctomb </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>int wctomb( char *s, wchar_t wc );</TT>
<BR><TT>#include &lt;mbstring.h&gt;</TT>
<BR><TT>int _fwctomb( char __far *s, wchar_t wc );</TT>
</DL>
<DL>
<DT>Safer C:
<DD>The Safer C Library extension provides the <A HREF="#wctomb_s">wctomb_s</A> function which is a safer alternative to<TT> wctomb</TT>
This newer<TT> wctomb_s</TT> function is recommended to be used instead of the traditional &quot;unsafe&quot;<TT> wctomb</TT>
function.
</DL>
<DL>
<DT>Description:
<DD>The<TT> wctomb</TT> function determines the number of bytes required to represent the multibyte character corresponding to
the wide character contained in<B> wc</B>.&nbsp; If<B> s</B> is not a NULL pointer, the multibyte character representation
is stored in the array pointed to by<B> s</B>.&nbsp; At most <TT> MB_CUR_MAX</TT> characters will be stored.
<BR><BR>The<TT> _fwctomb</TT> function is a data model independent form of the wctomb function that accepts far pointer arguments.
&nbsp;It is most useful in mixed memory model applications.
</DL>
<DL>
<DT>Returns:
<DD>If<B> s</B> is a NULL pointer, the<TT> wctomb</TT> function returns zero if multibyte character encodings are not state dependent,
and non-zero otherwise.&nbsp; If<B> s</B> is not a NULL pointer, the<TT> wctomb</TT> function returns:
<DL>
<DT>Value&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>-1
<DD>if the value of<B> wc</B> does not correspond to a valid multibyte character
<DT>len
<DD>the number of bytes that comprise the multibyte character corresponding to the value of<B> wc</B>.
</DL>
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#wctomb_s">wctomb_s</A>, <A HREF="#mblen">mblen</A>, <A HREF="#mbstowcs">mbstowcs</A>, <A HREF="#mbstowcs_s">mbstowcs_s</A>,
<A HREF="#mbtowc">mbtowc</A>, <A HREF="#wcstombs">wcstombs</A>, <A HREF="#wcstombs_s">wcstombs_s</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>wchar_t wchar = { 0x0073 };</TT>
<BR><TT>char&nbsp;&nbsp;&nbsp; mbbuffer[2];</TT>
<BR><BR><TT>void main()</TT>
<BR><TT>&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int len;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Character encodings are %sstate dependent\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( wctomb( NULL, 0 ) )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ? &quot;&quot; : &quot;not &quot; );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; len = wctomb( mbbuffer, wchar );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; mbbuffer[len] = '\0';</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;%s(%d)\n&quot;, mbbuffer, len );</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>produces the following:
<BR><BR><TT>Character encodings are not state dependent</TT>
<BR><TT>s(1)</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C
<BR><BR>_fwctomb is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> wctomb - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_fwctomb - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="wctomb_s"> wctomb_s, _fwctomb_s </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__ 1</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><TT>errno_t wctomb_s( int * restrict status,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char * restrict
s,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rsize_t smax,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t wc);</TT>
<BR><TT>errno_t _fwctomb_s( int __far * restrict status,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char __far
* restrict s,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rsize_t smax,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t wc);</TT>
</DL>
<DL>
<DT>Constraints:
<DD>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<TT>
wctomb_s</TT> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<BR><BR>Let<B> n</B> denote the number of bytes needed to represent the multibyte character corresponding to the wide character
given by<B> wc</B> (including any shift sequences).
<BR><BR>If<B> s</B> is not a null pointer, then<B> smax</B> shall not be less than<B> n</B>, and<B> smax</B> shall not be
greater than <TT> RSIZE_MAX</TT>.&nbsp; If<B> s</B> is a null pointer, then<B> smax</B> shall equal zero.
<BR><BR>If there is a runtime-constraint violation,<TT> wctomb_s</TT> does not modify the int pointed to by<B> status</B>,
and if<B> s</B> is not a null pointer, no more than<B> smax</B> elements in the array pointed to by<B> s</B> will be accessed.
</DL>
<DL>
<DT>Description:
<DD>The<TT> wctomb_s</TT> function determines<B> n</B> and stores the multibyte character representation of<B> wc</B> in the array
whose first element is pointed to by<B> s</B> (if<B> s</B> is not a null pointer).&nbsp; The number of characters stored never
exceeds <TT> MB_CUR_MAX</TT> or<B> smax</B>.&nbsp; If<B> wc</B> is a null wide character, a null byte is stored, preceded
by any shift sequence needed to restore the initial shift state, and the function is left in the initial conversion state.
<BR><BR>The implementation shall behave as if no library function calls the<TT> wctomb_s</TT> function.
<BR><BR>If<B> s</B> is a null pointer,the<TT> wctomb_s</TT> function stores into the int pointed to by<B> status</B> a nonzero
or zero value, if multibyte character encodings, respectively, do or do not have state-dependent encodings.
<BR><BR>If<B> s</B> is not a null pointer,the<TT> wctomb_s</TT> function stores into the int pointed to by<B> status</B> either<B>
n</B> or<B> -1</B> if<B> wc</B>, respectively, does or does not correspond to a valid multibyte character.
<BR><BR>In no case will the int pointed to by<B> status</B> be set to a value greater than the <TT> MB_CUR_MAX</TT> macro.
<BR><BR>The function is a data model independent form of the wctomb_s function that accepts far pointer arguments.&nbsp; It
is most useful in mixed memory model applications.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> wctomb_s</TT> function returns zero if there was no runtime-constraint violation.&nbsp; Otherwise, a non-zero value
is returned.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#wctomb">wctomb</A>, <A HREF="#mblen">mblen</A>, <A HREF="#mbstowcs">mbstowcs</A>, <A HREF="#mbstowcs_s">mbstowcs_s</A>,
<A HREF="#mbtowc">mbtowc</A>, <A HREF="#wcstombs">wcstombs</A>, <A HREF="#wcstombs_s">wcstombs_s</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#define __STDC_WANT_LIB_EXT1__ 1</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;stdlib.h&gt;</TT>
<BR><BR><TT>wchar_t wchar = { 0x0073 };</TT>
<BR><TT>char&nbsp;&nbsp;&nbsp; mbbuffer[3];</TT>
<BR><BR><TT>int main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; len;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; status;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; errno_t rc;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; rc = wctomb_s( &amp;status, NULL, 0, wchar );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf( &quot;Character encodings are %sstate dependent\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( status ) ? &quot;&quot; : &quot;not &quot; );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; rc = wctomb_s( &amp;len, mbbuffer, 2, wchar );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( rc != 0) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Character encoding error\n&quot;);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mbbuffer[len] = '\0';</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%s(%d)\n&quot;, mbbuffer, len );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; return( rc );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>Character encodings are not state dependent</TT>
<BR><TT>s(1)</TT>
</DL>
<DL>
<DT>Classification:
<DD>TR 24731
<BR><BR>_fwctomb_s is WATCOM
</DL>
<DL>
<DT>Systems:
<DD><TT> wctomb_s - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_fwctomb_s - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H2 ID="wctrans"> wctrans </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wctype.h&gt;</TT>
<BR><TT>wctrans_t wctrans( const char *property );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> wctrans</TT> function constructs a value with type <TT> wctrans_t</TT> that describes a mapping between wide characters
identified by the string argument<B> property</B>.&nbsp; The constructed value is affected by the <TT> LC_CTYPE</TT> category
of the current locale; the constructed value becomes indeterminate if the category's setting is changed.
<BR><BR>The two strings listed below are valid in all locales as<B> property</B> arguments to the<TT> wctrans</TT> function.
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>tolower
<DD>uppercase characters are mapped to lowercase
<DT>toupper
<DD>lowercase characters are mapped to uppercase
</DL>
</DL>
<DL>
<DT>Returns:
<DD>If<B> property</B> identifies a valid class of wide characters according to the <TT> LC_CTYPE</TT> category of the current
locale, the<TT> wctrans</TT> function returns a non-zero value that is valid as the second argument to the <TT> towctrans</TT>
function; otherwise, it returns zero.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#isalnum">isalnum</A>, <A HREF="#isalpha">isalpha</A>, <A HREF="#isblank">isblank</A>, <A HREF="#iscntrl">iscntrl</A>,
<A HREF="#isdigit">isdigit</A>, <A HREF="#isgraph">isgraph</A>, <A HREF="#isleadbyte">isleadbyte</A>, <A HREF="#islower">islower</A>,
<A HREF="#isprint">isprint</A>, <A HREF="#ispunct">ispunct</A>, <A HREF="#isspace">isspace</A>, <A HREF="#isupper">isupper</A>,
<A HREF="#iswctype">iswctype</A>, <A HREF="#isxdigit">isxdigit</A>, <A HREF="#tolower">tolower</A>, <A HREF="#toupper">toupper</A>,
<A HREF="#towctrans">towctrans</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;wctype.h&gt;</TT>
<BR><BR><TT>char *translations[2] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; &quot;tolower&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; &quot;toupper&quot;</TT>
<BR><TT>};</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; i;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; wint_t&nbsp; wc = 'A';</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; wint_t&nbsp; twc;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; 2; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; twc = towctrans( wc, wctrans( translations[i] ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%s(%lc): %lc\n&quot;, translations[i], wc, twc );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>tolower(A): a</TT>
<BR><TT>toupper(A): A</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C95
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS, Netware
</DL>
<H2 ID="wctype"> wctype </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;wctype.h&gt;</TT>
<BR><TT>wctype_t wctype( const char *property );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> wctype</TT> function constructs a value with type <TT> wctype_t</TT> that describes a class of wide characters identified
by the string argument,<B> property</B>.&nbsp; The constructed value is affected by the <TT> LC_CTYPE</TT> category of the
current locale; the constructed value becomes indeterminate if the category's setting is changed.
<BR><BR>The twelve strings listed below are valid in all locales as<B> property</B> arguments to the<TT> wctype</TT> function.
<DL>
<DT>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<DT>alnum
<DD>any wide character for which one of <TT> iswalpha</TT> or <TT> iswdigit</TT> is true
<DT>alpha
<DD>any wide character for which <TT> iswupper</TT> or <TT> iswlower</TT> is true, that is, for any wide character that is one
of an implementation-defined set for which none of <TT> iswcntrl</TT>, <TT> iswdigit</TT>, <TT> iswpunct</TT>, or <TT> iswspace</TT>
is true
<DT>blank
<DD>any wide character corresponding to a standard blank character (space or horizontal tab) or is one of an implementation-defined
set of wide characters for which <TT> iswblank</TT> is true
<DT>cntrl
<DD>any control wide character
<DT>digit
<DD>any wide character corresponding to a decimal-digit character
<DT>graph
<DD>any printable wide character except a space wide character
<DT>lower
<DD>any wide character corresponding to a lowercase letter, or one of an implementation-defined set of wide characters for which
none of <TT> iswcntrl</TT>, <TT> iswdigit</TT>, <TT> iswpunct</TT>, or <TT> iswspace</TT> is true
<DT>print
<DD>any printable wide character including a space wide character
<DT>punct
<DD>any printable wide character that is not a space wide character or a wide character for which <TT> iswalnum</TT> is true
<DT>space
<DD>any wide character corresponding to a standard white-space character or is one of an implementation-defined set of wide characters
for which <TT> iswalnum</TT> is false
<DT>upper
<DD>any wide character corresponding to a uppercase letter, or if c is one of an implementation-defined set of wide characters
for which none of <TT> iswcntrl</TT>, <TT> iswdigit</TT>, <TT> iswpunct</TT>, or <TT> iswspace</TT> is true
<DT>xdigit
<DD>any wide character corresponding to a hexadecimal digit character
</DL>
</DL>
<DL>
<DT>Returns:
<DD>If<B> property</B> identifies a valid class of wide characters according to the <TT> LC_CTYPE</TT> category of the current
locale, the<TT> wctype</TT> function returns a non-zero value that is valid as the second argument to the <TT> iswctype</TT>
function; otherwise, it returns zero.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#isalnum">isalnum</A>, <A HREF="#isalpha">isalpha</A>, <A HREF="#isblank">isblank</A>, <A HREF="#iscntrl">iscntrl</A>,
<A HREF="#isdigit">isdigit</A>, <A HREF="#isgraph">isgraph</A>, <A HREF="#isleadbyte">isleadbyte</A>, <A HREF="#islower">islower</A>,
<A HREF="#isprint">isprint</A>, <A HREF="#ispunct">ispunct</A>, <A HREF="#isspace">isspace</A>, <A HREF="#isupper">isupper</A>,
<A HREF="#iswctype">iswctype</A>, <A HREF="#isxdigit">isxdigit</A>, <A HREF="#tolower">tolower</A>, <A HREF="#toupper">toupper</A>,
<A HREF="#towctrans">towctrans</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;wchar.h&gt;</TT>
<BR><BR><TT>char *types[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; &quot;alnum&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; &quot;blank&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; &quot;alpha&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; &quot;cntrl&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; &quot;digit&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; &quot;graph&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; &quot;lower&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; &quot;print&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; &quot;punct&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; &quot;space&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; &quot;upper&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; &quot;xdigit&quot;</TT>
<BR><TT>};</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; i;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; wint_t&nbsp; wc = 'A';</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; 12; i++ )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( iswctype( wc, wctype( types[i] ) ) )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, types[i] );</TT>
<BR><TT>}</TT>
<BR><BR>produces the following:
<BR><BR><TT>alnum</TT>
<BR><TT>alpha</TT>
<BR><TT>graph</TT>
<BR><TT>print</TT>
<BR><TT>upper</TT>
<BR><TT>xdigit</TT>
</DL>
<DL>
<DT>Classification:
<DD>ISO C95
</DL>
<DL>
<DT>Systems:
<DD>All, Linux, RDOS
</DL>
<H2 ID="_wrapon"> _wrapon </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>short _FAR _wrapon( short wrap );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> _wrapon</TT> function is used to control the display of text when the text output reaches the right side of the text
window.&nbsp; This is text displayed with the <TT> _outtext</TT> and <TT> _outmem</TT> functions.&nbsp; The<B> wrap</B> argument
can take one of the following values:
<DL>
<DT>_GWRAPON
<DD>causes lines to wrap at the window border
<DT>_GWRAPOFF
<DD>causes lines to be truncated at the window border
</DL>
</DL>
<DL>
<DT>Returns:
<DD>The<TT> _wrapon</TT> function returns the previous setting for wrapping.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#_outtext">_outtext</A>, <A HREF="#_outmem">_outmem</A>, <A HREF="#_settextwindow">_settextwindow</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;conio.h&gt;</TT>
<BR><TT>#include &lt;graph.h&gt;</TT>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><BR><TT>main()</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int i;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char buf[ 80 ];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _TEXTC80 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _settextwindow( 5, 20, 20, 30 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _wrapon( _GWRAPOFF );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 1; i &lt;= 3; ++i ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _settextposition( 2 * i, 1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf( buf, &quot;Very very long line %d&quot;, i );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _outtext( buf );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _wrapon( _GWRAPON );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; for( i = 4; i &lt;= 6; ++i ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _settextposition( 2 * i, 1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf( buf, &quot;Very very long line %d&quot;, i );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _outtext( buf );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; getch();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>PC Graphics
</DL>
<DL>
<DT>Systems:
<DD>DOS
</DL>
<H2 ID="write"> write, _write </H2>
<DL>
<DT>Synopsis:
<DD>
<BR><TT>#include &lt;io.h&gt;</TT>
<BR><TT>int write( int handle, void *buffer, unsigned len );</TT>
<BR><TT>int _write( int handle, void *buffer, unsigned len );</TT>
</DL>
<DL>
<DT>Description:
<DD>The<TT> write</TT> function writes data at the operating system level.&nbsp; The number of bytes transmitted is given by<B>
len</B> and the data to be transmitted is located at the address specified by<B> buffer</B>.
<BR><BR>The<TT> _write</TT> function is identical to<TT> write</TT>.&nbsp; Use<TT> _write</TT> for ANSI naming conventions.
<BR><BR>The<B> handle</B> value is returned by the <TT> open</TT> function.&nbsp; The access mode must have included either
<TT> O_WRONLY</TT> or <TT> O_RDWR</TT> when the <TT> open</TT> function was invoked.
<BR><BR>The data is written to the file at the end when the file was opened with <TT> O_APPEND</TT> included as part of the
access mode; otherwise, it is written at the current file position for the file in question.&nbsp; This file position can
be determined with the <TT> tell</TT> function and can be set with the <TT> lseek</TT> function.
<BR><BR>When <TT> O_BINARY</TT> is included in the access mode, the data is transmitted unchanged.&nbsp; When <TT> O_TEXT</TT>
is included in the access mode, the data is transmitted with extra carriage return characters inserted before each linefeed
character encountered in the original data.
<BR><BR>A file can be truncated under DOS and OS/2 2.0 by specifying 0 as the<B> len</B> argument.<B>&nbsp; Note,</B> however,
that this doesn't work under OS/2 2.1, Windows NT/2000, and other operating systems.&nbsp; To truncate a file in a portable
manner, use the <TT> chsize</TT> function.
</DL>
<DL>
<DT>Returns:
<DD>The<TT> write</TT> function returns the number of bytes (does not include any extra carriage-return characters transmitted)
of data transmitted to the file.&nbsp; When there is no error, this is the number given by the<B> len</B> argument.&nbsp;
In the case of an error, such as there being no space available to contain the file data, the return value will be less than
the number of bytes transmitted.&nbsp; A value of -1 may be returned in the case of some output errors.&nbsp; When an error
has occurred, <TT> errno</TT> contains a value indicating the type of error that has been detected.
</DL>
<DL>
<DT>See Also:
<DD><A HREF="#chsize">chsize</A>, <A HREF="#close">close</A>, <A HREF="#creat">creat</A>, <A HREF="#dup">dup</A>, <A HREF="#dup2">dup2</A>,
<A HREF="#eof">eof</A>, <A HREF="#exec___">exec...</A>, <A HREF="#fdopen">fdopen</A>, <A HREF="#filelength">filelength</A>,
<A HREF="#fileno">fileno</A>, <A HREF="#fstat">fstat</A>, <A HREF="#_grow_handles">_grow_handles</A>, <A HREF="#isatty">isatty</A>,
<A HREF="#lseek">lseek</A>, <A HREF="#open">open</A>, <A HREF="#read">read</A>, <A HREF="#setmode">setmode</A>, <A HREF="#sopen">sopen</A>,
<A HREF="#stat">stat</A>, <A HREF="#tell">tell</A>, <A HREF="#umask">umask</A>
</DL>
<DL>
<DT>Example:
<DD>
<BR><TT>#include &lt;stdio.h&gt;</TT>
<BR><TT>#include &lt;io.h&gt;</TT>
<BR><TT>#include &lt;fcntl.h&gt;</TT>
<BR><BR><TT>char buffer[]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = { &quot;A text record to be written&quot; };</TT>
<BR><BR><TT>void main( void )</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int handle;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; int size_written;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; /* open a file for output&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;*/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; /* replace existing file if it exists */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; handle = open( &quot;file&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; O_WRONLY | O_CREAT | O_TRUNC
| O_TEXT,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S_IRUSR | S_IWUSR | S_IRGRP
| S_IWGRP );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; if( handle != -1 ) {</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* write the text&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_written = write( handle, buffer,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sizeof( buffer ) );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* test for error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( size_written != sizeof( buffer ) ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Error writing file\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* close the file&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close( handle );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>}</TT>
</DL>
<DL>
<DT>Classification:
<DD>POSIX 1003.1
<BR><BR>_write conforms to ANSI naming conventions
</DL>
<DL>
<DT>Systems:
<DD><TT> write - All, Linux, RDOS, Netware</TT>
<BR><BR><TT>_write - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, RDOS</TT>
</DL>
<H1 ID="ReMentrant_Functions"> Re-entrant Functions </H1>
<BR>The following functions in the C library are re-entrant:
<BR><BR><TT>abs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; atoi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; atol&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsearch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; bsearch_s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; div&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fabs
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fmbsrtowcs_s&nbsp; _fmbstowcs_s&nbsp;&nbsp; _fmemccpy&nbsp;&nbsp;
&nbsp;&nbsp; _fmemchr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fmemcmp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fmemcpy&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; _fmemicmp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fmemmove&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fmemset&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; _fstrcat&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fstrchr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fstrcmp&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; _fstrcpy&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fstrcspn&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fstricmp&nbsp;&nbsp;
&nbsp;&nbsp; _fstrlen&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fstrlwr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fstrncat&nbsp;&nbsp;
&nbsp;&nbsp; _fstrncmp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fstrncpy&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fstrnicmp&nbsp;&nbsp;&nbsp;
&nbsp;_fstrnset&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fstrpbrk&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fstrrchr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
_fstrrev&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fstrset&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fstrspn&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; _fstrstr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fstrupr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fwcrtombs_s&nbsp;&nbsp;
_fwcsrtombs_s&nbsp; _fwcstombs_s&nbsp;&nbsp; _fwctomb_s&nbsp;&nbsp;&nbsp;&nbsp; isalnum&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;isalpha&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isascii&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isblank&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; iscntrl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isdigit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
isgraph&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; islower&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isprint&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; ispunct&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isspace&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isupper
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isxdigit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; itoa&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; labs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ldiv&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; lfind&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; longjmp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;_lrotl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _lrotr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lsearch
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ltoa&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _makepath&nbsp;&nbsp;
&nbsp;&nbsp; mblen&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mbsrtowcs_s&nbsp;&nbsp;&nbsp; mbstowcs&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; mbstowcs_s&nbsp;&nbsp;&nbsp;&nbsp; mbtowc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memccpy&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memchr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memcmp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; memcpy&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memcpy_s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memicmp&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memmove&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memmove_s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memset
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movedata&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qsort&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; qsort_s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _rotl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;_rotr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; segread&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setjmp
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _splitpath&nbsp;&nbsp;&nbsp;&nbsp; strcat&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;strcat_s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strchr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcmp&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcoll&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcpy&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; strcpy_s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcspn&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strerror_s&nbsp;&nbsp;
&nbsp; strerrorlen_s&nbsp; stricmp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strlen&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;strlwr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strncat&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strncat_s&nbsp;
&nbsp;&nbsp;&nbsp; strncmp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strncpy&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strncpy_s
&nbsp;&nbsp;&nbsp;&nbsp; strnicmp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strnlen_s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strnset&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strpbrk&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strrchr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;strrev&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strset&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strspn
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strstr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strtok_s&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; strupr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; swab&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;tolower&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; toupper&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ultoa&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; utoa&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wcrtombs_s&nbsp;&nbsp;
&nbsp; wcscat_s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wcscpy_s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wcserror_s&nbsp;&nbsp;&nbsp;
&nbsp;wcserrorlen_s&nbsp; wcsncat_s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wcsncat_s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wcsncpy_s&nbsp;
&nbsp;&nbsp;&nbsp; wcsnlen_s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wcsrtombs_s&nbsp;&nbsp;&nbsp; wcstok_s&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; wcstombs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wcstombs_s&nbsp;&nbsp;&nbsp;&nbsp; wctomb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; </TT>
<BR><TT>wctomb_s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wmemcpy_s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wmemmove_s&nbsp;&nbsp;&nbsp;
</TT>
<H1 ID="ImplementationMDefined_Behavior_of_the_C_Library"> Implementation-Defined Behavior of the C Library </H1>
<BR><BR>This appendix describes the behavior of the 16-bit and 32-bit Open Watcom C libraries when the ISO/ANSI C Language
standard describes the behavior as<B> implementation-defined.</B>&nbsp; The term describing each behavior is taken directly
from the ISO/ANSI C Language standard.&nbsp; The numbers in parentheses at the end of each term refers to the section of the
standard that discusses the behavior.
<H2 ID="NULL_Macro"> NULL Macro </H2>
<BR><B>The null pointer constant to which the macro </B><TT> NULL</TT><B> expands (7.1.6).</B>
<BR><BR>The macro <TT> NULL</TT> expands to 0 in small data models and to 0L in large data models.
<H2 ID="Diagnostic_Printed_by_the_assert_Function"> Diagnostic Printed by the assert Function </H2>
<BR><B>The diagnostic printed by and the termination behavior of the </B><TT> assert</TT><B> function (7.2).</B>
<BR><BR>The <TT> assert</TT> function prints a diagnostic message to <TT> stderr</TT> and calls the <TT> abort</TT> routine
if the expression is false.&nbsp; The diagnostic message has the following form:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Assertion failed: [expression], file [name], line [number]</TT>
<H2 ID="Character_Testing"> Character Testing </H2>
<BR><B>The sets of characters tested for by the </B><TT> isalnum</TT><B>, </B><TT> isalpha</TT><B>, </B><TT> iscntrl</TT><B>,
</B><TT> islower</TT><B>, </B><TT> isprint</TT><B>, and </B><TT> isupper</TT><B> functions (7.3.1).</B>
<DL>
<DT>Function&nbsp;&nbsp;&nbsp;&nbsp; Characters Tested For
<DT>isalnum
<DD>Characters 0-9, A-Z, a-z
<DT>isalpha
<DD>Characters A-Z, a-z
<DT>iscntrl
<DD>ASCII 0x00-0x1f, 0x7f
<DT>islower
<DD>Characters a-z
<DT>isprint
<DD>ASCII 0x20-0x7e
<DT>isupper
<DD>Characters A-Z
</DL>
<H2 ID="Domain_Errors"> Domain Errors </H2>
<BR><B>The values returned by the mathematics functions on domain errors (7.5.1).</B>
<BR><BR>When a domain error occurs, the listed values are returned by the following functions:
<DL>
<DT>Function&nbsp;&nbsp;&nbsp;&nbsp; Value returned
<DT>acos
<DD>0.0
<DT>acosh
<DD>- HUGE_VAL
<DT>asin
<DD>0.0
<DT>atan2
<DD>0.0
<DT>atanh
<DD>- HUGE_VAL
<DT>log
<DD>- HUGE_VAL
<DT>log10
<DD>- HUGE_VAL
<DT>log2
<DD>- HUGE_VAL
<DT>pow(neg,frac)
<DD>0.0
<DT>pow(0.0,0.0)
<DD>1.0
<DT>pow(0.0,neg)
<DD>- HUGE_VAL
<DT>sqrt
<DD>0.0
<DT>y0
<DD>- HUGE_VAL
<DT>y1
<DD>- HUGE_VAL
<DT>yn
<DD>- HUGE_VAL
</DL>
<H2 ID="Underflow_of_FloatingMPoint_Values"> Underflow of Floating-Point Values </H2>
<BR><B>Whether the mathematics functions set the integer expression </B><TT> errno</TT><B> to the value of the macro </B><TT>
ERANGE</TT><B> on underflow range errors (7.5.1).</B>
<BR><BR>The integer expression <TT> errno</TT> is not set to <TT> ERANGE</TT> on underflow range errors in the mathematics
functions.
<H2 ID="The_fmod_Function"> The fmod Function </H2>
<BR><B>Whether a domain error occurs or zero is returned when the </B><TT> fmod</TT><B> function has a second argument of
zero (7.5.6.4).</B>
<BR><BR>Zero is returned when the second argument to <TT> fmod</TT> is zero.
<H2 ID="The_signal_Function"> The signal Function </H2>
<BR><B>The set of signals for the </B><TT> signal</TT><B> function (7.7.1.1).</B>
<BR><BR>See the description of the <TT> signal</TT> function presented earlier in this book.
<BR><BR><B>The semantics for each signal recognized by the </B><TT> signal</TT><B> function (7.7.1.1).</B>
<BR><BR>See the description of the <TT> signal</TT> function presented earlier in this book.
<BR><BR><B>The default handling and the handling at program startup for each signal recognized by the </B><TT> signal</TT><B>
function (7.7.1.1).</B>
<BR><BR>See the description of the <TT> signal</TT> function presented earlier in this book.
<H2 ID="Default_Signals"> Default Signals </H2>
<BR><B>If the equivalent of </B><TT> signal</TT><B>( sig, SIG_DFL ) is not executed prior to the call of a signal handler,
the blocking of the signal that is performed (7.7.1.1).</B>
<BR><BR>The equivalent of
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; signal( sig, SIG_DFL );</TT>
<BR><BR>is executed prior to the call of a signal handler.
<H2 ID="The_SIGILL_Signal"> The SIGILL Signal </H2>
<BR><B>Whether the default handling is reset if the </B><TT> SIGILL</TT><B> signal is received by a handler specified to the
</B><TT> signal</TT><B> function (7.7.1.1).</B>
<BR><BR>The equivalent of
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; signal( SIGILL, SIG_DFL );</TT>
<BR><BR>is executed prior to the call of the signal handler.
<H2 ID="Terminating_Newline_Characters"> Terminating Newline Characters </H2>
<BR><B>Whether the last line of a text stream requires a terminating new-line character (7.9.2).</B>
<BR><BR>The last line of a text stream does not require a terminating new-line character.
<H2 ID="Space_Characters"> Space Characters </H2>
<BR><B>Whether space characters that are written out to a text stream immediately before a new-line character appear when
read in (7.9.2).</B>
<BR><BR>All characters written out to a text stream will appear when read in.
<H2 ID="Null_Characters"> Null Characters </H2>
<BR><B>The number of null characters that may be appended to data written to a binary stream (7.9.2).</B>
<BR><BR>No null characters are appended to data written to a binary stream.
<H2 ID="File_Position_in_Append_Mode"> File Position in Append Mode </H2>
<BR><B>Whether the file position indicator of an append mode stream is initially positioned at the beginning or end of the
file (7.9.3).</B>
<BR><BR>When a file is open in append mode, the file position indicator initially points to the end of the file.
<H2 ID="Truncation_of_Text_Files"> Truncation of Text Files </H2>
<BR><B>Whether a write on a text stream causes the associated file to be truncated beyond that point (7.9.3).</B>
<BR><BR>Writing to a text stream does not truncate the file beyond that point.
<H2 ID="File_Buffering"> File Buffering </H2>
<BR><B>The characteristics of file buffering (7.9.3).</B>
<BR><BR>Disk files accessed through the standard I/O functions are fully buffered.&nbsp; The default buffer size is 512 bytes
for 16-bit systems, and 4096 bytes for 32-bit systems.
<H2 ID="ZeroMLength_Files"> Zero-Length Files </H2>
<BR><B>Whether a zero-length file actually exists (7.9.3).</B>
<BR><BR>A file with length zero can exist.
<H2 ID="File_Names"> File Names </H2>
<BR><B>The rules of composing valid file names (7.9.3).</B>
<BR><BR>A valid file specification consists of an optional drive letter (which is always followed by a colon), a series of
optional directory names separated by backslashes, and a file name.
<BR><BR><B>FAT File System:</B>&nbsp; Directory names and file names can contain up to eight characters followed optionally
by a period and a three letter extension.&nbsp; The complete path (including drive, directories and file name) cannot exceed
143 characters.&nbsp; Case is ignored (lowercase letters are converted to uppercase letters).
<BR><BR><B>HPFS File System:</B>&nbsp; Directory names and file names can contain up to 254 characters in the OS/2 High Performance
File System (HPFS).&nbsp; However, the complete path (including drive, directories and file name) cannot exceed 259 characters.
&nbsp;The period is a valid file name character and can appear in a file name or directory name as many times as required;
HPFS file names do not require file extensions as in the FAT file system.&nbsp; The HPFS preserves case in file names only
in directory listings but ignores case in file searches and other system operations (i.e, a directory cannot have more than
one file whose names differ only in case).
<H2 ID="File_Access_Limits"> File Access Limits </H2>
<BR><B>Whether the same file can be open multiple times (7.9.3).</B>
<BR><BR>It is possible to open a file multiple times.
<H2 ID="Deleting_Open_Files"> Deleting Open Files </H2>
<BR><B>The effect of the </B><TT> remove</TT><B> function on an open file (7.9.4.1).</B>
<BR><BR>The <TT> remove</TT> function deletes a file, even if the file is open.
<H2 ID="Renaming_with_a_Name_that_Exists"> Renaming with a Name that Exists </H2>
<BR><B>The effect if a file with the new name exists prior to a call to the </B><TT> rename</TT><B> function (7.9.4.2).</B>
<BR><BR>The <TT> rename</TT> function will fail if you attempt to rename a file using a name that exists.
<H2 ID="Printing_Pointer_Values"> Printing Pointer Values </H2>
<BR><B>The output for</B><TT> %p</TT><B> conversion in the </B><TT> fprintf</TT><B> function (7.9.6.1).</B>
<BR><BR>Two types of pointers are supported:&nbsp; near pointers (%hp), and far pointers (%lp).&nbsp; The output for %p depends
on the memory model being used.
<BR><BR>In 16-bit mode, the <TT> fprintf</TT> function produces hexadecimal values of the form XXXX for 16-bit near pointers,
and XXXX:XXXX (segment and offset separated by a colon) for 32-bit far pointers.
<BR><BR>In 32-bit mode, the <TT> fprintf</TT> function produces hexadecimal values of the form XXXXXXXX for 32-bit near pointers,
and XXXX:XXXXXXXX (segment and offset separated by a colon) for 48-bit far pointers.
<H2 ID="Reading_Pointer_Values"> Reading Pointer Values </H2>
<BR><B>The input for</B><TT> %p</TT><B> conversion in the </B><TT> fscanf</TT><B> function (7.9.6.2).</B>
<BR><BR>The <TT> fscanf</TT> function converts hexadecimal values into the correct address when the %p format specifier is
used.
<H2 ID="Reading_Ranges"> Reading Ranges </H2>
<BR><B>The interpretation of a</B><TT> -</TT><B> character that is neither the first nor the last character in the scanlist
for</B><TT> %[</TT><B> conversion in the </B><TT> fscanf</TT><B> function (7.9.6.2).</B>
<BR><BR>The &quot;-&quot; character indicates a character range.&nbsp; The character prior to the &quot;-&quot; is the first
character in the range.&nbsp; The character following the &quot;-&quot; is the last character in the range.
<H2 ID="File_Position_Errors"> File Position Errors </H2>
<BR><B>The value to which the macro </B><TT> errno</TT><B> is set by the </B><TT> fgetpos</TT><B> or </B><TT> ftell</TT><B>
function on failure (7.9.9.1, 7.9.9.4).</B>
<BR><BR>When the function <TT> fgetpos</TT> or <TT> ftell</TT> fails, they set <TT> errno</TT> to <TT> EBADF</TT> if the file
number is bad.&nbsp; The constants are defined in the<TT> &lt;errno.h&gt;</TT> header file.
<H2 ID="Messages_Generated_by_the_perror_Function"> Messages Generated by the perror Function </H2>
<BR><B>The messages generated by the </B><TT> perror</TT><B> function (7.9.10.4).</B>
<BR><BR>The <TT> perror</TT> function generates the following messages.
<DL>
<DT><B><I>Error</I></B>
<DD><B><I>Message</I></B>
<DT>0
<DD>&quot;Error 0&quot;
<DT>1
<DD>&quot;No such file or directory&quot;
<DT>2
<DD>&quot;Argument list too big&quot;
<DT>3
<DD>&quot;Exec format error&quot;
<DT>4
<DD>&quot;Bad file number&quot;
<DT>5
<DD>&quot;Not enough memory&quot;
<DT>6
<DD>&quot;Permission denied&quot;
<DT>7
<DD>&quot;File exists&quot;
<DT>8
<DD>&quot;Cross-device link&quot;
<DT>9
<DD>&quot;Invalid argument&quot;
<DT>10
<DD>&quot;File table overflow&quot;
<DT>11
<DD>&quot;Too many open files&quot;
<DT>12
<DD>&quot;No space left on device&quot;
<DT>13
<DD>&quot;Argument too large&quot;
<DT>14
<DD>&quot;Result too large&quot;
<DT>15
<DD>&quot;Resource deadlock would occur&quot;
</DL>
<H2 ID="Allocating_Zero_Memory"> Allocating Zero Memory </H2>
<BR><B>The behavior of the </B><TT> calloc</TT><B>, </B><TT> malloc</TT><B>, or </B><TT> realloc</TT><B> function if the size
requested is zero (7.10.3).</B>
<BR><BR>The value returned will be <TT> NULL</TT>.&nbsp; No actual memory is allocated.
<H2 ID="The_abort_Function"> The abort Function </H2>
<BR><B>The behavior of the </B><TT> abort</TT><B> function with regard to open and temporary files (7.10.4.1).</B>
<BR><BR>The <TT> abort</TT> function does not close any files that are open or temporary, nor does it flush any output buffers.
<H2 ID="The_atexit_Function"> The atexit Function </H2>
<BR><B>The status returned by the </B><TT> exit</TT><B> function if the value of the argument is other than zero, </B><TT>
EXIT_SUCCESS</TT><B>, or </B><TT> EXIT_FAILURE</TT><B> (7.10.4.3).</B>
<BR><BR>The <TT> exit</TT> function returns the value of its argument to the operating system regardless of its value.
<H2 ID="Environment_Names"> Environment Names </H2>
<BR><B>The set of environment names and the method for altering the environment list used by the </B><TT> getenv</TT><B> function
(7.10.4.4).</B>
<BR><BR>The set of environment names is unlimited.&nbsp; Environment variables can be set from the DOS command line using
the SET command.&nbsp; A program can modify its environment variables with the <TT> putenv</TT> function.&nbsp; Such modifications
last only until the program terminates.
<H2 ID="The_system_Function"> The system Function </H2>
<BR><B>The contents and mode of execution of the string by the </B><TT> system</TT><B> function (7.10.4.5).</B>
<BR><BR>The <TT> system</TT> function executes an internal DOS, Windows, or OS/2 command, or an EXE, COM, BAT or CMD file
from within a C program rather than from the command line.&nbsp; The <TT> system</TT> function examines the <TT> COMSPEC</TT>
environment variable to find the command interpreter and passes the argument string to the command interpreter.
<H2 ID="The_strerror_Function"> The strerror Function </H2>
<BR><B>The contents of the error message strings returned by the </B><TT> strerror</TT><B> function (7.11.6.2).</B>
<BR><BR>The <TT> strerror</TT> function generates the following messages.
<DL>
<DT><B><I>Error</I></B>
<DD><B><I>Message</I></B>
<DT>0
<DD>&quot;Error 0&quot;
<DT>1
<DD>&quot;No such file or directory&quot;
<DT>2
<DD>&quot;Argument list too big&quot;
<DT>3
<DD>&quot;Exec format error&quot;
<DT>4
<DD>&quot;Bad file number&quot;
<DT>5
<DD>&quot;Not enough memory&quot;
<DT>6
<DD>&quot;Permission denied&quot;
<DT>7
<DD>&quot;File exists&quot;
<DT>8
<DD>&quot;Cross-device link&quot;
<DT>9
<DD>&quot;Invalid argument&quot;
<DT>10
<DD>&quot;File table overflow&quot;
<DT>11
<DD>&quot;Too many open files&quot;
<DT>12
<DD>&quot;No space left on device&quot;
<DT>13
<DD>&quot;Argument too large&quot;
<DT>14
<DD>&quot;Result too large&quot;
<DT>15
<DD>&quot;Resource deadlock would occur&quot;
</DL>
<H2 ID="The_Time_Zone"> The Time Zone </H2>
<BR><B>The local time zone and Daylight Saving Time (7.12.1).</B>
<BR><BR>The default time zone is &quot;Eastern Standard Time&quot; (EST), and the corresponding daylight saving time zone
is &quot;Eastern Daylight Saving Time&quot; (EDT).
<H2 ID="The_clock_Function"> The clock Function </H2>
<BR><B>The era for the </B><TT> clock</TT><B> function (7.12.2.1).</B>
<BR><BR>The <TT> clock</TT> function's era begins with a value of 0 when the program starts to execute.
</BODY>
