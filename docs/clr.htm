<HEAD>
<TITLE> Open Watcom 2.0 C Language Reference </TITLE>
</HEAD>
<BODY>
<H1 ID="Index_of_Topics"> Index of Topics </H1>
<DL>
<DT>- # -
<DD><A HREF="#The__ifdef_and__ifndef_Directives">The #ifdef and #ifndef Directives</A>
<DT>- _ -
<DD><A HREF="#The____far_Keyword_for_Open_Watcom_CD16">The _ _far Keyword for Open Watcom C/16</A>
<BR><A HREF="#The____far_Keyword_for_Open_Watcom_CD32">The _ _far Keyword for Open Watcom C/32</A>
<BR><A HREF="#___far_____near_and____huge_Declarations">_ _far, _ _near and _ _huge Declarations</A>
<BR><A HREF="#The____far16_and__Seg16_Keywords">The _ _far16 and _Seg16 Keywords</A>
<BR><A HREF="#The____huge_Keyword_for_Open_Watcom_CD16">The _ _huge Keyword for Open Watcom C/16</A>
<BR><A HREF="#___interrupt_Declarations">_ _interrupt Declarations</A>
<BR><A HREF="#The____near_Keyword_for_Open_Watcom_CD16">The _ _near Keyword for Open Watcom C/16</A>
<BR><A HREF="#The____near_Keyword_for_Open_Watcom_CD32">The _ _near Keyword for Open Watcom C/32</A>
<DT>- A -
<DD><A HREF="#Additive_Operators">Additive Operators</A>
<BR><A HREF="#AddressMof_and_Indirection_Operators">Address-of and Indirection Operators</A>
<BR><A HREF="#Advanced_Types">Advanced Types</A>
<BR><A HREF="#Advantages">Advantages</A>
<BR><A HREF="#Argument_Substitution">Argument Substitution</A>
<BR><A HREF="#Arithmetic_Conversion">Arithmetic Conversion</A>
<BR><A HREF="#Array_Subscripting">Array Subscripting</A>
<BR><A HREF="#Arrays">Arrays</A>
<BR><A HREF="#Arrays_and_Pointers">Arrays and Pointers</A>
<BR><A HREF="#Assignment_Instead_of_Comparison">Assignment Instead of Comparison</A>
<BR><A HREF="#Assignment_Operators">Assignment Operators</A>
<BR><A HREF="#The_auto_Storage_Class">The auto Storage Class</A>
<BR><A HREF="#Automatic_Storage_Duration">Automatic Storage Duration</A>
<BR><A HREF="#Avoiding_Common_Pitfalls">Avoiding Common Pitfalls</A>
<BR><A HREF="#Avoiding_ImplementationMDefined_Behavior">Avoiding Implementation-Defined Behavior</A>
<DT>- B -
<DD><A HREF="#Based_Pointers_for_Open_Watcom_CD16_and_CD32">Based Pointers for Open Watcom C/16 and C/32</A>
<BR><A HREF="#Basic_Language_Elements">Basic Language Elements</A>
<BR><A HREF="#Basic_Types">Basic Types</A>
<BR><A HREF="#Behaviour_Concerning_Identifiers">Behaviour Concerning Identifiers</A>
<BR><A HREF="#Behaviour_Concerning_Statements">Behaviour Concerning Statements</A>
<BR><A HREF="#Beware_of_Long_External_Names">Beware of Long External Names</A>
<BR><A HREF="#BitMfields">Bit-fields</A>
<BR><A HREF="#Bitwise_AND_Operator">Bitwise AND Operator</A>
<BR><A HREF="#Bitwise_Exclusive_OR_Operator">Bitwise Exclusive OR Operator</A>
<BR><A HREF="#Bitwise_Inclusive_OR_Operator">Bitwise Inclusive OR Operator</A>
<BR><A HREF="#Bitwise_Shift_Operators">Bitwise Shift Operators</A>
<BR><A HREF="#The_Body_of_the_Function">The Body of the Function</A>
<BR><A HREF="#The_break_Statement">The break Statement</A>
<DT>- C -
<DD><A HREF="#Case_Rules_for_Object_and_Function_Names">Case Rules for Object and Function Names</A>
<BR><A HREF="#Cast_Operator">Cast Operator</A>
<BR><A HREF="#Changing_the_Line_Numbering_and_File_Name">Changing the Line Numbering and File Name</A>
<BR><A HREF="#Character_Constants">Character Constants</A>
<BR><A HREF="#Character_Sets">Character Sets</A>
<BR><A HREF="#Characters">Characters</A>
<BR><A HREF="#Choose_Appropriate_Names">Choose Appropriate Names</A>
<BR><A HREF="#Comma_Operator">Comma Operator</A>
<BR><A HREF="#Comments">Comments</A>
<BR><A HREF="#Compatible_Types">Compatible Types</A>
<BR><A HREF="#Compiler_Keywords">Compiler Keywords</A>
<BR><A HREF="#Complete_Data_Hiding">Complete Data Hiding</A>
<BR><A HREF="#Compound_Assignment">Compound Assignment</A>
<BR><A HREF="#Compound_Statements">Compound Statements</A>
<BR><A HREF="#Concatenating_Tokens">Concatenating Tokens</A>
<BR><A HREF="#Conditional_Operator">Conditional Operator</A>
<BR><A HREF="#Conditionally_Including_Source_Lines">Conditionally Including Source Lines</A>
<BR><A HREF="#Consistency">Consistency</A>
<BR><A HREF="#The_const_and_volatile_Declarations">The const and volatile Declarations</A>
<BR><A HREF="#Constant_Expressions">Constant Expressions</A>
<BR><A HREF="#Constants">Constants</A>
<BR><A HREF="#The_continue_Statement">The continue Statement</A>
<BR><A HREF="#Converting_An_Argument_to_a_String">Converting An Argument to a String</A>
<DT>- D -
<DD><A HREF="#The_Dangling_else">The Dangling else</A>
<BR><A HREF="#Data_Hiding">Data Hiding</A>
<BR><A HREF="#Declarations_of_Objects">Declarations of Objects</A>
<BR><A HREF="#Declarators">Declarators</A>
<BR><A HREF="#Default_Argument_Promotion">Default Argument Promotion</A>
<BR><A HREF="#Definition_of_a_Constant">Definition of a Constant</A>
<BR><A HREF="#Definition_of_a_Declaration">Definition of a Declaration</A>
<BR><A HREF="#Definition_of_a_Keyword">Definition of a Keyword</A>
<BR><A HREF="#Definition_of_a_Punctuator">Definition of a Punctuator</A>
<BR><A HREF="#Definition_of_a_Statement">Definition of a Statement</A>
<BR><A HREF="#Definition_of_a_String_Literal">Definition of a String Literal</A>
<BR><A HREF="#Definition_of_a_Token">Definition of a Token</A>
<BR><A HREF="#Definition_of_an_Identifier">Definition of an Identifier</A>
<BR><A HREF="#Definition_of_an_Operator">Definition of an Operator</A>
<BR><A HREF="#Definition_of_Expressions">Definition of Expressions</A>
<BR><A HREF="#Delayed_Error_From_Included_File">Delayed Error From Included File</A>
<BR><A HREF="#Displaying_a_Diagnostic_Message">Displaying a Diagnostic Message</A>
<BR><A HREF="#Do_Not_Do_Too_Much_In_One_Statement">Do Not Do Too Much In One Statement</A>
<BR><A HREF="#Do_Not_Reuse_the_Names_of_Static_Objects">Do Not Reuse the Names of Static Objects</A>
<BR><A HREF="#Do_Not_Use_goto_Too_Much">Do Not Use goto Too Much</A>
<BR><A HREF="#The_do_Statement">The do Statement</A>
<DT>- E -
<DD><A HREF="#Enumerated_Types">Enumerated Types</A>
<BR><A HREF="#Environment">Environment</A>
<BR><A HREF="#Equality_Operators">Equality Operators</A>
<BR><A HREF="#Escape_Sequences">Escape Sequences</A>
<BR><A HREF="#Examples_of_Declarations">Examples of Declarations</A>
<BR><A HREF="#Expression_Statements">Expression Statements</A>
<BR><A HREF="#Expressions">Expressions</A>
<BR><A HREF="#The_extern_Storage_Class">The extern Storage Class</A>
<BR><A HREF="#External_Definitions">External Definitions</A>
<BR><A HREF="#Extra_SemiMcolon_in_Macros">Extra Semi-colon in Macros</A>
<DT>- F -
<DD><A HREF="#Floating_Point">Floating Point</A>
<BR><A HREF="#FloatingMPoint_Constants">Floating-Point Constants</A>
<BR><A HREF="#FloatingMPoint_to_Integer_Conversion">Floating-Point to Integer Conversion</A>
<BR><A HREF="#FloatingMPoint_Types">Floating-Point Types</A>
<BR><A HREF="#The_for_Statement">The for Statement</A>
<BR><A HREF="#Formal_C_Grammar">Formal C Grammar</A>
<BR><A HREF="#Function_Calls">Function Calls</A>
<BR><A HREF="#Function_Declarations">Function Declarations</A>
<BR><A HREF="#Function_Prototypes">Function Prototypes</A>
<BR><A HREF="#Functions">Functions</A>
<DT>- G -
<DD><A HREF="#Glossary">Glossary</A>
<BR><A HREF="#The_goto_Statement">The goto Statement</A>
<BR><A HREF="#Group_Static_Objects_Together">Group Static Objects Together</A>
<BR><A HREF="#Grouping_Code_With_Related_Functionality">Grouping Code With Related Functionality</A>
<DT>- H -
<DD><A HREF="#History">History</A>
<BR><A HREF="#How_to_Use_This_Book">How to Use This Book</A>
<DT>- I -
<DD><A HREF="#Identifiers">Identifiers</A>
<BR><A HREF="#The_if_Statement">The if Statement</A>
<BR><A HREF="#ImplementationMDefined_Behavior">Implementation-Defined Behavior</A>
<BR><A HREF="#Including_Headers_and_Source_Files">Including Headers and Source Files</A>
<BR><A HREF="#Indent_to_Emphasize_Structure">Indent to Emphasize Structure</A>
<BR><A HREF="#Initialization_of_Arrays">Initialization of Arrays</A>
<BR><A HREF="#Initialization_of_Objects">Initialization of Objects</A>
<BR><A HREF="#Initialization_of_Scalar_Types">Initialization of Scalar Types</A>
<BR><A HREF="#Initialization_of_Structures">Initialization of Structures</A>
<BR><A HREF="#Initialization_of_Unions">Initialization of Unions</A>
<BR><A HREF="#Integer_Constants">Integer Constants</A>
<BR><A HREF="#Integer_to_FloatingMPoint_Conversion">Integer to Floating-Point Conversion</A>
<BR><A HREF="#Integer_Types">Integer Types</A>
<BR><A HREF="#Integers">Integers</A>
<BR><A HREF="#Integral_Promotion">Integral Promotion</A>
<BR><A HREF="#Introduction_to_C">Introduction to C</A>
<BR><A HREF="#Isolating_System_Dependent_Code">Isolating System Dependent Code</A>
<BR><A HREF="#Isolating_System_Dependent_Code_in_Modules">Isolating System Dependent Code in Modules</A>
<BR><A HREF="#Iteration_Statements">Iteration Statements</A>
<DT>- J -
<DD><A HREF="#Jump_Statements">Jump Statements</A>
<DT>- K -
<DD><A HREF="#Keep_Functions_Small">Keep Functions Small</A>
<BR><A HREF="#Keywords">Keywords</A>
<DT>- L -
<DD><A HREF="#Labelled_Statements">Labelled Statements</A>
<BR><A HREF="#Lexical_Grammar">Lexical Grammar</A>
<BR><A HREF="#Library_Functions">Library Functions</A>
<BR><A HREF="#Logical_AND_Operator">Logical AND Operator</A>
<BR><A HREF="#Logical_OR_Operator">Logical OR Operator</A>
<BR><A HREF="#Lvalues">Lvalues</A>
<DT>- M -
<DD><A HREF="#Macro_Replacement">Macro Replacement</A>
<BR><A HREF="#Macros_for_Numerical_Limits">Macros for Numerical Limits</A>
<BR><A HREF="#The_memos_c_File">The memos.c File</A>
<BR><A HREF="#The_memos_h_File">The memos.h File</A>
<BR><A HREF="#Missing_break_in_switch_Statement">Missing break in switch Statement</A>
<BR><A HREF="#Mixing_Memory_Models">Mixing Memory Models</A>
<BR><A HREF="#Modularity">Modularity</A>
<BR><A HREF="#More_Examples_of_Macro_Replacement">More Examples of Macro Replacement</A>
<BR><A HREF="#Multibyte_Characters">Multibyte Characters</A>
<BR><A HREF="#Multiplicative_Operators">Multiplicative Operators</A>
<DT>- N -
<DD><A HREF="#Name_Scope">Name Scope</A>
<BR><A HREF="#Notation">Notation</A>
<BR><A HREF="#The_Null_Directive">The Null Directive</A>
<BR><A HREF="#The_NULL_Macro">The NULL Macro</A>
<BR><A HREF="#Null_Statements">Null Statements</A>
<BR><A HREF="#Numerical_Limits_for_FloatingMPoint_Types">Numerical Limits for Floating-Point Types</A>
<BR><A HREF="#Numerical_Limits_for_Integer_Types">Numerical Limits for Integer Types</A>
<DT>- O -
<DD><A HREF="#Object_Declarations">Object Declarations</A>
<BR><A HREF="#The_offsetof_Macro">The offsetof Macro</A>
<BR><A HREF="#Open_Watcom_CD16_and_CD32_Predefined_Macros">Open Watcom C/16 and C/32 Predefined Macros</A>
<BR><A HREF="#Open_Watcom_Extended_Keywords">Open Watcom Extended Keywords</A>
<BR><A HREF="#Operator_Precedence">Operator Precedence</A>
<BR><A HREF="#The_Order_of_Translation">The Order of Translation</A>
<DT>- P -
<DD><A HREF="#The_Parameters_to_the_Function_main">The Parameters to the Function main</A>
<BR><A HREF="#Partial_Data_Hiding">Partial Data Hiding</A>
<BR><A HREF="#Phrase_Structure_Grammar">Phrase Structure Grammar</A>
<BR><A HREF="#Pointers">Pointers</A>
<BR><A HREF="#PostMIncrement_and_PostMDecrement">Post-Increment and Post-Decrement</A>
<BR><A HREF="#Postfix_Operators">Postfix Operators</A>
<BR><A HREF="#PreMIncrement_and_PreMDecrement_Operators">Pre-Increment and Pre-Decrement Operators</A>
<BR><A HREF="#Preprocessing_Directives">Preprocessing Directives</A>
<BR><A HREF="#Preprocessing_Directives_Grammar">Preprocessing Directives Grammar</A>
<BR><A HREF="#The_Preprocessor">The Preprocessor</A>
<BR><A HREF="#Primary_Expressions">Primary Expressions</A>
<BR><A HREF="#Programming_Style">Programming Style</A>
<BR><A HREF="#Providing_Other_Information_to_the_Compiler">Providing Other Information to the Compiler</A>
<DT>- Q -
<DD><A HREF="#Qualifiers">Qualifiers</A>
<DT>- R -
<DD><A HREF="#Ranges_of_Types">Ranges of Types</A>
<BR><A HREF="#Redefining_a_Macro">Redefining a Macro</A>
<BR><A HREF="#Reducing_Recompilation_Time">Reducing Recompilation Time</A>
<BR><A HREF="#The_register_Storage_Class">The register Storage Class</A>
<BR><A HREF="#Registers">Registers</A>
<BR><A HREF="#Relational_Operators">Relational Operators</A>
<BR><A HREF="#Rescanning_for_Further_Replacement">Rescanning for Further Replacement</A>
<BR><A HREF="#The_return_Statement">The return Statement</A>
<BR><A HREF="#Rewriting_and_Redesigning_Modules">Rewriting and Redesigning Modules</A>
<DT>- S -
<DD><A HREF="#A_Sample_Program">A Sample Program</A>
<BR><A HREF="#Segment_Constant_Based_Pointers_and_Objects">Segment Constant Based Pointers and Objects</A>
<BR><A HREF="#Segment_Object_Based_Pointers">Segment Object Based Pointers</A>
<BR><A HREF="#Selection_Statements">Selection Statements</A>
<BR><A HREF="#Self_Based_Pointers">Self Based Pointers</A>
<BR><A HREF="#SideMeffects_in_Macros">Side-effects in Macros</A>
<BR><A HREF="#Signed_and_Unsigned_Integer_Conversion">Signed and Unsigned Integer Conversion</A>
<BR><A HREF="#Simple_Argument_Substitution">Simple Argument Substitution</A>
<BR><A HREF="#Simple_Assignment">Simple Assignment</A>
<BR><A HREF="#The_sizeof_Operator">The sizeof Operator</A>
<BR><A HREF="#The_Small_and_Big_Code_Models">The Small and Big Code Models</A>
<BR><A HREF="#The_Small_and_Big_Data_Models">The Small and Big Data Models</A>
<BR><A HREF="#Special_Features">Special Features</A>
<BR><A HREF="#Special_Pointer_Types_for_Open_Watcom_CD16">Special Pointer Types for Open Watcom C/16</A>
<BR><A HREF="#Special_Pointer_Types_for_Open_Watcom_CD32">Special Pointer Types for Open Watcom C/32</A>
<BR><A HREF="#Standard_Keywords">Standard Keywords</A>
<BR><A HREF="#Standard_Predefined_Macros">Standard Predefined Macros</A>
<BR><A HREF="#Statements">Statements</A>
<BR><A HREF="#The_static_Storage_Class">The static Storage Class</A>
<BR><A HREF="#Static_Storage_Duration">Static Storage Duration</A>
<BR><A HREF="#Storage_Classes">Storage Classes</A>
<BR><A HREF="#String_Literals">String Literals</A>
<BR><A HREF="#Strings">Strings</A>
<BR><A HREF="#Structure_and_Union_Members">Structure and Union Members</A>
<BR><A HREF="#Structures">Structures</A>
<BR><A HREF="#Structures__Unions__Enumerations_and_BitMFields">Structures, Unions, Enumerations and Bit-Fields</A>
<BR><A HREF="#The_switch_Statement">The switch Statement</A>
<DT>- T -
<DD><A HREF="#Translation">Translation</A>
<BR><A HREF="#Translation_Limits">Translation Limits</A>
<BR><A HREF="#Trigraphs">Trigraphs</A>
<BR><A HREF="#Type_Conversion">Type Conversion</A>
<BR><A HREF="#Type_Definitions">Type Definitions</A>
<BR><A HREF="#Type_Specifiers">Type Specifiers</A>
<DT>- U -
<DD><A HREF="#Unary_Arithmetic_Operators">Unary Arithmetic Operators</A>
<BR><A HREF="#Unary_Operators">Unary Operators</A>
<BR><A HREF="#Unexpected_Operator_Precedence">Unexpected Operator Precedence</A>
<BR><A HREF="#Uninitialized_Objects">Uninitialized Objects</A>
<BR><A HREF="#Unions">Unions</A>
<BR><A HREF="#Use_Comments">Use Comments</A>
<BR><A HREF="#Use_Function_Prototypes">Use Function Prototypes</A>
<BR><A HREF="#Use_Included_Files_to_Organize_Structures">Use Included Files to Organize Structures</A>
<BR><A HREF="#Use_static_for_Most_Functions">Use static for Most Functions</A>
<BR><A HREF="#Uses">Uses</A>
<BR><A HREF="#Using_the_Preprocessor_to_Aid_Portability">Using the Preprocessor to Aid Portability</A>
<DT>- V -
<DD><A HREF="#Variable_Argument_Lists">Variable Argument Lists</A>
<BR><A HREF="#Variable_Argument_Macros">Variable Argument Macros</A>
<BR><A HREF="#Visually_Align_Object_Declarations">Visually Align Object Declarations</A>
<BR><A HREF="#Void">Void</A>
<BR><A HREF="#Void_Based_Pointers">Void Based Pointers</A>
<DT>- W -
<DD><A HREF="#The_while_Statement">The while Statement</A>
<BR><A HREF="#Wide_Character_Constants">Wide Character Constants</A>
<BR><A HREF="#Wide_String_Literals">Wide String Literals</A>
<BR><A HREF="#Writing_Portable_Programs">Writing Portable Programs</A>
</DL>
<H1 ID="Introduction_to_C"> Introduction to C </H1>
<BR><IMG SRC="clr.bmp">
<H2 ID="History"> History </H2>
<BR>The C programming language was developed by Dennis Ritchie in 1972 for the UNIX operating system.&nbsp; Over the years,
the language has appeared on many other systems, satisfying a need of programmers who want to be able to develop applications
that can run in many different environments.
<BR><BR>Because the C language was never formally defined, each implementation interpreted the behavior of the language in
slightly different ways, and also introduced their own extensions.&nbsp; As a result, the goal of true software portability
was not achieved.
<BR><BR>In 1982, the American National Standards Committee formed the X3J11 Technical Committee on the C Programming Language,
whose purpose was to formally define the C language and its library functions, and to describe its interaction with the execution
environment.&nbsp; The C Programming Language standard was completed in 1989.
<BR><BR>The Open Watcom C/16 and C/32 compiler has evolved from 8086 code generation technology developed and refined at WATCOM
International and the University of Waterloo since 1980.&nbsp; The first Open Watcom C/16 compiler was released in 1988.&nbsp;
The first Open Watcom C/32 compiler was released in 1989.
<H2 ID="Uses"> Uses </H2>
<BR>C is sometimes called a &quot;low-level&quot; language, referring to the fact that C programmers tend to think in terms
of bits, bytes, addresses and other concepts fundamental to assembly-language programming.
<BR><BR>But C is also a &quot;broad spectrum&quot; language.&nbsp; In addition to accessing the basic components of the computer,
it also provides features common to many &quot;high-level&quot; languages.&nbsp; Structured program control, data structures
and modular program design are recent additions to some high-level languages, but have been part of the C language since its
inception.
<BR><BR>C gives the programmer the ability to write applications at a level just above the assembly language level, without
having to know the assembly language of the machine.&nbsp; Language compilers provided this ability in the past, but the application
was often quite &quot;fat&quot;, because the code produced by the compiler was never as good as could be written by a good
assembly language programmer.&nbsp; But with modern code generation techniques it is often difficult, if not impossible, to
distinguish an assembly language program written by a human from the same program generated by a C compiler (based on code
size).&nbsp; In fact, some compilers now generate better code than all but the best assembly language programmers.
<BR><BR>So, what can C be used for?&nbsp; It can be used to write virtually anything, the same way that assembly language
can be used.&nbsp; But other programming languages continue to be used for specific programming applications at which they
excel.
<BR><BR>C tends to be used for &quot;systems programming&quot;, a term that refers to the writing of operating systems, programming
languages and other software tools that don't fall into the class of &quot;applications programming&quot;.&nbsp; A classic
example is the UNIX operating system, developed by Bell Laboratories.&nbsp; It is written almost entirely in C and is one
of the most portable operating systems available.
<BR><BR>C is also used for writing large programs that require more efficiency than the average application.&nbsp; Typical
examples are interpreters and compilers for programming languages.
<BR><BR>Another area where C is commonly used is large-scale application programs, such as databases, spreadsheets, word processors
and so on.&nbsp; These require a high degree of efficiency and compactness, since they are often basic to an individual's
or company's computing needs, and therefore consume a lot of computer resources.
<BR><BR>It seems that C is used extensively for commercially available products, but C can also be used for any application
that just requires more efficiency.&nbsp; For example, a large transaction processing system may be written in COBOL, but
to squeeze the last bit of speed out of the system, it may be desirable to rewrite it in C.&nbsp; That application could certainly
be written in assembly language, but many programmers now prefer to avoid programming at such a low level, when a C compiler
can generate code that is just as efficient.
<BR><BR>Finally, of course, a major reason for writing a program in C is that it will run with little or no modification on
any system with a C compiler.&nbsp; In the past, with the proliferation of C compilers and no standard to guide their design,
it was much more difficult.&nbsp; Today, with the appearance of the ISO standard for the C programming language, a program
written entirely in a conforming C implementation should be transportable to a new compiler with relatively little work.&nbsp;
Of course, issues like file names, memory layout and command line parameter syntax will vary from one system to another, but
a properly designed C application will isolate these parts of the code in &quot;system-dependent&quot; files, which can be
changed for each system.&nbsp; (Refer to &quot;Writing Portable Programs&quot;.)
<H2 ID="Advantages"> Advantages </H2>
<BR>C has a number of major advantages over other programming languages.
<UL>
<LI>Most systems provide a C compiler.
</UL>
<BR>Vendors of computer systems realize that the success of a system is dependent upon the availability of software for that
system.&nbsp; With the large body of C-based programs in existence, most vendors provide a C compiler in order to encourage
the transporting of some of these programs to their system.&nbsp; For systems that don't provide a C compiler, independent
companies may develop a compiler.
<BR><BR>With the development of the ISO/ANSI C standard, the trend towards universal availability of C compilers will probably
accelerate.
<UL>
<LI>C programs can be transported easily to other computers and operating systems.
</UL>
<BR>Many programming languages claim transportability.&nbsp; FORTRAN, COBOL and Pascal programs all have standards describing
them, so a program written entirely within the standard definition of the language will likely be portable.&nbsp; The same
is true of C.&nbsp; However, few languages can match portability with the other advantages of C, including efficiency of generated
code and the ability to work close to the machine level.
<UL>
<LI>Programs written in C are very efficient in both execution speed and code size.
</UL>
<BR>Few languages can match C in efficiency.&nbsp; A good assembly language programmer may be able to produce code better
than a C compiler, but he/she will have to spend much more time in the development of the application, because assembly language
programming lends itself more easily to errors.&nbsp; Compilers for other languages may produce efficient code for applications
within their scope, but few produce efficient code for<B> all</B> applications.
<UL>
<LI>C programs can get close to the hardware, controlling devices directly if necessary.
</UL>
<BR>Most programs do not need this ability, but if necessary, the program can access particular features of the computer.
&nbsp;For example, a fixed memory location may exist that contains a certain value of use to the program.&nbsp; It is easy
to access it from C, but not from many other languages.&nbsp; (Of course, if the program is designed to be portable, this
section of code will be isolated and clearly marked as depending on the operating system.)
<UL>
<LI>C programs are easy to maintain.
</UL>
<BR>Assembly language code is difficult to maintain owing to the very low level of programming (registers, addressing modes,
branching).&nbsp; C programs provide comparable functionality, but at a higher level.&nbsp; The programmer still thinks in
terms of machine capabilities, but without having to know the exact operation of the hardware, leaving the programmer free
to concentrate on program design rather than the intimate details of coding on that particular machine.
<UL>
<LI>C programs are easy to understand.
</UL>
<BR>&quot;Easy&quot; is, of course, a relative term.&nbsp; C programs are definitely easier to understand than the equivalent
assembly language program.&nbsp; Another programming language may be easier to understand for a particular kind of application,
but in general C is a good choice.
<UL>
<LI>All of the above advantages apply regardless of the application or the hardware or operating system on which it is running.
</UL>
<BR>This is the biggest advantage.&nbsp; Because C programs are portable, and C is not suited only to a certain class of applications,
it is often the best choice for developing an application.
<H2 ID="How_to_Use_This_Book"> How to Use This Book </H2>
<BR>This book is a description of the C programming language as implemented by the Open Watcom C/16 and C/32 compilers for
the 80x86 family of processors.&nbsp; It is intended to be an easy-to-read description of the C language.&nbsp; The ISO C
standard is the last word on details about the language, but it describes the language in terms that must be interpreted for
each implementation of a C compiler.
<BR><BR>This book attempts to describe the C language in terms of general behavior, and the specific behavior of the C compiler
when the standard describes the behavior as <B> implementation-defined.</B>
<BR><BR><B>&nbsp; Areas that are shaded describe the interpretation of the behavior that the Open Watcom C/16 and C/32 compilers
follow.</B>
<BR><BR>Programmers who are writing a program that will be ported to other systems should pay particular attention when using
these features, since other compilers may behave in other ways.&nbsp; As much as possible, an attempt is made to describe
other likely behaviors.
<BR><BR>This book does not describe any of the library functions that a C program might use to interact with its environment.
&nbsp;In particular, input and output is not described in this manual.&nbsp; The C language does not contain any I/O capabilities.
&nbsp;The Open Watcom C Library Reference manual describes all of the library functions, including those used for input and
output.
<BR><BR>A glossary is included in the appendix, and describes all terms used in the book.
<H1 ID="Notation"> Notation </H1>
<BR><BR>The C programming language contains many useful features, each of which has a number of optional parts.&nbsp; The
ISO C standard describes the language in very precise terms, often giving syntax diagrams to describe the features.
<BR><BR>This book attempts to describe the C language in more friendly terms.&nbsp; Where possible, features are described
using ordinary English.&nbsp; Jargon is avoided, although by necessity, new terminology is introduced throughout the book.
&nbsp;A glossary is provided at the end of the book to describe any terms that are used.
<BR><BR>Where the variety of features would create excessive amounts of text, simple syntax diagrams are used.&nbsp; It is
hoped that these are mostly self-explanatory.&nbsp; However, a brief explanation of the notation used is offered here:
<OL>
<LI>Required keywords are in normal lettering style (for example,<TT> enum</TT>).
<LI>Terms that describe a class of object that replace the term are in italics (for example,<B> identifier</B>).
<LI>When two or more optional forms are available, they are shown as follows:
<BR><BR><B>&nbsp; form 1</B>
<BR><B>&nbsp; or</B>
<BR><B>&nbsp; form 2</B>
<LI>Any other symbol that appears is required, unless otherwise noted.
</OL>
<BR>The following example is for an enumerated type:
<BR><BR><TT>&nbsp; enum</TT><B> identifier</B>
<BR><B>&nbsp; or</B>
<BR><TT>&nbsp; enum</TT> {<B> enumeration-constant-list</B> }
<BR><B>&nbsp; or</B>
<BR><TT>&nbsp; enum</TT><B> identifier</B> {<B> enumeration-constant-list</B> }
<BR><BR>An enumerated type has three forms:
<OL>
<LI>The required keyword <TT> enum</TT> followed by an identifier that names the type.&nbsp; The identifier is chosen by the
programmer.
<LI>The required keyword <TT> enum</TT> followed by a brace-enclosed list of enumeration constants.&nbsp; The braces are required,
and<B> enumeration-constant-list</B> is described elsewhere.
<LI>The required keyword <TT> enum</TT> followed by an identifier and a brace-enclosed list of enumeration constants.&nbsp;
As with the previous two forms, the identifier may be chosen by the programmer, the braces are required and<B> enumeration-constant-list</B>
is described elsewhere.
</OL>
<H1 ID="Basic_Language_Elements"> Basic Language Elements </H1>
<BR>The following topics are discussed:
<UL>
<LI>Character Sets
<LI>Keywords
<LI>Identifiers
<LI>Comments
</UL>
<H2 ID="Character_Sets"> Character Sets </H2>
<BR>The<B> source character set</B> contains the characters used during the translation of the C source file into object code.
&nbsp;The <B> execution character set</B> contains the characters used during the execution of the C program.&nbsp; In most
cases, these two character sets are the same, since the program is compiled and executed on the same machine.&nbsp; However,
C is sometimes used to <B> cross-compile,</B> whereby the compilation of the program occurs on one machine, but the compiler
generates code for some other machine.&nbsp; If the two machines have different character sets (say EBCDIC and ASCII), then
the compiler will, where appropriate, map characters from the source character set to the execution character set.&nbsp; This
mapping is implementation-defined, but generally maps the visual representation of the character.
<BR><BR>Regardless of which C compiler is used, the source and execution character sets contain (at least) the following characters:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; a b c d e f g h i j k l m n o p q r s t u v w x y z</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; A B C D E F G H I J K L M N O P Q R S T U V W X Y Z</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0 1 2 3 4 5 6 7 8 9</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ! &quot; # % &amp; ' ( ) * + , - . /</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; : ; &lt; = &gt; ? [ \ ] ^ _ { | } ~</TT>
<BR><BR>as well as the<B> space</B> (blank), <B> horizontal tab,</B> <B> vertical tab</B> and <B> form feed.</B>&nbsp; Also,
a <B> new line</B> character will exist for both the source and execution character sets.
<BR><BR>Any character other than those previously listed should appear in a source file in a character constant, a string
or a comment, otherwise the behavior is undefined.
<BR><BR>If the character set of the computer being used to compile the program does not contain a certain character, a <B>
trigraph</B> sequence may be used to represent it.&nbsp; Refer to the section &quot;Character Constants&quot;.
<BR><BR><B>&nbsp; The Open Watcom C/16 and C/32 compilers use the full IBM PC character set as both the source and execution
character sets.&nbsp; The set of values from hexadecimal 00 to 7F constitute the ASCII character set.</B>
<H3 ID="Multibyte_Characters"> Multibyte Characters </H3>
<BR>A multibyte character, as its name implies, is a character whose representation consists of more than one byte.&nbsp;
Multibyte characters allow compilers to provide extended character sets, often for human languages that contain more characters
than those found in the one-byte character set.
<BR><BR>Multibyte characters are generally restricted to:
<UL>
<LI>comments,
<LI>string literals,
<LI>character constants,
<LI>header names.
</UL>
<BR>The method for specifying multibyte characters generally varies depending upon the extended character set.
<H2 ID="Keywords"> Keywords </H2>
<BR>The following words are reserved as part of the C language and are called<B> keywords.</B>&nbsp; They may not be used
for any kind of identifier, including object names, function names, labels, structure or union tags (names).&nbsp; 
<BR><BR><TT>&nbsp; auto&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inline
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static</TT>
<BR><TT>&nbsp; _Bool&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct</TT>
<BR><TT>&nbsp; break&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enum&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch</TT>
<BR><TT>&nbsp; case&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; extern&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; register&nbsp;
&nbsp;&nbsp; typedef</TT>
<BR><TT>&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; restrict
&nbsp;&nbsp;&nbsp; union</TT>
<BR><TT>&nbsp; _Complex&nbsp;&nbsp;&nbsp;&nbsp; for&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; unsigned</TT>
<BR><TT>&nbsp; const&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void</TT>
<BR><TT>&nbsp; continue&nbsp;&nbsp;&nbsp;&nbsp; if&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signed&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; volatile</TT>
<BR><TT>&nbsp; default&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _Imaginary&nbsp;&nbsp; sizeof&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while</TT>
<BR><TT>&nbsp; do</TT>
<BR><BR>The Open Watcom compilers also reserve the following extended keywords:
<BR><BR>Microsoft compilers compatible 
<BR><TT>&nbsp; __asm&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __finally&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __pascal</TT>
<BR><TT>&nbsp; __based&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __fortran&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __saveregs</TT>
<BR><TT>&nbsp; __cdecl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __huge&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __segment</TT>
<BR><TT>&nbsp; __declspec&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __inline&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; __segname</TT>
<BR><TT>&nbsp; __except&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __int64&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __self</TT>
<BR><TT>&nbsp; __export&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __interrupt&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; __stdcall</TT>
<BR><TT>&nbsp; __far&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __leave&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __syscall</TT>
<BR><TT>&nbsp; __far16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __loadds&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __try</TT>
<BR><TT>&nbsp; __fastcall&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __near&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __unaligned</TT>
<BR><BR>IBM compilers compatible
<BR><TT>&nbsp; _Cdecl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _Finally&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _Seg16</TT>
<BR><TT>&nbsp; _Except&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _Leave&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _Syscall</TT>
<BR><TT>&nbsp; _Export&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _Packed&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _System</TT>
<BR><TT>&nbsp; _Far16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _Pascal&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _Try</TT>
<BR><TT>&nbsp; _Fastcall</TT>
<BR><BR>Open Watcom specific
<BR><TT>&nbsp; __builtin_isfloat&nbsp;&nbsp; __ow_imaginary_unit</TT>
<BR><TT>&nbsp; __watcall</TT>
<BR><BR>Note that, since C is sensitive to the case of letters, changing one or more letters in a keyword to upper case will
prevent the compiler from recognizing it as a keyword, thereby allowing it to be used as an identifier.&nbsp; However, this
is not a recommended programming practice.
<H2 ID="Identifiers"> Identifiers </H2>
<BR>Identifiers are used as:
<UL>
<LI>object or variable names,
<LI>function names,
<LI>labels,
<LI>structure, union or enumeration tags,
<LI>the name of a member of a structure or union,
<LI>enumeration constants, 
<LI>macro names,
<LI>typedef names.
</UL>
<BR>An identifier is formed by a sequence of the following characters:
<UL>
<LI>upper-case letters &quot;A&quot; through &quot;Z&quot;,
<LI>lower-case letters &quot;a&quot; through &quot;z&quot;,
<LI>the digits &quot;0&quot; through &quot;9&quot;,
<LI>the underscore &quot;_&quot;.
</UL>
<BR>The first character may not be a digit.
<BR><BR>An identifier cannot be a member of the list of keywords.
<BR><BR>Identifiers can consist of any number of characters, but the compiler is not required to consider more than 31 characters
as being significant, provided the identifier does not have <B> external linkage</B> (shared by more than one compiled module
of the program).&nbsp; If the identifier is external, the compiler is not required to consider more than 6 characters as being
significant.&nbsp; External identifiers may be case-sensitive.
<BR><BR>Of course, any particular compiler may choose to consider more characters as being significant, but a portable C program
will strictly adhere to the above rules.&nbsp; (This restriction is likely to be relaxed in future versions of the ISO C standard
and corresponding C compilers.)
<BR><BR><B>&nbsp; The Open Watcom C/16 and C/32 compilers do not restrict the number of significant characters for functions
or objects with external or internal linkage.</B>
<BR><BR><B>&nbsp; The linker provided with Open Watcom C/16 and C/32 restricts the number of significant characters in external
identifiers to 40 characters, and by default, distinguishes between identifiers that differ only in the case of the letters.
&nbsp;An option may be used to force the linker to ignore case differences.</B>
<BR><BR>Any external identifier that starts with the underscore character (&quot;_&quot;) may be reserved by the compiler.
&nbsp;Any other identifier that starts with two underscores, or an underscore and an upper-case letter may be reserved.&nbsp;
Generally, a program should avoid creating identifiers that start with an underscore.
<H2 ID="Comments"> Comments </H2>
<BR>A<B> comment</B> is identified by<TT> /*</TT> followed by any characters and terminated by<TT> */.</TT>&nbsp; Comments
are recognized anywhere in a program, except inside a character constant or string.&nbsp; Once the<TT> /*</TT> is found, characters
are examined only until the<TT> */</TT> is found.&nbsp; This excludes nesting of comments.
<BR><BR>A comment is treated as a &quot;white-space&quot; character, meaning that it is like a space character.
<BR><BR>For example, the program fragment,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* Close all the files.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; fcount; i++ ) { /* loop through list */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( flist[i] );&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; /* close the file */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>is equivalent to,
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; fcount; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( flist[i] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>Comments are sometimes used to temporarily remove a section of code during testing or debugging of a program.&nbsp;
For example, the second program fragment could be &quot;commented out&quot; as follows:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /*</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; fcount; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( flist[i] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><BR>This technique will not work on the first fragment because it contains comments, and comments may not be nested.&nbsp;
For these cases, the <TT> #if</TT> directive of the C preprocessor may be used.&nbsp; Refer to the chapter &quot;The Preprocessor&quot;
for more details.
<BR><BR><B>&nbsp; The Open Watcom C/16 and C/32 compilers support an extension for comments.&nbsp; The symbol</B><TT> //</TT><B>
can be used at any point in a physical source line (except inside a character constant or string literal).&nbsp; Any characters
from the</B><TT> //</TT><B> to the end of the line are treated as comment characters.&nbsp; The comment is terminated by the
end of the line.&nbsp; There is no explicit symbol for terminating the comment.&nbsp; For example, the program fragment used
at the beginning of this section can be rewritten as,</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Close all the files.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; fcount; i++ ) { // loop through
list</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( flist[i] );&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // close the file</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><B>&nbsp; This form of comment can be used to &quot;comment out&quot; code without the difficulties encountered with</B><TT>
/*.</TT>
<H1 ID="Basic_Types"> Basic Types </H1>
<BR>The following topics are discussed:
<UL>
<LI>Declarations of Objects
<LI>Integer Types
<LI>Floating-Point Types
<LI>Enumerated Types
<LI>Arrays
<LI>Strings
</UL>
<H2 ID="Declarations_of_Objects"> Declarations of Objects </H2>
<BR>When a name is used in a program, the compiler needs to know what that name represents.&nbsp; A <B> declaration</B> describes
to the compiler what a name is, including:
<UL>
<LI>How much storage it occupies (objects) or how much storage is required for the value that is returned (functions), and
how the value in that storage is to be interpreted.&nbsp; This is called the<B> type.</B>&nbsp; Examples include<TT> int</TT>,<TT>
float</TT> and<TT> struct list</TT>.
<LI>Whether the name is visible only within the module being compiled, or throughout the program.&nbsp; This is called the<B>
linkage,</B> and is part of the<B> storage class.</B>&nbsp; The keywords <TT> extern</TT> and <TT> static</TT> determine the
linkage.
<LI>For object names, whether the object is created every time the function is called and destroyed every time the function
returns.&nbsp; This is called the<B> storage duration,</B> and is part of the<B> storage class.</B>&nbsp; The keywords <TT>
extern</TT>, <TT> static</TT>, <TT> auto</TT> and <TT> register</TT> determine the storage duration.
</UL>
<BR>The placement of the declaration within the program determines whether the declaration applies to all functions within
the module, or just to the function within which the declaration appears.
<BR><BR>The<B> definition</B> of an object is similar to its declaration, except that the storage for the object is reserved.
&nbsp;Whether the declaration of an object is also a definition depends upon the placement of the declaration and the attributes
of the object.
<BR><BR>The usual form for defining (creating) an object is as follows:
<BR><BR><B>&nbsp; storage-class-specifier type-specifier declarator</B><TT>;</TT>
<BR><B>&nbsp; or</B>
<BR><B>&nbsp; storage-class-specifier type-specifier declarator</B><TT> =</TT><B> initializer</B><TT>;</TT>
<BR><BR>The<B> storage-class-specifier</B> is optional, and is thoroughly discussed in the chapter &quot;Storage Classes&quot;.
&nbsp;The<B> type-specifier</B> is also optional, and is thoroughly discussed in the next section and in the chapter &quot;Advanced
Types&quot;.&nbsp; At least one of the<B> storage-class-specifier</B> and<B> type-specifier</B> must be specified, and they
may be specified in either order, although it is recommended that the<B> storage-class-specifier</B> always be placed first.
<BR><BR>The<B> declarator</B> is the name of the object being defined along with other information about its type.&nbsp; There
may be several declarators, separated by commas.
<BR><BR>The<B> initializer</B> is discussed in the chapter &quot;Initialization of Objects&quot;.
<BR><BR>The following are examples of declarations of objects, along with a brief description of what each one means.&nbsp;
A more complete discussion of the terms used may be found in the relevant section.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int x;</TT>
<DL>
<DT>Inside a function
<DD>The object<TT> x</TT> is declared to be an<B> integer,</B> with<B> automatic storage duration</B>.&nbsp; Its value is available
only within the function (or compound statement) in which it is defined.&nbsp; This is also a definition.
</DL>
<DL>
<DT>Outside a function
<DD>The object<TT> x</TT> is created and declared to be an<B> integer</B> with<B> static storage duration</B>.&nbsp; Its value
is available within the<B> module</B> in which it is defined, and has<B> external linkage</B> so that any other module may
refer to it by using the declaration,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int x;</TT>
<BR><BR>This is also a definition.
</DL>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; register void * memptr;</TT>
<DL>
<DT>Inside a function
<DD>The object<TT> memptr</TT> is declared to be a<B> pointer to</B> <TT> void</TT> (no particular type of object), and is used
frequently in the function.&nbsp; This is also a definition.
</DL>
<DL>
<DT>Outside a function
<DD>Not valid because of the <TT> register</TT> storage class.
</DL>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; auto long int x, y;</TT>
<DL>
<DT>Inside a function
<DD>The objects<TT> x</TT> and<TT> y</TT> are declared to be<B> signed long integers</B> with<B> automatic storage duration</B>.
&nbsp;This is also a definition.
</DL>
<DL>
<DT>Outside a function
<DD>Not valid because of the <TT> auto</TT> storage class.
</DL>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static int nums[10];</TT>
<DL>
<DT>Inside a function
<DD>The object<TT> nums</TT> is declared to be an<B> array of 10 integers</B> with<B> static storage duration</B>.&nbsp; Its value
is only available within the function, and will be preserved between calls to the function.&nbsp; This is also a definition.
</DL>
<DL>
<DT>Outside a function
<DD>The object<TT> nums</TT> is declared to be an<B> array of 10 integers</B> with<B> static storage duration</B>.&nbsp; Its value
is only available within the<B> module</B>.&nbsp; (The difference is the <B> scope</B> of the object<TT> nums</TT>.) This
is also a definition.
</DL>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int x;</TT>
<DL>
<DT>Inside a function
<DD>The object<TT> x</TT> is declared to be an<B> integer</B> with<B> static storage duration</B>.&nbsp; No other functions within
the current module may refer to<TT> x</TT> unless they also declare it.&nbsp; The object is defined in another module, or
elsewhere in this function or module.
</DL>
<DL>
<DT>Outside a function
<DD>The object<TT> x</TT> is declared to be an<B> integer</B> with<B> static storage duration</B>.&nbsp; Its value is available
to all functions within the module.&nbsp; The object is defined in another module, or elsewhere in this module.
</DL>
<BR>The appendix &quot;Examples of Declarations&quot; contains many more examples of declarations of objects and functions.
<H2 ID="Name_Scope"> Name Scope </H2>
<BR>An identifier may be referenced only within its<B> scope</B>.&nbsp; 
<BR><BR>An identifier declared within a function or within a compound statement within a function has<B> block</B> scope,
and may be referenced only in the block in which it is declared.&nbsp; The object's scope includes any enclosed blocks and
terminates at the } which terminates the enclosing block.
<BR><BR>An identifier declared within a function prototype (as a parameter to that function) has<B> function prototype</B>
scope, and may not be referenced elsewhere.&nbsp; Its scope terminates at the ) which terminates the prototype.
<BR><BR>An identifier declared outside of any function or function prototype has<B> file</B> scope, and may be referenced
anywhere within the module in which it is declared.&nbsp; If a function contains a declaration for the same identifier, the
identifier with file scope is hidden within the function.&nbsp; Following the terminating } of the function, the identifier
with file scope becomes visible again.
<BR><BR>A label, which must appear within a function, has<B> function</B> scope.
<H2 ID="Type_Specifiers"> Type Specifiers </H2>
<BR>Every object has a<B> type</B> associated with it.&nbsp; Functions may be defined to return a value, and that value also
has a type.&nbsp; The type describes the interpretation of a value of that type, such as whether it is signed or unsigned,
a pointer, etc.&nbsp; The type also describes the amount of storage required.&nbsp; Together, the amount of storage and the
interpretation of stored values describes the range of values that may be stored in that type.
<BR><BR>There are a number of different types defined by the C language.&nbsp; They provide a great deal of power in selecting
methods for storing and moving data, and also contribute to the readability of the program.
<BR><BR>There are a number of &quot;basic types&quot;, those which will appear in virtually every program.&nbsp; More sophisticated
types provide methods to describe data structures, and are discussed in the chapter &quot;Advanced Types&quot;.
<BR><BR>A<B> type specifier</B> is one or more of:
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char</TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; double</TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; float</TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int</TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; long</TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; short</TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; signed</TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned</TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void</TT>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp; enumeration</B>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp; structure</B>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp; union</B>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp; typedef name</B>
<BR><BR>and may also include the following<B> type qualifiers</B>:
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; const</TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; volatile</TT>
<BR><BR><B>&nbsp; The Open Watcom compilers also provide the following extended</B><B><I> type qualifiers</I></B><B>:</B>
<BR><BR><B>&nbsp; </B>
<BR><TT>&nbsp;&nbsp;&nbsp; __based&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __fortran&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; _Seg16</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _Cdecl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __huge&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __segment</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; __cdecl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __inline&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __segname</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; __declspec&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __int64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; __self</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _Export&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __interrupt&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; __stdcall</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; __export&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __loadds&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; _Syscall</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; __far&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __near&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __syscall</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _Far16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _Packed&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _System</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; __far16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _Pascal&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __unaligned</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; _Fastcall&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __pascal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; __watcall</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; __fastcall&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __saveregs</TT>
<BR><BR>&nbsp; For the extended type qualifiers, see the appendix &quot;Compiler Keywords&quot;.
<BR><BR>Various combinations of these keywords may be used when declaring an object.&nbsp; Refer to the section on the type
being defined.
<BR><BR>The main types are <TT> char</TT>, <TT> int</TT>, <TT> float</TT> and <TT> double</TT>.&nbsp; The keywords <TT> short</TT>,
<TT> long</TT>, <TT> signed</TT>, <TT> unsigned</TT>, <TT> const</TT> and <TT> volatile</TT> modify these types.
<H2 ID="Integer_Types"> Integer Types </H2>
<BR>The most commonly used type is the integer.&nbsp; Integers are used for storing most numbers that do not require a decimal
point, such as counters, sizes and indices into arrays.&nbsp; The range of integers is limited by the underlying machine architecture
and is usually determined by the range of values that can be handled by the most convenient storage type of the hardware.
&nbsp;Most 16-bit machines can handle integers in the range<TT> -32768</TT> to<TT> 32767</TT>.&nbsp; Larger machines typically
handle integers in the range<TT> -2147483648</TT> to<TT> 2147483647</TT>.
<BR><BR>The general integer type includes a selection of types, specifying whether or not the value is to be considered as
signed (negative and positive values) or unsigned (non-negative values), character (holds one character of the character set),
short (small range), long (large range) or long long (very large range).
<BR><BR>Just specifying the type <TT> int</TT> indicates that the amount of storage should correspond to the most convenient
storage type of the hardware.&nbsp; The value is treated as being a signed quantity.&nbsp; According to the C language standard,
the minimum range for <TT> int</TT> is<TT> -32767</TT> to<TT> 32767</TT>, although a compiler may provide a greater range.
<BR><BR><B>&nbsp; With Open Watcom C/16, </B><TT> int</TT><B> has a range of</B><TT> -32768</TT><B> to</B><TT> 32767</TT><B>.</B>
<BR><BR><B>&nbsp; With Open Watcom C/32, </B><TT> int</TT><B> has a range of</B><TT> -2147483648</TT><B> to</B><TT> 2147483647</TT><B>.</B>
<BR><BR>Specifying the type <TT> char</TT> indicates that the amount of storage is large enough to store any member of the
execution character set.&nbsp; If a member of the required source character set (see &quot;Character Sets&quot;) is stored
in an object of type <TT> char</TT>, then the value is guaranteed to be positive.&nbsp; Whether or not other characters are
positive is implementation-defined.&nbsp; (In other words, whether <TT> char</TT> is signed or unsigned is implementation-defined.
&nbsp;If it is necessary for the object of type <TT> char</TT> to be signed or unsigned, then the object should be declared
explicitly, as described below.)
<BR><BR><B>&nbsp; The Open Watcom C/16 and C/32 compilers define </B><TT> char</TT><B> to be </B><TT> unsigned</TT><B>, allowing
objects of that type to store values in the range</B><TT> 0</TT><B> to</B><TT> 255</TT><B>.&nbsp; A command line switch may
be specified to cause </B><TT> char</TT><B> to be treated as </B><TT> signed</TT><B>.&nbsp; This switch should only be used
when porting a C program from a system where </B><TT> char</TT><B> is signed.</B>
<BR><BR>The <TT> int</TT> keyword may be specified with the keywords <TT> short</TT> or <TT> long</TT>.&nbsp; These keywords
provide additional information about the range of values to be stored in an object of this type.&nbsp; According to the C
language standard, a signed short integer has a minimum range of<TT> -32767</TT> to<TT> 32767</TT>.&nbsp; A signed long integer
has a minimum range of<TT> -2147483647</TT> to<TT> 2147483647</TT>.&nbsp; A signed long long integer has a minimum range of<TT>
-9223372036854775807</TT> to<TT> 9223372036854775807</TT>.
<BR><BR><B>&nbsp; With Open Watcom C/16 and C/32, </B><TT> short int</TT><B> has a range of</B><TT> -32768</TT><B> to</B><TT>
32767</TT><B>, while </B><TT> long int</TT><B> has a range of</B><TT> -2147483648</TT><B> to</B><TT> 2147483647</TT><B>, and
</B><TT> long long int</TT><B> has a range of</B><TT> -9223372036854775808</TT><B> to</B><TT> 9223372036854775807</TT><B>.</B>
<BR><BR>The <TT> char</TT> and <TT> int</TT> types may be specified with the keywords <TT> signed</TT> or <TT> unsigned</TT>.
&nbsp;These keywords explicitly indicate whether the type represents a signed or unsigned (non-negative) quantity.
<BR><BR>The keyword <TT> int</TT> may be omitted from the declaration if one (or more) of the keywords <TT> signed</TT>, <TT>
unsigned</TT>, <TT> short</TT> or <TT> long</TT> is specified.&nbsp; In other words, <TT> short</TT> is equivalent to <TT>
signed short int</TT> and <TT> unsigned long</TT> is equivalent to <TT> unsigned long int</TT>.
<BR><BR>The appendix &quot;Macros for Numerical Limits&quot; discusses a set of macro definitions describing the range and
other characteristics of the various numeric types.&nbsp; The macros from the header <TT> &lt;limits.h&gt;</TT>, which describe
the integer types, are discussed.
<BR><BR><B>&nbsp; The following table describes all of the various integer types and their ranges as implemented by the Open
Watcom C/16 and C/32 compilers.&nbsp; Note that the table is in order of increasing storage size.</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Minimum&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; Maximum</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; Value&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Value</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --------------------- --------------------- --------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signed char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -128&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 127</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 255</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 255</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -32768&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32767</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned short int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 65535</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int (C/16)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -32768&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32767</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int (C/32)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -2147483648&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
2147483647</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int (C/16)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 65535</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int (C/32)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;4294967295</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -2147483648&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; 2147483647</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; 4294967295</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long long int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -9223372036854775808
&nbsp;9223372036854775807</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long long int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 18446744073709551615</TT>
<BR><BR><B>&nbsp; With Open Watcom C/16, an object of type </B><TT> int</TT><B> has the same range as an object of type </B><TT>
short int</TT><B>.</B>
<BR><BR><B>&nbsp; With Open Watcom C/32, an object of type </B><TT> int</TT><B> has the same range as an object of type </B><TT>
long int</TT><B>.</B>
<BR><BR>The following are some examples of declarations of objects with integer type:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
a;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; signed char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; short&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned short int e;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
f,g;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; signed&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; h;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
j;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; signed long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned long int&nbsp; m;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; signed long long&nbsp;&nbsp; n;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; long long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; o;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned long long p;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; long long int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; q;</TT>
<H2 ID="FloatingMPoint_Types"> Floating-Point Types </H2>
<BR>A floating-point number is a number which may contain a decimal point and digits following the decimal point.&nbsp; The
range of floating-point numbers is usually considerably larger than that of integers, but the efficiency of integers is usually
much greater.&nbsp; Integers are always exact quantities, whereas floating-point numbers sometimes suffer from round-off error
and loss of precision.
<BR><BR>On some computers, floating-point arithmetic is<B> emulated</B> (simulated) by software, rather than hardware.&nbsp;
Software emulation can greatly reduce the speed of a program.&nbsp; While this should not affect the portability of a program,
a prudent programmer limits the use of floating-point numbers.
<BR><BR>There are three floating-point number types, <TT> float</TT>, <TT> double</TT>, and <TT> long double</TT>.
<BR><BR>The appendix &quot;Macros for Numerical Limits&quot; discusses a set of macro definitions describing the range and
other characteristics of the various numeric types.&nbsp; The macros from the header <TT> &lt;float.h&gt;</TT>, which describe
the floating-point types, are discussed.
<BR><BR><B>&nbsp; The following table gives the ranges available on the 80x86/80x87 using the Open Watcom C/16 and C/32 compiler.
&nbsp;The floating-point format is the</B><B><I> IEEE Standard for Binary Floating-Point Arithmetic</I></B><B> (ANSI/IEEE
Std 754-1985).</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;Smallest&nbsp;&nbsp; Largest&nbsp;&nbsp;&nbsp; Digits&nbsp;&nbsp;&nbsp;&nbsp; 80x87</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;Absolute&nbsp;&nbsp; Absolute&nbsp;&nbsp; Of&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Type</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Value&nbsp;&nbsp;
&nbsp;&nbsp; Value&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Accuracy&nbsp;&nbsp; Name</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -----------&nbsp;&nbsp; --------&nbsp;&nbsp; --------&nbsp;&nbsp; --------&nbsp;
&nbsp;----------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.1E-38&nbsp;&nbsp;&nbsp;
3.4E+38&nbsp;&nbsp;&nbsp; 6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short real</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.2E-308&nbsp;&nbsp; 1.7E+308
&nbsp; 15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long real</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long double&nbsp;&nbsp; 2.2E-308&nbsp;&nbsp; 1.7E+308&nbsp;&nbsp; 15&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long real</TT>
<BR><BR><B>&nbsp; By default, the Open Watcom C/16 and C/32 compilers emulate floating-point arithmetic.&nbsp; If the 8087
or 80x87 Numeric Processor Extension (numeric coprocessor, math chip) will be present at execution time, the compiler can
be forced to generate floating-point instructions for the coprocessor by specifying a command line switch, as described in
the User's Guide.&nbsp; Other than an improvement in execution speed, the final result should be the same as if the processor
is not present.</B>
<BR><BR>The following are some examples of declarations of objects with floating-point type:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; float&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; double&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; long double c;</TT>
<H2 ID="Enumerated_Types"> Enumerated Types </H2>
<BR>Sometimes it is desirable to have a list of constant values representing different things, and the exact values are not
relevant.&nbsp; They may need to be unique or may have duplicates.&nbsp; For example, a set of actions, colors or keys might
be represented in such a list.&nbsp; An <B> enumerated type</B> allows the creation of a list of items.
<BR><BR>An <B> enumerated type</B> is a set of identifiers that correspond to constants of type <TT> int</TT>.&nbsp; These
identifiers are called <B> enumeration constants.</B>&nbsp; The first identifier in the set has the value 0, and subsequent
identifiers are given the previous value plus one.&nbsp; Wherever a constant of type <TT> int</TT> is allowed, an enumeration
constant may be specified.
<BR><BR>The following type specifier defines the set of actions available in a simple memo program:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; enum actions { DISPLAY, EDIT, PURGE };</TT>
<BR><BR>The enumeration constant<TT> DISPLAY</TT> is equivalent to the integer constant 0, and<TT> EDIT</TT> and<TT> PURGE</TT>
are equivalent to 1 and 2 respectively.
<BR><BR>An enumerated type may be given an optional <B> tag</B> (name) with which it may be identified elsewhere in the program.
&nbsp;In the example above, the tag of the enumerated type is<TT> actions</TT>, which becomes a new type.&nbsp; If no tag
is given, then only those objects listed following the definition of the type may have the enumerated type.
<BR><BR>The <B> name space</B> for enumerated type tags is different from that of object names, labels and member names of
structures and unions, so a tag may be the same identifier as one of these other kinds.&nbsp; An enumerated type tag may not
be the same as the tag of a structure or union, or another enumerated type.
<BR><BR>Enumeration constants may be given a specific value by specifying '<TT>=</TT>' followed by the value.&nbsp; For example,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; enum colors { RED = 1, BLUE = 2, GREEN = 4 };</TT>
<BR><BR>creates the constants<TT> RED, BLUE</TT> and<TT> GREEN</TT> with values 1, 2 and 4 respectively.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; enum fruits { GRAPE, ORANGE = 6, APPLE, PLUM };</TT>
<BR><BR>creates constants with values 0, 6, 7 and 8.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; enum fruits { GRAPE, PLUM, RAISIN = GRAPE, PRUNE = PLUM };</TT>
<BR><BR>makes<TT> GRAPE</TT> and<TT> RAISIN</TT> equal to 0, and<TT> PLUM</TT> and<TT> PRUNE</TT> equal to 1.
<BR><BR>The formal specification of an enumerated type is as follows:
<BR><BR><TT>&nbsp; enum</TT><B> identifier</B>
<BR><B>&nbsp; or</B>
<BR><TT>&nbsp; enum</TT> {<B> enumeration-constant-list</B> }
<BR><B>&nbsp; or</B>
<BR><TT>&nbsp; enum</TT><B> identifier</B> {<B> enumeration-constant-list</B> }
<BR><BR><B>&nbsp; enumeration-constant-list:</B>
<BR><B>&nbsp;&nbsp;&nbsp; enumeration-constant</B>
<BR><B>&nbsp; or</B>
<BR><B>&nbsp; enumeration-constant, enumeration-constant-list</B>
<BR><BR><B>&nbsp; enumeration-constant:</B>
<BR><B>&nbsp;&nbsp;&nbsp; identifier</B>
<BR><B>&nbsp; or</B>
<BR><B>&nbsp; identifier = constant-expression</B>
<BR><BR>The type of an enumeration is implementation-defined, although it must be compatible with an integer type.&nbsp; Many
compilers will use<TT> int</TT>.
<BR><BR><B>&nbsp; From the following table, the Open Watcom C/16 and Open Watcom C/32 compilers will choose the smallest type
that has sufficient range to represent all of the constants of a particular enumeration:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Smallest&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;Largest</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; Value&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Value</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ------------------&nbsp; ---------------------&nbsp; ----------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signed char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -128&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 127</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 255</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signed short&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -32768&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32767</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned short&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 65535</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signed long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -2147483648&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2147483647</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4294967295</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signed long long&nbsp;&nbsp;&nbsp; -9223372036854775808&nbsp;&nbsp;&nbsp;&nbsp;
9223372036854775807</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp; 18446744073709551615</TT>
<BR><BR><B>&nbsp; A command-line option may be used to force all enumerations to </B><TT> int</TT><B>.</B>
<BR><BR>To create an object with enumerated type, one of two forms may be used.&nbsp; The first form is to create the type
as shown above, and then to declare an object as follows:
<BR><BR><TT>&nbsp; enum</TT><B> tag object-name</B><TT>;</TT>
<BR><BR>For example, the declaration,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; enum fruits fruit;</TT>
<BR><BR>declares the object<TT> fruit</TT> to be the enumerated type<TT> fruits.</TT>
<BR><BR>The second form is to list the identifiers of the objects following the closing brace of the enumeration declaration.
&nbsp;For example,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; enum fruits { GRAPE, ORANGE, APPLE, PLUM } fruit;</TT>
<BR><BR>Provided no other objects with the same enumeration are going to be declared, the enumerated type tag<TT> fruits</TT>
is not required.&nbsp; The declaration could be specified as,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; enum { GRAPE, ORANGE, APPLE, PLUM } fruit;</TT>
<BR><BR>An identifier that is an enumeration constant may only appear in one enumeration type.&nbsp; For example, the constant<TT>
ORANGE</TT> may not be included in another enumeration, because the compiler would then have two values for<TT> ORANGE.</TT>
<H2 ID="Arrays"> Arrays </H2>
<BR>An<B> array</B> is a collection of objects which are all of the same type.&nbsp; All elements (objects) in the array are
stored in contiguous (adjacent) memory.
<BR><BR>References to array elements are usually made through<B> indexing</B> into the array.&nbsp; To facilitate this, the
elements of the array are numbered starting at zero.&nbsp; Hence an array declared with<TT> n</TT> elements is indexed using
indices between 0 and<TT> n-1.</TT>
<BR><BR>An array may either be given an explicit size (using a constant expression) or its size may be determined by the number
of values used to initialize it.&nbsp; Also, it is possible to declare an array without any size information, in the following
cases:
<UL>
<LI>a parameter to a function is declared as &quot;array of<B> type</B>&quot; (in which case the compiler alters the type
to be &quot;pointer to<B> type</B>&quot;),
<LI>an array object has external linkage (extern) and the definition which creates the array is given elsewhere,
<LI>the array is fully declared later in the same module.
</UL>
<BR>An array of undetermined size is an <B> incomplete type</B>.
<BR><BR>An array declaration is of the following form:
<BR><BR><B>&nbsp; type identifier</B><TT> [</TT><B> constant-expression</B><TT> ];</TT>
<BR><B>&nbsp; or</B>
<BR><B>&nbsp; type identifier</B><TT>[] = {</TT><B> initializer-list</B><TT> };</TT>
<BR><B>&nbsp; or</B>
<BR><B>&nbsp; type identifier</B><TT>[</TT><B> constant-expression</B><TT> ] = {</TT><B> initializer-list</B><TT> };</TT>
<BR><B>&nbsp; or</B>
<BR><B>&nbsp; type identifier</B><TT>[];</TT>
<BR><BR>where<B> type</B> is the type of each element of the array,<B> identifier</B> is the name of the array,<B> constant-expression</B>
is an expression that evaluates to a positive integer defining the number of elements in the array, and<B> initializer-list</B>
is a list of values (of type<B> type</B>) to be assigned to successive elements of the array.
<BR><BR>For example,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int values[10];</TT>
<BR><BR>declares<TT> values</TT> to be an array of 10 integers, with indices from 0 to 9.&nbsp; The expression<TT> values[5]</TT>
refers to the sixth integer in the array.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char text[] = { &quot;some stuff&quot; };</TT>
<BR><BR>declares<TT> text</TT> to be an array of 11 characters, each containing successive letters from<TT> &quot;some stuff&quot;.</TT>
&nbsp;The value of<TT> text[10]</TT> is<TT> '\0'</TT> (the null character), representing the terminating character in the
string (see Strings).
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern NODES nodelist[];</TT>
<BR><BR>declares<TT> nodelist</TT> to be an array of<TT> NODES</TT> (defined elsewhere), and the array is of unknown size.
&nbsp;In another source file or later in the current file, there must be a corresponding declaration of<TT> nodelist</TT>
which defines how big the array actually is.
<BR><BR>It is possible to declare multi-dimensional arrays by including more than one set of dimensions.&nbsp; For example,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int tbl[2][3];</TT>
<BR><BR>defines a 2-row by 3-column array of integers.&nbsp; In fact, it defines an array of 2 arrays of 3 integers.&nbsp;
The values are stored in memory in the following order:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; tbl[0][0]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; tbl[0][1]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; tbl[0][2]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; tbl[1][0]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; tbl[1][1]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; tbl[1][2]</TT>
<BR><BR>The rows of the table are stored together.&nbsp; This form of storing an array is called<B> row-major order.</B>&nbsp;
The expression<TT> tbl[1][2]</TT> refers to the element in the last row and last column of the array.
<BR><BR>In an expression, if an array is named without specifying any indices, the value of the array name is the address
of its first element.&nbsp; In the example,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; array[10];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int * aptr;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; aptr = array;</TT>
<BR><BR>the assignment to<TT> aptr</TT> is equivalent to,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; aptr = &amp;array[0];</TT>
<BR><BR>Since multi-dimensional arrays are just arrays of arrays, it follows that omission of some, but not all, dimensions
is equivalent to taking the address of the first element of the sub-array.&nbsp; In the example,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; array[9][5][2];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int * aptr;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; aptr = array[7];</TT>
<BR><BR>the assignment to<TT> aptr</TT> is equivalent to,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; aptr = &amp;array[7][0][0];</TT>
<BR><BR>Note that no checking of indices is performed at execution time.&nbsp; An invalid index (less than zero or greater
than the highest index) will refer to memory as if the array was extended to accommodate the index.
<H2 ID="Strings"> Strings </H2>
<BR>A<B> string</B> is a special form of the type &quot;array of characters&quot;, specifically an array of characters terminated
by a <B> null character.</B>&nbsp; The null character is a character with the value zero, represented as<TT> \0</TT> within
a string, or as the character constant<TT> '\0'</TT>.&nbsp; Because string processing is such a common task in programming,
C provides a set of library functions for handling strings.
<BR><BR>A string is represented by the address of the first character in the string.&nbsp; The<B> length</B> of a string is
the number of characters up to, but not including, the null character.
<BR><BR>An array can be initialized to be a string using the following form:
<BR><BR><B>&nbsp; type identifier</B><TT>[] = { &quot;</TT><B>string value</B><TT> &quot; };</TT>
<BR><BR>(The braces are optional.) For example,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char ident[] = &quot;This is my program&quot;;</TT>
<BR><BR>declares<TT> ident</TT> to be an array of 19 characters, the last of which has the value zero.&nbsp; The string has
18 characters plus the null character.
<BR><BR>In the above example,<TT> ident</TT> is an array whose value is a string.&nbsp; However, the quote-enclosed value
used to initialize the array is called a <B> string literal.</B>&nbsp; String literals are described in the &quot;Constants&quot;
chapter.
<BR><BR>A string may be used anywhere in a program where a &quot;pointer to <TT> char</TT>&quot; may be used.&nbsp; For example,
if the declaration,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char * ident;</TT>
<BR><BR>was encountered, the statement,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ident = &quot;This is my program&quot;;</TT>
<BR><BR>would set the value of<TT> ident</TT> to be the address of the string<TT> &quot;This is my program&quot;.</TT>
<H1 ID="Constants"> Constants </H1>
<BR>A constant is a value which is fixed at compilation time and is often just a number, character or string.&nbsp; Every
constant has a type which is determined by its form and value.&nbsp; For example, the value<TT> 1</TT> may have the type <TT>
signed int</TT>, while the value<TT> 400000</TT> may have the type <TT> signed long</TT>.&nbsp; In many cases, the type of
the constant does not matter.&nbsp; If, for example, the value<TT> 1</TT> is assigned to an object of type <TT> long int</TT>,
then the value<TT> 1</TT> will be converted to a long integer before the assignment takes place.
<H2 ID="Integer_Constants"> Integer Constants </H2>
<BR>An integer constant begins with a digit and contains no fractional or exponent part.&nbsp; A prefix may be included which
defines whether the constant is in octal, decimal or hexadecimal format.
<BR><BR>A constant may be suffixed by<TT> u</TT> or<TT> U</TT> indicating an <TT> unsigned int</TT>, or by<TT> l</TT> or<TT>
L</TT> indicating a <TT> long int</TT>, or by both indicating an <TT> unsigned long int</TT>.
<BR><BR>If a constant does not start with a zero and contains a sequence of digits, then it is interpreted as a decimal (base
10) constant.&nbsp; These are decimal constants:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 7</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 762</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 98765L</TT>
<BR><BR>If the constant starts with<TT> 0x</TT> or<TT> 0X</TT> followed by the digits from<TT> 0</TT> through<TT> 9</TT> and
the letters<TT> a</TT> (or<TT> A</TT>) through<TT> f</TT> (or<TT> F</TT>), then the constant is interpreted as a hexadecimal
(base 16) constant.&nbsp; The letters<TT> A</TT> through<TT> F</TT> represent the values 10 through 15 respectively.&nbsp;
These are hexadecimal constants:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0X07FFF</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0x12345678L</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0xFABE</TT>
<BR><BR>If a constant starts with a zero, then it is an octal constant and may contain only the digits 0 through 7.&nbsp;
These are octal constants:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 017</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0735643L</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0</TT>
<BR><BR>Note that the constant<TT> 0</TT> is actually an octal constant, but is zero in decimal, octal and hexadecimal.
<BR><BR>The following table describes what type the compiler will give to a constant.&nbsp; The left column indicates what
base (decimal, octal or hexadecimal) is used and what suffixes (<TT>U</TT> or<TT> L</TT>) are present.&nbsp; The right column
indicates the types that may be given to such a constant.&nbsp; The type of an integer constant is the first type from the
table in which its value can be accurately represented.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Constant&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;Type</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ----------------------- --------------------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsuffixed decimal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int, long, unsigned long</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsuffixed octal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int, unsigned int, long, unsigned
long</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsuffixed hexadecimal&nbsp; int, unsigned int, long, unsigned long</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; suffix U only&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int,
unsigned long</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; suffix L only&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long, unsigned
long</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; suffixes U and L&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; suffix LL only&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long long, unsigned
long long</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; suffixes U and LL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long long</TT>
<BR><BR>The following table illustrates a number of constants and their interpretation and type:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Hexa-</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Decimal
&nbsp; decimal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/16&nbsp; Open Watcom C/32</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Constant&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Value&nbsp;&nbsp;&nbsp; Value&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; Type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Type</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ----------&nbsp; ----------&nbsp; --------&nbsp; ------------&nbsp; ------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 33&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; 33&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 21&nbsp; signed int&nbsp;&nbsp;&nbsp;&nbsp; signed int</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 033&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;27&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1B&nbsp; signed int&nbsp;&nbsp;&nbsp;&nbsp; signed int</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x33&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;51&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 33&nbsp; signed int&nbsp;&nbsp;&nbsp;&nbsp; signed int</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 33333&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 33333&nbsp;&nbsp;
&nbsp;&nbsp; 8235&nbsp; signed long&nbsp;&nbsp;&nbsp; signed int</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 033333&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 14043&nbsp;&nbsp;&nbsp;
&nbsp; 36DB&nbsp; signed int&nbsp;&nbsp;&nbsp;&nbsp; signed int</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xA000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 40960&nbsp;&nbsp;&nbsp;
&nbsp; A000&nbsp; unsigned int&nbsp;&nbsp; signed int</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x33333&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 209715&nbsp;&nbsp;&nbsp;&nbsp; 33333
&nbsp;signed long&nbsp;&nbsp;&nbsp; signed int</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0x80000000&nbsp; 2147483648&nbsp; 80000000&nbsp; unsigned long&nbsp; unsigned int</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 2147483648&nbsp; 2147483648&nbsp; 80000000&nbsp; unsigned long&nbsp; unsigned int</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 4294967295&nbsp; 4294967295&nbsp; FFFFFFFF&nbsp; unsigned long&nbsp; unsigned int</TT>
<H2 ID="FloatingMPoint_Constants"> Floating-Point Constants </H2>
<BR>A floating-point constant may be distinguished by the presence of either a period, an<TT> e</TT> or<TT> E</TT>, or both.
&nbsp;It consists of a value part (mantissa) optionally followed by an exponent.&nbsp; The mantissa may include a sequence
of digits representing a whole number, followed by a period, followed by a sequence of digits representing a fractional part.
&nbsp;The exponent must start with an<TT> e</TT> or<TT> E</TT> followed by an optional sign (<TT>+</TT> or<TT> -</TT>), and
a digit sequence representing (with the sign) the power of 10 by which the mantissa should be multiplied.&nbsp; Optionally,
the suffix<TT> f</TT> or<TT> F</TT> may be added indicating the constant has type <TT> float</TT>, or the suffix<TT> l</TT>
or<TT> L</TT> indicating the constant has type <TT> long double</TT>.&nbsp; If no suffix is present then the constant has
type <TT> double</TT>.
<BR><BR>In the mantissa, either the whole number part or the fractional part must be present.&nbsp; If only the whole number
part is present and no period is included then the exponent part must be present.
<BR><BR>The following table illustrates a number of floating-point constants and their type:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Constant&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Value&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Type</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ----------&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ------------&nbsp;&nbsp;&nbsp; ----------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 3.14159265&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3.14159265E0&nbsp;&nbsp;&nbsp; double</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 11E24&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.1E25&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .5L&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5E-1&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long double</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 7.234E-22F&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7.234E-22&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0E0&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double</TT>
<H2 ID="Character_Constants"> Character Constants </H2>
<BR>A character constant is usually one character enclosed in single-quotes, and indicates a constant whose value is the representation
of the character in the execution character set.&nbsp; A character constant has type <TT> int</TT>.
<BR><BR>The character enclosed in quotes may be any character in the source character set.&nbsp; Certain characters in the
character set may not be directly representable, since they may be assigned other meanings.&nbsp; These characters can be
entered using the following escape sequences:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Character&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Escape</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Character&nbsp;&nbsp; Name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; Sequence</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ---------&nbsp;&nbsp; -----------------&nbsp;&nbsp; --------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; single quote&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; \'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double quote&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; &quot; or \&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; question mark&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; ? or \?</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; backslash&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; octal value&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \octal digits (max 3)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hexadecimal value
&nbsp; \xhexadecimal digits</TT>
<BR><BR>For example,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 'a'&nbsp;&nbsp;&nbsp;&nbsp; /* the letter a */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; '\''&nbsp;&nbsp;&nbsp; /* a single quote */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; '?'&nbsp;&nbsp;&nbsp;&nbsp; /* a question mark */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; '\?'&nbsp;&nbsp;&nbsp; /* a question mark */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; '\\'&nbsp;&nbsp;&nbsp; /* a backslash */</TT>
<BR><BR>are all simple character constants.
<BR><BR>The following are some character constants containing octal escape sequences, made up of a<TT> \</TT> followed by
one, two or three octal digits (the digits<TT> 0</TT> through<TT> 7</TT>):
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; '\0'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; '\377'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; '\100'</TT>
<BR><BR>If a character constant containing an octal value is found, but a non-octal character is also present, or if a fourth
octal digit is found, it is not part of the octal character already specified, and constitutes a separate character.&nbsp;
For example,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; '\1000'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; '\109'</TT>
<BR><BR>the first constant is a two-character constant, consisting of the characters<TT> '\100'</TT> and<TT> '0'</TT> (because
an octal value consists of at most three octal digits).&nbsp; The second constant is also a two-character constant, consisting
of the characters<TT> '\10'</TT> and<TT> '9'</TT> (because<TT> 9</TT> is not an octal digit).
<BR><BR>If more than one octal value is to be specified in a character constant, then each octal value must be specified starting
with<TT> \</TT>.
<BR><BR>The meaning of character constants with more than one character is implementation-defined.
<BR><BR>The following are some character constants containing hexadecimal escape sequences, made up of a<TT> \x</TT> followed
by one or more hexadecimal digits (the digits<TT> 0</TT> through<TT> 9</TT>, and the letters<TT> a</TT> through<TT> f</TT>
and<TT> A</TT> through<TT> F</TT>).&nbsp; (The values of these character constants are the same as the first examples of octal
values presented above.)
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; '\x0'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; '\xFF'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; '\x40'</TT>
<BR><BR>If a character constant containing a hexadecimal value is found, but a non-hexadecimal character is also present,
it is not part of the hexadecimal character already specified, and constitutes a separate character.&nbsp; For example,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; '\xFAx'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; '\xFx'</TT>
<BR><BR>the first constant is a two-character constant, consisting of the characters<TT> '\xFA'</TT> and<TT> 'x'</TT> (because<TT>
x</TT> is not a hexadecimal digit).&nbsp; The second constant is also a two-character constant, consisting of the characters<TT>
'\xF'</TT> and<TT> 'x'</TT>.
<BR><BR>If more hexadecimal digits are found than are required to specify one character, the behavior is implementation-defined.
&nbsp;Specifically, any sequence of hexadecimal characters in a hexadecimal value in a character constant is used to specify
the value of one character.&nbsp; If more than one hexadecimal value is to be specified in a character constant, then each
hexadecimal value must be specified starting with<TT> \x</TT>.
<BR><BR>The meaning of character constants with more than one character is implementation-defined.
<BR><BR>In addition to the above escape sequences, the following escape sequences may be used to represent non-graphic characters:
&nbsp;
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Escape</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Sequence&nbsp;&nbsp;&nbsp; Meaning</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; --------&nbsp;&nbsp;&nbsp; -------------------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; \a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Causes an audible or visual alert</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; \b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Back up one character</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; \f&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Move to the start of the next page</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Move to the start of the next line</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; \r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Move to the start of the current
line</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; \t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Move to the next horizontal tab</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; \v&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Move to the next vertical tab</TT>
<BR><BR>The following trigraph sequences may be used to represent characters not available on all terminals or systems:&nbsp;

<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Trigraph</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Character&nbsp;&nbsp; Sequence</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ---------&nbsp;&nbsp; --------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ??(</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ??)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ??&lt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ??&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ??!</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ??=</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ??/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ??'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ??-</TT>
<BR><BR><B>&nbsp; The Open Watcom C/16 and C/32 compilers also allow character constants with more than one character.&nbsp;
These may be used to initialize larger types, such as </B><TT> int</TT><B>.&nbsp; For example, the program fragment:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int code;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; code = 'ab';</TT>
<BR><BR><B>&nbsp; assigns the constant value</B><TT> 'ab'</TT><B> to the integer object</B><TT> code</TT><B>.&nbsp; The letter</B><TT>
b</TT><B> is placed in the lowest order (least significant) portion of the integer value and the letter</B><TT> a</TT><B>
is placed in the next highest portion.</B>
<BR><BR><B>&nbsp; Up to four characters may be placed in a character constant.&nbsp; Successive characters, starting from
the right-most character in the constant, are placed in successively higher order (more significant) bytes of the result.</B>
<BR><BR>Note that a character constant such as<TT> 'a'</TT> is different from the corresponding string literal<TT> &quot;a&quot;</TT>.
&nbsp;The former is of type <TT> int</TT> and has the value of the letter<TT> a</TT> in the execution character set.&nbsp;
The latter is of type &quot;pointer to <TT> char</TT>&quot; and its value is the address of the first character (<TT>a</TT>)
of the string literal.
<H3 ID="Wide_Character_Constants"> Wide Character Constants </H3>
<BR>If the value of a character constant is to be a multibyte character from an extended character set, then a<B> wide character
constant</B> should be specified.&nbsp; Its form is similar to normal character constants, except that the constant is preceded
by the character<TT> L</TT>.
<BR><BR>The type of a wide character constant is <TT> wchar_t</TT>, which is one of the integral types, and is described in
the header <TT> &lt;stddef.h&gt;</TT>.
<BR><BR><B>&nbsp; With Open Watcom C/16 and C/32, </B><TT> wchar_t</TT><B> is defined as </B><TT> unsigned short</TT><B>.</B>
<BR><BR>For example, the constant<TT> L'a'</TT> is a wide character constant containing the letter<TT> a</TT> from the source
character set, and has type <TT> wchar_t</TT>.&nbsp; In contrast, the constant<TT> 'a'</TT> is a character constant containing
the letter<TT> a</TT>, and has type <TT> int</TT>.
<BR><BR>How the multibyte character maps onto the wide character value is defined by the <TT> mbtowc</TT> library function.
<BR><BR>As shown above, a wide character constant may also contain a single byte character, since an extended character set
contains the single byte characters.&nbsp; The single byte character is mapped onto the corresponding wide character code.
<H2 ID="String_Literals"> String Literals </H2>
<BR>A sequence of zero or more characters enclosed within double-quotes is a <B> string literal.</B>
<BR><BR>Most of the same rules for creating character constants also apply to creating string literals.&nbsp; However, the
single-quote may be entered directly or as the<TT> \'</TT> escape sequence.&nbsp; The double-quote must be entered as the<TT>
\&quot;</TT> escape sequence.
<BR><BR>The value of a string literal is the sequence of characters within the quotes, plus a null character at the end.
<BR><BR>The type of a string literal is &quot;array of <TT> char</TT>&quot;.
<BR><BR>The following are examples of string literals:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &quot;Hello there&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &quot;\&quot;Quotes inside string\&quot;&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &quot;G'day&quot;</TT>
<BR><BR>If two or more string literals are adjacent, the compiler will join them together into one string literal.&nbsp; The
pair of string literals,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &quot;Hello&quot; &quot;there&quot;</TT>
<BR><BR>would be joined by the compiler to be,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &quot;Hellothere&quot;</TT>
<BR><BR>and is an array of 11 characters, including the single terminating null character.
<BR><BR>The joining of adjacent string literals occurs<B> after</B> the replacement of escape sequences.&nbsp; In the examples,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &quot;\xFAB\xFA&quot; &quot;B&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &quot;\012\01&quot; &quot;2&quot;</TT>
<BR><BR>the first string, after joining, consists of three characters, with the values<TT> '\xFAB'</TT>,<TT> '\xFA'</TT> and<TT>
'B'</TT>.&nbsp; The second string, after joining, also consists of three characters, with the values<TT> '\012'</TT>,<TT>
'\01'</TT> and<TT> '2'</TT>.
<BR><BR>A program should not attempt to modify a string literal, as this behavior is undefined.&nbsp; On computers where memory
can be protected, it is likely that string literals will be placed where the program cannot modify them.&nbsp; An attempt
to modify them will cause the program to fail.&nbsp; On other computers without such protection, the literal can be modified,
but this is generally considered to be a poor programming practice.&nbsp; (Constants should be constant!)
<BR><BR>A string literal normally is a string.&nbsp; It is not a string if one of the characters within double-quotes is the
null character (<TT>\0</TT>).&nbsp; If such a string literal is treated as a string, then only those characters before the
first null character will be considered part of the string.&nbsp; The characters following the first null character will be
ignored.
<BR><BR>If a source file uses the same string literal in several places, the compiler may combine them so that only one instance
of the string exists and each reference refers to that string.&nbsp; In other words, the addresses of each of the string literals
would be the same.&nbsp; However, no program should rely on this since other compilers may make each string a separate instance.
<BR><BR><B>&nbsp; The Open Watcom C/16 and C/32 compilers combine several instances of the same string literal in the same
module into a single string literal, provided that they occur in declarations of constant objects or in statements other than
declarations (eg.&nbsp; assignment).</B>
<BR><BR>If the program requires that several string literals be the same instance, then an object should be declared as an
array of <TT> char</TT> with its value initialized to the string.
<H3 ID="Wide_String_Literals"> Wide String Literals </H3>
<BR>If any of the characters in a string literal are multibyte characters from an extended character set, then a<B> wide string
literal</B> should be specified.&nbsp; Its form is similar to normal string literals, except that the string is preceded by
the character<TT> L</TT>.
<BR><BR>The type of a wide string literal is &quot;array of <TT> wchar_t</TT>&quot;.&nbsp; <TT> wchar_t</TT> is one of the
integral types, and is described in the header <TT> &lt;stddef.h&gt;</TT>.
<BR><BR><B>&nbsp; With Open Watcom C/16 and C/32, </B><TT> wchar_t</TT><B> is defined as </B><TT> unsigned short</TT><B>.</B>
<BR><BR>For example, the string literal<TT> L&quot;ab&quot;</TT> is a wide string literal containing the letters<TT> a</TT>
and<TT> b</TT>.&nbsp; Its type is &quot;array [3] of <TT> wchar_t</TT>&quot;, and the values of its elements are<TT> L'a'</TT>,<TT>
L'b'</TT> and<TT> '\0'</TT>.&nbsp; In contrast, the string literal<TT> &quot;ab&quot;</TT> has type &quot;array [3] of <TT>
char</TT>&quot;, and the values of its elements are<TT> 'a'</TT>,<TT> 'b'</TT> and<TT> '\0'</TT>.
<BR><BR>How the multibyte characters map onto wide character values is defined by the <TT> mbtowc</TT> library function.
<BR><BR>As shown above, a wide string literal may also contain single byte characters, since the extended character set contains
the single byte characters.&nbsp; The single byte characters are mapped onto the corresponding wide character codes.
<BR><BR>Adjacent wide string literals will be concatenated by the compiler and a null character appended to the end.&nbsp;
If a string literal and a wide string literal are adjacent, the behavior when the compiler attempts to concatentate them is
undefined.
<H1 ID="Type_Conversion"> Type Conversion </H1>
<BR>Whenever two operands are involved in an operation, some kind of <B> conversion</B> of one or both of the operands may
take place.&nbsp; For example, a <TT> short int</TT> and a <TT> long int</TT> cannot be directly added.&nbsp; Instead, the
<TT> short int</TT> must first be converted to a <TT> long int</TT>, then the two values can be added.
<BR><BR>Fortunately, C provides most conversions as<B> implicit</B> operations.&nbsp; Simply by indicating that the two values
are to be added, the C compiler will check their types and generate the appropriate conversions.&nbsp; Sometimes it is necessary,
however, to be aware of exactly how C will convert the operands.
<BR><BR>Conversion of operands always attempts to preserve the value of the operand.&nbsp; Where preservation of the value
is not possible, the compiler will sign-extend signed quantities and discard the high bits of quantities being converted to
smaller types.
<BR><BR>The rules of type conversions are fully discussed in the following sections.
<H2 ID="Integral_Promotion"> Integral Promotion </H2>
<DL>
<DT>Rule:
<DD>A <TT> char</TT>, <TT> short int</TT> or <TT> int</TT> bit-field in either of their signed or unsigned forms, or an object
that has an enumerated type, is always converted to an <TT> int</TT>.&nbsp; If the type <TT> int</TT> cannot contain the entire
range of the object being converted, then the object will be converted to an <TT> unsigned int</TT>.
</DL>
<BR>A <TT> signed</TT> or <TT> unsigned char</TT> will be converted to a <TT> signed int</TT> without changing the value.
<BR><BR><B>&nbsp; With Open Watcom C/16, a </B><TT> short int</TT><B> has the same range as </B><TT> int</TT><B>, therefore
a </B><TT> signed short int</TT><B> is converted to a </B><TT> signed int</TT><B>, and an </B><TT> unsigned short int</TT><B>
is converted to an </B><TT> unsigned int</TT><B>, without changing the value.</B>
<BR><BR><B>&nbsp; With Open Watcom C/32, a </B><TT> signed</TT><B> or </B><TT> unsigned</TT><B> </B><TT> short int</TT><B>
is converted to an </B><TT> int</TT><B> without changing the value.</B>
<BR><BR>These promotions are called the <B> integral promotions.</B>
<H2 ID="Signed_and_Unsigned_Integer_Conversion"> Signed and Unsigned Integer Conversion </H2>
<DL>
<DT>Rule:
<DD>If an unsigned integer is converted to an integer type of any size, then, if the value can be represented in the new type,
the value remains unchanged.
</DL>
<BR>If an unsigned integer is converted to a longer type (type with greater range), then the value will not change.&nbsp;
If it is converted to a type with a smaller range, then provided the value can be represented in the smaller range, the value
will remain unchanged.&nbsp; If the value cannot be represented, then if the result type is signed, the result is implementation-defined.
&nbsp;If the result type is <TT> unsigned</TT>, the result is the integer modulo (1+the largest unsigned number that can be
stored in the shorter type).
<BR><BR><B>&nbsp; With Open Watcom C/16, unsigned integers are promoted to longer types by extending the high-order bits with
zeros.&nbsp; They are demoted to shorter types by discarding the high-order portion of the larger type.</B>
<BR><BR>Consider the following examples of 32-bit quantities (<TT> unsigned long int</TT>) being converted to 16-bit quantities
(<TT> signed short int</TT> or <TT> unsigned short int</TT>):
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32-bit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; 16-bit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signed&nbsp;&nbsp; unsigned</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; long&nbsp;&nbsp;&nbsp; representation&nbsp;&nbsp; representation&nbsp;&nbsp; short&nbsp;
&nbsp; short</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ------&nbsp; --------------&nbsp;&nbsp; --------------&nbsp;&nbsp; ------&nbsp;&nbsp; --------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 65538&nbsp;&nbsp; 0x00010002&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x0002&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 100000&nbsp; 0x000186A0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x86A0&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -31072&nbsp;&nbsp; 34464</TT>
<DL>
<DT>Rule:
<DD>When a signed integer is converted to an unsigned integer of equal or greater length, if the value is non-negative, the value
will be unchanged.
</DL>
<BR>A non-negative value stored in a signed integer may be converted to an equal or larger integer type without affecting
the value.&nbsp; A negative value is first converted to the signed type of the same length as the result, then (1+the largest
unsigned number that can be stored in the result type) is added to the value to convert it to the unsigned type.
<BR><BR><B>&nbsp; With Open Watcom C/16, signed integers are promoted to longer types by </B><B><I> sign-extending</I></B><B>
the value (the high bit of the shorter type is propogated throughout the high bits of the longer type).&nbsp; When the longer
type is unsigned, the sign-extended bit-pattern is then treated as an unsigned value.</B>
<BR><BR>Consider the following examples of 16-bit signed quantities (<TT> signed short int</TT>) being converted to 32-bit
quantities (<TT> signed long int</TT> and <TT> unsigned long int</TT>):
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; signed&nbsp; 16-bit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32-bit&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signed&nbsp;&nbsp; unsigned</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; short&nbsp;&nbsp; represention&nbsp;&nbsp; representation&nbsp;&nbsp; long&nbsp;&nbsp;&nbsp;
&nbsp;long</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ------&nbsp; ------------&nbsp;&nbsp; --------------&nbsp;&nbsp; ------&nbsp;&nbsp; ----------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xFFFE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xFFFFFFFE
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4294967294</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 32766&nbsp;&nbsp; 0x7FFE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00007FFE&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; 32766&nbsp;&nbsp;&nbsp; 32766</TT>
<DL>
<DT>Rule:
<DD>When a signed integer is converted to a longer signed integer, the value will not change.
<DT>Rule:
<DD>When a signed integer is converted to a shorter type, the result is implementation-defined.
</DL>
<BR><B>&nbsp; With Open Watcom C/16, signed integers are converted to a shorter type by preserving the low-order (least significant)
portion of the larger type.</B>
<H2 ID="FloatingMPoint_to_Integer_Conversion"> Floating-Point to Integer Conversion </H2>
<DL>
<DT>Rule:
<DD>When a floating-point type is converted to integer, the fractional part is discarded.&nbsp; If the value of the integer part
cannot be represented in the integer type, then the result is undefined.
</DL>
<BR>Hence, it is valid only to convert a floating-point type to integer within the range of the integer type being converted
to.&nbsp; Refer to the section &quot;Integer Types&quot; for details on the range of integers.
<H2 ID="Integer_to_FloatingMPoint_Conversion"> Integer to Floating-Point Conversion </H2>
<DL>
<DT>Rule:
<DD>When the value of an integer type is converted to a floating-point type, and the integer value cannot be represented exactly
in the floating-point type, the value will be rounded either up or down.
</DL>
<BR>Rounding of floating-point numbers is implementation-defined.&nbsp; The technique being used by the compiler may be determined
from the macro <TT> FLT_ROUNDS</TT> found in the header <TT> &lt;float.h&gt;</TT>.&nbsp; The following table describes the
meaning of the various values:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; FLT_ROUNDS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Technique</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ----------&nbsp; ------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; indeterminable</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; toward zero</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; to nearest number</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; toward positive infinity</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; toward negative infinity</TT>
<BR><BR><B>&nbsp; The Open Watcom C/16 and C/32 compilers will round to the nearest number.&nbsp; (The value of</B><TT> FLT_ROUNDS</TT><B>
is 1.)</B>
<DL>
<DT>Rule:
<DD>When a floating-point value is converted to a larger floating-point type (<TT> float</TT> to <TT> double</TT>, <TT> float</TT>
to <TT> long double</TT>, or <TT> double</TT> to <TT> long double</TT>), the value remains unchanged.
<DT>Rule:
<DD>When any floating-point type is demoted to a floating-point type with a smaller range, then the result will be undefined if
the value lies outside the range of the smaller type.&nbsp; If the value lies inside the range, but cannot be represented
exactly, then rounding will occur in an implementation-defined manner.
</DL>
<BR><B>&nbsp; The Open Watcom C/16 and C/32 compilers round to the nearest number.&nbsp; (The value of</B><TT> FLT_ROUNDS</TT><B>
is 1.)</B>
<H2 ID="Arithmetic_Conversion"> Arithmetic Conversion </H2>
<BR>Whenever two values are used with a binary operator that expects arithmetic types (integer or floating-point), conversions
may take place implicitly.&nbsp; Most binary operators work on two values of the same type.&nbsp; If the two values have different
types, then the type with the smaller range is always promoted to the type with the greater range.&nbsp; Conceptually, each
type is found in the table below and the type found lower in the table is converted to the type found higher in the table.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; long double</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; double</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; float</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned long</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; long</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned int</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int</TT>
<BR><BR>Note that any types smaller than <TT> int</TT> have<B> integral promotions</B> performed on them to promote them to
<TT> int</TT>.
<BR><BR>The following table illustrates the result type of performing an addition on combinations of various types:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Operation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Result Type</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; --------------------------&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; signed char + signed char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signed int</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned char + signed int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signed int</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; signed int + signed int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signed int</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; signed int + unsigned int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned int + signed long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signed long</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; signed int + unsigned long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; signed char + float&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
float</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; signed long + double&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; float + double&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; double</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; float + long double&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
long double</TT>
<H2 ID="Default_Argument_Promotion"> Default Argument Promotion </H2>
<BR>When a call is made to a function, the C compiler checks to see if the function has been defined already, or if a prototype
for that function has been found.&nbsp; If so, then the arguments to the function are converted to the specified types.&nbsp;
If neither is true, then the arguments to the function are promoted as follows:
<UL>
<LI>all integer types have the <B> integral promotions</B> performed on them, and,
<LI>all arguments of type <TT> float</TT> are promoted to <TT> double</TT>.
</UL>
<BR>If the definition of the function does not have parameters with types that match the promoted types, the behavior is undefined.
<H1 ID="Advanced_Types"> Advanced Types </H1>
<BR>The following topics are discussed:
<UL>
<LI>Structures
<LI>Unions
<LI>Pointers
<LI>Void
<LI>The const and volatile Declarations
</UL>
<H2 ID="Structures"> Structures </H2>
<BR>A<B> structure</B> is a type composed of a sequential group of<B> members</B> of various types.&nbsp; Like other types,
a structure is a model describing storage requirements and interpretations, and does not reserve any storage.&nbsp; Storage
is reserved when an object is declared to be an<B> instance</B> of the structure.
<BR><BR>Each of the members of a structure must have a name, with the exception of<B> bit-fields.</B>
<BR><BR><B>&nbsp; With Open Watcom C/16 and C/32, a structure member may be unnamed if the member is a structure or union.</B>
<BR><BR>A structure may not contain a member with an incomplete type.&nbsp; In particular, it may not contain a member with
a type of the structure being defined (otherwise the structure would have indeterminate size), although it may contain a pointer
to it.
<BR><BR>The structure may be given an optional <B> tag</B> with which the structure may be referenced elsewhere in the program.
&nbsp;If no tag is given, then only those objects listed following the definition of the structure may have the structure
type.
<BR><BR>The <B> name space</B> for structure tags is different from that of object names, labels and member names, so a tag
may be the same identifier as one of these other kinds.&nbsp; A structure tag may not be the same as the tag of a union or
enumerated type, or another structure.
<BR><BR>Each structure has its own name space, so an identifier may be used as a member name in more than one structure.&nbsp;
An identifier that is an object name, structure tag, union tag, union member name, enumeration tag or label may also be used
as a member name without ambiguity.
<BR><BR>Structures help to organize program data by collecting several related objects into one object.&nbsp; They are also
used for linked lists, trees and for describing externally-defined regions of data that the application must access.
<BR><BR>The following structure might describe a token identified by parsing a typed command:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct tokendef {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp; length;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp; type;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp; text[80];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR>This defines a structure containing three members, an integer containing the token length, another integer containing
some encoding of the token type, and the third an array of 80 characters containing the text of the token.&nbsp; The tag of
the structure is<TT> tokendef.</TT>
<BR><BR>The above definition does not actually create an object containing the structure.&nbsp; Creation of an instance of
the structure requires a list of identifiers following the structure definition, or to use<TT> struct tokendef</TT> in place
of a type for declaring an object.&nbsp; For example,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct tokendef {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp; length;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp; type;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp; text[80];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; } token;</TT>
<BR><BR>is equivalent to,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct tokendef {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp; length;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp; type;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp; text[80];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct tokendef token;</TT>
<BR><BR>Both create the object<TT> token</TT> as an instance of the structure<TT> tokendef.</TT>&nbsp; The<B> type</B> of<TT>
token</TT> is<TT> struct tokendef.</TT>
<BR><BR>References to a member of a structure are made using the <B> dot</B> operator (.).&nbsp; The first operand of the
.&nbsp; operator is the object containing the structure.&nbsp; The second operand is the name of the member.&nbsp; For example,<TT>
token.length</TT> refers to the<TT> length</TT> member of the<TT> tokendef</TT> structure contained in<TT> token.</TT>
<BR><BR>If<TT> tokenptr</TT> is declared as,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct tokendef * tokenptr;</TT>
<BR><BR>(<TT>tokenptr</TT> is a pointer to a<TT> tokendef</TT> structure), then,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; (*tokenptr).length</TT>
<BR><BR>refers to the<TT> length</TT> member of the<TT> tokendef</TT> structure that<TT> tokenptr</TT> points to.&nbsp; Alternatively,
to refer to a member of a structure, the <B> arrow</B> operator (<TT>-&gt;</TT>) is used:
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; tokenptr-&gt;length</TT>
<BR><BR>is equivalent to,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; (*tokenptr).length</TT>
<BR><BR><B>&nbsp; If a structure contains an unnamed member which is a structure or union, then the members of the inner structure
or union are referenced as if they were members of the outer structure.&nbsp; For example,</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct outer {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct inner {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; a,
b;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int c;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } X;</TT>
<BR><BR><B>&nbsp; The members of</B><TT> X</TT><B> are referenced as</B><TT> X.a</TT><B>,</B><TT> X.b</TT><B> and</B><TT>
X.c</TT><B>.</B>
<BR><BR>Each member of a structure is at a higher address than the previous member.&nbsp; Alignment of members may cause (unnamed)
gaps between members, and an unnamed area at the end of the structure.
<BR><BR><B>&nbsp; The Open Watcom C/16 and C/32 compilers provide a command-line switch and a </B><TT> #pragma</TT><B> to
control the alignment of members of structures.&nbsp; See the User's Guide for details.</B>
<BR><BR><B>&nbsp; In addition, the </B><TT> _Packed</TT><B> keyword is provided, and if specified before the </B><TT> struct</TT><B>
keyword, will force the structure to be packed (no alignment, no gaps) regardless of the setting of the command-line switch
or the </B><TT> #pragma</TT><B> controlling the alignment of members.</B>
<BR><BR>A pointer to an object with a structure type, suitably cast, is also a pointer to the first member of the structure.
<BR><BR>A structure declaration of the form,
<BR><BR><TT>&nbsp; struct</TT><B> tag;</B>
<BR><BR>can be used to declare a new structure within a block, temporarily hiding the old structure.&nbsp; When the block
ends, the previous structure's hidden declaration will be restored.&nbsp; For example,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct thing { int a,b; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* ... */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct thing;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct s1&nbsp;&nbsp;&nbsp; { struct thing
* thingptr; } tptr;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct thing { struct s1 *&nbsp;&nbsp;&nbsp;
s1ptr; }&nbsp;&nbsp;&nbsp; sptr;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>the original definition of<TT> struct thing</TT> is suppressed in order to create a new definition.&nbsp; Failure
to suppress the original definition would result in<TT> thingptr</TT> being a pointer to the old definition of<TT> thing</TT>
rather than the new one.
<BR><BR>Redefining structures can be confusing and should be avoided.
<H3 ID="BitMfields"> Bit-fields </H3>
<BR>A member of a structure can be declared as a<B> bit-field</B>, provided the type of the member is <TT> int</TT>, <TT>
unsigned int</TT> or <TT> signed int</TT>.
<BR><BR><B>&nbsp; In addition, the Open Watcom C/16 and C/32 compilers allow the types </B><TT> char</TT><B>, </B><TT> unsigned
char</TT><B>, </B><TT> short int</TT><B> and </B><TT> unsigned short int</TT><B> to be bit-fields.</B>
<BR><BR>A bit-field declares the member to be a number of bits.&nbsp; A value may be assigned to the bit-field in the same
manner as other integral types, provided the value can be stored in the number of bits available.&nbsp; If the value is too
big for the bit-field, excess high bits are discarded when the value is stored.
<BR><BR>The type of the bit-field determines the treatment of the highest bit of the bit-field.&nbsp; Signed types cause the
high bit to be treated as a sign bit, while unsigned types do not treat it as a sign bit.&nbsp; For a bit-field defined with
type <TT> int</TT> (and no <TT> signed</TT> or <TT> unsigned</TT> keyword), whether or not the high bit is considered a sign
bit is implementation-defined.
<BR><BR><B>&nbsp; The Open Watcom C/16 and C/32 compilers treat the high bit of a bit-field of type </B><TT> int</TT><B> as
a sign bit.</B>
<BR><BR>A bit-field is declared by following the member name by a colon and a constant expression which evaluates to a non-negative
value that does not exceed the number of bits in the type.
<BR><BR>A bit-field may be declared without a name and may be used to align a structure to an imposed form.&nbsp; Such a bit-field
cannot be referenced.
<BR><BR>If two bit-fields are declared sequentially within the same structure, and they would both fit within the storage
unit assigned to them by the compiler, then they are both placed within the same storage unit.&nbsp; If the second bit-field
doesn't fit, then whether it is placed in the next storage unit, or partially placed in the same unit as the first and spilled
over into the next unit, is implementation-defined.
<BR><BR><B>&nbsp; The Open Watcom C/16 and C/32 compilers place a bit-field in the next storage unit if it will not fit in
the remaining portion of the previously defined bit-field.&nbsp; Bit-fields are not allowed to straddle storage unit boundaries.</B>
<BR><BR>An unnamed member declared as<TT> :&nbsp; 0</TT> prevents the next bit-field from being placed in the same storage
unit as the previous bit-field.
<BR><BR>The order that bit-fields are placed in the storage unit is implementation-defined.
<BR><BR><B>&nbsp; The Open Watcom C/16 and C/32 compilers place bit-fields starting at the low-order end (least significant
bit) of the storage unit.&nbsp; If a 1-bit bit-field is placed alone in an </B><TT> unsigned int</TT><B> then a value of 1
in the bit-field corresponds to a value of 1 in the integer.</B>
<BR><BR>Consider the following structure definition:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct list_el {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct list_el * link;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned short&nbsp;&nbsp; elnum;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int&nbsp;&nbsp;&nbsp;&nbsp; length&nbsp;&nbsp;&nbsp; : 3;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signed int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offset&nbsp;&nbsp;
&nbsp;: 4;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; flag&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : 1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
text;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR>The structure<TT> list_el</TT> contains the following members:
<OL>
<LI><TT> link</TT> is a pointer to a<TT> list_el</TT> structure, indicating that instances of this structure will probably
be used in a linked list,
<LI><TT> elnum</TT> is an unsigned short integer,
<LI><TT> length</TT> is an unsigned bit-field containing 3 bits, allowing values in the range 0 through 7,
<LI><TT> offset</TT> is a signed bit-field containing 4 bits, which will be placed in the same integer with<TT> length.</TT>
&nbsp;Since the type is <TT> signed int</TT>, the range of values for this bit-field is<TT> -</TT>8 through 7,
<LI><TT> flag</TT> is a 1-bit field,
<BR><BR><B>&nbsp; Since the type is </B><TT> int</TT><B>, the Open Watcom C/16 and C/32 compilers will treat the bit as a
sign bit, and the set of values for the bit-field is</B><TT> -</TT><B>1 and 0.</B>
<LI><TT> text</TT> is a pointer to character, possibly a string.
</OL>
<H2 ID="Unions"> Unions </H2>
<BR>A<B> union</B> is similar to a structure, except that each member of a union is placed starting at the same storage location,
rather than in sequentially higher storage locations.&nbsp; (The Pascal term for a union is &quot;variant record&quot;.)
<BR><BR>The <B> name space</B> for union tags is different from that of object names, labels and member names, so a tag may
be the same identifier as one of these other kinds.&nbsp; The tag may not be the same identifier as the tag of a structure,
enumeration or another union.
<BR><BR>Each union has its own name space, so an identifier may be used as a member name in several different unions.&nbsp;
An identifier that is an object name, structure tag, structure member name, union tag, enumeration tag or label may also be
used as a member name without ambiguity.
<BR><BR><B>&nbsp; With Open Watcom C/16 and C/32, unions, like structures, may contain unnamed members that are structures
or unions.&nbsp; References to the members of an unnamed structure or union are made as if the members of the inner structure
or union were at the outer level.</B>
<BR><BR>The size of a union is the size of the largest of the members it contains.
<BR><BR>A pointer to an object that is a union points to each of the members of the union.&nbsp; If one or more of the members
of the union is a <B> bit-field</B>, then a pointer to the object also points to the storage unit in which the bit-field resides.
<BR><BR>Storing a value in one member of a union, and then referring to it via another member is only meaningful when the
different members have the same type.&nbsp; Members of a union may themselves be structures, and if some or all of the members
start with the same members in each structure, then references to those structure members may be made via any of the union
members.&nbsp; For example, consider the following structure and union definitions:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct rec1 {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectype;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v1,v2,v3;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *&nbsp;&nbsp;&nbsp; text;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct rec2 {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rectype;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short int flags : 8;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enum&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {red, blue, green} hue;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; union alt_rec {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct rec1&nbsp;&nbsp; val1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct rec2&nbsp;&nbsp; val2;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>alt_rec</TT> is a union defining two members<TT> val1</TT> and<TT> val2</TT>, which are two different forms of
a record, namely the structures<TT> rec1</TT> and<TT> rec2</TT> respectively.&nbsp; Each of the different record forms starts
with the member<TT> rectype.</TT>&nbsp; The following program fragment would be valid:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; union alt_rec&nbsp; record;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* ... */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; record.rec1.rectype = 33;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DoSomething( record.rec2.rectype );</TT>
<BR><BR>However, the following fragment would exhibit implementation-defined behavior:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; record.rec1.v1 = 27;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DoSomethingElse( record.rec2.hue );</TT>
<BR><BR>In other words, unless several members of a union are themselves structures where the first few members are of the
same type, a program should not store into a union member and retrieve a value using another union member.&nbsp; Generally,
a flag or other indicator is kept to describe which member of the union is currently the &quot;active&quot; member.
<H2 ID="Pointers"> Pointers </H2>
<BR>A<B> pointer</B> to an object is equivalent to the address of the object in the memory of the computer.
<BR><BR>An object may be declared to be a pointer to a type of object, or it may be declared to be a pointer to no particular
type.&nbsp; The form,
<BR><BR><B>&nbsp; type</B><TT> *</TT><B> identifier</B><TT>;</TT>
<BR><BR>declares the identifier to be a pointer to the given type.&nbsp; If<B> type</B> is <TT> void</TT>, then the identifier
is a pointer to no particular type of object (a generic pointer).
<BR><BR>The following examples illustrate various pointer declarations:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int * intptr;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; intptr</TT> is a pointer to an <TT> int</TT>.
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char * charptr;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; charptr</TT> is a pointer to a<TT> char</TT>.
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct tokendef * token;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; token</TT> is a pointer to the structure<TT> tokendef.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char * argv[];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; argv</TT> is an array of pointers to <TT> char</TT> or an array of pointers to strings.
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char ** strptr;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; strptr</TT> is a pointer to a pointer to <TT> char</TT>.
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void * dumpbeg;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; dumpbeg</TT> is a pointer, but to no particular type of object.
<BR>Any place that a pointer may be used, the constant 0 may also be used.&nbsp; This value is the <B> null pointer constant.</B>
&nbsp;The value that is used internally to represent a null pointer is guaranteed not to be a pointer to an object.&nbsp;
It does not necessarily correspond to the integer value 0.&nbsp; It merely represents a pointer that does not currently point
at anything.&nbsp; The macro <TT> NULL</TT>, defined in the header <TT> &lt;stddef.h&gt;</TT>, may also be used in place of
0.
<H3 ID="Special_Pointer_Types_for_Open_Watcom_CD16"> Special Pointer Types for Open Watcom C/16 </H3>
<BR><B>&nbsp; Note:&nbsp; the following sections only apply to the Open Watcom C/16 (16-bit) compiler.&nbsp; For the Open
Watcom C/32 compiler, see the section &quot;Special Pointer Types for Open Watcom C/32&quot;.</B>
<BR><BR>On the 8086, a normal pointer (16 bits) can only point to a 64K region of the total memory available on the machine.
&nbsp;This effectively limits any program to a maximum of 64K of executable code and 64K of data.&nbsp; For many applications,
this does not pose a limitation.
<BR><BR>Some applications need more than 64K of code or data, or both.&nbsp; The Open Watcom C/16 compiler provides a mechanism
whereby pointers can be declared that get beyond the 64K limit.&nbsp; This can be done either by specifying an option when
compiling the files (see the User's Guide) or by including a special type qualifier keyword in the declaration of the object.
&nbsp;Later sections describe these keywords and their use.
<BR><BR>The use of the keywords may prevent the program from compiling using other C compilers, in particular when the program
is being transported to another system.&nbsp; However, the preprocessor can be used to eliminate the keywords on these other
systems.
<BR><BR>Before discussing the special pointer types, it is important to understand the different <B> memory models</B> that
are available and what they mean.&nbsp; The five memory models are referred to as:
<DL>
<DT>small 
<DD>small code (code &lt; 64K), small data (data &lt; 64K)
<DT>compact 
<DD>small code (code &lt; 64K), big data (total data &gt; 64K, all objects &lt; 64K)
<DT>medium 
<DD>big code (code &gt; 64K), small data (data &lt; 64K)
<DT>large 
<DD>big code (code &gt; 64K), big data (total data &gt; 64K, all objects &lt; 64K)
<DT>huge 
<DD>big code (code &gt; 64K), huge data (total data &gt; 64K, objects &gt; 64K)
</DL>
<BR>The following sections discuss the memory models in terms of &quot;small&quot; and &quot;big&quot; code and data sizes.
&nbsp;The terms &quot;small&quot;, &quot;compact&quot;, &quot;medium&quot;, &quot;large&quot; and &quot;huge&quot; are simply
concise terms used to describe the combinations of code and data sizes available.
<H4 ID="The_Small_and_Big_Code_Models"> The Small and Big Code Models </H4>
<BR>Each program can use either<B> small code</B> (less than 64K) or<B> big code</B> (more than 64K).&nbsp; Small code means
that all functions (together) must fit within the 64K limit on code size.&nbsp; It is possible to call a function using only
a 16-bit pointer.&nbsp; This is the default.
<BR><BR>Big code removes the restriction, but requires that all functions be called with a 32-bit pointer.&nbsp; A 32-bit
pointer consists of two 16-bit quantities, called the <B> segment</B> and <B> offset.</B>&nbsp; (When the computer uses the
segment and offset to refer to an actual memory location, the two values are combined to produce a 20-bit memory address,
which allows for the addressing of 1024K of memory.) Because of the larger pointers, the code generated by the big code option
takes more space and takes longer to execute.
<BR><BR>When the big code option is being used, it is possible to group functions together into several 64K (or smaller) regions.
&nbsp;Each module can be its own region, or several modules can be grouped.&nbsp; It is possible to call other functions within
the same group using a 16-bit value.&nbsp; These functions are said to be <B> near.</B>&nbsp; Functions outside the group
can still be called, but must be called using a 32-bit value.&nbsp; These functions are said to be <B> far.</B>
<BR><BR>When the big code option is given on the command line for compiling the module, ordinary pointers to functions will
be defined automatically to be of the larger type, and function calls will be done using the longer (32-bit) form.
<BR><BR>It is also possible to use the small code option, and to override certain functions and pointers to functions as being<B>
far.</B>&nbsp; However, this method may lead to problems.&nbsp; The Open Watcom C/16 compiler generates special function calls
that the programmer doesn't see, such as checking for stack overflow when a function is invoked.&nbsp; These calls are either<B>
near</B> or<B> far</B> depending entirely on the memory model chosen when the module is compiled.&nbsp; If the small code
model is being used, all calls will be near calls.&nbsp; If, however, several code groups are created with far calls between
them, they will all need to access the stack overflow checking routines.&nbsp; The linker can only place these special routines
in one of the code groups, leaving the other functions without access to them, causing an error.
<BR><BR>To resolve this problem, mixing code models requires that all modules be compiled with the big code model, overriding
certain functions as being near.&nbsp; In this manner, the stack checking routines can be placed in any code group, which
the other code groups can still access.&nbsp; Alternatively, a command-line switch may be used to turn off stack checking,
so no stack checking routines get called.
<H4 ID="The_Small_and_Big_Data_Models"> The Small and Big Data Models </H4>
<BR>Each program can use either<B> small data</B> (less than 64K) or<B> big data</B> (more than 64K).&nbsp; Small data requires
that all objects exist within one 64K region of memory.&nbsp; It is possible to refer to each object using a 16-bit pointer.
&nbsp;This is the default.
<BR><BR>Big data removes the restriction, but all pointers to data objects require a 32-bit pointer.&nbsp; As with the big
code option, extra instructions are required to manipulate the 32-bit pointer, so the generated code will be larger and not
as fast.
<BR><BR>With either small or big data, each object is restricted in size to a maximum of 64K bytes.&nbsp; However, an object
may be declared as<B> huge,</B> allowing the object to be bigger than 64K bytes.&nbsp; Pointers to huge objects are the least
efficient because of extra code required to handle them, especially when doing pointer arithmetic.&nbsp; Huge objects are
discussed in the section &quot;The _ _huge Keyword&quot;.
<BR><BR>When the big data option is being used, the program still retains one region up to 64K in size in which objects can
be referred to using 16-bit pointers, regardless of the code group being executed.&nbsp; These objects are said to be <B>
near.</B>&nbsp; Objects outside this region can still be referenced, but must be referred to using a 32-bit value.&nbsp; These
objects are said to be <B> far.</B>
<BR><BR>When the big data option is given on the command line for compiling the module, ordinary pointers to objects other
than functions will be defined automatically to be of the larger type.
<BR><BR>It is also possible to use the small data option, and to override certain objects as being<B> far.</B>&nbsp; The programmer
must decide which method is easier to use.
<H4 ID="Mixing_Memory_Models"> Mixing Memory Models </H4>
<BR>It is possible to mix small and big code and data pointers within one program.&nbsp; In fact, a programmer striving for
optimum efficiency will probably mix pointer types.&nbsp; But great care must be taken!
<BR><BR>In some applications, the programmer may want the ability to have either big code or big data, but won't want to pay
the extra-code penalty required to compile everything accordingly.&nbsp; In the case of big data, the programmer may realize
that 99% of the data structures can reside within the 64K limit, and the remaining ones must go beyond that limit.&nbsp; Similarly,
it may be desirable to have only a few functions that don't fit within the 64K limit.
<BR><BR>When overriding the current memory model, it is<B> very</B> important to declare each type properly.
<BR><BR>The following sections describe how to override the current memory model.
<H4 ID="The____far_Keyword_for_Open_Watcom_CD16"> The _ _far Keyword for Open Watcom C/16 </H4>
<BR>When the big code memory model is in effect, functions are<B> far</B> and pointers to functions are declared automatically
to be pointers to<B> far</B> functions.&nbsp; Similarly, the big data model causes all pointers to objects (other than functions)
to be pointers to<B> far</B> objects.&nbsp; However, when either the small code or small data model is being used, the keyword
<TT> __far</TT> may be used to override to the big model.
<BR><BR>The <TT> __far</TT> keyword is a type qualifier that modifies the token that follows it.&nbsp; If <TT> __far</TT>
precedes<TT> *</TT> (as in<TT> __far *</TT>), then the pointer points to something far.&nbsp; Otherwise, if <TT> __far</TT>
precedes the identifier of the object or function being declared (as in<TT> __far x)</TT>, then the object itself is far.
<BR><BR>The keyword <TT> __far</TT> can only be applied to function and object names and the indirection (pointer) symbol<TT>
*</TT>.&nbsp; Parameters to functions may<B> not</B> be declared as <TT> __far</TT> since they are always in the 64K data
area that is near.
<BR><BR><B>&nbsp; Open Watcom C/16 provides the predefined macros </B><TT> far</TT><B> and </B><TT> _far</TT><B> for convenience
and compatibility with the Microsoft C compiler.&nbsp; They may be used in place of </B><TT> __far</TT><B>.</B>
<BR><BR>The following examples illustrate the use of the <TT> __far</TT> keyword.&nbsp; The examples assume that the small
memory model (small code, small data) is being used.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int __far * ptr;</TT>
<BR><BR>&nbsp;&nbsp;&nbsp; declares<TT> ptr</TT> to be a pointer to an integer.&nbsp; The object<TT> ptr</TT> is near (addressable
using only 16 bits), but the value of the pointer is the address of an integer which is far, and so the pointer contains 32
bits.
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int * __far fptr;</TT>
<BR><BR>&nbsp;&nbsp;&nbsp; also declares<TT> fptr</TT> to be a pointer to an integer.&nbsp; However, the object<TT> fptr</TT>
is far, but the integer that it points to is near.
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int __far * __far ffptr;</TT>
<BR><BR>&nbsp;&nbsp;&nbsp; declares<TT> ffptr</TT> to be a pointer (which is far) to an integer (which is far).
<BR>When declaring a function, placing the keyword <TT> __far</TT> in front of the function name causes the compiler to treat
the function as being far.&nbsp; It is important, if the function is called before its definition, that a <B> function prototype</B>
be included prior to any calls.&nbsp; For example, the declaration,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void __far BubbleSort();</TT>
<BR><BR>declares the function<TT> BubbleSort</TT> to be far, meaning that any calls to it must be far calls.
<BR><BR>Here are a few more examples.&nbsp; These, too, assume that the small memory model (small code, small data) is being
used.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct symbol * __far FSymAlloc( void );</TT>
<BR><BR>&nbsp;&nbsp;&nbsp; declares the function<TT> FSymAlloc</TT> to be far, returning a pointer to a near<TT> symbol</TT>
structure.
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct symbol __far * __far FFSymAlloc( void );</TT>
<BR><BR>&nbsp;&nbsp;&nbsp; declares the function<TT> FFSymAlloc</TT> to be far, returning a pointer to a far<TT> symbol</TT>
structure.
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void Indirect( float __far fn() );</TT>
<BR><BR>&nbsp;&nbsp;&nbsp; declares the function<TT> Indirect</TT> to be near, taking one parameter<TT> fn</TT> which is a
pointer to a far function that returns a <TT> float</TT>.
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int AdjustLeft( struct symbol * __far symptr );</TT>
<BR><BR>&nbsp;&nbsp;&nbsp; is an invalid declaration, since it attempts to declare<TT> symptr</TT> to be far.&nbsp; All parameters
must be near, since they reside in the 64K data area that is always near.
<H4 ID="The____near_Keyword_for_Open_Watcom_CD16"> The _ _near Keyword for Open Watcom C/16 </H4>
<BR>When the small code memory model is in effect, functions are<B> near,</B> and pointers to functions are automatically
declared to be pointers to<B> near</B> functions.&nbsp; Similarly, the small data model causes all pointers to objects (other
than functions) to be pointers to<B> near</B> objects.&nbsp; However, when either the big code or big data model is being
used, the keyword <TT> __near</TT> may be used to override to the small model.
<BR><BR>The <TT> __near</TT> keyword is a type qualifier that modifies the token that follows it.&nbsp; If <TT> __near</TT>
precedes<TT> *</TT> (as in<TT> __near *</TT>), then the pointer points to something near.&nbsp; Otherwise, if <TT> __near</TT>
precedes the identifier of the object or function being declared (as in<TT> __near x)</TT>, then the object itself is near.
<BR><BR>The keyword <TT> __near</TT> can only be applied to function and object names and the indirection (pointer) symbol<TT>
*.</TT>
<BR><BR><B>&nbsp; Open Watcom C/16 provides the predefined macros </B><TT> near</TT><B> and </B><TT> _near</TT><B> for convenience
and compatibility with the Microsoft C compiler.&nbsp; They may be used in place of </B><TT> __near</TT><B>.</B>
<BR><BR>The following examples illustrate the use of the <TT> __near</TT> keyword.&nbsp; These examples assume that the large
memory module (big code, big data) is being used.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int __near * x;</TT>
<BR><BR>&nbsp;&nbsp;&nbsp; declares the object<TT> x</TT> to be a pointer to a near integer.&nbsp; (<TT>x</TT> is not necessarily
within the 64K data area that is near, but the integer that it points to is.)
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int * __near nx;</TT>
<BR><BR>&nbsp;&nbsp;&nbsp; declares the object<TT> nx</TT> to be near, and is a pointer to a far integer.&nbsp; (<TT>nx</TT>
is within the 64K data area that is near, but the integer that it points to might not be.)
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int __near * __near nnx;</TT>
<BR><BR>&nbsp;&nbsp;&nbsp; declares the object<TT> nnx</TT> to be near, and is a pointer to a near integer.&nbsp; (<TT>nnx</TT>
and the integer that it points to are both within the 64K data area that is near.)
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct symbol * __near NSymAlloc( void );</TT>
<BR><BR>&nbsp;&nbsp;&nbsp; declares the function<TT> NSymAlloc</TT> to be near, and returns a pointer to a far<TT> symbol</TT>
structure.
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct symbol __near * __near NNSymAlloc( void );</TT>
<BR><BR>&nbsp;&nbsp;&nbsp; declares the function<TT> NNSymAlloc</TT> to be near, and returns a pointer to a near<TT> symbol</TT>
structure.
<H4 ID="The____huge_Keyword_for_Open_Watcom_CD16"> The _ _huge Keyword for Open Watcom C/16 </H4>
<BR>Even using the big data model, each object is restricted in size to 64K.&nbsp; Some applications will need to get beyond
this limitation.&nbsp; The Open Watcom C/16 compiler provides the keyword <TT> __huge</TT> to describe those objects that
exceed 64K in size.&nbsp; The code generated for these objects is less efficient than for <TT> __far</TT> objects.
<BR><BR>The declaration of such objects follows the same pattern as above, with the keyword <TT> __huge</TT> preceding the
name of the object if the object itself is bigger than 64K, or preceding the<TT> *</TT> if the pointer is to an object that
is bigger than 64K.
<BR><BR>The keyword <TT> __huge</TT> can only be applied to arrays.&nbsp; Huge objects may be used in both the small and big
data models.
<BR><BR><B>&nbsp; Open Watcom C/16 provides the predefined macros </B><TT> huge</TT><B> and </B><TT> _huge</TT><B> for convenience
and compatibility with the Microsoft C compiler.&nbsp; They may be used in place of </B><TT> __huge</TT><B>.</B>
<BR><BR>These examples illustrate the use of the <TT> __huge</TT> keyword.&nbsp; They assume that big code, small data (the
medium memory model) is in effect.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int __huge iarray[50000];</TT>
<BR><BR>&nbsp;&nbsp;&nbsp; declares the object<TT> iarray</TT> to be an array of 50000 integers, for a total size of 100000
bytes.
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int __huge * iptr;</TT>
<BR><BR>&nbsp;&nbsp;&nbsp; declares<TT> iptr</TT> to be near, and a pointer to an integer that is part of a huge array, such
as an element of<TT> iarray.</TT>
<H3 ID="Special_Pointer_Types_for_Open_Watcom_CD32"> Special Pointer Types for Open Watcom C/32 </H3>
<BR>With an 80386 processor in &quot;protect&quot; mode, a normal pointer (32 bits) can point to a 4 gigabyte (4,294,967,296
byte) region of the memory available on the machine.&nbsp; (In practice, memory limits may mean that these regions will be
smaller than 4 gigabytes.) These regions are called<B> segments,</B> and there may be more than one segment defined for the
memory.&nbsp; Each 32-bit pointer is actually an offset within a 4 gigabyte segment, and the offsets within two different
segments are generally not related to each other in a known manner.
<BR><BR>As an example, the screen memory may be set up so that it resides in a different region of the memory from the program's
data.&nbsp; Normal pointers (those within the program's data area) will not be able to access such regions.
<BR><BR>Like the 16-bit version of Open Watcom C (for the 8086 and 80286), Open Watcom C/32 uses the <TT> __near</TT> and
<TT> __far</TT> keywords to describe objects that are either in the normal data space or elsewhere.
<BR><BR>Objects or functions that are near require a 32-bit pointer to access them.
<BR><BR>Objects or functions that are far require a 48-bit pointer to access them.&nbsp; This 48-bit pointer consists of two
parts:&nbsp; a <B> selector</B> consisting of 16 bits, and an <B> offset</B> consisting of 32 bits.&nbsp; A selector is similar
to a segment in a 16-bit program's far pointer, except that the numeric value of the selector does not directly determine
the memory region.&nbsp; Instead, the processor uses the selector value in conjunction with a &quot;descriptor table&quot;
to determine what region of memory is to be accessed.&nbsp; In the discussion of far pointers on the 80386, the terms selector
and segment may be used interchangeably.
<BR><BR>Like the 16-bit compiler, the Open Watcom C/32 compiler supports the small, compact, medium and large memory models.
&nbsp;Throughout the discussions in the following sections, it is assumed that the small memory model is being used, since
it is the most likely to be used.
<H4 ID="The____far_Keyword_for_Open_Watcom_CD32"> The _ _far Keyword for Open Watcom C/32 </H4>
<BR>The <TT> __far</TT> keyword is a type qualifier that modifies the token that follows it.&nbsp; If <TT> __far</TT> precedes<TT>
*</TT> (as in<TT> __far *</TT>), then the pointer points to something that is far (not in the normal data region).&nbsp; Otherwise,
if <TT> __far</TT> precedes the identifier of the object or function being declared (as in<TT> __far x</TT>), then the object
or function is far.
<BR><BR>The keyword <TT> __far</TT> can only be applied to function and object names and the indirection (pointer) symbol<TT>
*</TT>.&nbsp; Parameters to functions may<B> not</B> be declared as <TT> __far</TT>, since they are always in the normal data
region.
<BR><BR>These examples illustrate the use of the <TT> __far</TT> keyword, and assume that the small memory model is being
used.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int __far * ptr;</TT>
<BR><BR>&nbsp;&nbsp;&nbsp; declares<TT> ptr</TT> to be a pointer to an integer.&nbsp; The object<TT> ptr</TT> is near but
the integer that it points to is far.
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int * __far fptr;</TT>
<BR><BR>&nbsp;&nbsp;&nbsp; also declares<TT> fptr</TT> to be a pointer to an integer.&nbsp; However, the object<TT> fptr</TT>
is far, but the integer that it points to is near.
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int __far * __far ffptr;</TT>
<BR><BR>&nbsp;&nbsp;&nbsp; declares<TT> ffptr</TT> to be a pointer (which is far) to an integer (which is far).
<BR>When declaring a function, placing the keyword <TT> __far</TT> in front of the function name causes the compiler to treat
the function as being far.&nbsp; It is important, if the function is called before its definition, that a <B> function prototype</B>
be included prior to any calls.&nbsp; For example, the declaration,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern void __far SystemService();</TT>
<BR><BR>declares the function<TT> SystemService</TT> to be far, meaning that any calls to it must be far calls.
<BR><BR>Here are a few more examples:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern struct systbl * __far FSysTblPtr( void );</TT>
<BR><BR>&nbsp;&nbsp;&nbsp; declares the function<TT> FSysTblPtr</TT> to be far, returning a pointer to a near<TT> systbl</TT>
structure.
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern struct systbl __far * __far FFSysTblPtr( void );</TT>
<BR><BR>&nbsp;&nbsp;&nbsp; declares the function<TT> FFSysTblPtr</TT> to be far, returning a pointer to a far<TT> systbl</TT>
structure.
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern void Indirect( char __far fn() );</TT>
<BR><BR>&nbsp;&nbsp;&nbsp; declares the function<TT> Indirect</TT> to be near, taking one parameter<TT> fn</TT> which is a
pointer to a far function that returns a <TT> char</TT>.
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int StoreSysTbl( struct systbl * __far sysptr );</TT>
<BR><BR>&nbsp;&nbsp;&nbsp; is an invalid declaration, since it attempts to declare<TT> sysptr</TT> to be far.&nbsp; All parameters
must be near, since they reside in the normal data area that is always near.
<H4 ID="The____near_Keyword_for_Open_Watcom_CD32"> The _ _near Keyword for Open Watcom C/32 </H4>
<BR>The <TT> __near</TT> keyword is a type qualifier that modifies the token that follows it.&nbsp; If <TT> __near</TT> precedes<TT>
*</TT> (as in<TT> __near *</TT>), then the pointer points to something that is near (in the normal data region).&nbsp; Otherwise,
if <TT> __near</TT> precedes the identifier of the object or function being declared (as in<TT> __near x</TT>), then the object
or function is near.
<BR><BR>The keyword <TT> __near</TT> can only be applied to function and object names and the indirection (pointer) symbol<TT>
*</TT>.
<BR><BR>For programmers using the small memory model, the <TT> __near</TT> keyword is not required, but may be useful for
making the program more readable.
<H4 ID="The____far16_and__Seg16_Keywords"> The _ _far16 and _Seg16 Keywords </H4>
<BR>With the 80386 processor, a far pointer consists of a 16-bit selector and a 32-bit offset.&nbsp; Open Watcom C/32 also
supports a special kind of far pointer which consists of a 16-bit selector and a 16-bit offset.&nbsp; These pointers, referred
to as <B> far16</B> pointers, allow 32-bit code to access code and data running in 16-bit mode.
<BR><BR>In the OS/2 operating system (version 2.0 or higher), the first 512 megabytes of the 4 gigabyte segment referenced
by the DS register is divided into 8192 areas of 64K bytes each.&nbsp; A far16 pointer consists of a 16-bit selector referring
to one of the 64K byte areas, and a 16-bit offset into that area.
<BR><BR>For compatibility with Microsoft C, Open Watcom C/32 provides the <TT> __far16</TT> keyword.&nbsp; A pointer declared
as,
<BR><BR><B>&nbsp; type</B><TT> __far16 *</TT><B> name</B><TT>;</TT>
<BR><BR>defines an object that is a far16 pointer.&nbsp; If such a pointer is accessed in the 32-bit environment, the compiler
will generate the necessary code to convert between the far16 pointer and a &quot;flat&quot; 32-bit pointer.
<BR><BR>For example, the declaration,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char __far16 * bufptr;</TT>
<BR><BR>declares the object<TT> bufptr</TT> to be a far16 pointer to <TT> char</TT>.
<BR><BR>A function declared as,
<BR><BR><B>&nbsp; type</B><TT> __far16</TT><B> func</B><TT>(</TT><B> parm-list</B><TT> );</TT>
<BR><BR>declares a 16-bit function.&nbsp; Any calls to such a function from the 32-bit environment will cause the compiler
to convert any 32-bit pointer parameters to far16 pointers, and any <TT> int</TT> parameters from 32 bits to 16 bits.&nbsp;
(In the 16-bit environment, an object of type <TT> int</TT> is only 16 bits.) Any return value from the function will have
its return value converted in an appropriate manner.
<BR><BR>For example, the declaration,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char * __far16 Scan( char * buffer, int buflen, short err );</TT>
<BR><BR>declares the 16-bit function<TT> Scan</TT>.&nbsp; When this function is called from the 32-bit environment, the<TT>
buffer</TT> parameter will be converted from a flat 32-bit pointer to a far16 pointer (which, in the 16-bit environment, would
be declared as<TT> char __far *</TT>).&nbsp; The<TT> buflen</TT> parameter will be converted from a 32-bit integer to a 16-bit
integer.&nbsp; The<TT> err</TT> parameter will be passed unchanged.&nbsp; Upon returning, the far16 pointer (far pointer in
the 16-bit environment) will be converted to a 32-bit pointer which describes the equivalent location in the 32-bit address
space.
<BR><BR>For compatibility with IBM C Set/2, Open Watcom C/32 provides the <TT> _Seg16</TT> keyword.&nbsp; Note that <TT> _Seg16</TT>
is<B> not</B> interchangeable with <TT> __far16</TT>.
<BR><BR>A pointer declared as,
<BR><BR><B>&nbsp; type</B><TT> * _Seg16</TT><B> name</B><TT>;</TT>
<BR><BR>defines an object that is a far16 pointer.&nbsp; Note that the <TT> _Seg16</TT> appears on the opposite side of the<TT>
*</TT> than the <TT> __far16</TT> keyword described above.
<BR><BR>For example,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char * _Seg16 bufptr;</TT>
<BR><BR>declares the object<TT> bufptr</TT> to be a far16 pointer to <TT> char</TT> (the same as above).
<BR><BR>The <TT> _Seg16</TT> keyword may not be used to describe a 16-bit function.&nbsp; A <TT> #pragma</TT> directive must
be used.&nbsp; See the User's Guide for details.&nbsp; A function declared as,
<BR><BR><B>&nbsp; type</B><TT> * _Seg16</TT><B> func</B><TT>(</TT><B> parm-list</B><TT> );</TT>
<BR><BR>declares a 32-bit function that returns a far16 pointer.
<BR><BR>For example, the declaration,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char * _Seg16 Scan( char * buffer, int buflen, short err );</TT>
<BR><BR>declares the 32-bit function<TT> Scan</TT>.&nbsp; No conversion of the parameter list will take place.&nbsp; The return
value is a far16 pointer.
<H3 ID="Based_Pointers_for_Open_Watcom_CD16_and_CD32"> Based Pointers for Open Watcom C/16 and C/32 </H3>
<BR>Near pointers are generally the most efficient type of pointer because they are small, and the compiler can assume knowledge
about what segment of the computer's memory the pointer (offset) refers to.&nbsp; Far pointers are the most flexible because
they allow the programmer to access any part of the computer's memory, without limitation to a particular segment.&nbsp; However,
far pointers are bigger and slower because of the additional flexibility.
<BR><BR>Based pointers are a compromise between the efficiency of near pointers and the flexibility of far pointers.&nbsp;
With based pointers, the programmer takes responsibility to tell the compiler which segment a near pointer (offset) belongs
to, but may still access segments of the computer's memory outside of the normal data segment (DGROUP).&nbsp; The result is
a pointer type which is as small as and almost as efficient as a near pointer, but with most of the flexibility of a far pointer.
<BR><BR>An object declared as a based pointer falls into one of the following categories:
<UL>
<LI>the based pointer is in the segment described by another object,
<LI>the based pointer, used as a pointer to another object of the same type (as in a linked list), refers to the same segment,
<LI>the based pointer is an offset to no particular segment, and must be combined explicitly with a segment value to produce
a valid pointer.
</UL>
<BR>To support based pointers, the following keywords are provided:
<BR><BR><TT>&nbsp; __based </TT>
<BR><TT>&nbsp; __segment </TT>
<BR><TT>&nbsp; __segname </TT>
<BR><TT>&nbsp; __self </TT>
<BR>The following operator is also provided:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; :&gt;</TT>
<BR><BR>These keywords and operator are described in the following sections.
<BR><BR>Two macros, defined in <TT> &lt;malloc.h&gt;</TT> are also provided:&nbsp; 
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _NULLSEG</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _NULLOFF</TT>
<BR><BR>They are used in a similar manner to <TT> NULL</TT>, but are used with objects declared as <TT> __segment</TT> and
<TT> __based</TT> respectively.
<H4 ID="Segment_Constant_Based_Pointers_and_Objects"> Segment Constant Based Pointers and Objects </H4>
<BR>A segment constant based pointer or object has its segment value based on a specific, named segment.&nbsp; A segment constant
based object is specified as:
<BR><BR><B>&nbsp; type</B><TT> __based( __segname( &quot;</TT><B>segment</B><TT>&quot; ) )</TT><B> object-name</B><TT>;</TT>
<BR><BR>and a segment constant based pointer is specified as:
<BR><BR><B>&nbsp; type</B><TT> __based( __segname( &quot;</TT><B>segment</B><TT>&quot; ) ) *</TT><B> object-name</B><TT>;</TT>
<BR><BR>where<B> segment</B> is the name of the segment in which the pointer or object is based.&nbsp; As shown above, the
segment name is always specified as a string.&nbsp; There are three special segment names recognized by the compiler:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &quot;_CODE&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &quot;_CONST&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &quot;_DATA&quot;</TT>
<BR><BR>The<TT> &quot;_CODE&quot;</TT> segment is the default code segment.&nbsp; The<TT> &quot;_CONST&quot;</TT> segment
is the segment containing constant values.&nbsp; The<TT> &quot;_DATA&quot;</TT> segment is the default data segment.&nbsp;
If the segment name is not one of the three recognized names, then a segment will be created with that name.&nbsp; If a segment
constant based object is being defined, then it will be placed in the named segment.&nbsp; If a segment constant based pointer
is being defined, then it can point at objects in the named segment.
<BR><BR>The following examples illustrate segment constant based pointers and objects:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int __based( __segname( &quot;_CODE&quot; ) )&nbsp;&nbsp; ival = 3;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int __based( __segname( &quot;_CODE&quot; ) ) * iptr;</TT>
<BR><BR><TT>ival</TT> is an object that resides in the default code segment.<TT>&nbsp; iptr</TT> is an object that resides
in the data segment (the usual place for data objects), but points at an integer which resides in the default code segment.<TT>
&nbsp;iptr</TT> is suitable for pointing at<TT> ival</TT>.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char __based( __segname( &quot;GOODTHINGS&quot; ) ) thing;</TT>
<BR><BR><TT>thing</TT> is an object which resides in the segment<TT> GOODTHINGS</TT>, which will be created if it does not
already exist.&nbsp; (The creation of segments is done by the linker, and is a method of grouping objects and functions.&nbsp;
Nothing is implicitly created during the execution of the program.)
<H4 ID="Segment_Object_Based_Pointers"> Segment Object Based Pointers </H4>
<BR>A segment object based pointer derives its segment value from another named object.&nbsp; A segment object based pointer
is specified as follows:
<BR><BR><B>&nbsp; type</B><TT> __based(</TT><B> segment</B><TT> ) *</TT><B> name</B><TT>;</TT>
<BR><BR>where<B> segment</B> is an object defined as type <TT> __segment</TT>.
<BR><BR>An object of type <TT> __segment</TT> may contain a segment value.&nbsp; Such an object is particularly designed for
use with segment object based pointers.
<BR><BR>The following example illustrates a segment object based pointer:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; __segment&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; seg;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char __based( seg ) * cptr;</TT>
<BR><BR>The object<TT> seg</TT> contains only a segment value.&nbsp; Whenever the object<TT> cptr</TT> is used to point to
a character, the actual pointer value will be made up of the segment value found in<TT> seg</TT> and the offset value found
in<TT> cptr</TT>.&nbsp; The object<TT> seg</TT> might be assigned values such as the following:
<UL>
<LI>a constant value (eg.&nbsp; the segment containing screen memory),
<LI>the result of the library function <TT> _bheapseg</TT>,
<LI>the segment portion of another pointer value, by casting it to the type <TT> __segment</TT>.
</UL>
<H4 ID="Void_Based_Pointers"> Void Based Pointers </H4>
<BR>A void based pointer must be explicitly combined with a segment value to produce a reference to a memory location.&nbsp;
A void based pointer does not infer its segment value from another object.&nbsp; The<TT> :&gt;</TT> (base) operator is used
to combine a segment value and a void based pointer.
<BR><BR>For example, on an IBM PC or PS/2 computer, running DOS, with a color monitor, the screen memory begins at segment
0xB800, offset 0.&nbsp; In a video text mode, to examine the first character currently displayed on the screen, the following
code could be used:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern void main()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __segment&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; screen;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char __based( void ) * scrptr;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; screen = 0xB800;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scrptr = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Top left character is '%c'.\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *(screen:&gt;scrptr)
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The general form of the<TT> :&gt;</TT> operator is:
<BR><BR><B>&nbsp; segment</B><TT> :&gt;</TT><B> offset</B>
<BR><BR>where<B> segment</B> is an expression of type <TT> __segment</TT>, and<B> offset</B> is an expression of type<TT>
__based( void ) *</TT>.
<H4 ID="Self_Based_Pointers"> Self Based Pointers </H4>
<BR>A self based pointer infers its segment value from itself.&nbsp; It is particularly useful for structures such as linked
lists, where all of the list elements are in the same segment.&nbsp; A self based pointer pointing to one element may be used
to access the next element, and the compiler will use the same segment as the original pointer.
<BR><BR>The following example illustrates a function which will print the values stored in the last two members of a linked
list:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct a {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct a __based( __self ) * next;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; number;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern void PrintLastTwo( struct a far * list )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __segment&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; seg;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct a __based( seg ) * aptr;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; seg&nbsp; = FP_SEG( list );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aptr = FP_OFF( list );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( ; aptr != _NULLOFF; aptr = aptr-&gt;next ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( aptr-&gt;next == _NULLOFF ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Last
item is %d\n&quot;, aptr-&gt;number );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if( aptr-&gt;next-&gt;next == _NULLOFF
) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Second
last item is %d\n&quot;, aptr-&gt;number );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The parameter to the function<TT> PrintLastTwo</TT> is a far pointer, pointing to a linked list structure anywhere
in memory.&nbsp; It is assumed that all members of a particular linked list of this type reside in the same segment of the
computer's memory.&nbsp; (Another instance of the linked list might reside entirely in a different segment.) The object<TT>
seg</TT> is given the segment portion of the far pointer.&nbsp; The object<TT> aptr</TT> is given the offset portion, and
is described as being based in the segment stored in<TT> seg.</TT>
<BR><BR>The expression<TT> aptr-&gt;next</TT> refers to the<TT> next</TT> member of the structure stored in memory at the
offset stored in<TT> aptr</TT> and the segment implied by<TT> aptr</TT>, which is the value stored in<TT> seg.</TT>&nbsp;
So far, the behavior is no different than if<TT> next</TT> had been declared as,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct a * next;</TT>
<BR><BR>The expression<TT> aptr-&gt;next-&gt;next</TT> illustrates the difference of using a self based pointer.&nbsp; The
first part of the expression (<TT>aptr-&gt;next</TT>) occurs as described above.&nbsp; However, using the result to point
to the next member occurs by using the offset value found in the<TT> next</TT> member and combining it with the segment value
of the<B> pointer used to get to that member</B>, which is still the segment implied by<TT> aptr</TT>, which is the value
stored in<TT> seg.</TT>&nbsp; If<TT> next</TT> had not been declared using<TT> __based( __self )</TT>, then the second pointing
operation would refer to the offset value found in the<TT> next</TT> member, but with the default data segment (DGROUP), which
may or may not be the same segment as stored in<TT> seg.</TT>
<H2 ID="Void"> Void </H2>
<BR>The <TT> void</TT> type has several purposes:
<OL>
<LI>To declare an object as being a pointer to no particular type.&nbsp; For example,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void * membegin;</TT>
<BR><BR>defines<TT> membegin</TT> as being a pointer.&nbsp; It does not point to anything without a<B> cast</B> operator.
&nbsp;The statement,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *(char *) membegin = '\0';</TT>
<BR><BR>will place a zero in the character at which<TT> membegin</TT> points.
<LI>To declare a function as not returning a value.&nbsp; For example,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void rewind( FILE * stream );</TT>
<BR><BR>declares the standard library function <TT> rewind</TT> which takes one parameter and returns nothing.
<LI>To evaluate an expression for its side-effects, discarding the result of the expression.&nbsp; For example,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; (void) getchar();</TT>
<BR><BR>calls the library function <TT> getchar</TT>, which normally returns a character.&nbsp; In this case, the character
is discarded, effectively advancing one character in the file without caring what character is read.&nbsp; This use of <TT>
void</TT> is primarily for readability, because casting the expression to the void type will be done automatically.&nbsp;
The above example could also be written as,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; getchar();</TT>
</OL>
<BR>The keyword <TT> void</TT> is also used in one other instance.&nbsp; If a function takes no parameters, <TT> void</TT>
may be used in the declaration.&nbsp; For example,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int getchar( void );</TT>
<BR><BR>declares the standard library function <TT> getchar</TT>, which takes no parameters and returns an integer.
<BR><BR>No object (other than a function) may be declared with type <TT> void</TT>.
<H2 ID="The_const_and_volatile_Declarations"> The const and volatile Declarations </H2>
<BR>An object may be declared with the keyword <TT> const</TT>.&nbsp; Such an object may not be modified directly by the program.
&nbsp;For objects with static storage duration, this type qualifier describes to the compiler which objects may be placed
in read-only memory, if the computer supports such a concept.&nbsp; It also provides the opportunity for the compiler to detect
attempts to modify the object.&nbsp; The compiler may also generate better code when it knows that an object will not be modified.
<BR><BR>Even though an object is declared to be constant, it is possible to modify its value indirectly by storing its address
(using a cast) in another object declared to be a pointer to the same type (without the<TT> const</TT>), and then using the
second object to modify the value to which it points.&nbsp; However, this should be done with caution, and may fail on computers
with protected memory.
<BR><BR>If the declaration of an object does not include<TT> *</TT>, that is to say it is not a pointer of any kind, then
the keyword <TT> const</TT> appearing anywhere in the type specifier (including any <TT> typedef</TT>'s) indicates that the
object is constant and may not be changed.&nbsp; If the object is a pointer and <TT> const</TT> appears to the left of the<TT>
*</TT>, the object is a pointer to a constant value, meaning that the value to which the pointer points may not be modified,
although the pointer value may be changed.&nbsp; If <TT> const</TT> appears to the right of the<TT> *</TT>, the object is
a constant pointer to a value, meaning that the pointer to the value may not be changed, although what the pointer points
to may be changed.&nbsp; If <TT> const</TT> appears on both sides of the<TT> *</TT>, the object is a constant pointer to a
constant value, meaning that the pointer and the object to which it points may not be changed.
<BR><BR>If the declaration of a structure, union or array includes <TT> const</TT>, then each member of the type, when referred
to, is treated as if <TT> const</TT> had been specified.
<BR><BR>The declarations,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; const int&nbsp;&nbsp; baseyear = 1900;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; const int * byptr;</TT>
<BR><BR>declare the object<TT> baseyear</TT> to be an integer whose value is constant and set to 1900, and the object<TT>
byptr</TT> to be a pointer to a constant object of integer type.&nbsp; If<TT> byptr</TT> was made to point to another integer
that was not, in fact, declared to be constant, then<TT> byptr</TT> could not be used to modify that value.<TT>&nbsp; byptr</TT>
may be used to get a value from an integer object, and never to change it.&nbsp; Another way of stating it is that what<TT>
byptr</TT> points to is constant, but<TT> byptr</TT> itself is not constant.
<BR><BR>The declarations,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; baseyear;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int * const byptr = &amp;baseyear;</TT>
<BR><BR>declare the object<TT> byptr</TT> as a constant pointer to an integer, in this case the object<TT> baseyear.</TT>
&nbsp;The value of<TT> baseyear</TT> may be modified via<TT> byptr</TT>, but the value of<TT> byptr</TT> itself may not be
changed.&nbsp; In this case,<TT> byptr</TT> itself is constant, but what<TT> byptr</TT> points to is not constant.&nbsp; 
<BR><BR>An object may be declared with the keyword <TT> volatile</TT>.&nbsp; Such an object may be freely modified by the
program, and its value also may be modified through actions outside the program.&nbsp; For example, a flag may be set when
a given interrupt occurs.&nbsp; The keyword <TT> volatile</TT> indicates to the compiler that care must be taken when optimizing
code referring to the object, so that the meaning of the program is not altered.&nbsp; An object that the compiler might otherwise
have been able to keep in a register for an extended period of time will be forced to reside in normal storage so that an
external change to it will be reflected in the program's behavior.
<BR><BR>If the declaration of an object does not include<TT> *</TT>, that is to say it is not a pointer of any kind, then
the keyword <TT> volatile</TT> appearing anywhere in the type specifier (including any <TT> typedef</TT>'s) indicates that
the object is volatile and may be changed at any time without the program knowing.&nbsp; If the object is a pointer and <TT>
volatile</TT> appears to the left of the<TT> *</TT>, the object is a pointer to a volatile value, meaning that the value to
which the pointer points may be changed at any time.&nbsp; If <TT> volatile</TT> appears to the right of the<TT> *</TT>, the
object is a volatile pointer to a value, meaning that the pointer to the value may be changed at any time.&nbsp; If <TT> volatile</TT>
appears on both the left and the right of the<TT> *</TT>, the object is a volatile pointer to a volatile value, meaning that
the pointer or the value to which it points may be changed at any time.
<BR><BR>If the declaration of a structure, union or array includes <TT> volatile</TT>, then each member of the type, when
referred to, is treated as if <TT> volatile</TT> had been specified.
<BR><BR>The declarations,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; volatile int&nbsp;&nbsp; attncount;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; volatile int * acptr;</TT>
<BR><BR>declare the object<TT> attncount</TT> to be an integer whose value may be altered at any time (say by an asynchronous
attention handler), and the object<TT> acptr</TT> to be a pointer to a volatile object of integer type.
<BR><BR>If both <TT> const</TT> and <TT> volatile</TT> are included in the declaration of an object, then that object may
not be modified by the program, but it may be modified through some external action.&nbsp; An example of such an object is
the clock in a computer, which is modified periodically (every clock &quot;tick&quot;), but programs are not allowed to change
it.
<H1 ID="Storage_Classes"> Storage Classes </H1>
<BR>The<B> storage class</B> of an object describes:
<UL>
<LI>the duration of the existence of the object.&nbsp; An object may exist throughout the execution of the program, or only
during the span of time that the function in which it is defined is executing.&nbsp; In the latter case, each time the function
is called, a new instance of the object is created, and that object is destroyed when the function returns.
<LI>the<B> scope</B> of the object.&nbsp; An object may be declared so that it is only accessible within the function in which
it is defined, within the module or throughout the entire program.
</UL>
<BR>A<B> storage class specifier</B> is one of:
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; auto</TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; register</TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern</TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static</TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef</TT>
<BR><BR><TT> typedef</TT> is included in the list of storage class specifiers for convenience, because the syntax of a type
definition is the same as for an object declaration.&nbsp; A <TT> typedef</TT> declaration does not create an object, only
a synonym for a type, which does not have a storage class associated with it.
<BR><BR>Only one of these keywords (excluding <TT> typedef</TT>) may be specified in a declaration of an object.
<BR><BR>If an object or function is declared with a storage class, but no type specifier, then the type of the object or function
is assumed to be <TT> int</TT>.
<BR><BR>While a storage class specifier may be placed following a type specifier, this tends to be difficult to read.&nbsp;
It is recommended that the storage class (if present) always be placed first in the declaration.&nbsp; The ISO C standard
states that the ability to place the storage class specifier other than at the beginning of the declaration is an obsolescent
feature.
<H2 ID="Type_Definitions"> Type Definitions </H2>
<BR>A<B> typedef</B> declaration introduces a synonym for another type.&nbsp; It does not introduce a new type.
<BR><BR>The general form of a type definition is:
<BR><BR><TT>&nbsp; typedef</TT><B> type-information typedef-name</B><TT>;</TT>
<BR><BR>The<B> typedef-name</B> may be a comma-separated list of identifiers, all of which become synonyms for the type.&nbsp;
The names are in the same name space as ordinary object names, and can be redefined in inner blocks.&nbsp; However, this can
be confusing and should be avoided.
<BR><BR>The simple declaration,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef signed int COUNTER;</TT>
<BR><BR>declares the identifier<TT> COUNTER</TT> to be equivalent to the type <TT> signed int</TT>.&nbsp; A subsequent declaration
like,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; COUNTER ctr;</TT>
<BR><BR>declares the object<TT> ctr</TT> to be a signed integer.&nbsp; If, later on, it is necessary to change all counters
to be long signed integers, then only the <TT> typedef</TT> would have to be changed, as follows:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef long signed int COUNTER;</TT>
<BR><BR>All declarations of objects of that type will use the new type.
<BR><BR>The <TT> typedef</TT> can be used to simplify declarations elsewhere in a program.&nbsp; For example, consider the
following structure:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct complex {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double&nbsp;&nbsp;&nbsp; real;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double&nbsp;&nbsp;&nbsp; imaginary;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR>To declare an object to be an instance of the structure requires the following declaration:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct complex cnum;</TT>
<BR><BR>Now consider the following structure definition with a type definition:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef struct {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double&nbsp;&nbsp; real;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double&nbsp;&nbsp; imaginary;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; } COMPLEX;</TT>
<BR><BR>In this case, the identifier<TT> COMPLEX</TT> refers to the entire structure definition, including the keyword <TT>
struct</TT>.&nbsp; Therefore, an object can be declared as follows:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; COMPLEX cnum;</TT>
<BR><BR>While this is a simple example, it illustrates a method of making object declarations more readable.
<BR><BR>Consider the following example, where the object<TT> fnptr</TT> is being declared as a pointer to a function which
takes two parameters, a pointer to a structure<TT> dim3</TT> and an integer.&nbsp; The function returns a pointer to the structure<TT>
dim3.</TT>&nbsp; The declarations could appear as follows:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct dim3 {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp; x;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp; y;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp; z;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct dim3 * (*fnptr)( struct dim3 *, int );</TT>
<BR><BR>or as:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef struct {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp; x;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp; y;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp; z;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; } DIM3;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DIM3 * (*fnptr)( DIM3 *, int );</TT>
<BR><BR>or as:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef struct {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp; x;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp; y;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp; z;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; } DIM3;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef DIM3 * DIM3FN( DIM3 *, int );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DIM3FN * fnptr;</TT>
<BR><BR>The last example simply declares<TT> fnptr</TT> to be a pointer to a<TT> DIM3FN</TT>, while<TT> DIM3FN</TT> is declared
to be a function with two parameters, a pointer to a<TT> DIM3</TT> and an integer.&nbsp; The function returns a pointer to
a<TT> DIM3.&nbsp; DIM3</TT> is declared to be a structure of three co-ordinates.
<H3 ID="Compatible_Types"> Compatible Types </H3>
<BR>Some operations, such as assignment, are restricted to operating on two objects of the same type.&nbsp; If both operands
are already the same type, then no special conversion is required.&nbsp; Otherwise, the compiler may alter automatically one
or both operands to make them the same type.&nbsp; The integral promotions and arithmetic conversions are examples.&nbsp;
Other types may require an explicit cast.
<BR><BR>The compiler decides whether or not an explicit cast is required based on the concept of <B> compatible types.</B>
&nbsp;The following types are compatible:
<UL>
<LI>two types that are declared exactly the same way,
<LI>two types that differ only in the ordering of the type specifiers, for example, <TT> unsigned long int</TT> and <TT> int
long unsigned</TT>,
<LI>two arrays of members of compatible type, where both arrays have the same size, or where one array is declared without
size information,
<LI>two functions that return the same type, one containing no parameter information, and the other containing a fixed number
of parameters (no &quot;<TT>,...</TT>&quot;) that are not affected by the default argument promotions,
<LI>two structures, defined in separate modules, that have the same number and names of members, in the same order, with compatible
types,
<LI>two unions, defined in separate modules, that have the same number and names of members, with compatible types,
<LI>two enumerated types, defined in separate modules, that have the same number of enumeration constants, with the same names
and the same values,
<LI>two pointers to compatible types.
</UL>
<H2 ID="Static_Storage_Duration"> Static Storage Duration </H2>
<BR>An object with<B> static storage duration</B> is created and initialized only once, prior to the execution of the program.
&nbsp;Any value stored in such an object is retained throughout the program unless it is explicitly altered by the program
(or it is declared with the <TT> volatile</TT> keyword).
<BR><BR>Any object that is declared outside the scope of a function has static storage duration.
<BR><BR>There are three types of static objects:
<OL>
<LI>objects whose values are only available within the function in which they are defined (no linkage).&nbsp; For example,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern void Fn( int x )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static int ObjCount;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* ... */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<LI>objects whose values are only available within the module in which they are defined (internal linkage).&nbsp; For example,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static int ObjCount;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern void Fn( int x )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* ... */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<LI>objects whose values are available to all components of the program (external linkage).&nbsp; For example,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int ObjCount = { 0 };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern void Fn( int x )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* ... */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
</OL>
<BR>The first two types are defined with the keyword <TT> static</TT>, while the third is defined with the (optional) keyword
<TT> extern</TT>.
<H3 ID="The_static_Storage_Class"> The static Storage Class </H3>
<BR>Any declaration of an object may be preceded by the keyword <TT> static</TT>.&nbsp; A declaration inside a function indicates
to the compiler that the object has <B> no linkage,</B> meaning that it is available only within the function.&nbsp; A declaration
not inside any function indicates to the compiler that this object has <B> internal linkage,</B> meaning that it is available
in all functions within the module in which it is defined.&nbsp; Other modules may not refer to the specific object.&nbsp;
They may have their own object defined with the same name, but this is a questionable programming practice and should be avoided.
<BR><BR>The value of the object will be preserved between function calls.&nbsp; Any value placed in an object with static
storage duration will remain unchanged until changed by a function within the same module.&nbsp; It is also possible for a
pointer to the object to be passed to a function outside the module in which the object is defined.&nbsp; This pointer could
be used to modify the value of the object.
<H3 ID="The_extern_Storage_Class"> The extern Storage Class </H3>
<BR>If an object is declared with the keyword <TT> extern</TT> inside a function, then the object has <B> external linkage,</B>
meaning that its value is available to all modules, and to the function(s) containing the definition in the current module.
&nbsp;No initializer list may be specified in this case, which implies that the space for the object is allocated in some
other module.
<BR><BR>If an object is declared outside of the definition of a function, and the declaration does not contain either of the
keywords <TT> static</TT> or <TT> extern</TT>, then the space for the object is created at this point.&nbsp; The object has
<B> external linkage,</B> meaning that it is available to other modules in the program.
<BR><BR>The following examples illustrate the creation of external objects, provided the declarations occur outside any function:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; X;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; float F;</TT>
<BR><BR>If the declaration for an object, outside of the definition of a function, contains the keyword <TT> extern</TT> and
has an initializer list, then space for the object is created at this point, and the object has external linkage.&nbsp; If,
however, the declaration does not include an initializer list, then the compiler assumes that the object is declared elsewhere.
&nbsp;If, during the remainder of the compilation of the module, no further declarations of the object are found, or more
declarations with <TT> extern</TT> and no initializer list are found, then the object must have space allocated for it in
another module.&nbsp; If a subsequent declaration in the same module does have an initializer list or omits the <TT> extern</TT>
keyword, then the space for the object is created at that point.
<BR><BR>The following examples also illustrate the creation of external objects:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern LIST * ListHead = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp; StartVal = 77;</TT>
<BR><BR>However, the next examples illustrate the<B> tentative definition</B> of external objects.&nbsp; If no further definition
of the object of a form shown above is found, then the object is found outside of the module.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern LIST * ListEl;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int&nbsp;&nbsp;&nbsp; Z;</TT>
<BR><BR>Another module may define its own object with the same name (provided it has<B> static</B> storage class), but it
will not be able to access the external one.&nbsp; However, this can be confusing and is a questionable programming practice.
<BR><BR>Any value placed in an object declared with the <TT> extern</TT> keyword will remain unchanged until changed by a
function within the same or another module.
<BR><BR>A function that is declared without the keyword <TT> static</TT> has external linkage.
<BR><BR>Suppose a module declares an object (outside of any function definition) as follows:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct list_el * ListTop;</TT>
<BR><BR>where the structure<TT> list_el</TT> is defined elsewhere.&nbsp; This declaration allocates space for and declares
the object<TT> ListTop</TT> to be a pointer to a structure<TT> list_el</TT>, with external linkage.&nbsp; Another module with
the declaration,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern struct list_el * ListTop;</TT>
<BR><BR>refers to the same object<TT> ListTop</TT>, and states that it is found outside of the module.
<BR><BR>Within a program, possibly consisting of more than one module, each object or function with external linkage must
be defined (have space allocated for it) exactly once.
<H2 ID="Automatic_Storage_Duration"> Automatic Storage Duration </H2>
<BR>The most commonly used object in a C program is one that has meaning only within the function in which it is defined.
&nbsp;The object is created when execution of the function is begun and destroyed when execution of the function is completed.
&nbsp;Such an object is said to have<B> automatic storage duration.</B>&nbsp; The<B> scope</B> of the object is said to be
the function in which it is defined.
<BR><BR>If such an object has the same name as another object defined outside the function (using <TT> static</TT> or <TT>
extern</TT>), then the outside object is hidden from the function.
<BR><BR>Within a function, any object that does not have its declaration preceded by the keyword <TT> static</TT> or <TT>
extern</TT> has automatic storage duration.
<BR><BR>It is possible to declare an object as automatic within any block of a function.&nbsp; The<B> scope</B> of such an
object is the block in which it is declared, including any blocks inside it.&nbsp; Any outside block is unable to access such
an object.
<BR><BR>Automatic objects may be initialized as described in the chapter &quot;Initialization of Objects&quot;.&nbsp; Initialization
of the object only occurs when the block in which the object is declared is entered normally.&nbsp; In particular, a jump
into a block nested within the function will<B> not</B> initialize any objects declared in that block.&nbsp; This is a questionable
programming practice, and should be avoided.
<BR><BR>The following function checks a string to see if it contains nothing but digits:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int IsInt( const char * ptr )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /**********************************/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( *ptr == '\0' ) return( 0 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( ;; ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp; ch;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ch = *(ptr++);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( ch == '\0' )&nbsp;&nbsp;&nbsp;&nbsp;
return( 1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( !isdigit( ch ) ) return( 0 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The object<TT> ch</TT> has a scope consisting only of the <TT> for</TT> loop.&nbsp; Any statements before or after
the loop cannot access<TT> ch.</TT>
<H3 ID="The_auto_Storage_Class"> The auto Storage Class </H3>
<BR>The declaration of an object in a function that does not contain the keywords <TT> static</TT>, <TT> extern</TT> or <TT>
register</TT> declares an object with automatic storage duration.&nbsp; Such an object may precede its declaration with the
keyword <TT> auto</TT> for readability.
<BR><BR>An object declared with no storage class specifier or with <TT> auto</TT> is &quot;addressable&quot;, which means
that the<B> address-of</B> operator may be applied to it.
<BR><BR>The programmer should not assume any relationship between the storage locations of multiple <TT> auto</TT> objects
declared in a function.&nbsp; If relative placement of objects is important, a structure should be used.
<BR><BR>The following function illustrates a use for <TT> auto</TT> objects:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int FindSize( struct thing * thingptr )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /********************************************/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto char * start;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto char * finish;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FindEnds( thingptr, &amp;start, &amp;finish );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( finish - start + 1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The addresses of the automatic objects<TT> start</TT> and<TT> finish</TT> are passed to<TT> FindEnds</TT>, which,
presumably, modifies them.
<H3 ID="The_register_Storage_Class"> The register Storage Class </H3>
<BR>An object that is declared within a function, and whose declaration includes the keyword <TT> register</TT>, is considered
to have automatic storage duration.&nbsp; The <TT> register</TT> keyword merely provides a hint to the compiler that this
object is going to be heavily used, allowing the compiler to try to put it into a high-speed access part of the machine, such
as a machine register.&nbsp; The compiler may, however, ignore such a directive for any number of reasons, such as,
<UL>
<LI>the compiler does not support objects in registers,
<LI>there are no available registers, or,
<LI>the compiler makes its own decisions about register usage.
</UL>
<BR>Only certain types of objects may be placed in registers, although the set of such types is implementation-defined.
<BR><BR><B>&nbsp; The Open Watcom C/16 and C/32 compilers may place any object that is sufficiently small, including a small
structure, in one or more registers.</B>
<BR><BR><B>&nbsp; The compiler will decide which objects will be placed in registers.&nbsp; The </B><TT> register</TT><B>
keyword is ignored, except to prevent taking the address of such an object.</B>
<BR><BR>Objects declared with or without <TT> register</TT> may generally be treated in the same way.&nbsp; An exception to
this rule is that the <B> address-of</B> operator<TT> (&amp;)</TT> may not be applied to a <TT> register</TT> object, since
registers are generally not within the normal storage of the computer.
<H1 ID="Initialization_of_Objects"> Initialization of Objects </H1>
<BR>Any definition of an object may include a value or list of values for initializing it, in which case the declaration is
followed by an equal sign (<TT>=</TT>) and the initial value(s).
<BR><BR>The initial value for an object with static storage duration may be any expression that evaluates to a constant value,
including using the<B> address-of</B> operator to take the address of a function or object with static storage duration.
<BR><BR>The initial value for an object with automatic storage duration may be any expression that would be valid as an assignment
to that object, including references to other objects.&nbsp; The evaluations of the initializations occur in the order in
which the definitions of the objects occur.
<H2 ID="Initialization_of_Scalar_Types"> Initialization of Scalar Types </H2>
<BR>The initial value for a scalar type (pointers, integers and floating-point types) may be enclosed in braces, although
braces are not required.
<BR><BR>The following declarations might appear inside a function:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static&nbsp;&nbsp; int&nbsp;&nbsp; MaxRecLen&nbsp; = 1000;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static&nbsp;&nbsp; int&nbsp;&nbsp; MaxMemSize = { 1000 * 8 + 10000 };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float Pi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; = 3.14159;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; auto&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; = 3;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; register int&nbsp;&nbsp; y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = x * MaxRecLen;</TT>
<H2 ID="Initialization_of_Arrays"> Initialization of Arrays </H2>
<BR>For arrays of characters being initialized with a string literal, and for arrays of <TT> wchar_t</TT> being initialized
with a wide string literal, the braces around initial values are optional.&nbsp; For other arrays, the braces are required.
<BR><BR>If an array of unknown size is initialized, then the size of the array is determined by the number of initializing
values provided.&nbsp; In particular, an array of characters of unknown size may be initialized using a string literal, in
which case the size of the array is the number of characters in the string, plus one for the terminating null character.&nbsp;
Each character of the string is placed in successive elements of the array.&nbsp; Consider the following array declarations:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp; StartPt[] = &quot;Starting point...&quot;;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; Tabs[]&nbsp;&nbsp;&nbsp; = { 1, 9, 17, 25, 33, 41 };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; float Roots[]&nbsp;&nbsp; = { 1., 1.414, 1.732, 2., 2.236 };</TT>
<BR><BR>The object<TT> StartPt</TT> is an array of 18 characters,<TT> Tabs</TT> is an array of 6 integers, and<TT> Roots</TT>
is an array of 5 floating-point numbers.
<BR><BR>If an array is declared to have a certain number of elements, then the maximum number of values in the initialization
list is the number of elements in the array.&nbsp; An exception is made for arrays of characters, where the initializer may
be a string with the same length as the number of characters in the array.&nbsp; Each character from the string is assigned
to the corresponding element of the array.&nbsp; The null character at the end of the string literal is ignored.
<BR><BR>If there are fewer initialization values than elements of the array, then any elements not receiving a value from
the list are assigned the value zero (for arithmetic types), or the null pointer constant (for pointers).&nbsp; Consider the
following examples:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp; Vowels1[6]&nbsp; = &quot;aeiouy&quot;;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp; Vowels2[6]&nbsp; = { 'a', 'e', 'i', 'o', 'u', 'y' };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; Numbers[10] = { 100, 10, 1 };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; float Blort[5]&nbsp;&nbsp;&nbsp; = { 5.6, -2.2 };</TT>
<BR><BR>The objects<TT> Vowels1</TT> and<TT> Vowels2</TT> are both arrays of six characters, and both contain exactly the
same values in each of their corresponding elements.&nbsp; The object<TT> Numbers</TT> is an array of 10 integers, the first
three of which are initialized to<TT> 100</TT>,<TT> 10</TT> and<TT> 1</TT>, and the remaining seven are set to zero.&nbsp;
The object<TT> Blort</TT> is an array of 5 floating-point numbers.&nbsp; The first two elements are initialized to<TT> 5.6</TT>
and<TT> -2.2</TT>, and the remaining three are set to zero.
<BR><BR>If an array of more than one dimension is initialized, then each subarray may be initialized using a brace-enclosed
list of values.&nbsp; This form will work for an arbitrary number of dimensions.&nbsp; Consider the following two-dimensional
case:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int Box[3][4] = { { 11, 12, 13, 14 },</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; { 21, 22, 23, 24 },</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; { 31, 32, 33, 34 } };</TT>
<BR><BR>The object<TT> Box</TT> is an array of 3 arrays of 4 integers.&nbsp; There are three values in the initialization
list, corresponding to the first dimension (3 rows).&nbsp; Each initialization value is itself a list of values corresponding
to the second dimension (4 columns).&nbsp; In other words, the first list of values<TT> { 11, 12, 13, 14 }</TT> is assigned
to the first row of<TT> Box</TT>, the second list of values<TT> { 21, 22, 23, 24 }</TT> is assigned to the second row of<TT>
Box</TT>, and the third list of values<TT> { 31, 32, 33, 34 }</TT> is assigned to the third row of<TT> Box.</TT>
<BR><BR>If all values are supplied for initializing an array, or if only elements from the end of the array are omitted, then
the sub-levels need not be within braces.&nbsp; For example, the following declaration of<TT> Box</TT> is the same as above:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int Box[3][4] = { 11, 12, 13, 14,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; 21, 22, 23, 24,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; 31, 32, 33, 34 };</TT>
<BR><BR>The same rules about incomplete initialization lists apply to multi-dimensional arrays.&nbsp; The following example
defines a mathematical 3-by-3 identity matrix:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int Identity[3][3] = { { 1 },</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { 0, 1 },</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { 0, 0, 1 } };</TT>
<BR><BR>The missing values are replaced with zeroes.&nbsp; The initialization also could have been given as,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int Identity[3][3] = { { 1, 0, 0 },</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { 0, 1, 0 },</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { 0, 0, 1 } };</TT>
<BR><BR>or as,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int Identity[3][3] = { 1, 0, 0,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, 1, 0,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, 0, 1 };</TT>
<H2 ID="Initialization_of_Structures"> Initialization of Structures </H2>
<BR>Structures may be initialized in a manner similar to arrays.&nbsp; The initializer list must be specified within braces.
<BR><BR>For example,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct printformat {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; pagewid;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; carr_ctl;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *&nbsp; buffer;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char PrBuffer[256];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct printformat PrtFmt = { 80, ' ', PrBuffer };</TT>
<BR><BR>Each value from the initializer list is assigned to each successive member of the structure.&nbsp; Any unnamed gaps
between members or at the end of the structure (caused by alignment) are ignored during initialization.&nbsp; If there are
more members of the structure than values specified by the initializer list, then the remaining members are initialized to
zero (for arithmetic types) or the null pointer constant (for pointers).
<BR><BR>If a structure member is itself an array, structure or union, then the sub-members may be initialized using a brace-enclosed
initializer list.&nbsp; If braces are not specified, then for the purposes of initialization, the sub-members are treated
as if they are members of the outer structure, as each subsequent initializer value initializes a sub-member, until no more
sub-members are found, in which case the next member of the outer structure is initialized.
<H2 ID="Initialization_of_Unions"> Initialization of Unions </H2>
<BR>Initializations of unions is the same as for structures, except that only the first member of the union may be initialized,
using a brace-enclosed initializer.
<BR><BR>Consider the following example:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct first3 {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char first, second, third;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; union ustr {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
string[20];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct first3&nbsp; firstthree;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; union ustr Str = { &quot;Hello there&quot; };</TT>
<BR><BR>The object<TT> Str</TT> is declared to be a union of two types, the first of which is an array of 20 characters, and
the second of which is a structure that allows direct access to the first three characters of the string contained in the
array.&nbsp; The array is initialized to the string<TT> &quot;Hello there&quot;.</TT>&nbsp; The three characters of<TT> struct
first3</TT> will have the characters<TT> 'H', 'e'</TT> and<TT> 'l'.</TT>&nbsp; Had the declaration of<TT> ustr</TT> been,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; union ustr {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct first3&nbsp; firstthree;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
string[20];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR>then the initialization could only set the first three characters.
<H2 ID="Uninitialized_Objects"> Uninitialized Objects </H2>
<BR>An object with<B> static</B> storage duration, and no explicit initialization, will be initialized as if every member
that has arithmetic type was assigned zero and every member that has a pointer type was assigned a null (zero) pointer.
<BR><BR>An object with<B> automatic</B> storage duration, and no explicit initialization, is not initialized.&nbsp; Hence,
a reference to such an automatic object that has not been assigned a value will yield undefined behavior.&nbsp; On most systems,
the value of the object will be arbitrary and unpredictable.
<H1 ID="Expressions"> Expressions </H1>
<BR>An<B> expression</B> is a sequence of operators and operands that describes how to,
<UL>
<LI>calculate a value (eg.&nbsp; addition)
<LI>create side-effects (eg.&nbsp; assignment, increment)
</UL>
<BR>or both.
<BR><BR>The order of execution of the expression is usually determined by a mixture of,
<OL>
<LI>parentheses<TT> ()</TT>, which indicate to the compiler the desired grouping of operations,
<LI>the precedence of operators, which describes the relative priority of operators in the absence of parentheses,
<LI>the common algebraic ordering,
<LI>the associativity of operators.&nbsp; 
</OL>
<BR>In most other cases, the order of execution is determined by the compiler and may not be relied upon.&nbsp; Exceptions
to this rule are described in the relevant section.&nbsp; Most users will find that the order of execution is well-defined
and intuitive.&nbsp; However, when in doubt, use parentheses.
<BR><BR>The table below summarizes the levels of precedence in expressions.&nbsp; 
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Expression Type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Operators</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ----------------------&nbsp; ------------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; primary&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; identifier</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; constant</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (expression)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ----------------------&nbsp; ------------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; postfix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; a[b]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a.b&nbsp;&nbsp;&nbsp;&nbsp; a-&gt;b</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a++&nbsp;&nbsp;&nbsp;&nbsp; a--</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ----------------------&nbsp; ------------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unary&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; sizeof u&nbsp;&nbsp; sizeof( a )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++a&nbsp;&nbsp;&nbsp;&nbsp; --a</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *a</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~a&nbsp;
&nbsp;&nbsp;&nbsp; !a</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ----------------------&nbsp; ------------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; cast&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; (type) a</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ----------------------&nbsp; ------------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; multiplicative&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a * b&nbsp;&nbsp; a
/ b&nbsp;&nbsp; a % b</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ----------------------&nbsp; ------------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; additive&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;a + b&nbsp;&nbsp; a - b</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ----------------------&nbsp; ------------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; shift&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; a &lt;&lt; b&nbsp; a &gt;&gt; b</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ----------------------&nbsp; ------------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; relational&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
a &lt; b&nbsp;&nbsp; a &gt; b&nbsp;&nbsp; a &lt;= b&nbsp; a &gt;= b</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ----------------------&nbsp; ------------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; equality&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;a == b&nbsp; a != b</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ----------------------&nbsp; ------------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; bitwise AND&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a &amp;
b</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ----------------------&nbsp; ------------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; bitwise exclusive OR&nbsp;&nbsp;&nbsp; a ^ b</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ----------------------&nbsp; ------------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; bitwise inclusive OR&nbsp;&nbsp;&nbsp; a | b</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ----------------------&nbsp; ------------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; logical AND&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a &amp;&amp;
b</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ----------------------&nbsp; ------------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; logical OR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
a || b</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ----------------------&nbsp; ------------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; conditional (*)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a ? b : c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ----------------------&nbsp; ------------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; assignment (*)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a = b</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a += b&nbsp;&nbsp;&nbsp;&nbsp; a -= b</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a *= b&nbsp;&nbsp;&nbsp;&nbsp; a /= b&nbsp;&nbsp;&nbsp;&nbsp; a %= b</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a &amp;= b&nbsp;&nbsp;&nbsp;&nbsp; a ^= b&nbsp;&nbsp;&nbsp;&nbsp; a |= b</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a &lt;&lt;= b&nbsp;&nbsp;&nbsp; a &gt;&gt;= b</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ----------------------&nbsp; ------------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; comma&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; a,b</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ----------------------&nbsp; ------------------------------</TT>
<BR><BR>(*) associates from right to left
<BR><BR>Operations at a higher level in the table will occur before those below.&nbsp; All operators involving more than one
operand associate from left to right, except for the conditional and assignment operators, which associate from right to left.
&nbsp;Operations at the same level, except where discussed in the relevant section, may be executed in any order that the
compiler chooses (subject to the usual algebraic rules).&nbsp; In particular, the compiler may regroup sub-expressions that
are both associative and commutative in order to improve the efficiency of the code, provided the meaning (i.e.&nbsp; types
and results) of the operands and result are not affected by the regrouping.
<BR><BR>The order of any side-effects (for example, assignment, or action taken by a function call) is also subject to alteration
by the compiler.
<BR><BR>An<B> exception</B> occurs when the operands for an operator are invalid.&nbsp; For example, division by zero may
cause an exception.&nbsp; If an exception occurs, the behavior is undefined.&nbsp; If an exception is a possibility, the program
should be prepared to handle it.
<BR><BR>In the following sections, a formal syntax is used to describe each level in the precedence table.&nbsp; This syntax
is used in order to completely describe the relationships between the various levels.
<H2 ID="Lvalues"> Lvalues </H2>
<BR>In order to understand certain components of expressions, it is important to understand the term <B> lvalue</B>.
<BR><BR>An<B> lvalue</B> is an expression that designates an object.&nbsp; The simplest form of<B> lvalue</B> is an identifier
which is an object (for example, an integer).
<BR><BR>The type of the expression may not be <TT> void</TT> or a function.&nbsp; The term<B> lvalue</B> is derived from<B>
l</B>eft<B> value,</B> which refers to the fact that an<B> lvalue</B> is typically on the left side of an assignment expression.
<BR><BR>If<TT> ptr</TT> is a pointer to a type other than <TT> void</TT> or a function, then both<TT> ptr</TT> and<TT> *ptr</TT>
are<B> lvalues.</B>
<BR><BR>A <B> modifiable lvalue</B> is an<B> lvalue</B> whose type is not an array or an incomplete type, whose declaration
does not contain the keyword <TT> const</TT>, and, if it is a structure or union, then none of its members contains the keyword
<TT> const</TT>.
<H2 ID="Primary_Expressions"> Primary Expressions </H2>
<BR><B>&nbsp; primary-expression:</B>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; identifier</B>
<BR><B>&nbsp;&nbsp; or</B>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; constant</B>
<BR><B>&nbsp;&nbsp; or</B>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string-literal</B>
<BR><B>&nbsp;&nbsp; or</B>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </B>(<B> expression </B>)
<BR><BR>A<B> primary expression</B> is the simplest part of an expression.&nbsp; It consists of one of the following:
<DL>
<DT>identifier
<DD>An identifier that designates a function is called a <B> function designator.</B>&nbsp; An identifier that designates an object
is an <B> lvalue.</B>
<DT>constant
<DD>A constant is a primary expression whose type depends on its form.&nbsp; See &quot;Constants&quot;.
<DT>string-literal
<DD>A string literal is a primary expression whose type is &quot;array of <TT> char</TT>&quot;.&nbsp; A string literal is also
an<B> lvalue</B> (but is not modifiable).
<DT>expression inside parentheses
<DD>The type and value of a parenthesized expression are the same as for the expression without parentheses.&nbsp; It may be an<B>
lvalue,</B> function designator or void expression.
</DL>
<BR>Given these declarations,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; count;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int *&nbsp;&nbsp; ctrptr;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; f( int );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; g( int );</TT>
<BR><BR>the following are all valid primary expressions:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; count</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 3</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 3.2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 'a'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &quot;Hello there&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; (count + 3)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; (*(ctrptr+1))</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; (f( ++i ) * g( j++ ))</TT>
<H2 ID="Postfix_Operators"> Postfix Operators </H2>
<BR><B>&nbsp; postfix-expression:</B>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; primary-expression</B>
<BR><B>&nbsp;&nbsp; or</B>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; array-subscripting-expression</B>
<BR><B>&nbsp;&nbsp; or</B>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; function-call-expression</B>
<BR><B>&nbsp;&nbsp; or</B>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; member-designator-expression</B>
<BR><B>&nbsp;&nbsp; or</B>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; post-increment-expression</B>
<BR><B>&nbsp;&nbsp; or</B>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; post-decrement-expression</B>
<H3 ID="Array_Subscripting"> Array Subscripting </H3>
<BR><B>&nbsp; array-subscripting-expression:</B>
<BR><B>&nbsp;&nbsp;&nbsp; postfix-expression</B><TT>[</TT><B>expression</B><TT>]</TT>
<BR><BR>The general form for array subscripting is,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; array[index]</TT>
<BR><BR>where<TT> array</TT> must have the type &quot;array of<B> type</B>&quot; or &quot;pointer to<B> type</B>&quot;, and<TT>
index</TT> must have an integral type.&nbsp; The result has type &quot;<B>type</B>&quot;.
<BR><BR><TT>array[index]</TT> is equivalent to<TT> (*(array+index))</TT>, or the<TT> index</TT>-th element of the array<TT>
array</TT>, where the first element is numbered zero.&nbsp; Note that<TT> index</TT> is scaled automatically to account for
the size of the elements of<TT> array.</TT>
<BR><BR>An alternate form for array subscripting is,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; index[array]</TT>
<BR><BR>although this form is not commonly used.
<H3 ID="Function_Calls"> Function Calls </H3>
<BR><B>&nbsp; function-call-expression:</B>
<BR><B>&nbsp;&nbsp;&nbsp; postfix-expression</B><TT>()</TT>
<BR><B>&nbsp; or</B>
<BR><B>&nbsp; postfix-expression</B><TT> (</TT><B>argument-expression-list</B><TT>)</TT>
<BR><BR><B>&nbsp; argument-expression-list:</B>
<BR>&nbsp;&nbsp;&nbsp; one or more<B> assignment-expression</B>s separated by commas
<BR><BR>A<B> postfix-expression</B> followed by parentheses containing zero or more comma-separated expressions is a<B> function-call-expression</B>.
&nbsp;The postfix-expression denotes the function to be called, and must evaluate to a pointer to a function.&nbsp; The simplest
form of this expression is an identifier which is the name of a function.&nbsp; For example,<TT> Fn()</TT> calls the function<TT>
Fn.</TT>
<BR><BR>The expressions within the parentheses denote the arguments to the function.&nbsp; If a function prototype has been
declared, then the number of arguments must match the parameter list in the prototype, and the arguments are converted to
the types specified in the prototype.
<BR><BR>If the postfix-expression is simply an identifier, and no function prototype declaration for that identifier is in
scope, then an implicit,
<BR><BR><TT>&nbsp; extern int</TT><B> identifier</B><TT>();</TT>
<BR><BR>declaration is placed in the innermost block containing the function call.&nbsp; This declares the function as having
external linkage, no information about its parameters is available, and the function returns an integer.
<BR><BR>The expressions are evaluated (in an undefined order) and the values assigned to the parameters for the function.
&nbsp;All arguments are passed by value, allowing the function to modify its parameters without affecting the arguments used
to create the parameters.&nbsp; However, an argument can be a pointer to an object, in which case the function may modify
the object to which the pointer points.
<BR><BR>If a function prototype is in scope at both a call to a function and its definition (and if the prototypes are the
same), then the compiler will ensure that the required number and type of parameters are present.
<BR><BR>If no function prototype is in scope at a call to a function, then the<B> default argument promotions</B> are performed.
&nbsp;(Integral types such as <TT> char</TT> and <TT> short int</TT> are converted to <TT> int</TT>, while <TT> float</TT>
values are converted to <TT> double</TT>.) When the function definition is encountered, if the parameter types do not match
the default argument promotions, then the behavior is undefined.&nbsp; (Usually, the parameters to the function will receive
incorrect values.)
<BR><BR>If a function prototype has been declared at a call to a function, then each argument is converted, as if by assignment,
to the type of the corresponding parameter.&nbsp; When the function definition is encountered, if the types of the parameters
do not match the types of the parameters in the function prototype, the behavior is undefined.
<BR><BR>If the ellipsis (<TT>,...</TT>) notation is used in a function prototype, then those arguments in a function call
that correspond to the ellipsis have only the default argument promotions performed on them.&nbsp; (See the chapter &quot;Functions&quot;
for a complete description of the ellipsis notation.)
<BR><BR>Function calls may be recursive.&nbsp; Functions may call themselves either directly, or via other functions.
<BR><BR>The following are some examples of function calls:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; putchar( 'x' );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; chr = getchar();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; valid = isdigit( chr );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;chr = %c, valid = %2x\n&quot;, chr, valid );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; fnptr = &amp;MyFunction;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; (*fnptr)( parm1, parm2 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; fnptr( parm1, parm2 );</TT>
<H3 ID="Structure_and_Union_Members"> Structure and Union Members </H3>
<BR><B>&nbsp; member-designator-expression:</B>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; postfix-expression . identifier</B>
<BR><B>&nbsp;&nbsp; or</B>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; postfix-expression</B><TT>-&gt;</TT><B>identifier</B>
<BR><BR>The first operand of the .&nbsp; operator must be an object with a structure or union type.&nbsp; The second operand
must be the name of a member of that type.&nbsp; The result is the value of the member, and is an lvalue if the first operand
is also an lvalue.
<BR><BR>The first operand of the<TT> -&gt;</TT> operator must be a pointer to an object with a structure or union type.&nbsp;
The second operand must be the name of a member of that type.&nbsp; The result is the value of the member of the structure
or union to which the first expression points, and is an lvalue.
<H3 ID="PostMIncrement_and_PostMDecrement"> Post-Increment and Post-Decrement </H3>
<BR><B>&nbsp; post-increment-expression:</B>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; postfix-expression</B><TT>++</TT>
<BR><BR><B>&nbsp; post-decrement-expression:</B>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; postfix-expression</B><TT>--</TT>
<BR><BR>The operand of post-increment and post-decrement must be a modifiable lvalue, and a scalar (not a structure, union
or array).
<BR><BR>The effect of the operation is that the operand is incremented or decremented by 1, adjusted for the type of the operand.
&nbsp;For example, if the operand is declared to be a &quot;pointer to<B> type</B>&quot;, then the increment or decrement
will be by the value<TT> sizeof(</TT><B> type</B><TT> )</TT>.
<BR><BR>The result of both post-increment and post-decrement (if it is just a subexpression of a larger expression) is the
original, unmodified value of the operand.&nbsp; In other words, the original value of the operand is used in the expression,
and then it is incremented or decremented.&nbsp; Whether the operand is incremented immediately after use or after completion
of execution of the expression is undefined.&nbsp; Consider the statements,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int i = 2;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int j;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; j = (i++) + (i++);</TT>
<BR><BR>Depending on the compiler,<TT> j</TT> may get the value 4 or 5.&nbsp; If the increments are delayed until after the
expression is evaluated,<TT> j</TT> gets the value<TT> 2 + 2.</TT>&nbsp; If the increment of<TT> i</TT> happens immediately
after its value is retrieved, then<TT> j</TT> gets the value<TT> 2 + 3.</TT>
<BR><BR>To avoid ambiguity, the above expression could be written as:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; j = i + i;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; i += 2;</TT>
<H2 ID="Unary_Operators"> Unary Operators </H2>
<BR><B>&nbsp; unary-expression:</B>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; postfix-expression</B>
<BR><B>&nbsp;&nbsp; or</B>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pre-increment-expression</B>
<BR><B>&nbsp;&nbsp; or</B>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pre-decrement-expression</B>
<BR><B>&nbsp;&nbsp; or</B>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unary-operator cast-expression</B>
<BR><B>&nbsp;&nbsp; or</B>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sizeof-expression</B>
<BR><BR><B>&nbsp; unary-operator:</B>&nbsp; one of
<BR><TT>&nbsp; &amp; * + - ~ !</TT>
<H3 ID="PreMIncrement_and_PreMDecrement_Operators"> Pre-Increment and Pre-Decrement Operators </H3>
<BR><B>&nbsp; pre-increment-expression:</B>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </B><TT>++</TT><B> unary-expression</B>
<BR><BR><B>&nbsp; pre-decrement-expression:</B>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </B><TT>--</TT><B> unary-expression</B>
<BR><BR>The operand of the pre-increment and pre-decrement operators must be a modifiable lvalue, and a scalar (not a structure,
union or array).
<BR><BR>The operand is incremented or decremented by 1, adjusted for the type of the operand.&nbsp; For example, if the operand
is declared to be a &quot;pointer to<B> type</B>&quot;, then the increment or decrement will be by the value<TT> sizeof(</TT><B>
type</B><TT> ).</TT>
<BR><BR>The expression<TT> ++obj</TT> is equivalent to<TT> (obj += 1)</TT>, while<TT> --obj</TT> is equivalent to<TT> (obj
-= 1).</TT>
<H3 ID="AddressMof_and_Indirection_Operators"> Address-of and Indirection Operators </H3>
<BR><B>&nbsp; unary-expression:</B>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </B><TT>&amp;</TT><B> cast-expression</B>
<BR><B>&nbsp;&nbsp; or</B>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </B><TT>*</TT><B> cast-expression</B>
<BR><BR>The unary<TT> &amp;</TT> symbol denotes the <B> address-of</B> operator.&nbsp; Its operand must designate a function
or an array, or be an lvalue that designates an object that is not a bit-field and is not declared with the <TT> register</TT>
storage-class specifier.&nbsp; If the type of the operand is &quot;<B>type</B>&quot;, then the type of the result is &quot;pointer
to<B> type</B>&quot; and the result is the address of the operand.
<BR><BR>If the type of the operand is &quot;array of<B> type</B>&quot;, then the type of the result is &quot;pointer to<B>
type</B>&quot; and the result is the address of the first element of the array.
<BR><BR>The<TT> *</TT> symbol, in its unary form, denotes the <B> indirection</B> or <B> pointer</B> operator.&nbsp; Its operand
must be a pointer type, except that it may not be a pointer to <TT> void</TT>.&nbsp; If the operand is a &quot;pointer to<B>
type</B>&quot;, then the type of the result is &quot;<B>type</B>&quot;, and the result is the object to which the operand
points.
<BR><BR>No checking is performed to ensure that the value of the pointer is valid.&nbsp; If an invalid pointer value is used,
the behavior of<TT> *</TT> is undefined.
<BR><BR>Examples:
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; counter;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int * ctrptr;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void&nbsp; (*fnptr)( int, int * );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ctrptr&nbsp; = &amp;counter;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; *ctrptr = 3;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; fnptr = FnRetVoid;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; fnptr( *ctrptr, &amp;counter );</TT>
<H3 ID="Unary_Arithmetic_Operators"> Unary Arithmetic Operators </H3>
<BR><B>&nbsp; unary-expression:</B>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </B><TT>+</TT><B> cast-expression</B>
<BR><B>&nbsp;&nbsp; or</B>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </B><TT>-</TT><B> cast-expression</B>
<BR><B>&nbsp;&nbsp; or</B>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </B><TT>~</TT><B> cast-expression</B>
<BR><B>&nbsp;&nbsp; or</B>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </B><TT>!</TT><B> cast-expression</B>
<BR><BR>The<TT> +</TT> symbol, in its unary form, simply returns the value of its operand.&nbsp; The type of its operand must
be an arithmetic type (character, integer or floating-point).&nbsp; Integral promotion is performed on the operand, and the
result has the promoted type.
<BR><BR>The<TT> -</TT> symbol, in its unary form, is the<B> negation</B> or <B> negative</B> operator.&nbsp; The type of its
operand must be an arithmetic type (character, integer or floating-point).&nbsp; The result is the negative of the operand.
&nbsp;Integral promotion is performed on the operand, and the result has the promoted type.&nbsp; The expression<TT> -obj</TT>
is equivalent to<TT> (0-obj).</TT>
<BR><BR>The<TT> ~</TT> symbol is the <B> bitwise complement, 1's complement</B> or<B> bitwise not</B> operator.&nbsp; The
type of the operand must be an integral type, and integral promotion is performed on the operand.&nbsp; The type of the result
is the type of the promoted operand.&nbsp; Each bit of the result is the complement of the corresponding bit in the operand,
effectively turning 0 bits to 1, and 1 bits to 0.
<BR><BR>The<TT> !</TT>&nbsp; symbol is the <B> logical not</B> operator.&nbsp; Its operand must be a scalar type (not a structure,
union or array).&nbsp; The result type is <TT> int</TT>.&nbsp; If the operand has the value zero, then the result value is
1.&nbsp; If the operand has some other value, then the result is 0.
<H3 ID="The_sizeof_Operator"> The sizeof Operator </H3>
<BR><B>&nbsp; sizeof-expression:</B>
<BR><TT>&nbsp;&nbsp;&nbsp; sizeof</TT><B> unary-expression</B>
<BR><B>&nbsp; or</B>
<BR><TT>&nbsp; sizeof(</TT><B> type-name</B><TT> )</TT>
<BR><BR>The <TT> sizeof</TT> operator gives the size (in bytes) of its operand.&nbsp; The operand may be an expression, or
a type in parentheses.&nbsp; In either case, the type must not be a function, bit-field or incomplete type (such as <TT> void</TT>,
or an array that has not had its length declared).
<BR><BR>Note that an expression operand to <TT> sizeof</TT> is not evaluated.&nbsp; The expression is examined to determine
the result type, from which the size is determined.
<BR><BR>If the operand has a character type, then the result is 1.
<BR><BR>If the type is a structure or union, then the result is the total number of bytes in the structure or union, including
any internal or trailing padding included by the compiler for alignment purposes.&nbsp; The size of a structure can be greater
than the sum of the sizes of its members.
<BR><BR>If the type is an array, then the result is the total number of bytes in the array, unless the operand is a parameter
in the function definition enclosing the current block, in which case the result is the size of a pointer.
<BR><BR>The type of the result of the <TT> sizeof</TT> operator is implementation-defined, but it is an unsigned integer type,
and is represented by <TT> size_t</TT> in the <TT> &lt;stddef.h&gt;</TT> header.
<BR><BR><B>&nbsp; For the Open Watcom C/16 and C/32 compilers, the macro </B><TT> size_t</TT><B> is </B><TT> unsigned int</TT><B>.</B>
<BR><BR>Example:
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct s {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct s * next;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; obj1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; obj2;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static struct s * SAllocAndFill( const struct s * def_s )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /*******************************************************/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct s * sptr;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sptr = malloc( sizeof( struct s ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( sptr != NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memcpy( sptr, def_s, sizeof( struct s ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( sptr );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The function<TT> SAllocAndFill</TT> receives a pointer to a<TT> struct s.</TT>&nbsp; It allocates such a structure,
and copies the contents of the structure pointed to by<TT> def_s</TT> into the allocated memory.&nbsp; A pointer to the allocated
structure is returned.
<BR><BR>The library function <TT> malloc</TT> takes the number of bytes to allocate as a parameter and<TT> sizeof( struct
s )</TT> provides that value.&nbsp; The library function <TT> memcpy</TT> also takes, as the third parameter, the number of
bytes to copy and again<TT> sizeof( struct s )</TT> provides that value.
<H2 ID="Cast_Operator"> Cast Operator </H2>
<BR><B>&nbsp; cast-expression:</B>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unary-expression</B>
<BR><B>&nbsp;&nbsp; or</B>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </B>(<B> type-name </B>)<B> cast-expression</B>
<BR><BR>When an expression is preceded by a type name in parentheses, the value of the expression is converted to the named
type.&nbsp; This is called a <B> cast.</B>&nbsp; Both the type name and the operand type must be scalar (not a structure,
union or array), unless the type name is <TT> void</TT>.&nbsp; If the type name is <TT> void</TT>, the operand type must be
a complete type (not an array of unknown size, or a structure or union that has not yet been defined).
<BR><BR>A cast does not yield an lvalue.
<BR><BR>Pointers may be freely converted from &quot;pointer to <TT> void</TT>&quot; to any other pointer type without using
an explicit cast operator.&nbsp; Pointers also may be converted from any pointer type to &quot;pointer to <TT> void</TT>&quot;.
<BR><BR>A pointer may be converted to a pointer to another type.&nbsp; However, the pointer may be invalid if the resulting
pointer is not properly aligned for the type.&nbsp; Converting a pointer to a pointer to a type with less strict alignment,
and back again, will yield the same pointer.&nbsp; However, converting it to a pointer to a type with more strict alignment,
and back again, may yield a different pointer.&nbsp; On many computers, where alignment is not required (but may improve performance),
conversion of pointers may take place freely.
<BR><BR><B>&nbsp; With Open Watcom C/16 and C/32, alignment of integers, pointers and floating-point numbers is not required,
so the compiler does not do any alignment.&nbsp; However, aligning these types may make a program run slightly faster.</B>
<BR><BR><B>&nbsp; A command line switch may be used to force the compiler to do alignment on all structures.</B>
<BR><BR>A pointer to a function may be converted to a pointer to a different type of function, and back again.&nbsp; The resulting
pointer will be the same as the original pointer.
<BR><BR>If a pointer is converted to a pointer to a different type of function, and a call is made using that pointer, the
behavior is undefined.
<BR><BR>A pointer may be converted to an integral type.&nbsp; The type of integer required to hold the value of the pointer
is implementation-defined.&nbsp; If the integer is not large enough to fully contain the value, then the behavior is undefined.
<BR><BR>An integer may be converted to a pointer.&nbsp; The result is implementation-defined.
<BR><BR><B>&nbsp; With Open Watcom C/16, for the purposes of conversion between pointers and integers, </B><TT> __near</TT><B>
pointers are treated as </B><TT> unsigned int</TT><B>.&nbsp; </B><TT> __far</TT><B> and </B><TT> __huge</TT><B> pointers are
treated as </B><TT> unsigned long int</TT><B>, with the pointer's segment value in the high-order (most significant) two bytes.
&nbsp;All the usual integer conversion rules then apply.&nbsp; Note that huge pointers are not normalized in any way.</B>
<BR><BR><B>&nbsp; With Open Watcom C/32, for the purposes of conversion between pointers and integers, </B><TT> __near</TT><B>
pointers are treated as </B><TT> unsigned int</TT><B>.&nbsp; </B><TT> __far16</TT><B> and </B><TT> _Seg16</TT><B> pointers
are also treated as </B><TT> unsigned int</TT><B>, with the pointer's segment value in the high-order (most significant) two
bytes.&nbsp; All the usual integer conversion rules then apply.&nbsp; Note that </B><TT> __far</TT><B> pointers may not be
converted to an integer without losing the segment information.</B>
<H2 ID="Multiplicative_Operators"> Multiplicative Operators </H2>
<BR><B>&nbsp; multiplicative-expression:</B>
<BR><B>&nbsp;&nbsp;&nbsp; cast-expression</B>
<BR><B>&nbsp; or</B>
<BR><B>&nbsp; multiplicative-expression</B><TT> *</TT><B> cast-expression</B>
<BR><B>&nbsp; or</B>
<BR><B>&nbsp; multiplicative-expression</B><TT> /</TT><B> cast-expression</B>
<BR><B>&nbsp; or</B>
<BR><B>&nbsp; multiplicative-expression</B><TT> %</TT><B> cast-expression</B>
<BR><BR>The<TT> *</TT> symbol, in its binary form, yields the <B> product</B> of its operands.&nbsp; The operands must have
arithmetic type, and have the usual arithmetic conversions performed on them.
<BR><BR>The<TT> /</TT> symbol yields the <B> quotient</B> from the division of the first operand by the second operand.&nbsp;
The operands must have arithmetic type, and have the usual arithmetic conversions performed on them.&nbsp; Note that when
a division by zero occurs, the behavior is undefined.
<BR><BR>When both operands of / are of integer type and positive value, and the division is inexact, the result is the largest
integer less than the algebraic (exact) quotient.&nbsp; (The result is rounded down.)
<BR><BR>When one or both operands of / is negative and the division is inexact, whether the compiler rounds the value up or
down is implementation-defined.
<BR><BR><B>&nbsp; The Open Watcom C/16 and C/32 compilers always round the result of integer division toward zero.&nbsp; This
action is also called truncation.</B>
<BR><BR>The<TT> %</TT> symbol yields the <B> remainder</B> from the division of the first operand by the second operand.&nbsp;
The operands of<TT> %</TT> must have integral type.
<BR><BR>When both operands of<TT> %</TT> are positive, the result is a positive value smaller than the second operand.&nbsp;
When one or both operands is negative, whether the result is positive or negative is implementation-defined.
<BR><BR><B>&nbsp; With the Open Watcom C/16 and C/32 compiler, the remainder has the same sign as the first operand.</B>
<BR><BR>For integral types<TT> a</TT> and<TT> b</TT>, if<TT> b</TT> is not zero, then<TT> (a/b)*b + a%b</TT> will equal<TT>
a</TT>.
<H2 ID="Additive_Operators"> Additive Operators </H2>
<BR><B>&nbsp; additive-expression:</B>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; multiplicative-expression</B>
<BR><B>&nbsp;&nbsp; or</B>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; additive-expression </B><TT>+</TT><B> multiplicative-expression</B>
<BR><B>&nbsp;&nbsp; or</B>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; additive-expression </B><TT>-</TT><B> multiplicative-expression</B>
<BR><BR>The<TT> +</TT> symbol, in its binary form, denotes the <B> sum</B> of its operands.
<BR><BR>If both operands have arithmetic type, then the usual arithmetic conversions are performed on them.
<BR><BR>If one of the operands is a pointer, then the other operand must have an integral type.&nbsp; The pointer operand
may not be a pointer to <TT> void</TT>.&nbsp; Before being added to the pointer value, the integral value is multiplied by
the size of the object to which the pointer points.&nbsp; The result type is the same as the pointer operand type.&nbsp; If
the pointer value is a pointer to a member of an array, then the resulting pointer will point to a member of the same array,
provided the array is large enough.&nbsp; If the resulting pointer does not point to a member of the array, then its use with
the unary<TT> *</TT> (indirection) or<TT> -&gt;</TT> (arrow) operator will yield undefined behavior.
<BR><BR>The<TT> -</TT> symbol, in its binary form, denotes the <B> difference</B> resulting from the subtraction of the second
operand from the first.&nbsp; If both operands have arithmetic type, then the usual arithmetic conversions are performed on
them.
<BR><BR>If the first operand is a pointer, then the second operand must either be a pointer to the same type or an integral
type.
<BR><BR>In the same manner as for adding a pointer and an integral value, the integral value is multiplied by the size of
the object to which the pointer points.&nbsp; The pointer operand may not be a pointer to <TT> void</TT>.&nbsp; The result
type is the same type as the pointer operand.
<BR><BR>If both operands are pointers to the same type, the difference is divided by the size of the type, representing the
difference of the subscripts of the two array members (assuming the type is &quot;array of<B> type</B>&quot;).&nbsp; The type
of the result is implementation-defined, and is represented by <TT> ptrdiff_t</TT> (a signed integral type) defined in the
<TT> &lt;stddef.h&gt;</TT> header.
<BR><BR><B>&nbsp; With Open Watcom C/16 and C/32, </B><TT> ptrdiff_t</TT><B> is </B><TT> int</TT><B>, unless the huge memory
model is being used, in which case </B><TT> ptrdiff_t</TT><B> is </B><TT> long int</TT><B>.</B>
<H2 ID="Bitwise_Shift_Operators"> Bitwise Shift Operators </H2>
<BR><B>&nbsp; shift-expression:</B>
<BR><B>&nbsp;&nbsp;&nbsp; additive-expression</B>
<BR><B>&nbsp; or</B>
<BR><B>&nbsp; shift-expression</B><TT> &lt;&lt;</TT><B> additive-expression</B>
<BR><B>&nbsp; or</B>
<BR><B>&nbsp; shift-expression</B><TT> &gt;&gt;</TT><B> additive-expression</B>
<BR><BR>The<TT> &lt;&lt;</TT> symbol denotes the <B> left-shift</B> operator.&nbsp; Both operands must have an integral type,
and the integral promotions are performed on them.&nbsp; The type of the result is the type of the promoted left operand.
<BR><BR>The result of<TT> op &lt;&lt; amt</TT> is<TT> op</TT> left-shifted<TT> amt</TT> bit positions.&nbsp; Zero bits are
filled on the right.&nbsp; Effectively, the high bits shifted out of<TT> op</TT> are discarded, and the resulting set of bits
is re-interpreted as the result.&nbsp; Another interpretation is that<TT> op</TT> is multiplied by 2 raised to the power<TT>
amt</TT>.
<BR><BR>The<TT> &gt;&gt;</TT> symbol denotes the <B> right-shift</B> operator.&nbsp; Both operands must have an integral type,
and the integral promotions are performed on them.&nbsp; The type of the result is the type of the promoted left operand.
<BR><BR>The result of<TT> op &gt;&gt; amt</TT> is<TT> op</TT> right-shifted<TT> amt</TT> bit positions.&nbsp; If<TT> op</TT>
has an unsigned type, or a signed type and a non-negative value, then<TT> op</TT> is divided by 2 raised to the power<TT>
amt</TT>.&nbsp; Effectively, the low bits shifted out of<TT> op</TT> are discarded, zero bits are filled on the left, and
the resulting set of bits is re-interpreted as the result.
<BR><BR>If<TT> op</TT> has a signed type and negative value, then the behavior of<TT> op &gt;&gt; amt</TT> is implementation-defined.
&nbsp;Usually, the high bits vacated by the right shift are filled with the sign bit from before the shift (arithmetic right
shift), or with 0 (logical right shift).
<BR><BR><B>&nbsp; With Open Watcom C/16 and C/32, a right shift of a negative value of a signed type causes the sign bit to
be propogated throughout the bits vacated by the shift.&nbsp; Essentially, the vacated bits are filled with 1 bits.</B>
<BR><BR>For both bitwise shift operators, if the number of bits to shift exceeds the number of bits in the type, the result
is undefined.
<H2 ID="Relational_Operators"> Relational Operators </H2>
<BR><B>&nbsp; relational-expression:</B>
<BR><B>&nbsp;&nbsp;&nbsp; shift-expression</B>
<BR><B>&nbsp; or</B>
<BR><B>&nbsp; relational-expression</B><TT> &lt;</TT><B> shift-expression</B>
<BR><B>&nbsp; or</B>
<BR><B>&nbsp; relational-expression</B><TT> &gt;</TT><B> shift-expression</B>
<BR><B>&nbsp; or</B>
<BR><B>&nbsp; relational-expression</B><TT> &lt;=</TT><B> shift-expression</B>
<BR><B>&nbsp; or</B>
<BR><B>&nbsp; relational-expression</B><TT> &gt;=</TT><B> shift-expression</B>
<BR><BR>Each of the symbols <TT> &lt;</TT><B> (less than),</B> <TT> &gt;</TT><B> (greater than),</B> <TT> &lt;=</TT><B> (less
than or equal to),</B> <TT> &gt;=</TT><B> (greater than or equal to),</B> yields the value 1 if the relation is true, and
0 if the relation is false.&nbsp; The result type is <TT> int</TT>.
<BR><BR>If both operands have arithmetic type, then the usual arithmetic conversions are performed on them.
<BR><BR>If one of the operands is a pointer, then the other operand must be a pointer to a compatible type.&nbsp; The result
depends on where (in the address space of the computer) the pointers actually point.
<BR><BR>If both pointers point to members of the same array object, then the pointer that points to the member with a higher
subscript will be greater than the other pointer.
<BR><BR>If both pointers point to different members within the same structure, then the pointer pointing to the member declared
later in the structure will be greater than the other pointer.
<BR><BR>If both pointers point to the same union object, then they will be equal.
<BR><BR>All other comparisons yield undefined behavior.&nbsp; As discussed above, the relationship between pointers is determined
by the locations in the machine storage that the pointers reference.&nbsp; Typically, the numeric values of the pointer operands
are compared.
<H2 ID="Equality_Operators"> Equality Operators </H2>
<BR><B>&nbsp; equality-expression:</B>
<BR><B>&nbsp;&nbsp;&nbsp; relational-expression</B>
<BR><B>&nbsp; or</B>
<BR><B>&nbsp; equality-expression</B><TT> ==</TT><B> relational-expression</B>
<BR><B>&nbsp; or</B>
<BR><B>&nbsp; equality-expression</B><TT> !=</TT><B> relational-expression</B>
<BR><BR>The symbols<TT> ==</TT> <B> (equal to)</B> and<TT> !=</TT> <B> (not equal to)</B> yield the value 1 if the relation
is true, and 0 if the relation is false.&nbsp; The result type is <TT> int</TT>.
<BR><BR>If both operands have arithmetic type, then the usual arithmetic conversions are performed on them.
<BR><BR>If both operands are pointers to the same type and they compare equal, then they are pointers to the same object.
<BR><BR>If both operands are pointers and one is a pointer to <TT> void</TT>, then the other is converted to a pointer to
<TT> void</TT>.
<BR><BR>If one of the operands is a pointer, the other may be a null pointer constant (zero).
<BR><BR>No other combinations are valid.
<H2 ID="Bitwise_AND_Operator"> Bitwise AND Operator </H2>
<BR><B>&nbsp; and-expression:</B>
<BR><B>&nbsp;&nbsp;&nbsp; equality-expression</B>
<BR><B>&nbsp; or</B>
<BR><B>&nbsp; and-expression</B><TT> &amp;</TT><B> equality-expression</B>
<BR><BR>The<TT> &amp;</TT> symbol, in its binary form, denotes the <B> bitwise AND</B> operator.&nbsp; Each of the operands
must have integral type, and the usual arithmetic conversions are performed.
<BR><BR>The result is the bitwise AND of the two operands.&nbsp; That is, the bit in the result is set if and only if each
of the corresponding bits in the operands are set.
<BR><BR>The following table illustrates some bitwise AND operations:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Operation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Result</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ---------------&nbsp;&nbsp; ------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0x0000 &amp; 0x7A4C&nbsp;&nbsp; 0x0000</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0xFFFF &amp; 0x7A4C&nbsp;&nbsp; 0x7A4C</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0x1001 &amp; 0x0001&nbsp;&nbsp; 0x0001</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0x29F4 &amp; 0xE372&nbsp;&nbsp; 0x2170</TT>
<H2 ID="Bitwise_Exclusive_OR_Operator"> Bitwise Exclusive OR Operator </H2>
<BR><B>&nbsp; exclusive-or-expression:</B>
<BR><B>&nbsp;&nbsp;&nbsp; and-expression</B>
<BR><B>&nbsp; or</B>
<BR><B>&nbsp; exclusive-or-expression</B><TT> ^</TT><B> and-expression</B>
<BR><BR>The<TT> ^</TT> symbol denotes the <B> bitwise exclusive OR</B> operator.&nbsp; Each of the operands must have integral
type, and the usual arithmetic conversions are performed.
<BR><BR>The result is the bitwise exclusive OR of the two operands.&nbsp; That is, the bit in the result is set if and only
if exactly one of the corresponding bits in the operands is set.
<BR><BR>Another interpretation is that, if one of the operands is treated as a mask, then every 1 bit in the mask causes the
corresponding bit in the other operand to be complemented (0 becomes 1, 1 becomes 0) before being placed in the result, while
every 0 bit in the mask causes the corresponding bit in the other operand to be placed unchanged in the result.
<BR><BR>The following table illustrates some exclusive OR operations:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Operation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Result</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ---------------&nbsp;&nbsp; ------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0x0000 ^ 0x7A4C&nbsp;&nbsp; 0x7A4C</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0xFFFF ^ 0x7A4C&nbsp;&nbsp; 0x85B3</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0xFFFF ^ 0x85B3&nbsp;&nbsp; 0x7A4C</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0x1001 ^ 0x0001&nbsp;&nbsp; 0x1000</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0x29F4 ^ 0xE372&nbsp;&nbsp; 0xCA86</TT>
<H2 ID="Bitwise_Inclusive_OR_Operator"> Bitwise Inclusive OR Operator </H2>
<BR><B>&nbsp; inclusive-or-expression:</B>
<BR><B>&nbsp;&nbsp;&nbsp; exclusive-or-expression</B>
<BR><B>&nbsp; or</B>
<BR><B>&nbsp; inclusive-or-expression</B><TT> |</TT><B> exclusive-or-expression</B>
<BR><BR>The<TT> |</TT> symbol denotes the <B> bitwise inclusive OR</B> operator.&nbsp; Each of the operands must have integral
type, and the usual arithmetic conversions are performed.
<BR><BR>The result is the bitwise inclusive OR of the two operands.&nbsp; That is, the bit in the result is set if at least
one of the corresponding bits in the operands is set.
<BR><BR>The following table illustrates some inclusive OR operations:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Operation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Result</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ---------------&nbsp;&nbsp; ------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0x0000 | 0x7A4C&nbsp;&nbsp; 0x7A4C</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0xFFFF | 0x7A4C&nbsp;&nbsp; 0xFFFF</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0x1100 | 0x0022&nbsp;&nbsp; 0x1122</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0x29F4 | 0xE372&nbsp;&nbsp; 0xEBF6</TT>
<H2 ID="Logical_AND_Operator"> Logical AND Operator </H2>
<BR><B>&nbsp; logical-and-expression:</B>
<BR><B>&nbsp;&nbsp;&nbsp; inclusive-or-expression</B>
<BR><B>&nbsp; or</B>
<BR><B>&nbsp; logical-and-expression</B><TT> &amp;&amp;</TT><B> inclusive-or-expression</B>
<BR><BR>The<TT> &amp;&amp;</TT> symbol denotes the <B> logical AND</B> operator.&nbsp; Each of the operands must have scalar
type.
<BR><BR>If both of the operands are not equal to zero, then the result is 1.&nbsp; Otherwise, the result is zero.&nbsp; The
result type is <TT> int</TT>.
<BR><BR>If the first operand is zero, then the second operand is not evaluated.&nbsp; Any side effects that would have happened
if the second operand had been executed do not happen.&nbsp; Any function calls encountered in the second operand do not take
place.
<H2 ID="Logical_OR_Operator"> Logical OR Operator </H2>
<BR><B>&nbsp; logical-or-expression:</B>
<BR><B>&nbsp;&nbsp;&nbsp; logical-and-expression</B>
<BR><B>&nbsp; or</B>
<BR><B>&nbsp; logical-or-expression</B><TT> ||</TT><B> logical-and-expression</B>
<BR><BR>The<TT> ||</TT> symbol denotes the <B> logical OR</B> operator.&nbsp; Each of the operands must have scalar type.
<BR><BR>If one or both of the operands is not equal to zero, then the result is 1.&nbsp; Otherwise, the result is zero (both
operands are zero).&nbsp; The result type is <TT> int</TT>.
<BR><BR>If the first operand is not zero, then the second operand is not evaluated.&nbsp; Any side effects that would have
happened if the second operand had been executed do not happen.&nbsp; Any function calls encountered in the second operand
do not take place.
<H2 ID="Conditional_Operator"> Conditional Operator </H2>
<BR><B>&nbsp; conditional-expression:</B>
<BR><B>&nbsp;&nbsp;&nbsp; logical-or-expression</B>
<BR><B>&nbsp; or</B>
<BR><B>&nbsp; logical-or-expression</B><TT> ?</TT><B>&nbsp; expression</B><TT> :</TT><B>&nbsp; conditional-expression</B>
<BR><BR>The<TT> ?</TT>&nbsp; symbol separates the first two parts of a <B> conditional</B> operator, and the<TT> :</TT>&nbsp;
symbol separates the second and third parts.&nbsp; The first operand must have a scalar type (not a structure, union or array).
<BR><BR>The first operand is evaluated.&nbsp; If its value is not equal to zero, then the second operand is evaluated and
its value is the result.&nbsp; Otherwise, the third operand is evaluated and its value is the result.
<BR><BR>Whichever operand is evaluated, the other is not evaluated.&nbsp; Any side effects that might have happened during
the evaluation of the other operand do not happen.
<BR><BR>If both the second and third operands have arithmetic type, then the usual arithmetic conversions are performed on
them, and the type of the result is the same type as the converted operands.
<BR><BR>If both operands have the same structure, union or pointer type, then the result has that type.
<BR><BR>If both operands are pointers, and one is &quot;pointer to <TT> void</TT>&quot;, then the result type is &quot;pointer
to <TT> void</TT>&quot;.
<BR><BR>If one operand is a pointer, and the other is a null pointer constant (0), the result type is that of the pointer.
<BR><BR>If both operands are void expressions, then the result is a void expression.
<BR><BR>No other combinations of result types are permitted.
<BR><BR>Note that, unlike most other operators, the conditional operator associates from right to left.&nbsp; For example,
the expression,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; a = b ? c : d ? e : f;</TT>
<BR><BR>is translated as if it had been parenthesized as follows:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; a = b ? c : (d ? e : f);</TT>
<BR><BR>This construct is confusing, and so should probably be avoided.
<H2 ID="Assignment_Operators"> Assignment Operators </H2>
<BR><B>&nbsp; assignment-expression:</B>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; conditional-expression</B>
<BR><B>&nbsp;&nbsp; or</B>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; simple-assignment-expression</B>
<BR><B>&nbsp;&nbsp; or</B>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; compound-assignment-expression</B>
<BR><BR>An <B> assignment operator</B> stores a value in the object designated by the left operand.&nbsp; The left operand
must be a modifiable lvalue.
<BR><BR>The result type and value are those of the left operand after the assignment.
<BR><BR>Whether the left or right operand is evaluated first is undefined.
<BR><BR>Note that, unlike most other operators, the assignment operators associate from right to left.&nbsp; For example,
the expression,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; a += b = c;</TT>
<BR><BR>is translated as if it had been bracketed as follows:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; a += (b = c);</TT>
<H3 ID="Simple_Assignment"> Simple Assignment </H3>
<BR><B>&nbsp; simple-assignment-operator:</B>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unary-expression </B><TT>=</TT><B> assignment-expression</B>
<BR><BR>The<TT> =</TT> symbol denotes <B> simple assignment.</B>&nbsp; The value of the right operand is converted to the
type of the left operand and replaces the value designated by the left operand.
<BR><BR>The two operands must obey one of the following rules,
<UL>
<LI>both have arithmetic types,
<LI>both have the same structure or union type, or the right operand differs only in the presence of the <TT> const</TT> or
<TT> volatile</TT> keywords,
<LI>both are pointers to the same type,
<LI>both are pointers and one is a pointer to <TT> void</TT>,
<LI>the left operand is a pointer, and the right is a null pointer constant (0).
</UL>
<H3 ID="Compound_Assignment"> Compound Assignment </H3>
<BR><B>&nbsp; compound-assignment-expression:</B>
<BR><B>&nbsp;&nbsp;&nbsp; unary-expression assignment-operator assignment-expression</B>
<BR><BR><B>&nbsp; assignment-operator:</B>&nbsp; one of
<BR><TT>&nbsp; += -=</TT>
<BR><TT>&nbsp; *= /= %=</TT>
<BR><TT>&nbsp; &amp;= ^= |=</TT>
<BR><TT>&nbsp; &lt;&lt;= &gt;&gt;=</TT>
<BR><BR>A <B> compound assignment</B> operator of the form<TT> a</TT><B> op</B><TT>= b</TT> is equivalent to the simple assignment
expression<TT> a = a</TT><B> op</B><TT> (b)</TT>, except that the left operand<TT> a</TT> is evaluated only once.
<BR><BR>The compound assignment operator must have operands consistent with those allowed by the corresponding binary operator.
<H2 ID="Comma_Operator"> Comma Operator </H2>
<BR><B>&nbsp; expression:</B>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assignment-expression</B>
<BR><B>&nbsp;&nbsp; or</B>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; expression</B><TT>,</TT><B> assignment-expression</B>
<BR><BR>At the lowest precedence, the <B> comma operator</B> evaluates the left operand as a void expression (it is evaluated
and its result, if any, is discarded), and then evaluates the right operand.&nbsp; The result has the type and value of the
second operand.
<BR><BR>In contexts where the comma is also used as a separator (function argument lists and initializer lists), a comma expression
must be placed in parentheses.
<BR><BR>For example,
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Fn( (pi=3.14159,two_pi=2*pi) );</TT>
<BR><BR>the function<TT> Fn</TT> has one parameter, which has the value 2 times<TT> pi</TT>.
<BR><BR><TT>&nbsp; for( i = 0, j = 0, k = 0;; i++, j++, k++ )</TT>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; statement</B><TT>;</TT>
<BR><BR>The <TT> for</TT> statement allows three expressions.&nbsp; In this example, the first expression initializes three
objects and the third expression increments the three objects.
<H2 ID="Constant_Expressions"> Constant Expressions </H2>
<BR>A constant expression may be specified in several places:
<UL>
<LI>the size of a bit-field member of a structure,
<LI>the value of an enumeration constant,
<LI>an initializer list,
<LI>the number of elements in an array,
<LI>the value of a <TT> case</TT> label constant,
<LI>with the <TT> #if</TT> and <TT> #elif</TT> preprocessor directives.
</UL>
<BR>In most cases, a constant expression consists of a series of constant values and operations that evaluate to a constant
value.&nbsp; Certain operations may only appear within the operand of the <TT> sizeof</TT> operator.&nbsp; These include:
<UL>
<LI>a function call,
<LI>pre- or post-increment or decrement,
<LI>assignment,
<LI>comma operator,
<LI>array subscripting,
<LI>the .&nbsp; and,<TT> -&gt;</TT> operators (structure member access),
<LI>the unary<TT> &amp;</TT> (address-of) operator (see exception below),
<LI>the unary<TT> *</TT> (indirection) operator,
<LI>casts to a type other than an integer type.
</UL>
<BR>In a constant expression that is an initializer, floating-point constants and casts may be specified.&nbsp; Objects that
have static storage duration, and function designators (names), may be used to provide addresses, either explicitly using
the unary<TT> &amp;</TT> (address-of) operator, or implicitly by specifying the identifier only.
<BR><BR>The following examples illustrate constant expressions that may be used anywhere:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 3</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 256*3 + 27</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; OPSYS == OS_DOS /* These are macro names */</TT>
<BR><BR>The next set of examples are constant expressions that are only valid in an initializer:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &amp;SomeObject</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SomeFunction</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 3.5 * 7.2 / 6.5</TT>
<BR><BR>In a constant expression that is part of a <TT> #if</TT> or <TT> #elif</TT> preprocessor directive, only integral
constants and operators are permitted (and macros that, when replaced, follow these same rules).
<H1 ID="Statements"> Statements </H1>
<BR>A<B> statement</B> describes what actions are to be performed.&nbsp; Statements may only be placed inside functions.&nbsp;
Statements are executed in sequence, except where described below.
<H2 ID="Labelled_Statements"> Labelled Statements </H2>
<BR>Any statement may be preceded by a <B> label.</B>&nbsp; Labelled statements are usually the target of a <TT> goto</TT>
statement, and hence occur infrequently.
<BR><BR>A label is an identifier followed by a colon.&nbsp; Labels do not affect the flow of execution of a program.&nbsp;
A label that is encountered during execution is ignored.
<BR><BR>The following example illustrates a statement with a label:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; xyz: i = 0;</TT>
<BR><BR>Labels can only precede statements.&nbsp; It follows that labels may only appear inside functions.
<BR><BR>A label may be defined only once within any particular function.
<BR><BR>The identifier used for a label may be the same as another identifier for an object, function or tag, or a label in
another function.&nbsp; The <B> name space</B> for labels is separate from non-label identifiers, and each function has its
own label name space.
<H2 ID="Compound_Statements"> Compound Statements </H2>
<BR>A <B> compound statement</B> is a set of statements grouped together inside braces.&nbsp; It may have its own declarations
of objects, with or without initializations, and may or may not have any executable statements.&nbsp; A compound statement
is also called a <B> block.</B>
<BR><BR>The general form of a compound statement is:
<BR><BR><TT>&nbsp; {</TT><B> declaration-list statement-list</B><TT> }</TT>
<BR><BR>where<B> declaration-list</B> is a list of zero or more declarations of objects to be used in the block.<B>&nbsp;
statement-list</B> is a list of zero or more statements to be executed when the block is entered.
<BR><BR>Any declarations for objects that have automatic storage duration and initializers for them are evaluated in the order
in which they occur.
<BR><BR>An object declared with the keyword <TT> extern</TT> inside a block may not be initialized in the declaration, since
the storage for that object is defined elsewhere.
<BR><BR>An object declared in a block, without the keyword <TT> extern</TT>, may not be redeclared within the same block,
except in a block contained within the current block.
<H2 ID="Expression_Statements"> Expression Statements </H2>
<BR>A statement that is an expression is evaluated as a void expression for its side effects, such as the assigning of a value
with the assignment operator.&nbsp; The result of the expression is discarded.&nbsp; This discarding may be made explicit
by casting the expression as a <TT> void</TT>.
<BR><BR>For example, the statement,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; count = 3;</TT>
<BR><BR>consists of the expression<TT> count = 3</TT>, which has the side effect of assigning the value 3 to the object<TT>
count.</TT>&nbsp; The result of the expression is 3, with the type the same as the type of<TT> count.</TT>&nbsp; The result
is not used any further.&nbsp; As another example, the statement,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; (void) memcpy( dest, src, len );</TT>
<BR><BR>indicates that, regardless of the fact that <TT> memcpy</TT> returns a result, the result should be ignored.&nbsp;
However, it is equally valid, and quite common, to write,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; memcpy( dest, src, len );</TT>
<BR><BR>As a matter of programming style, casting an expression as <TT> void</TT> should only be done when the result of the
expression might normally be expected to be used further.&nbsp; In this case, casting to <TT> void</TT> indicates that the
result was intentionally discarded and is not an error of omission.
<H2 ID="Null_Statements"> Null Statements </H2>
<BR>A null statement, which is just a semi-colon, takes no action.&nbsp; It is useful for placing a label just before a block-closing
brace, or for indicating an empty block, such as in an iteration statement.&nbsp; Consider the following examples of null
statements:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gets( buffer );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( *buffer++ != '\0' )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* ... */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endblk: ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The <TT> while</TT> iteration statement skips over characters in<TT> buffer</TT> until the null character is found.
&nbsp;The body of the iteration is empty, since the controlling expression does all of the work.&nbsp; The<TT> endblk:</TT>
&nbsp;declares a label just before the final }, which might be used by a <TT> goto</TT> to exit the block.
<H2 ID="Selection_Statements"> Selection Statements </H2>
<BR>A <B> selection statement</B> evaluates an expression, called the <B> controlling expression,</B> then based on the result
selects from a set of statements.&nbsp; These statements are then executed.
<H3 ID="The_if_Statement"> The if Statement </H3>
<BR><TT>&nbsp; if(</TT><B> expression</B><TT> )</TT><B> statement</B>
<BR><B>&nbsp; or</B>
<BR><TT>&nbsp; if(</TT><B> expression</B><TT> )</TT><B> statement</B><TT> else</TT><B> statement</B>
<BR><BR>In both cases, the type of the controlling expression (inside the parentheses) is a scalar type (not a structure,
union or array).&nbsp; If the controlling expression evaluates to a non-zero value, then the first statement is executed.
<BR><BR>In the second form, the <TT> else</TT> is executed if the controlling expression evaluates to zero.
<BR><BR>Each statement may be a compound statement.&nbsp; For example,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; if( delay &gt; 5 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Waited too long\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ok = FALSE;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ok = TRUE;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>In the classic case of the dangling <TT> else</TT>, the <TT> else</TT> is bound to the nearest <TT> if</TT> that does
not yet have an <TT> else</TT>.&nbsp; For example,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; if( x &gt; 0 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( y &gt; 0 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;x &gt; 0 &amp;&amp; y &gt;
0\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;x &lt;= 0\n&quot; );</TT>
<BR><BR>will print<TT> x &lt;= 0</TT> when<TT> x &gt; 0</TT> is true and<TT> y &gt; 0</TT> is false, because the <TT> else</TT>
is bound to the second <TT> if</TT>, not the first.&nbsp; To correct this example, it would have to be changed to,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; if( x &gt; 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( y &gt; 0 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;x &gt; 0 &amp;&amp; y &gt;
0\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; } else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;x &lt;= 0\n&quot; );</TT>
<BR><BR>This example illustrates why it is a good idea to always use braces to explicitly state the subject of the control
structures, rather than relying on the fact that a single statement is also a compound statement.&nbsp; A better way of writing
the above example is,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; if( x &gt; 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( y &gt; 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;x &gt; 0 &amp;&amp; y &gt;
0\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;x &lt;= 0\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>where all subjects of the control structures are contained within braces, leaving no doubt about the meaning.&nbsp;
A dangling <TT> else</TT> cannot occur if braces are always used.
<BR><BR>If the statements between the <TT> if</TT> and the <TT> else</TT> are reached via a label, the statements following
the <TT> else</TT> will not be executed.&nbsp; However, jumping into a block is poor programming practice, since it makes
the program difficult to follow.
<H3 ID="The_switch_Statement"> The switch Statement </H3>
<BR><TT>&nbsp; switch(</TT><B> expression</B><TT> )</TT><B> statement</B>
<BR><BR>Usually,<B> statement</B> is a compound statement or block.&nbsp; Embedded within the statement are <TT> case</TT>
labels and possibly a <TT> default</TT> label, of the following form:
<BR><BR><TT>&nbsp; case</TT><B> constant-expression :&nbsp; statement</B>
<BR><TT>&nbsp; default :</TT><B>&nbsp; statement</B>
<BR><BR>The controlling expression and the constant-expressions on each <TT> case</TT> label all must have integral type.
&nbsp;No two of the <TT> case</TT> constant-expressions may be the same value.&nbsp; The <TT> default</TT> label may appear
at most once in any <TT> switch</TT> block.
<BR><BR>The controlling statement is evaluated, and the integral promotion is performed on the result.&nbsp; If the promoted
value of the expression matches any of the case labels promoted to the same type, control is given to the statement following
that case label.&nbsp; Otherwise, control is given to the statement following the <TT> default</TT> label (if present).&nbsp;
If no default label is present, then no statements in the <TT> switch</TT> block are executed.
<BR><BR>When statements within a <TT> switch</TT> block are being executed and another <TT> case</TT> or <TT> default</TT>
is encountered, it is ignored and execution continues with the statement following the label.&nbsp; The <TT> break</TT> statement
may be used to terminate execution of the switch block.
<BR><BR>In the following example,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; for( i = 1; i &lt;= 8; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%d &quot;, i );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch( i ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 2:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 4:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;less than 5 &quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 6:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 8:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;even\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;odd\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>the following output is produced:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 1 odd</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 2 less than 5 even</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 3 odd</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 4 less than 5 even</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 5 odd</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 6 even</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 7 odd</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 8 even</TT>
<H2 ID="Iteration_Statements"> Iteration Statements </H2>
<BR>Iteration statements control looping.&nbsp; There are three forms of iteration statements:&nbsp; <TT> while</TT>, <TT>
do</TT>/<TT> while</TT> and <TT> for</TT>.
<BR><BR>The controlling expression must have a scalar type.&nbsp; The<B> loop body</B> (often a compound statement or block)
is executed repeatedly until the controlling expression is equal to zero.
<H3 ID="The_while_Statement"> The while Statement </H3>
<BR><TT>&nbsp; while (</TT><B> expression</B><TT> )</TT><B> statement</B>
<BR><BR>The evaluation of the controlling expression takes place before each execution of the loop body (<B>statement</B>).
&nbsp;If the expression evaluates to zero the first time, the loop body is not executed at all.
<BR><BR>The<B> statement</B> may be a compound statement.
<BR><BR>For example,
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char * ptr;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* ... */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; while( *ptr != '\0' ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( *ptr == '.' )break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++ptr;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The loop will scan characters pointed at by<TT> ptr</TT> until either a null character or a dot is found.&nbsp; If
the initial value of<TT> ptr</TT> points at a null character, then no part of the loop body will be executed, leaving<TT>
ptr</TT> pointing at the null character.
<H3 ID="The_do_Statement"> The do Statement </H3>
<BR><TT>&nbsp; do</TT><B> statement</B><TT> while (</TT><B> expression</B><TT> );</TT>
<BR><BR>The evaluation of the controlling expression takes place after each execution of the loop body (<B>statement</B>).
&nbsp;If the expression evaluates to zero the first time, the loop body is executed exactly once.
<BR><BR>The<B> statement</B> may be a compound statement.
<BR><BR>For example,
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char * ptr;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char * endptr;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* ... */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; endptr = ptr + strlen( ptr );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; do {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --endptr;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; } while( endptr &gt;= ptr&nbsp; &amp;&amp;&nbsp; *endptr == ' ' );</TT>
<BR><BR>In this example, the loop will terminate when<TT> endptr</TT> finds a non-blank character starting from the right,
or when<TT> endptr</TT> goes past the beginning of the string.&nbsp; If a non-blank character is found,<TT> endptr</TT> will
be left pointing at that character.
<H3 ID="The_for_Statement"> The for Statement </H3>
<BR>The statement, 
<BR><BR><TT>&nbsp; for (</TT><B> expr1</B><TT>;</TT><B> expr2</B><TT>;</TT><B> expr3</B><TT> )</TT><B> statement</B>
<BR><BR>is almost equivalent to,
<BR><BR><B>&nbsp; expr1</B><TT>;</TT>
<BR><TT>&nbsp; while (</TT><B> expr2</B><TT> ) {</TT>
<BR><B>&nbsp; statement</B>
<BR><B>&nbsp; expr3</B><TT>;</TT>
<BR><TT>&nbsp; }</TT>
<BR><BR>The difference is that the <TT> continue</TT> statement will pass control to the statement<B> expr3</B> rather than
to the end of the loop body.
<BR><BR><B>expr1</B> is an initialization expression and may be omitted.
<BR><BR><B>expr2</B> is the controlling expression, and specifies an evaluation to be made before each iteration of the loop
body.&nbsp; If the expression evaluates to zero, the loop body is not executed, and control is passed to the statement following
the loop body.&nbsp; If<B> expr2</B> is omitted, then a non-zero (true) value is substituted in its place.&nbsp; In this case,
the statements in the loop must cause an explicit break from the loop.
<BR><BR><B>expr3</B> specifies an operation to be performed after each iteration.&nbsp; A common operation would be the incrementing
of a counter.<B>&nbsp; expr3</B> may be omitted.
<BR><BR>The<B> statement</B> may be a compound statement.
<BR><BR>For example,
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char charvec[256];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp; count;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; for( count = 0; count &lt;= 255; count++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; charvec[count] = count;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>This example will initialize the character array<TT> charvec</TT> to the values from 0 to 255.
<BR><BR>The following are examples of <TT> for</TT> statements:
<BR><BR><TT>&nbsp; for( ;; )</TT>
<BR><B>&nbsp; statement</B><TT>;</TT>
<BR><BR>All statements in the body of the loop will be executed until a <TT> break</TT> or <TT> goto</TT> statement is executed
which passes control outside of the loop, or a <TT> return</TT> statement is executed which exits the function.&nbsp; This
is sometimes called <B> loop forever</B>.
<BR><BR><TT>&nbsp; for( i = 0; i &lt;= 100; ++i )</TT>
<BR><B>&nbsp; statement</B><TT>;</TT>
<BR><BR>The object<TT> i</TT> is given the initial value zero, and after each iteration of the loop is incremented by one.
&nbsp;The loop is executed 101 times, with<TT> i</TT> having the successive values<TT> 0</TT>,<TT> 1</TT>,<TT> 2 ...&nbsp;
99</TT>,<TT> 100</TT>, and having the value<TT> 101</TT> after termination of the loop.
<BR><BR><TT>&nbsp; for( ; *bufptr != '\0'; ++bufptr )</TT>
<BR><B>&nbsp; statement</B><TT>;</TT>
<BR><BR>The object<TT> bufptr</TT> is already initialized, and the loop will continue until<TT> bufptr</TT> points at a null
character.&nbsp; After each iteration of the loop,<TT> bufptr</TT> will be incremented to point at the next character.
<H2 ID="Jump_Statements"> Jump Statements </H2>
<BR>A jump statement causes execution to continue at a specific place in a program, without executing any other intervening
statements.&nbsp; There are four jump statements:&nbsp; <TT> goto</TT>, <TT> continue</TT>, <TT> break</TT> and <TT> return</TT>.
<H3 ID="The_goto_Statement"> The goto Statement </H3>
<BR><TT>&nbsp; goto</TT><B> identifier</B><TT>;</TT>
<BR><BR><B>identifier</B> is a label somewhere in the current function (including any block within the function).&nbsp; The
next statement executed will be the one following that label.
<BR><BR><B>Note:</B>&nbsp; it can be confusing to use the <TT> goto</TT> statement excessively.&nbsp; It is easy to create
<B> spaghetti code,</B> which is very difficult to understand, even by the person who wrote it.&nbsp; It is recommended that
the <TT> goto</TT> statement be used, at most, to jump<B> out of</B> blocks, never into them.
<H3 ID="The_continue_Statement"> The continue Statement </H3>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; continue;</TT>
<BR><BR>A <TT> continue</TT> statement may only appear within a loop body, and causes a jump to the inner-most loop's loop-continuation
statement (the end of the loop body).
<BR><BR>In a <TT> while</TT> statement, the jump is effectively back to the <TT> while</TT>.
<BR><BR>In a <TT> do</TT> statement, the jump is effectively down to the <TT> while</TT>.
<BR><BR>In a <TT> for</TT> statement, the jump is effectively to the closing brace of the compound-statement that is the subject
of the <TT> for</TT> loop.&nbsp; The third expression in the <TT> for</TT> statement, which is often an increment or decrement,
is then executed before control is returned to the top of the loop.
<H3 ID="The_break_Statement"> The break Statement </H3>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><BR>A <TT> break</TT> statement may only appear in an iteration (loop) body or a <TT> switch</TT> statement.
<BR><BR>In a loop, a <TT> break</TT> will cause execution to continue at the statement following the loop body.
<BR><BR>In a <TT> switch</TT> statement, a <TT> break</TT> will cause execution to continue at the statement following the
switch.&nbsp; If the loop or <TT> switch</TT> that contains the <TT> break</TT> is enclosed inside another loop or <TT> switch</TT>,
only the inner-most loop or <TT> switch</TT> is terminated.&nbsp; The <TT> goto</TT> statement may be used to terminate more
than one loop or <TT> switch</TT>.
<H3 ID="The_return_Statement"> The return Statement </H3>
<BR><TT>&nbsp; return;</TT>
<BR><B>&nbsp; or</B>
<BR><TT>&nbsp; return</TT><B> expression</B><TT>;</TT>
<BR><BR>A popular variation of the second form is,
<BR><BR><TT>&nbsp;&nbsp; return(</TT><B> expression</B><TT> );</TT>
<BR><BR>The <TT> return</TT> statement causes execution of the current function to be terminated, and control is passed to
the caller.&nbsp; A function may contain any number of <TT> return</TT> statements.
<BR><BR>If the function is declared with a return type of <TT> void</TT> (no value is returned), then no <TT> return</TT>
statement within that function may return a value.
<BR><BR>If the function is declared as having a return type of other than <TT> void</TT>, then any <TT> return</TT> statement
with an expression will evaluate the expression and convert it to the return type.&nbsp; That value will be the value returned
by the function.&nbsp; If a <TT> return</TT> is executed without an expression, and the caller uses the value returned by
the function, the behavior is undefined since no value was returned.&nbsp; An arbitrary value will probably be used.
<BR><BR>Reaching the closing brace } that terminates the function is equivalent to executing a <TT> return</TT> statement
without an expression.
<H1 ID="Functions"> Functions </H1>
<BR>There are two forms for defining a function.&nbsp; The first form is,
<BR><BR><B>&nbsp; storage-class return-type identifier</B><TT> (</TT><B> parameter-type-list</B><TT> )</TT>
<BR><TT>&nbsp; {</TT>
<BR><B>&nbsp; declaration-list</B>
<BR><BR><B>&nbsp; statement-list</B>
<BR><TT>&nbsp; }</TT>
<BR><BR>The<B> storage-class</B> may be one of <TT> extern</TT> or <TT> static</TT>.&nbsp; If<B> storage-class</B> is omitted,
<TT> extern</TT> is assumed.
<BR><BR>The<B> return-type</B> may be any valid type except an<B> array</B>.&nbsp; If<B> return-type</B> is omitted, <TT>
int</TT> is assumed.
<BR><BR>The<B> identifier</B> is the name of the function.
<BR><BR>The<B> parameter-type-list</B> is either <TT> void</TT> or empty, meaning the function takes no parameters, or a comma-separated
list of declarations of the objects, including both type and parameter name (identifier).&nbsp; If multiple arguments of the
same type are specified, the type of each argument must be given individually.&nbsp; The form,
<BR><BR><B>&nbsp; type id1, id2</B>
<BR><BR>is not permitted within the parameter list.
<BR>If the<B> parameter-type-list</B> ends with<TT> ,...</TT>&nbsp; then the function will accept a variable number of arguments.
<BR><BR>Any parameter declared as &quot;array of<B> type</B>&quot; is changed to &quot;pointer to<B> type</B>&quot;.&nbsp;
Any parameter declared as &quot;<B> function</B>&quot; is changed to &quot;pointer to<B> function</B>&quot;.
<BR><BR>The following examples illustrate several function definitions:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int F( void )</TT>
<BR><BR>&nbsp;&nbsp;&nbsp; The function<TT> F</TT> has no parameters, and returns an integer.
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void G( int x )</TT>
<BR><BR>&nbsp;&nbsp;&nbsp; The function<TT> G</TT> has one parameter, an integer object named<TT> x</TT>, and does not return
a value.
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void * H( long int len, long int wid )</TT>
<BR><BR>&nbsp;&nbsp;&nbsp; The function<TT> H</TT> has two parameters, long integer objects named<TT> len</TT> and<TT> wid</TT>,
and returns a pointer which does not point to any particular type of object.
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void I( char * format, ... )</TT>
<BR><BR>&nbsp;&nbsp;&nbsp; The function<TT> I</TT> has one known parameter, an object named<TT> format</TT> that is a pointer
to a character (string).&nbsp; The function also accepts a variable number of parameters following<TT> format</TT>.&nbsp;
The function does not return a result.
<BR>This form of function definition also serves as a prototype declaration for any calls to the function that occur later
in the same module.&nbsp; With the function prototype in scope at the time of a call to the function, the arguments are converted
to the type of the corresponding parameter prior to the value being assigned.&nbsp; If a call to the function is to be made
prior to its definition, or from another module, a function prototype should be specified for it in order to ensure proper
conversion of argument types.&nbsp; Failure to do this will result in the default argument promotions being performed, with
undefined behavior if the function parameter types do not match the promoted argument types.
<BR><BR>The second form of function definition is,
<BR><BR><B>&nbsp; storage-class return-type identifier</B><TT> (</TT><B> identifier-list</B><TT> )</TT>
<BR><B>&nbsp; declaration-list</B>
<BR><TT>&nbsp; {</TT>
<BR><B>&nbsp; declaration-list</B>
<BR><BR><B>&nbsp; statement-list</B>
<BR><TT>&nbsp; }</TT>
<BR><BR>The<B> storage-class</B>,<B> return-type</B> and<B> identifier</B> parts are all the same as for the first form of
definition.&nbsp; In this form, the<B> identifier-list</B> is a (possibly empty) comma-separated list of identifiers (object
names) without any type information.&nbsp; Following the closing parenthesis, and before the opening brace of the body of
the function, the declarations for the objects are given, using the normal rules.&nbsp; Any object of type <TT> int</TT> need
not be explicitly declared.
<BR><BR>In the declarations of the parameter identifiers, <TT> register</TT> is the only storage-class specifier that may
be used.
<BR><BR>A function prototype is created from the definition after the default argument promotions have been performed on each
parameter.&nbsp; All arguments to a function declared in this manner will have the default argument promotions performed on
them.&nbsp; The resulting types must match the types of the declared parameters, after promotion.&nbsp; Otherwise, the behavior
is undefined.
<BR><BR>Note that it is impossible to pass an object of type <TT> float</TT> to a function declared in this manner.&nbsp;
The argument of type <TT> float</TT> will automatically be promoted to <TT> double</TT>, and the parameter will also be promoted
to <TT> double</TT> (assuming that it was declared as <TT> float</TT>).&nbsp; For similar reasons, it is not possible to pass
an object of type <TT> char</TT> or <TT> short int</TT> without promotion taking place.
<BR><BR>According to the ISO standard for the C language,<B> this form of function definition is obsolete</B> and should not
be used.&nbsp; It is provided for historical reasons, in particular, for compatibility with older C compilers.&nbsp; Using
the first form of function definition often allows the compiler to generate better code.
<BR><BR>The following examples are the same as those given with the first form above, with the appropriate modifications:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int F()</TT>
<BR><BR>&nbsp;&nbsp;&nbsp; The function<TT> F</TT> has no parameters, and returns an integer.
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void G( x )</TT>
<BR><BR>&nbsp;&nbsp;&nbsp; The function<TT> G</TT> has one parameter, an integer object named<TT> x</TT>, and does not return
a value.&nbsp; This example could have also been written as,
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void G( x )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int x;</TT>
<BR><BR>&nbsp;&nbsp;&nbsp; which explicitly declares<TT> x</TT> to be an integer.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void * H( len, wid )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long int len;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long int wid;</TT>
<BR><BR>&nbsp;&nbsp;&nbsp; The function<TT> H</TT> has two parameters, both integer objects named<TT> len</TT> and<TT> wid</TT>,
and returns a pointer which does not point to any particular type of object.&nbsp; Any call to this function must ensure that
the arguments are long integers, either by using an object so declared, or by explicitly casting the object to the type.
<BR>The last example using the ellipsis (<TT>,...</TT>) notation is not directly representable using the second form of function
definition.&nbsp; With most compilers it is possible to handle variable argument lists in this form, but knowledge of the
mechanism used to pass arguments to functions is required, and this mechanism may vary between different compilers.
<H2 ID="The_Body_of_the_Function"> The Body of the Function </H2>
<BR>Following the declaration of the function and the opening brace is the<B> body</B> of the function.&nbsp; It consists
of two portions, both of which are optional.
<BR><BR>The first portion is the declaration list for any objects needed within the function.&nbsp; These objects may have
any type and any storage class.&nbsp; Objects with storage class <TT> register</TT> or <TT> auto</TT> have <B> automatic storage
duration</B>, meaning they are created when the function is called, and destroyed when the function returns to the caller.
&nbsp;(The value of the object is not preserved between calls to the function.) Objects with storage class <TT> extern</TT>
or <TT> static</TT> have <B> static storage duration</B>, meaning they are created once, before the function is ever called,
and destroyed only when the program terminates.&nbsp; Any value placed in such an object will remain even after the function
has returned, so that the next time the function is called the value will still be present (unless some other action is taken
to change it, such as using another object containing a pointer to the static object to modify the value).
<BR><BR>Unless an explicit <TT> return</TT> statement is executed, the function will not return to the caller until the brace
at the end of the function definition is encountered.&nbsp; The return will be as if a <TT> return</TT> statement with no
expression was executed.&nbsp; If the function is declared as returning a value, and the caller attempts to use the value
returned in this manner, the behavior is undefined.&nbsp; The value used will be arbitrary.
<BR><BR>A function may call itself (recursion) directly, or it may call another function or functions which in turn call it.
&nbsp;Any objects declared with<B> automatic storage duration</B> are created as a new instance of the object upon each recursion,
while objects declared with<B> static storage duration</B> only have one instance shared between the recursive instances of
the function.
<H2 ID="Function_Prototypes"> Function Prototypes </H2>
<BR>A function prototype is like a definition of a function, but without the body.&nbsp; A semi-colon is specified immediately
following the closing right parenthesis of the function's declaration.&nbsp; The prototype describes the name of the function,
the types of parameters it expects (names are optional) and the type of the return value.&nbsp; This information can be used
by the C compiler to do proper argument type checking and conversion for calls to the function, and to properly handle the
return value.
<BR><BR>If no function prototype has been found by the time a call to a function is made, all arguments have the default argument
promotions performed on them, and the return type is assumed to be <TT> int</TT>.&nbsp; If the actual definition of the function
does not have parameters that match the promoted types, the behavior is undefined.&nbsp; If the return type is not <TT> int</TT>
and a return value is required, the behavior is undefined.
<BR><BR>The prototype for a function must match the function definition.&nbsp; Each parameter type and the type of the return
value must be the same, otherwise the behavior is undefined.
<BR><BR>All library functions have prototypes in one of several header files.&nbsp; That header file should be included whenever
a function described therein is used.&nbsp; Refer to the Open Watcom C Library Reference manual for details.
<H3 ID="Variable_Argument_Lists"> Variable Argument Lists </H3>
<BR>If the prototype (and definition) for a function has a parameter list that ends with<TT> ,...</TT>&nbsp; then the function
has a<B> variable argument list</B> or<B> variable parameter list</B> meaning that the number of arguments to the function
can vary.&nbsp; (The library function <TT> printf</TT> is an example.) At least one argument must be provided before the variable
portion.&nbsp; This argument usually describes, in some fashion, how many other arguments to expect.&nbsp; It may be a simple
count, or may involve (as with <TT> printf</TT>) an encoding of the number and types of arguments.
<BR><BR>All arguments that correspond to a variable argument list have the default argument promotions performed on them,
since it is not possible to determine, at compilation time, what types will be required by the function.
<BR><BR>Since the parameters represented by the<TT> ,...</TT>&nbsp; don't have names, special handling is required.&nbsp;
The C language provides a special type and three macros for handling variable argument lists.&nbsp; To be able to use these,
the header <TT> &lt;stdarg.h&gt;</TT> must be included.
<BR><BR>The type <TT> va_list</TT> is an implementation-specific type used to store information about the variable list.&nbsp;
Within the function, an object must be declared with type <TT> va_list</TT>.&nbsp; This object is used by the macros and functions
for processing the list.
<BR><BR>The macro <TT> va_start</TT> has the form,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void va_start( va_list </TT><B>parminfo</B>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; , </TT>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp; lastparm</B>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</TT>
<BR><BR>The object<B> parminfo</B> is set up by the macro with information describing the variable list.&nbsp; The argument<B>
lastparm</B> is the name (identifier) of the last parameter before the<TT> ,...</TT>&nbsp; and must not have been declared
with the storage class <TT> register</TT>.
<BR><BR>The macro <TT> va_start</TT> must be executed before any processing of the variable portion of the parameter list
is performed.
<BR><BR><TT> va_start</TT> may be executed more than once, but only if an intervening <TT> va_end</TT> is executed.
<BR><BR>The macro <TT> va_arg</TT> has the form,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp; type</B>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_arg( va_list </TT>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp; parminfo</B>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; , </TT>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp; type</B>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</TT>
<BR><BR><B>parminfo</B> is the same object named in the call to <TT> va_start</TT>.<B>&nbsp; type</B> is the type of argument
expected.&nbsp; The types expected should only be those that result from the default argument promotions (<TT> int</TT>, <TT>
long int</TT> and <TT> long long int</TT> and their unsigned varieties, <TT> double</TT> and <TT> long double</TT>), and those
that are not subject to promotion (pointers, structures and unions).&nbsp; The type must be determined by the program.&nbsp;
The <TT> va_arg</TT> macro expands to an expression that has the type and value of the next parameter in the variable list.
<BR><BR>In the case of <TT> printf</TT>, the parameter type expected is determined by the &quot;conversion specifications&quot;
such as<TT> %s</TT>,<TT> %d</TT> and so on.
<BR><BR>The first invocation of the <TT> va_arg</TT> macro (after executing a <TT> va_start</TT>) returns the value of the
parameter following<B> lastparm</B> (as specified in <TT> va_start</TT>).&nbsp; Each subsequent invocation of <TT> va_arg</TT>
returns the next parameter in the list.&nbsp; At each invocation, the value of<B> parminfo</B> is modified (in some implementation-specific
manner) to reflect the processing of the parameter list.
<BR><BR>If the type of the next parameter does not match<B> type</B>, or if no parameter was specified, the behavior is undefined.
<BR><BR>The macro <TT> va_end</TT> has the form,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void va_end( va_list </TT><B>parminfo</B>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</TT>
<BR><BR><B>parminfo</B> is the same object named in the corresponding call to <TT> va_start</TT>.&nbsp; The function <TT>
va_end</TT> closes off processing of the variable argument list, which must be done prior to returning from the function.
&nbsp;If <TT> va_end</TT> is not called before returning, the behavior is undefined.
<BR><BR>If <TT> va_end</TT> is called without a corresponding call to <TT> va_start</TT> having been done, the behavior is
undefined.
<BR><BR>After calling <TT> va_end</TT> and prior to returning, it is possible to call <TT> va_start</TT> again and reprocess
the variable list.&nbsp; It will be necessary to call <TT> va_end</TT> again before returning.
<BR><BR>The following function takes an arbitrary number of floating-point numbers as parameters along with a count, and returns
the average of the numbers:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdarg.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern double Average( int count, ... )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /*************************************/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double&nbsp; sum = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; i;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_list parminfo;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( count == 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( 0.0 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_start( parminfo, count );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; count; i++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sum += va_arg( parminfo, double );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_end( parminfo );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( sum / count );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="The_Parameters_to_the_Function_main"> The Parameters to the Function main </H2>
<BR>The function <TT> main</TT> has a special meaning in C.&nbsp; It is the function that receives control when a program
is started.&nbsp; The function<TT> main</TT> has the following definition:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int main( int argc, char * argv[] )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT><B>statements</B>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The objects <TT> argc</TT> and <TT> argv</TT> have the following properties:
<UL>
<LI><TT> argc</TT> is the &quot;argument count&quot;, or the number of parameters (including program name) supplied to the
program, and its value is greater than zero,
<LI><TT> argv</TT> is an array of pointers to strings containing the parameters,
<LI><TT> argv[0]</TT> is the program name, if available, otherwise it is a pointer to a string containing only the null character,
<LI><TT> argv[argc]</TT> is a null pointer, representing the end of the argument list,
<LI><TT> argv[1]</TT> through<TT> argv[argc-1]</TT> are pointers to strings representing the arguments to the program.&nbsp;
These strings are modifiable by the program, and exist throughout the execution of the program.&nbsp; The strings will generally
be in mixed (upper and lower) case, although a system that cannot provide mixed case argument strings will provide them in
lower case.
</UL>
<BR>The translation of the arguments to the program, as provided by the operating system (often from the command-line used
to invoke the program), into the strings contained in<TT> argv</TT>, is implementation-defined.
<BR><BR><B>&nbsp; With Open Watcom C/16 and C/32, each unquoted, blank-separated token on the command line is made into a
string that is an element of</B><TT> argv.</TT><B>&nbsp; Quoted strings are maintained as one element without the quotes.</B>
<BR><BR><B>&nbsp; For example, the command line,</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pgm 2+ 1 tokens &quot;one token&quot;</TT>
<BR><BR>&nbsp; will result in<TT> argc</TT> having the value 5, and the elements of<TT> argv</TT> being the strings<TT> &quot;pgm&quot;</TT>,<TT>
&quot;2+&quot;</TT>,<TT> &quot;1&quot;</TT>,<TT> &quot;tokens&quot;</TT> and<TT> &quot;one token&quot;.</TT>
<BR><BR>The function<TT> main</TT> may also be declared without any parameters, as,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int main( void )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; statements</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The return value of<TT> main</TT> is an integer, usually representing a termination status.&nbsp; If no return value
is specified (by using a <TT> return</TT> statement with no expression or encountering the closing brace in the function),
then the value returned is undefined.
<BR><BR>The <TT> exit</TT> library function may be used to terminate the program at any point.&nbsp; The value of the argument
to <TT> exit</TT> is returned as if<TT> main</TT> had returned the value.
<H1 ID="The_Preprocessor"> The Preprocessor </H1>
<BR>The<B> preprocessor,</B> as its name suggests, is that part of the C compiler which processes certain directives embedded
in the source file(s) in advance of the actual compilation of the program.&nbsp; Specifically, the preprocessor allows a source
file to,
<UL>
<LI>include other files (perhaps referencing externally-defined objects, or containing the definitions of structures or other
types which are needed by more than one source file),
<LI>compile certain portions of the code depending on some condition (such as the kind of computer for which the code is being
generated), and,
<LI>replace<B> macros</B> with other text which is then compiled.
</UL>
<BR>The preprocessing phase occurs after trigraphs have been converted and physical lines ending with <TT> \</TT> have been
concatenated to create longer logical lines, but before escape sequences in character constants have been converted, or adjacent
string literals are concatenated.
<BR><BR>Any line whose first non-blank character is a<TT> #</TT> marks the beginning of a<B> preprocessing directive.</B>
&nbsp;Spaces may appear between the<TT> #</TT> and the identifier for the directive.&nbsp; The <TT> #include</TT> and <TT>
#define</TT> directives are each contained on one line (after concatenation of lines ending with<TT> \</TT>), while the conditional
compilation directives span multiple lines.
<BR><BR>A preprocessor directive is not terminated by a semi-colon.
<H2 ID="The_Null_Directive"> The Null Directive </H2>
<BR>A preprocessing directive of the form, 
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #</TT>
<BR><BR>(with no other tokens on the same line) has no effect and is discarded.
<H2 ID="Including_Headers_and_Source_Files"> Including Headers and Source Files </H2>
<BR>A directive of the form, 
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;name&gt;</TT>
<BR><BR>will search a sequence of places defined by the implementation for the <B> header</B> identified by<TT> name.</TT>
&nbsp;A header declares a set of library functions and any necessary types or macros needed for their use.&nbsp; Headers are
usually provided by the compiler, or by a library provided for use with the compiler.
<BR><BR><TT>name</TT> may not contain a<TT> &gt;</TT> character.&nbsp; If the header is found, the entire directive is replaced
by the contents of the header.&nbsp; If the header is not found, an error will occur.
<BR><BR>A directive of the form,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &quot;name&quot;</TT>
<BR><BR>will search for the source file identified by<TT> name.&nbsp; name</TT> may not contain a<TT> &quot;</TT> (double-quote)
character.&nbsp; If the source file identified by<TT> name</TT> is found, then the entire directive is replaced by the contents
of the file.&nbsp; Otherwise, the directive is processed as if the,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;name&gt;</TT>
<BR><BR>form had been used.
<BR><BR>A third form of <TT> #include</TT> directive is also supported.&nbsp; A directive of the form,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include tokens</TT>
<BR><BR>causes all macro substitutions (described below) to take place on<TT> tokens.</TT>&nbsp; After substitution, the directive
must match either the<TT> &lt;name&gt;</TT> or<TT> &quot;name&quot;</TT> forms described above (including<TT> &lt;</TT> and<TT>
&gt;</TT>, or quotes), in which case the <TT> #include</TT> is processed in the corresponding manner.
<BR><BR>See the User's Guide for details about how the compiler searches for included files.
<BR><BR><TT> #include</TT> directives may be nested.&nbsp; Each implementation may allow different depths of nesting, but
all must allow at least 8 levels.&nbsp; (In other words, a source file may include another file, which includes another file,
and so on, up to a depth of eight files.)
<BR><BR><B>&nbsp; The operating system may further limit the number of files that may be open at one time.&nbsp; See the appropriate
operating system manual for details.</B>
<H2 ID="Conditionally_Including_Source_Lines"> Conditionally Including Source Lines </H2>
<BR>A directive of the form, 
<BR><BR><B>&nbsp; </B><TT> #if</TT><B> constant-expression</B>
<BR><B>&nbsp; body of </B><TT> #if</TT>
<BR><B>&nbsp; </B><TT> #endif</TT>
<BR><BR>evaluates the<B> constant-expression,</B> and if it evaluates to a non-zero value, then the body of the <TT> #if</TT>
is processed by the preprocessor.&nbsp; Processing of the body ends when a corresponding <TT> #elif</TT>, <TT> #else</TT>,
or the terminating <TT> #endif</TT> is encountered.
<BR><BR>The <TT> #if</TT> directive allows source and preprocessor lines to be conditionally processed by the compiler.
<BR><BR>If the<B> constant-expression</B> evaluates to zero, then the body of the <TT> #if</TT> is not processed, and the
corresponding <TT> #elif</TT> or <TT> #else</TT> (if present) is processed.&nbsp; If neither of these directives are present,
then the preprocessor skips to the <TT> #endif</TT>.&nbsp; Any preprocessing directives within the body of the <TT> #if</TT>
are not processed, but they are examined in order to determine any nested directives, in order to find the matching <TT> #elif</TT>,
<TT> #else</TT> or <TT> #endif</TT>.
<BR><BR>The<B> constant-expression</B> is of the same form as used in the <TT> if</TT> statement, except that the values used
must be integer values (including character constants).&nbsp; No cast or <TT> sizeof</TT> operators or enumeration constants
may be used.&nbsp; Each identifier that is a macro name is replaced (as described below), and remaining identifiers are replaced
with<TT> 0L</TT>.&nbsp; All values are converted to long integers using the usual arithmetic conversions.&nbsp; After each
item has been converted, the evaluation of the expression takes place using the arithmetic of the translation environment.
&nbsp;Any character constants are evaluated as members of the<B> source</B> character set.
<BR><BR><B>&nbsp; With Open Watcom C/16 and C/32, character constants have the same value in both the source and execution
character sets.</B>
<BR><BR>The unary expression,
<BR><BR><TT>&nbsp; defined</TT><B> identifier</B>
<BR><B>&nbsp; or</B>
<BR><TT>&nbsp; defined(</TT><B> identifier</B><TT> )</TT>
<BR><BR>may be used to determine if an identifier is currently defined as a macro.&nbsp; Any macro name that is part of this
unary expression is not expanded.&nbsp; The above expressions evaluate to 1 if the named identifier is currently a macro,
otherwise they evaluate to 0.
<BR><BR>As discussed above, if the<B> constant-expression</B> of the <TT> #if</TT> evaluates to zero, the preprocessor looks
for a corresponding <TT> #elif</TT>.&nbsp; This directive means &quot;else if&quot;, and has a similar form as <TT> #if</TT>:
&nbsp;
<BR><BR><B>&nbsp; </B><TT> #elif</TT><B> constant-expression</B>
<BR><B>&nbsp; body of </B><TT> #elif</TT>
<BR><BR>An <TT> #elif</TT> may only be placed inside the body of an <TT> #if</TT>.&nbsp; The body of the <TT> #elif</TT> is
processed only if the<B> constant-expression</B> evaluates to a non-zero value and the constant-expressions of the corresponding
<TT> #if</TT> and (preceding) <TT> #elif</TT> statements evaluated to zero.&nbsp; Otherwise the body is not processed, and
the preprocessor skips to the next corresponding <TT> #elif</TT> or <TT> #else</TT>, or to the <TT> #endif</TT> if neither
of these directives is present.
<BR><BR>The <TT> #else</TT> directive has the form, 
<BR><BR><B>&nbsp; </B><TT> #else</TT>
<BR>&nbsp; body of <TT> #else</TT>
<BR><BR>The body of the <TT> #else</TT> is processed only if the constant expressions of the corresponding <TT> #if</TT> and
<TT> #elif</TT> statements evaluated to zero.&nbsp; The body of the <TT> #else</TT> is processed until the corresponding <TT>
#endif</TT> is encountered.
<BR><BR>The form of the <TT> #endif</TT> directive is,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #endif</TT>
<BR><BR>and marks the end of the <TT> #if</TT>.
<BR><BR>The following are examples of conditional inclusion of source lines:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #if OPSYS == OS_CMS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fn_syntax = &quot;filename filetype fm&quot;;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #elif OPSYS == OS_MVS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fn_syntax = &quot;'userid.library.type(membername)'&quot;;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #elif OPSYS == OS_DOS&nbsp; ||&nbsp; OPSYS == OS_OS2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fn_syntax = &quot;filename.ext&quot;;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fn_syntax = &quot;filename&quot;;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #endif</TT>
<BR><BR>The object<TT> fn_syntax</TT> is set to the appropriate filename syntax string depending on the value of the macro<TT>
OPSYS.</TT>&nbsp; If<TT> OPSYS</TT> does not match any of the stated values, then<TT> fn_syntax</TT> is set to the default
string<TT> &quot;filename&quot;.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #if HARDWARE == HW_IBM370</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #if OPSYS == OS_CMS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; escape_cmd = &quot;CMS&quot;;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #elif OPSYS == OS_MVS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; escape_cmd = &quot;TSO&quot;;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; escape_cmd = &quot;SYSTEM&quot;;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #endif</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; escape_cmd = &quot;SYSTEM&quot;;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #endif</TT>
<BR><BR>The object<TT> escape_cmd</TT> is set to an appropriate string depending on the values of the macros<TT> HARDWARE</TT>
and<TT> OPSYS.</TT>&nbsp; The indentation of the directives clearly illustrates the flow between various conditions and levels
of directives.
<H3 ID="The__ifdef_and__ifndef_Directives"> The #ifdef and #ifndef Directives </H3>
<BR>The <TT> #ifdef</TT> directive is used to check if an identifier is currently defined as a macro.&nbsp; For example, the
directive,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #ifdef xyz</TT>
<BR><BR>processes the body of the <TT> #ifdef</TT> only if the identifier<TT> xyz</TT> is currently a macro.&nbsp; This example
is equivalent to,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #if defined xyz</TT>
<BR><BR>or
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #if defined( xyz )</TT>
<BR><BR>In a similar manner, the directive, 
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #ifndef xyz</TT>
<BR><BR>is equivalent to,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #if !defined xyz</TT>
<BR><BR>or
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #if !defined( xyz )</TT>
<H2 ID="Macro_Replacement"> Macro Replacement </H2>
<BR>A directive of the form, 
<BR><BR><TT>&nbsp; #define</TT><B> identifier replacement-list</B>
<BR><BR>defines a <B> macro</B> with the name<B> identifier.</B>&nbsp; This particular form of macro is called an <B> object-like</B>
macro, because it is used like an object (as opposed to a function).&nbsp; Any source line that contains a token matching
the macro name has that token replaced by the<B> replacement-list.</B>&nbsp; The tokens of the replacement-list are then rescanned
for more macro replacements.
<BR><BR>For example, the macro,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define TABLE_LIMIT 256</TT>
<BR><BR>defines the macro<TT> TABLE_LIMIT</TT> to be equivalent to the token<TT> 256.</TT>&nbsp; This is sometimes called
a <B> manifest constant,</B> because it provides a descriptive term for a value that makes programs easier to read.&nbsp;
It is a very good idea to use descriptive names wherever appropriate to improve the readability of a program.&nbsp; It may
also save time if the same value is used many different places, and the value must be changed at some point.
<BR><BR>Care must be exercised when using more complicated object-like macros.&nbsp; Consider the following example:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define COUNT1 10</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define COUNT2 20</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define TOTAL_COUNT COUNT1+COUNT2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* ... */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; memptr = malloc( TOTAL_COUNT * sizeof( int ) );</TT>
<BR><BR>If <TT> int</TT> is 2 bytes in size, this call to <TT> malloc</TT> will allocate 50 bytes of memory, instead of the
expected 60.&nbsp; This occurs because<TT> TOTAL_COUNT * sizeof( int )</TT> becomes<TT> 10+20 * 2</TT> after macro replacement,
and the precedence rules for expression evaluation cause the multiply to be done first.&nbsp; To solve this problem, the macro
for<TT> TOTAL_COUNT</TT> should be defined as:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define TOTAL_COUNT (COUNT1+COUNT2)</TT>
<BR><BR>A directive of the form, 
<BR><BR><B>&nbsp; </B><TT> #define</TT><B> identifier</B><TT>(</TT><B> identifier-list</B><TT> )</TT><B> replacement-list</B>
<BR><BR>is called a <B> function-like</B> macro, because it is used like a function call.&nbsp; No space may appear between<B>
identifier</B> and the left parenthesis in the macro definition.&nbsp; Any source line(s) that contains what looks like a
function call, where the name of the function matches a function-like macro name, and the number of parameters matches the
number of identifiers in the<B> identifier-list,</B> has the entire function call replaced by the<B> replacement-list,</B>
substituting the actual arguments of the function call for the occurrences of the identifiers in the replacement-list.&nbsp;
If the left parenthesis following the macro name was created as the result of a macro substitution, no further substitution
will take place.&nbsp; If the macro name appears but is not followed by a left parenthesis, no further substitution will take
place.
<BR><BR>Consider this example:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define endof( string ) \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (string + strlen( string ))</TT>
<BR><BR>The<TT> \</TT> causes the two lines to be joined together into one logical line, making this equivalent to,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define endof( string )&nbsp;&nbsp;&nbsp; (string + strlen( string ))</TT>
<BR><BR>The function-like macro<TT> endof</TT> can be used to find a pointer to the null character terminating a string.&nbsp;
The statement,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; endptr = endof( ptr );</TT>
<BR><BR>will have the macro replaced, so it will then be parsed as,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; endptr = (ptr + strlen( ptr ));</TT>
<BR><BR>Note that, in this case, the argument is evaluated twice.&nbsp; If<TT> StrFn( ptr )</TT> was specified instead of<TT>
ptr</TT>, then the function would get called twice, because the substitution would yield,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; endptr = (StrFn( ptr ) + strlen( StrFn( ptr ) ));</TT>
<BR><BR>In gathering up the tokens used to identify the arguments, each sequence of tokens separated by a comma constitutes
an argument, unless that comma happens to be within a matched pair of left and right parentheses.&nbsp; When a right parenthesis
is found that matches the beginning left parenthesis, and the number of arguments matches the number of identifiers in the
macro definition, then the gathering of the arguments is complete and the substitution takes place.
<BR><BR>For example,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define mymemcpy( dest, src, len ) \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memcpy( dest, src, len )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* ... */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; mymemcpy( destptr, srcptr, (t=0, t=strlen(srcptr)) );</TT>
<BR><BR>will, for the parameters<TT> dest</TT>,<TT> src</TT> and<TT> len</TT>, use the arguments<TT> destptr</TT>,<TT> srcptr</TT>
and<TT> (t=0, t=strlen(srcptr))</TT> respectively.
<BR><BR>This form of macro is also useful for &quot;commenting out&quot; a function call that is used for debugging the program.
&nbsp;For example,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define alive( where ) printf( &quot;Alive at&quot; where &quot;\n&quot; )</TT>
<BR><BR>could later be replaced by,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define alive( where ) /* */</TT>
<BR><BR>Alternatively, the definition,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define alive( where )</TT>
<BR><BR>may be used.&nbsp; When the module or program is recompiled using this new definition for<TT> alive</TT>, all of the
calls to <TT> printf</TT> made as a result of the macro replacement will disappear, without the necessity of deleting the
appropriate lines in each module.
<BR><BR>A directive of the form, 
<BR><BR><B>&nbsp; </B><TT> #undef</TT><B> identifier</B>
<BR><BR>causes the macro definition for<B> identifier</B> to be thrown away.&nbsp; No error is reported if no macro definition
for<B> identifier</B> exists.
<H2 ID="Argument_Substitution"> Argument Substitution </H2>
<BR>The argument substitution capabilities of the C preprocessor are very powerful, but can be tricky.&nbsp; The following
sections illustrate the capabilities, and try to shed light on the problems that might be encountered.
<H3 ID="Converting_An_Argument_to_a_String"> Converting An Argument to a String </H3>
<BR>In the replacement-string for a function-like macro, each occurrence of <TT> #</TT> must be followed by a parameter to
the macro.&nbsp; If so, both the<TT> #</TT> and the parameter are replaced by a string created from the characters of the
argument itself, with no further substitutions performed on the argument.&nbsp; Each white space within the argument is converted
to a single blank character.&nbsp; If the argument contains a character constant or string literal, any occurrences of<TT>
&quot;</TT> (double-quote) are replaced by<TT> \&quot;</TT>, and any occurrences of<TT> \</TT> (backslash) are replaced by<TT>
\\</TT>.
<BR><BR>The following table gives a number of examples of the result of the application of the macro,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define string( parm ) # parm</TT>
<BR><BR>as shown in the first column:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Argument&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;After Substitution</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ---------------------&nbsp;&nbsp; ------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; string( abc )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;abc&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; string( &quot;abc&quot; )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;\&quot;abc\&quot;&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; string( &quot;abc&quot; &quot;def&quot; )&nbsp;&nbsp; &quot;\&quot;abc\&quot; \&quot;def\&quot;&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; string( \'/ )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;\\'/&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; string( f(x) )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;f(x)&quot;</TT>
<H3 ID="Concatenating_Tokens"> Concatenating Tokens </H3>
<BR>In the replacement-list, if a parameter is preceded or followed by <TT> ##</TT>, then the parameter is replaced by the
argument itself, without examining the argument for any further replacements.&nbsp; After all such substitutions, each<TT>
##</TT> is removed and the tokens on either side are concatenated together.&nbsp; The newly formed token is then examined
for further macro replacement.
<BR><BR><TT>##</TT> may not be either the first or last token in the replacement-list.
<BR><BR>Assuming that the following macros are defined,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define first&nbsp;&nbsp;&nbsp;&nbsp; &quot;Piece&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define last&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;of Earth&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define firstlast &quot;Peace on Earth&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define first1&nbsp;&nbsp;&nbsp; &quot;Peas&quot;</TT>
<BR><BR>the following table gives a number of examples of the result of the application of the macro,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define glue( x, y ) x ## y</TT>
<BR><BR>as shown in the first column.&nbsp; For the examples that span several lines, each successive line of the &quot;Result&quot;
column indicates successive expansions of the macros.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Argument&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; After
Substitution</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -------------------&nbsp;&nbsp; ------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; glue( 12, 34 )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1234</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; glue( first, 1 )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; first1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;Peas&quot;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; glue( first, 2 )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; first2</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; glue( first, last )&nbsp;&nbsp; firstlast</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;Peace on Earth&quot;</TT>
<H3 ID="Simple_Argument_Substitution"> Simple Argument Substitution </H3>
<BR>In the absence of either the<TT> #</TT> or<TT> ##</TT> operators, a parameter is replaced by its argument.&nbsp; Before
this happens, however, the argument is scanned again to see if there are any further macro substitutions to be made, applying
all of the above rules.&nbsp; The rescanning applies<B> only</B> to the argument, not to any other tokens that might be adjacent
to the argument when it replaces the parameter.&nbsp; In other words, if the last token of the argument and the first token
following in the replacement list together form a valid macro, no substitution of that macro will take place.
<BR><BR>Consider the following examples, with these macro definitions in place:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define f(a)&nbsp;&nbsp; a</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define g(x)&nbsp;&nbsp; (1+x)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define h(s,t) s t</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define i(y)&nbsp;&nbsp; 2-y</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define xyz&nbsp;&nbsp;&nbsp; printf</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define rcrs&nbsp;&nbsp; rcrs+2</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Invocation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
After Substitution</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ---------------------&nbsp;&nbsp; --------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; f(c)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; c</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; f(f(c))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; f(c)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; f(g(c))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; f((1+c))</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1+c)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; h(&quot;hello&quot;,f(&quot;there&quot;))&nbsp;&nbsp; h(&quot;hello&quot;,&quot;there&quot;)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;hello&quot; &quot;there&quot;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; f(xyz)(&quot;Hello\n&quot;)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f(printf)(&quot;Hello\n&quot;)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;Hello\n&quot;)</TT>
<H3 ID="Variable_Argument_Macros"> Variable Argument Macros </H3>
<BR>Macros may be defined to take optional additional parameters.&nbsp; This is accomplished using the<TT> ...</TT>&nbsp;
(ellipsis) keyword as the last parameter in the macro declaration.&nbsp; There may be no further parameters past the variable
argument, and errors will be generated if the preprocessor finds anything other than a closing parenthesis after the ellipsis.
&nbsp;The variable arguments may be referenced as a whole using the <TT> __VA_ARGS__</TT> keyword.&nbsp; Special behavior
of pasting this parameter with a comma can result in the comma being removed (this is an extension to the standard).&nbsp;
The only token to which this applies is a comma.&nbsp; Any other token which <TT> __VA_ARGS__</TT> is pasted with is not removed.
&nbsp;The <TT> __VA_ARGS__</TT> parameter may be converted to a string using the<TT> #</TT> operator.&nbsp; Consider the following
examples of macros with variable number of arguments:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define shuffle1( a, b, ... )&nbsp; b,__VA_ARGS__##,a</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define shuffle2( a, b, ... )&nbsp; b,## __VA_ARGS__,a</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define shuffle3( a, b, ... )&nbsp; b,## __VA_ARGS__##,a</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define showlist( ... )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #__VA_ARGS__</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define args( f, ... )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __VA_ARGS__</TT>
<BR><BR>It is safe to assume that any time a comma is used near <TT> __VA_ARGS__</TT> the<TT> ##</TT> operator should be used
to paste them together.&nbsp; Both<TT> shuffle1</TT> and<TT> shuffle2</TT> macros are valid examples of pasting <TT> __VA_ARGS__</TT>
together with a comma; either the leading or trailing comma may be concatenated, and if <TT> __VA_ARGS__</TT> is empty, the
comma is removed.&nbsp; The macro<TT> shuffle3</TT> works as well; the sequence of concantenations happens from left to right,
hence first the comma and empty <TT> __VA_ARGS__</TT> are concantenated and both are removed, afterwards the trailing comma
is concatentated with<TT> b.</TT>&nbsp; Several example usages of the above macros follow:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Invocation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
After Substitution</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ---------------------&nbsp;&nbsp; --------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; shuffle(x,y,z)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y,z,x</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; shuffle(x,y)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y,x&nbsp;
&nbsp;&nbsp; // second ',' dissappears</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; shuffle(a,b,c,d,e)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b,c,d,e,a</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; showlist(x,y,z)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;x,y,z&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; args(&quot;%s&quot;,charptr)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; charptr</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; args(&quot;%d+%d=%d&quot;,a,b,c)&nbsp; a,b,c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; args(&quot;none&quot;)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // nothing</TT>
<H3 ID="Rescanning_for_Further_Replacement"> Rescanning for Further Replacement </H3>
<BR>After all parameters in the replacement-list have been replaced, the resulting set of tokens is re-examined for any further
replacement.&nbsp; If, during this scan, an apparent invocation of the macro currently being replaced is found, it is<B> not</B>
replaced.&nbsp; Further invocations of the macro currently being replaced are not eligible for replacement until a new set
of tokens from the source file, unrelated to the tokens resulting from the current substitution, are being processed.
<BR><BR>Consider these examples, using the above macro definitions:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Invocation&nbsp;&nbsp;&nbsp; After Rescanning</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -----------&nbsp;&nbsp; ----------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; f(g)(r)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g(r)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1+r)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; f(f)(r)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f(r)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; h(f,(b))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f (b)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; i(h(i,(b)))&nbsp;&nbsp; i(i (b))</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2-i (b)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; i(i (b))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i(2-b)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2-2-b</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; rcrs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rcrs+2</TT>
<BR><BR>In other words, if an apparent invocation of a macro appears, and its name matches the macro currently being replaced,
and the apparent invocation was<B> manufactured</B> by other replacements, it is<B> not</B> replaced.&nbsp; If, however, the
apparent invocation comes directly from an argument to the macro replacement, then it<B> is</B> replaced.
<BR><BR>After all replacements have been done, the resulting set of tokens replaces the invocation of the macro in the source
file, and the file is then rescanned starting at the replacement-list.&nbsp; Any further macro invocations are then replaced.
&nbsp;However, if as a result of scanning the replacement-list with following tokens another apparent invocation of the macro
just replaced is found, then that macro name is<B> not</B> replaced.&nbsp; An invocation of the macro will again be replaced
only when a new invocation of the macro is found, unrelated to the just-replaced macro.
<BR><BR>If the replacement-list of tokens resembles a preprocessor directive, the preprocessor will not process it.
<BR><BR>A macro definition lasts until it is undefined (with <TT> #undef</TT>) or until the end of the module.
<H2 ID="More_Examples_of_Macro_Replacement"> More Examples of Macro Replacement </H2>
<BR>The following examples are given in the ISO C standard, and are presented here as a complete guide to the way in which
macros are replaced.&nbsp; The expansions are shown in stages to better illustrate the process.
<BR><BR>The first set of examples illustrates the rules for creating string literals (using the<TT> #</TT> operator) and concatenating
tokens (using the<TT> ##</TT> operator).&nbsp; The following definitions are used:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define str(s)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # s</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define xstr(s)&nbsp;&nbsp;&nbsp;&nbsp; str(s)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define debug(s, t) printf(&quot;x&quot; # s &quot;= %d, x&quot; # t &quot;= %s&quot;, x
## s, x ## t )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define INCFILE(n)&nbsp; vers ## n&nbsp; /* comment */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define glue(a, b)&nbsp; a ## b</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define xglue(a, b) glue(a, b)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define HIGHLOW&nbsp;&nbsp;&nbsp;&nbsp; &quot;hello&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define LOW&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOW &quot;, world&quot;</TT>
<BR><BR>The following replacements are made.&nbsp; The final result shows adjacent string literals joined together to form
a single string.&nbsp; This step is not actually part of the preprocessor stage, but is given for clarity.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; debug( 1, 2 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;x&quot; &quot;1&quot; &quot;= %d, x&quot; &quot;2&quot; &quot;=
%s&quot;, x1, x2 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;x1= %d, x2= %s&quot;, x1, x2 );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; fputs(str(strncmp(&quot;abc\0d&quot;, &quot;abc&quot;, '\4') /* this goes away */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; == 0) str(: @\n), s);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fputs(&quot;strncmp(\&quot;abc\\0d\&quot;, \&quot;abc\&quot;, '\\4') ==
0&quot; &quot;: @\n&quot;, s);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fputs(&quot;strncmp(\&quot;abc\\0d\&quot;, \&quot;abc\&quot;, '\\4') ==
0: @\n&quot;, s);</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include xstr(INCFILE(2).h)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include xstr(vers2.h)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include str(vers2.h)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &quot;vers2.h&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>(and then the directive is replaced by the file contents)
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; glue(HIGH, LOW)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HIGHLOW</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;hello&quot;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; xglue(HIGH, LOW)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xglue(HIGH, LOW &quot;, world&quot;)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glue( HIGH, LOW &quot;, world&quot;)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HIGHLOW &quot;, world&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;hello&quot; &quot;, world&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;hello, world&quot;</TT>
<BR><BR>The following examples illustrate the rules for redefinition and re-examination of macros.&nbsp; The following definitions
are used:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define x&nbsp;&nbsp;&nbsp; 3</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define f(a) f(x * (a))</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #undef&nbsp; x</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define x&nbsp;&nbsp;&nbsp; 2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define g&nbsp;&nbsp;&nbsp; f</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define z&nbsp;&nbsp;&nbsp; z[0]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define h&nbsp;&nbsp;&nbsp; g(~</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define m(a) a(w)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define w&nbsp;&nbsp;&nbsp; 0,1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define t(a) a</TT>
<BR><BR>The following substitutions are made:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; f(y+1) + f(f(z)) % t(t(g)(0) + t)(1)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; f(x * (y+1)) + ...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; f(2 * (y+1)) + f(f(z)) % t(t(g)(0) + t)(1)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + f(f(x * (z))) % ...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + f(f(2 * (z))) % ...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + f(x * (f(2 * (z)))) % ...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + f(2 * (f(2 * (z)))) % ...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + f(2 * (f(2 * (z[0])))) % t(t(g)(0)
+ t)(1)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; % t(g(0) + t)(1)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; % t(f(0) + t)(1)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; % t(f(x * (0))
+ t)(1)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; % t(f(2 * (0))
+ t)(1)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; f(2 * (y+1)) + f(2 * (f(2 * (z[0])))) % f(2 * (0)) + t(1)</TT>
<BR><BR>Another example:
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; g(2+(3,4)-w) | h 5) &amp; m(f)^m(m)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; f(2+(3,4)-w) | ...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; f(2+(3,4)-0,1) | ...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; f(x * (2+(3,4)-0,1)) | ...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; f(2 * (2+(3,4)-0,1)) | h 5) &amp; ...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; | g(~ 5) &amp; ...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; | f(~ 5) &amp; ...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; | f(x * (~ 5)) &amp; ...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; | f(2 * (~ 5)) &amp; m(f)^...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp; f(w)^...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp; f(0,1)^...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp; f(x * (0,1))^...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp; f(2 * (0,1))^m(m)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^m(w)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; f(2 * (2+(3,4)-0,1)) | f(2 * (~ 5)) &amp; f(2 * (0,1))^m(0,1)</TT>
<H2 ID="Redefining_a_Macro"> Redefining a Macro </H2>
<BR>Once a macro has been defined, its definition remains until it is explicitly undefined (using the <TT> #undef</TT> directive),
or until the compilation of the source file is finished.&nbsp; If a macro is undefined, then it may be redefined in some other
(or the same) way.&nbsp; If, during a macro replacement, the name of a macro that has been defined, undefined and then defined
again is encountered, the current (most recent) definition of the macro is used,<B> not</B> the one that was in effect when
the macro being replaced was defined.
<BR><BR>Consider this example:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define MAXVAL 1000</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define g(x)&nbsp;&nbsp; CheckLimit( x, MAXVAL )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #undef&nbsp; MAXVAL</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define MAXVAL 200</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; g( 10 );</TT>
<BR><BR>This macro invocation expands to,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CheckLimit( 10, 200 );</TT>
<BR><BR>A macro that has been defined may be redefined (without undefining it first) only if the new definition has a replacement-list
that is identical to the original definition.&nbsp; Each preprocessing token in both the original and new replacement lists
must have the same ordering and spelling, and there must be the same number of tokens.&nbsp; The number of spaces between
tokens does not matter, unless one definition has no spaces, and the other has spaces.&nbsp; Comments count as one space.
<BR><BR>The following examples illustrate valid redefinitions of macros:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define OBJ_LIKE&nbsp;&nbsp;&nbsp;&nbsp; (1-1)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define OBJ_LIKE&nbsp;&nbsp;&nbsp;&nbsp; /******/ (1-1) /****/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define FN_LIKE(a)&nbsp;&nbsp; ( a )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define FN_LIKE( a ) (&nbsp;&nbsp;&nbsp; /******/ \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a&nbsp; /******* \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */ )</TT>
<BR><BR>The next examples illustrate invalid redefinitions of the same macros:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define OBJ_LIKE&nbsp;&nbsp;&nbsp;&nbsp; (0)</TT>
<BR><BR>&nbsp;&nbsp;&nbsp; The token sequence is different.
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define OBJ_LIKE&nbsp;&nbsp;&nbsp;&nbsp; (1 - 1)</TT>
<BR><BR>&nbsp;&nbsp;&nbsp; The spacing is different (none versus one).
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define FN_LIKE(b)&nbsp;&nbsp; ( a )</TT>
<BR><BR>&nbsp;&nbsp;&nbsp; The parameter is a different name, and is used differently.
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define FN_LIKE(b)&nbsp;&nbsp; ( b )</TT>
<BR><BR>&nbsp;&nbsp;&nbsp; The parameter is a different name.
<H2 ID="Changing_the_Line_Numbering_and_File_Name"> Changing the Line Numbering and File Name </H2>
<BR>A directive of the form, 
<BR><BR><B>&nbsp; </B><TT> #line</TT><B> number</B>
<BR><BR>sets the line number that the compiler associates with the current line in the source file to the specified number.
<BR><BR>A directive of the form,
<BR><BR><B>&nbsp; </B><TT> #line</TT><B> number string</B>
<BR><BR>sets the line number as above and also sets the name that the compiler associates with the source file that is being
read to the name contained in the string.
<BR><BR>If the directive is not recognized as one of the two forms described above, then macro substitution is performed (if
possible) on the tokens on the line, and another attempt is made.&nbsp; If the directive still does not match one of the two
forms, an error is reported.
<H2 ID="Displaying_a_Diagnostic_Message"> Displaying a Diagnostic Message </H2>
<BR>A directive of the form, 
<BR><BR><B>&nbsp; </B><TT> #error</TT><B> tokens</B>
<BR><BR>causes the compiler to display a diagnostic message containing the tokens from the directive.
<H2 ID="Providing_Other_Information_to_the_Compiler"> Providing Other Information to the Compiler </H2>
<BR>A directive of the form, 
<BR><BR><B>&nbsp; </B><TT> #pragma</TT><B> tokens</B>
<BR><BR>informs the compiler about some aspect of the compilation, in an implementation-defined manner.
<BR><BR>A pragma operator of the form, 
<BR><BR><B>&nbsp; </B><TT> _Pragma</TT><B> ( string-literal )</B>
<BR><BR>is an alternative method of specifying #pragma directives.&nbsp; For example, the following two statements are equivalent.
<BR><BR><B>&nbsp; _Pragma( &quot;library (\&quot;kernel32.lib\&quot;)&quot; )</B>
<BR><B>&nbsp; #pragma library (&quot;kernel32.lib&quot;)</B>
<BR>The _Pragma operator can be used in macro definition.
<BR><BR><B>&nbsp; # define LIBRARY(X) PRAGMA(library (#X))</B>
<BR><B>&nbsp; # define PRAGMA(X) _Pragma(#X)</B>
<BR><B>&nbsp; LIBRARY(kernel32.lib) // same as #pragma library (&quot;kernel32.lib&quot;)</B>
<BR><BR><B>&nbsp; See the User's Guide for full details of the </B><TT> #pragma</TT><B> directive.</B>
<H2 ID="Standard_Predefined_Macros"> Standard Predefined Macros </H2>
<BR>The following macro names are reserved by the compiler:
<BR><BR><TT> __DATE__</TT>
<BR><BR>&nbsp;&nbsp;&nbsp; The date of translation of the source file (a string literal).&nbsp; The form of the date is &quot;Mmm
dd yyyy&quot; where:
<DL>
<DT>Mmm
<DD>represents the month and is one of:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Jan&nbsp; Feb&nbsp; Mar&nbsp; Apr&nbsp; May&nbsp; Jun</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Jul&nbsp; Aug&nbsp; Sep&nbsp; Oct&nbsp; Nov&nbsp; Dec</TT>
<DT>dd
<DD>is the day of the month.&nbsp; The first character is a blank if the day is less than 10.
<DT>yyyy
<DD>is the year.
</DL>
<BR>If the compiler cannot determine the current date, another date is provided.
<BR><BR><B>&nbsp; With Open Watcom C/16 and C/32, the current date is always available.</B>
<BR><BR><TT> __FILE__</TT>
<BR><BR>The name of the current source file (a string literal).&nbsp; The name may be changed using the <TT> #line</TT> directive.
<BR><BR><TT> __LINE__</TT>
<BR><BR>The line number of the current source line (a decimal constant).&nbsp; The line number may be changed using the <TT>
#line</TT> directive.
<BR><BR><TT> __STDC__</TT>
<BR><BR>The integer constant 1, indicating that the compiler is a standard-conforming implementation.
<BR><BR><TT> __STDC_HOSTED__</TT>
<BR><BR>The integer constant 1, indicating that the compiler is a hosted (not freestanding) implementation.
<BR><BR><TT> __STDC_LIB_EXT1__</TT>
<BR><BR>The long integer constant 200509L, indicating conformance to the ISO/IEC Technical Report 24731, Extensions to the
C Library, Part I:&nbsp; Bounds-checking interfaces.
<BR><BR><TT> __STDC_VERSION__</TT>
<BR><BR>A decimal constant indicating the version of ISO C language standard that the compiler adheres to.&nbsp; Depending
on compile time switches, this will be either 199901L (to indicate conformance with ISO/IEC 9899:1999) or 199409L (to indicate
conformance with ISO/IEC 9899/AMD1:1995).
<BR><BR><TT> __TIME__</TT>
<BR><BR>The time of translation of the source file (a string literal).&nbsp; The form of the time is &quot;hh:mm:ss&quot;,
with leading zeros provided for values less than 10.
<BR>If the compiler cannot determine the current time, another time is provided.
<BR><BR><B>&nbsp; With Open Watcom C/16 and C/32, the current time is always available.</B>
<BR><BR><TT> __func__</TT>
<BR><BR>The name of the current function (a string literal).
<BR><BR>Any other macros predefined by the compiler will begin with an underscore (_) character.&nbsp; None of the predefined
macros, nor the identifier<TT> defined</TT>, may be undefined (with <TT> #undef</TT>) or redefined (with <TT> #define</TT>).
<H2 ID="Open_Watcom_CD16_and_CD32_Predefined_Macros"> Open Watcom C/16 and C/32 Predefined Macros </H2>
<BR>The Open Watcom C/16 and C/32 compilers also provide the following predefined macros for describing the memory model being
used:
<BR><BR><TT> __COMPACT__</TT>
<BR><BR>&nbsp;&nbsp;&nbsp; The compact memory model is being used.&nbsp; 
<BR><TT> __FLAT__</TT>
<BR><BR>&nbsp;&nbsp;&nbsp; The &quot;flat&quot; memory model is being used for the 80386 processor.&nbsp; All segment registers
refer to the same segment.
<BR><TT> __FUNCTION__</TT>
<BR><BR>&nbsp;&nbsp;&nbsp; The name of the current function (a string literal).
<BR><TT> __HUGE__</TT>
<BR><BR>&nbsp;&nbsp;&nbsp; The huge memory model is being used.&nbsp; 
<BR><TT> __LARGE__</TT>
<BR><BR>&nbsp;&nbsp;&nbsp; The large memory model is being used.&nbsp; 
<BR><TT> __MEDIUM__</TT>
<BR><BR>&nbsp;&nbsp;&nbsp; The medium memory model is being used.&nbsp; 
<BR><TT> __SMALL__</TT>
<BR><BR>&nbsp;&nbsp;&nbsp; The small memory model is being used.&nbsp; 
<BR>The Open Watcom C/16 and C/32 compilers also provide the following macros for describing the target operating system:
<BR><BR><TT> __DOS__</TT>
<BR><BR>&nbsp;&nbsp;&nbsp; The program is being compiled for use on a DOS operating system.
<BR><TT> __NETWARE_386__</TT>
<BR><BR>&nbsp;&nbsp;&nbsp; The program is being compiled for use on the Novell Netware 386 operating system.
<BR><TT> __NT__</TT>
<BR><BR>&nbsp;&nbsp;&nbsp; The program is being compiled for use on the Windows NT operating system.
<BR><TT> __OS2__</TT>
<BR><BR>&nbsp;&nbsp;&nbsp; The program is being compiled for use on the OS/2 operating system.
<BR><TT> __QNX__</TT>
<BR><BR>&nbsp;&nbsp;&nbsp; The program is being compiled for use on the QNX operating system.
<BR><TT> __WINDOWS__</TT>
<BR><BR>&nbsp;&nbsp;&nbsp; The program is being compiled for use with Microsoft Windows.
<BR><TT> __WINDOWS_386__</TT>
<BR><BR>&nbsp;&nbsp;&nbsp; The program is being compiled for use with Microsoft Windows, using the Open Watcom 32-bit Windows
interface.
<BR>The Open Watcom C/16 compiler also provides the following miscellaneous macro:
<BR><BR><TT> __CHEAP_WINDOWS__</TT>
<BR><BR>&nbsp;&nbsp;&nbsp; The program is being compiled for use with Microsoft Windows using the &quot;zW&quot; compiler
option.
<BR><BR>The Open Watcom C/16 and C/32 compilers also provide the following miscellaneous macros:
<BR><TT> __CHAR_SIGNED__</TT>
<BR><BR>&nbsp;&nbsp;&nbsp; The program is being compiled using the &quot;j&quot; compiler option.&nbsp; The default<TT> char</TT>
type is treated as a signed quantity.
<BR><TT> __FPI__</TT>
<BR><BR>&nbsp;&nbsp;&nbsp; The program is being compiled using in-line floating point instructions.
<BR><TT> __INLINE_FUNCTIONS__</TT>
<BR><BR>&nbsp;&nbsp;&nbsp; The program is being compiled using the &quot;oi&quot; compiler option.
<BR><BR><TT> __WATCOMC__</TT>
<BR>&nbsp;&nbsp;&nbsp; The compiler being used is the Open Watcom C/16 or Open Watcom C/32 compiler.&nbsp; The value of the
macro is the version number of the compiler times 100.
<BR><TT> __386__</TT>
<BR><BR>&nbsp;&nbsp;&nbsp; The program is being compiled for the 80386 processor, using the Open Watcom C/32 compiler.
<BR>The Open Watcom C/16 and C/32 compilers also provide the following predefined macros for compatibility with the Microsoft
C compiler, even though most of these macros do not begin with an underscore (_) character:
<BR><BR><TT> MSDOS</TT>
<BR><BR>&nbsp;&nbsp;&nbsp; The program is being compiled for use on a DOS operating system.
<BR><TT> _M_IX86</TT>
<BR><BR>&nbsp;&nbsp;&nbsp; The program is being compiled for a specific target architecture.&nbsp; The macro is identically
equal to 100 times the architecture compiler option value (-0, -1, -2, -3, -4, -5, etc.).&nbsp; If &quot;-5&quot; (Pentium
instruction timings) was specified as a compiler option, then the value of<TT> _M_IX86</TT> would be 500.
<BR><TT> M_I86</TT>
<BR><BR>&nbsp;&nbsp;&nbsp; The program is being compiled for use on the Intel 80x86 processor.
<BR><TT> M_I386</TT>
<BR><BR>&nbsp;&nbsp;&nbsp; The program is being compiled for use on the Intel 80386 processor.
<BR><TT> M_I86CM</TT>
<BR><BR>&nbsp;&nbsp;&nbsp; The compact memory model is being used.&nbsp; 
<BR><TT> M_I86HM</TT>
<BR><BR>&nbsp;&nbsp;&nbsp; The huge memory model is being used.&nbsp; 
<BR><TT> M_I86LM</TT>
<BR><BR>&nbsp;&nbsp;&nbsp; The large memory model is being used.&nbsp; 
<BR><TT> M_I86MM</TT>
<BR><BR>&nbsp;&nbsp;&nbsp; The medium memory model is being used.&nbsp; 
<BR><TT> M_I86SM</TT>
<BR><BR>&nbsp;&nbsp;&nbsp; The small memory model is being used.&nbsp; 
<BR><BR><TT> NO_EXT_KEYS</TT>
<BR>&nbsp;&nbsp;&nbsp; The program is being compiled for ISO/ANSI conformance using the &quot;za&quot; (no extended keywords)
compiler option.
<H2 ID="The_offsetof_Macro"> The offsetof Macro </H2>
<BR>The macro, 
<BR><BR><TT>&nbsp; offsetof(</TT><B> type, member</B><TT> );</TT>
<BR><BR>expands to a constant expression with type <TT> size_t</TT>.&nbsp; The value of the expression is the offset in bytes
of<B> member</B> from the start of the structure<B> type</B>.<B>&nbsp; member</B> should not be a bit-field.
<BR><BR>To use this macro, include the <TT> &lt;stddef.h&gt;</TT> header.
<H2 ID="The_NULL_Macro"> The NULL Macro </H2>
<BR>The <TT> NULL</TT> macro expands to a <B> null pointer constant,</B> which is a value that indicates a pointer does not
currently point to anything.
<BR><BR>It is recommended that <TT> NULL</TT>, instead of 0, be used for null pointer constants.
<BR><BR>To use this macro, include the <TT> &lt;stddef.h&gt;</TT> header.
<H1 ID="The_Order_of_Translation"> The Order of Translation </H1>
<BR>This chapter describes the sequence of steps that the C compiler takes in order to translate a set of source files.&nbsp;
Most programmers do not need to thoroughly understand these steps, as they are intuitive.&nbsp; However, occasionally it will
be necessary to examine the sequence to solve a problem in the translation process.
<BR><BR>Even though the steps of translation are listed as separate phases, the compiler may combine them together.&nbsp;
However, this should be transparent to the user.
<BR><BR>The following are the phases of translation:
<OL>
<LI>The characters of the source file(s) are mapped to the source character set.&nbsp; Any end-of-line markers used in the
file system are translated, as necessary, to new-line characters.&nbsp; Any trigraphs are replaced by the appropriate single
character.
<LI>Physical source lines are joined together wherever a line is terminated by a backslash (<TT>\</TT>) character.&nbsp; Effectively,
the<TT> \</TT> and the new-line character are deleted, creating a longer line from that record and the one following.
<LI>The source is broken down into preprocessing tokens and sequences of &quot;white-space&quot; (space and tab) characters
(including comments).&nbsp; Each token is the longest sequence of characters that can be a token.&nbsp; Each comment is replaced
by one white-space character.&nbsp; The new-line characters are retained at this point.
<LI>Preprocessing directives are executed and macro invocations are substituted.&nbsp; A header named in a <TT> #include</TT>
directive is processed according to rules 1 to 4.
<LI>Members of the source character set and escape sequences in character constants and string literals are converted to single
characters in the execution character set.
<LI>Adjacent character string literal tokens and adjacent wide string literal tokens are concatenated.
<LI>White-space characters separating tokens are discarded.&nbsp; Each preprocessing token is converted to a token.&nbsp;
The tokens are translated according to the syntactic and semantic rules.
</OL>
<BR>The final phase usually occurs outside of the compilation phase.&nbsp; In this phase, often called the <B> linking</B>
phase, all external object definitions are resolved, and an executable program image is created.&nbsp; The completed image
contains all the information necessary to run the program in the appropriate execution environment.
<H1 ID="Modularity"> Modularity </H1>
<BR>For many small programs, it is possible to write a single module which contains all of the C source for the program.&nbsp;
This module can then be compiled, linked and run.
<BR><BR>However, for larger applications it is not possible to maintain one module with everything in it.&nbsp; Or, if it
is technically possible, compiling such a large module every time a change is made to the source carries too great a time
penalty with it.&nbsp; At this point, it becomes necessary to break the program into pieces, or modules.
<BR><BR>Dividing a program can be done quite easily.&nbsp; If the only issue is to reduce the size of the modules that need
to be compiled, then arbitrary divisions of the code into modules will accomplish the goal.
<BR><BR>There are other advantages, however, to planning program modularity.&nbsp; Some of these advantages are:
<UL>
<LI>recompilation time is reduced,
<LI>code can be grouped into logically-connected areas, making it easier to find things,
<LI>data structures can be hidden in one module, avoiding the temptation of letting an outside piece of code &quot;peek&quot;
into a structure it really should not access directly,
<LI>whole modules can be rewritten or redesigned without affecting other modules,
<LI>areas of the code that depend on the hardware or operating system can be isolated for easy replacement when the program
is ported.&nbsp; This may extend to replacing the module with an assembly language equivalent for increased performance.
</UL>
<BR>The following sections discuss each of these points in more detail.
<H2 ID="Reducing_Recompilation_Time"> Reducing Recompilation Time </H2>
<BR>As discussed above, merely breaking a program into pieces will reduce the amount of time spent recompiling the source.
&nbsp;A bug is often a simple coding error, requiring only a one or two line change.&nbsp; Recompiling only a small percentage
of the code and relinking will be faster than recompiling everything.
<BR><BR>Occasionally, recompiling all of the modules will be required.&nbsp; This usually arises when a data structure, constant,
macro or other item that is used by several modules is changed.&nbsp; With good program design, such a change would occur
in a header file, and all modules that include that header would be recompiled.
<H2 ID="Grouping_Code_With_Related_Functionality"> Grouping Code With Related Functionality </H2>
<BR>The best way to break programs into modules is to designate each module as having some overall purpose.&nbsp; For example,
one module may deal exclusively with interacting with the user.&nbsp; Another module may manage a table of names, while yet
another may process some small subset of the set of actions that may be performed by the program.
<BR><BR>Many of the modules then become <B> resource managers,</B> and every part of the code that needs to do something significant
with that resource must act through that resource manager.
<BR><BR>Using the example of the names table manager, it is likely that the manager will need to do things like create and
delete a name entry in the table.&nbsp; These actions would translate directly to two functions with external linkage.
<BR><BR>By dividing up a program along lines of related functionality, it is usually easy to know where to look when a problem
is being tracked.
<BR><BR>Module names that clearly state the purpose of the module also help to locate things.
<H2 ID="Data_Hiding"> Data Hiding </H2>
<BR>Sometimes a module is written that has exclusive ownership of a data structure, such as a linked list.&nbsp; All other
modules that wish to access the structure must call a function in the module that owns it.&nbsp; This technique is known as<B>
data hiding.</B>&nbsp; The actual data is hidden in the structure, and only the <B> functional interface</B> (also called
the <B> procedural interface)</B> may be used to access it.&nbsp; The functional interface is just the set of functions provided
for accessing the structure.
<BR><BR>The main advantage of data hiding is that the data structure may be changed with little or no impact on other modules.
&nbsp;Also, access to the structure is controlled, leading to fewer errors because of misuse of the structure.
<BR><BR>It is possible to have different levels of data hiding.&nbsp; Complete data hiding occurs when no outside module has
access to the structure at all.&nbsp; Partial data hiding occurs when elements of the structure can be accessed, but the overall
structure may not be manipulated.
<BR><BR>Note that these rules work only if the programmer respects them.&nbsp; The rules are not enforced by the compiler.
&nbsp;If a module includes a header that describes the data structures being used by another module that wants exclusive access
to the structures, a rule is being broken.&nbsp; Whether this is good or bad depends entirely on the judgement of the programmer.
<H3 ID="Complete_Data_Hiding"> Complete Data Hiding </H3>
<BR>With complete data hiding, having a pointer to an element of the structure has no intrinsic value except as a parameter
to the functional interface.&nbsp; Getting or setting a value in the structure requires a function call.
<BR><BR>The advantage of this technique is that the complete data structure may be totally redesigned without affecting other
modules.&nbsp; The definitions of the individual structures (<TT> struct</TT>'s, <TT> union</TT>'s, arrays) may be changed
and no other module will have to be changed, or even recompiled.
<BR><BR>The main disadvantage of complete data hiding is that even simple accesses require a function call, which is less
efficient than just referencing a storage location.
<BR><BR>Function-like macros may also be used to implement complete data hiding, avoiding the function call but hiding the
true structure of the data.&nbsp; Recompilation of all modules may be required if the data structures change.
<H3 ID="Partial_Data_Hiding"> Partial Data Hiding </H3>
<BR>Partial data hiding occurs when the structure itself (for example, a linked list) is not accessible in its entirety, but
elements of the structure (an element of the linked list) are accessible.
<BR><BR>Using the names table manager as an example, it may be necessary to call the names table manager to create a name
entry, but once the name is created, a pointer to the name is returned as the return value of the create function.&nbsp; This
pointer points to a structure which is defined in a header that any module can include.&nbsp; Therefore, the contents of an
element of the data structure can be manipulated directly.
<BR><BR>This method is more efficient than the complete data hiding technique.&nbsp; However, when the structure used for
the names table is changed, all modules that refer to that structure must be recompiled.
<H2 ID="Rewriting_and_Redesigning_Modules"> Rewriting and Redesigning Modules </H2>
<BR>With modular program design and data hiding, it is often possible to completely replace a module without affecting others.
&nbsp;This is usually only possible when the functional interface does not change.&nbsp; With partial data hiding, the actual
types used to implement the structure would have to remain unchanged, otherwise at least a recompilation would be required.
&nbsp;Changing a <TT> struct</TT>, for example, would probably require a recompilation if only the types changed, or new members
were added.&nbsp; If, however, the names of the members changed, or some other fundamental change occurred, then source code
changes in these other modules would be necessary.
<H2 ID="Isolating_System_Dependent_Code_in_Modules"> Isolating System Dependent Code in Modules </H2>
<BR>System dependencies are only relevant if the program being developed is to be run on different computers or operating
systems.&nbsp; Isolating system dependent code is discussed more thoroughly in the chapter &quot;Writing Portable Programs&quot;.
<BR><BR>It is quite difficult, sometimes, to identify what constitutes system dependent code.&nbsp; The first time a program
is ported to a new system, a number of problem areas usually arise.&nbsp; These areas should be carefully examined, and the
code that is dependent on the host environment should be isolated.&nbsp; Isolation may be accomplished by placing the code
in a separate module marked as system dependent, or by placing macros in the code to compile differently for the different
systems.
<H1 ID="Writing_Portable_Programs"> Writing Portable Programs </H1>
<BR>Portable software is software that is written in such a way that it is relatively easy to get the software running on
a new and different computer.&nbsp; By choosing the C language, the first step has been taken to reduce the effort involved
in porting, but there are many other things that must be done.&nbsp; Some of these things include:
<UL>
<LI>isolating the portions of the code that depend on the hardware or operating system being used,
<LI>being aware of what features of the C language are implementation-defined and avoiding them, or taking them into account,
<LI>being aware of the various ranges of values that may be stored in certain types, and declaring objects appropriately,
<LI>being aware of special features available on some systems that might be useful.
</UL>
<BR>No programmer can seriously expect to write a large portable program the first time.&nbsp; The first port of the program
will take a significant period of time, but the final result will be a program which is much more portable than before.&nbsp;
Generally, each subsequent port will be easier and take less time.&nbsp; Of course, if the new target system has a new concept
that was not considered in the original program design (such as a totally different user-interface), then porting will necessarily
take longer.
<H2 ID="Isolating_System_Dependent_Code"> Isolating System Dependent Code </H2>
<BR>The biggest problem when trying to port a program is to uncover all the places in the code where an assumption about the
underlying hardware or operating system was made, and which proves to be incorrect on the new system.&nbsp; Many of these
differences are hidden in library routines, but they can still cause problems.
<BR><BR>Consider, for example, the issue of distinguishing between alphabetic and non-alphabetic characters.&nbsp; The library
provides the function <TT> isalpha</TT> which takes a character argument and returns a non-zero value if the character is
alphabetic, and 0 otherwise.&nbsp; Suppose a programmer, writing a FORTRAN compiler, wanted to know if a variable name started
with the letters 'I' through 'N', in order to determine if it should be an integer variable.&nbsp; The programmer might write,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; upletter = toupper( name[0] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; if( upletter &gt;= 'I'&nbsp; &amp;&amp;&nbsp; upletter &lt;= 'N' ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* ... */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>If the program was being developed on a machine using the ASCII character set, this code would work fine, since the
upper case letters have 26 consecutive values.&nbsp; However, porting the program to a machine using the EBCDIC character
set, problems may arise because between the letters 'I' and 'J' are 7 other characters, including '}'.&nbsp; Thus, the name
&quot;}VAR&quot; might be considered a valid integer variable name, which it is not.&nbsp; To solve this problem, the programmer
could write,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; if( isalpha( name[0] ) ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; upletter = toupper( name[0] );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( upletter &gt;= 'I'&nbsp; &amp;&amp;&nbsp; upletter &lt;= 'N'
) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* ... */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>In this case, it is not necessary to isolate the code because a relatively simple coding change covers both cases.
&nbsp;But there are cases where each system will require a new set of functions for some aspect of the program.
<BR><BR>Consider the user interface of a program.&nbsp; If the program just displays lines of output to a scrolling terminal,
and accepts lines of input in the same way, the user interface probably won't need to change between systems.&nbsp; But suppose
the program has a sophisticated user interface involving full-screen presentation of data, windows, and menus, and uses a
mouse and the keyboard for input.&nbsp; In the absence of standards for such interfaces, it is quite likely that each system
will require a customized set of functions.&nbsp; Here is where program portability can become an art.
<BR><BR>An approach to this problem is to completely isolate the user interface code of the program.&nbsp; The processing
of data occurs independently of what appears on the screen.&nbsp; At the completion of processing, a function is called which
updates the screen.&nbsp; This code may or may not be portable, depending on how many layers of functions are built between
the physical screen and the generic program.&nbsp; At a level fairly close to the screen hardware, a set of functions should
be defined which perform the set of actions that the program needs.&nbsp; The full set of functions will depend extensively
on the requirements of the program, but they should be functions that can reasonably be expected to work on any system to
which the program will eventually be ported.
<BR><BR>Other areas that may be system dependent include:
<UL>
<LI>The behavior and capabilities of devices, including printers.&nbsp; Some printers support multiple fonts, expanded and
compressed characters, underlining, graphics, and so on.&nbsp; Others support only relatively simple text output.
<LI>Accessing memory regions outside of normally addressable storage.&nbsp; A good example is the Intel 80x86 family of processors.
&nbsp;With the Open Watcom C/16 16-bit compiler, the addressable storage is 1024 kilobytes, but a 16-bit address can only
address 64 kilobytes.&nbsp; Special steps must be taken when compiling in order to address the full storage space.&nbsp; Many
compilers for the 8086, including Open Watcom C/16 and C/32, introduce new keywords that describe pointer types beyond the
16-bit pointer.
<LI>Code that has been written in assembly language for speed.&nbsp; As code generation technology advances, assembly language
code should become less necessary.
<LI>Code that accesses some special feature of the system.&nbsp; As an example, many systems provide the ability to temporarily
exit to the operating system level, and later return to the program.&nbsp; The method of doing this varies between systems,
and the requirements of the program often change as well.
<LI>Handling the command line parameters.&nbsp; While C breaks the list of parameters down into strings, the interpretation
of those strings may vary between systems.&nbsp; A program probably should attempt to conform to any conventions of the system
on which it is being run.
<LI>Handling other startup requirements.&nbsp; Allocation of memory, initializing devices, and so on, may be done at this
point.
</UL>
<H2 ID="Beware_of_Long_External_Names"> Beware of Long External Names </H2>
<BR>According the C Language standard, a compiler may limit external names (functions and global objects) to 6 significant
characters.&nbsp; This limitation is often imposed by the &quot;linking&quot; stage of the development process.
<BR><BR>In practice, most systems allow many more significant characters.&nbsp; However, the developer of a portable program
should be aware of the potential for porting the program to a system that has a small limit, and name external objects accordingly.
<BR><BR>If the developer must port a program with many names that are not unique within the limitations imposed by the target
development system, the preprocessor may be used to provide shorter unique names for all objects.&nbsp; Note that this method
may seriously impair any symbolic debugging facilities provided by the development system.
<H2 ID="Avoiding_ImplementationMDefined_Behavior"> Avoiding Implementation-Defined Behavior </H2>
<BR>Several aspects of the code generated by the C compiler depend on the behavior of the particular C compiler being used.
&nbsp;A portable program should avoid these where possible, and take them into consideration where they can't be avoided.
&nbsp;It may be possible to use macros to avoid some of these issues.
<BR><BR>An important behavior that varies between systems is the number of characters of external objects and functions that
the system recognizes.&nbsp; The standard states that a system must recognize a minimum of 6 characters, although future standards
may remove or extend this limit.&nbsp; Most systems allow more than 6 characters, but several recognize only 8 characters.
&nbsp;For true portability, a function or object that has external linkage should be kept unique in the first 6 characters.
&nbsp;Sometimes this requires ingenuity when thinking of names, but developing a system for naming objects goes a long way
towards fitting within this restriction.&nbsp; The goal, of course, is to still have meaningful object names.&nbsp; If all
systems that will eventually be used have a higher limit, then the programmer may decide to go past the 6 character limit.
&nbsp;If a port is done to a system with the 6 character limit, a lot of source changes may be required.
<BR><BR>To solve this problem, macros could be used to map the actual function names into more cryptic names that fit within
the 6 character limit.&nbsp; This technique may have the adverse affect of making debugging very difficult because many of
the function and object names will not be the same as contained in the source code.
<BR><BR>Another implementation-defined behavior occurs with the type <TT> char</TT>.&nbsp; The standard does not impose a
<TT> signed</TT> or <TT> unsigned</TT> interpretation on the type.&nbsp; A program that uses an object of type <TT> char</TT>
that requires the values to be interpreted as signed or unsigned should explicitly declare the object with that type.
<H2 ID="Ranges_of_Types"> Ranges of Types </H2>
<BR>The range of an object of type <TT> int</TT> is not specified by the standard, except to say that the minimum range is<TT>
-</TT>32767 to 32767.&nbsp; If an object is to contain an integer value, then thought should be given as to whether or not
this range of values is acceptable on all systems.&nbsp; If the object is a counter that will never go outside the range 0
to 255, then the range will be adequate.&nbsp; However, if the object is to contain values that may exceed this range, then
a <TT> long int</TT> may be required.
<BR><BR>The same argument applies to objects with type <TT> float</TT>.&nbsp; It may make more sense to declare them with
type <TT> double</TT>.
<BR><BR>When converting floating-point numbers to integers, the rounding behavior can also vary between compilers and systems.
&nbsp;If it is important to know how the rounding behaves, then the program should refer to the macro<TT> FLT_ROUNDS</TT>
(defined in the header <TT> &lt;float.h&gt;</TT>), which is a value describing the type of rounding performed.
<H2 ID="Special_Features"> Special Features </H2>
<BR>Some systems provide special features that may or may not exist on other systems.&nbsp; For example, many provide the
ability to exit to the operating system, run some other programs, then return to the program that was running.&nbsp; Other
systems may not provide this ability.&nbsp; In an interactive program, this feature may be very useful.&nbsp; By isolating
the code that deals with this feature, a program may remain easily portable.&nbsp; On the systems that don't support this
feature, it may be necessary to provide a<B> stub</B> function which does nothing, or displays a message.
<H2 ID="Using_the_Preprocessor_to_Aid_Portability"> Using the Preprocessor to Aid Portability </H2>
<BR>The preprocessor is particularly useful for providing alternate code sequences to deal with portability issues.&nbsp;
Conditional compilation provided by the <TT> #if</TT> directive allows the insertion of differing code sequences depending
on some criteria.&nbsp; Defining a set of macros which describe the various systems, and another macro that selects a particular
system, makes it easy to add system-dependent code.
<BR><BR>For example, consider the macros,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define OS_DOS&nbsp;&nbsp;&nbsp; 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define OS_CMS&nbsp;&nbsp;&nbsp; 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define OS_MVS&nbsp;&nbsp;&nbsp; 2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define OS_OS2&nbsp;&nbsp;&nbsp; 3</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define OS_QNX&nbsp;&nbsp;&nbsp; 4</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define HW_IBMPC&nbsp; 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define HW_IBM370 1</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define PR_i8086&nbsp; 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define PR_370&nbsp;&nbsp;&nbsp; 1</TT>
<BR><BR>They describe a set of operating systems<TT> (OS)</TT>, hardware<TT> (HW)</TT> and processors<TT> (PR)</TT>, which
together can completely describe a computer and its operating system.&nbsp; If the program was being ported to a IBM 370 running
the MVS operating system, then it could include a header defining the macros above, and declare the macros,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define OPSYS&nbsp;&nbsp;&nbsp;&nbsp; OS_MVS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define HARDWARE&nbsp; HW_IBM370</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define PROCESSOR PR_370</TT>
<BR><BR>The following code sequence would include the call only if the program was being compiled for a 370 running MVS:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #if HARDWARE == HW_IBM370&nbsp; &amp;&amp;&nbsp; OPSYS == OS_MVS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DoMVSStuff( x, y );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #endif</TT>
<BR><BR>In other cases, code may be conditionally compiled based only on the hardware regardless of the operating system,
or based only on the operating system regardless of the hardware or processor.
<BR><BR>This technique may work well if used in moderation.&nbsp; However, a module that is filled with these directives becomes
difficult to read, and that module becomes a candidate for being rewritten entirely for each system.
<H1 ID="Avoiding_Common_Pitfalls"> Avoiding Common Pitfalls </H1>
<BR>Even though a C program is much easier to write than the corresponding assembly language program, there are a few areas
where most programmers make mistakes, and spend a great deal of time staring at the code trying to figure out why the program
doesn't work.
<BR><BR>The bugs that are the most difficult to find often occur when the compiler doesn't give an error or warning, but the
code generated is not what the programmer expected.&nbsp; After a great deal of looking, the programmer spots the error and
realizes that the compiler generated the correct code, but it wasn't the code that was wanted.
<BR><BR>Some compilers, including Open Watcom C/16 and C/32, have optional checking for common errors built into them, providing
warnings when these conditions arise.&nbsp; It is probably better to eliminate the code that causes the warning than to turn
off the checking done by the compiler.
<BR><BR>The following sections illustrate several common pitfalls, and discuss how to avoid them.
<H2 ID="Assignment_Instead_of_Comparison"> Assignment Instead of Comparison </H2>
<BR>The code fragment,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; chr = getc();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; if( chr = 'a' ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;letter is 'a'\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;letter is not 'a'\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>will never print the message<TT> letter is not 'a'</TT>, regardless of the value of<TT> chr.</TT>
<BR><BR>The problem occurs in the second line of the example.&nbsp; The statement,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; if( chr = 'a' ) {</TT>
<BR><BR>assigns the character constant<TT> 'a'</TT> to the object<TT> chr.</TT>&nbsp; If the value of<TT> chr</TT> is not
zero, then the statement that is the subject of the <TT> if</TT> is executed.
<BR><BR>The value of the constant<TT> 'a'</TT> is never zero, so the first part of the <TT> if</TT> will always be executed.
&nbsp;The second part might as well not even be there!
<BR><BR>Of course, the correct way to code the second line is,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; if( chr == 'a' ) {</TT>
<BR><BR>changing the<TT> =</TT> to<TT> ==</TT>.&nbsp; This statement says to compare the value of<TT> chr</TT> against the
constant<TT> 'a'</TT> and to execute the subject of the <TT> if</TT> only if the values are the same.
<BR><BR>Using one equal sign (assignment) instead of two (comparison for equality) is a common errors made by programmers,
often by those who are familiar with languages such as Pascal, where the single<TT> =</TT> means &quot;comparison for equality&quot;.
<H2 ID="Unexpected_Operator_Precedence"> Unexpected Operator Precedence </H2>
<BR>The code fragment,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; if( chr = getc() != EOF ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;The value of chr is %d\n&quot;, chr );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>will always print<TT> 1</TT>, as long as end-of-file is not detected in <TT> getc</TT>.&nbsp; The intention was to
assign the value from <TT> getc</TT> to<TT> chr</TT>, then to test the value against<TT> EOF</TT>.
<BR><BR>The problem occurs in the first line, which says to call the library function <TT> getc</TT>.&nbsp; The return value
from <TT> getc</TT> (an integer value representing a character, or<TT> EOF</TT> if end-of-file is detected), is compared against<TT>
EOF</TT>, and if they are not equal (it's not end-of-file), then 1 is assigned to the object<TT> chr.</TT>&nbsp; Otherwise,
they are equal and 0 is assigned to<TT> chr.</TT>&nbsp; The value of<TT> chr</TT> is, therefore, always 0 or 1.
<BR><BR>The correct way to write this code fragment is,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; if( (chr = getc()) != EOF ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;The value of chr is %d\n&quot;, chr );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The extra parentheses force the assignment to occur first, and then the comparison for equality is done.
<BR><BR>Note:&nbsp; doing assignment inside the controlling expression of loop or selection statements is not a good programming
practice.&nbsp; These expressions tend to be difficult to read, and problems such as using<TT> =</TT> instead of<TT> ==</TT>
are more difficult to detect when, in some cases,<TT> =</TT> is desired.
<H2 ID="Delayed_Error_From_Included_File"> Delayed Error From Included File </H2>
<BR>Suppose the source file<TT> mytypes.h</TT> contained the line,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef int COUNTER</TT>
<BR><BR>and the main source file being compiled started with,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &quot;mytypes.h&quot;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int main( void )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /*********************/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; COUNTER x;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* ... */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>Attempting to compile the main source file would report a message such as,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Error! Expecting ';' but found 'extern' on line 3</TT>
<BR><BR>Examining the main source file does not show any problem.&nbsp; The problem actually occurs in the included source
file, since the <TT> typedef</TT> statement does not end with a semi-colon.&nbsp; It is this semi-colon that the compiler
is expecting to find.&nbsp; The next token found is the<TT> extern</TT> keyword, so the error is reported in the main source
file.
<BR><BR>When an error occurs shortly after an <TT> #include</TT> directive, and the error is not readily apparent, the error
may actually be caused by something in the included file.
<H2 ID="Extra_SemiMcolon_in_Macros"> Extra Semi-colon in Macros </H2>
<BR>The next code fragment illustrates a common error when using the preprocessor to define constants:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define MAXVAL 10;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* ... */</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; if( value &gt;= MAXVAL ) break;</TT>
<BR><BR>The compiler will report an error message like,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Error! Expecting ')' but found ';' on line 372</TT>
<BR><BR>The problem is easily spotted when the macro substitution is performed on line 372.&nbsp; Using the definition for<TT>
MAXVAL</TT>, the substituted version of line 372 reads,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; if( value &gt;= 10; ) break;</TT>
<BR><BR>The semi-colon (<TT>;</TT>) in the definition was not treated as an end-of-statement indicator as expected, but was
included in the definition of the macro (<B>manifest constant</B>)<TT> MAXVAL.</TT>&nbsp; The substitution then results in
a semi-colon being placed in the middle of the controlling expression, which yields the syntax error.
<H2 ID="The_Dangling_else"> The Dangling else </H2>
<BR>In the code fragment,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; if( value1 &gt; 0 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( value2 &gt; 0 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Both values greater than zero\n&quot;
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;value1 is not greater than zero\n&quot; );</TT>
<BR><BR>suppose<TT> value1</TT> has the value 3, while<TT> value2</TT> has the value<TT> -</TT>7.&nbsp; This code fragment
will cause the message,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; value1 is not greater than zero</TT>
<BR><BR>to be displayed.
<BR><BR>The problem occurs because of the <TT> else</TT>.&nbsp; The program is indented incorrectly according to the syntax
that the compiler will determine from the statements.&nbsp; The correct indentation should clearly show where the error lies:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; if( value1 &gt; 0 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( value2 &gt; 0 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Both values greater than zero\n&quot;
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;value1 is not greater than
zero\n&quot; );</TT>
<BR><BR>The <TT> else</TT> belongs to the<B> second</B> <TT> if</TT>, not the first.&nbsp; Whenever there is more than one
<TT> if</TT> statement without braces and without an <TT> else</TT> statement, the next <TT> else</TT> will be matched to
the most recent <TT> if</TT> statement.
<BR><BR>This code fragment clearly illustrates the usefulness of using braces to state program structure.&nbsp; The above
example would be (correctly) written as,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; if( value1 &gt; 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( value2 &gt; 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Both values greater than zero\n&quot;
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;value1 is not greater than zero\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="Missing_break_in_switch_Statement"> Missing break in switch Statement </H2>
<BR>In the code fragment,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; switch( value ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 1:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;value is 1\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;value is not 1\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>if<TT> value</TT> is 1, the following output will appear:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; value is 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; value is not 1</TT>
<BR><BR>This unexpected behavior occurs because, when<TT> value</TT> is 1, the <TT> switch</TT> causes control to be passed
to the<TT> case 1:</TT>&nbsp; label, where the first <TT> printf</TT> occurs.&nbsp; Then the<TT> default</TT> label is encountered.
&nbsp;Labels are ignored in execution, so the next statement executed is the second <TT> printf</TT>.
<BR><BR>To correct this example, it should be changed to,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; switch( value ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 1:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;value is 1\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;value is not 1\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The <TT> break</TT> statement causes control to be passed to the statement following the closing brace of the <TT>
switch</TT> statement.
<H2 ID="SideMeffects_in_Macros"> Side-effects in Macros </H2>
<BR>In the code fragment,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define endof( ptr ) ptr + strlen( ptr )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* ... */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; endptr = endof( ptr++ );</TT>
<BR><BR>the statement gets expanded to,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; endptr = ptr++ + strlen( ptr++ );</TT>
<BR><BR>The parameter<TT> ptr</TT> gets incremented twice, rather than once as expected.
<BR><BR>The only way to avoid this pitfall is to be aware of what macros are being used, and to be careful when using them.
&nbsp;Several library functions may be implemented as macros on some systems.&nbsp; These functions include,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; getc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; putc</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; getchar&nbsp;&nbsp;&nbsp; putchar</TT>
<BR><BR>The ISO standard requires that documentation states which library functions evaluate their arguments more than once.
<H1 ID="Programming_Style"> Programming Style </H1>
<BR>Programming style is as individual as a person's preference in clothing.&nbsp; Unfortunately, just as some programmers
wouldn't win a fashion contest, some code has poor style.&nbsp; This code is usually easy to spot, because it is difficult
to understand.
<BR><BR>Good programming style can make the difference between programs that are easy to debug and modify, and those that
you just want to avoid.
<BR><BR>There are a number of aspects to programming style.&nbsp; There is no perfect style that is altogether superior to
all others.&nbsp; Each programmer must find a style that makes him or her comfortable.&nbsp; The intention is to write code
that is easy to read and understand, not to try to stump the next person who has to fix a problem in the code.
<BR><BR>Good programming style will also lead to less time spent writing a program, and certainly less time spent debugging
or modifying it.
<BR><BR>The following sections discuss various aspects of programming style.&nbsp; They reflect the author's own biases, but
they are biases based on years of hacking his way through code, mostly good and some bad, and much of it his own!
<H2 ID="Consistency"> Consistency </H2>
<BR>Perhaps the most important aspect of style is <B> consistency</B>.&nbsp; Try, as much as possible, to use the same rules
throughout the entire program.&nbsp; Having a mixed bag of styles within one program will confuse even the best of programmers
trying to decipher the code.
<BR><BR>If more than one programmer is involved in the project, it may be appropriate, before the first line of code is written,
to discuss general rules of style.&nbsp; Some rules are more important than others.&nbsp; Make sure everyone understands the
rules, and are encouraged to follow them.
<H2 ID="Case_Rules_for_Object_and_Function_Names"> Case Rules for Object and Function Names </H2>
<BR>When examining a piece of code, the scope of an object is sometimes difficult to determine.&nbsp; One needs to examine
the declarations of objects within the function, then those declared outside of any functions, then those declared included
from other source files.&nbsp; If no strict rules of naming objects are followed, each place will need to be laboriously searched
each time.
<BR><BR>Using mixed case object names, with strict rules, can make the job much easier.&nbsp; It does not matter what rules
are established, as long as the rules are consistently applied throughout the program.
<BR><BR>Consider the following sample set of rules, used throughout this book:
<OL>
<LI>objects declared within a function with automatic storage duration are entirely in lower case,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x, counter, limit;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; float&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; save_global;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct s * sptr;</TT>
<LI>objects with static storage duration (global objects) start with an upper case letter, and words or word fragments also
start with upper case,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TotalCount;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern float&nbsp;&nbsp;&nbsp; GlobalAverage;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static struct s SepStruct;</TT>
<LI>function names start with an upper case letter, and words or word fragments also start with upper case, (distinguishable
from global objects by the left parenthesis),
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int&nbsp;&nbsp;&nbsp;&nbsp; TrimLength( char * ptr, int len );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static field * CreateField( char * name );</TT>
<LI>all constants are entirely in upper case.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define FIELD_LIMIT 500</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define BUFSIZE&nbsp;&nbsp;&nbsp;&nbsp; 32</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; enum { INVALID, HELP, ADD, DELETE, REPLACE };</TT>
<LI>all <TT> typedef</TT> tags are in upper case.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef struct {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float real;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float imaginary;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; } COMPLEX;</TT>
</OL>
<BR>Thus, the storage duration and scope of each identifier can be determined without regard to context.&nbsp; Consider this
program fragment:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chr = ReadChar();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( chr != EOF ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GlbChr = chr;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>Using the above rules,
<OL>
<LI><TT> ReadChar</TT> is a function,
<LI><TT> chr</TT> is an object with automatic storage duration defined within the current function,
<LI><TT> EOF</TT> is a constant,
<LI><TT> GlbChr</TT> is an object with static storage duration.
</OL>
<BR>Note:&nbsp; the library functions do not use mixed case names.&nbsp; Also, the function <TT> main</TT> does not begin
with an upper case<TT> M.</TT>&nbsp; Using the above coding style, library functions would stand out from other functions
because of the letter-case difference.
<H2 ID="Choose_Appropriate_Names"> Choose Appropriate Names </H2>
<BR>The naming of objects can be critical to the ease with which bugs can be found, or changes can be made.&nbsp; Using object
names such as<TT> linecount, columns</TT> and<TT> rownumber</TT> will make the program more readable.&nbsp; Of course, short
forms will creep into the code (few programmers like to type more than is really necessary), but they should be used judiciously.
<BR><BR>Consistency of naming also helps to make the code more readable.&nbsp; If a structure is used throughout the program,
and many different routines need a pointer to that structure, then the name of each object that points to it could be made
the same.&nbsp; Using the example of a symbol table, the object name<TT> symptr</TT> might be used everywhere to mean &quot;pointer
to a symbol structure&quot;.&nbsp; A programmer seeing that object will automatically know what it is declared to be.
<BR><BR>Appropriate function names are also very important.&nbsp; Names such as<TT> DoIt</TT>, while saving the original programmer
from trying to think of a good name, make it more difficult for the next programmer to figure out what is going on.
<H2 ID="Indent_to_Emphasize_Structure"> Indent to Emphasize Structure </H2>
<BR>The following is a valid function:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static void BubbleSort( int list[], int n )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /**********************************/ { int index1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; = 0; int index2; int temp; if( n &lt; 2 )return; do {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; index2 = index1 + 1; do { if( list[ index1 ] &gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; list[ index2 ] ) { temp = list[ index1 ]; list[</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; index1 ] = list[ index2 ]; list[ index2 ] = temp;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; } } while( ++index2 &lt; n ); } while( ++index1 &lt; n-1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ); }</TT>
<BR><BR>(The compiler will know that it's valid, but the programmer would find it difficult to validate.) Here is the same
function, but using indenting to clearly illustrate the function structure:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static void BubbleSort( int list[], int n )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /*****************************************/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int index1 = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int index2;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int temp;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( n &lt; 2 )return;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; index2 = index1 + 1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( list[ index1
] &gt; list[ index2 ] ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;temp = list[ index1 ];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;list[ index1 ] = list[ index2 ];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;list[ index2 ] = temp;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } while( ++index2 &lt; n );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } while( ++index1 &lt; n-1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>Generally, it is good practice to indent each level of code by a consistent amount, for example 4 spaces.&nbsp; Thus,
the subject of an <TT> if</TT> statement is always indented 4 spaces inside the <TT> if</TT>.&nbsp; In this manner, all loop
and selection statements will stand out, making it easier to determine when the statements end.
<BR><BR>The following are some recommended patterns to use when indenting statements.&nbsp; These patterns have been used
throughout the book.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int Fn( void )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /************/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* indent 4 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; if( condition ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* indent 4 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* indent 4 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; if( condition ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* indent 4 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; } else if( condition ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* indent 4 from first if */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( condition ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* indent 4 from nearest if */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* indent 4 from first if */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; switch( condition ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case VALUE:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* indent 4 from switch */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case VALUE:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; do {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* indent 4 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; while( condition );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; while( condition ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* indent 4 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; for( a; b; c ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* indent 4 */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>Two other popular indenting styles are,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; if( condition )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT><B>statement</B>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>and,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; if( condition )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT><B>statements</B>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>It is not important which style is used.&nbsp; However, a consistent style is an asset.
<H2 ID="Visually_Align_Object_Declarations"> Visually Align Object Declarations </H2>
<BR>A lengthy series of object declarations can be difficult to read if care is not taken to improve the readability.&nbsp;
Consider the declarations,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct flentry *flptr;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct fldsym *sptr;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char *bufptr,*wsbuff;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int length;</TT>
<BR><BR>Now, consider the same declarations, but with some visual alignment done:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct flentry * flptr;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct fldsym&nbsp; * sptr;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * bufptr;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * wsbuff;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; length;</TT>
<BR><BR>It is easier to scan a list of objects when their names all begin in the same column.
<H2 ID="Keep_Functions_Small"> Keep Functions Small </H2>
<BR>A function that is several hundred lines long can be difficult to comprehend, especially if it is being looked at on a
terminal, which might only have 25 lines.&nbsp; Large functions also tend to have a lot of nesting of program structures,
making it difficult to follow the logic.
<BR><BR>A function that fits entirely within the terminal display can be studied and understood more easily.&nbsp; Program
constructs don't get as complicated.&nbsp; Large functions often can be broken up into smaller functions which are easier
to maintain.
<H2 ID="Use_static_for_Most_Functions"> Use static for Most Functions </H2>
<BR>Most functions do not need to be called from routines outside of the current module.&nbsp; Yet, if the keyword <TT> static</TT>
is not used in the function declaration, then the function is automatically given <B> external linkage</B>.&nbsp; This can
lead to a proliferation of external symbols, which may cause naming conflicts.&nbsp; Also, some linking programs may impose
limitations.
<BR><BR>Only those functions that must have external linkage should be made external.&nbsp; All other definitions of functions
should start with the keyword <TT> static</TT>.
<BR><BR>It also is a good idea to start definitions for external functions with the keyword <TT> extern</TT>, even though
it is the default case.
<H2 ID="Group_Static_Objects_Together"> Group Static Objects Together </H2>
<BR>Static objects that are declared outside of any function definition, and are used throughout the module, generally should
be declared together, for example before the definition of the first function.&nbsp; Placing the declarations of these objects
near the beginning of the module makes them easier to find.
<H2 ID="Do_Not_Reuse_the_Names_of_Static_Objects"> Do Not Reuse the Names of Static Objects </H2>
<BR>If an object with static storage duration exists in one module, but has <B> internal linkage</B>, then another object
with the same name should not be declared in another module.&nbsp; The programmer may confuse them.
<BR><BR>Even more importantly, if an object exists with <B> external linkage</B>, a module should not declare another object
with the same name with<B> internal linkage</B>.&nbsp; This second object will overshadow the first within the module, but
the next programmer to look at the code will likely be confused.
<H2 ID="Use_Included_Files_to_Organize_Structures"> Use Included Files to Organize Structures </H2>
<BR>Included source files can be used to organize data structures and related information.&nbsp; They should be used when
the same structure is needed in different modules.&nbsp; They should even be considered when the structure is used only in
one place.
<BR><BR>Generally, each included source file should contain structures and related information for one aspect of the program.
&nbsp;For example, a file that describes a symbol table might contain the actual structures or other types that are required,
along with any manifest constants that are useful.
<H2 ID="Use_Function_Prototypes"> Use Function Prototypes </H2>
<BR>Function prototypes are very useful for eliminating common errors when calling functions.&nbsp; If every function in a
program is prototyped (and the prototypes are used), then it is difficult to pass the wrong number or types of arguments,
or to misinterpret the return value.
<BR><BR>Using the symbol table example, the included source file that describes the symbol table structure and any related
global objects or constant values could also contain the function prototypes for the functions used to access the table.&nbsp;
Another approach is to have separate source files containing the function prototypes, possibly using a different naming convention
for the file.&nbsp; For example,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &quot;symbols.h&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &quot;symbols.fn&quot;</TT>
<BR><BR>would include the structures and related values from<TT> symbols.h</TT>, and the function prototypes from<TT> symbols.fn</TT>.
<H2 ID="Do_Not_Do_Too_Much_In_One_Statement"> Do Not Do Too Much In One Statement </H2>
<BR>In the same manner that a big function that does too much can be confusing, so too can a long statement.&nbsp; Historically,
a programmer might combine many operations into a single statement in order to get the compiler to produce better code.&nbsp;
With current compilers, splitting the statement into two or more simpler statements will produce equivalent code, and will
make the program easier to understand.
<BR><BR>A common example of a statement that can be split is,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( (c = getchar()) != EOF ) {</TT>
<BR><BR>Historically, this statement might have allowed the compiler to avoid storing the value of<TT> c</TT> and then reloading
it again to compare with<TT> EOF.</TT>&nbsp; However, the equivalent,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c = getchar();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( c != EOF ) {</TT>
<BR><BR>is more readable, and most compilers will produce the same code.
<H2 ID="Do_Not_Use_goto_Too_Much"> Do Not Use goto Too Much </H2>
<BR>The <TT> goto</TT> statement is a very powerful tool, but it is very easy to misuse.&nbsp; Here are some general rules
for the use of <TT> goto</TT>'s:
<UL>
<LI>don't use them!
</UL>
<BR>If that rule is not satisfactory, then these should be followed:
<UL>
<LI>Never <TT> goto</TT> a label that is above.&nbsp; That is the beginning of <B> spaghetti code</B>.&nbsp; Loop statements
can always be used.
<LI>Never <TT> goto</TT> the middle of a block (compound-statement).&nbsp; A block should always be entered by passing over
the opening brace.
<LI>Use <TT> goto</TT> to jump out of nested blocks, where the <TT> break</TT> statement is not appropriate.
</UL>
<BR>Above all, keep the use of <TT> goto</TT>'s to a minimum.
<H2 ID="Use_Comments"> Use Comments </H2>
<BR>Comments are crucial to good programming style.&nbsp; Regardless of how well the program is written, some code will be
difficult to understand.&nbsp; Comments make it possible to give a full explanation for what the code is trying to do.
<BR><BR>Each function definition should begin with a short comment describing what the function does.
<BR><BR>Each module should begin with comments describing the purpose of the module.&nbsp; It is also a good idea to type
in who wrote it, when it was written, who modified it and why, and when it was modified.&nbsp; This last collection of information
is commonly called an <B> audit trail</B>, as it leaves a trail allowing a programmer to see the evolution of the module,
along with who has been changing it.
<BR><BR>The following audit trail is from one module in an actual product:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* Modified: By:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Reason:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * ========&nbsp; ==&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;======</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * 84/04/23&nbsp; Dave McClurkin Initial implementation</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * 84/11/08&nbsp; Jim Graham&nbsp;&nbsp;&nbsp;&nbsp; Implemented TOTAL non-combinable;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; added MAXIMUM,MINIMUM,AVERAGE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * 84/12/12&nbsp; Steve McDowell Added call to CheckBreak</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * 85/01/12&nbsp; ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Fixed overflow problems</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * 85/01/29&nbsp; Alex Kachura&nbsp;&nbsp; Saves value of TYP_ field</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * 86/01/31&nbsp; Steve McDowell Switched to use of numeric accumulator</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * 86/12/10&nbsp; ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Removed some commented code</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * 87/02/24&nbsp; ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Made all commands combinable</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<H1 ID="Compiler_Keywords"> Compiler Keywords </H1>
<BR>The following topics are discussed:
<UL>
<LI>Standard Keywords
<LI>Open Watcom C/16 and C/32 Keywords
</UL>
<H2 ID="Standard_Keywords"> Standard Keywords </H2>
<BR>The following is the list of keywords reserved by the C language:
<BR><BR><TT>&nbsp; auto&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inline
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static</TT>
<BR><TT>&nbsp; _Bool&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct</TT>
<BR><TT>&nbsp; break&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enum&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch</TT>
<BR><TT>&nbsp; case&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; extern&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; register&nbsp;
&nbsp;&nbsp; typedef</TT>
<BR><TT>&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; restrict
&nbsp;&nbsp;&nbsp; union</TT>
<BR><TT>&nbsp; _Complex&nbsp;&nbsp;&nbsp;&nbsp; for&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; unsigned</TT>
<BR><TT>&nbsp; const&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void</TT>
<BR><TT>&nbsp; continue&nbsp;&nbsp;&nbsp;&nbsp; if&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signed&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; volatile</TT>
<BR><TT>&nbsp; default&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _Imaginary&nbsp;&nbsp; sizeof&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while</TT>
<BR><TT>&nbsp; do</TT>
<H2 ID="Open_Watcom_Extended_Keywords"> Open Watcom Extended Keywords </H2>
<BR>The Open Watcom compilers also reserve the following extended keywords:
<BR><BR>Microsoft compilers compatible 
<BR><TT>&nbsp; __asm&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __finally&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __pascal</TT>
<BR><TT>&nbsp; __based&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __fortran&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __saveregs</TT>
<BR><TT>&nbsp; __cdecl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __huge&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __segment</TT>
<BR><TT>&nbsp; __declspec&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __inline&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; __segname</TT>
<BR><TT>&nbsp; __except&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __int64&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __self</TT>
<BR><TT>&nbsp; __export&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __interrupt&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; __stdcall</TT>
<BR><TT>&nbsp; __far&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __leave&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __syscall</TT>
<BR><TT>&nbsp; __far16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __loadds&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __try</TT>
<BR><TT>&nbsp; __fastcall&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __near&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __unaligned</TT>
<BR><BR>IBM compilers compatible
<BR><TT>&nbsp; _Cdecl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _Finally&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _Seg16</TT>
<BR><TT>&nbsp; _Except&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _Leave&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _Syscall</TT>
<BR><TT>&nbsp; _Export&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _Packed&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _System</TT>
<BR><TT>&nbsp; _Far16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _Pascal&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _Try</TT>
<BR><TT>&nbsp; _Fastcall</TT>
<BR><BR>Open Watcom specific
<BR><TT>&nbsp; __builtin_isfloat&nbsp;&nbsp; __ow_imaginary_unit</TT>
<BR><TT>&nbsp; __watcall</TT>
<BR><BR>The keywords <TT> __based</TT>, <TT> __segment</TT>, <TT> __segname</TT> and <TT> __self</TT> are described in the
section &quot;Based Pointers for Open Watcom C/16 and C/32&quot;.&nbsp; Open Watcom C/16 and C/32 provide the predefined macro
<TT> _based</TT> for convenience and compatibility with the Microsoft C compiler.&nbsp; It may be used in place of <TT> __based</TT>.
&nbsp;Open Watcom C/16 and C/32 provide the predefined macro <TT> _segment</TT> for convenience and compatibility with the
Microsoft C compiler.&nbsp; It may be used in place of <TT> __segment</TT>.&nbsp; Open Watcom C/16 and C/32 provide the predefined
macro <TT> _segname</TT> for convenience and compatibility with the Microsoft C compiler.&nbsp; It may be used in place of
<TT> __segname</TT>.&nbsp; Open Watcom C/16 and C/32 provide the predefined macro <TT> _self</TT> for convenience and compatibility
with the Microsoft C compiler.&nbsp; It may be used in place of <TT> __self</TT>.
<BR><BR>The keywords <TT> __far</TT>, <TT> __huge</TT> and <TT> __near</TT> are described in the sections &quot;Special Pointer
Types for Open Watcom C/16&quot; and &quot;Special Pointer Types for Open Watcom C/32&quot;.&nbsp; Open Watcom C/16 and C/32
provide the predefined macros <TT> far</TT> and <TT> _far</TT> for convenience and compatibility with the Microsoft C compiler.
&nbsp;They may be used in place of <TT> __far</TT>.&nbsp; Open Watcom C/16 and C/32 provide the predefined macros <TT> huge</TT>
and <TT> _huge</TT> for convenience and compatibility with the Microsoft C compiler.&nbsp; They may be used in place of <TT>
__huge</TT>.&nbsp; Open Watcom C/16 and C/32 provide the predefined macros <TT> near</TT> and <TT> _near</TT> for convenience
and compatibility with the Microsoft C compiler.&nbsp; They may be used in place of <TT> __near</TT>.
<BR>The keywords <TT> __far16</TT> , <TT> _Far16</TT> and <TT> _Seg16</TT> are described in the section &quot;Special Pointer
Types for Open Watcom C/32&quot;.&nbsp; Open Watcom C/16 and C/32 provide the predefined macro <TT> _far16</TT> for convenience
and compatibility with the Microsoft C compiler.&nbsp; It may be used in place of <TT> __far16</TT>.
<BR><BR>The <TT> _Packed</TT> keyword is described in the section &quot;Structures&quot;.
<BR><BR>The <TT> __cdecl</TT> and <TT> _Cdecl</TT> keywords may be used with function definitions, and indicates that the
calling convention for the function is the same as that used by Microsoft C.&nbsp; All parameters are pushed onto the stack,
instead of being passed in registers.&nbsp; This calling convention may be controlled by a <TT> #pragma</TT> directive.&nbsp;
See the User's Guide.&nbsp; Open Watcom C/16 and C/32 provide the predefined macros <TT> cdecl</TT> and <TT> _cdecl</TT> for
convenience and compatibility with the Microsoft C compiler.&nbsp; They may be used in place of <TT> __cdecl</TT>.
<BR><BR>The <TT> __fastcall</TT> and <TT> _Fastcall</TT> keywords may be used with function definitions, and indicates that
the calling convention used is compatible with Microsoft C compiler.&nbsp; This calling convention may be controlled by a
<TT> #pragma</TT> directive.&nbsp; Open Watcom C/16 and C/32 provide the predefined macro <TT> _fastcall,</TT> for convenience
and compatibility with the Microsoft C compiler.&nbsp; It may be used in place of <TT> __fastcall</TT> See the User's Guide..
<BR><BR>The <TT> __fortran</TT> keyword may be used with function definitions, and indicates that the calling convention for
the function is suitable for calling a function written in FORTRAN.&nbsp; By default, this keyword has no effect.&nbsp; This
calling convention may be controlled by a <TT> #pragma</TT> directive.&nbsp; See the User's Guide.&nbsp; Open Watcom C/16
and C/32 provide the predefined macros <TT> fortran</TT> and <TT> _fortran</TT> for convenience and compatibility with the
Microsoft C compiler.&nbsp; They may be used in place of <TT> __fortran</TT>.
<BR><BR>The <TT> __pascal</TT> and <TT> _Pascal</TT> keywords may be used with function definitions, and indicates that the
calling convention for the function is suitable for calling a function written in Pascal.&nbsp; All parameters are pushed
onto the stack, but in reverse order to the order specified by<TT> __cdecl</TT>.&nbsp; This calling convention may be controlled
by a <TT> #pragma</TT> directive.&nbsp; See the User's Guide.&nbsp; Open Watcom C/16 and C/32 provide the predefined macros
<TT> pascal</TT> and <TT> _pascal</TT> for convenience and compatibility with the Microsoft C compiler.&nbsp; They may be
used in place of <TT> __pascal</TT>.
<BR><BR>The <TT> __syscall</TT> , <TT> _Syscall</TT> and <TT> _System</TT> keywords may be used with function definitions,
and indicates that the calling convention used is compatible with OS/2 (version 2.0 or higher).&nbsp; This calling convention
may be controlled by a <TT> #pragma</TT> directive.&nbsp; See the User's Guide.&nbsp; Open Watcom C/16 and C/32 provide the
predefined macro <TT> _syscall</TT> for convenience and compatibility with the Microsoft C compiler.&nbsp; It may be used
in place of <TT> __syscall</TT>.
<BR><BR>The <TT> __stdcall</TT> keyword may be used with function definitions, and indicates that the calling convention used
is compatible with Win32.&nbsp; This calling convention may be controlled by a <TT> #pragma</TT> directive.&nbsp; Open Watcom
C/16 and C/32 provide the predefined macro <TT> _stdcall,</TT> for convenience and compatibility with the Microsoft C compiler.
&nbsp;It may be used in place of <TT> __stdcall</TT> See the User's Guide.
<BR><BR>The <TT> __watcall</TT> keyword may be used with function definitions, and indicates that the Open Watcom default
calling convention is used.&nbsp; This calling convention may be controlled by a <TT> #pragma</TT> directive.&nbsp; See the
User's Guide.
<BR><BR>The <TT> __export</TT> and <TT> _Export</TT> keywords may be used with objects with static storage duration (global
objects) and with functions, and describes that object or function as being a known object or entry point within a Dynamic
Link Library in OS/2 or Microsoft Windows.&nbsp; The object or function must also be declared as having external linkage (using
the <TT> extern</TT> keyword).&nbsp; In addition, any<B> call back</B> function whose address is passed to Windows (and which
Windows will &quot;call back&quot;) must be defined with the<TT> __export</TT> keyword, otherwise the call will fail and cause
unpredictable results.&nbsp; The<TT> __export</TT> keyword may be omitted if the object or function is exported by an option
specified using the linker.&nbsp; See the Open Watcom Linker User's Guide.&nbsp; Open Watcom C/16 and C/32 provide the predefined
macro <TT> _export</TT> for convenience and compatibility with the Microsoft C compiler.&nbsp; It may be used in place of
<TT> __export</TT>.
<BR><BR>The <TT> __interrupt</TT> keyword may be used with function definitions for functions that handle computer interrupts.
&nbsp;All registers are saved before the function begins execution and restored prior to returning from the interrupt.&nbsp;
The machine language return instruction for the function is changed to<TT> iret</TT> (interrupt return).&nbsp; Functions written
using<TT> __interrupt</TT> are suitable for attaching to the interrupt vector using the library function <TT> _dos_setvect</TT>.
&nbsp;Open Watcom C/16 and C/32 provide the predefined macros <TT> interrupt</TT> and <TT> _interrupt</TT> for convenience
and compatibility with the Microsoft C compiler.&nbsp; They may be used in place of <TT> __interrupt</TT>.
<BR><BR>The <TT> __loadds</TT> keyword may be used with functions, and causes the compiler to generate code that will force
the DS register to be set to the default data segment (DGROUP) so that near pointers will refer to that segment.&nbsp; This
keyword is normally used with functions written for Dynamic Link Libraries in Windows and OS/2.&nbsp; Open Watcom C/16 and
C/32 provide the predefined macro <TT> _loadds</TT> for convenience and compatibility with the Microsoft C compiler.&nbsp;
It may be used in place of <TT> __loadds</TT>.
<BR><BR>The <TT> __saveregs</TT> keyword may be used with functions.&nbsp; It is provided for compatibility with Microsoft
C, and has no effect in Open Watcom C/16 and C/32.&nbsp; Open Watcom C/16 and C/32 provide the predefined macro <TT> _saveregs</TT>
for convenience and compatibility with the Microsoft C compiler.&nbsp; It may be used in place of <TT> __saveregs</TT>.
<BR><BR>The <TT> __try</TT> , <TT> _Try</TT> , <TT> __except</TT> , <TT> _Except</TT> , <TT> __finally</TT> , <TT> _Finally</TT>
, <TT> __leave</TT> and <TT> _Leave</TT> keywords may be used for exception handling, See the &quot;Structured Exception Handling&quot;
in User's Guide.&nbsp; Open Watcom C/16 and C/32 provide the predefined macro <TT> _try</TT> for convenience and compatibility
with the Microsoft C compiler.&nbsp; It may be used in place of <TT> __try</TT>.&nbsp; Open Watcom C/16 and C/32 provide the
predefined macro <TT> _except</TT> for convenience and compatibility with the Microsoft C compiler.&nbsp; It may be used in
place of <TT> __except</TT>.&nbsp; Open Watcom C/16 and C/32 provide the predefined macro <TT> _finally</TT> for convenience
and compatibility with the Microsoft C compiler.&nbsp; It may be used in place of <TT> __finally</TT>.&nbsp; Open Watcom C/16
and C/32 provide the predefined macro <TT> _leave</TT> for convenience and compatibility with the Microsoft C compiler.&nbsp;
It may be used in place of <TT> __leave</TT>.
<BR><BR>The <TT> __ow_imaginary_unit</TT> keyword may be used as _Imaginary constant 1.0.
<BR><BR>The <TT> __builtin_isfloat</TT> keyword may be used as function for testing symbol type.
<H1 ID="Trigraphs"> Trigraphs </H1>
<BR>The following is the list of trigraphs.&nbsp; In a C source file, all occurrences (including inside quoted strings and
character constants) of any of the trigraph sequences below are replaced by the corresponding single character.&nbsp; 
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Trigraph</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Character&nbsp;&nbsp; Sequence</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ---------&nbsp;&nbsp; --------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ??(</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ??)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ??&lt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ??&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ??!</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ??=</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ??/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ??'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ??-</TT>
<BR><BR>No other trigraphs exist.&nbsp; Any question mark (<TT>?</TT>) that does not belong to one of the trigraphs is not
changed.
<BR><BR>To get a sequence of characters that would otherwise be a trigraph, place a<TT> \</TT> before the second question
mark.&nbsp; This will cause the trigraph to be broken up so that it is not recognized, but later in the translation process,
the<TT> \?</TT>&nbsp; will be converted to<TT> ?.</TT>&nbsp; For example,<TT> ?\?=</TT> will be translated to<TT> ??=.</TT>
<H1 ID="Escape_Sequences"> Escape Sequences </H1>
<BR>The following are the escape sequences and their meanings:&nbsp; 
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Escape</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Sequence&nbsp;&nbsp;&nbsp; Meaning</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; --------&nbsp;&nbsp;&nbsp; -------------------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; \a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Causes an audible or visual alert</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; \b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Back up one character</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; \f&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Move to the start of the next page</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Move to the start of the next line</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; \r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Move to the start of the current
line</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; \t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Move to the next horizontal tab</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; \v&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Move to the next vertical tab</TT>
<BR><BR>Each escape sequence maps to a single character.&nbsp; When such a character is sent to a display device, the action
corresponding to that character is performed.
<H1 ID="Operator_Precedence"> Operator Precedence </H1>
<BR>The table below summarizes the levels of precedence in expressions.&nbsp; 
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Expression Type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Operators</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ----------------------&nbsp; ------------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; primary&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; identifier</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; constant</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (expression)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ----------------------&nbsp; ------------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; postfix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; a[b]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a.b&nbsp;&nbsp;&nbsp;&nbsp; a-&gt;b</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a++&nbsp;&nbsp;&nbsp;&nbsp; a--</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ----------------------&nbsp; ------------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unary&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; sizeof u&nbsp;&nbsp; sizeof( a )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++a&nbsp;&nbsp;&nbsp;&nbsp; --a</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *a</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~a&nbsp;
&nbsp;&nbsp;&nbsp; !a</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ----------------------&nbsp; ------------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; cast&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; (type) a</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ----------------------&nbsp; ------------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; multiplicative&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a * b&nbsp;&nbsp; a
/ b&nbsp;&nbsp; a % b</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ----------------------&nbsp; ------------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; additive&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;a + b&nbsp;&nbsp; a - b</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ----------------------&nbsp; ------------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; shift&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; a &lt;&lt; b&nbsp; a &gt;&gt; b</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ----------------------&nbsp; ------------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; relational&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
a &lt; b&nbsp;&nbsp; a &gt; b&nbsp;&nbsp; a &lt;= b&nbsp; a &gt;= b</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ----------------------&nbsp; ------------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; equality&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;a == b&nbsp; a != b</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ----------------------&nbsp; ------------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; bitwise AND&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a &amp;
b</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ----------------------&nbsp; ------------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; bitwise exclusive OR&nbsp;&nbsp;&nbsp; a ^ b</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ----------------------&nbsp; ------------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; bitwise inclusive OR&nbsp;&nbsp;&nbsp; a | b</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ----------------------&nbsp; ------------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; logical AND&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a &amp;&amp;
b</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ----------------------&nbsp; ------------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; logical OR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
a || b</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ----------------------&nbsp; ------------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; conditional (*)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a ? b : c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ----------------------&nbsp; ------------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; assignment (*)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a = b</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a += b&nbsp;&nbsp;&nbsp;&nbsp; a -= b</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a *= b&nbsp;&nbsp;&nbsp;&nbsp; a /= b&nbsp;&nbsp;&nbsp;&nbsp; a %= b</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a &amp;= b&nbsp;&nbsp;&nbsp;&nbsp; a ^= b&nbsp;&nbsp;&nbsp;&nbsp; a |= b</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a &lt;&lt;= b&nbsp;&nbsp;&nbsp; a &gt;&gt;= b</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ----------------------&nbsp; ------------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; comma&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; a,b</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ----------------------&nbsp; ------------------------------</TT>
<BR><BR>(*) associates from right to left
<BR><BR>Operations at a higher level in the table will occur before those below.&nbsp; All operators involving more than one
operand associate from left to right, except for the conditional and assignment operators, which associate from right to left.
&nbsp;Operations at the same level, except where discussed in the relevant section, may be executed in any order that the
compiler chooses (subject to the usual algebraic rules).&nbsp; In particular, the compiler may regroup sub-expressions that
are both associative and commutative in order to improve the efficiency of the code, provided the meaning (i.e.&nbsp; types
and results) of the operands and result are not affected by the regrouping.
<BR><BR>The order of any side-effects (for example, assignment, or action taken by a function call) is also subject to alteration
by the compiler.
<H1 ID="Formal_C_Grammar"> Formal C Grammar </H1>
<BR>This appendix presents the formal grammar of the C programming language.&nbsp; The following notation is used:
<BR><BR>{digit}<TT>(0)</TT>
<BR>&nbsp;&nbsp;&nbsp; Zero or more occurrences of<B> digit</B> are allowed.
<BR>{digit}<TT>(1)</TT>
<BR>&nbsp;&nbsp;&nbsp; One or more occurrences of<B> digit</B> are allowed.
<BR>&lt;integer-suffix &gt;
<BR><B>&nbsp;&nbsp;&nbsp; integer-suffix</B> is optional, with only one occurrence being allowed if present.
<BR><TT>A</TT> |<TT> B</TT> |<TT> C</TT>
<BR>&nbsp;&nbsp;&nbsp; Choose one of<TT> A</TT>,<TT> B</TT> or<TT> C.</TT>
<H2 ID="Lexical_Grammar"> Lexical Grammar </H2>
<BR>The following topics are discussed:
<UL>
<LI>Tokens
<LI>Keywords
<LI>Identifiers
<LI>Constants
<LI>String Literals
<LI>Operators
<LI>Punctuators
</UL>
<H3 ID="Definition_of_a_Token"> Definition of a Token </H3>
<BR><B>token</B>
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyword
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; identifier
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; constant
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; string-literal
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; operator
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; punctuator
<H3 ID="Definition_of_a_Keyword"> Definition of a Keyword </H3>
<BR><B>keyword</B>
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; standard-keyword
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; Open Watcom-extended-keyword
<BR><BR><B>standard-keyword</B> 
<BR><TT>&nbsp; auto&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inline&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; static</TT>
<BR><TT>&nbsp; _Bool&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct</TT>
<BR><TT>&nbsp; break&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enum&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch</TT>
<BR><TT>&nbsp; case&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; extern&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; register&nbsp;
&nbsp;&nbsp; typedef</TT>
<BR><TT>&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; restrict
&nbsp;&nbsp;&nbsp; union</TT>
<BR><TT>&nbsp; _Complex&nbsp;&nbsp;&nbsp;&nbsp; for&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; unsigned</TT>
<BR><TT>&nbsp; const&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void</TT>
<BR><TT>&nbsp; continue&nbsp;&nbsp;&nbsp;&nbsp; if&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signed&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; volatile</TT>
<BR><TT>&nbsp; default&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _Imaginary&nbsp;&nbsp; sizeof&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while</TT>
<BR><TT>&nbsp; do</TT>
<BR><BR><B>Open Watcom-extended-keyword</B>
<BR><BR>Microsoft compilers compatible 
<BR><TT>&nbsp; __asm&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __finally&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __pascal</TT>
<BR><TT>&nbsp; __based&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __fortran&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __saveregs</TT>
<BR><TT>&nbsp; __cdecl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __huge&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __segment</TT>
<BR><TT>&nbsp; __declspec&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __inline&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; __segname</TT>
<BR><TT>&nbsp; __except&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __int64&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __self</TT>
<BR><TT>&nbsp; __export&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __interrupt&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; __stdcall</TT>
<BR><TT>&nbsp; __far&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __leave&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __syscall</TT>
<BR><TT>&nbsp; __far16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __loadds&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __try</TT>
<BR><TT>&nbsp; __fastcall&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __near&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __unaligned</TT>
<BR><BR>IBM compilers compatible
<BR><TT>&nbsp; _Cdecl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _Finally&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _Seg16</TT>
<BR><TT>&nbsp; _Except&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _Leave&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _Syscall</TT>
<BR><TT>&nbsp; _Export&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _Packed&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _System</TT>
<BR><TT>&nbsp; _Far16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _Pascal&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _Try</TT>
<BR><TT>&nbsp; _Fastcall</TT>
<BR><BR>Open Watcom specific
<BR><TT>&nbsp; __builtin_isfloat&nbsp;&nbsp; __ow_imaginary_unit</TT>
<BR><TT>&nbsp; __watcall</TT>
<H3 ID="Definition_of_an_Identifier"> Definition of an Identifier </H3>
<BR><B>identifier</B>
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nondigit {nondigit | digit}<TT>(0)</TT>
<BR><BR><B>nondigit</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT>a | b | ...&nbsp; | z | A | B | ...&nbsp; | Z | _</TT>
<BR><BR><B>digit</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT>0 | 1 | ...&nbsp; | 9</TT>
<H3 ID="Definition_of_a_Constant"> Definition of a Constant </H3>
<BR><B>constant</B>
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; floating-constant
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; integer-constant
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; enumeration-constant
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; character-constant
<BR><BR><B>floating-constant</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fractional-constant &lt;exponent-part &gt; &lt;floating-suffix &gt;
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; digit-sequence exponent-part &lt;floating-suffix &gt;
<BR><BR><B>exponent-part</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT>e|E</TT> &lt;<TT>+|-</TT> &gt; digit-sequence
<BR><BR><B>floating-suffix</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT>f | F | l | L</TT>
<BR><BR><B>fractional-constant</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;digit-sequence &gt; .&nbsp; digit-sequence
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; digit-sequence .
<BR><BR><B>digit-sequence</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {digit}<TT>(1)</TT>
<BR><BR><B>integer-constant</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; decimal-constant &lt;integer-suffix &gt;
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; octal-constant &lt;integer-suffix &gt;
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; hexadecimal-constant &lt;integer-suffix &gt;
<BR><BR><B>integer-suffix</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT>u|U</TT> &lt;<TT>l|L</TT> &gt;
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; <TT>l|L</TT> &lt;<TT>u|U</TT> &gt;
<BR><BR><B>decimal-constant</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nonzero-digit{digit}<TT>(0)</TT>
<BR><BR><B>nonzero-digit</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT>1 | 2 | ...&nbsp; | 9</TT>
<BR><BR><B>octal-constant</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT>0</TT>{octal-digit}<TT>(0)</TT>
<BR><BR><B>octal-digit</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT>0 | 1 | ...&nbsp; | 7</TT>
<BR><BR><B>hexadecimal-constant</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT>0x</TT>|<TT>0X</TT>{hexadecimal-digit}<TT>(1)</TT>
<BR><BR><B>hexadecimal-digit</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT>0 | 1 | ...&nbsp; | 9 |</TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT>a | b | ...&nbsp; | f | A | B | ...&nbsp; | F</TT>
<BR><BR><B>enumeration-constant</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; identifier
<BR><BR><B>character-constant</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT>'</TT>{c-char}<TT>(1)</TT><TT>'</TT>
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; <TT>L'</TT>{c-char}<TT>(1)</TT><TT>'</TT>
<BR><BR><B>c-char</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; any character in the source character set except
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the single-quote<TT> '</TT>, backslash<TT> \</TT>, or new-line character
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; escape-sequence
<BR><BR><B>escape-sequence</B> is one of
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT>\' \&quot; \\</TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT>\</TT>o<TT> \</TT>oo<TT> \</TT>ooo
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT>\x</TT>{hexadecimal-digit}<TT>(1)</TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT>\a \b \f \n \r \t \v</TT>
<H3 ID="Definition_of_a_String_Literal"> Definition of a String Literal </H3>
<BR><B>string-literal</B>
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT>&quot;</TT>{s-char}<TT>(0)</TT><TT>&quot;</TT>
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; <TT>L&quot;</TT>{s-char}<TT>(0)</TT><TT>&quot;</TT>
<BR><BR><B>s-char</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; any character in the source character set except
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the double-quote<TT> &quot;</TT>, backslash<TT> \</TT>, or new-line character
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; escape-sequence
<H3 ID="Definition_of_an_Operator"> Definition of an Operator </H3>
<BR><B>operator</B> is one of
<BR>&nbsp;&nbsp;&nbsp; <TT>[&nbsp; ]&nbsp; (&nbsp; )&nbsp; .&nbsp; -&gt;</TT>
<BR>&nbsp;&nbsp;&nbsp; <TT>++&nbsp; --&nbsp; &amp;&nbsp; *&nbsp; +&nbsp; -&nbsp; ~&nbsp; !&nbsp; sizeof</TT>
<BR>&nbsp;&nbsp;&nbsp; <TT>/&nbsp; %&nbsp; &lt;&lt;&nbsp; &gt;&gt;&nbsp; &lt;&nbsp; &gt;&nbsp; &lt;=&nbsp; &gt;=&nbsp; ==
&nbsp;!=&nbsp; ^&nbsp; |&nbsp; &amp;&amp;&nbsp; ||</TT>
<BR>&nbsp;&nbsp;&nbsp; <TT>?&nbsp; : </TT>
<BR>&nbsp;&nbsp;&nbsp; <TT>=&nbsp; *=&nbsp; /=&nbsp; %=&nbsp; +=&nbsp; -=&nbsp; &lt;&lt;=&nbsp; &gt;&gt;=&nbsp; &amp;=&nbsp;
^=&nbsp; |=</TT>
<BR>&nbsp;&nbsp;&nbsp; <TT>,&nbsp; #&nbsp; ##</TT>
<BR>&nbsp;&nbsp;&nbsp; <TT>:&gt;</TT>
<H3 ID="Definition_of_a_Punctuator"> Definition of a Punctuator </H3>
<BR><B>punctuator</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT>[&nbsp; ]&nbsp; (&nbsp; )&nbsp; {&nbsp; }&nbsp; *&nbsp; ,&nbsp; :
&nbsp;= ; ... #</TT>
<H2 ID="Phrase_Structure_Grammar"> Phrase Structure Grammar </H2>
<BR>The following topics are discussed:
<UL>
<LI>Expressions
<LI>Declarations
<LI>Statements
<LI>External Definitions
</UL>
<H3 ID="Definition_of_Expressions"> Definition of Expressions </H3>
<BR><B>constant-expression</B>
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; conditional-expression
<BR><BR><B>expression</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assignment-expression{<TT> ,</TT> assignment-expression}<TT>(0)</TT>
<BR><BR><B>assignment-expression</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; conditional-expression
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; unary-expression assignment-operator assignment-expression
<BR><BR><B>assignment-operator</B> is one of
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT>=&nbsp; *=&nbsp; /=&nbsp; %=&nbsp; +=&nbsp; -=&nbsp; &lt;&lt;=&nbsp;
&gt;&gt;=&nbsp; &amp;=&nbsp; ^=&nbsp; |=</TT>
<BR><BR><B>conditional-expression</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; logical-OR-expression &lt;<TT>?</TT>&nbsp; expression<TT> :</TT>&nbsp;
conditional-expression &gt;
<BR><BR><B>logical-OR-expression</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; logical-AND-expression{<TT>||</TT> logical-AND-expression}<TT>(0)</TT>
<BR><BR><B>logical-AND-expression</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inclusive-OR-expression {<TT>&amp;&amp;</TT> inclusive-OR-expression}<TT>(0)</TT>
<BR><BR><B>inclusive-OR-expression</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exclusive-OR-expression {<TT>|</TT> exclusive-OR-expression}<TT>(0)</TT>
<BR><BR><B>exclusive-OR-expression</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AND-expression {<TT>^</TT> AND-expression}<TT>(0)</TT>
<BR><BR><B>AND-expression</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; equality-expression {<TT>&amp;</TT> equality-expression}<TT>(0)</TT>
<BR><BR><B>equality-expression</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; relational-expression {<TT>==</TT>|<TT>!=</TT> relational-expression}<TT>(0)</TT>
<BR><BR><B>relational-expression</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; shift-expression {<TT>&lt;</TT>|<TT>&gt;</TT>|<TT>&lt;=</TT>|<TT>&gt;=</TT>
shift-expression}<TT>(0)</TT>
<BR><BR><B>shift-expression</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; additive-expression {<TT>&lt;&lt;</TT>|<TT>&gt;&gt;</TT> additive-expression}<TT>(0)</TT>
<BR><BR><B>additive-expression</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; multiplicative-expression {<TT>+</TT>|<TT>-</TT> multiplicative-expression}<TT>(0)</TT>
<BR><BR><B>multiplicative-expression</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cast-expression {<TT>*</TT>|<TT>/</TT>|<TT>%</TT> cast-expression}<TT>(0)</TT>
<BR><BR><B>cast-expression</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unary-expression
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; <TT>(</TT> type-name<TT> )</TT> cast-expression
<BR><BR><B>unary-expression</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; postfix-expression
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; <TT>++ | -- | sizeof</TT> unary-expression
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; <TT>sizeof(</TT> type-name<TT> )</TT>
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; unary-operator cast-expression
<BR><BR><B>unary-operator</B> is one of
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT>&amp; * + - ~ !</TT>
<BR><BR><B>postfix-expression</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; primary-expression
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; postfix-expression<TT> [</TT> expression<TT> ]</TT>
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; postfix-expression<TT> (</TT> &lt;argument-expression-list &gt;<TT> )</TT>
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; postfix-expression .&nbsp; identifier
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; postfix-expression<TT> -&gt;</TT> identifier
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; postfix-expression<TT> ++</TT>
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; postfix-expression<TT> --</TT>
<BR><BR><B>argument-expression-list</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assignment-expression {<TT>,</TT> assignment-expression}<TT>(0)</TT>
<BR><BR><B>primary-expression</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; identifier
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; constant
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; string-literal
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; <TT>(</TT> expression<TT> )</TT>
<H3 ID="Definition_of_a_Declaration"> Definition of a Declaration </H3>
<BR><B>declaration</B>
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; declaration-specifiers &lt;init-declarator-list &gt;<TT>;</TT>
<BR><BR><B>declaration-specifiers</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; storage-class-specifier &lt;declaration-specifiers &gt;
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; type-specifier &lt;declaration-specifiers &gt;
<BR><BR><B>init-declarator-list</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; init-declarator {<TT>,</TT> init-declarator}<TT>(0)</TT>
<BR><BR><B>init-declarator</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; declarator &lt;<TT>=</TT> initializer &gt;
<BR><BR><B>storage-class-specifier</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT>typedef | extern | static | auto | register</TT>
<BR><BR><B>type-specifier</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT>void | char | short | int | long | float |</TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT>double | signed | unsigned</TT>
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; struct-or-union-specifier
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; enum-specifier
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; typedef-name
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; type-qualifier
<BR><BR><B>type-qualifier</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT>const | volatile</TT>
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; Open Watcom-type-qualifier
<BR><BR><B>Open Watcom-type-qualifier</B> 
<BR><TT>&nbsp; __based&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __fortran&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; _Seg16</TT>
<BR><TT>&nbsp; _Cdecl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __huge&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __segment</TT>
<BR><TT>&nbsp; __cdecl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __inline&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; __segname</TT>
<BR><TT>&nbsp; __declspec&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __int64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; __self</TT>
<BR><TT>&nbsp; _Export&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __interrupt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;__stdcall</TT>
<BR><TT>&nbsp; __export&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __loadds&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; _Syscall</TT>
<BR><TT>&nbsp; __far&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __near&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __syscall</TT>
<BR><TT>&nbsp; _Far16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _Packed&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; _System</TT>
<BR><TT>&nbsp; __far16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _Pascal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; __unaligned</TT>
<BR><TT>&nbsp; _Fastcall&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __pascal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; __watcall</TT>
<BR><TT>&nbsp; __fastcall&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __saveregs</TT>
<BR><BR><B>struct-or-union-specifier</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct-or-union &lt;identifier &gt;<TT> {</TT> struct-declaration-list<TT>
}</TT>
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; struct-or-union identifier
<BR><BR><B>struct-or-union</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT>struct | union</TT>
<BR><BR><B>struct-declaration-list</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {struct-declaration}<TT>(1)</TT>
<BR><BR><B>struct-declaration</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type-specifier-list struct-declarator-list<TT>;</TT>
<BR><BR><B>type-specifier-list</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {type-specifier}<TT>(1)</TT>
<BR><BR><B>struct-declarator-list</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct-declarator {<TT>,</TT> struct-declarator}<TT>(0)</TT>
<BR><BR><B>struct-declarator</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; declarator
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp;&nbsp; &lt;declarator &gt;<TT> :</TT>&nbsp; constant-expression
<BR><BR><B>enum-specifier</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT>enum</TT> &lt;identifier &gt;<TT> {</TT> enumerator-list<TT> }</TT>
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; <TT>enum</TT> identifier
<BR><BR><B>enumerator-list</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enumerator {<TT>,</TT> enumerator}<TT>(0)</TT>
<BR><BR><B>enumerator</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enumeration-constant &lt;<TT>=</TT> constant-expression &gt;
<BR><BR><B>declarator</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;pointer &gt; direct-declarator
<BR><BR><B>direct-declarator</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; identifier
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; <TT>(</TT> declarator<TT> )</TT>
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; direct-declarator<TT> [</TT> &lt;constant-expression &gt;<TT> ]</TT>
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; direct-declarator<TT> (</TT> parameter-type-list<TT> )</TT>
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; direct-declarator<TT> (</TT> &lt;identifier-list &gt;<TT> )</TT>
<BR><BR><B>pointer</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<TT>*</TT> &lt;type-specifier-list &gt;}<TT>(1)</TT>
<BR><BR><B>parameter-type-list</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameter-list &lt;<TT>, ...</TT>&nbsp; &gt;
<BR><BR><B>parameter-list</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameter-declaration {<TT>,</TT> parameter-declaration}<TT>(0)</TT>
<BR><BR><B>parameter-declaration</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; declaration-specifiers declarator
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; declaration-specifiers &lt;abstract-declarator &gt;
<BR><BR><B>identifier-list</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; identifier {<TT>,</TT> identifier}<TT>(0)</TT>
<BR><BR><B>type-name</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type-specifier-list &lt;abstract-declarator &gt;
<BR><BR><B>abstract-declarator</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pointer
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp;&nbsp; &lt;pointer &gt; direct-abstract-declarator
<BR><BR><B>direct-abstract-declarator</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT>(</TT> abstract-declarator<TT> )</TT>
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp;&nbsp; &lt;direct-abstract-declarator &gt;<TT> [</TT> &lt;constant-expression &gt;<TT>
]</TT>
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp;&nbsp; &lt;direct-abstract-declarator &gt;<TT> (</TT> &lt;parameter-type-list &gt;<TT>
)</TT>
<BR><BR><B>typedef-name</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; identifier
<BR><BR><B>initializer</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assignment-expression
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; <TT>{</TT>initializer-list &lt;<TT>,</TT> &gt;<TT>}</TT>
<BR><BR><B>initializer-list</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; initializer {<TT>,</TT> initializer}<TT>(0)</TT>
<H3 ID="Definition_of_a_Statement"> Definition of a Statement </H3>
<BR><B>statement</B>
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; labelled-statement
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; compound-statement
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; expression-statement
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; selection-statement
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; iteration-statement
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; jump-statement
<BR><BR><B>labelled-statement</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; identifier<TT> :</TT>&nbsp; statement
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; <TT>case</TT> constant-expression<TT> :</TT>&nbsp; statement
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; <TT>default :</TT>&nbsp; statement
<BR><BR><B>compound-statement</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT>{</TT> &lt;declaration-list &gt; &lt;statement-list &gt;<TT>}</TT>
<BR><BR><B>declaration-list</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {declaration}<TT>(1)</TT>
<BR><BR><B>statement-list</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {statement}<TT>(1)</TT>
<BR><BR><B>expression-statement</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;expression &gt;<TT>;</TT>
<BR><BR><B>selection-statement</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT>if (</TT> expression<TT> )</TT> statement
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; <TT>if (</TT> expression<TT> )</TT> statement<TT> else</TT> statement
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; <TT>switch (</TT> expression<TT> )</TT> statement
<BR><BR><B>iteration-statement</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT>while (</TT> expression<TT> )</TT> statement
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; <TT>do</TT> statement<TT> while (</TT> expression<TT> );</TT>
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; <TT>for (</TT> &lt;expression &gt;<TT>;</TT> &lt;expression &gt;<TT>;</TT> &lt;expression
&gt;<TT> )</TT> statement
<BR><BR><B>jump-statement</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT>goto</TT> identifier<TT>;</TT>
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; <TT>continue;</TT>
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; <TT>break;</TT>
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; <TT>return</TT> &lt;expression &gt;<TT>;</TT>
<H3 ID="External_Definitions"> External Definitions </H3>
<BR><B>file</B>
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {external-definition}<TT>(1)</TT>
<BR><BR><B>external-definition</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; function-definition
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; declaration
<BR><BR><B>function-definition</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;declaration-specifiers &gt; declarator &lt;declaration-list
&gt;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; compound-statement
<H2 ID="Preprocessing_Directives_Grammar"> Preprocessing Directives Grammar </H2>
<BR><B>preprocessing-file</B>
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; group
<BR><BR><B>group</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {group-part}<TT>(1)</TT>
<BR><BR><B>group-part</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;pp-token &gt; new-line
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; if-section
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; control-line
<BR><BR><B>if-section</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if-group {elif-group}<TT>(0)</TT> &lt;else-group &gt; endif-line
<BR><BR><B>if-group</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT>#if</TT> const-expression new-line &lt;group &gt;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT>#ifdef</TT> identifier new-line &lt;group &gt;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT>#ifndef</TT> identifier new-line &lt;group &gt;
<BR><BR><B>elif-group</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT>#elif</TT> constant-expression new-line &lt;group &gt;
<BR><BR><B>else-group</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT>#else</TT> new-line &lt;group &gt;
<BR><BR><B>endif-line</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT>#endif</TT> new-line
<BR><BR><B>control-line</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT>#include</TT> pp-tokens new-line
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT>#define</TT> identifier &lt;pp-tokens &gt; new-line
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT>#define</TT> identifier<TT> (</TT> &lt;identifier-list &gt;<TT> )</TT>
&lt;pp-tokens &gt; new-line
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT>#undef</TT> identifier new-line
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT>#line</TT> pp-tokens new-line
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT>#error</TT> &lt;pp-tokens &gt; new-line
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT>#pragma</TT> &lt;pp-tokens &gt; new-line
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT>#</TT> new-line
<BR><BR><B>pp-tokens</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {preprocessing-token}<TT>(1)</TT>
<BR><BR><B>preprocessing-token</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; header-name (only within a<TT> #include</TT> directive)
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; identifier (no keyword distinction)
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; constant
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; string-literal
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; operator
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; punctuator
<BR>&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; each non-white-space character that cannot be one of the above
<BR><BR><B>header-name</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <TT>&lt;</TT>{h-char}<TT>(0)</TT><TT>&gt;</TT>
<BR><BR><B>h-char</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; any character in the source character set except<B> new-line</B> and<TT>
&gt;</TT>
<BR><BR><B>new-line</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the new-line character
<H1 ID="Translation_Limits"> Translation Limits </H1>
<BR>All standard-conforming C compilers must be able to translate and execute a program that contains one instance of every
one of the following limits.&nbsp; Each limit is the minimum limit (the smallest maximum) that the compiler may impose.
<BR><BR><B>&nbsp; The Open Watcom C/16 and C/32 compilers do not impose any arbitrary restrictions in any of these areas.
&nbsp;Restrictions arise solely because of memory limitations.</B>
<UL>
<LI>15 nesting levels of compound statements, iteration control structures (<TT> for</TT>, <TT> do</TT>/<TT> while</TT>, <TT>
while</TT>), and selection control structures (<TT> if</TT>, <TT> switch</TT>),
<LI>8 nesting levels of conditional inclusion (<TT> #if</TT>),
<LI>12 pointer, array and function declarators (in any order) modifying an arithmetic, structure, union or incomplete type
in a declaration,
<LI>31 nesting levels of parenthesized declarators within a full declarator,
<LI>32 nesting levels of parenthesized expressions within a full expression,
<LI>31 significant initial characters in an internal identifier or a macro name,
<LI>6 significant initial characters in an external identifier,
<LI>511 external identifiers in one translation unit (module),
<LI>127 identifiers with block scope declared in one block,
<LI>1024 macro identifiers simultaneously defined in one translation unit (module),
<LI>31 parameters in one function definition,
<LI>31 arguments in one function call,
<LI>31 parameters in one macro definition,
<LI>31 parameters in one macro invocation,
<LI>509 characters in a logical (continued) source line,
<LI>509 characters in a character string literal or wide string literal (after concatenation),
<LI>32767 bytes in an object,
<LI>8 nesting levels for <TT> #include</TT>d files,
<LI>257 <TT> case</TT> labels for a <TT> switch</TT> statement (excluding those for any nested <TT> switch</TT> statements),
<LI>127 members in a single structure or union,
<LI>127 enumeration constants in a single enumeration,
<LI>15 levels of nested structure or union definitions in a single struct-declaration-list (structure or union definition).
</UL>
<H1 ID="Macros_for_Numerical_Limits"> Macros for Numerical Limits </H1>
<BR>Although the various numerical types may have different ranges depending on the implementation of the C compiler, it is
still possible to write programs that can adapt to these changing ranges.&nbsp; In most circumstances, it is clear whether
an integer object is sufficiently large to contain all necessary values for it, regardless of whether or not the integer is
only 16 bits.
<BR><BR>However, a programmer may want to be able to conditionally compile code based on information about the range of certain
types.&nbsp; The header <TT> &lt;limits.h&gt;</TT> defines a set of macros that describe the range of the various integer
types.&nbsp; The header <TT> &lt;float.h&gt;</TT> defines another set of macros that describe the range and other characteristics
of the various floating-point types.
<H2 ID="Numerical_Limits_for_Integer_Types"> Numerical Limits for Integer Types </H2>
<BR>The following macros are replaced by constant expressions that may be used in <TT> #if</TT> preprocessing directives.
&nbsp;For a compiler to conform to the C language standard, the magnitude of the value of the expression provided by the compiler
must equal or exceed the ISO value given below, and have the same sign.&nbsp; (Positive values must be greater than or equal
to the ISO value.&nbsp; Negative values must be less than or equal to the ISO value.) The values for the actual compilers
are shown following the ISO value.
<UL>
<LI>the number of bits in the smallest object that is not a bit-field (byte)
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Macro: CHAR_BIT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Value</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ISO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt;= 8</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/16 and C/32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;8</TT>
<LI>the minimum value for an object of type <TT> signed char</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Macro: SCHAR_MIN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Value</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ISO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;= -127</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/16 and C/32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;-128</TT>
<LI>the maximum value for an object of type <TT> signed char</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Macro: SCHAR_MAX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Value</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ISO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt;= 127</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/16 and C/32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;127</TT>
<LI>the maximum value for an object of type <TT> unsigned char</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Macro: UCHAR_MAX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Value</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ISO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt;= 255</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/16 and C/32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;255</TT>
<LI>the minimum value for an object of type <TT> char</TT>
<BR><BR>If <TT> char</TT> is <TT> unsigned</TT> (the default case)
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Macro: CHAR_MIN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Value</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ISO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/16 and C/32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;0</TT>
<BR><BR>If <TT> char</TT> is <TT> signed</TT> (by using the command-line switch to force it to be signed), then<TT> CHAR_MIN</TT>
is equivalent to<TT> SCHAR_MIN</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Macro: CHAR_MIN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Value</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ISO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;= -127</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/16 and C/32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;-128</TT>
<LI>the maximum value for an object of type <TT> char</TT>
<BR><BR>If <TT> char</TT> is <TT> unsigned</TT> (the default case), then<TT> CHAR_MAX</TT> is equivalent to<TT> UCHAR_MAX</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Macro: CHAR_MAX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Value</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ISO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt;= 255</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/16 and C/32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;255</TT>
<BR><BR>If <TT> char</TT> is <TT> signed</TT> (by using the command-line switch to force it to be signed), then<TT> CHAR_MAX</TT>
is equivalent to<TT> SCHAR_MAX</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Macro: CHAR_MAX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Value</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ISO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt;= 127</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/16 and C/32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;127</TT>
<LI>the maximum number of bytes in a multibyte character, for any supported locale
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Macro: MB_LEN_MAX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Value</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ISO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt;= 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/16 and C/32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;2</TT>
<LI>the minimum value for an object of type <TT> short int</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Macro: SHRT_MIN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Value</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ISO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;= -32767</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/16 and C/32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;-32768</TT>
<LI>the maximum value for an object of type <TT> short int</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Macro: SHRT_MAX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Value</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ISO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt;= 32767</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/16 and C/32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;32767</TT>
<LI>the maximum value for an object of type <TT> unsigned short int</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Macro: USHRT_MAX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Value</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ISO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt;= 65535</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/16 and C/32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;65535</TT>
<LI>the minimum value for an object of type <TT> int</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Macro: INT_MIN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Value</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ISO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt;= -32767</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-32768</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-2147483648</TT>
<LI>the maximum value for an object of type <TT> int</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Macro: INT_MAX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Value</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ISO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;= 32767</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
32767</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
2147483647</TT>
<LI>the maximum value for an object of type <TT> unsigned int</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Macro: UINT_MAX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Value</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ISO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&gt;= 65535</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
65535</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
4294967295</TT>
<LI>the minimum value for an object of type <TT> long int</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Macro: LONG_MIN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Value</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ISO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;= -2147483647</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/16 and C/32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;-2147483648</TT>
<LI>the maximum value for an object of type <TT> long int</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Macro: LONG_MAX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Value</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ISO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt;= 2147483647</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/16 and C/32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;2147483647</TT>
<LI>the maximum value for an object of type <TT> unsigned long int</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Macro: ULONG_MAX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Value</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ISO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt;= 4294967295</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/16 and C/32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;4294967295</TT>
<LI>the minimum value for an object of type <TT> long long int</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Macro: LLONG_MIN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Value</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ISO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;= -9223372036854775807</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/16 and C/32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;-9223372036854775808</TT>
<LI>the maximum value for an object of type <TT> long long int</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Macro: LLONG_MAX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Value</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ISO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt;= 9223372036854775807</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/16 and C/32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;9223372036854775807</TT>
<LI>the maximum value for an object of type <TT> unsigned long long int</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Macro: ULLONG_MAX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Value</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ISO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt;= 18446744073709551615</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/16 and C/32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;18446744073709551615</TT>
</UL>
<H2 ID="Numerical_Limits_for_FloatingMPoint_Types"> Numerical Limits for Floating-Point Types </H2>
<BR>The following macros are replaced by expressions which are not necessarily constant.&nbsp; For a compiler to conform to
the C language standard, the magnitude of the value of the expression provided by the compiler must equal or exceed the ISO
value given below, and have the same sign.&nbsp; (Positive values must be greater than or equal to the ISO value.&nbsp; Negative
values must be less than or equal to the ISO value.) The values for the actual compilers are shown following the ISO value.
&nbsp;Most compilers will exceed some of these values.
<BR><BR>For those characteristics that have three different macros, the macros that start with<TT> FLT_</TT> refer to type
<TT> float</TT>,<TT> DBL_</TT> refer to type <TT> double</TT> and<TT> LDBL_</TT> refer to type <TT> long double</TT>.
<UL>
<LI>the radix (base) of representation for the exponent
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Macro: FLT_RADIX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Value</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ISO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt;= 2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/16 and C/32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;2</TT>
<LI>the precision, or number of digits in the floating-point mantissa, expressed in terms of the<TT> FLT_RADIX</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Macro: FLT_MANT_DIG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Value</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ISO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; no value specified</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/16 and C/32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;23</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Macro: DBL_MANT_DIG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Value</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ISO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; no value specified</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/16 and C/32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;52</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Macro: LDBL_MANT_DIG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Value</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ISO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; no value specified</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/16 and C/32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;52</TT>
<LI>the number of decimal digits of precision
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Macro: FLT_DIG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Value</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ISO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt;= 6</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/16 and C/32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;6</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Macro: DBL_DIG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Value</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ISO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt;= 10</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/16 and C/32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;15</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Macro: LDBL_DIG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Value</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ISO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt;= 10</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/16 and C/32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;15</TT>
<LI>the minimum negative integer<B> n</B> such that<TT> FLT_RADIX</TT> raised to the power<B> n</B>, minus 1, is a normalized
floating-point number, or,
<UL>
<LI>the minimum exponent value in terms of<TT> FLT_RADIX</TT>, or,
<LI>the base<TT> FLT_RADIX</TT> exponent for the floating-point value that is closest, but not equal, to zero
</UL>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Macro: FLT_MIN_EXP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Value</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ISO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; no value specified</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/16 and C/32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;-127</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Macro: DBL_MIN_EXP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Value</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ISO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; no value specified</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/16 and C/32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;-1023</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Macro: LDBL_MIN_EXP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Value</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ISO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; no value specified</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/16 and C/32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;-1023</TT>
<LI>the minimum negative integer<B> n</B> such that 10 raised to the power<B> n</B> is in the range of normalized floating-point
numbers, or,
<UL>
<LI>the base 10 exponent for the floating-point value that is closest, but not equal, to zero
</UL>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Macro: FLT_MIN_10_EXP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Value</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ISO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;= -37</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/16 and C/32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;-38</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Macro: DBL_MIN_10_EXP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Value</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ISO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;= -37</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/16 and C/32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;-307</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Macro: LDBL_MIN_10_EXP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Value</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ISO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;= -37</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/16 and C/32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;-307</TT>
<LI>the maximum integer<B> n</B> such that<TT> FLT_RADIX</TT> raised to the power<B> n</B>, minus 1, is a representable finite
floating-point number, or,
<UL>
<LI>the maximum exponent value in terms of<TT> FLT_RADIX</TT>, or,
<LI>the base<TT> FLT_RADIX</TT> exponent for the largest valid floating-point value
</UL>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Macro: FLT_MAX_EXP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Value</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ISO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; no value specified</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/16 and C/32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;127</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Macro: DBL_MAX_EXP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Value</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ISO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; no value specified</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/16 and C/32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;1023</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Macro: LDBL_MAX_EXP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Value</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ISO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; no value specified</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/16 and C/32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;1023</TT>
<LI>the maximum integer<B> n</B> such that 10 raised to the power<B> n</B> is a representable finite floating-point number,
or,
<UL>
<LI>the base 10 exponent for the largest valid floating-point value
</UL>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Macro: FLT_MAX_10_EXP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Value</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ISO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt;= 37</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/16 and C/32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;38</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Macro: DBL_MAX_10_EXP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Value</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ISO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt;= 37</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/16 and C/32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;308</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Macro: LDBL_MAX_10_EXP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Value</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ISO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt;= 37</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/16 and C/32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;308</TT>
<LI>the maximum representable finite floating-point number
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Macro: FLT_MAX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Value</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ISO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt;= 1E+37</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/16 and C/32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;3.402823466E+38</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Macro: DBL_MAX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Value</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ISO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt;= 1E+37</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/16 and C/32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;1.79769313486231560E+308</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Macro: LDBL_MAX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Value</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ISO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt;= 1E+37</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/16 and C/32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;1.79769313486231560E+308</TT>
<LI>the difference between<TT> 1.0</TT> and the least value greater than<TT> 1.0</TT> that is representable in the given floating-point
type, or,
<UL>
<LI>the smallest number<TT> eps</TT> such that<TT> (1.0 + eps) != 1.0</TT>
</UL>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Macro: FLT_EPSILON&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Value</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ISO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;= 1E-5</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/16 and C/32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;1.192092896E-15</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Macro: DBL_EPSILON&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Value</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ISO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;= 1E-9</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/16 and C/32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;2.2204460492503131E-16</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Macro: LDBL_EPSILON&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Value</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ISO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;= 1E-9</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/16 and C/32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;2.2204460492503131E-16</TT>
<LI>the minimum positive normalized floating-point number
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Macro: FLT_MIN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Value</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ISO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;= 1E-37</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/16 and C/32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;1.175494351E-38</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Macro: DBL_MIN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Value</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ISO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;= 1E-37</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/16 and C/32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;2.22507385850720160E-308</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Macro: LDBL_MIN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Value</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ISO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;= 1E-37</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Open Watcom C/16 and C/32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;2.22507385850720160E-308</TT>
</UL>
<BR>As discussed in the section &quot;Integer to Floating-Point Conversion&quot;, the macro<TT> FLT_ROUNDS</TT> is replaced
by a constant expression whose value indicates what kind of rounding occurs following a floating-point operation.&nbsp; The
following table gives the value of<TT> FLT_ROUNDS</TT> and its meaning:
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; FLT_ROUNDS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Technique</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ----------&nbsp; ------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; indeterminable</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; toward zero</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; to nearest number</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; toward positive infinity</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; toward negative infinity</TT>
<BR><BR>If<TT> FLT_ROUNDS</TT> has any other value, the rounding mechanism is implementation-defined.
<BR><BR><B>&nbsp; For the Open Watcom C/16 and C/32 compiler, the value of</B><TT> FLT_ROUNDS</TT><B> is 1, meaning that floating-point
values are rounded to the nearest representable number.</B>
<H1 ID="ImplementationMDefined_Behavior"> Implementation-Defined Behavior </H1>
<BR>This appendix describes the behavior of Open Watcom C/16 and C/32 when the standard describes the behavior as<B> implementation-defined.</B>
&nbsp;The term describing each behavior is taken directly from the ISO/ANSI C Language standard.&nbsp; The numbers in parentheses
at the end of each term refers to the section of the standard that discusses the behavior.
<H2 ID="Translation"> Translation </H2>
<BR><B>How a diagnostic is identified (5.1.1.3).</B>
<BR><BR>&nbsp;&nbsp; A diagnostic message appears as:
<BR><BR><B>&nbsp;&nbsp;&nbsp;&nbsp; filename</B>(<B>line-number</B>):<B>&nbsp; error-type</B>!<B>&nbsp; msg-number</B>:<B>
&nbsp;msg_text</B>
<BR><BR>&nbsp;&nbsp; where:
<DL>
<DT>filename
<DD>is the name of the source file where the error was detected.&nbsp; If the error was found in a file included from the source
file specified on the compiler command line, then the name of the included file will appear.
<DT>line-number
<DD>is the source line number in the named file where the error was detected.
<DT>error-type
<DD>is either the word<TT> Error</TT> for errors that prevent the compile from completing successfully (no code will be generated),
or<TT> Warning</TT> for conditions detected by the compiler that may not do what the programmer expected, but are otherwise
valid.&nbsp; Warnings will not prevent the compiler from generating code.&nbsp; The issuance of warnings may be controlled
by a command-line switch.&nbsp; See the User's Guide for details.
<DT>msg-number
<DD>is the letter<TT> E</TT> (for errors) followed by a four digit error number, or the letter<TT> W</TT> (for warnings) followed
by a three digit warning number.&nbsp; Each message has its own unique message number.
<DT>msg-text
<DD>is a descriptive message indicating the problem.
</DL>
<BR>Example:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; test.c(35): Warning! W301: No prototype found for 'GetItem'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; test.c(57): Error! E1009: Expecting '}' but found ','</TT>
<H2 ID="Environment"> Environment </H2>
<BR><B>The semantics of the arguments to main (5.1.2.2.1).</B>
<BR><BR>&nbsp;&nbsp; Each blank-separated token, except within quoted strings, on the command line is made into a string that
is an element of <TT> argv.</TT>&nbsp; Quoted strings are maintained as one element.
<BR><BR>&nbsp;&nbsp; For example, for the command line,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pgm 2+ 1 tokens &quot;one token&quot;</TT>
<BR><BR>&nbsp;&nbsp; <TT> argc</TT> would have the value<TT> 5</TT>, and the five elements of<TT> argv</TT> would be,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pgm</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tokens</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; one token</TT>
<BR><BR><B>What constitutes an interactive device (5.1.2.3).</B>
<BR><BR>&nbsp;&nbsp; For Open Watcom C/16 and C/32, the keyboard and the video display are considered interactive devices.
<H2 ID="Behaviour_Concerning_Identifiers"> Behaviour Concerning Identifiers </H2>
<BR><B>The number of significant initial characters (beyond 31) in an identifier without external linkage (6.1.2).</B>
<BR><BR>&nbsp;&nbsp; Unlimited.
<BR><BR><B>The number of significant initial characters (beyond 6) in an identifier with external linkage (6.1.2).</B>
<BR><BR>&nbsp;&nbsp; The Open Watcom C/16 and C/32 compilers do not impose a limit.&nbsp; The Open Watcom Linker limits significant
characters to 40.
<BR><BR><B>Whether case distinctions are significant in an identifier with external linkage (6.1.2).</B>
<BR><BR>&nbsp;&nbsp; The Open Watcom C/16 and C/32 compilers produce object names in mixed case.&nbsp; The Open Watcom Linker
provides an option to respect or ignore case when resolving linkages.&nbsp; By default, the linker respects case.&nbsp; See
the Open Watcom Linker User's Guide for details.
<H2 ID="Characters"> Characters </H2>
<BR><B>The members of the source and execution character sets, except as explicitly specified in the standard (5.2.1).</B>
<BR><BR>&nbsp;&nbsp; The full IBM PC character set is available in both the source and execution character sets.&nbsp; The
set of values between 0x20 and 0x7F are the ASCII character set.
<BR><BR><B>The shift states used for the encoding of multibyte characters (5.2.1.2).</B>
<BR><BR>&nbsp;&nbsp; There are no shift states in the support for multibyte characters.
<BR><BR><B>The number of bits in a character in the execution character set (5.2.4.2.1).</B>
<BR><BR>&nbsp;&nbsp; 8
<BR><BR><B>The mapping of members of the source character set (in character constants and string literals) to members of the
execution character set (6.1.3.4).</B>
<BR><BR>&nbsp;&nbsp; Both the source and execution character sets are the full IBM PC character set for whichever code page
is in effect.&nbsp; In addition, the following table shows escape sequences available in the source character set, and what
they translate to in the execution character set.&nbsp; 
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Escape&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Hex</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Sequence&nbsp;&nbsp;&nbsp; Value&nbsp;&nbsp; Meaning</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --------&nbsp;&nbsp;&nbsp; -----&nbsp;&nbsp; -------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 07&nbsp;&nbsp;
&nbsp;&nbsp; Bell or alert</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 08&nbsp;&nbsp;
&nbsp;&nbsp; Backspace</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \f&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0C&nbsp;&nbsp;
&nbsp;&nbsp; Form feed</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0A&nbsp;&nbsp;
&nbsp;&nbsp; New-line</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0D&nbsp;&nbsp;
&nbsp;&nbsp; Carriage return</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 09&nbsp;&nbsp;
&nbsp;&nbsp; Horizontal tab</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \v&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0B&nbsp;&nbsp;
&nbsp;&nbsp; Vertical tab</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 27&nbsp;&nbsp;
&nbsp;&nbsp; Apostrophe or single quote</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 22&nbsp;
&nbsp;&nbsp;&nbsp; Double quote</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3F&nbsp;&nbsp;
&nbsp;&nbsp; Question mark</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5C&nbsp;&nbsp;
&nbsp;&nbsp; Backslash</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \ddd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; Octal value</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \xddd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; Hexadecimal value</TT>
<BR><BR><B>The value of an integer character constant that contains a character or escape sequence that is not represented
in the execution character set or the extended character set for a wide character constant (6.1.3.4).</B>
<BR><BR>&nbsp;&nbsp; Not possible.&nbsp; Both the source and execution character sets are the IBM PC character set.&nbsp;
Thus, all characters in the source character set map directly to the execution character set.
<BR><BR><B>The value of an integer character constant that contains more than one character or a wide character constant that
contains more than one multibyte character (6.1.3.4).</B>
<BR><BR>&nbsp;&nbsp; A multi-character constant is stored with the right-most character in the lowest-order (least significant)
byte, and subsequent characters (moving to the left) being placed in higher-order (more significant) bytes.&nbsp; Up to four
characters may be placed in a character constant.
<BR><BR><B>The current locale used to convert multibyte characters into corresponding wide characters (codes) for a wide character
constant (6.1.3.4).</B>
<BR><BR>&nbsp;&nbsp; The Open Watcom C/16 and C/32 compilers currently support only the<TT> &quot;C&quot;</TT> locale, using
North American English, and translates code page 437 to UNICODE.
<BR><BR>&nbsp;&nbsp; To support multibyte characters, a command line switch can be used to indicate which multibyte character
set to use.&nbsp; See the User's Guide for details.
<BR><BR><B>Whether a plain </B><TT> char</TT><B> has the same range of values as </B><TT> signed char</TT><B> or </B><TT>
unsigned char</TT><B> (6.2.1.1).&nbsp; </B>
<BR><BR>&nbsp;&nbsp; Open Watcom C/16 and C/32 treat <TT> char</TT> as <TT> unsigned</TT>, although a compiler command line
switch can be used to make it <TT> signed</TT>.
<H2 ID="Integers"> Integers </H2>
<BR><B>The representations and sets of values of the various types of integers (6.1.2.5).</B>
<BR><BR>&nbsp;&nbsp; Integers are stored using 2's complement form.&nbsp; The high bit of each signed integer is a sign bit.
&nbsp;If the sign bit is 1, the value is negative.
<BR><BR>&nbsp;&nbsp; The ranges of the various integer types are described in the section &quot;Integer Types&quot;.
<BR><BR><B>The result of converting an integer to a shorter signed integer, or the result of converting an unsigned integer
to a signed integer of equal length, if the value cannot be represented (6.2.1.2).</B>
<BR><BR>&nbsp;&nbsp; When converting to a shorter type, the high-order bits of the longer value are discarded, and the remaining
bits are interpreted according to the new type.
<BR><BR>&nbsp;&nbsp; For example, converting the signed long integer<TT> -15584170</TT> (hexadecimal<TT> 0xFF123456</TT>)
to a signed short integer yields the result<TT> 13398</TT> (hexadecimal<TT> 0x3456</TT>).
<BR><BR>&nbsp;&nbsp; When converting an unsigned integer to a signed integer of equal length, the bits are simply re-interpreted
according to the new type.
<BR><BR>&nbsp;&nbsp; For example, converting the unsigned short integer<TT> 65535</TT> (hexadecimal<TT> 0xFFFF</TT>) to a
signed short integer yields the result<TT> -1</TT> (hexadecimal<TT> 0xFFFF</TT>).
<BR><BR><B>The results of bitwise operations on signed integers (6.3).</B>
<BR><BR>&nbsp;&nbsp; The sign bit is treated as any other bit during bitwise operations.&nbsp; At the completion of the operation,
the new bit pattern is interpreted according to the result type.
<BR><BR><B>The sign of the remainder on integer division (6.3.5).</B>
<BR><BR>&nbsp;&nbsp; The remainder has the same sign as the numerator (left operand).
<BR><BR><B>The result of a right shift of a negative-valued signed integral type (6.3.7).</B>
<BR><BR>&nbsp;&nbsp; A right shift of a signed integer will leave the higher, vacated bits with the original value of the
high bit.&nbsp; In other words, the sign bit is propogated to fill bits vacated by the shift.
<BR><BR>&nbsp;&nbsp; For example, the result of<TT> ((short) 0x0123) &gt;&gt; 4</TT> would be<TT> 0x0012.</TT>&nbsp; The result
of<TT> ((short) 0xFEFE) &gt;&gt; 4</TT> will be<TT> 0xFFEF.</TT>
<H2 ID="Floating_Point"> Floating Point </H2>
<BR><B>The representations and sets of values of the various types of floating-point numbers (6.1.2.5).</B>
<BR><BR>&nbsp;&nbsp; These are discussed in the section &quot;Floating-Point Types&quot;.&nbsp; The floating-point format
used is the IEEE Standard for Binary Floating-Point Arithmetic as defined in the ANSI/IEEE Standard 754-1985.
<BR><BR><B>The direction of truncation when an integral number is converted to a floating-point number that cannot exactly
represent the original value (6.2.1.3).</B>
<BR><BR>&nbsp;&nbsp; Truncation is only possible when converting a <TT> long int</TT> (signed or unsigned) to <TT> float</TT>.
&nbsp;The 24 most-significant bits (including sign bit) are used.&nbsp; The 25th is examined, and if it is 1, the value is
rounded up by adding one to the 24-bit value.&nbsp; The remaining bits are ignored.
<BR><BR><B>The direction of truncation or rounding when a floating-point number is converted to a narrower floating-point
number (6.2.1.4).</B>
<BR><BR>&nbsp;&nbsp; The value is rounded to the nearest value in the smaller type.
<H2 ID="Arrays_and_Pointers"> Arrays and Pointers </H2>
<BR><B>The type of integer required to hold the maximum size of an array - that is, the type of the </B><TT> sizeof</TT><B>
operator, </B><TT> size_t</TT><B> (6.3.3.4, 7.1.1).</B>
<BR><BR>&nbsp;&nbsp; <TT> unsigned int</TT>
<BR><BR><B>The result of casting an integer to a pointer or vice versa (6.3.4).</B>
<BR><BR>&nbsp;&nbsp; Open Watcom C/16 conversion of pointer to integer:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Pointer&nbsp;&nbsp;&nbsp;&nbsp; short int</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long int</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ----------- --------------------------- ---------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; near&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result is pointer value
&nbsp;&nbsp;&nbsp; result is DS register in</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; high-order 2 bytes, pointer</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value in low-order 2 bytes</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ----------- --------------------------- ---------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; far&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; segment is discarded, result
result is segment in high-</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; huge&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; is pointer offset (low-order order
2 bytes, offset in</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2 bytes
of pointer)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; low-order 2 bytes</TT>
<BR><BR>&nbsp;&nbsp; Open Watcom C/16 conversion of integer to pointer:
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Integer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; far
pointer</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; near pointer&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; huge pointer</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ----------- --------------------------- ---------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short int&nbsp;&nbsp; result is integer value&nbsp;&nbsp;&nbsp;&nbsp; result
segment is DS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; register, offset is</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer value</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ----------- --------------------------- ---------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long int&nbsp;&nbsp;&nbsp; result is low-order 2&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; result segment is high-</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
byte of integer value&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; order 2 bytes, offset is</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; low-order 2 bytes</TT>
<BR><BR>&nbsp;&nbsp; Open Watcom C/32 conversion of pointer to integer:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Pointer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long int</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ----------- --------------------------- ---------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; near&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result is low-order 2&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; result is pointer value</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
byte of pointer value</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ----------- --------------------------- ---------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; far&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; segment is discarded,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; segment is discarded,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; huge&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result is low-order 2&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; result is pointer offset</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
bytes of pointer value</TT>
<BR><BR>&nbsp;&nbsp; Open Watcom C/32 conversion of integer to pointer:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Integer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; far
pointer</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; near pointer&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; huge pointer</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ----------- --------------------------- ---------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short int&nbsp;&nbsp; result is integer value,&nbsp;&nbsp;&nbsp; result
segment is DS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
with zeroes for high-order&nbsp; register, offset is integer</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
2 bytes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;value, with zeroes for</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; high-order 2 bytes</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ----------- --------------------------- ---------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result is integer value
&nbsp;&nbsp;&nbsp; result segment is DS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; register,
offset is</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer value</TT>
<BR><BR><B>The type of integer required to hold the difference between two pointers to elements of the same array, </B><TT>
ptrdiff_t</TT><B> (6.3.6, 7.1.1).</B>
<BR><BR>&nbsp;&nbsp; If the huge memory model is being used, <TT> ptrdiff_t</TT> has type <TT> long int</TT>.
<BR><BR>&nbsp;&nbsp; For all other memory models, <TT> ptrdiff_t</TT> has type <TT> int</TT>.
<BR><BR>&nbsp;&nbsp; If two huge pointers are subtracted and the huge memory model is not being used, then the result type
will be <TT> long int</TT> even though <TT> ptrdiff_t</TT> is <TT> int</TT>.
<H2 ID="Registers"> Registers </H2>
<BR><B>The extent to which objects can actually be placed in registers by use of the </B><TT> register</TT><B> storage-class
specifier (6.5.1).</B>
<BR><BR>&nbsp;&nbsp; The Open Watcom C/16 and C/32 compilers may place any object that is sufficiently small, including a
small structure, in one or more registers.
<BR><BR>&nbsp;&nbsp; The number of objects that can be placed in registers varies, and is decided by the compiler.&nbsp; The
keyword <TT> register</TT> does not control the placement of objects in registers.
<H2 ID="Structures__Unions__Enumerations_and_BitMFields"> Structures, Unions, Enumerations and Bit-Fields </H2>
<BR><B>A member of a union object is accessed using a member of a different type (6.3.2.3).</B>
<BR><BR>&nbsp;&nbsp; The behavior is undefined.&nbsp; Whatever bit values are present as were stored via one member will be
extracted via another.
<BR><BR><B>The padding and alignment of members of structures (6.5.2.1).</B>
<BR><BR>&nbsp;&nbsp; The Open Watcom C/16 and C/32 compilers align structure members by default.&nbsp; A command line switch,
or the<TT> pack</TT> pragma, may be used to override the default.&nbsp; See the User's Guide for default values and other
details.
<BR><BR><B>Whether a &quot;plain&quot; </B><TT> int</TT><B> bit-field is treated as a </B><TT> signed int</TT><B> bit-field
or as an </B><TT> unsigned int</TT><B> bit-field (6.5.2.1).</B>
<BR><BR>&nbsp;&nbsp; <TT> signed int</TT>
<BR><BR><B>The order of allocation of bit-fields within a unit (6.5.2.1).</B>
<BR><BR>&nbsp;&nbsp; Low-order (least significant) bit to high-order bit.
<BR><BR><B>Whether a bit-field can straddle a storage-unit boundary (6.5.2.1).</B>
<BR><BR>&nbsp;&nbsp; Bit-fields may not straddle storage-unit boundaries.&nbsp; If there is insufficient room to store a subsequent
bit-field in a storage-unit, then it will be placed in the next storage-unit.
<BR><BR><B>The integer type chosen to represent the values of an enumeration type (6.5.2.2).</B>
<BR><BR>&nbsp;&nbsp; By default, Open Watcom C/16 and C/32 will use the smallest integer type that can accommodate all values
in the enumeration.&nbsp; The first appropriate type will be chosen according to the following table:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Smallest&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; Largest</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; Value&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;Value</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ------------------&nbsp; ---------------------&nbsp; ----------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signed char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -128&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 127</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 255</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signed short&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -32768&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32767</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned short&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 65535</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signed long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -2147483648&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
2147483647</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4294967295</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signed long long&nbsp;&nbsp;&nbsp; -9223372036854775808&nbsp;&nbsp;&nbsp;
&nbsp;9223372036854775807</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp; 18446744073709551615</TT>
<BR><BR>&nbsp;&nbsp; Both compilers have a command-line switch that force all enumerations to type <TT> int</TT>.&nbsp; See
the User's Guide for details.
<H2 ID="Qualifiers"> Qualifiers </H2>
<BR><B>What constitutes an access to an object that has volatile-qualified type (6.5.5.3).</B>
<BR><BR>&nbsp;&nbsp; Any reference to a volatile object is also an access to that object.
<H2 ID="Declarators"> Declarators </H2>
<BR><B>The maximum number of declarators that may modify an arithmetic, structure or union type (6.5.4).</B>
<BR><BR>&nbsp;&nbsp; Limited only by available memory.
<H2 ID="Behaviour_Concerning_Statements"> Behaviour Concerning Statements </H2>
<BR><B>The maximum number of </B><TT> case</TT><B> values in a </B><TT> switch</TT><B> statement (6.6.4.2).</B>
<BR><BR>&nbsp;&nbsp; Limited only by available memory.
<H2 ID="Preprocessing_Directives"> Preprocessing Directives </H2>
<BR><B>Whether the value of a single-character character constant in a constant expression that controls conditional inclusion
matches the value of the same character constant in the execution character set.&nbsp; Whether such a character constant may
have a negative value (6.8.1).</B>
<BR><BR>&nbsp;&nbsp; The character sets are the same so characters will match.&nbsp; Character constants are unsigned quantities,
so no character will be negative.
<BR><BR><B>The method for locating includable source files (6.8.2).&nbsp; </B>
<BR><BR>&nbsp;&nbsp; See the User's Guide for full details of how included files are located.
<BR><BR><B>The support of quoted names for includable source files (6.8.2).</B>
<BR><BR>&nbsp;&nbsp; See the User's Guide for full details of how included files are located.
<BR><BR><B>The mapping of source file character sequences (6.8.2).</B>
<BR><BR>&nbsp;&nbsp; The source and execution character sets are the same.&nbsp; Escape sequences are not supported in preprocessor
directives.
<BR><BR><B>The behavior of each recognized </B><TT> #pragma</TT><B> directive (6.8.6).</B>
<BR><BR>&nbsp;&nbsp; See the User's Guide.
<BR><BR><B>The definitions for </B><TT> __DATE__</TT><B> and </B><TT> __TIME__</TT><B> when respectively, the date and time
of translation are not available (6.8.8).</B>
<BR><BR>&nbsp;&nbsp; The date and time are always available.
<H2 ID="Library_Functions"> Library Functions </H2>
<BR><B>The null pointer constant to which the macro </B><TT> NULL</TT><B> expands (7.1.6).</B>
<BR><BR>&nbsp;&nbsp; For Open Watcom C/16, the <TT> NULL</TT> macro expands to<TT> 0</TT> for the small and medium (small
data) memory models, and to<TT> 0L</TT> for the compact, large and huge (big data) memory models.
<BR><BR>&nbsp;&nbsp; For Open Watcom C/32, the <TT> NULL</TT> macro expands to<TT> 0.</TT>
<BR><BR>The implementation-defined behavior of the library functions is described in the Open Watcom C Library Reference manual.
<H1 ID="Examples_of_Declarations"> Examples of Declarations </H1>
<BR>This chapter presents a series of examples of declarations of objects and functions.&nbsp; Along with each example is
a description that indicates how to read the declaration.
<BR><BR>This chapter may be used as a &quot;cookbook&quot; for declarations.&nbsp; Some complicated but commonly required
declarations are given here.
<BR><BR>The first examples are very simple, and build in complexity.&nbsp; Some of the examples given near the end of each
section are unlikely to ever be required in a real program, but hopefully they will provide an understanding of how to read
and write C declarations.
<BR><BR>To reduce the complexity and to better illustrate how a small difference in the declaration can mean a big difference
in the meaning, the following rules are followed:
<OL>
<LI>if an object is being declared, it is called<TT> x</TT> or<TT> X</TT>,
<LI>if a function is being declared, it is called<TT> F</TT>,
<LI>if an object is being declared, it usually has type <TT> int</TT>, although any other type may be substituted,
<LI>if a function is being declared, it usually returns type <TT> int</TT>, although any other type may be substituted.
</OL>
<BR>Storage class specifiers (<TT> extern</TT>, <TT> static</TT>, <TT> auto</TT> or <TT> register</TT>) have purposely been
omitted.
<H2 ID="Object_Declarations"> Object Declarations </H2>
<BR>Here are some examples of object (variable) declarations:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int x;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp; 1</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; (1)</TT><TT>x</TT> is an<TT> (2)</TT>integer.
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int * x;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp; 2 1</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; (1)</TT><TT>x</TT> is a<TT> (2)</TT>pointer to an<TT> (3)</TT>integer.
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int ** x;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp; 32 1</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; (1)</TT><TT>x</TT> is a<TT> (2)</TT>pointer to a<TT> (3)</TT>pointer to an<TT> (4)</TT>integer.
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; const int x;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp; 3&nbsp; 1</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; (1)</TT><TT>x</TT> is a<TT> (2)</TT>constant<TT> (3)</TT>integer.
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int const x;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp; 1</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; (1)</TT><TT>x</TT> is a<TT> (2)</TT>constant<TT> (3)</TT>integer (same as above).
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; const int * x;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp; 4&nbsp; 2 1</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; (1)</TT><TT>x</TT> is a<TT> (2)</TT>pointer to a<TT> (3)</TT>constant<TT> (4)</TT>integer.
&nbsp;The value of<TT> x</TT> may change, but the integer that it points to may not be changed.&nbsp; In other words,<TT>
*x</TT> cannot be modified.
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int * const x;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp; 3&nbsp;&nbsp; 2&nbsp;&nbsp; 1</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; (1)</TT><TT>x</TT> is a<TT> (2)</TT>constant<TT> (3)</TT>pointer to an<TT> (4)</TT>integer.
&nbsp;The value of<TT> x</TT> may not change, but the integer that it points to may change.&nbsp; In other words,<TT> x</TT>
will always point at the same location, but the contents of that location may vary.
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; const int * const x;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp; 5&nbsp; 3&nbsp;&nbsp; 2&nbsp;&nbsp; 1</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; (1)</TT><TT>x</TT> is a<TT> (2)</TT>constant<TT> (3)</TT>pointer to a<TT> (4)</TT>constant<TT>
(5)</TT>integer.&nbsp; The value of<TT> x</TT> may not change, and the integer that it points to may not change.&nbsp; In
other words,<TT> x</TT> will always point at the same location, which cannot be modified via<TT> x.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int x[];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp; 12</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; (1)</TT><TT>x</TT> is an<TT> (2)</TT>array of<TT> (3)</TT>integers.
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int x[53];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp; 123</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; (1)</TT><TT>x</TT> is an<TT> (2)</TT>array of<TT> (3)</TT>53<TT> (4)</TT>integers.
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int * x[];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp; 3 12</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; (1)</TT><TT>x</TT> is an<TT> (2)</TT>array of<TT> (3)</TT>pointers to<TT> (4)</TT>integer.
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int (*x)[];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp; 21 3</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; (1)</TT><TT>x</TT> is a<TT> (2)</TT>pointer to an<TT> (3)</TT>array of<TT> (4)</TT>integers.
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int * (*x)[];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5&nbsp; 4&nbsp; 21 3</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; (1)</TT><TT>x</TT> is a<TT> (2)</TT>pointer to an<TT> (3)</TT>array of<TT> (4)</TT>pointers
to<TT> (5)</TT>integer.
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int (*x)();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp; 21 3</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; (1)</TT><TT>x</TT> is a<TT> (2)</TT>pointer to a<TT> (3)</TT>function returning an<TT> (4)</TT>integer.
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int (*x[25])();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6&nbsp;&nbsp; 4123&nbsp;&nbsp; 5</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; (1)</TT><TT>x</TT> is an<TT> (2)</TT>array of<TT> (3)</TT>25<TT> (4)</TT>pointers to<TT> (5)</TT>functions
returning an<TT> (6)</TT>integer.
<H2 ID="Function_Declarations"> Function Declarations </H2>
<BR>Here are some examples of function declarations:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int F();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp; 12</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; (1)</TT><TT>F</TT> is a<TT> (2)</TT>function returning an<TT> (3)</TT>integer.
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int * F();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp; 3 12</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; (1)</TT><TT>F</TT> is a<TT> (2)</TT>function returning a<TT> (3)</TT>pointer to an<TT> (4)</TT>integer.
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int (*F())();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5&nbsp;&nbsp; 312&nbsp; 4</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; (1)</TT><TT>F</TT> is a<TT> (2)</TT>function returning a<TT> (3)</TT>pointer to a<TT> (4)</TT>function
returning an<TT> (5)</TT>integer.
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int * (*F())();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6&nbsp; 5&nbsp; 312&nbsp; 4</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; (1)</TT><TT>F</TT> is a<TT> (2)</TT>function returning a<TT> (3)</TT>pointer to a<TT> (4)</TT>function
returning a<TT> (5)</TT>pointer to an<TT> (6)</TT>integer.
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int (*F())[];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5&nbsp;&nbsp; 312&nbsp; 4</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; (1)</TT><TT>F</TT> is a<TT> (2)</TT>function returning a<TT> (3)</TT>pointer to an<TT> (4)</TT>array
of<TT> (5)</TT>integers.
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int (*(*F())[])();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7&nbsp;&nbsp; 5 312&nbsp; 4&nbsp; 6</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; (1)</TT><TT>F</TT> is a<TT> (2)</TT>function returning a<TT> (3)</TT>pointer to an<TT> (4)</TT>array
of<TT> (5)</TT>pointers to<TT> (6)</TT>functions returning an<TT> (7)</TT>integer.
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int * (*(*F())[])();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8&nbsp; 7&nbsp; 5 312&nbsp; 4&nbsp; 6</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; (1)</TT><TT>F</TT> is a<TT> (2)</TT>function returning a<TT> (3)</TT>pointer to an<TT> (4)</TT>array
of<TT> (5)</TT>pointers to<TT> (6)</TT>functions returning a<TT> (7)</TT>pointer to an<TT> (8)</TT>integer.
<H2 ID="___far_____near_and____huge_Declarations"> _ _far, _ _near and _ _huge Declarations </H2>
<BR>The following examples illustrate the use of the <TT> __far</TT> and <TT> __huge</TT> keywords.
<BR><BR>The use of the <TT> __near</TT> keyword is symmetrical with the use of the <TT> __far</TT> keyword, so no examples
of <TT> __near</TT> are shown.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int __far X;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp; 1</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; (1)</TT><TT>X</TT> is a<TT> (2)</TT>far<TT> (3)</TT>integer.
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int * __far x;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp; 3&nbsp;&nbsp; 2&nbsp;&nbsp; 1</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; (1)</TT><TT>x</TT> is<TT> (2)</TT>far, and is a<TT> (3)</TT>pointer to an<TT> (4)</TT>integer.
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int __far * x;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp; 3 1</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; (1)</TT><TT>x</TT> is a<TT> (2)</TT>far<TT> (3)</TT>pointer to an<TT> (4)</TT>integer.
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int __far * __far x;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp; 4&nbsp;&nbsp; 2&nbsp;&nbsp; 1</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; (1)</TT><TT>x</TT> is<TT> (2)</TT>far, and is a<TT> (3)</TT>far<TT> (4)</TT>pointer to an<TT>
(5)</TT>integer.
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int __far X[];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp; 13</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; (1)</TT><TT>X</TT> is a<TT> (2)</TT>far<TT> (3)</TT>array of<TT> (4)</TT>integers.
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int __huge X[];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp; 13</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; (1)</TT><TT>x</TT> is a<TT> (2)</TT>huge<TT> (3)</TT>array of<TT> (4)</TT>integers (<TT>X</TT>
is an array that can exceed 64K in size.)
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int * __far X[];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5&nbsp; 4&nbsp;&nbsp; 2&nbsp;&nbsp; 13</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; (1)</TT><TT>X</TT> is a<TT> (2)</TT>far<TT> (3)</TT>array of<TT> (4)</TT>pointers to<TT> (5)</TT>integers.
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int __far * X[];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp; 4 12</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; (1)</TT><TT>X</TT> is an<TT> (2)</TT>array of<TT> (3)</TT>far<TT> (4)</TT>pointers to<TT> (5)</TT>integers.
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int __far * __far X[];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp; 5&nbsp;&nbsp; 2&nbsp;&nbsp; 13</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; (1)</TT><TT>X</TT> is a<TT> (2)</TT>far<TT> (3)</TT>array of<TT> (4)</TT>far<TT> (5)</TT>pointers
to<TT> (6)</TT>integers.
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int __far F();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp; 13</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; (1)</TT><TT>F</TT> is a<TT> (2)</TT>far<TT> (3)</TT>function returning an<TT> (4)</TT>integer.
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int * __far F();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5&nbsp; 4&nbsp;&nbsp; 2&nbsp;&nbsp; 13</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; (1)</TT><TT>F</TT> is a<TT> (2)</TT>far<TT> (3)</TT>function returning a<TT> (4)</TT>pointer
to an<TT> (5)</TT>integer.
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int __far * F();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp; 4 12</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; (1)</TT><TT>F</TT> is a<TT> (2)</TT>function returning a<TT> (3)</TT>far<TT> (4)</TT>pointer
to an<TT> (5)</TT>integer.
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int __far * __far F();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp; 5&nbsp;&nbsp; 2&nbsp;&nbsp; 13</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; (1)</TT><TT>F</TT> is a<TT> (2)</TT>far<TT> (3)</TT>function returning a<TT> (4)</TT>far<TT>
(5)</TT>pointer to an<TT> (6)</TT>integer.
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int (__far * x)();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp; 3 1 4</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; (1)</TT><TT>x</TT> is a<TT> (2)</TT>far<TT> (3)</TT>pointer to a<TT> (4)</TT>function returning
an<TT> (5)</TT>integer.
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int __far * (* x)();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp; 5&nbsp; 2 1 3</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; (1)</TT><TT>x</TT> is a<TT> (2)</TT>pointer to a<TT> (3)</TT>function returning a<TT> (4)</TT>far<TT>
(5)</TT>pointer to an<TT> (6)</TT>integer.
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int __far * (__far * x)();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7&nbsp;&nbsp;&nbsp; 5&nbsp;&nbsp; 6&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp; 3 1 4</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; (1)</TT><TT>x</TT> is a<TT> (2)</TT>far<TT> (3)</TT>pointer to a<TT> (4)</TT>function returning
a<TT> (5)</TT>far<TT> (6)</TT>pointer to an<TT> (7)</TT>integer.
<H2 ID="___interrupt_Declarations"> _ _interrupt Declarations </H2>
<BR>The following example illustrates the use of the <TT> __interrupt</TT> keyword.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void __interrupt __far F();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
2&nbsp;&nbsp; 14</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp; (1)</TT><TT>F</TT> is a<TT> (2)</TT>far<TT> (3)</TT>interrupt<TT> (4)</TT>function returning<TT>
(5)</TT>nothing.
<H1 ID="A_Sample_Program"> A Sample Program </H1>
<BR>This chapter presents an entire C program, to illustrate many of the features of the language, and to illustrate elements
of programming style.
<BR><BR>This program implements a memo system suitable for maintaining a set of memos, and displaying them on the screen.
&nbsp;The program allows the user to display memos relevant to today's date, move through the memos adding new ones and replacing
or deleting existing ones.&nbsp; The program displays help information whenever an invalid action is entered, or when the
sole parameter to the program is a question mark.
<BR><BR>The program is in complete conformance to the ISO C standard.&nbsp; It should be able to run, without modification,
on any system that provides an ISO-conforming C compiler.
<H2 ID="The_memos_h_File"> The memos.h File </H2>
<BR>The source file<TT> memos.h</TT> contains the structures used for storing the memos:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* This structure is for an individual line in a memo.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef struct text_line {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct text_line * next;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; text[1];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; } TEXT_LINE;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* This structure is the head of an individual memo.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef struct memo_el {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct memo_el * prev;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct memo_el * next;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TEXT_LINE *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; text;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; date[9];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; } MEMO_EL;</TT>
<H2 ID="The_memos_c_File"> The memos.c File </H2>
<BR>The source for the program follows:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdlib.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;string.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;ctype.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;time.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &quot;memos.h&quot;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* This program implements a simple memo facility.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Memos may be added to a memo file, displayed</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * on the screen, and deleted.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Modified&nbsp;&nbsp;&nbsp;&nbsp; by&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; reason</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * ========&nbsp;&nbsp;&nbsp;&nbsp; ==&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; ======</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * 87/10/02&nbsp;&nbsp;&nbsp;&nbsp; Steve McDowell&nbsp; Initial implementation.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * 88/09/20&nbsp;&nbsp;&nbsp;&nbsp; Steve McDowell&nbsp; Fixed up some style issues,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; introduced use of TRUE and</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FALSE.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* Define some constants to make the code more readable.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define TRUE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define FALSE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define NULLCHAR&nbsp;&nbsp;&nbsp; '\0'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static const char FileName[] = { &quot;memos.db&quot; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static const char TempName[] = { &quot;tempmemo.db&quot; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static MEMO_EL *&nbsp; MemoHead&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = NULL;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MemosModified = FALSE;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; QuitFlag&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
= TRUE;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef enum {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INVALID,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HELP,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ADD,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DELETE,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REPLACE,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SHOW,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UP,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DOWN,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TOP,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TODAY,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SAVE,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; QUIT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; } ACTION;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* This table maps action keywords onto the &quot;actions&quot; defined</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * above. The table also defines short forms for the keywords.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef struct {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ACTION act;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char * keyword;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; } ACTION_MAP;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static ACTION_MAP KeywordMap[] = {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HELP,&nbsp;&nbsp;&nbsp; &quot;help&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HELP,&nbsp;&nbsp;&nbsp; &quot;h&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ADD,&nbsp;&nbsp;&nbsp;&nbsp; &quot;add&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ADD,&nbsp;&nbsp;&nbsp;&nbsp; &quot;a&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DELETE,&nbsp; &quot;delete&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DELETE,&nbsp; &quot;del&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REPLACE, &quot;replace&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REPLACE, &quot;rep&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SHOW,&nbsp;&nbsp;&nbsp; &quot;show&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SHOW,&nbsp;&nbsp;&nbsp; &quot;sh&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UP,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;up&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UP,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;u&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DOWN,&nbsp;&nbsp;&nbsp; &quot;down&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DOWN,&nbsp;&nbsp;&nbsp; &quot;d&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DOWN,&nbsp;&nbsp;&nbsp; &quot;&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TOP,&nbsp;&nbsp;&nbsp;&nbsp; &quot;top&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TODAY,&nbsp;&nbsp; &quot;today&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TODAY,&nbsp;&nbsp; &quot;tod&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SAVE,&nbsp;&nbsp;&nbsp; &quot;save&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SAVE,&nbsp;&nbsp;&nbsp; &quot;sa&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; QUIT,&nbsp;&nbsp;&nbsp; &quot;quit&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; QUIT,&nbsp;&nbsp;&nbsp; &quot;q&quot;,</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INVALID, &quot;&quot; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* Maximum buffer length (maximum length of line of memo).</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define MAXLEN 80</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* Function prototypes.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static TEXT_LINE *&nbsp; AddLine();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static MEMO_EL *&nbsp;&nbsp;&nbsp; AddMemo();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static MEMO_EL *&nbsp;&nbsp;&nbsp; DeleteMemo();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static MEMO_EL *&nbsp;&nbsp;&nbsp; DoActions();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static MEMO_EL *&nbsp;&nbsp;&nbsp; DoDownAction();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static MEMO_EL *&nbsp;&nbsp;&nbsp; DoUpAction();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static MEMO_EL *&nbsp;&nbsp;&nbsp; EnterAMemo();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static ACTION&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetAction();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static void *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MemoMAlloc();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static ACTION&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PromptAction();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static ACTION&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ReadAction();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static MEMO_EL *&nbsp;&nbsp;&nbsp; ReadAMemo();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static MEMO_EL *&nbsp;&nbsp;&nbsp; ShowTodaysMemos();</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int main( int argc, char * argv[] )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /****************************************/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; index;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MEMO_EL * el;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Memo facility\n&quot; );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* Check for a single argument that is a question mark,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * If found, then display the usage notes.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( argc == 2&nbsp; &amp;&amp;&nbsp; strcmp( argv[1], &quot;?&quot;
) == 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Usage();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit( 0 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ReadMemos();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MemosModified = FALSE;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; QuitFlag&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = FALSE;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* Use the command line parameters, if any, as the first</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * actions to be performed on the memos.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; el = NULL;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( index = 1; index &lt; argc; ++index ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; el = DoActions( el, GetAction( argv[index]
) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( QuitFlag ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( FALSE );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HandleMemoActions( el );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( FALSE );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static void ReadMemos( void )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /***************************/</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* Read the memos file, building the structure to contain it.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FILE *&nbsp;&nbsp;&nbsp; fid;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MEMO_EL * new_el;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MEMO_EL * prev_el;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mcount;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fid = fopen( FileName, &quot;r&quot; );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( fid == NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Memos file not found.&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&quot; Starting with no memos.\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* Loop reading entire memos.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prev_el = NULL;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( mcount = 0;; mcount++ ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new_el = ReadAMemo( fid );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( new_el == NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%d
memo(s) found.\n&quot;, mcount );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( fid );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( prev_el == NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MemoHead = new_el;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new_el-&gt;prev =
NULL;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prev_el-&gt;next
= new_el;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new_el-&gt;prev =
prev_el;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new_el-&gt;next = NULL;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prev_el = new_el;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static int ReadLine( char buffer[], int len, FILE * fid )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /*******************************************************/</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* Read a line from the memos file. Handle any I/O errors and</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * EOF. Return the length read, not counting the newline on</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * the end.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( fgets( buffer, len, fid ) == NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( feof( fid ) ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( EOF );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; perror( &quot;Error reading memos file&quot;
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; abort();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( strlen( buffer ) - 1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static MEMO_EL * ReadAMemo( FILE * fid )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /**************************************/</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* Read one memo, creating the memo structure and filling it</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * in. Return a pointer to the memo (NULL if none read).</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MEMO_EL *&nbsp;&nbsp; el;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; len;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TEXT_LINE * line;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buffer[MAXLEN];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; len = ReadLine( buffer, MAXLEN, fid );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( len == EOF ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( NULL );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* First line must be of the form &quot;Date:&quot; or &quot;Date:YY/MM/DD&quot;:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( (len != 5&nbsp; &amp;&amp;&nbsp; len != 13)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ||&nbsp; strncmp(
buffer, &quot;Date:&quot;, 5 ) != 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BadFormat();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buffer[len] = NULLCHAR;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; el = MemoMAlloc( sizeof( MEMO_EL ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; el-&gt;text = NULL;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcpy( el-&gt;date, buffer + 5 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; line = NULL;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( ;; ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; len = ReadLine( buffer, MAXLEN, fid );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( len == EOF ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BadFormat();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buffer[len] = NULLCHAR;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( strcmp( buffer, &quot;====&quot; ) ==
0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( el );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; line = AddLine( buffer, el, line );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static TEXT_LINE * AddLine( char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buffer[],</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MEMO_EL *&nbsp;&nbsp; el,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TEXT_LINE * prevline )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /************************************************/</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* Add a line of text to the memo, taking care of all the</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * details of modifying the structure.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TEXT_LINE * line;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; line = MemoMAlloc( sizeof( TEXT_LINE ) + strlen( buffer ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcpy( line-&gt;text, buffer );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; line-&gt;next = NULL;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( prevline == NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; el-&gt;text = line;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prevline-&gt;next = line;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( line );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static ACTION PromptAction( void )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /********************************/</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* The user didn't specify an action on the command line,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * so prompt for it.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ACTION act;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( ;; ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;\nEnter an action:\n&quot;
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; act = ReadAction();</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( act != INVALID ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( act );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;\nThat selection was not valid.\n&quot;
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Help();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static ACTION ReadAction( void )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /******************************/</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* Read an action from the terminal.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Return the action code.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char buffer[80];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( gets( buffer ) == NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; perror( &quot;Error reading action&quot;
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; abort();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( GetAction( buffer ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static ACTION GetAction( char buffer[] )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /**************************************/</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* Given the string in the buffer, return the action that</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * corresponds to it.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * The string in the buffer is first zapped into lower case</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * so that mixed-case entries are recognized.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ACTION_MAP * actmap;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bufptr;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( bufptr = buffer; *bufptr != NULLCHAR; ++bufptr ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *bufptr = tolower( *bufptr );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( actmap = KeywordMap; actmap-&gt;act != INVALID; ++actmap
) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( strcmp( buffer, actmap-&gt;keyword )
== 0 ) break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( actmap-&gt;act );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static void HandleMemoActions( MEMO_EL * el )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /*******************************************/</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* Handle all the actions entered from the keyboard.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( ;; ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; el = DoActions( el, PromptAction() );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( QuitFlag ) break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static MEMO_EL * DoActions( MEMO_EL * el, ACTION act )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /****************************************************/</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* Perform one action on the memos.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MEMO_EL * new_el;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MEMO_EL * prev_el;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch( act ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case HELP:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Help();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case ADD:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new_el = AddMemo( el );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( new_el != NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; el = new_el;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MemosModified = TRUE;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case DELETE:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; el = DeleteMemo( el );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MemosModified = TRUE;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case REPLACE:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prev_el = el;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new_el = AddMemo( el );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( new_el != NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DeleteMemo( prev_el
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MemosModified = TRUE;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case SHOW:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DisplayMemo( el );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case UP:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; el = DoUpAction( el );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case DOWN:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; el = DoDownAction( el );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case TOP:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; el = NULL;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case TODAY:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; el = ShowTodaysMemos();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case SAVE:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( SaveMemos() ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MemosModified = FALSE;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case QUIT:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( WantToQuit() ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; QuitFlag = TRUE;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; el = NULL;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( el );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static MEMO_EL * AddMemo( MEMO_EL * el )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /**************************************/</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* Add a memo following the current one.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MEMO_EL * new_el;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MEMO_EL * next;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new_el = EnterAMemo();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( new_el == NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( NULL );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( el == NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; next = MemoHead;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MemoHead = new_el;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; next = el-&gt;next;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; el-&gt;next = new_el;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new_el-&gt;prev = el;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new_el-&gt;next = next;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( next != NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; next-&gt;prev = new_el;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( new_el );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static MEMO_EL * EnterAMemo( void )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /*********************************/</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* Read a memo from the keyboard, creating the memo structure</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * and filling it in. Return a pointer to the memo (NULL if</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * none read).</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MEMO_EL *&nbsp;&nbsp; el;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; len;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TEXT_LINE * line;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buffer[MAXLEN];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;What date do you want the memo displayed&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot; (YY/MM/DD)?\n&quot;
);</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( gets( buffer ) == NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Error reading from terminal.\n&quot;
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( NULL );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; len = strlen( buffer );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( len != 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp;&nbsp;
(len != 8</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;||&nbsp; buffer[2] != '/'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;|| buffer[5] != '/') ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Date is not valid.\n&quot;
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( NULL );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; el = MemoMAlloc( sizeof( MEMO_EL ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; el-&gt;text = NULL;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcpy( el-&gt;date, buffer );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; line = NULL;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;\nEnter the text of the memo.\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;To terminate the memo,&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot; enter a line
starting with =\n&quot; );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( ;; ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( gets( buffer ) == NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Error
reading from terminal.\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( NULL );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( buffer[0] == '=' ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( el );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; line = AddLine( buffer, el, line );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static MEMO_EL * DeleteMemo( MEMO_EL * el )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /*****************************************/</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* Delete the current memo.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Return a pointer to another memo, usually the following one.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MEMO_EL * prev;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MEMO_EL * next;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MEMO_EL * ret_el;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( el == NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( MemoHead );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prev = el-&gt;prev;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; next = el-&gt;next;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret_el = next;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( ret_el == NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret_el = prev;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* If it's the first memo, set a new MemoHead value.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( prev == NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MemoHead = next;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( next != NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; next-&gt;prev = NULL;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prev-&gt;next = next;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( next != NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; next-&gt;prev = prev;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DisposeMemo( el );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( ret_el );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static MEMO_EL * DoUpAction( MEMO_EL * el )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /*****************************************/</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* Perform the UP action, including displaying the memo.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( el == NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DisplayTop();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; el = el-&gt;prev;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DisplayMemo( el );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( el );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static MEMO_EL * DoDownAction( MEMO_EL * el )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /*******************************************/</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* Perform the DOWN action, including displaying the memo.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MEMO_EL * next_el;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; next_el = (el == NULL) ? MemoHead : el-&gt;next;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( next_el == NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;No more memos.\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; el = next_el;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DisplayMemo( el );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( el );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static MEMO_EL * ShowTodaysMemos( void )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /**************************************/</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* Show all memos that either:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * (1) match today's date</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * (2) don't have a date stored.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Return a pointer to the last displayed memo.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MEMO_EL * el;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MEMO_EL * last_el;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp;&nbsp; timer;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct tm ltime;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; date[9];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* Get today's time in YY/MM/DD format.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time( &amp;timer );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ltime = *localtime( &amp;timer );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strftime( date, 9, &quot;%y/%m/%d&quot;, &amp;ltime );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; last_el = NULL;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( el = MemoHead; el != NULL; el = el-&gt;next ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( el-&gt;date[0] == NULLCHAR</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;||&nbsp; strcmp( date, el-&gt;date ) == 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DisplayMemo( el );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; last_el = el;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( last_el );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static void DisplayMemo( MEMO_EL * el )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /*************************************/</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* Display a memo on the screen.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TEXT_LINE * tline;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( el == NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DisplayTop();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( el-&gt;date[0] == NULLCHAR ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;\nUndated memo\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;\nDated: %s\n&quot;, el-&gt;date
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( tline = el-&gt;text; tline != NULL; tline = tline-&gt;next
) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;&nbsp;&nbsp;&nbsp; %s\n&quot;,
tline-&gt;text );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static int SaveMemos( void )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /**************************/</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* Save the memos to the memos file.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FILE *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fid;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MEMO_EL *&nbsp;&nbsp; el;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TEXT_LINE * tline;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buffer[20];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( MemoHead == NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;No memos to save.\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( FALSE );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* Open a temporary filename in case something goes wrong</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * during the save.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fid = fopen( TempName, &quot;w&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( fid == NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Unable to open \&quot;%s\&quot;
for writing.\n&quot;, TempName );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Save not performed.\n&quot;
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( FALSE );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( el = MemoHead; el != NULL; el = el-&gt;next ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf( buffer, &quot;Date:%s&quot;, el-&gt;date
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( !WriteLine( buffer, fid ) ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( FALSE );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tline = el-&gt;text;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( ; tline != NULL; tline = tline-&gt;next
) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( !WriteLine( tline-&gt;text,
fid ) ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;return( FALSE );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( !WriteLine( &quot;====&quot;, fid
) ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( FALSE );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* Now get rid of the old file, if it's there, then rename</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * the new one.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( fid );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fid = fopen( FileName, &quot;r&quot; );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( fid != NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( fid );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( remove( FileName ) != 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; perror( &quot;Can't
remove old memos file&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( FALSE );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( rename( TempName, FileName ) != 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; perror( &quot;Can't rename new memos file&quot;
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( FALSE );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( TRUE );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static int WriteLine( char * text, FILE * fid )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /*********************************************/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( fprintf( fid, &quot;%s\n&quot;, text ) &lt; 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; perror( &quot;Error writing memos file&quot;
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( FALSE );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( TRUE );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* Routines for displaying HELP and other simple text.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static void Usage( void )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /***********************/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Usage:\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;&nbsp;&nbsp;&nbsp; memos ?\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; displays
this text\n&quot; );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;&nbsp; or\n&quot; );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;&nbsp;&nbsp;&nbsp; memos\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prompts
for all actions.\n&quot; );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;&nbsp; or\n&quot; );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;&nbsp;&nbsp;&nbsp; memos action\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; performs
the action.\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; More
than one action may be specified.\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; action
is one of:\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ShowActions();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static void ShowActions( void )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /*****************************/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; Help&nbsp;&nbsp;&nbsp; (display this text)\n&quot; );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; Add&nbsp;&nbsp;&nbsp;&nbsp; (add new memo here)\n&quot; );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; DELete&nbsp; (delete current memo)\n&quot; );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; REPlace (replace current memo)\n&quot; );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; SHow&nbsp;&nbsp;&nbsp; (show the current memo again)\n&quot; );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; Up&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (move up one memo)\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; Down&nbsp;&nbsp;&nbsp; (move down one memo)\n&quot; );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; TOP&nbsp;&nbsp;&nbsp;&nbsp; (move to the top of the list\n&quot; );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; TODay&nbsp;&nbsp; (display today's memos)\n&quot; );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; SAve&nbsp;&nbsp;&nbsp; (write the memos to disk)\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static void Help( void )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /**********************/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Choose one of:\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ShowActions();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; Quit\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static void DisplayTop( void )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /****************************/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Top of memos.\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static int WantToQuit( void )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /***************************/</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* Check to see if the memos have been modified, but not saved.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * If so, query the user to make sure that he/she wants to quit</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * without saving the memos.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char buffer[MAXLEN];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( !MemosModified&nbsp; ||&nbsp; MemoHead == NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( TRUE );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;\nThe memos have been modified but not saved.\n&quot;
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Do you want to leave without saving them?\n&quot; );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gets( buffer );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( tolower( buffer[0] ) == 'y' );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static void BadFormat( void )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /***************************/</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Invalid format for memos file\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; abort();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static void * MemoMAlloc( int size )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /**********************************/</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* Allocate the specified size of memory, dealing with the</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * case of a failure by displaying a message and quitting.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; register char * mem;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mem = malloc( size );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( mem == NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Unable to allocate %d characters
of memory\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;size );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; abort();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( mem );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static void DisposeMemo( MEMO_EL * el )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /*************************************/</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* Dispose of a memo, including its lines.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TEXT_LINE * tline;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TEXT_LINE * next;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tline = el-&gt;text;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( tline != NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; next = tline-&gt;next;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; free( tline );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tline = next;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; free( el );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H1 ID="Glossary"> Glossary </H1>
<DL>
<DT>address
<DD>An address is a location in a computer's memory.&nbsp; Each storage location (byte) has an address by which it is referenced.
&nbsp;A<B> pointer</B> is an address.
<DT>aggregate
<DD>An aggregate type is either an<B> array</B> or a<B> structure.</B>&nbsp; The term<B> aggregate</B> refers to the fact that
arrays and structures are made up of other types.
<DT>alignment
<DD>On some computers, objects such as integers, pointers and floating-point numbers may be stored only at certain addresses (for
example, only at even addresses).&nbsp; An attempt to reference an object that is not properly aligned may cause the program
to fail.&nbsp; Other computers may not require alignment, but may suggest it in order to increase the speed of execution of
programs.
<BR><BR>C compilers align all objects that require it, including putting padding characters within structures and arrays,
if necessary.&nbsp; However, it is still possible for a program to attempt to reference an improperly-aligned object.
<BR><BR><B>&nbsp; The Open Watcom C/16 and C/32 compilers align structure members by default.&nbsp; A command line switch,
or the</B><TT> pack</TT><B> pragma, may be used to control this behavior.&nbsp; Other objects may also be aligned by default.</B>
<BR><BR><B>&nbsp; See the User's Guide for default values and other details.</B>
<DT>argument
<DD>An argument to a function call is an expression whose value is assigned to the parameter for the function.&nbsp; The function
may modify the parameter, but the original argument is unaffected.&nbsp; This method of passing values to a function is often
called <B> call by value.</B>
<BR><BR>The argument may be a pointer to an object, in which case the function may modify the object to which the pointer
points, while the argument value (the pointer) is unaffected.
<DT>array
<DD>An array is a set of objects of the same type, grouped into adjacent memory locations.&nbsp; References to elements of the
array are made by <B> subscripts</B> or <B> indices.</B>
<DT>assignment
<DD>Assignment is the storing of a value into an object, which is usually done with the <TT> =</TT> operator.
<DT>automatic storage duration
<DD>An object with automatic storage duration is created when the<B> function</B> in which it is defined is invoked, and is destroyed
when the function returns to the caller.
<DT>bit
<DD>A bit is the smallest possible unit of information, representing one of two values, 0 or 1.&nbsp; If the bit is 0, it is said
to be<B> off.</B>&nbsp; If the bit is 1, it is said to be<B> on.</B>
<BR><BR>A bit is not representable by an<B> address,</B> but is part of a<B> byte,</B> which does have an address.
<BR><BR><B>&nbsp; Most processors, including the Intel 80x86 family of processors, have 8 bits in a byte.</B>
<DT>bit-field
<DD>A bit-field is a type that contains a specified number of bits.
<DT>block
<DD>A block is a part of a function that begins with<TT> {</TT> and ends with<TT> }</TT> and contains declarations of objects
and statements that perform some action.&nbsp; A block is also called a <B> compound statement.</B>
<DT>byte
<DD>A byte is the smallest unit of storage representable by a unique<B> address,</B> usually capable of holding one character
of information.
<BR><BR><B>&nbsp; Most processors, including the Intel 80x86 family of processors, have 8</B><B><I> bits</I></B><B> in a byte.</B>
<DT>cast
<DD>To cast an object is to explicitly convert it to another<B> type.</B>
<DT>character constant
<DD>A character constant is usually one character (possibly a <B> trigraph</B> or <B> escape sequence)</B> contained within single-quotes
(for example,<TT> 'a', '??('</TT> and<TT> '\n'</TT>).
<BR><BR><B>&nbsp; The Open Watcom C/16 and C/32 compilers allow character constants with one, two, three or four characters.</B>
<DT>comment
<DD>A comment is a sequence of characters, outside of a <B> string literal</B> or <B> character constant,</B> starting with<TT>
/*</TT> and ending with<TT> */.</TT>&nbsp; The comment is only examined to find the<TT> */</TT> that terminates it.&nbsp;
Hence, a comment may not contain another comment.
<DT>compiler
<DD>A compiler is a program which reads a file containing programming language statements and translates it into instructions
that the computer can understand.
<BR><BR>For example, a C compiler translates statements described in this book.
<DT>compound statement
<DD>A compound statement is a part of a function that begins with<TT> {</TT> and ends with<TT> }</TT> and contains declarations
of objects and statements that perform some action.&nbsp; A compound statement is also called a <B> block.</B>
<DT>declaration
<DD>A declaration describes the attributes of an object or function, such as the storage duration, linkage, and type.&nbsp; The
space for an object is reserved when its<B> definition</B> is found.&nbsp; The declaration of a function describes the function
arguments and type and is also called a function prototype.&nbsp; The declaration of a function does not include the statements
to be executed when the function is called.
<DT>decrement
<DD>To decrement a number is to subtract (one) from it.&nbsp; To decrement a pointer is to decrease its value by the size of the
object to which the pointer points.
<DT>definition
<DD>A definition of an object is the same as a<B> declaration,</B> except that the storage for the object is reserved when its
definition is found.&nbsp; A function definition includes the statements to be executed when the function is called.
<DT>exception
<DD>An exception occurs when an operand to an operator has an invalid value.&nbsp; Division by zero is a common exception.
<DT>floating-point
<DD>A floating-point number is a member of a subset of the mathematical set of real numbers, containing (possibly) a fraction
and an exponent.&nbsp; The floating-point<B> type</B> is represented by one of the keywords <TT> float</TT>, <TT> double</TT>
or <TT> long double</TT>.
<DT>function
<DD>A function is a collection of declarations and statements, preceded by a declaration of the name of the function and the<B>
parameters</B> to it, as well as a possible<B> return value.</B>&nbsp; The statements describe a series of steps to be taken
after the function is called, and before it finishes.
<DT>header
<DD>A header contains C source, usually function prototypes, structure and union definitions, linkages to externally-defined objects
and macro definitions.&nbsp; A header is included using the <TT> #include</TT> preprocessor directive.
<DT>identifier
<DD>An identifier is a sequence of characters, starting with a letter or underscore, and consisting of letters, digits and underscores.
&nbsp;An identifier is used as the name of an object, a tag, function, typedef, label, macro or member of a structure or union.
<DT>implementation-defined behavior
<DD>Behavior that is implementation-defined depends on how a particular C compiler handles a certain case.&nbsp; All C compilers
must document their behavior in these cases.
<DT>incomplete type
<DD>An incomplete type is one which has been declared, but its size or structure has not yet been stated.&nbsp; An example is
an array of items that was declared without specifying how many items.&nbsp; The <TT> void</TT> type is also an incomplete
type, but it can never be completed.
<DT>increment
<DD>To increment a number is to add (one) to it.&nbsp; To increment a pointer is to increase its value by the size of the object
to which the pointer points.
<DT>index
<DD>An index (or<B> subscript</B>) is a number used to reference an element of an<B> array.</B>&nbsp; It is an integral value.
&nbsp;The first element of an array has the index zero.
<DT>indirection
<DD>Indirection occurs when an object that is a pointer to an object is actually used to point to it.&nbsp; The unary form of
the <TT> *</TT> operator, or the <TT> -&gt;</TT> operator are used for indirection.
<DT>initialization
<DD>The initialization of an object is the act of giving it its first (initial) value.&nbsp; This may be done by giving an initialization
value when the object is declared, or by explicitly assigning it a value.
<DT>integer
<DD>An integer is a<B> type</B> that is a subset of the mathematical set of integers.&nbsp; It is represented by the keyword <TT>
int</TT>, and has a number of variations including <TT> signed char</TT>, <TT> unsigned char</TT>, <TT> short signed int</TT>,
<TT> short unsigned int</TT>, <TT> signed int</TT>, <TT> unsigned int</TT>, <TT> long signed int</TT>, <TT> long unsigned
int</TT>, <TT> long long signed int</TT> and <TT> long long unsigned int</TT>.
<DT>integral promotion
<DD>An object or constant that is a <TT> char</TT>, <TT> short int</TT>, <TT> int</TT> bit-field, or of <TT> enum</TT> type, that
is used in an expression, is promoted to an <TT> int</TT> (if <TT> int</TT> is large enough to contain all possible values
of the smaller type) or <TT> unsigned int</TT>.
<DT>keyword
<DD>A keyword is an<B> identifier</B> that is reserved for use by the compiler.&nbsp; No object name or other use of an identifier
may use a keyword.
<DT>label
<DD>A label is an<B> identifier</B> that corresponds to a particular<B> statement</B> in a<B> function.</B>&nbsp; It may be used
by the <TT> goto</TT> statement.&nbsp; <TT> default</TT> is a special label which is used with the <TT> switch</TT> statement.
<DT>library function
<DD>A library function is a function provided with the C compiler that performs some commonly needed action.&nbsp; The C language
standard describes a set of functions that all C compilers must provide.&nbsp; Whether or not the function actually generates
a function call is implementation-defined.
<DT>line
<DD>A line is conceptually similar to a line as seen in a text editor.&nbsp; The line in a text editor may be called a physical
line.&nbsp; Several physical lines may be joined together into one logical line (or just &quot;line&quot;) by ending all but
the last line with a<TT> \</TT> symbol.&nbsp; C does not normally require statements to fit onto one line, so using the<TT>
\</TT> symbol is usually only necessary when defining <B> macros.</B>
<DT>linkage
<DD>An object with<B> external</B> linkage may be referenced by any<B> module</B> in the program.&nbsp; An object with<B> internal</B>
linkage may be referenced only within the module in which it is defined.&nbsp; An object with<B> no</B> linkage may only be
referenced within the<B> block</B> in which it is defined.
<DT>lint
<DD>lint is a utility program, often provided with the compiler, which detects problems that the compiler will accept as syntactically
valid, but likely are not what the programmer intended.
<DT>lvalue
<DD>An lvalue is an expression that designates an object.&nbsp; The term originally comes from the assignment expression,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; L = R</TT>
<BR><BR>in which the left operand<TT> L</TT> to the assignment operator must be a modifiable value.&nbsp; The most common
form of lvalue is the identifier of an object.
<BR><BR>If an expression<TT> E</TT> evaluates to a pointer to an object, then<TT> *E</TT> is an lvalue that designates the
object to which<TT> E</TT> points.&nbsp; In particular, if<TT> E</TT> is declared as a &quot;pointer to <TT> int</TT>&quot;,
then both<TT> E</TT> and<TT> *E</TT> are lvalues having the respective types &quot;pointer to <TT> int</TT>&quot; and <TT>
int</TT>.
<DT>macro
<DD>There are two kinds of macros.&nbsp; An object-like macro is an<B> identifier</B> that is replaced by a sequence of<B> tokens.</B>
&nbsp;A function-like macro is an apparent function call which is replaced by a sequence of tokens.
<DT>module
<DD>Referred to in the C language standard as a<B> translation unit,</B> a module is usually a file containing C source code.
&nbsp;A module may include headers or other source files, and have conditional compilation (preprocessing directives), object
declarations, and/or functions.&nbsp; A module is thus considered to be a C source file after the included files and conditional
compilation have been processed.
<DT>name space
<DD>A name space is a category of identifiers.&nbsp; The same identifier may appear in different name spaces.&nbsp; For example,
the identifier<TT> thing</TT> may be a label, object name, tag and member of a structure or union, all at the same time, since
each of these has its own name space.&nbsp; The syntax of the use of the identifier resolves which category the identifier
falls into.
<DT>nesting
<DD>Nesting is placing something inside something else.&nbsp; For example, a <TT> for</TT> statement may, as part of its body,
contain another <TT> for</TT> statement.&nbsp; The second <TT> for</TT> is said to be nested inside the first.&nbsp; Another
form of nesting occurs when source files include other files.
<DT>null pointer constant
<DD>The value zero, when used in a place where a pointer type is expected, is considered to be a null pointer constant, which
is a value that indicates that the pointer does not currently point to anything.&nbsp; The compiler interprets the zero as
a special value, and does not guarantee that the actual value of the pointer will be zero.
<BR><BR>The macro <TT> NULL</TT> is often used to represent the null pointer constant.
<DT>null character
<DD>The character with all<B> bits</B> set to zero is used to terminate<B> strings,</B> and is called the null character.&nbsp;
It is represented by the<B> escape sequence</B><TT> \0</TT> in a string, or as the character constant<TT> '\0'</TT>.
<DT>object
<DD>An object is a collection of<B> bytes</B> in the storage of the computer, used to represent values.&nbsp; The size and meaning
of the object is determined by its<B> type.</B>&nbsp; A<B> scalar</B> object is often referred to as a<B> variable.</B>
<DT>parameter
<DD>A parameter to a function is a &quot;local copy&quot; of the argument values determined in the call to the function.&nbsp;
Any modification of a parameter value does not affect the argument to the function call.&nbsp; However, an argument (and hence
a parameter) may be a pointer to an object, in which case the function may modify the object to which its parameter points.
<DT>pointer
<DD>An object that contains the<B> address</B> of another object is said to be a pointer to that object.
<DT>portable
<DD>Portable software is written in such a way that it is relatively easy to make the software run on different hardware or operating
systems.
<DT>precedence
<DD>Precedence is the set of implicit rules for determining the order of execution of an expression in the absence of parentheses.
<DT>preprocessor
<DD>The preprocessor:
<UL>
<LI>examines<B> tokens</B> for<B> macros</B> and does appropriate substitutions if necessary,
<LI>includes headers or other source files, and,
<LI>includes or excludes input lines based on <TT> #if</TT> directives
</UL>
<BR>before the compiler translates the source.
<DT>recursion
<DD>Recursion occurs when a<B> function</B> calls itself either directly, or by calling another function which calls it.&nbsp;
See recursion.&nbsp; (!)
<DT>register
<DD>A register is a special part of the computer, usually not part of the addressable storage.&nbsp; Registers may contain values
and are generally faster to use than storage.
<BR>The<B> keyword</B> <TT> register</TT> may be used when declaring an object with<B> automatic storage duration,</B> indicating
to the compiler that this object will be heavily used, and the compiler should attempt to optimize the use of this object,
possibly by placing it in a machine register.
<DT>return value
<DD>A return value is the value returned by a<B> function</B> via the <TT> return</TT> statement.
<DT>rounding
<DD>A value is rounded when the representation used to store a value is not exact.&nbsp; The value may be increased or decreased
to the nearest value that may be accurately represented.
<DT>scalar
<DD>A scalar is an object that is not a structure, union or array.&nbsp; Basically, it is a single item, with type such as character,
any of the various integer types, or floating-point.
<DT>scope
<DD>The scope of an<B> identifier</B> identifies the part of the<B> module</B> that may refererence it.&nbsp; An object with<B>
block</B> scope may only be referenced within the block in which it is defined.&nbsp; An object with<B> file</B> scope may
be referred to anywhere within the file in which it is defined.
<DT>sequence point
<DD>A sequence point is a point at which all<B> side-effects</B> from previously executed statements will have been resolved,
and no side-effects from statements not yet executed will have occurred.&nbsp; Normally, the programmer will not need to worry
about sequence points, as it is the compiler's job to ensure that side-effects are resolved at the proper time.
<DT>side-effect
<DD>A side-effect modifies a value of an object, causing a change in the state of the program.&nbsp; The most common side-effect
is<B> assignment,</B> whereby the value of the left operand is changed.
<DT>signed
<DD>A signed value can represent both negative and positive values.
<BR><BR>The<B> keyword</B> <TT> signed</TT> may be used with the types <TT> char</TT>, <TT> short int</TT>, <TT> int</TT>,
<TT> long int</TT> and <TT> long long int</TT>.
<DT>statement
<DD>A statement describes the actions that are to be taken by the program.&nbsp; (Statements are distinct from the declarations
of objects.)
<DT>static storage duration
<DD>An object with static storage duration is created when the program is invoked, and destroyed when the program exits.&nbsp;
Any value stored in the object will remain until explicitly modified.
<DT>string
<DD>A string is a sequence of characters terminated by a<B> null character.</B>&nbsp; A reference to a string is made with the<B>
address</B> of the first character.
<DT>string literal
<DD>A string literal is a sequence of zero or more characters enclosed within double-quotes and is a constant.&nbsp; Adjacent
string literals are concatenated into one string literal.&nbsp; The value of a string literal is the sequence of characters
within the quotes, plus a<B> null character</B> (<TT>\0</TT>) placed at the end.
<DT>structure
<DD>A structure is a<B> type</B> which is a set of named members of (possibly different) types, which reside in memory starting
at adjacent and sequentially increasing storage locations.
<DT>subscript
<DD>A subscript (or<B> index</B>) is a number used to reference an element of an<B> array.</B>&nbsp; It is a non-negative integral
value.&nbsp; The first element of an array has the subscript zero.
<DT>tag
<DD>A tag is an identifier which names a structure, union or enumeration.&nbsp; In the declaration,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; enum nums { ZERO, ONE, TWO } value;</TT>
<BR><BR><TT>nums</TT> is the tag of the enumeration, while<TT> value</TT> is an object declared with the enumeration type.
<DT>token
<DD>A token is the unit used by the<B> preprocessor</B> for scanning for<B> macros,</B> and by the<B> compiler</B> for scanning
the input source lines.&nbsp; Each identifier, constant and comment is one token, while other characters are each, individually,
one token.
<DT>type
<DD>The type of an<B> object</B> describes the size of the object, and what interpretation is to be used when using the value
of the object.&nbsp; It may include information such as whether the value is <TT> signed</TT> or <TT> unsigned</TT>, and what
range of values it may contain.
<DT>undefined behavior
<DD>Undefined behavior occurs when an erroneous program construct or bad data is used, and the standard does not impose a behavior.
&nbsp;Possible actions of undefined behavior include ignoring the problem, behaving in a documented manner, terminating the
compilation with an error, and terminating the execution with an error.
<DT>union
<DD>A union is a<B> type</B> which is a set of named members of (possibly different) types, which reside in memory starting at
the same memory location.
<DT>unsigned
<DD>An unsigned value is one that can represent only non-negative values.
<BR><BR>&nbsp;&nbsp; The<B> keyword</B> <TT> unsigned</TT> may be used with the types <TT> char</TT>, <TT> short int</TT>,
<TT> int</TT>, <TT> long int</TT> and <TT> long long int</TT>.
<DT>variable
<DD>A variable is generally the same thing as an<B> object.</B>&nbsp; It is most often used to refer to<B> scalar</B> objects.
<DT>void
<DD>The <TT> void</TT><B> type</B> is a special type that really indicates &quot;no particular type&quot;.&nbsp; An object that
is a &quot;pointer to <TT> void</TT>&quot; may not be used to point at anything without it first being<B> cast</B> to the
appropriate type.
<BR><BR>The<B> keyword</B> <TT> void</TT> is also used as the type of a<B> function</B> that has no<B> return value,</B> and
as the<B> parameter</B> list of a function that requires no parameters.
</DL>
</BODY>
