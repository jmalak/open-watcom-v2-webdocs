<HEAD>
<TITLE> Open Watcom 2.0 C/C++ User's Guide </TITLE>
</HEAD>
<BODY>
<H1 ID="Index_of_Topics"> Index of Topics </H1>
<DL>
<DT>- &quot; -
<DD><A HREF="#The__MfhUqV__LPrecompiled_HeaderR_Option">The &quot;-fh[q]&quot; (Precompiled Header) Option</A>
<DT>- 0 -
<DD><A HREF="#0">0</A>
<DT>- 1 -
<DD><A HREF="#1">1</A>
<BR><A HREF="#16Mbit_Assembly_Language_Considerations">16-bit Assembly Language Considerations</A>
<BR><A HREF="#16Mbit_Code_Models">16-bit Code Models</A>
<BR><A HREF="#16Mbit_Data_Models">16-bit Data Models</A>
<BR><A HREF="#16Mbit_Memory_Layout">16-bit Memory Layout</A>
<BR><A HREF="#16Mbit_Memory_Models">16-bit Memory Models</A>
<BR><A HREF="#16Mbit_Pragmas">16-bit Pragmas</A>
<BR><A HREF="#16Mbit__A_Function_that_Never_Returns">16-bit:&nbsp; A Function that Never Returns</A>
<BR><A HREF="#16Mbit__Alias_Names">16-bit:&nbsp; Alias Names</A>
<BR><A HREF="#16Mbit__Alternate_Names_for_Symbols">16-bit:&nbsp; Alternate Names for Symbols</A>
<BR><A HREF="#16Mbit__An_Example">16-bit:&nbsp; An Example</A>
<BR><A HREF="#16Mbit__Auxiliary_Pragmas">16-bit:&nbsp; Auxiliary Pragmas</A>
<BR><A HREF="#16Mbit__Auxiliary_Pragmas_and_the_80x87">16-bit:&nbsp; Auxiliary Pragmas and the 80x87</A>
<BR><A HREF="#16Mbit__Calling_Conventions_for_80x87Mbased_Applications">16-bit:&nbsp; Calling Conventions for 80x87-based Applications</A>
<BR><A HREF="#16Mbit__Calling_Conventions_for_NonM80x87_Applications">16-bit:&nbsp; Calling Conventions for Non-80x87 Applications</A>
<BR><A HREF="#16Mbit__Data_Representation">16-bit:&nbsp; Data Representation</A>
<BR><A HREF="#16Mbit__Defining_Exported_Symbols_in_Dynamic_Link_Libraries">16-bit:&nbsp; Defining Exported Symbols in Dynamic Link Libraries</A>
<BR><A HREF="#16Mbit__Defining_Windows_Callback_Functions">16-bit:&nbsp; Defining Windows Callback Functions</A>
<BR><A HREF="#16Mbit__Describing_Argument_Information">16-bit:&nbsp; Describing Argument Information</A>
<BR><A HREF="#16Mbit__Describing_Calling_Information">16-bit:&nbsp; Describing Calling Information</A>
<BR><A HREF="#16Mbit__Describing_Function_Return_Information">16-bit:&nbsp; Describing Function Return Information</A>
<BR><A HREF="#16Mbit__Describing_How_Functions_Use_Memory">16-bit:&nbsp; Describing How Functions Use Memory</A>
<BR><A HREF="#16Mbit__Describing_the_Registers_Modified_by_a_Function">16-bit:&nbsp; Describing the Registers Modified by a Function</A>
<BR><A HREF="#16Mbit__Effect_of_Function_Prototypes_on_Arguments">16-bit:&nbsp; Effect of Function Prototypes on Arguments</A>
<BR><A HREF="#16Mbit__Forcing_a_Stack_Frame">16-bit:&nbsp; Forcing a Stack Frame</A>
<BR><A HREF="#16Mbit__Forcing_Arguments_into_Specific_Registers">16-bit:&nbsp; Forcing Arguments into Specific Registers</A>
<BR><A HREF="#16Mbit__Functions_with_Variable_Number_of_Arguments">16-bit:&nbsp; Functions with Variable Number of Arguments</A>
<BR><A HREF="#16Mbit__Interfacing_to_Assembly_Language_Functions">16-bit:&nbsp; Interfacing to Assembly Language Functions</A>
<BR><A HREF="#16Mbit__Loading_Data_Segment_Register">16-bit:&nbsp; Loading Data Segment Register</A>
<BR><A HREF="#16Mbit__Memory_Layout">16-bit:&nbsp; Memory Layout</A>
<BR><A HREF="#16Mbit__Passing_Arguments_in_Registers">16-bit:&nbsp; Passing Arguments in Registers</A>
<BR><A HREF="#16Mbit__Passing_Arguments_in_Reverse_Order">16-bit:&nbsp; Passing Arguments in Reverse Order</A>
<BR><A HREF="#16Mbit__Passing_Arguments_to_InMLine_Functions">16-bit:&nbsp; Passing Arguments to In-Line Functions</A>
<BR><A HREF="#16Mbit__Passing_Arguments_Using_RegisterMBased_Calling_Conventions">16-bit:&nbsp; Passing Arguments Using Register-Based Calling Conventions</A>
<BR><A HREF="#16Mbit__Passing_Values_in_80x87Mbased_Applications">16-bit:&nbsp; Passing Values in 80x87-based Applications</A>
<BR><A HREF="#16Mbit__Predefined____cdecl__Alias">16-bit:&nbsp; Predefined &quot;__cdecl&quot; Alias</A>
<BR><A HREF="#16Mbit__Predefined____pascal__Alias">16-bit:&nbsp; Predefined &quot;__pascal&quot; Alias</A>
<BR><A HREF="#16Mbit__Predefined____watcall__Alias">16-bit:&nbsp; Predefined &quot;__watcall&quot; Alias</A>
<BR><A HREF="#16Mbit__Predefined_Aliases">16-bit:&nbsp; Predefined Aliases</A>
<BR><A HREF="#16Mbit__Preserving_80x87_FloatingMPoint_Registers_Across_Calls">16-bit:&nbsp; Preserving 80x87 Floating-Point Registers Across Calls</A>
<BR><A HREF="#16Mbit__Removing_Arguments_from_the_Stack">16-bit:&nbsp; Removing Arguments from the Stack</A>
<BR><A HREF="#16Mbit__Returning_FloatingMPoint_Data">16-bit:&nbsp; Returning Floating-Point Data</A>
<BR><A HREF="#16Mbit__Returning_Function_Values_in_Registers">16-bit:&nbsp; Returning Function Values in Registers</A>
<BR><A HREF="#16Mbit__Returning_Structures">16-bit:&nbsp; Returning Structures</A>
<BR><A HREF="#16Mbit__Returning_Values_from_Functions">16-bit:&nbsp; Returning Values from Functions</A>
<BR><A HREF="#16Mbit__Returning_Values_in_80x87Mbased_Applications">16-bit:&nbsp; Returning Values in 80x87-based Applications</A>
<BR><A HREF="#16Mbit__Setting_Priority_of_Static_Data_Initialization_LCPP_OnlyR">16-bit:&nbsp; Setting Priority of Static Data Initialization (C++ Only)</A>
<BR><A HREF="#16Mbit__Size_of_Enumerated_Types">16-bit:&nbsp; Size of Enumerated Types</A>
<BR><A HREF="#16Mbit__Sizes_of_Predefined_Types">16-bit:&nbsp; Sizes of Predefined Types</A>
<BR><A HREF="#16Mbit__Specifying_Symbol_Attributes">16-bit:&nbsp; Specifying Symbol Attributes</A>
<BR><A HREF="#16Mbit__The_ALIAS_Pragma_LC_OnlyR">16-bit:&nbsp; The ALIAS Pragma (C Only)</A>
<BR><A HREF="#16Mbit__The_ALLOC_TEXT_Pragma_LC_OnlyR">16-bit:&nbsp; The ALLOC_TEXT Pragma (C Only)</A>
<BR><A HREF="#16Mbit__The_CODE_SEG_Pragma">16-bit:&nbsp; The CODE_SEG Pragma</A>
<BR><A HREF="#16Mbit__The_COMMENT_Pragma">16-bit:&nbsp; The COMMENT Pragma</A>
<BR><A HREF="#16Mbit__The_DATA_SEG_Pragma">16-bit:&nbsp; The DATA_SEG Pragma</A>
<BR><A HREF="#16Mbit__The_DISABLE_MESSAGE_Pragma">16-bit:&nbsp; The DISABLE_MESSAGE Pragma</A>
<BR><A HREF="#16Mbit__The_DUMP_OBJECT_MODEL_Pragma_LCPP_OnlyR">16-bit:&nbsp; The DUMP_OBJECT_MODEL Pragma (C++ Only)</A>
<BR><A HREF="#16Mbit__The_ENABLE_MESSAGE_Pragma">16-bit:&nbsp; The ENABLE_MESSAGE Pragma</A>
<BR><A HREF="#16Mbit__The_ENUM_Pragma">16-bit:&nbsp; The ENUM Pragma</A>
<BR><A HREF="#16Mbit__The_ERROR_Pragma">16-bit:&nbsp; The ERROR Pragma</A>
<BR><A HREF="#16Mbit__The_EXTREF_Pragma">16-bit:&nbsp; The EXTREF Pragma</A>
<BR><A HREF="#16Mbit__The_FUNCTION_Pragma">16-bit:&nbsp; The FUNCTION Pragma</A>
<BR><A HREF="#16Mbit__The_INCLUDE_ALIAS_Pragma">16-bit:&nbsp; The INCLUDE_ALIAS Pragma</A>
<BR><A HREF="#16Mbit__The_INLINE_DEPTH_Pragma_LCPP_OnlyR">16-bit:&nbsp; The INLINE_DEPTH Pragma (C++ Only)</A>
<BR><A HREF="#16Mbit__The_INLINE_RECURSION_Pragma_LCPP_OnlyR">16-bit:&nbsp; The INLINE_RECURSION Pragma (C++ Only)</A>
<BR><A HREF="#16Mbit__The_INTRINSIC_Pragma">16-bit:&nbsp; The INTRINSIC Pragma</A>
<BR><A HREF="#16Mbit__The_MESSAGE_Pragma">16-bit:&nbsp; The MESSAGE Pragma</A>
<BR><A HREF="#16Mbit__The_ONCE_Pragma">16-bit:&nbsp; The ONCE Pragma</A>
<BR><A HREF="#16Mbit__The_PACK_Pragma">16-bit:&nbsp; The PACK Pragma</A>
<BR><A HREF="#16Mbit__The_READ_ONLY_FILE_Pragma">16-bit:&nbsp; The READ_ONLY_FILE Pragma</A>
<BR><A HREF="#16Mbit__The_TEMPLATE_DEPTH_Pragma_LCPP_OnlyR">16-bit:&nbsp; The TEMPLATE_DEPTH Pragma (C++ Only)</A>
<BR><A HREF="#16Mbit__The_WARNING_Pragma_LCPP_OnlyR">16-bit:&nbsp; The WARNING Pragma (C++ Only)</A>
<BR><A HREF="#16Mbit__Type__char_">16-bit:&nbsp; Type &quot;char&quot;</A>
<BR><A HREF="#16Mbit__Type__double_">16-bit:&nbsp; Type &quot;double&quot;</A>
<BR><A HREF="#16Mbit__Type__float_">16-bit:&nbsp; Type &quot;float&quot;</A>
<BR><A HREF="#16Mbit__Type__int_">16-bit:&nbsp; Type &quot;int&quot;</A>
<BR><A HREF="#16Mbit__Type__long_int_">16-bit:&nbsp; Type &quot;long int&quot;</A>
<BR><A HREF="#16Mbit__Type__short_int_">16-bit:&nbsp; Type &quot;short int&quot;</A>
<BR><A HREF="#16Mbit__Using_Pragmas_to_Specify_Default_Libraries">16-bit:&nbsp; Using Pragmas to Specify Default Libraries</A>
<BR><A HREF="#16Mbit__Using_Pragmas_to_Specify_Options">16-bit:&nbsp; Using Pragmas to Specify Options</A>
<BR><A HREF="#16Mbit__Using_the_80x87_to_Pass_Arguments">16-bit:&nbsp; Using the 80x87 to Pass Arguments</A>
<BR><A HREF="#16Mbit__Using_the_80x87_to_Return_Function_Values">16-bit:&nbsp; Using the 80x87 to Return Function Values</A>
<DT>- 2 -
<DD><A HREF="#2">2</A>
<DT>- 3 -
<DD><A HREF="#3">3</A>
<BR><A HREF="#32Mbit_Assembly_Language_Considerations">32-bit Assembly Language Considerations</A>
<BR><A HREF="#32Mbit_Code_Models">32-bit Code Models</A>
<BR><A HREF="#32Mbit_Data_Models">32-bit Data Models</A>
<BR><A HREF="#32Mbit_Memory_Layout">32-bit Memory Layout</A>
<BR><A HREF="#32Mbit_Memory_Models">32-bit Memory Models</A>
<BR><A HREF="#32Mbit_Pragmas">32-bit Pragmas</A>
<BR><A HREF="#32Mbit__A_Function_that_Never_Returns">32-bit:&nbsp; A Function that Never Returns</A>
<BR><A HREF="#32Mbit__Alias_Names">32-bit:&nbsp; Alias Names</A>
<BR><A HREF="#32Mbit__Alternate_Names_for_Symbols">32-bit:&nbsp; Alternate Names for Symbols</A>
<BR><A HREF="#32Mbit__An_Example">32-bit:&nbsp; An Example</A>
<BR><A HREF="#32Mbit__Auxiliary_Pragmas">32-bit:&nbsp; Auxiliary Pragmas</A>
<BR><A HREF="#32Mbit__Auxiliary_Pragmas_and_the_80x87">32-bit:&nbsp; Auxiliary Pragmas and the 80x87</A>
<BR><A HREF="#32Mbit__Calling_Conventions_for_80x87Mbased_Applications">32-bit:&nbsp; Calling Conventions for 80x87-based Applications</A>
<BR><A HREF="#32Mbit__Calling_Conventions_for_NonM80x87_Applications">32-bit:&nbsp; Calling Conventions for Non-80x87 Applications</A>
<BR><A HREF="#32Mbit__Data_Representation">32-bit:&nbsp; Data Representation</A>
<BR><A HREF="#32Mbit__Defining_Exported_Symbols_in_Dynamic_Link_Libraries">32-bit:&nbsp; Defining Exported Symbols in Dynamic Link Libraries</A>
<BR><A HREF="#32Mbit__Describing_Argument_Information">32-bit:&nbsp; Describing Argument Information</A>
<BR><A HREF="#32Mbit__Describing_Calling_Information">32-bit:&nbsp; Describing Calling Information</A>
<BR><A HREF="#32Mbit__Describing_Function_Return_Information">32-bit:&nbsp; Describing Function Return Information</A>
<BR><A HREF="#32Mbit__Describing_How_Functions_Use_Memory">32-bit:&nbsp; Describing How Functions Use Memory</A>
<BR><A HREF="#32Mbit__Describing_the_Registers_Modified_by_a_Function">32-bit:&nbsp; Describing the Registers Modified by a Function</A>
<BR><A HREF="#32Mbit__Effect_of_Function_Prototypes_on_Arguments">32-bit:&nbsp; Effect of Function Prototypes on Arguments</A>
<BR><A HREF="#32Mbit__Forcing_a_Stack_Frame">32-bit:&nbsp; Forcing a Stack Frame</A>
<BR><A HREF="#32Mbit__Forcing_Arguments_into_Specific_Registers">32-bit:&nbsp; Forcing Arguments into Specific Registers</A>
<BR><A HREF="#32Mbit__Functions_with_Variable_Number_of_Arguments">32-bit:&nbsp; Functions with Variable Number of Arguments</A>
<BR><A HREF="#32Mbit__Interfacing_to_Assembly_Language_Functions">32-bit:&nbsp; Interfacing to Assembly Language Functions</A>
<BR><A HREF="#32Mbit__Loading_Data_Segment_Register">32-bit:&nbsp; Loading Data Segment Register</A>
<BR><A HREF="#32Mbit__Memory_Layout">32-bit:&nbsp; Memory Layout</A>
<BR><A HREF="#32Mbit__Passing_Arguments_in_Registers">32-bit:&nbsp; Passing Arguments in Registers</A>
<BR><A HREF="#32Mbit__Passing_Arguments_in_Reverse_Order">32-bit:&nbsp; Passing Arguments in Reverse Order</A>
<BR><A HREF="#32Mbit__Passing_Arguments_to_InMLine_Functions">32-bit:&nbsp; Passing Arguments to In-Line Functions</A>
<BR><A HREF="#32Mbit__Passing_Arguments_Using_RegisterMBased_Calling_Conventions">32-bit:&nbsp; Passing Arguments Using Register-Based Calling Conventions</A>
<BR><A HREF="#32Mbit__Passing_Values_in_80x87Mbased_Applications">32-bit:&nbsp; Passing Values in 80x87-based Applications</A>
<BR><A HREF="#32Mbit__Predefined____cdecl__Alias">32-bit:&nbsp; Predefined &quot;__cdecl&quot; Alias</A>
<BR><A HREF="#32Mbit__Predefined____pascal__Alias">32-bit:&nbsp; Predefined &quot;__pascal&quot; Alias</A>
<BR><A HREF="#32Mbit__Predefined____stdcall__Alias">32-bit:&nbsp; Predefined &quot;__stdcall&quot; Alias</A>
<BR><A HREF="#32Mbit__Predefined____syscall__Alias">32-bit:&nbsp; Predefined &quot;__syscall&quot; Alias</A>
<BR><A HREF="#32Mbit__Predefined____watcall__Alias_Lregister_calling_conventionR">32-bit:&nbsp; Predefined &quot;__watcall&quot; Alias (register calling convention)</A>
<BR><A HREF="#32Mbit__Predefined____watcall__Alias_Lstack_calling_conventionR">32-bit:&nbsp; Predefined &quot;__watcall&quot; Alias (stack calling convention)</A>
<BR><A HREF="#32Mbit__Predefined_Aliases">32-bit:&nbsp; Predefined Aliases</A>
<BR><A HREF="#32Mbit__Preserving_80x87_FloatingMPoint_Registers_Across_Calls">32-bit:&nbsp; Preserving 80x87 Floating-Point Registers Across Calls</A>
<BR><A HREF="#32Mbit__Removing_Arguments_from_the_Stack">32-bit:&nbsp; Removing Arguments from the Stack</A>
<BR><A HREF="#32Mbit__Returning_FloatingMPoint_Data">32-bit:&nbsp; Returning Floating-Point Data</A>
<BR><A HREF="#32Mbit__Returning_Function_Values_in_Registers">32-bit:&nbsp; Returning Function Values in Registers</A>
<BR><A HREF="#32Mbit__Returning_Structures">32-bit:&nbsp; Returning Structures</A>
<BR><A HREF="#32Mbit__Returning_Values_from_Functions">32-bit:&nbsp; Returning Values from Functions</A>
<BR><A HREF="#32Mbit__Returning_Values_in_80x87Mbased_Applications">32-bit:&nbsp; Returning Values in 80x87-based Applications</A>
<BR><A HREF="#32Mbit__Setting_Priority_of_Static_Data_Initialization_LCPP_OnlyR">32-bit:&nbsp; Setting Priority of Static Data Initialization (C++ Only)</A>
<BR><A HREF="#32Mbit__Size_of_Enumerated_Types">32-bit:&nbsp; Size of Enumerated Types</A>
<BR><A HREF="#32Mbit__Sizes_of_Predefined_Types">32-bit:&nbsp; Sizes of Predefined Types</A>
<BR><A HREF="#32Mbit__Specifying_Symbol_Attributes">32-bit:&nbsp; Specifying Symbol Attributes</A>
<BR><A HREF="#32Mbit__The_ALIAS_Pragma_LC_OnlyR">32-bit:&nbsp; The ALIAS Pragma (C Only)</A>
<BR><A HREF="#32Mbit__The_ALLOC_TEXT_Pragma_LC_OnlyR">32-bit:&nbsp; The ALLOC_TEXT Pragma (C Only)</A>
<BR><A HREF="#32Mbit__The_CODE_SEG_Pragma">32-bit:&nbsp; The CODE_SEG Pragma</A>
<BR><A HREF="#32Mbit__The_COMMENT_Pragma">32-bit:&nbsp; The COMMENT Pragma</A>
<BR><A HREF="#32Mbit__The_DATA_SEG_Pragma">32-bit:&nbsp; The DATA_SEG Pragma</A>
<BR><A HREF="#32Mbit__The_DISABLE_MESSAGE_Pragma">32-bit:&nbsp; The DISABLE_MESSAGE Pragma</A>
<BR><A HREF="#32Mbit__The_DUMP_OBJECT_MODEL_Pragma_LCPP_OnlyR">32-bit:&nbsp; The DUMP_OBJECT_MODEL Pragma (C++ Only)</A>
<BR><A HREF="#32Mbit__The_ENABLE_MESSAGE_Pragma">32-bit:&nbsp; The ENABLE_MESSAGE Pragma</A>
<BR><A HREF="#32Mbit__The_ENUM_Pragma">32-bit:&nbsp; The ENUM Pragma</A>
<BR><A HREF="#32Mbit__The_ERROR_Pragma">32-bit:&nbsp; The ERROR Pragma</A>
<BR><A HREF="#32Mbit__The_EXTREF_Pragma">32-bit:&nbsp; The EXTREF Pragma</A>
<BR><A HREF="#32Mbit__The_FUNCTION_Pragma">32-bit:&nbsp; The FUNCTION Pragma</A>
<BR><A HREF="#32Mbit__The_INCLUDE_ALIAS_Pragma">32-bit:&nbsp; The INCLUDE_ALIAS Pragma</A>
<BR><A HREF="#32Mbit__The_INLINE_DEPTH_Pragma_LCPP_OnlyR">32-bit:&nbsp; The INLINE_DEPTH Pragma (C++ Only)</A>
<BR><A HREF="#32Mbit__The_INLINE_RECURSION_Pragma_LCPP_OnlyR">32-bit:&nbsp; The INLINE_RECURSION Pragma (C++ Only)</A>
<BR><A HREF="#32Mbit__The_INTRINSIC_Pragma">32-bit:&nbsp; The INTRINSIC Pragma</A>
<BR><A HREF="#32Mbit__The_MESSAGE_Pragma">32-bit:&nbsp; The MESSAGE Pragma</A>
<BR><A HREF="#32Mbit__The_ONCE_Pragma">32-bit:&nbsp; The ONCE Pragma</A>
<BR><A HREF="#32Mbit__The_PACK_Pragma">32-bit:&nbsp; The PACK Pragma</A>
<BR><A HREF="#32Mbit__The_READ_ONLY_FILE_Pragma">32-bit:&nbsp; The READ_ONLY_FILE Pragma</A>
<BR><A HREF="#32Mbit__The_TEMPLATE_DEPTH_Pragma_LCPP_OnlyR">32-bit:&nbsp; The TEMPLATE_DEPTH Pragma (C++ Only)</A>
<BR><A HREF="#32Mbit__The_WARNING_Pragma_LCPP_OnlyR">32-bit:&nbsp; The WARNING Pragma (C++ Only)</A>
<BR><A HREF="#32Mbit__Type__char_">32-bit:&nbsp; Type &quot;char&quot;</A>
<BR><A HREF="#32Mbit__Type__double_">32-bit:&nbsp; Type &quot;double&quot;</A>
<BR><A HREF="#32Mbit__Type__float_">32-bit:&nbsp; Type &quot;float&quot;</A>
<BR><A HREF="#32Mbit__Type__int_">32-bit:&nbsp; Type &quot;int&quot;</A>
<BR><A HREF="#32Mbit__Type__long_int_">32-bit:&nbsp; Type &quot;long int&quot;</A>
<BR><A HREF="#32Mbit__Type__short_int_">32-bit:&nbsp; Type &quot;short int&quot;</A>
<BR><A HREF="#32Mbit__Using_Pragmas_to_Specify_Default_Libraries">32-bit:&nbsp; Using Pragmas to Specify Default Libraries</A>
<BR><A HREF="#32Mbit__Using_Pragmas_to_Specify_Options">32-bit:&nbsp; Using Pragmas to Specify Options</A>
<BR><A HREF="#32Mbit__Using_StackMBased_Calling_Conventions">32-bit:&nbsp; Using Stack-Based Calling Conventions</A>
<BR><A HREF="#32Mbit__Using_the_80x87_to_Pass_Arguments">32-bit:&nbsp; Using the 80x87 to Pass Arguments</A>
<BR><A HREF="#32Mbit__Using_the_80x87_to_Return_Function_Values">32-bit:&nbsp; Using the 80x87 to Return Function Values</A>
<BR><A HREF="#3_r_s_">3{r|s}</A>
<DT>- 4 -
<DD><A HREF="#4">4</A>
<BR><A HREF="#4_r_s_">4{r|s}</A>
<DT>- 5 -
<DD><A HREF="#5">5</A>
<BR><A HREF="#5_r_s_">5{r|s}</A>
<DT>- 6 -
<DD><A HREF="#6">6</A>
<BR><A HREF="#6_r_s_">6{r|s}</A>
<DT>- 8 -
<DD><A HREF="#80x86_Floating_Point">80x86 Floating Point</A>
<BR><A HREF="#80x86_RunMtime_Conventions">80x86 Run-time Conventions</A>
<DT>- _ -
<DD><A HREF="#The___declspec_Keyword">The __declspec Keyword</A>
<DT>- A -
<DD><A HREF="#About_This_Manual">About This Manual</A>
<BR><A HREF="#adUEXfile_nameYV">ad[=&lt;file_name&gt;]</A>
<BR><A HREF="#adbs">adbs</A>
<BR><A HREF="#addUEXfile_nameYV">add[=&lt;file_name&gt;]</A>
<BR><A HREF="#adfs">adfs</A>
<BR><A HREF="#adhpUEXpath_nameYV">adhp[=&lt;path_name&gt;]</A>
<BR><A HREF="#adtUEXtarget_nameYV">adt[=&lt;target_name&gt;]</A>
<DT>- B -
<DD><A HREF="#Based_Pointers">Based Pointers</A>
<BR><A HREF="#bc">bc</A>
<BR><A HREF="#bd">bd</A>
<BR><A HREF="#Benchmarking_Hints">Benchmarking Hints</A>
<BR><A HREF="#bg">bg</A>
<BR><A HREF="#bm">bm</A>
<BR><A HREF="#br">br</A>
<BR><A HREF="#btUEXosYV">bt[=&lt;os&gt;]</A>
<BR><A HREF="#bw">bw</A>
<DT>- C -
<DD><A HREF="#CPP_Exception_Handling">C++ Exception Handling</A>
<BR><A HREF="#Choosing_the_Correct_FloatingMPoint_Option">Choosing the Correct Floating-Point Option</A>
<BR><A HREF="#Code_Generation">Code Generation</A>
<BR><A HREF="#Compatibility_with_Microsoft_Visual_CPP">Compatibility with Microsoft Visual C++</A>
<BR><A HREF="#Compatibility_with_Older_Versions_of_the_80x86_Compilers">Compatibility with Older Versions of the 80x86 Compilers</A>
<BR><A HREF="#Compiler_Diagnostics">Compiler Diagnostics</A>
<BR><A HREF="#Compiler_Options_M_Full_Description">Compiler Options - Full Description</A>
<BR><A HREF="#Compiler_Options_M_Indexed">Compiler Options - Indexed</A>
<BR><A HREF="#Compiler_Options_M_Summarized_Alphabetically">Compiler Options - Summarized Alphabetically</A>
<BR><A HREF="#Compiler_Options_M_Summarized_By_Category">Compiler Options - Summarized By Category</A>
<BR><A HREF="#Consistency_Rules_for_Precompiled_Headers">Consistency Rules for Precompiled Headers</A>
<BR><A HREF="#Creating_a_Tiny_Memory_Model_Application">Creating a Tiny Memory Model Application</A>
<BR><A HREF="#Creating_and_Using_Precompiled_Headers">Creating and Using Precompiled Headers</A>
<BR><A HREF="#Creating_ROMMbased_Applications">Creating ROM-based Applications</A>
<DT>- D -
<DD><A HREF="#dP">d+</A>
<BR><A HREF="#d0">d0</A>
<BR><A HREF="#d1">d1</A>
<BR><A HREF="#d1P">d1+</A>
<BR><A HREF="#d2">d2</A>
<BR><A HREF="#d2i">d2i</A>
<BR><A HREF="#d2s">d2s</A>
<BR><A HREF="#d2t">d2t</A>
<BR><A HREF="#d3">d3</A>
<BR><A HREF="#d3i">d3i</A>
<BR><A HREF="#d3s">d3s</A>
<BR><A HREF="#dXnameYUEtextV">d&lt;name&gt;[=text]</A>
<BR><A HREF="#db">db</A>
<BR><A HREF="#DebuggingDProfiling">Debugging/Profiling</A>
<BR><A HREF="#Diagnostics">Diagnostics</A>
<BR><A HREF="#DoubleMByteDUnicode_Characters">Double-Byte/Unicode Characters</A>
<DT>- E -
<DD><A HREF="#eXnumberY">e&lt;number&gt;</A>
<BR><A HREF="#ecc">ecc</A>
<BR><A HREF="#ecd">ecd</A>
<BR><A HREF="#ecf">ecf</A>
<BR><A HREF="#ecp">ecp</A>
<BR><A HREF="#ecr">ecr</A>
<BR><A HREF="#ecs">ecs</A>
<BR><A HREF="#ecw">ecw</A>
<BR><A HREF="#ee">ee</A>
<BR><A HREF="#ef">ef</A>
<BR><A HREF="#ei">ei</A>
<BR><A HREF="#em">em</A>
<BR><A HREF="#en">en</A>
<BR><A HREF="#Environment_Variables">Environment Variables</A>
<BR><A HREF="#epUXnumberYV">ep[&lt;number&gt;]</A>
<BR><A HREF="#eq">eq</A>
<BR><A HREF="#er">er</A>
<BR><A HREF="#errno_Values_and_Their_Meanings">errno Values and Their Meanings</A>
<BR><A HREF="#et">et</A>
<BR><A HREF="#ew">ew</A>
<BR><A HREF="#Exception_Filters_and_Exception_Handlers">Exception Filters and Exception Handlers</A>
<BR><A HREF="#ez">ez</A>
<DT>- F -
<DD><A HREF="#fcEXfile_nameY">fc=&lt;file_name&gt;</A>
<BR><A HREF="#fhUqVUEXfile_nameYV">fh[q][=&lt;file_name&gt;]</A>
<BR><A HREF="#fhd">fhd</A>
<BR><A HREF="#fhr">fhr</A>
<BR><A HREF="#fhw">fhw</A>
<BR><A HREF="#fhwe">fhwe</A>
<BR><A HREF="#fiEXfile_nameY">fi=&lt;file_name&gt;</A>
<BR><A HREF="#Flat_Memory_Model">Flat Memory Model</A>
<BR><A HREF="#foUEXfile_nameYV">fo[=&lt;file_name&gt;]</A>
<BR><A HREF="#foUEXfile_nameYV_LpreprocessorR">fo[=&lt;file_name&gt;] (preprocessor)</A>
<BR><A HREF="#FORCE">FORCE</A>
<BR><A HREF="#fp2">fp2</A>
<BR><A HREF="#fp3">fp3</A>
<BR><A HREF="#fp5">fp5</A>
<BR><A HREF="#fp6">fp6</A>
<BR><A HREF="#fpc">fpc</A>
<BR><A HREF="#fpd">fpd</A>
<BR><A HREF="#fpi">fpi</A>
<BR><A HREF="#fpi87">fpi87</A>
<BR><A HREF="#fpr">fpr</A>
<BR><A HREF="#frUEXfile_nameYV">fr[=&lt;file_name&gt;]</A>
<BR><A HREF="#ft">ft</A>
<BR><A HREF="#fti">fti</A>
<BR><A HREF="#fx">fx</A>
<BR><A HREF="#fzh">fzh</A>
<BR><A HREF="#fzs">fzs</A>
<DT>- G -
<DD><A HREF="#gEXcodegroupY">g=&lt;codegroup&gt;</A>
<DT>- H -
<DD><A HREF="#h_w_d_c_">h{w,d,c}</A>
<DT>- I -
<DD><A HREF="#iEXdirectoryY">i=&lt;directory&gt;</A>
<BR><A HREF="#InMline_Assembly_Directives_and_Opcodes">In-line Assembly Directives and Opcodes</A>
<BR><A HREF="#InMline_Assembly_Language">In-line Assembly Language</A>
<BR><A HREF="#InMline_Assembly_Language_Default_Environment">In-line Assembly Language Default Environment</A>
<BR><A HREF="#InMline_Assembly_Language_Tutorial">In-line Assembly Language Tutorial</A>
<BR><A HREF="#InMline_Assembly_Language_using__asm">In-line Assembly Language using _asm</A>
<BR><A HREF="#INCLUDE">INCLUDE</A>
<DT>- J -
<DD><A HREF="#j">j</A>
<DT>- K -
<DD><A HREF="#k">k</A>
<DT>- L -
<DD><A HREF="#Labels_in_InMline_Assembly_Code">Labels in In-line Assembly Code</A>
<BR><A HREF="#LFN">LFN</A>
<BR><A HREF="#The_LFN_Environment_Variable">The LFN Environment Variable</A>
<BR><A HREF="#LIB">LIB</A>
<BR><A HREF="#LIBDOS">LIBDOS</A>
<BR><A HREF="#LIBOS2">LIBOS2</A>
<BR><A HREF="#LIBPHAR">LIBPHAR</A>
<BR><A HREF="#LIBWIN">LIBWIN</A>
<BR><A HREF="#Linking_Applications_for_the_Various_16Mbit_Memory_Models">Linking Applications for the Various 16-bit Memory Models</A>
<BR><A HREF="#Linking_Applications_for_the_Various_32Mbit_Memory_Models">Linking Applications for the Various 32-bit Memory Models</A>
<DT>- M -
<DD><A HREF="#Math_RunMTime_Error_Messages">Math Run-Time Error Messages</A>
<BR><A HREF="#mc">mc</A>
<BR><A HREF="#mf">mf</A>
<BR><A HREF="#mh">mh</A>
<BR><A HREF="#Mixed_16Mbit_Memory_Model">Mixed 16-bit Memory Model</A>
<BR><A HREF="#Mixed_32Mbit_Memory_Model">Mixed 32-bit Memory Model</A>
<BR><A HREF="#Mixing_and_Matching__tryD_finally_and__tryD_except">Mixing and Matching _try/_finally and _try/_except</A>
<BR><A HREF="#ml">ml</A>
<BR><A HREF="#mm">mm</A>
<BR><A HREF="#Modifying_the_Startup_Code">Modifying the Startup Code</A>
<BR><A HREF="#ms">ms</A>
<DT>- N -
<DD><A HREF="#ncEXnameY">nc=&lt;name&gt;</A>
<BR><A HREF="#ndEXnameY">nd=&lt;name&gt;</A>
<BR><A HREF="#nmEXnameY">nm=&lt;name&gt;</A>
<BR><A HREF="#NO87">NO87</A>
<BR><A HREF="#The_NO87_Environment_Variable">The NO87 Environment Variable</A>
<BR><A HREF="#ntEXnameY">nt=&lt;name&gt;</A>
<DT>- O -
<DD><A HREF="#oa">oa</A>
<BR><A HREF="#ob">ob</A>
<BR><A HREF="#oc">oc</A>
<BR><A HREF="#od">od</A>
<BR><A HREF="#oeEXnumY">oe=&lt;num&gt;</A>
<BR><A HREF="#of">of</A>
<BR><A HREF="#ofP">of+</A>
<BR><A HREF="#oh">oh</A>
<BR><A HREF="#oi">oi</A>
<BR><A HREF="#oiP">oi+</A>
<BR><A HREF="#ok">ok</A>
<BR><A HREF="#ol">ol</A>
<BR><A HREF="#olP">ol+</A>
<BR><A HREF="#om">om</A>
<BR><A HREF="#on">on</A>
<BR><A HREF="#oo">oo</A>
<BR><A HREF="#op">op</A>
<BR><A HREF="#Open_Watcom_CDCPP__include_File_Processing">Open Watcom C/C++ #include File Processing</A>
<BR><A HREF="#Open_Watcom_CDCPP_80x87_Math_Libraries">Open Watcom C/C++ 80x87 Math Libraries</A>
<BR><A HREF="#Open_Watcom_CDCPP_Alternate_Math_Libraries">Open Watcom C/C++ Alternate Math Libraries</A>
<BR><A HREF="#Open_Watcom_CDCPP_C_Libraries">Open Watcom C/C++ C Libraries</A>
<BR><A HREF="#Open_Watcom_CDCPP_Class_Libraries">Open Watcom C/C++ Class Libraries</A>
<BR><A HREF="#Open_Watcom_CDCPP_Command_Line_Examples">Open Watcom C/C++ Command Line Examples</A>
<BR><A HREF="#Open_Watcom_CDCPP_Command_Line_Format">Open Watcom C/C++ Command Line Format</A>
<BR><A HREF="#Open_Watcom_CDCPP_Compiler_Options">Open Watcom C/C++ Compiler Options</A>
<BR><A HREF="#The_Open_Watcom_CDCPP_Compilers">The Open Watcom C/C++ Compilers</A>
<BR><A HREF="#Open_Watcom_CDCPP_DLLMbased_Compilers">Open Watcom C/C++ DLL-based Compilers</A>
<BR><A HREF="#Open_Watcom_CDCPP_Extended_Keywords">Open Watcom C/C++ Extended Keywords</A>
<BR><A HREF="#The_Open_Watcom_CDCPP_Libraries">The Open Watcom C/C++ Libraries</A>
<BR><A HREF="#Open_Watcom_CDCPP_Library_Directory_Structure">Open Watcom C/C++ Library Directory Structure</A>
<BR><A HREF="#Open_Watcom_CDCPP_Math_Libraries">Open Watcom C/C++ Math Libraries</A>
<BR><A HREF="#Open_Watcom_CDCPP_Predefined_Macros">Open Watcom C/C++ Predefined Macros</A>
<BR><A HREF="#Open_Watcom_CDCPP_Preprocessor">Open Watcom C/C++ Preprocessor</A>
<BR><A HREF="#The_Open_Watcom_CDCPP_RunMtime_Initialization_Routines">The Open Watcom C/C++ Run-time Initialization Routines</A>
<BR><A HREF="#Open_Watcom_CDCPP_RunMTime_Messages">Open Watcom C/C++ Run-Time Messages</A>
<BR><A HREF="#The_Open_Watcom_Code_Generator">The Open Watcom Code Generator</A>
<BR><A HREF="#Optimizations">Optimizations</A>
<BR><A HREF="#or">or</A>
<BR><A HREF="#os">os</A>
<BR><A HREF="#ot">ot</A>
<BR><A HREF="#ou">ou</A>
<BR><A HREF="#ox">ox</A>
<BR><A HREF="#oz">oz</A>
<DT>- P -
<DD><A HREF="#PATH">PATH</A>
<BR><A HREF="#pil">pil</A>
<BR><A HREF="#Precompiled_Headers">Precompiled Headers</A>
<BR><A HREF="#Preprocessor">Preprocessor</A>
<BR><A HREF="#p_e_l_c_wEXnumY_">p{e,l,c,w=&lt;num&gt;}</A>
<DT>- Q -
<DD><A HREF="#q">q</A>
<DT>- R -
<DD><A HREF="#r">r</A>
<BR><A HREF="#Refining_Exception_Handling">Refining Exception Handling</A>
<BR><A HREF="#Resuming_Execution_After_an_Exception">Resuming Execution After an Exception</A>
<BR><A HREF="#ri">ri</A>
<BR><A HREF="#ROMable_Functions">ROMable Functions</A>
<BR><A HREF="#RunMTime_Error_Messages">Run-Time Error Messages</A>
<DT>- S -
<DD><A HREF="#s">s</A>
<BR><A HREF="#Segment_Constant_Based_Pointers_and_Objects">Segment Constant Based Pointers and Objects</A>
<BR><A HREF="#Segment_Object_Based_Pointers">Segment Object Based Pointers</A>
<BR><A HREF="#SegmentsDModules">Segments/Modules</A>
<BR><A HREF="#Self_Based_Pointers">Self Based Pointers</A>
<BR><A HREF="#sg">sg</A>
<BR><A HREF="#SourceDOutput_Control">Source/Output Control</A>
<BR><A HREF="#st">st</A>
<BR><A HREF="#Structured_Exception_Handling">Structured Exception Handling</A>
<BR><A HREF="#Summary_of_16Mbit_Memory_Models">Summary of 16-bit Memory Models</A>
<BR><A HREF="#Summary_of_32Mbit_Memory_Models">Summary of 32-bit Memory Models</A>
<BR><A HREF="#Summary__80x86_Floating_Point">Summary:&nbsp; 80x86 Floating Point</A>
<BR><A HREF="#Summary__80x86_RunMtime_Conventions">Summary:&nbsp; 80x86 Run-time Conventions</A>
<BR><A HREF="#Summary__CPP_Exception_Handling">Summary:&nbsp; C++ Exception Handling</A>
<BR><A HREF="#Summary__Code_Generation">Summary:&nbsp; Code Generation</A>
<BR><A HREF="#Summary__Compatibility_with_Microsoft_Visual_CPP">Summary:&nbsp; Compatibility with Microsoft Visual C++</A>
<BR><A HREF="#Summary__Compatibility_with_Older_Versions_of_the_80x86_Compilers">Summary:&nbsp; Compatibility with Older Versions of the 80x86 Compilers</A>
<BR><A HREF="#Summary__DebuggingDProfiling">Summary:&nbsp; Debugging/Profiling</A>
<BR><A HREF="#Summary__Diagnostics">Summary:&nbsp; Diagnostics</A>
<BR><A HREF="#Summary__DoubleMByteDUnicode_Characters">Summary:&nbsp; Double-Byte/Unicode Characters</A>
<BR><A HREF="#Summary__Optimizations">Summary:&nbsp; Optimizations</A>
<BR><A HREF="#Summary__Preprocessor">Summary:&nbsp; Preprocessor</A>
<BR><A HREF="#Summary__SegmentsDModules">Summary:&nbsp; Segments/Modules</A>
<BR><A HREF="#Summary__SourceDOutput_Control">Summary:&nbsp; Source/Output Control</A>
<BR><A HREF="#Summary__Target_Specific">Summary:&nbsp; Target Specific</A>
<BR><A HREF="#SystemMDependent_Functions">System-Dependent Functions</A>
<DT>- T -
<DD><A HREF="#tEXnumY">t=&lt;num&gt;</A>
<BR><A HREF="#Target_Specific">Target Specific</A>
<BR><A HREF="#Termination_Handlers">Termination Handlers</A>
<BR><A HREF="#Throwing_Your_Own_Exceptions">Throwing Your Own Exceptions</A>
<BR><A HREF="#Tiny_Memory_Model">Tiny Memory Model</A>
<BR><A HREF="#TMP">TMP</A>
<DT>- U -
<DD><A HREF="#uXnameY">u&lt;name&gt;</A>
<BR><A HREF="#Use_of_Environment_Variables">Use of Environment Variables</A>
<DT>- V -
<DD><A HREF="#v">v</A>
<BR><A HREF="#Variables_in_InMline_Assembly_Code">Variables in In-line Assembly Code</A>
<BR><A HREF="#vc___">vc...</A>
<BR><A HREF="#vcap">vcap</A>
<BR><A HREF="#Void_Based_Pointers">Void Based Pointers</A>
<DT>- W -
<DD><A HREF="#wXnumberY">w&lt;number&gt;</A>
<BR><A HREF="#WATCOM">WATCOM</A>
<BR><A HREF="#WCC">WCC</A>
<BR><A HREF="#WCC386">WCC386</A>
<BR><A HREF="#wcdEXnumberY">wcd=&lt;number&gt;</A>
<BR><A HREF="#wceEXnumberY">wce=&lt;number&gt;</A>
<BR><A HREF="#WCGMEMORY">WCGMEMORY</A>
<BR><A HREF="#WCL">WCL</A>
<BR><A HREF="#WCL386">WCL386</A>
<BR><A HREF="#WD">WD</A>
<BR><A HREF="#WDW">WDW</A>
<BR><A HREF="#we">we</A>
<BR><A HREF="#When_to_Precompile_Header_Files">When to Precompile Header Files</A>
<BR><A HREF="#WLANG">WLANG</A>
<BR><A HREF="#wo">wo</A>
<BR><A HREF="#WPP">WPP</A>
<BR><A HREF="#WPP386">WPP386</A>
<BR><A HREF="#wx">wx</A>
<DT>- X -
<DD><A HREF="#x">x</A>
<BR><A HREF="#xd">xd</A>
<BR><A HREF="#xds">xds</A>
<BR><A HREF="#xdt">xdt</A>
<BR><A HREF="#xr">xr</A>
<BR><A HREF="#xs">xs</A>
<BR><A HREF="#xss">xss</A>
<BR><A HREF="#xst">xst</A>
<BR><A HREF="#xx">xx</A>
<DT>- Z -
<DD><A HREF="#za">za</A>
<BR><A HREF="#zam">zam</A>
<BR><A HREF="#zat">zat</A>
<BR><A HREF="#zc">zc</A>
<BR><A HREF="#zdl">zdl</A>
<BR><A HREF="#zd_f_p_">zd{f,p}</A>
<BR><A HREF="#ze">ze</A>
<BR><A HREF="#zev">zev</A>
<BR><A HREF="#zf">zf</A>
<BR><A HREF="#zfw">zfw</A>
<BR><A HREF="#zf_f_p_">zf{f,p}</A>
<BR><A HREF="#zg">zg</A>
<BR><A HREF="#zg_f_p_">zg{f,p}</A>
<BR><A HREF="#zk0u">zk0u</A>
<BR><A HREF="#zkuEXcodepageY">zku=&lt;codepage&gt;</A>
<BR><A HREF="#zk_0_1_2_l_">zk{0,1,2,l}</A>
<BR><A HREF="#zl">zl</A>
<BR><A HREF="#zld">zld</A>
<BR><A HREF="#zlf">zlf</A>
<BR><A HREF="#zls">zls</A>
<BR><A HREF="#zm">zm</A>
<BR><A HREF="#zmf">zmf</A>
<BR><A HREF="#zpU_1_2_4_8_16_V">zp[{1,2,4,8,16}]</A>
<BR><A HREF="#zpw">zpw</A>
<BR><A HREF="#zq">zq</A>
<BR><A HREF="#zri">zri</A>
<BR><A HREF="#zro">zro</A>
<BR><A HREF="#zs">zs</A>
<BR><A HREF="#ztXnumberY">zt&lt;number&gt;</A>
<BR><A HREF="#zu">zu</A>
<BR><A HREF="#zv">zv</A>
<BR><A HREF="#zw">zw</A>
<BR><A HREF="#zW_LoptimizedR">zW (optimized)</A>
<BR><A HREF="#zWs">zWs</A>
<BR><A HREF="#zz">zz</A>
</DL>
<H1 ID="About_This_Manual"> About This Manual </H1>
<BR><IMG SRC="cguide.bmp">
<BR>This manual contains the following chapters:
<DL>
<DT>Chapter 1 -
<DD><A HREF="#About_This_Manual">About This Manual</A>.
<BR><BR>This chapter provides an overview of the contents of this guide.
<DT>Chapter 2 -
<DD><A HREF="#Open_Watcom_CDCPP_Compiler_Options">Open Watcom C/C++ Compiler Options</A>.
<BR><BR>This chapter provides a summary and reference section for all the C and C++ compiler options.
<DT>Chapter 3 -
<DD><A HREF="#The_Open_Watcom_CDCPP_Compilers">The Open Watcom C/C++ Compilers</A>.
<BR><BR>This chapter describes how to compile an application from the command line.&nbsp; This chapter also describes compiler
environment variables, benchmarking hints, compiler diagnostics, #include file processing, the preprocessor, predefined macros,
extended keywords, and the code generator.
<DT>Chapter 4 -
<DD><A HREF="#Precompiled_Headers">Precompiled Headers</A>.
<BR><BR>This chapter describes the use of precompiled headers to speed up compilation.
<DT>Chapter 5 -
<DD><A HREF="#The_Open_Watcom_CDCPP_Libraries">The Open Watcom C/C++ Libraries</A>.
<BR><BR>This chapter describes the Open Watcom C/C++ library directory structure, C libraries, class libraries, math libraries,
80x87 math libraries, alternate math libraries, the &quot;NO87&quot; environment variable, and the run-time initialization
routines.
<DT>Chapter 6 -
<DD><A HREF="#16Mbit_Memory_Models">16-bit Memory Models</A>.
<BR><BR>This chapter describes the Open Watcom C/C++ memory models (including code and data models), the tiny memory model,
the mixed memory model, linking applications for the various memory models, creating a tiny memory model application, and
memory layout in an executable.
<DT>Chapter 7 -
<DD><A HREF="#16Mbit_Assembly_Language_Considerations">16-bit Assembly Language Considerations</A>.
<BR><BR>This chapter describes issues relating to 16-bit interfacing such as parameter passing conventions.
<DT>Chapter 8 -
<DD><A HREF="#16Mbit_Pragmas">16-bit Pragmas</A>.
<BR><BR>This chapter describes the use of pragmas with the 16-bit compilers.
<DT>Chapter 9 -
<DD><A HREF="#32Mbit_Memory_Models">32-bit Memory Models</A>.
<BR><BR>This chapter describes the Open Watcom C/C++ memory models (including code and data models), the flat memory model,
the mixed memory model, linking applications for the various memory models, and memory layout in an executable.
<DT>Chapter 10 -
<DD><A HREF="#32Mbit_Assembly_Language_Considerations">32-bit Assembly Language Considerations</A>.
<BR><BR>This chapter describes issues relating to 32-bit interfacing such as parameter passing conventions.
<DT>Chapter 11 -
<DD><A HREF="#32Mbit_Pragmas">32-bit Pragmas</A>.
<BR><BR>This chapter describes the use of pragmas with the 32-bit compilers.
<DT>Chapter 12 -
<DD><A HREF="#InMline_Assembly_Language">In-line Assembly Language</A>.
<BR><BR>This chapter describes in-line assembly language programming using the auxiliary pragma.
<DT>Chapter 13 -
<DD><A HREF="#Creating_ROMMbased_Applications">Creating ROM-based Applications</A>.
<BR><BR>This chapter discusses some embedded systems issues as they pertain to the C library.
<DT>Appendix A.&nbsp; -
<DD><A HREF="#Use_of_Environment_Variables">Use of Environment Variables</A>.
<BR><BR>This appendix describes all the environment variables used by the compilers and related tools.
<DT>Appendix B.&nbsp; -
<DD><A HREF="#Open_Watcom_CDCPP_RunMTime_Messages">Open Watcom C/C++ Run-Time Messages</A>.
<BR><BR>This appendix lists all of the C/C++ run-time diagnostic messages with an explanation for each.
</DL>
<H1 ID="Open_Watcom_CDCPP_Compiler_Options"> Open Watcom C/C++ Compiler Options </H1>
<BR>Source files can be compiled using either the IDE or command-line compilers.&nbsp; This chapter describes all the compiler
options that are available.
<BR><BR>For information about compiling applications from the IDE, see the<B><I> Open Watcom Graphical Tools User's Guide.</I></B>
<BR><BR>For information about compiling applications from the command line, see the chapter entitled <A HREF="#The_Open_Watcom_CDCPP_Compilers">The Open Watcom C/C++ Compilers</A>.
<BR><BR>The Open Watcom C/C++ compiler command names (<B>compiler_name</B>) are:&nbsp; 
<DL>
<DT>WCC
<DD>the Open Watcom C compiler for 16-bit Intel platforms.
<DT>WPP
<DD>the Open Watcom C++ compiler for 16-bit Intel platforms.
<DT>WCC386
<DD>the Open Watcom C compiler for 32-bit Intel platforms.
<DT>WPP386
<DD>the Open Watcom C++ compiler for 32-bit Intel platforms.
</DL>
<H2 ID="Compiler_Options_M_Indexed"> Compiler Options - Indexed </H2>
<BR>In this section, we present an index of all compiler options.
<BR><BR><A HREF="#0">0</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#1">1</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#2">2</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#3">3</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#4">4</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#5">5</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#6">6</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#3_r_s_">3{r|s}</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#4_r_s_">4{r|s}</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#5_r_s_">5{r|s}</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#6_r_s_">6{r|s}</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#adUEXfile_nameYV">ad[=&lt;file_name&gt;]</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#addUEXfile_nameYV">add[=&lt;file_name&gt;]</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#adhpUEXpath_nameYV">adhp[=&lt;path_name&gt;]</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#adtUEXtarget_nameYV">adt[=&lt;target_name&gt;]</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#adbs">adbs</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#adfs">adfs</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#bc">bc</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#bd">bd</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#bg">bg</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#bm">bm</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#br">br</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#btUEXosYV">bt[=&lt;os&gt;]</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#bw">bw</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#d0">d0</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#d1">d1</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#d1P">d1+</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#d2">d2</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#d2i">d2i</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#d2s">d2s</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#d2t">d2t</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#d3">d3</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#d3i">d3i</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#d3s">d3s</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#dXnameYUEtextV">d&lt;name&gt;[=text]</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#dP">d+</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#db">db</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#eXnumberY">e&lt;number&gt;</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#ecc">ecc</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#ecd">ecd</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#ecf">ecf</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#ecp">ecp</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#ecr">ecr</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#ecs">ecs</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#ecw">ecw</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#ee">ee</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#ef">ef</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#ei">ei</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#em">em</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#en">en</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#epUXnumberYV">ep[&lt;number&gt;]</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#eq">eq</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#er">er</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#et">et</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#ew">ew</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#ez">ez</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#fcEXfile_nameY">fc=&lt;file_name&gt;</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#fhUqVUEXfile_nameYV">fh[q][=&lt;file_name&gt;]</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#fhd">fhd</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#fhr">fhr</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#fhw">fhw</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#fhwe">fhwe</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#fiEXfile_nameY">fi=&lt;file_name&gt;</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#foUEXfile_nameYV_LpreprocessorR">fo[=&lt;file_name&gt;] (preprocessor)</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

<BR><A HREF="#foUEXfile_nameYV">fo[=&lt;file_name&gt;]</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#fpc">fpc</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#fpi">fpi</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#fpi87">fpi87</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#fp2">fp2</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#fp3">fp3</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#fp5">fp5</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#fp6">fp6</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#fpd">fpd</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#fpr">fpr</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#frUEXfile_nameYV">fr[=&lt;file_name&gt;]</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#ft">ft</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#fti">fti</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#fx">fx</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#fzh">fzh</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#fzs">fzs</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#gEXcodegroupY">g=&lt;codegroup&gt;</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#h_w_d_c_">h{w,d,c}</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#iEXdirectoryY">i=&lt;directory&gt;</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#j">j</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#k">k</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#mf">mf</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#ms">ms</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#mm">mm</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#mc">mc</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#ml">ml</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#mh">mh</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#ncEXnameY">nc=&lt;name&gt;</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#ndEXnameY">nd=&lt;name&gt;</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#nmEXnameY">nm=&lt;name&gt;</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#ntEXnameY">nt=&lt;name&gt;</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#oa">oa</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#ob">ob</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#oc">oc</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#od">od</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#oeEXnumY">oe=&lt;num&gt;</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#of">of</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#ofP">of+</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#oh">oh</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#oi">oi</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#oiP">oi+</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#ok">ok</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#ol">ol</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#olP">ol+</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#om">om</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#on">on</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#oo">oo</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#op">op</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#or">or</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#os">os</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#ot">ot</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#ou">ou</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#ox">ox</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#oz">oz</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#oa">oa</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#pil">pil</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#p_e_l_c_wEXnumY_">p{e,l,c,w=&lt;num&gt;}</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#q">q</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#r">r</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#ri">ri</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#s">s</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#sg">sg</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#st">st</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#tEXnumY">t=&lt;num&gt;</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#uXnameY">u&lt;name&gt;</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#v">v</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#vc___">vc...</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#wXnumberY">w&lt;number&gt;</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#wcdEXnumberY">wcd=&lt;number&gt;</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#wceEXnumberY">wce=&lt;number&gt;</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#we">we</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#wo">wo</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#wx">wx</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#x">x</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#xd">xd</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#xdt">xdt</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#xds">xds</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#xr">xr</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#xs">xs</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#xst">xst</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#xss">xss</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#xx">xx</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#za">za</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#zam">zam</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#zat">zat</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#ze">ze</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#zc">zc</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#zd_f_p_">zd{f,p}</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#zdl">zdl</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#zev">zev</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#zf">zf</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#zf_f_p_">zf{f,p}</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#zfw">zfw</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#zg">zg</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#zg_f_p_">zg{f,p}</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#zk_0_1_2_l_">zk{0,1,2,l}</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#zk0u">zk0u</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#zkuEXcodepageY">zku=&lt;codepage&gt;</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#zl">zl</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#zld">zld</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#zlf">zlf</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#zls">zls</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#zm">zm</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#zmf">zmf</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#zpU_1_2_4_8_16_V">zp[{1,2,4,8,16}]</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#zpw">zpw</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#zq">zq</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#zri">zri</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#zro">zro</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#zs">zs</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#ztXnumberY">zt&lt;number&gt;</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#zu">zu</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#zv">zv</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#zw">zw</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#zW_LoptimizedR">zW (optimized)</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#zWs">zWs</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><A HREF="#zz">zz</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<H2 ID="Compiler_Options_M_Summarized_Alphabetically"> Compiler Options - Summarized Alphabetically </H2>
<BR>In this section, we present a terse summary of compiler options.&nbsp; This summary is displayed on the screen by simply
entering the compiler command name with no arguments.
<DL>
<DT>Option:
<DD>Description:
<DT>0
<DD>(16-bit only) 8088 and 8086 instructions (default for 16-bit) (see <A HREF="#0">0</A>)
<DT>1
<DD>(16-bit only) 188 and 186 instructions (see <A HREF="#1">1</A>)
<DT>2
<DD>(16-bit only) 286 instructions (see <A HREF="#2">2</A>)
<DT>3
<DD>(16-bit only) 386 instructions (see <A HREF="#3">3</A>)
<DT>4
<DD>(16-bit only) 486 instructions (see <A HREF="#4">4</A>)
<DT>5
<DD>(16-bit only) Pentium instructions (see <A HREF="#5">5</A>)
<DT>6
<DD>(16-bit only) Pentium Pro instructions (see <A HREF="#6">6</A>)
<DT>3r
<DD>(32-bit only) generate 386 instructions based on 386 instruction timings and use register-based argument passing conventions
(see <A HREF="#3_r_s_">3{r|s}</A>)
<DT>3s
<DD>(32-bit only) generate 386 instructions based on 386 instruction timings and use stack-based argument passing conventions
(see <A HREF="#3_r_s_">3{r|s}</A>)
<DT>4r
<DD>(32-bit only) generate 386 instructions based on 486 instruction timings and use register-based argument passing conventions
(see <A HREF="#4_r_s_">4{r|s}</A>)
<DT>4s
<DD>(32-bit only) generate 386 instructions based on 486 instruction timings and use stack-based argument passing conventions
(see <A HREF="#4_r_s_">4{r|s}</A>)
<DT>5r
<DD>(32-bit only) generate 386 instructions based on Intel Pentium instruction timings and use register-based argument passing
conventions (default for 32-bit) (see <A HREF="#5_r_s_">5{r|s}</A>)
<DT>5s
<DD>(32-bit only) generate 386 instructions based on Intel Pentium instruction timings and use stack-based argument passing conventions
(see <A HREF="#5_r_s_">5{r|s}</A>)
<DT>6r
<DD>(32-bit only) generate 386 instructions based on Intel Pentium Pro instruction timings and use register-based argument passing
conventions (see <A HREF="#6_r_s_">6{r|s}</A>)
<DT>6s
<DD>(32-bit only) generate 386 instructions based on Intel Pentium Pro instruction timings and use stack-based argument passing
conventions (see <A HREF="#6_r_s_">6{r|s}</A>)
<DT>ad[=&lt;file_name&gt;]
<DD>generate make style automatic dependency file (see <A HREF="#adUEXfile_nameYV">ad[=&lt;file_name&gt;]</A>)
<DT>adbs
<DD>force path separators generated in auto-dependency files to backslashes (see <A HREF="#adbs">adbs</A>)
<DT>add[=&lt;file_name&gt;]
<DD>specify source dependency name generated in make style auto-dependency file (see <A HREF="#addUEXfile_nameYV">add[=&lt;file_name&gt;]</A>)
<DT>adhp[=&lt;file_name&gt;]
<DD>specify path to use for headers with no path given (see <A HREF="#adhpUEXpath_nameYV">adhp[=&lt;path_name&gt;]</A>)
<DT>adfs
<DD>force path separators generated in auto-dependency files to forward slashes (see <A HREF="#adfs">adfs</A>)
<DT>adt[=&lt;target_name&gt;]
<DD>specify target name generated in make style auto-dependency file (see <A HREF="#adtUEXtarget_nameYV">adt[=&lt;target_name&gt;]</A>)
<DT>bc
<DD>build target is a console application (see <A HREF="#bc">bc</A>)
<DT>bd
<DD>build target is a Dynamic Link Library (DLL) (see <A HREF="#bd">bd</A>)
<DT>bg
<DD>build target is a GUI application (see <A HREF="#bg">bg</A>)
<DT>bm
<DD>build target is a multi-thread environment (see <A HREF="#bm">bm</A>)
<DT>br
<DD>build target uses DLL version of C/C++ run-time libraries (see <A HREF="#br">br</A>)
<DT>bt[=&lt;os&gt;]
<DD>build target for operating system &lt;os&gt; (see <A HREF="#btUEXosYV">bt[=&lt;os&gt;]</A>)
<DT>bw
<DD>build target uses default windowing support (see <A HREF="#bw">bw</A>)
<DT>d0
<DD>(C++ only) no debugging information (see <A HREF="#d0">d0</A>)
<DT>d1
<DD>line number debugging information (see <A HREF="#d1">d1</A>)
<DT>d1+
<DD>(C only) line number debugging information plus typing information for global symbols and local structs and arrays (see <A HREF="#d1P">d1+</A>)
<DT>d2
<DD>full symbolic debugging information (see <A HREF="#d2">d2</A>)
<DT>d2i
<DD>(C++ only) d2 and debug inlines; emit inlines as external out-of-line functions (see <A HREF="#d2i">d2i</A>)
<DT>d2s
<DD>(C++ only) d2 and debug inlines; emit inlines as static out-of-line functions (see <A HREF="#d2s">d2s</A>)
<DT>d2t
<DD>(C++ only) full symbolic debugging information, without type names (see <A HREF="#d2t">d2t</A>)
<DT>d3
<DD>full symbolic debugging with unreferenced type names (see <A HREF="#d3">d3</A>) ,*
<DT>d3i
<DD>(C++ only) d3 plus debug inlines; emit inlines as external out-of-line functions (see <A HREF="#d3i">d3i</A>)
<DT>d3s
<DD>(C++ only) d3 plus debug inlines; emit inlines as static out-of-line functions (see <A HREF="#d3s">d3s</A>)
<DT>d&lt;name&gt;[=text]
<DD>preprocessor #define name [text] (see <A HREF="#dXnameYUEtextV">d&lt;name&gt;[=text]</A>)
<DT>d+
<DD>allow extended -d macro definitions (see <A HREF="#dP">d+</A>)
<DT>db
<DD>generate browsing information (see <A HREF="#db">db</A>)
<DT>e&lt;number&gt;
<DD>set error limit number (default is 20) (see <A HREF="#eXnumberY">e&lt;number&gt;</A>)
<DT>ecc
<DD>set default calling convention to __cdecl (see <A HREF="#ecc">ecc</A>)
<DT>ecd
<DD>set default calling convention to __stdcall (see <A HREF="#ecd">ecd</A>)
<DT>ecf
<DD>set default calling convention to __fastcall (see <A HREF="#ecf">ecf</A>)
<DT>ecp
<DD>set default calling convention to __pascal (see <A HREF="#ecp">ecp</A>)
<DT>ecr
<DD>set default calling convention to __fortran (see <A HREF="#ecr">ecr</A>)
<DT>ecs
<DD>set default calling convention to __syscall (see <A HREF="#ecs">ecs</A>)
<DT>ecw
<DD>set default calling convention to __watcall (default) (see <A HREF="#ecw">ecw</A>)
<DT>ee
<DD>call epilogue hook routine (see <A HREF="#ee">ee</A>)
<DT>ef
<DD>use full path names in error messages (see <A HREF="#ef">ef</A>)
<DT>ei
<DD>force enum base type to use at least an int (see <A HREF="#ei">ei</A>)
<DT>em
<DD>force enum base type to use minimum (see <A HREF="#em">em</A>)
<DT>en
<DD>emit routine name before prologue (see <A HREF="#en">en</A>)
<DT>ep[&lt;number&gt;]
<DD>call prologue hook routine with number of stack bytes available (see <A HREF="#epUXnumberYV">ep[&lt;number&gt;]</A>)
<DT>eq
<DD>do not display error messages (they are still written to a file) (see <A HREF="#eq">eq</A>)
<DT>er
<DD>(C++ only) do not recover from undefined symbol errors (see <A HREF="#er">er</A>)
<DT>et
<DD>Pentium profiling (see <A HREF="#et">et</A>)
<DT>ew
<DD>(C++ only) generate less verbose messages (see <A HREF="#ew">ew</A>)
<DT>ez
<DD>(32-bit only) generate Phar Lap Easy OMF-386 object file (see <A HREF="#ez">ez</A>)
<DT>fc=&lt;file_name&gt;
<DD>(C++ only) specify file of command lines to be batch processed (see <A HREF="#fcEXfile_nameY">fc=&lt;file_name&gt;</A>)
<DT>fh[q][=&lt;file_name&gt;]
<DD>use precompiled headers (see <A HREF="#fhUqVUEXfile_nameYV">fh[q][=&lt;file_name&gt;]</A>)
<DT>fhd
<DD>store debug info for pre-compiled header once (DWARF only) (see <A HREF="#fhd">fhd</A>)
<DT>fhr
<DD>(C++ only) force compiler to read pre-compiled header (see <A HREF="#fhr">fhr</A>)
<DT>fhw
<DD>(C++ only) force compiler to write pre-compiled header (see <A HREF="#fhw">fhw</A>)
<DT>fhwe
<DD>(C++ only) don't include pre-compiled header warnings when &quot;we&quot; is used (see <A HREF="#fhwe">fhwe</A>)
<DT>fi=&lt;file_name&gt;
<DD>force file_name to be included (see <A HREF="#fiEXfile_nameY">fi=&lt;file_name&gt;</A>)
<DT>fo=&lt;file_name&gt;
<DD>set object or preprocessor output file specification (see <A HREF="#foUEXfile_nameYV_LpreprocessorR">fo[=&lt;file_name&gt;] (preprocessor)</A>)
(see <A HREF="#foUEXfile_nameYV">fo[=&lt;file_name&gt;]</A>)
<DT>fpc
<DD>generate calls to floating-point library (see <A HREF="#fpc">fpc</A>)
<DT>fpi
<DD>(16-bit only) generate in-line 80x87 instructions with emulation (default)
<BR><BR>(32-bit only) generate in-line 387 instructions with emulation (default) (see <A HREF="#fpi">fpi</A>)
<DT>fpi87
<DD>(16-bit only) generate in-line 80x87 instructions
<BR><BR>(32-bit only) generate in-line 387 instructions (see <A HREF="#fpi87">fpi87</A>)
<DT>fp2
<DD>generate in-line 80x87 instructions (see <A HREF="#fp2">fp2</A>)
<DT>fp3
<DD>generate in-line 387 instructions (see <A HREF="#fp3">fp3</A>)
<DT>fp5
<DD>generate in-line 80x87 instructions optimized for Pentium processor (see <A HREF="#fp5">fp5</A>)
<DT>fp6
<DD>generate in-line 80x87 instructions optimized for Pentium Pro processor (see <A HREF="#fp6">fp6</A>)
<DT>fpd
<DD>enable generation of Pentium FDIV bug check code (see <A HREF="#fpd">fpd</A>)
<DT>fpr
<DD>generate 8087 code compatible with older versions of compiler (see <A HREF="#fpr">fpr</A>)
<DT>fr=&lt;file_name&gt;
<DD>set error file specification (see <A HREF="#frUEXfile_nameYV">fr[=&lt;file_name&gt;]</A>)
<DT>ft
<DD>try truncated (8.3) header file specification (see <A HREF="#ft">ft</A>)
<DT>fti
<DD>(C only) track include file opens (see <A HREF="#fti">fti</A>)
<DT>fx
<DD>do not try truncated (8.3) header file specification (see <A HREF="#fx">fx</A>)
<DT>fzh
<DD>(C++ only) do not automatically append extensions for include files (see <A HREF="#fzh">fzh</A>)
<DT>fzs
<DD>(C++ only) do not automatically append extensions for source files (see <A HREF="#fzs">fzs</A>)
<DT>g=&lt;codegroup&gt;
<DD>set code group name (see <A HREF="#gEXcodegroupY">g=&lt;codegroup&gt;</A>)
<DT>h{w,d,c}
<DD>set debug output format (Open Watcom, Dwarf, Codeview) (see <A HREF="#h_w_d_c_">h{w,d,c}</A>)
<DT>i=&lt;directory&gt;
<DD>add directory to list of include directories (see <A HREF="#iEXdirectoryY">i=&lt;directory&gt;</A>)
<DT>j
<DD>change char default from unsigned to signed (see <A HREF="#j">j</A>)
<DT>k
<DD>(C++ only) continue processing files (ignore errors) (see <A HREF="#k">k</A>)
<DT>m{f,s,m,c,l,h}
<DD>memory model - mf=flat (see <A HREF="#mf">mf</A>), ms=small (see <A HREF="#ms">ms</A>), mm=medium (see <A HREF="#mm">mm</A>),
mc=compact (see <A HREF="#mc">mc</A>), ml=large (see <A HREF="#ml">ml</A>), mh=huge (see <A HREF="#mh">mh</A>) (default is
&quot;ms&quot; for 16-bit and Netware, &quot;mf&quot; for 32-bit)
<DT>nc=&lt;name&gt;
<DD>set name of the code class (see <A HREF="#ncEXnameY">nc=&lt;name&gt;</A>)
<DT>nd=&lt;name&gt;
<DD>set name of the &quot;data&quot; segment (see <A HREF="#ndEXnameY">nd=&lt;name&gt;</A>)
<DT>nm=&lt;name&gt;
<DD>set module name different from filename (see <A HREF="#nmEXnameY">nm=&lt;name&gt;</A>)
<DT>nt=&lt;name&gt;
<DD>set name of the &quot;text&quot; segment (see <A HREF="#ntEXnameY">nt=&lt;name&gt;</A>)
<DT>o{a,b,c,d,e,f,f+,h,i,i+,k,l,l+,m,n,o,p,r,s,t,u,x,z}
<DD>control optimization (see <A HREF="#oa">oa</A>) (see <A HREF="#of">of</A>)
<DT>pil
<DD>preprocessor ignores #line directives (see <A HREF="#pil">pil</A>)
<DT>p{e,l,c,w=&lt;num&gt;}
<DD>preprocess file only, sending output to standard output; &quot;c&quot; include comments; &quot;e&quot; encrypt identifiers
(C++ only); &quot;l&quot; include #line directives; w=&lt;num&gt; wrap output lines at &lt;num&gt; columns (zero means no
wrap) (see <A HREF="#p_e_l_c_wEXnumY_">p{e,l,c,w=&lt;num&gt;}</A>)
<DT>q
<DD>operate quietly (see <A HREF="#q">q</A>)
<DT>r
<DD>save/restore segment registers (see <A HREF="#r">r</A>)
<DT>ri
<DD>return chars and shorts as ints (see <A HREF="#ri">ri</A>)
<DT>s
<DD>remove stack overflow checks (see <A HREF="#s">s</A>)
<DT>sg
<DD>generate calls to grow the stack (see <A HREF="#sg">sg</A>)
<DT>st
<DD>touch stack through SS first (see <A HREF="#st">st</A>)
<DT>t=&lt;num&gt;
<DD>(C++ only) set tab stop multiplier (see <A HREF="#tEXnumY">t=&lt;num&gt;</A>)
<DT>u&lt;name&gt;
<DD>preprocessor #undef name (see <A HREF="#uXnameY">u&lt;name&gt;</A>)
<DT>v
<DD>output function declarations to .def file (with typedef names) (see <A HREF="#v">v</A>)
<DT>vc...
<DD>(C++ only) VC++ compatibility options (see <A HREF="#vc___">vc...</A>)
<DT>w&lt;number&gt;
<DD>set warning level number (default is w1) (see <A HREF="#wXnumberY">w&lt;number&gt;</A>)
<DT>wcd=&lt;num&gt;
<DD>warning control:&nbsp; disable warning message &lt;num&gt; (see <A HREF="#wcdEXnumberY">wcd=&lt;number&gt;</A>)
<DT>wce=&lt;num&gt;
<DD>warning control:&nbsp; enable warning message &lt;num&gt; (see <A HREF="#wceEXnumberY">wce=&lt;number&gt;</A>)
<DT>we
<DD>treat all warnings as errors (see <A HREF="#we">we</A>)
<DT>wo
<DD>(C only) (16-bit only) warn about problems with overlaid code (see <A HREF="#wo">wo</A>)
<DT>wx
<DD>set warning level to maximum setting (see <A HREF="#wx">wx</A>)
<DT>x
<DD>preprocessor ignores environment variables (see <A HREF="#x">x</A>)
<DT>xd
<DD>(C++ only) disable exception handling (default) (see <A HREF="#xd">xd</A>)
<DT>xdt
<DD>(C++ only) disable exception handling (same as &quot;xd&quot;) (see <A HREF="#xdt">xdt</A>)
<DT>xds
<DD>(C++ only) disable exception handling (table-driven destructors) (see <A HREF="#xds">xds</A>)
<DT>xr
<DD>(C++ only) enable RTTI (see <A HREF="#xr">xr</A>)
<DT>xs
<DD>(C++ only) enable exception handling (see <A HREF="#xs">xs</A>)
<DT>xst
<DD>(C++ only) enable exception handling (direct calls for destruction) (see <A HREF="#xst">xst</A>)
<DT>xss
<DD>(C++ only) enable exception handling (table-driven destructors) (see <A HREF="#xss">xss</A>)
<DT>xx
<DD>ignore default directories for file search (.,../h,../c,...) (see <A HREF="#xx">xx</A>)
<DT>z{a,e}
<DD>disable/enable language extensions (default is ze) (see <A HREF="#za">za</A>) (see <A HREF="#ze">ze</A>)
<DT>zam
<DD>disable all predefined old extension macros (keyword macros, non-ISO names) (see <A HREF="#zam">zam</A>)
<DT>zat
<DD>(C++ only) disable alternative tokens (see <A HREF="#zat">zat</A>)
<DT>zc
<DD>place literal strings in code segment (see <A HREF="#zc">zc</A>)
<DT>zd{f,p}
<DD>allow DS register to &quot;float&quot; or &quot;peg&quot; it to DGROUP (default is zdp) (see <A HREF="#zd_f_p_">zd{f,p}</A>)
<DT>zdl
<DD>(32-bit only) load DS register directly from DGROUP (see <A HREF="#zdl">zdl</A>)
<DT>zev
<DD>(C only, Unix extension) enable arithmetic on void derived types (see <A HREF="#zev">zev</A>)
<DT>zf
<DD>(C++ only) let scope of for loop initialization extend beyond loop (see <A HREF="#zf">zf</A>)
<DT>zf{f,p}
<DD>allow FS register to be used (default for all but flat memory model) or not be used (default for flat memory model) (see <A HREF="#zf_f_p_">zf{f,p}</A>)
<DT>zfw
<DD>generate FWAIT instructions on 386 and later (see <A HREF="#zfw">zfw</A>)
<DT>zg
<DD>output function declarations to .def (without typedef names) (see <A HREF="#zg">zg</A>)
<DT>zg{f,p}
<DD>allow GS register to be used or not used (see <A HREF="#zg_f_p_">zg{f,p}</A>)
<DT>zk0
<DD>double-byte char support for Kanji (see <A HREF="#zk_0_1_2_l_">zk{0,1,2,l}</A>)
<DT>zk0u
<DD>translate Kanji double-byte characters to UNICODE (see <A HREF="#zk0u">zk0u</A>)
<DT>zk1
<DD>double-byte char support for Chinese/Taiwanese (see <A HREF="#zk_0_1_2_l_">zk{0,1,2,l}</A>)
<DT>zk2
<DD>double-byte char support for Korean (see <A HREF="#zk_0_1_2_l_">zk{0,1,2,l}</A>)
<DT>zkl
<DD>double-byte char support if current code page has lead bytes (see <A HREF="#zk_0_1_2_l_">zk{0,1,2,l}</A>)
<DT>zku=&lt;codepage&gt;
<DD>load UNICODE translate table for specified code page (see <A HREF="#zkuEXcodepageY">zku=&lt;codepage&gt;</A>)
<DT>zl
<DD>suppress generation of library file names and references in object file (see <A HREF="#zl">zl</A>)
<DT>zld
<DD>suppress generation of file dependency information in object file (see <A HREF="#zld">zld</A>)
<DT>zlf
<DD>add default library information to object files (see <A HREF="#zlf">zlf</A>)
<DT>zls
<DD>remove automatically inserted symbols (such as runtime library references) (see <A HREF="#zls">zls</A>)
<DT>zm
<DD>place each function in separate segment (near functions not allowed) (see <A HREF="#zm">zm</A>)
<DT>zmf
<DD>place each function in separate segment (near functions allowed) (see <A HREF="#zmf">zmf</A>)
<DT>zp[{1,2,4,8,16}]
<DD>set minimal structure packing (member alignment) (see <A HREF="#zpU_1_2_4_8_16_V">zp[{1,2,4,8,16}]</A>)
<DT>zpw
<DD>output warning when padding is added in a struct/class (see <A HREF="#zpw">zpw</A>)
<DT>zq
<DD>operate quietly (see <A HREF="#zq">zq</A>)
<DT>zri
<DD>inline floating point rounding code (see <A HREF="#zri">zri</A>)
<DT>zro
<DD>omit floating point rounding code (see <A HREF="#zro">zro</A>)
<DT>zs
<DD>syntax check only (see <A HREF="#zs">zs</A>)
<DT>zt&lt;number&gt;
<DD>set data threshold (default is zt32767) (see <A HREF="#ztXnumberY">zt&lt;number&gt;</A>)
<DT>zu
<DD>do not assume that SS contains segment of DGROUP (see <A HREF="#zu">zu</A>)
<DT>zv
<DD>(C++ only) enable virtual function removal optimization (see <A HREF="#zv">zv</A>)
<DT>zw
<DD>Microsoft Windows prologue/epilogue code sequences (see <A HREF="#zw">zw</A>)
<DT>zW
<DD>(16-bit only) Microsoft Windows optimized prologue/epilogue code sequences (see <A HREF="#zW_LoptimizedR">zW (optimized)</A>)
<DT>zWs
<DD>(16-bit only) Microsoft Windows smart callback sequences (see <A HREF="#zWs">zWs</A>)
<DT>zz
<DD>remove &quot;@size&quot; from __stdcall function names (10.0 compatible) (see <A HREF="#zz">zz</A>)
</DL>
<H2 ID="Compiler_Options_M_Summarized_By_Category"> Compiler Options - Summarized By Category </H2>
<BR>In the following sections, we present a terse summary of compiler options organized into categories.
<H3 ID="Summary__Target_Specific"> Summary:&nbsp; Target Specific </H3>
<DL>
<DT>Option:
<DD>Description:
<DT>bc
<DD>build target is a console application (see <A HREF="#bc">bc</A>)
<DT>bd
<DD>build target is a Dynamic Link Library (DLL) (see <A HREF="#bd">bd</A>)
<DT>bg
<DD>build target is a GUI application (see <A HREF="#bg">bg</A>)
<DT>bm
<DD>build target is a multi-threaded environment (see <A HREF="#bm">bm</A>)
<DT>br
<DD>build target uses DLL version of C/C++ run-time library (see <A HREF="#br">br</A>)
<DT>bt[=&lt;os&gt;]
<DD>build target for operating system &lt;os&gt; (see <A HREF="#btUEXosYV">bt[=&lt;os&gt;]</A>)
<DT>bw
<DD>build target uses default windowing support (see <A HREF="#bw">bw</A>)
<DT>of
<DD>generate traceable stack frames as needed (see <A HREF="#of">of</A>)
<DT>of+
<DD>always generate traceable stack frames (see <A HREF="#ofP">of+</A>)
<DT>sg
<DD>generate calls to grow the stack (see <A HREF="#sg">sg</A>)
<DT>st
<DD>touch stack through SS first (see <A HREF="#st">st</A>)
<DT>zw
<DD>generate code for Microsoft Windows (see <A HREF="#zw">zw</A>)
<DT>zW
<DD>(16-bit only) Microsoft Windows optimized prologue/epilogue code sequences (see <A HREF="#zW_LoptimizedR">zW (optimized)</A>)
<DT>zWs
<DD>(16-bit only) Microsoft Windows smart callback sequences (see <A HREF="#zWs">zWs</A>)
</DL>
<H3 ID="Summary__DebuggingDProfiling"> Summary:&nbsp; Debugging/Profiling </H3>
<DL>
<DT>Option:
<DD>Description:
<DT>d0
<DD>(C++ only) no debugging information (see <A HREF="#d0">d0</A>)
<DT>d1
<DD>line number debugging information (see <A HREF="#d1">d1</A>)
<DT>d1+
<DD>(C only) line number debugging information plus typing information for global symbols and local structs and arrays (see <A HREF="#d1P">d1+</A>)
<DT>d2
<DD>full symbolic debugging information (see <A HREF="#d2">d2</A>)
<DT>d2i
<DD>(C++ only) d2 and debug inlines; emit inlines as external out-of-line functions (see <A HREF="#d2i">d2i</A>)
<DT>d2s
<DD>(C++ only) d2 and debug inlines; emit inlines as static out-of-line functions (see <A HREF="#d2s">d2s</A>)
<DT>d2t
<DD>(C++ only) d2 but without type names (see <A HREF="#d2t">d2t</A>)
<DT>d3
<DD>full symbolic debugging with unreferenced type names (see <A HREF="#d3">d3</A>)
<DT>d3i
<DD>(C++ only) d3 plus debug inlines; emit inlines as external out-of-line functions (see <A HREF="#d3i">d3i</A>)
<DT>d3s
<DD>(C++ only) d3 plus debug inlines; emit inlines as static out-of-line functions (see <A HREF="#d3s">d3s</A>)
<DT>ee
<DD>call epilogue hook routine (see <A HREF="#ee">ee</A>)
<DT>en
<DD>emit routine names in the code segment (see <A HREF="#en">en</A>)
<DT>ep[&lt;number&gt;]
<DD>call prologue hook routine with number stack bytes available (see <A HREF="#epUXnumberYV">ep[&lt;number&gt;]</A>)
<DT>et
<DD>Pentium profiling (see <A HREF="#et">et</A>)
<DT>h{w,d,c}
<DD>set debug output format (Open Watcom, DWARF, Codeview) (see <A HREF="#h_w_d_c_">h{w,d,c}</A>)
<DT>s
<DD>remove stack overflow checks (see <A HREF="#s">s</A>)
</DL>
<H3 ID="Summary__Preprocessor"> Summary:&nbsp; Preprocessor </H3>
<DL>
<DT>Option:
<DD>Description:
<DT>d&lt;name&gt;[=text]
<DD>precompilation #define name [text] (see <A HREF="#dXnameYUEtextV">d&lt;name&gt;[=text]</A>)
<DT>d+
<DD>allow extended &quot;d&quot; macro definitions on command line (see <A HREF="#dP">d+</A>)
<DT>fo[=&lt;file_name&gt;]
<DD>set preprocessor output file name (see <A HREF="#foUEXfile_nameYV_LpreprocessorR">fo[=&lt;file_name&gt;] (preprocessor)</A>)
<DT>pil
<DD>preprocessor ignores #line directives (see <A HREF="#pil">pil</A>)
<DT>p{e,l,c,w=&lt;num&gt;}
<DD>preprocess file
<DL>
<DT>c
<DD>preserve comments
<DT>e
<DD>encrypt identifiers (C++ only)
<DT>l
<DD>insert #line directives
<DT>w=&lt;num&gt;
<DD>wrap output lines at &lt;num&gt; columns.&nbsp; Zero means no wrap.
</DL>
<BR>(see <A HREF="#p_e_l_c_wEXnumY_">p{e,l,c,w=&lt;num&gt;}</A>)
<DT>u&lt;name&gt;
<DD>undefine macro name (see <A HREF="#uXnameY">u&lt;name&gt;</A>)
</DL>
<H3 ID="Summary__Diagnostics"> Summary:&nbsp; Diagnostics </H3>
<DL>
<DT>Option:
<DD>Description:
<DT>e&lt;number&gt;
<DD>set error limit number (see <A HREF="#eXnumberY">e&lt;number&gt;</A>)
<DT>ef
<DD>use full path names in error messages (see <A HREF="#ef">ef</A>)
<DT>eq
<DD>do not display error messages (they are still written to a file) (see <A HREF="#eq">eq</A>)
<DT>er
<DD>(C++ only) do not recover from undefined symbol errors (see <A HREF="#er">er</A>)
<DT>ew
<DD>(C++ only) alternate error message formatting (see <A HREF="#ew">ew</A>)
<DT>q
<DD>operate quietly (see <A HREF="#q">q</A>)
<DT>t=&lt;num&gt;
<DD>set tab stop multiplier (see <A HREF="#tEXnumY">t=&lt;num&gt;</A>)
<DT>w&lt;number&gt;
<DD>set warning level number (see <A HREF="#wXnumberY">w&lt;number&gt;</A>)
<DT>wcd=&lt;num&gt;
<DD>warning control:&nbsp; disable warning message &lt;num&gt; (see <A HREF="#wcdEXnumberY">wcd=&lt;number&gt;</A>)
<DT>wce=&lt;num&gt;
<DD>warning control:&nbsp; enable warning message &lt;num&gt; (see <A HREF="#wceEXnumberY">wce=&lt;number&gt;</A>)
<DT>we
<DD>treat all warnings as errors (see <A HREF="#we">we</A>)
<DT>wx
<DD>set warning level to maximum setting (see <A HREF="#wx">wx</A>)
<DT>z{a,e}
<DD>disable/enable language extensions (see <A HREF="#za">za</A>) (see <A HREF="#ze">ze</A>)
<DT>zq
<DD>operate quietly (see <A HREF="#zq">zq</A>)
<DT>zs
<DD>syntax check only (see <A HREF="#zs">zs</A>)
</DL>
<H3 ID="Summary__SourceDOutput_Control"> Summary:&nbsp; Source/Output Control </H3>
<DL>
<DT>Option:
<DD>Description:
<DT>ad[=&lt;file_name&gt;]
<DD>generate make style auto-dependency file (see <A HREF="#adUEXfile_nameYV">ad[=&lt;file_name&gt;]</A>)
<DT>adbs
<DD>force path separators generated in make style auto-dependency file to backslashes (see <A HREF="#adbs">adbs</A>)
<DT>add[=&lt;file_name&gt;]
<DD>set source name (the first dependency) for make style auto-dependency file (see <A HREF="#addUEXfile_nameYV">add[=&lt;file_name&gt;]</A>)
<DT>adhp[=&lt;path prefix&gt;]
<DD>set default path for header dependencies which result in filename only (see <A HREF="#adhpUEXpath_nameYV">adhp[=&lt;path_name&gt;]</A>)
<DT>adfs
<DD>force path separators generated in make style auto-dependency file to forward slashes (see <A HREF="#adfs">adfs</A>)
<DT>adt[=&lt;target_name&gt;]
<DD>specify target name generated in make style auto-dependency file (see <A HREF="#adtUEXtarget_nameYV">adt[=&lt;target_name&gt;]</A>)
<DT>db
<DD>generate browsing information (see <A HREF="#db">db</A>)
<DT>ez
<DD>generate PharLap EZ-OMF object files (see <A HREF="#ez">ez</A>)
<DT>fc=&lt;file_name&gt;
<DD>(C++ only) specify file of command lines to be batch processed (see <A HREF="#fcEXfile_nameY">fc=&lt;file_name&gt;</A>)
<DT>fh[q][=&lt;file_name&gt;]
<DD>use precompiled headers (see <A HREF="#fhUqVUEXfile_nameYV">fh[q][=&lt;file_name&gt;]</A>)
<DT>fhd
<DD>store debug info for pre-compiled header once (DWARF only) (see <A HREF="#fhd">fhd</A>)
<DT>fhr
<DD>(C++ only) force compiler to read pre-compiled header (will never write) (see <A HREF="#fhr">fhr</A>)
<DT>fhw
<DD>(C++ only) force compiler to write pre-compiled header (will never read) (see <A HREF="#fhw">fhw</A>)
<DT>fhwe
<DD>(C++ only) don't include pre-compiled header warnings when &quot;we&quot; is used (see <A HREF="#fhwe">fhwe</A>)
<DT>fi=&lt;file_name&gt;
<DD>force file_name to be included (see <A HREF="#fiEXfile_nameY">fi=&lt;file_name&gt;</A>)
<DT>fo[=&lt;file_name&gt;]
<DD>set object or preprocessor output file name (see <A HREF="#foUEXfile_nameYV">fo[=&lt;file_name&gt;]</A>)
<DT>fr[=&lt;file_name&gt;]
<DD>set error file name (see <A HREF="#frUEXfile_nameYV">fr[=&lt;file_name&gt;]</A>)
<DT>ft
<DD>try truncated (8.3) header file specification (see <A HREF="#ft">ft</A>)
<DT>fti
<DD>(C only) track include file opens (see <A HREF="#fti">fti</A>)
<DT>fx
<DD>do not try truncated (8.3) header file specification (see <A HREF="#fx">fx</A>)
<DT>fzh
<DD>(C++ only) do not automatically append extensions for include files (see <A HREF="#fzh">fzh</A>)
<DT>fzs
<DD>(C++ only) do not automatically append extensions for source files (see <A HREF="#fzs">fzs</A>)
<DT>i=&lt;directory&gt;
<DD>another include directory (see <A HREF="#iEXdirectoryY">i=&lt;directory&gt;</A>)
<DT>k
<DD>continue processing files (ignore errors) (see <A HREF="#k">k</A>)
<DT>v
<DD>output function declarations to .def (see <A HREF="#v">v</A>)
<DT>x
<DD>ignore environment variables when searching for include files (see <A HREF="#x">x</A>)
<DT>xx
<DD>ignore default directories for file search (.,../h,../c,...) (see <A HREF="#xx">xx</A>)
<DT>zam
<DD>disable all predefined old extension macros (keyword macros, non-ISO names) (see <A HREF="#zam">zam</A>)
<DT>zat
<DD>(C++ only) disable alternative tokens (see <A HREF="#zat">zat</A>)
<DT>zf
<DD>(C++ only) let scope of for loop initialization extend beyond loop (see <A HREF="#zf">zf</A>)
<DT>zg
<DD>generate function prototypes using base types (see <A HREF="#zg">zg</A>)
<DT>zl
<DD>remove default library information (see <A HREF="#zl">zl</A>)
<DT>zld
<DD>remove file dependency information (see <A HREF="#zld">zld</A>)
<DT>zlf
<DD>add default library information to object files (see <A HREF="#zlf">zlf</A>)
<DT>zls
<DD>remove automatically generated symbols references (see <A HREF="#zls">zls</A>)
</DL>
<H3 ID="Summary__Code_Generation"> Summary:&nbsp; Code Generation </H3>
<DL>
<DT>Option:
<DD>Description:
<DT>ecc
<DD>set default calling convention to __cdecl (see <A HREF="#ecc">ecc</A>)
<DT>ecd
<DD>set default calling convention to __stdcall (see <A HREF="#ecd">ecd</A>)
<DT>ecf
<DD>set default calling convention to __fastcall (see <A HREF="#ecf">ecf</A>)
<DT>ecp
<DD>set default calling convention to __pascal (see <A HREF="#ecp">ecp</A>)
<DT>ecr
<DD>set default calling convention to __fortran (see <A HREF="#ecr">ecr</A>)
<DT>ecs
<DD>set default calling convention to __syscall (see <A HREF="#ecs">ecs</A>)
<DT>ecw
<DD>set default calling convention to __watcall (default) (see <A HREF="#ecw">ecw</A>)
<DT>ei
<DD>force enum base type to use at least an int (see <A HREF="#ei">ei</A>)
<DT>em
<DD>force enum base type to use minimum (see <A HREF="#em">em</A>)
<DT>j
<DD>change char default from unsigned to signed (see <A HREF="#j">j</A>)
<DT>ri
<DD>return chars and shorts as ints (see <A HREF="#ri">ri</A>)
<DT>xr
<DD>(C++ only) enable RTTI (see <A HREF="#xr">xr</A>)
<DT>zc
<DD>place literal strings in the code segment (see <A HREF="#zc">zc</A>)
<DT>zp{1,2,4,8,16}
<DD>pack structure members (see <A HREF="#zpU_1_2_4_8_16_V">zp[{1,2,4,8,16}]</A>)
<DT>zpw
<DD>output warning when padding is added in a struct/class (see <A HREF="#zpw">zpw</A>)
<DT>zt&lt;number&gt;
<DD>set data threshold (see <A HREF="#ztXnumberY">zt&lt;number&gt;</A>)
<DT>zv
<DD>(C++ only) enable virtual function removal optimization (see <A HREF="#zv">zv</A>)
</DL>
<H3 ID="Summary__80x86_Floating_Point"> Summary:&nbsp; 80x86 Floating Point </H3>
<DL>
<DT>Option:
<DD>Description:
<DT>fpc
<DD>calls to floating-point library (see <A HREF="#fpc">fpc</A>)
<DT>fpi
<DD>in-line 80x87 instructions with emulation (see <A HREF="#fpi">fpi</A>)
<DT>fpi87
<DD>in-line 80x87 instructions (see <A HREF="#fpi87">fpi87</A>)
<DT>fp2
<DD>generate floating-point for 80x87 (see <A HREF="#fp2">fp2</A>)
<DT>fp3
<DD>generate floating-point for 387 (see <A HREF="#fp3">fp3</A>)
<DT>fp5
<DD>optimize floating-point for Pentium (see <A HREF="#fp5">fp5</A>)
<DT>fp6
<DD>optimize floating-point for Pentium Pro (see <A HREF="#fp6">fp6</A>)
<DT>fpd
<DD>enable generation of Pentium FDIV bug check code (see <A HREF="#fpd">fpd</A>)
</DL>
<H3 ID="Summary__SegmentsDModules"> Summary:&nbsp; Segments/Modules </H3>
<DL>
<DT>Option:
<DD>Description:
<DT>g=&lt;codegroup&gt;
<DD>set code group name (see <A HREF="#gEXcodegroupY">g=&lt;codegroup&gt;</A>)
<DT>nc=&lt;name&gt;
<DD>set code class name (see <A HREF="#ncEXnameY">nc=&lt;name&gt;</A>)
<DT>nd=&lt;name&gt;
<DD>set data segment name (see <A HREF="#ndEXnameY">nd=&lt;name&gt;</A>)
<DT>nm=&lt;name&gt;
<DD>set module name (see <A HREF="#nmEXnameY">nm=&lt;name&gt;</A>)
<DT>nt=&lt;name&gt;
<DD>set name of text segment (see <A HREF="#ntEXnameY">nt=&lt;name&gt;</A>)
<DT>zm
<DD>place each function in separate segment (near functions not allowed) (see <A HREF="#zm">zm</A>)
<DT>zmf
<DD>(C++ only) place each function in separate segment (near functions allowed) (see <A HREF="#zmf">zmf</A>)
</DL>
<H3 ID="Summary__80x86_RunMtime_Conventions"> Summary:&nbsp; 80x86 Run-time Conventions </H3>
<DL>
<DT>Option:
<DD>Description:
<DT>0
<DD>(16-bit only) 8088 and 8086 instructions (see <A HREF="#0">0</A>)
<DT>1
<DD>(16-bit only) 188 and 186 instructions (see <A HREF="#1">1</A>)
<DT>2
<DD>(16-bit only) 286 instructions (see <A HREF="#2">2</A>)
<DT>3
<DD>(16-bit only) 386 instructions (see <A HREF="#3">3</A>)
<DT>4
<DD>(16-bit only) 486 instructions (see <A HREF="#4">4</A>)
<DT>5
<DD>(16-bit only) Pentium instructions (see <A HREF="#5">5</A>)
<DT>6
<DD>(16-bit only) Pentium Pro instructions (see <A HREF="#6">6</A>)
<DT>3r
<DD>(32-bit only) 386 register calling conventions (see <A HREF="#3_r_s_">3{r|s}</A>)
<DT>3s
<DD>(32-bit only) 386 stack calling conventions (see <A HREF="#3_r_s_">3{r|s}</A>)
<DT>4r
<DD>(32-bit only) 486 register calling conventions (see <A HREF="#4_r_s_">4{r|s}</A>)
<DT>4s
<DD>(32-bit only) 486 stack calling conventions (see <A HREF="#4_r_s_">4{r|s}</A>)
<DT>5r
<DD>(32-bit only) Pentium register calling conventions (see <A HREF="#5_r_s_">5{r|s}</A>)
<DT>5s
<DD>(32-bit only) Pentium stack calling conventions (see <A HREF="#5_r_s_">5{r|s}</A>)
<DT>6r
<DD>(32-bit only) Pentium Pro register calling conventions (see <A HREF="#6_r_s_">6{r|s}</A>)
<DT>6s
<DD>(32-bit only) Pentium Pro stack calling conventions (see <A HREF="#6_r_s_">6{r|s}</A>)
<DT>m{f,s,m,c,l,h}
<DD>memory model (Flat,Small,Medium,Compact,Large,Huge) (see <A HREF="#mf">mf</A>)
<DT>zdf
<DD>DS floats i.e.&nbsp; not fixed to DGROUP (see <A HREF="#zd_f_p_">zd{f,p}</A>)
<DT>zdp
<DD>DS is pegged to DGROUP (see <A HREF="#zd_f_p_">zd{f,p}</A>)
<DT>zdl
<DD>Load DS directly from DGROUP (see <A HREF="#zdl">zdl</A>)
<DT>zff
<DD>FS floats i.e.&nbsp; not fixed to a segment (see <A HREF="#zf_f_p_">zf{f,p}</A>)
<DT>zfp
<DD>FS is pegged to a segment (see <A HREF="#zf_f_p_">zf{f,p}</A>)
<DT>zgf
<DD>GS floats i.e.&nbsp; not fixed to a segment (see <A HREF="#zg_f_p_">zg{f,p}</A>)
<DT>zgp
<DD>GS is pegged to a segment (see <A HREF="#zg_f_p_">zg{f,p}</A>)
<DT>zri
<DD>Inline floating point rounding code (see <A HREF="#zri">zri</A>)
<DT>zro
<DD>Omit floating point rounding code (see <A HREF="#zro">zro</A>)
<DT>zu
<DD>SS != DGROUP (see <A HREF="#zu">zu</A>)
</DL>
<H3 ID="Summary__Optimizations"> Summary:&nbsp; Optimizations </H3>
<DL>
<DT>Option:
<DD>Description:
<DT>oa
<DD>relax aliasing constraints (see <A HREF="#oa">oa</A>)
<DT>ob
<DD>enable branch prediction (see <A HREF="#ob">ob</A>)
<DT>oc
<DD>disable &lt;call followed by return&gt; to &lt;jump&gt; optimization (see <A HREF="#oc">oc</A>)
<DT>od
<DD>disable all optimizations (see <A HREF="#od">od</A>)
<DT>oe[=&lt;num&gt;]
<DD>expand user functions in-line.&nbsp; &lt;num&gt; controls max size (see <A HREF="#oeEXnumY">oe=&lt;num&gt;</A>)
<DT>oh
<DD>enable repeated optimizations (longer compiles) (see <A HREF="#oh">oh</A>)
<DT>oi
<DD>expand intrinsic functions in-line (see <A HREF="#oi">oi</A>)
<DT>oi+
<DD>(C++ only) expand intrinsic functions in-line and set inline_depth to maximum (see <A HREF="#oiP">oi+</A>)
<DT>ok
<DD>enable control flow prologues and epilogues (see <A HREF="#ok">ok</A>)
<DT>ol
<DD>enable loop optimizations (see <A HREF="#ol">ol</A>)
<DT>ol+
<DD>enable loop optimizations with loop unrolling (see <A HREF="#olP">ol+</A>)
<DT>om
<DD>generate in-line 80x87 code for math functions (see <A HREF="#om">om</A>)
<DT>on
<DD>allow numerically unstable optimizations (see <A HREF="#on">on</A>)
<DT>oo
<DD>continue compilation if low on memory (see <A HREF="#oo">oo</A>)
<DT>op
<DD>generate consistent floating-point results (see <A HREF="#op">op</A>)
<DT>or
<DD>reorder instructions for best pipeline usage (see <A HREF="#or">or</A>)
<DT>os
<DD>favor code size over execution time in optimizations (see <A HREF="#os">os</A>)
<DT>ot
<DD>favor execution time over code size in optimizations (see <A HREF="#ot">ot</A>)
<DT>ou
<DD>all functions must have unique addresses (see <A HREF="#ou">ou</A>)
<DT>ox
<DD>equivalent to -obmiler -s (see <A HREF="#ox">ox</A>)
<DT>oz
<DD>NULL points to valid memory in the target environment (see <A HREF="#oz">oz</A>)
</DL>
<H3 ID="Summary__CPP_Exception_Handling"> Summary:&nbsp; C++ Exception Handling </H3>
<DL>
<DT>Option:
<DD>Description:
<DT>xd
<DD>disable exception handling (default) (see <A HREF="#xd">xd</A>)
<DT>xdt
<DD>disable exception handling (same as &quot;xd&quot;) (see <A HREF="#xdt">xdt</A>)
<DT>xds
<DD>disable exception handling (table-driven destructors) (see <A HREF="#xds">xds</A>)
<DT>xs
<DD>enable exception handling (see <A HREF="#xs">xs</A>)
<DT>xst
<DD>enable exception handling (direct calls for destruction) (see <A HREF="#xst">xst</A>)
<DT>xss
<DD>enable exception handling (table-driven destructors) (see <A HREF="#xss">xss</A>)
</DL>
<H3 ID="Summary__DoubleMByteDUnicode_Characters"> Summary:&nbsp; Double-Byte/Unicode Characters </H3>
<DL>
<DT>Option:
<DD>Description:
<DT>zk{0,1,2,l}
<DD>double-byte char support:&nbsp; 0=Kanji,1=Chinese/Taiwanese,2=Korean,l=local (see <A HREF="#zk_0_1_2_l_">zk{0,1,2,l}</A>)
<DT>zk0u
<DD>translate double-byte Kanji to UNICODE (see <A HREF="#zk0u">zk0u</A>)
<DT>zku=&lt;codepage&gt;
<DD>load UNICODE translate table for specified code page (see <A HREF="#zkuEXcodepageY">zku=&lt;codepage&gt;</A>)
</DL>
<H3 ID="Summary__Compatibility_with_Microsoft_Visual_CPP"> Summary:&nbsp; Compatibility with Microsoft Visual C++ </H3>
<DL>
<DT>Option:
<DD>Description:
<DT>vc...
<DD>VC++ compatibility options (see <A HREF="#vc___">vc...</A>)
<DT>vcap
<DD>allow alloca() or _alloca() in a parameter list
</DL>
<H3 ID="Summary__Compatibility_with_Older_Versions_of_the_80x86_Compilers"> Summary:&nbsp; Compatibility with Older Versions of the 80x86 Compilers </H3>
<DL>
<DT>Option:
<DD>Description:
<DT>r
<DD>save/restore segment registers across calls (see <A HREF="#r">r</A>)
<DT>fpr
<DD>generate backward compatible 80x87 code (see <A HREF="#fpr">fpr</A>)
<DT>zz
<DD>generate backward compatible __stdcall conventions by removing the &quot;@size&quot; from __stdcall function names (10.0 compatible)
(see <A HREF="#zz">zz</A>)
</DL>
<H2 ID="Compiler_Options_M_Full_Description"> Compiler Options - Full Description </H2>
<BR>In the following sections, we present complete descriptions of compiler options organized into categories.
<H3 ID="Target_Specific"> Target Specific </H3>
<BR>This group of options deals with characteristics of the target application; for example, simple executables versus Dynamic
Link Libraries, character-mode versus graphical user interface, single-threaded versus multi-threaded, and so on.
<H4 ID="bc"> bc </H4>
<BR>(OS/2, Win16/32 only) This option causes the compiler to emit into the object file references to the appropriate startup
code for a character-mode console application.&nbsp; The presence of<TT> LibMain/DLLMain</TT> or<TT> WinMain/wWinMain</TT>
in the source code does not influence the selection of startup code.&nbsp; Only<TT> main</TT> and<TT> wmain</TT> are significant.
<BR>If none of &quot;bc&quot;, &quot;bd&quot;, &quot;bg&quot; or &quot;bw&quot; are specified then the order of priority in
determining which combination of startup code and libraries to use are as follows.
<OL>
<LI>The presence of one of<TT> LibMain</TT> or<TT> DLLMain</TT> implies that the DLL startup code and libraries should be
used.
<LI>The presence of<TT> WinMain</TT> or<TT> wWinMain</TT> implies that the GUI startup code and libraries should be used.
<LI>The presence of<TT> main</TT> or<TT> wmain</TT> implies that the default startup code and libraries should be used.
</OL>
<BR>If both a wide and non-wide version of an entry point are specified, the &quot;wide&quot; entry point will be used.&nbsp;
Thus<TT> wWinMain</TT> is called when both<TT> WinMain</TT> and<TT> wWinMain</TT> are present.&nbsp; Similarly,<TT> wmain</TT>
is called when both<TT> main</TT> and<TT> wmain</TT> are present (and<TT> WinMain/wWinMain</TT> are not present).&nbsp; By
default, if both<TT> wmain</TT> and<TT> WinMain</TT> are included in the source code, then the startup code will attempt to
call<TT> wWinMain</TT> (since both &quot;wide&quot; and &quot;windowed&quot; entry points were included).
<H4 ID="bd"> bd </H4>
<BR>(OS/2, Win16/32 only) This option causes the compiler to emit into the object file references to the run-time DLL startup
code (reference to the<TT> __DLLstart_</TT> symbol) and, if required, special versions of the run-time libraries that support
DLLs.&nbsp; The presence of<TT> main/wmain</TT> or<TT> WinMain/wWinMain</TT> in the source code does not influence the selection
of startup code.&nbsp; Only<TT> LibMain</TT> and<TT> DLLMain</TT> are significant (see <A HREF="#bc">bc</A>).&nbsp; If you
are building a DLL with statically linked C runtime (the default), it is recommended that you compile at least one of its
object files with the &quot;bd&quot; switch to ensure that the DLL's C runtime is properly initialized.&nbsp; The macro<TT>
__SW_BD</TT> will be predefined if &quot;bd&quot; is selected.
<H4 ID="bg"> bg </H4>
<BR>(OS/2, Win16/32 only) This option causes the compiler to emit into the object file references to the appropriate startup
code for a windowed (GUI) application.&nbsp; The presence of<TT> LibMain/DLLMain</TT> or<TT> main/wmain</TT> in the source
code does not influence the selection of startup code.&nbsp; Only<TT> WinMain</TT> and<TT> wWinMain</TT> are significant (see
<A HREF="#bc">bc</A>).
<H4 ID="bm"> bm </H4>
<BR>(Netware, OS/2, Win32 only) This option causes the compiler to emit into the object file references to the appropriate
multi-threaded library name(s).&nbsp; The macros<TT> _MT</TT> and<TT> __SW_BM</TT> will be predefined if &quot;bm&quot; is
selected.
<H4 ID="br"> br </H4>
<BR>(OS/2, Win32 only) This option causes the compiler to emit into the object file references to the run-time DLL library
name(s).&nbsp; The run-time DLL libraries are special subsets of the Open Watcom C/C++ run-time libraries that are available
as DLLs.&nbsp; When you use this option with an OS/2 application, you must also specify the &quot;CASEEXACT&quot; option to
the Open Watcom Linker.&nbsp; The macros<TT> _DLL</TT> and<TT> __SW_BR</TT> will be predefined if &quot;br&quot; is selected.
<H4 ID="btUEXosYV"> bt[=&lt;os&gt;] </H4>
<BR>This option causes the compiler to define the &quot;build&quot; target.&nbsp; This option is used for cross-development
work.&nbsp; It prevents the compiler from defining the default build target (which is based on the host system the compiler
is running on).&nbsp; The default build targets are:
<DL>
<DT>DOS
<DD>when the host operating system is DOS,
<DT>OS2
<DD>when the host operating system is OS/2,
<DT>NT
<DD>when the host operating system is Windows NT (including Windows 95),
<DT>QNX
<DD>when the host operating system is QNX.&nbsp; or
<DT>LINUX
<DD>when the host operating system is Linux.
</DL>
<BR>It also prevents the compiler from defining the default target macro.&nbsp; Instead the compiler defines a macro consisting
of the string &quot;&lt;os&gt;&quot; converted to uppercase and prefixed and suffixed with two underscores.&nbsp; The default
target macros are described in the section entitled <A HREF="#Open_Watcom_CDCPP_Predefined_Macros">Open Watcom C/C++ Predefined Macros</A>.
<BR><BR>For example, specifying the option:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; bt=foo</TT>
<BR><BR>would cause the compiler to define the macro
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; __FOO__</TT>
<BR><BR>and prevent it from defining<TT> MSDOS</TT> ,<TT> _DOS</TT> and<TT> __DOS__</TT> if the compiler was being run under
DOS,<TT> __OS2__</TT> if using the OS/2 hosted compiler,<TT> __NT__</TT> if using the Windows NT or Windows 95 hosted compiler,<TT>
__QNX__</TT> and<TT> __UNIX__</TT> if using the QNX hosted version.&nbsp; or<TT> __LINUX__</TT> and<TT> __UNIX__</TT> if using
the Linux hosted version.&nbsp; Any string consisting of letters, digits, and the underscore character may be used for the
target name.
<BR><BR>The compiler will also construct an environment variable called<B> &lt;os&gt;_INCLUDE</B> and see if it has been defined.
&nbsp;If the environment variable is defined then each directory listed in it is searched (in the order that they were specified).
&nbsp;For example, the environment variable<B> WINDOWS_INCLUDE</B> will be searched if<B> bt=WINDOWS</B> option was specified.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; set windows_include=\watcom\h\win</TT>
<BR><BR>Include file processing is described in the section entitled <A HREF="#Open_Watcom_CDCPP__include_File_Processing">Open Watcom C/C++ #include File Processing</A>.
<BR><BR>Several target names are recognized by the compiler and perform additional operations.
<DL>
<DT>Target name
<DD>Additional operation
<DT>DOS
<DD>Defines the macros<TT> _DOS</TT> and<TT> MSDOS</TT> .
<DT>WINDOWS
<DD>Same as specifying one of the &quot;zw&quot; options.&nbsp; Defines the macros<TT> _WINDOWS</TT> (16-bit only) and<TT> __WINDOWS_386__</TT>
(32-bit only).
<DT>NETWARE
<DD>(32-bit only) Causes the compiler to use stack-based calling conventions.&nbsp; Also defines the macro<TT> __NETWARE_386__</TT>
.
<DT>QNX
<DD>Defines the macro<TT> __UNIX__</TT> .
<DT>LINUX
<DD>Defines the macro<TT> __UNIX__</TT> .
</DL>
<BR>Specifying &quot;bt&quot; with no target name following restores the default target name.
<H4 ID="bw"> bw </H4>
<BR>(Win16 only) This option causes the compiler to import a special symbol so that the default windowing library code is
linked into your application.&nbsp; The presence of<TT> LibMain/DLLMain</TT> in the source code does not influence the selection
of startup code.&nbsp; Only<TT> main, wmain, WinMain</TT> and<TT> wWinMain</TT> are significant (see <A HREF="#bc">bc</A>).
&nbsp;The macro<TT> __SW_BW</TT> will be predefined if &quot;bw&quot; is selected.
<H4 ID="of"> of </H4>
<BR>This option selects the generation of traceable stack frames for those functions that contain calls or require stack frame
setup.
<BR>(16-bit only) To use Open Watcom's &quot;Dynamic Overlay Manager&quot; (DOS only), you must compile all modules using
one of the &quot;of&quot; or &quot;of+&quot; options (&quot;of&quot; is sufficient).
<BR><BR>For near functions, the following function prologue sequence is generated.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; (16-bit only)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push BP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp; BP,SP</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; (32-bit only)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push EBP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp; EBP,ESP</TT>
<BR><BR>For far functions, the following function prologue sequence is generated.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; (16-bit only)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inc&nbsp; BP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push BP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp; BP,SP</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; (32-bit only)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inc&nbsp; EBP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push EBP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp; EBP,ESP</TT>
<BR><BR>The BP/EBP value on the stack will be even or odd depending on the code model.
<BR><BR>For 16-bit DOS systems, the Dynamic Overlay Manager uses this information to determine if the return address on the
stack is a short address (16-bit offset) or long address (32-bit segment:offset).
<BR><BR>Do not use this option for 16-bit Windows applications.&nbsp; It will alter the code sequence generated for &quot;_export&quot;
functions.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;</TT><B>compiler_name</B><TT> toaster -of</TT>
<BR><BR>The macro<TT> __SW_OF</TT> will be predefined if &quot;of&quot; is selected.
<H4 ID="ofP"> of+ </H4>
<BR>This option selects the generation of traceable stack frames for all functions regardless of whether they contain calls
or require stack frame setup.&nbsp; This option is intended for developers of embedded systems (ROM-based applications).
<BR>To use Open Watcom's &quot;Dynamic Overlay Manager&quot; (16-bit DOS only), you must compile all modules using one of
the &quot;of&quot; or &quot;of+&quot; options (&quot;of&quot; is sufficient).
<BR><BR>For near functions, the following function prologue sequence is generated.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; (16-bit only)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push BP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp; BP,SP</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; (32-bit only)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push EBP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp; EBP,ESP</TT>
<BR><BR>For far functions, the following function prologue sequence is generated.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; (16-bit only)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inc&nbsp; BP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push BP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp; BP,SP</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; (32-bit only)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inc&nbsp; EBP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push EBP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp; EBP,ESP</TT>
<BR><BR>The BP/EBP value on the stack will be even or odd depending on the code model.
<BR><BR>For 16-bit DOS systems, the Dynamic Overlay Manager uses this information to determine if the return address on the
stack is a short address (16-bit offset) or long address (32-bit segment:offset).
<BR><BR>Do not use this option for 16-bit Windows applications.&nbsp; It will alter the code sequence generated for &quot;_export&quot;
functions.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;</TT><B>compiler_name</B><TT> toaster -of+</TT>
<H4 ID="sg"> sg </H4>
<BR>This option is useful for 32-bit OS/2 and Win32 multi-threaded applications.&nbsp; It requests the code generator to emit
a run-time call at the start of any function that has more than 4K bytes of automatic variables (variables located on the
stack).
<BR>Under 32-bit OS/2, the stack is grown automatically in 4K pages for any threads, other than the primary thread, using
the stack &quot;guard page&quot; mechanism.&nbsp; The stack consists of in-use committed pages topped off with a special guard
page.&nbsp; A memory reference into the 4K guard page causes the operating system to grow the stack by one 4K page and to
add a new 4K guard page.&nbsp; This works fine when there is less than 4K of automatic variables in a function.&nbsp; When
there is more than 4K of automatic data, the stack must be grown in an orderly fashion, 4K bytes at a time, until the stack
has grown sufficiently to accommodate all the automatic variable storage requirements.&nbsp; Hence the requirement for a stack-growing
run-time routine.&nbsp; The stack-growing run-time routine is called<TT> __GRO.</TT>
<BR><BR>The &quot;stack=&quot; linker option specifies how much stack is available and committed for the primary thread when
an executable starts.&nbsp; The stack size parameter to<TT> _beginthread()</TT> specifies how much stack is available for
a child thread.&nbsp; The child thread starts with just 4k of stack committed.&nbsp; The stack will not grow to be bigger
than the size specified by the stack size parameter.
<BR><BR>Under 32-bit Windows (Win32), the stack is grown automatically in 4K pages for all threads using a similar stack &quot;guard
page&quot; mechanism.&nbsp; The stack consists of in-use committed pages topped off with a special guard page.&nbsp; The techniques
for growing the stack in an orderly fashion are the same as that described above for OS/2.
<BR><BR>The &quot;stack=&quot; linker option specifies how much stack is available for the primary thread when an executable
starts.&nbsp; The &quot;commit stack=&quot; linker directive specifies how much of that stack is committed when the executable
starts.&nbsp; If no &quot;commit stack=&quot; directive is used, it defaults to the same value as the stack size.&nbsp; The
stack size parameter to<TT> _beginthread()</TT> specifies how much stack is committed for a child thread.&nbsp; If the size
is set to zero, the size of the primary thread stack is used for the child thread stack.&nbsp; When the child thread executes,
the stack space is not otherwise restricted.
<BR><BR>The macro<TT> __SW_SG</TT> will be predefined if &quot;sg&quot; is selected.
<H4 ID="st"> st </H4>
<BR>This option causes the code generator to ensure that the first reference to the stack in a function is to the stack &quot;bottom&quot;
using the SS register.&nbsp; If the memory for this part of the stack is not mapped to the task, a memory fault will occur
involving the SS register.&nbsp; This permits an operating system to allocate additional stack space to the faulting task.
<BR>Suppose that a function requires 100 bytes of stack space.&nbsp; The code generator usually emits an instruction sequence
to reduce the stack pointer by the required number of bytes of stack space, thereby establishing a new stack bottom.&nbsp;
When the &quot;st&quot; option is specified, the code generator will ensure that the first reference to the stack is to a
memory location with the lowest address.&nbsp; If a memory fault occurs, the operating system can determine that it was a
stack reference (since the SS register is involved) and also how much additional stack space is required.
<BR><BR>See the description of the &quot;sg&quot; option for a more general solution to the stack allocation problem.&nbsp;
The macro<TT> __SW_ST</TT> will be predefined if &quot;st&quot; is selected.
<H4 ID="zw"> zw </H4>
<BR>(16-bit only) This option causes the compiler to generate the prologue/epilogue code sequences required for Microsoft
Windows applications.&nbsp; The following &quot;fat&quot; prologue/epilogue sequence is generated for any functions declared
to be &quot;far _export&quot; or &quot;far pascal&quot;.
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; far pascal func(...)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; far _export func(...)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; far _export pascal func(...)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push DS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp; AX</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nop</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inc&nbsp; BP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push BP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp; BP,SP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push DS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp; DS,AX</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop DS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop BP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dec BP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; retf n</TT>
<BR><BR>The macro<TT> __WINDOWS__</TT> will be predefined if &quot;zw&quot; is selected.
<BR><BR>(32-bit only) This option causes the compiler to generate any special code sequences required for 32-bit Microsoft
Windows applications.&nbsp; The macro<TT> __WINDOWS__</TT> and<TT> __WINDOWS_386__</TT> will be predefined if &quot;zw&quot;
is selected.
<H4 ID="zW_LoptimizedR"> zW (optimized) </H4>
<BR>(16-bit only) This option is similar to &quot;zw&quot; but causes the compiler to generate more efficient prologue/epilogue
code sequences in some cases.&nbsp; This option may be used for Microsoft Windows applications code other than user callback
functions.&nbsp; Any functions declared as &quot;far _export&quot; will be compiled with the &quot;fat&quot; prologue/epilogue
code sequence described under the &quot;zw&quot; option.
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; far _export func(...)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; far _export pascal func(...)</TT>
<BR><BR>The following &quot;skinny&quot; prologue/epilogue sequence is generated for functions that are not declared to be
&quot;far _export&quot;.&nbsp; 
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; far pascal func(...)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; far func(...)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inc&nbsp; BP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push BP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp; BP,SP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop BP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dec BP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; retf n</TT>
<BR><BR>The macro<TT> __WINDOWS__</TT> will be predefined if &quot;zW&quot; is selected.
<H4 ID="zWs"> zWs </H4>
<BR>(16-bit only) This option is similar to &quot;zW&quot; but causes the compiler to generate &quot;smart callbacks&quot;.
&nbsp;This option may be used for Microsoft Windows user callback functions in executables only.&nbsp; It is not permitted
for DLLs.&nbsp; Normally, a callback function cannot be called directly.&nbsp; You must use MakeProcInstance to obtain a function
pointer with which to call the callback function.
<BR>If you specify &quot;zWs&quot; then you do not need to use MakeProcInstance in order to call your own callback functions.
&nbsp;Any functions declared as &quot;far _export&quot; will be compiled with the &quot;smart&quot; prologue code sequence
described here.
<BR><BR>The following example shows the usual prologue code sequence that is generated when the &quot;zWs&quot; option is
NOT used.
<BR><BR><B>Example:</B>
<BR><BR><B>&nbsp;&nbsp;&nbsp;&nbsp; compiler_name</B><TT> winapp -mc -bt=windows -d1</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; short FAR PASCAL __export Function1( short var1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
long varlong,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
short var2 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0000&nbsp; 1e&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FUNCTION1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; ds</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0001&nbsp; 58&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;&nbsp;&nbsp; ax</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0002&nbsp; 90&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nop</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0003&nbsp; 45&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inc&nbsp;&nbsp;&nbsp;&nbsp; bp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0004&nbsp; 55&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; bp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0005&nbsp; 89 e5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; bp,sp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0007&nbsp; 1e&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; ds</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0008&nbsp; 8e d8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ds,ax</TT>
<BR><BR>The following example shows the &quot;smart&quot; prologue code sequence that is generated when the &quot;zWs&quot;
option is used.&nbsp; The assumption here is that the SS register contains the address of DGROUP.
<BR><BR><B>Example:</B>
<BR><BR><B>&nbsp;&nbsp;&nbsp;&nbsp; compiler_name</B><TT> winapp -mc -bt=windows -d1 -zWs</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; short FAR PASCAL __export Function1( short var1,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
long varlong,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
short var2 )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0000&nbsp; 8c d0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FUNCTION1&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax,ss</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0002&nbsp; 45&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inc&nbsp;&nbsp;&nbsp;&nbsp; bp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0003&nbsp; 55&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; bp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0004&nbsp; 89 e5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; bp,sp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0006&nbsp; 1e&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; ds</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0007&nbsp; 8e d8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ds,ax</TT>
<H3 ID="DebuggingDProfiling"> Debugging/Profiling </H3>
<BR>This group of options deals with all the forms of debugging information that can be included in an object file.&nbsp;
Support for profiling of Pentium code is also described.
<H4 ID="d0"> d0 </H4>
<BR>(C++ only) No debugging information is included in the object file.
<H4 ID="d1"> d1 </H4>
<BR>Line number debugging information is included in the object file.&nbsp; This option provides additional information to
the Open Watcom Debugger (at the expense of larger object files and executable files).&nbsp; Line numbers are handy when debugging
your application with the Open Watcom Debugger at the source code level.&nbsp; Code speed is not affected by this option.
&nbsp;To avoid recompiling, the Open Watcom Strip Utility can be used to remove debugging information from the executable
image.
<H4 ID="d1P"> d1+ </H4>
<BR>(C only) Line number debugging information plus typing information for global symbols and local structs and arrays is
included in the object file.&nbsp; Although global symbol information can be made available to the Open Watcom Debugger through
a Open Watcom Linker option, typing information for global symbols and local structs and arrays must be requested when the
source file is compiled.&nbsp; This option provides additional information to the Open Watcom Debugger (at the expense of
larger object files and executable files).&nbsp; Code speed is not affected by this option.&nbsp; To avoid recompiling, the
Open Watcom Strip Utility can be used to remove debugging information from the executable image.
<H4 ID="d2"> d2 </H4>
<BR>In addition to line number information, local symbol and data type information is included in the object file.&nbsp; Although
global symbol information can be made available to the Open Watcom Debugger through a Open Watcom Linker option, local symbol
and typing information must be requested when the source file is compiled.&nbsp; This option provides additional information
to the Open Watcom Debugger (at the expense of larger object files and executable files).
<BR>By default, the compiler will select the &quot;od&quot; level of optimization if &quot;d2&quot; is specified (see the
description of the &quot;od&quot; option).&nbsp; Starting with version 11.0, the compiler now expands functions in-line where
appropriate.&nbsp; This means that symbolic information for the in-lined function will not be available.
<BR><BR>The use of this option will make the debugging chore somewhat easier at the expense of code speed and size.&nbsp;
To create production code, you should recompile without this option.
<H4 ID="d2i"> d2i </H4>
<BR>(C++ only) This option is identical to &quot;d2&quot; but does not permit in-lining of functions.&nbsp; Functions are
emitted as external out-of-line functions.&nbsp; This option can result in larger object and/or executable files than with
&quot;d2&quot; (we are discussing both &quot;code&quot; and &quot;file&quot; size here).
<H4 ID="d2s"> d2s </H4>
<BR>(C++ only) This option is identical to &quot;d2&quot; but does not permit in-lining of functions.&nbsp; Functions are
emitted as static out-of-line functions.&nbsp; This option can result in larger object and/or executable files than with &quot;d2&quot;
or &quot;d2i&quot; (we are discussing both &quot;code&quot; and &quot;file&quot; size here).&nbsp; Link times are faster than
&quot;d2i&quot; (fewer segment relocations) but executables are slightly larger.
<H4 ID="d2t"> d2t </H4>
<BR>(C++ only) This option is identical to &quot;d2&quot; but does not include type name debugging information.&nbsp; This
option can result in smaller object and/or executable files (we are discussing &quot;file&quot; size here).
<H4 ID="d3"> d3 </H4>
<BR>This option is identical to &quot;d2&quot; but also includes symbolic debugging information for unreferenced type names.
&nbsp;Note that this can result in very large object and/or executable files when header files like<TT> WINDOWS.H</TT> or<TT>
OS2.H</TT> are included.
<H4 ID="d3i"> d3i </H4>
<BR>(C++ only) This option is identical to &quot;d3&quot; but does not permit in-lining of functions.&nbsp; Functions are
emitted as external out-of-line functions.&nbsp; This option can result in larger object and/or executable files than with
&quot;d3&quot; (we are discussing both &quot;code&quot; and &quot;file&quot; size here).
<H4 ID="d3s"> d3s </H4>
<BR>(C++ only) This option is identical to &quot;d3&quot; but does not permit in-lining of functions.&nbsp; Functions are
emitted as static out-of-line functions.&nbsp; This option can result in larger object and/or executable files than with &quot;d3&quot;
or &quot;d3i&quot; (we are discussing both &quot;code&quot; and &quot;file&quot; size here).&nbsp; Link times are faster than
&quot;d3i&quot; (fewer segment relocations) but executables are slightly larger.
<H4 ID="ee"> ee </H4>
<BR>This option causes the compiler to generate a call to<TT> __EPI</TT> in the epilogue sequence at the end of every function.
&nbsp;This user-written routine can be used to collect/record profiling information.&nbsp; The macro<TT> __SW_EE</TT> will
be predefined if &quot;ee&quot; is selected.
<H4 ID="en"> en </H4>
<BR>The compiler will emit the function name into the object code as a string of characters just before the function prologue
sequence is generated.&nbsp; The string is terminated by a byte count of the number of characters in the string.
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; void Toaster( int arg )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; db&nbsp;&nbsp;
&nbsp;&nbsp; &quot;Toaster&quot;, 7</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public&nbsp; Toaster</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Toaster label&nbsp;&nbsp; byte</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret</TT>
<BR><BR>This option is intended for developers of embedded systems (ROM-based applications).&nbsp; It may also be used in
conjunction with the &quot;ep&quot; option for special user-written profiling applications.&nbsp; The macro<TT> __SW_EN</TT>
will be predefined if &quot;en&quot; is selected.
<H4 ID="epUXnumberYV"> ep[&lt;number&gt;] </H4>
<BR>This option causes the compiler to generate a call to a user-written<TT> __PRO</TT> routine in the prologue sequence at
the start of every function.&nbsp; This routine can be used to collect/record profiling information.&nbsp; The optional argument<B>
&lt;number&gt;</B> can be used to cause the compiler to allocate that many bytes on the stack as a place for<TT> __PRO</TT>
to store information.&nbsp; The macro<TT> __SW_EP</TT> will be predefined if &quot;ep&quot; is selected.
<H4 ID="et"> et </H4>
<BR>(Pentium only) This option causes the compiler to generate code into the prolog of each function to count exactly how
much time is spent within that function, in clock ticks.&nbsp; This option is valid only for Pentium compatible processors
(i.e., the instructions inserted into the code do not work on 486 or earlier architectures).&nbsp; The Pentium &quot;rdtsc&quot;
opcode is used to obtain the instruction cycle count.
<BR>At the end of the execution of the program, a file will be written to the same location as the executable, except with
a &quot;.prf&quot; extension.&nbsp; The contents of the file will look like this:
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1903894223&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp; main</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1785232334&nbsp;&nbsp;&nbsp;
1376153&nbsp; StageA</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1882249150&nbsp;&nbsp;&nbsp;
&nbsp; 13293&nbsp; StageB</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1830895850&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; 2380&nbsp; StageC</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 225730118&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; 99&nbsp; StageD</TT>
<BR><BR>The first column is the total number of clock ticks spent inside of the function during the execution of the program,
the second column is the number of times it was called and the third column is the individual function name.&nbsp; The total
number of clock ticks includes time spent within functions called from this function.
<BR><BR>The overhead of the profiling can be somewhat intrusive, especially for small leaf functions (i.e., it may skew your
results somewhat).
<H4 ID="h_w_d_c_"> h{w,d,c} </H4>
<BR>The type of debugging information that is to be included in the object file is one of &quot;Open Watcom&quot;, &quot;DWARF&quot;
or &quot;Codeview&quot;.&nbsp; The default is &quot;DWARF&quot;.
<BR>If you wish to use the Microsoft Codeview debugger, then choose the &quot;hc&quot; option (this option causes Codeview
Level 4 information to be generated).&nbsp; It will be necessary to run the Microsoft Debugging Information Compactor, CVPACK,
on the executable once the linker has created it.&nbsp; For information on requesting the linker to automatically run CVPACK,
see the section entitled &quot;OPTION CVPACK&quot; in the<B><I> Open Watcom Linker User's Guide.</I></B>&nbsp; Alternatively,
you can run CVPACK from the command line.
<BR><BR>When linking the application, you must also choose the appropriate Open Watcom Linker DEBUG directive.&nbsp; See the<B><I>
Open Watcom Linker User's Guide</I></B> for more information.
<H4 ID="s"> s </H4>
<BR>Stack overflow checking is omitted from the generated code.&nbsp; By default, the compiler will emit code at the beginning
of every function that checks for the &quot;stack overflow&quot; condition.&nbsp; This option can be used to disable this
feature.&nbsp; The macro<TT> __SW_S</TT> will be predefined if &quot;s&quot; is selected.
<H3 ID="Preprocessor"> Preprocessor </H3>
<BR>This group of options deals with the compiler preprocessor.
<H4 ID="dXnameYUEtextV"> d&lt;name&gt;[=text] </H4>
<BR>This option can be used to define a preprocessor macro from the command line.&nbsp; If<B> =text</B> is not specified,
then 1 is assumed.&nbsp; In other words, specifying<TT> -dDBGON</TT> is equivalent to specifying<TT> -dDBGON=1</TT> on the
command line.
<BR>If<B> =text</B> is specified, then this option is equivalent to including the following line in your source code.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define name text</TT>
<BR><BR>Consider the following example.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; d_MODDATE=&quot;87.05.04&quot;</TT>
<BR><BR>The above example is equivalent to a line in the source file containing:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define _MODDATE &quot;87.05.04&quot;</TT>
<H4 ID="dP"> d+ </H4>
<BR>The syntax of any &quot;d&quot; option which follows on the command line is extended to include C/C++ tokens as part of
&quot;text&quot;.&nbsp; The token string is terminated by a space character.&nbsp; This permits more complex syntax than is
normally allowed.
<BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -d+ -d_radx=x*3.1415926/180</TT>
<BR><BR>This is equivalent to specifying the following in the source code.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define _radx x*3.1415926/180</TT>
<BR><BR>Open Watcom C++ extends this feature by allowing parameterized macros.&nbsp; When a parameter list is specified, the
&quot;=&quot; character must not be specified.&nbsp; It also permits immediate definition of the macro as shown in the second
line of the example.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -d+ -d_rad(x)x*3.1415926/180</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -d+_rad(x)x*3.1415926/180</TT>
<BR><BR>This is equivalent to specifying the following in the source code.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define _rad(x) x*3.1415926/180</TT>
<H4 ID="foUEXfile_nameYV_LpreprocessorR"> fo[=&lt;file_name&gt;] (preprocessor) </H4>
<BR>The &quot;fo&quot; option is used with any form of the &quot;p&quot; (preprocessor) option to name the output file drive,
path, file name and extension.&nbsp; If the output file name is not specified, it is constructed from the source file name.
&nbsp;If the output file extension is not specified, it is &quot;.i&quot; by default.
<BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;</TT><B>compiler_name</B><TT> report -p -fo=d:\proj\prep\</TT>
<BR><BR>A trailing &quot;\&quot; must be specified for directory names.&nbsp; If, for example, the option was specified as<TT>
fo=d:\proj\prep</TT> then the output file would be called<TT> d:\proj\prep.i</TT>.&nbsp; A default filename extension must
be preceded by a period (&quot;.&quot;).
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;</TT><B>compiler_name</B><TT> report -p -fo=d:\proj\prep\.cpr</TT>
<H4 ID="pil"> pil </H4>
<BR>By default, #line directives embedded in source files are processed and will be used as a basis for file name and line
number information in error messages, __FILE__ and __LINE__ symbols, etc.&nbsp; The &quot;pil&quot; option causes the preprocessor
to ignore #line directives and refer to actual file names and line numbers.
<H4 ID="p_e_l_c_wEXnumY_"> p{e,l,c,w=&lt;num&gt;} </H4>
<BR>The input file is preprocessed and, by default, is written to the standard output file.&nbsp; The &quot;fo&quot; option
may be used to redirect the output to a file with default extension &quot;.i&quot;.
<BR>Specify &quot;pc&quot; if you wish to include the original source comments in the Open Watcom C/C++ preprocessor output
file.
<BR><BR>(C++ Only) Specify &quot;pe&quot; if you wish to encrypt the original identifiers when they are written to the Open
Watcom C/C++ preprocessor output file.
<BR><BR>Specify &quot;pl&quot; if you wish to include<TT> #line</TT> directives.
<BR><BR>Specify &quot;pcl&quot; or &quot;plc&quot; if you wish both source comments and #line directives.
<BR><BR>Use the &quot;w=&lt;num&gt;&quot; suffix if you wish to wish output lines to wrap at &lt;num&gt; columns.&nbsp; Zero
means no wrap.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;</TT><B>compiler_name</B><TT> report -pcelw=80</TT>
<BR><BR>The input file is preprocessed only.&nbsp; When only &quot;p&quot; is specified, source comments and #line directives
are not included.&nbsp; You must request these using the &quot;c&quot; and &quot;l&quot; suffixes.&nbsp; When the output of
the preprocessor is fed into the compiler, the<TT> #line</TT> directive enables the compiler to issue diagnostics in terms
of line numbers of the original source file.
<BR><BR>The options which are supported when the Open Watcom C/C++ preprocessor is requested are:&nbsp; &quot;d&quot;, &quot;fi&quot;,
&quot;fo&quot;, &quot;i&quot;, &quot;m?&quot;, and &quot;u&quot;.
<H4 ID="uXnameY"> u&lt;name&gt; </H4>
<BR>The &quot;u&quot; option may be used to turn off the definition of a predefined macro.&nbsp; If no name is specified then
all predefined macros are undefined.
<BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;</TT><B>compiler_name</B><TT> report -uM_I386</TT>
<H3 ID="Diagnostics"> Diagnostics </H3>
<BR>This group of options deals with the control of compiler diagnostics.
<H4 ID="eXnumberY"> e&lt;number&gt; </H4>
<BR>The compiler will stop compilation after reaching<B> &lt;number&gt;</B> errors.&nbsp; By default, the compiler will stop
compilation after 20 errors.
<H4 ID="ef"> ef </H4>
<BR>This option causes the compiler to display full path names for files in error messages.
<H4 ID="eq"> eq </H4>
<BR>This option causes the compiler to not display error messages on the console; however, they are still written to a file
(see <A HREF="#frUEXfile_nameYV">fr[=&lt;file_name&gt;]</A>).
<H4 ID="er"> er </H4>
<BR>(C++ only) This option causes the C++ compiler to not recover from undefined symbol errors.&nbsp; By default, the compiler
recovers from &quot;undefined symbol&quot; errors by injecting a special entry into the symbol table that prevents further
issuance of diagnostics relating to the use of the same name.&nbsp; Specify the &quot;er&quot; option if you want all uses
of the symbol to be diagnosed.
<BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void foo( S *p ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p-&gt;m = 1; // member 'm' has not been declared in 'S'</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void bar( S *p ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p-&gt;m = 2; // no error unless &quot;er&quot; is specified</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H4 ID="ew"> ew </H4>
<BR>(C++ only) This option causes the C++ compiler to generate equivalent but less verbose diagnostic messages.
<H4 ID="q"> q </H4>
<BR>This option is equivalent to the &quot;zq&quot; option (see <A HREF="#zq">zq</A>).
<H4 ID="tEXnumY"> t=&lt;num&gt; </H4>
<BR>(C++ only) The &quot;t&quot; option is used to set the tab stop interval.&nbsp; By default, the compiler assumes a tab
stop occurs at multiples of 8 (1+n x 8 = 1, 9, 17, ...&nbsp; for n=0, 1, 2, ...).&nbsp; When the compiler reports a line number
and column number in a diagnostic message, the column number has been adjusted for intervening tabs.&nbsp; If the default
tab stop setting for your text editor is not a multiple of 8, then you should use this option.
<BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;</TT><B>compiler_name</B><TT> report -t=4</TT>
<H4 ID="wXnumberY"> w&lt;number&gt; </H4>
<BR>The compiler will issue only warning type messages of severity<B> &lt;number&gt;</B> or below.&nbsp; Type 1 warning messages
are the most severe while type 3 warning messages are the least severe.&nbsp; Specify &quot;w0&quot; to prevent warning messages
from being issued.&nbsp; Specify &quot;wx&quot; to obtain all warning messages.
<H4 ID="wcdEXnumberY"> wcd=&lt;number&gt; </H4>
<BR>The compiler will not issue the warning message indicated by<B> &lt;number&gt;.</B>
<H4 ID="wceEXnumberY"> wce=&lt;number&gt; </H4>
<BR>The compiler will issue the warning message indicated by<B> &lt;number&gt;</B> despite any pragmas that may have disabled
it.
<H4 ID="we"> we </H4>
<BR>By default, the compiler will continue to create an object file when there are warnings produced.&nbsp; This option can
be used to treat all warnings as errors, thereby preventing the compiler from creating an object file if there are warnings
found within a module.
<H4 ID="wo"> wo </H4>
<BR>(C only) (16-bit only) This option tells the compiler to emit warnings for things that will cause problems when compiling
code for use in overlays.
<H4 ID="wx"> wx </H4>
<BR>This option sets the warning level to its maximum setting.
<H4 ID="za"> za </H4>
<BR>This option helps to ensure that the module to be compiled conforms to the ISO/ANSI C or C++ programming language specification
(depending on the compiler which is selected).&nbsp; The macro<TT> NO_EXT_KEYS</TT> (no extended keywords) will be predefined
if &quot;za&quot; is selected.&nbsp; The &quot;ou&quot; option will be enabled (see <A HREF="#ou">ou</A>).&nbsp; This option
also suppress all predefined macros which name is not ISO/ANSI C/C++ standard compliant.&nbsp; See also the description of
the &quot;ze&quot; option.
<BR>When using the C compiler, there is an exception to the enforcement of the ISO C standard programming language specification.
&nbsp;The use of C++ style comments (// comment) are not diagnosed.
<H4 ID="ze"> ze </H4>
<BR>The &quot;ze&quot; option (default) enables the use of the following compiler extensions:
<OL>
<LI>The requirement for at least one external definition per module is relaxed.
<LI>When using the C compiler, some forgiveable pointer type mismatches become warnings instead of errors.
<LI>In-line math functions are allowed (note that<B> errno</B> will not be set by in-line functions).
<LI>When using the C compiler, anonymous structs/unions are allowed (this is always permitted in C++).
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int a;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; union {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; b;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float alt_b;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int c;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; } x;</TT>
<BR><BR>In the above example, &quot;x.b&quot; is a valid reference to the &quot;b&quot; field.
<LI>For C only, ISO function prototype scope rules are relaxed to allow the following program to compile without any errors.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void foo( struct a *__p );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct a {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int b;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int c;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void bar( void )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct a x;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foo( &amp;x );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>According to a strict interpretation of the ISO C standard, the function prototype introduces a new scope which is
terminated at the semicolon (;).&nbsp; The effect of this is that the structure tag &quot;a&quot; in the function &quot;foo&quot;
is not the same structure tag &quot;a&quot; defined after the prototype.&nbsp; A diagnostic must be issued for a conforming
ISO C implementation.
<LI>A trailing comma (,) is allowed after the last constant in an enum declaration.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; enum colour { RED, GREEN, BLUE, };</TT>
<LI>The ISO requirement that all enums have a base type of<B> int</B> is relaxed.&nbsp; The motivation for this extension
is conservation of storage.&nbsp; Many enums can be represented by integral types that are smaller in size than an<B> int.</B>
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; enum colour { RED, GREEN, BLUE, };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void foo( void )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enum colour x;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = RED;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>In the example, &quot;x&quot; can be stored in an<B> unsigned char</B> because its values span the range 0 to 2.
<LI>The ISO requirement that the base type of a bitfield be<B> int</B> or<B> unsigned</B> is relaxed.&nbsp; This allows a
programmer to allocate bitfields from smaller units of storage than an<B> int</B> (e.g.,<B> unsigned char</B>).
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char a : 1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char b : 1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char c : 1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; } x;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned a : 1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned b : 1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned c : 1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; } y;</TT>
<BR><BR>In the above example, the size of &quot;x&quot; is the same size as an<B> unsigned char</B> whereas the size of &quot;y&quot;
is the same size as an<B> unsigned int.</B>
<LI>Enable all predefined macros which name is not ISO/ANSI C/C++ compliant.&nbsp; The following macros are defined.&nbsp;

<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _near, near</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _far, far, SOMDLINK (16-bit)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _huge, huge</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _based</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _segment</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _segname</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _self</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _cdecl, cdecl, SOMLINK (16-bit)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _pascal, pascal</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _fastcall</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _fortran, fortran</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _inline</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _interrupt, interrupt</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _export</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _loadds</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _saveregs</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _stdcall</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _syscall, SOMLINK (32-bit), SOMDLINK (32-bit)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _far16</TT>
</OL>
<BR>See also the description of the &quot;za&quot; option.
<H4 ID="zq"> zq </H4>
<BR>The &quot;quiet mode&quot; option causes the informational messages displayed by the compiler to be suppressed.&nbsp;
Normally, messages are displayed identifying the compiler and summarizing the number of lines compiled.&nbsp; As well, a dot
is displayed every few seconds while the code generator is active, to indicate that the compiler is still working.&nbsp; These
messages are all suppressed by the &quot;quiet mode&quot; option.&nbsp; Error and warning messages are not suppressed.
<H4 ID="zs"> zs </H4>
<BR>The compiler will check the source code only and omit the generation of object code.&nbsp; Syntax checking, type checking,
and so on are performed as usual.
<H3 ID="SourceDOutput_Control"> Source/Output Control </H3>
<BR>This group of options deals with control over the input files and output files that the compiler processes and/or creates.
<H4 ID="adUEXfile_nameYV"> ad[=&lt;file_name&gt;] </H4>
<BR>This option enables generation of automatic dependency infomation in makefile format, as a list of targets and their dependents.
&nbsp;If the name of the automatic dependency file is not specified, it is constructed from the source file name.&nbsp; If
the dependency extension is not specified, it is &quot;.d&quot; by default.
<BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;</TT><B>compiler_name</B><TT> report -ad=d:\proj\obj\</TT>
<BR><BR>A trailing &quot;\&quot; must be specified for directory names.&nbsp; If, for example, the option was specified as<TT>
fo=d:\proj\obj</TT> then the dependency file will be called<TT> d:\proj\obj.d</TT>.
<BR><BR>A default filename extension must be preceded by a period (&quot;.&quot;).
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;</TT><B>compiler_name</B><TT> report -ad=d:\proj\obj\.dep</TT>
<BR><BR>The content of the generated file has the following format:
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &lt;targetname&gt;:&lt;input source file&gt; &lt;included header files...&gt;</TT>
<BR><BR>Note that the header files listed in the dependency file normally do not include the standard library headers.
<H4 ID="adbs"> adbs </H4>
<BR>When generating make style automatic dependency files, this option forces all path separators (&quot;/&quot; or &quot;\&quot;)
to be a backslash (&quot;\&quot;).&nbsp; Certain usage may result in mixed path separators; this options helps generating
automatic dependency information in a format appropriate for the make tool used.
<H4 ID="addUEXfile_nameYV"> add[=&lt;file_name&gt;] </H4>
<BR>Set the first dependency name in a make style automatic dependency file.&nbsp; By default, the name of the source file
to be compiled is used.&nbsp; (see <A HREF="#adUEXfile_nameYV">ad[=&lt;file_name&gt;]</A>)
<H4 ID="adhpUEXpath_nameYV"> adhp[=&lt;path_name&gt;] </H4>
<BR>When including a file with &quot;&quot; delimiters, the resulting filename in make style automatic dependency files will
have no path.&nbsp; This option allows such files to be given a path; said path may be relative.&nbsp; The path_name argument
is directly prepended to the filename, therefore a trailing path separator must be specified.
<BR>This issue only affects headers found in the current directory, that is, the directory current at the time of compilation.
&nbsp;If a header is located in an including file's directory, it will automatically receive a path.
<BR><BR>This option is useful in situations where the current directory at the time when the automatic dependency information
is evaluated is not the same as the current directory at the time of compilation (i.e., when the automatic dependency information
was generated).
<H4 ID="adfs"> adfs </H4>
<BR>When generating make style automatic dependency files, this option forces all path separators (&quot;/&quot; or &quot;\&quot;)
to be a forward slash (&quot;/&quot;).&nbsp; Certain usage may result in mixed path separators; this options helps generating
automatic dependency information in a format appropriate for the make tool used.
<H4 ID="adtUEXtarget_nameYV"> adt[=&lt;target_name&gt;] </H4>
<BR>This option enables generation of automatic dependency infomation in the form of a makefile.&nbsp; The target in the makefile
can be specified.&nbsp; If the automatic dependency target is not specified through this option, it is constructed from the
source file name.&nbsp; If the target extension is not specified, it is &quot;.obj&quot; by default.
<BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;</TT><B>compiler_name</B><TT> report -adt=d:\proj\obj\</TT>
<BR><BR>A trailing &quot;\&quot; must be specified for directory names.&nbsp; If, for example, the option was specified as<TT>
fo=d:\proj\obj</TT> then the dependency file would be called<TT> d:\proj\obj.obj</TT>.
<BR><BR>A default filename extension must be preceded by a period (&quot;.&quot;).
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;</TT><B>compiler_name</B><TT> report -adt=d:\proj\obj\.dep</TT>
<BR><BR>The generated file has the following contents:
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &lt;targetname&gt;:&lt;input source file&gt; &lt;included header files...&gt;</TT>
<BR><BR>Note that the header files listed in the dependency file normally do not include the standard library headers.
<H4 ID="db"> db </H4>
<BR>Use this option to generate browsing information.&nbsp; The browsing information is recorded in a file whose name is constructed
from the source file name and the extension &quot;.mbr&quot;.
<H4 ID="ez"> ez </H4>
<BR>(32-bit only) The compiler will generate an object file in Phar Lap Easy OMF-386 (object module format) instead of the
default Microsoft OMF.&nbsp; The macro<TT> __SW_EZ</TT> will be predefined if &quot;ez&quot; is selected.
<H4 ID="fcEXfile_nameY"> fc=&lt;file_name&gt; </H4>
<BR>(C++ only) The specified &quot;batch&quot; file contains a list of command lines to be processed.&nbsp; This enables the
processing of a number of source files together with options for each file with one single invocation of the compiler.&nbsp;
Only one &quot;fc&quot; option is allowed and no source file names are permitted on the command line.
<BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [batch.txt]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; main&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -onatx -zp4</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; part1 part2 -onatx -zp4 -d1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; part3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -onatx -zp4 -d2</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;</TT><B>compiler_name</B><TT> -fc=\watcom\h\batch.txt</TT>
<BR><BR>Each line in the file is treated stand-alone.&nbsp; In other words, the options from one line do not carry over to
another line.&nbsp; However, any options specified on the command line or the associated compiler environment variable will
carry over to the individual command lines in the batch file.&nbsp; When the compiler diagnoses errors in a source file, processing
of subsequent command lines is halted unless the &quot;k&quot; option was specified (see <A HREF="#k">k</A>).
<H4 ID="fhUqVUEXfile_nameYV"> fh[q][=&lt;file_name&gt;] </H4>
<BR>The compiler will generate/use a precompiled header for the first header file referenced by<TT> #include</TT> in the source
file.&nbsp; See the chapter entitled <A HREF="#Precompiled_Headers">Precompiled Headers</A> for more information.
<H4 ID="fhd"> fhd </H4>
<BR>The compiler will store debug info for the pre-compiled header once (DWARF only).&nbsp; See the chapter entitled <A HREF="#Precompiled_Headers">Precompiled Headers</A>
for more information.
<H4 ID="fhr"> fhr </H4>
<BR>(C++ only) This option will force the compiler to read the pre-compiled header if it appears to be up-to-date; otherwise,
it will read the header files included by the source code.&nbsp; It will never write the pre-compiled header (even when it
is out-of-date).&nbsp; See the chapter entitled <A HREF="#Precompiled_Headers">Precompiled Headers</A> for more information.
<H4 ID="fhw"> fhw </H4>
<BR>(C++ only) This option will force the compiler to write the pre-compiled header (even when it appears to be up-to-date).
&nbsp;See the chapter entitled <A HREF="#Precompiled_Headers">Precompiled Headers</A> for more information.
<H4 ID="fhwe"> fhwe </H4>
<BR>(C++ only) This option will ensure that pre-compiled header warnings are not counted as errors when the &quot;we&quot;
(treat warnings as errors) option is specified.
<H4 ID="fiEXfile_nameY"> fi=&lt;file_name&gt; </H4>
<BR>The specified file is included as if a
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &quot;&lt;file_name&gt;&quot;</TT>
<BR><BR>directive were placed at the start of the source file.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;</TT><B>compiler_name</B><TT> report -fi=\watcom\h\stdarg.h</TT>
<H4 ID="foUEXfile_nameYV"> fo[=&lt;file_name&gt;] </H4>
<BR>When generating an object file, the &quot;fo&quot; option may be used to name the object file drive, path, file name and
extension.&nbsp; If the object file name is not specified, it is constructed from the source file name.&nbsp; If the object
file extension is not specified, it is &quot;.obj&quot; by default.
<BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;</TT><B>compiler_name</B><TT> report -fo=d:\proj\obj\</TT>
<BR><BR>A trailing &quot;\&quot; must be specified for directory names.&nbsp; If, for example, the option was specified as<TT>
fo=d:\proj\obj</TT> then the object file would be called<TT> d:\proj\obj.obj</TT>.
<BR><BR>A default filename extension must be preceded by a period (&quot;.&quot;).
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;</TT><B>compiler_name</B><TT> report -fo=d:\proj\obj\.dbo</TT>
<H4 ID="frUEXfile_nameYV"> fr[=&lt;file_name&gt;] </H4>
<BR>The &quot;fr&quot; option is used to name the error file drive, path, file name and extension.&nbsp; If the error file
name is not specified, it is constructed from the source file name.&nbsp; If the output file extension is not specified, it
is &quot;.err&quot; by default.&nbsp; If no part of the name is specified, then no error file is produced (i.e., -fr disables
production of an error file).
<BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;</TT><B>compiler_name</B><TT> report -fr=d:\proj\errs\</TT>
<BR><BR>A trailing &quot;\&quot; must be specified for directory names.&nbsp; If, for example, the option was specified as<TT>
fr=d:\proj\errs</TT> then the output file would be called<TT> d:\proj\errs.err</TT>.&nbsp; A default filename extension must
be preceded by a period (&quot;.&quot;).
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;</TT><B>compiler_name</B><TT> report -fr=d:\proj\errs\.erf</TT>
<H4 ID="ft"> ft </H4>
<BR>If the compiler cannot open a header file whose file name is longer than 8 letters or whose file extension is longer than
3 letters, it will truncate the name at 8 letters and the extension at 3 letters and try to open a file with the shortened
name.&nbsp; This is the default behaviour for the compiler.
<BR>For example, if the compiler cannot open the header file called<TT> strstream.h,</TT> it will attempt to open a header
file called<TT> strstrea.h.</TT>
<H4 ID="fti"> fti </H4>
<BR>(C only) Whenever a file is open as a result of<TT> #include</TT> directive processing, an informational message is printed.
&nbsp;The message contains the file name and line number identifying where the<TT> #include</TT> directive was located.
<H4 ID="fx"> fx </H4>
<BR>This option can be used to disable the truncated header filename processing that the compiler does by default (see &quot;ft&quot;
above).
<H4 ID="fzh"> fzh </H4>
<BR>(C++ only) This option can be used to stop the compiler from automatically adding extensions to include files.&nbsp; The
default behaviour of the compiler is to search for the specified file, then to try known extensions if the file specifier
does not have an extension.&nbsp; Thus, #include &lt;string&gt; could be matched by 'string', 'string.h' or 'string.hpp' (see
&quot;fzs&quot; below).&nbsp; The macro<TT> __SW_FZH</TT> will be defined when this switch is used.
<H4 ID="fzs"> fzs </H4>
<BR>(C++ only) This option can be used to stop the compiler from automatically adding extensions to source files.&nbsp; The
default behaviour of the compiler is to search for the specified file, then to try known extensions if the file specifier
does not have an extension.&nbsp; Thus, 'src_file' could be matched by 'src_file', 'src_file.cpp' or 'src_file.cc' (see &quot;fzh&quot;
above).&nbsp; The macro<TT> __SW_FZS</TT> will be defined when this switch is used.
<H4 ID="iEXdirectoryY"> i=&lt;directory&gt; </H4>
<BR>where &quot;&lt;directory&gt;&quot; takes the form
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [d:]path;[d:]path...</TT>
<BR><BR>The specified paths are added to the list of directories in which the compiler will search for &quot;include&quot;
files.&nbsp; See the section entitled <A HREF="#Open_Watcom_CDCPP__include_File_Processing">Open Watcom C/C++ #include File Processing</A>
for information on directory searching.
<H4 ID="k"> k </H4>
<BR>(C++ only) This option instructs the compiler to continue processing subsequent source files after an error has been diagnosed
in the current source file.&nbsp; See the option <A HREF="#fcEXfile_nameY">fc=&lt;file_name&gt;</A> for information on compiling
multiple source files.
<H4 ID="v"> v </H4>
<BR>Open Watcom C will output function declarations to a file with the same filename as the C source file but with extension
&quot;.def&quot;.&nbsp; The &quot;definitions&quot; file may be used as an &quot;include&quot; file when compiling other modules
in order to take advantage of the compiler's function and argument type checking.
<H4 ID="x"> x </H4>
<BR>The compiler ignores the<B> INCLUDE</B> and<B> &lt;os&gt;_INCLUDE</B> environment variables, if they exist, when searching
for include files.&nbsp; See the section entitled <A HREF="#Open_Watcom_CDCPP__include_File_Processing">Open Watcom C/C++ #include File Processing</A>
for information on directory searching.
<H4 ID="xx"> xx </H4>
<BR>The compiler behaviour for file search changes following way:
<UL>
<LI>current directory &quot;.&quot; is ignored when searching for include files
<LI>adjacent<TT> ..\h</TT> directory is ignored when searching for include files
<LI>don't do recursive search for parent directories when searching for include files
<LI>adjacent<TT> ..\c</TT> directory is ignored when searching for source file
</UL>
<BR>See the section entitled <A HREF="#Open_Watcom_CDCPP__include_File_Processing">Open Watcom C/C++ #include File Processing</A>
for information on directory searching.
<H4 ID="zam"> zam </H4>
<BR>Open Watcom define many extension macros for compatibility with old MS C compiler (far, _far, near, _near, cdecl, _cdecl,
etc.).&nbsp; For details see Open Watcom compilers predefined macros.&nbsp; These macros use names which are not ISO C/C++
compliant.&nbsp; The option disables all these predefined macros.
<H4 ID="zat"> zat </H4>
<BR>ISO C++ defines a number of alternative tokens that can be used instead of certain traditional tokens.&nbsp; For example
&quot;and&quot; instead of &quot;&amp;&amp;&quot;, &quot;or&quot; instead of &quot;||&quot;, etc.&nbsp; See section 2.5 of
the ISO C++ 98 standard for the complete list of such tokens.&nbsp; The &quot;zat&quot; option disables support for these
tokens so that the names &quot;and&quot;, &quot;or&quot;, etc are no longer reserved.
<H4 ID="zf"> zf </H4>
<BR>Starting with Open Watcom 1.3, the scope of a variable declared in the initialization expression of a for loop header
is by default limited to the body of the loop.&nbsp; This is in accordance with the ISO C++ standard.&nbsp; The &quot;zf&quot;
option causes the compiler to revert to the behavior it had before Open Watcom 1.3.&nbsp; In particular, it causes the scope
of variables declared in the initialization expression of a for loop header to extend beyond the loop.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;iostream&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void f()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( int i = 0; i &lt; 10; ++i ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; i &lt;&lt; &quot;\n&quot;;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; &quot;Value of i at loop termination: &quot; &lt;&lt; i &lt;&lt;
&quot;\n&quot;;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The above code will not compile with Open Watcom 1.3 or later because the variable &quot;i&quot; is out of scope in
the last output statement.&nbsp; The &quot;zf&quot; option will allow such code to compile by extending the scope of &quot;i&quot;
beyond the loop.
<H4 ID="zg"> zg </H4>
<BR>The &quot;zg&quot; option is similar to the &quot;v&quot; option except that function declarations will be output to the
&quot;DEF&quot; file using base types (i.e., typedefs are reduced to their base type).
<BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef unsigned int UINT;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; UINT f( UINT x )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( x + 1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>If you use the &quot;v&quot; option, the output will be:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern UINT f(UINT );</TT>
<BR><BR>If you use the &quot;zg&quot; option, the output will be:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern unsigned int f(unsigned int );</TT>
<H4 ID="zl"> zl </H4>
<BR>By default, the compiler places in the object file the names of the C libraries that correspond to the memory model and
floating-point options that were selected.&nbsp; The Open Watcom Linker uses these library names to select the libraries required
to link the application.&nbsp; If you use the &quot;zl&quot; option, the library names will not be included in the generated
object file.
<BR>The compiler may generate external references for library code that conveniently cause the linker to link in different
code.&nbsp; One such case is:&nbsp; if you have any functions that pass or return floating-point values (i.e., float or double),
the compiler will insert an external reference that will cause the floating-point formatting routines to be included in the
executable.&nbsp; The &quot;zl&quot; option will disable these external references.
<BR><BR>Use this option when you wish to create a library of object modules which do not contain Open Watcom C/C++ library
name references.
<H4 ID="zld"> zld </H4>
<BR>By default, the compiler places in the object file the names and time stamps of all the files referenced by the source
file.&nbsp; This file dependency information can then be used by WMAKE to determine that this file needs to be recompiled
if any of the referenced files has been modified since the object file was created.&nbsp; This option causes the compiler
to not emit this information into the object file.
<H4 ID="zlf"> zlf </H4>
<BR>The &quot;zlf&quot; option tells the compilers to emit references for all default library information into the compiled
object file.&nbsp; See also the options &quot;zl&quot;, &quot;zld&quot; and &quot;zls&quot;.
<H4 ID="zls"> zls </H4>
<BR>The &quot;zls&quot; option tells the compilers to remove automatically inserted symbols.&nbsp; These symbols are usually
used to force symbol references to be fixed up from the run-time libraries.&nbsp; An example would be the symbol __DLLstart_,
that is inserted into any object file that has a DllMain() function defined within its source file.
<H3 ID="Code_Generation"> Code Generation </H3>
<BR>This group of options deals with controlling some aspects of the code that is generated by the compiler.
<H4 ID="ecc"> ecc </H4>
<BR>set default calling convention to __cdecl
<H4 ID="ecd"> ecd </H4>
<BR>set default calling convention to __stdcall
<H4 ID="ecf"> ecf </H4>
<BR>set default calling convention to __fastcall
<H4 ID="ecp"> ecp </H4>
<BR>set default calling convention to __pascal
<H4 ID="ecr"> ecr </H4>
<BR>set default calling convention to __fortran
<H4 ID="ecs"> ecs </H4>
<BR>set default calling convention to __syscall
<H4 ID="ecw"> ecw </H4>
<BR>set default calling convention to __watcall (default)
<H4 ID="ei"> ei </H4>
<BR>This option can be used to force the compiler to allocate at least an &quot;int&quot; for all enumerated types.&nbsp;
The macro<TT> __SW_EI</TT> will be predefined if &quot;ei&quot; is selected.
<H4 ID="em"> em </H4>
<BR>This option can be used to force the compiler to allocate the smallest storage unit required to hold all possible values
given for an enumerated list.&nbsp; This option is the default for the x86 architecture.&nbsp; The macro<TT> __SW_EM</TT>
will be predefined if &quot;em&quot; is selected.
<H4 ID="j"> j </H4>
<BR>The default<TT> char</TT> type is changed from an unsigned to a signed quantity.&nbsp; The macros<TT> __CHAR_SIGNED__</TT>
and<TT> __SW_J</TT> will be predefined if &quot;j&quot; is selected.
<H4 ID="ri"> ri </H4>
<BR>Functions declared to return integral types such as chars and shorts are promoted to returning ints.&nbsp; This allows
non-ISO-conforming source code which does not properly declare the return types of functions to work properly.&nbsp; The use
of this option should be avoided.
<H4 ID="xr"> xr </H4>
<BR>The &quot;xr&quot; option is used to to enable the use of the C++ feature called Run-Time Type Information (RTTI).&nbsp;
RTTI can only be used with classes that have virtual functions declared.&nbsp; This restriction implies that if you enable
RTTI, the amount of storage used for a class in memory does not change.&nbsp; The RTTI information is added to the virtual
function information block so there will be an increase in the executable size if you choose to enable RTTI.&nbsp; There is
no execution penalty at all unless you use the dynamic_cast&lt;&gt; feature in which case, you should be aware that the operation
requires a lookup operation in order to perform the conversion properly.&nbsp; You can mix and match modules compiled with
and without &quot;xr&quot;, with the caveat that dynamic_cast&lt;&gt; and typeid() may not function (return NULL or throw
an exception) if used on a class instance that was not compiled with the &quot;xr&quot; option.
<H4 ID="zc"> zc </H4>
<BR>The &quot;zc&quot; option causes the code generator to place literal strings and<B> const</B> items in the code segment.
<BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern const int cvar = 1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int var = 2;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; const int ctable[ 5 ] = { 1, 2, 3, 4, 5 };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char *birds[ 3 ] = { &quot;robin&quot;, &quot;finch&quot;, &quot;wren&quot; };</TT>
<BR><BR>In the above example,<TT> cvar</TT> and<TT> ctable</TT> and the strings<TT> &quot;robin&quot;, &quot;finch&quot;,</TT>
etc.&nbsp; are placed in the code segment.&nbsp; This option is supported in large data or flat memory models only, or if
the item is explicitly &quot;far&quot;.&nbsp; The macro<TT> __SW_ZC</TT> will be predefined if &quot;zc&quot; is selected.
<H4 ID="zpU_1_2_4_8_16_V"> zp[{1,2,4,8,16}] </H4>
<BR>The &quot;zp&quot; option allows you to specify the alignment of members in a structure.&nbsp; The default is &quot;zp2&quot;
for the 16-bit compiler and &quot;zp8&quot; for 32-bit compiler.&nbsp; The alignment of structure members is described in
the following table.&nbsp; If the size of the member is 1, 2, 4, 8 or 16, the alignment is given for each of the &quot;zp&quot;
options.&nbsp; If the member of the structure is an array or structure, the alignment is described by the row &quot;x&quot;.
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; zp1&nbsp;&nbsp;&nbsp;&nbsp; zp2&nbsp;&nbsp;&nbsp;&nbsp; zp4&nbsp;&nbsp;&nbsp;&nbsp; zp8&nbsp;&nbsp;
&nbsp; zp16</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; sizeof(member)&nbsp; \---------------------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;
&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;
&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;
&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;
&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;
&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;
&nbsp;aligned to largest member</TT>
<BR><BR>An alignment of 0 means no alignment, 2 means word boundary, 4 means doubleword boundary, etc.
<BR><BR>Note that packed structures are padded to ensure that consecutive occurrences of the same structure in memory are
aligned appropriately.&nbsp; This is illustrated when the following example is compiled with &quot;zp4&quot;.&nbsp; The amount
of padding is determined as follows.&nbsp; If the largest member of structure &quot;s&quot; is 1 byte then &quot;s&quot; is
not aligned.&nbsp; If the largest member of structure &quot;s&quot; is 2 bytes then &quot;s&quot; is aligned according to
row 2.&nbsp; If the largest member of structure &quot;s&quot; is 4 bytes then &quot;s&quot; is aligned according to row 4.
&nbsp;If the largest member of structure &quot;s&quot; is 8 bytes then &quot;s&quot; is aligned according to row 8.&nbsp;
At present, there are no scalar objects that can have a size of 16 bytes.&nbsp; If the largest member of structure &quot;s&quot;
is an array or structure then &quot;s&quot; is aligned according to row &quot;x&quot;.&nbsp; Padding is the inclusion of slack
bytes at the end of a structure in order to guarantee the alignment of consecutive occurrences of the same structure in memory.
<BR><BR>To understand why structure member alignment may be important, consider the following example.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stddef.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef struct memo_el {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
date[9];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct memo_el *prev,*next;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ref_number;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
sex;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; } memo;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main( )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Offset of %s is %d\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;date&quot;,
offsetof( memo, date ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Offset of %s is %d\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;prev&quot;,
offsetof( memo, prev ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Offset of %s is %d\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;next&quot;,
offsetof( memo, next ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Offset of %s is %d\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;ref_number&quot;,
offsetof( memo, ref_number ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Offset of %s is %d\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;sex&quot;,
offsetof( memo, sex ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Size of %s is %d\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;memo&quot;,
sizeof( memo ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Number of padding bytes is %d\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sizeof( memo )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - (offsetof( memo,
sex ) + sizeof( char )) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>In the above example, the default alignment &quot;zp8&quot; will cause the pointer and integer items to be aligned
on even addresses although the array &quot;date&quot; is 9 bytes in length.&nbsp; The items are 2-byte aligned when sizeof(item)
is 2 and 4-byte aligned when sizeof(item) is 4.
<BR><BR>On computer systems that have a 16-bit (or 32-bit) bus, improved performance can be obtained when pointer, integer
and floating-point items are aligned on an even boundary.&nbsp; This could be done by careful rearrangement of the fields
of the structure or it can be forced by use of the &quot;zp&quot; option.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 16-bit output when compiled zp1:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Offset of date is 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Offset of prev is 9</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Offset of next is 11</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Offset of ref_number is 13</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Offset of sex is 15</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Size of memo is 16</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Number of padding bytes is 0</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 16-bit output when compiled zp4:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Offset of date is 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Offset of prev is 10</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Offset of next is 12</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Offset of ref_number is 14</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Offset of sex is 16</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Size of memo is 18</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Number of padding bytes is 1</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 32-bit output when compiled zp1:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Offset of date is 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Offset of prev is 9</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Offset of next is 13</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Offset of ref_number is 17</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Offset of sex is 21</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Size of memo is 22</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Number of padding bytes is 0</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 32-bit output when compiled zp4:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Offset of date is 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Offset of prev is 12</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Offset of next is 16</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Offset of ref_number is 20</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Offset of sex is 24</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Size of memo is 28</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Number of padding bytes is 3</TT>
<H4 ID="zpw"> zpw </H4>
<BR>The compiler will output a warning message whenever padding is added to a struct/class for alignment purposes.
<H4 ID="ztXnumberY"> zt&lt;number&gt; </H4>
<BR>The &quot;data threshold&quot; option is used to set the maximum size for data objects to be included in the default data
segment.&nbsp; This option can be used with the compact, large, and huge (16-bit) memory models only.&nbsp; These are memory
models where there can be more than one data segment.&nbsp; Normally, all data objects whose size is less than or equal to
the threshold value are placed in the default data segment &quot;_DATA&quot; unless they are specifically declared to be<TT>
far</TT> items.&nbsp; When there is a large amount of static data, it is often useful to set the data threshold size so that
all objects larger than this size are placed in another (far) data segment.&nbsp; For example, the option &quot;zt100&quot;
causes all data objects larger than 100 bytes in size to be implicitly declared as<TT> far</TT> and grouped in other data
segments.
<BR>The default data threshold value is 32767.&nbsp; Thus, by default, all objects greater than 32767 bytes in size are implicitly
declared as<TT> far</TT> and will be placed in other data segments.&nbsp; If the &quot;zt&quot; option is specified without
a size, the data threshold value is 256.&nbsp; The largest value that can be specified is 32767 (a larger value will result
in 256 being selected).
<BR><BR>If the &quot;zt&quot; option is used to compile any module in a program, then you must compile all the other modules
in the program with the same option (and value).
<BR><BR>Care must be exercised when declaring the size of objects in different modules.&nbsp; Consider the following declarations
in two different C files.&nbsp; Suppose we define an array in one module as follows:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int Array[100] = { 0 };</TT>
<BR><BR>and, suppose we reference the same array in another module as follows:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int Array[10];</TT>
<BR><BR>Assuming that these modules were compiled with the option &quot;zt100&quot;, we would have a problem.&nbsp; In the
first module, the array would be placed in another segment since<TT> Array[100]</TT> is bigger than the data threshold.&nbsp;
In the second module, the array would be placed in the default data segment since<TT> Array[10]</TT> is smaller than the data
threshold.&nbsp; The extra code required to reference the object in another data segment would not be generated.
<BR><BR>Note that this problem can also occur even when the &quot;zt&quot; option is not used (i.e., for objects greater than
32767 bytes in size).&nbsp; There are two solutions to this problem:&nbsp; (1) be consistent when declaring an object's size,
or, (2) do not specify the size in data reference declarations.
<H4 ID="zv"> zv </H4>
<BR>(C++ only) Enable virtual function removal optimization.
<H3 ID="80x86_Floating_Point"> 80x86 Floating Point </H3>
<BR>This group of options deals with control over the type of floating-point instructions that the compiler generates.&nbsp;
There are two basic types - floating-point calls (FPC) or floating-point instructions (FPI).&nbsp; They are selectable through
the use of one of the compiler options described below.&nbsp; You may wish to use the following list when deciding which option
best suits your requirements.&nbsp; Here is a summary of advantages/disadvantages to both.
<DL>
<DT>FPC
<DD>
<OL>
<LI>not IEEE floating-point
<LI>not tailorable to processor
<LI>uses coprocessor if present; simulates otherwise
<LI>32-bit/64-bit accuracy
<LI>runs somewhat faster if coprocessor present
<LI>faster emulation (fewer bits of accuracy)
<LI>leaner &quot;math&quot; library
<LI>fatter application code (calls to library rather than in-line instructions)
<LI>application cannot trap floating-point exceptions
<LI>ideal for ROM applications
</OL>
<DT>FPI, FPI87
<DD>
<OL>
<LI>IEEE floating-point
<LI>tailorable to processor (see fp2, fp3, fp5, fp6)
<LI>uses coprocessor if present; emulates IEEE otherwise
<LI>up to 80-bit accuracy
<LI>runs &quot;full-tilt&quot; if coprocessor present
<LI>slower emulation (more bits of accuracy)
<LI>fatter &quot;math&quot; library
<LI>leaner application code (in-line instructions)
<LI>application can trap floating-point exceptions
<LI>ideal for general-purpose applications
</OL>
</DL>
<BR>To see the difference in the type of code generated, consider the following small example.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;time.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clock_t&nbsp; cstart, cend;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cstart = clock();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cend = clock();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%4.2f seconds to calculate\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((float)cend - cstart)
/ CLOCKS_PER_SEC );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The following 32-bit code is generated by the Open Watcom C compiler (wcc386) using the &quot;fpc&quot; option.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; main_&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; ebx</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; edx</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call&nbsp;&nbsp;&nbsp; clock_</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; edx,eax</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call&nbsp;&nbsp;&nbsp; clock_</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call&nbsp;&nbsp;&nbsp; __U4FS&nbsp; ; unsigned
4 to floating single</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ebx,eax</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; eax,edx</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call&nbsp;&nbsp;&nbsp; __U4FS&nbsp; ; unsigned
4 to floating single</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; edx,eax</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; eax,ebx</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call&nbsp;&nbsp;&nbsp; __FSS&nbsp;&nbsp;
; floating single subtract</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; edx,3c23d70aH</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call&nbsp;&nbsp;&nbsp; __FSM&nbsp;&nbsp;
; floating single multiply</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call&nbsp;&nbsp;&nbsp; __FSFD&nbsp; ; floating
single to floating double</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; edx</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; eax</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; offset L1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call&nbsp;&nbsp;&nbsp; printf_</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add&nbsp;&nbsp;&nbsp;&nbsp; esp,0000000cH</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;&nbsp;&nbsp; edx</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;&nbsp;&nbsp; ebx</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret</TT>
<BR><BR>The following 32-bit code is generated by the Open Watcom C compiler (wcc386) using the &quot;fpi&quot; option.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; main_&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; ebx</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; edx</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sub&nbsp;&nbsp;&nbsp;&nbsp; esp,00000010H</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call&nbsp;&nbsp;&nbsp; clock_</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; edx,eax</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call&nbsp;&nbsp;&nbsp; clock_</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xor&nbsp;&nbsp;&nbsp;&nbsp; ebx,ebx</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; [esp],eax</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; +4H[esp],ebx</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; +8H[esp],edx</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; +0cH[esp],ebx</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fild&nbsp;&nbsp;&nbsp; qword ptr [esp]&nbsp;
&nbsp;&nbsp; ; integer to double</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fild&nbsp;&nbsp;&nbsp; qword ptr +8H[esp]
&nbsp;; integer to double</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fsubp&nbsp;&nbsp; st(1),st&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; subtract</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fmul&nbsp;&nbsp;&nbsp; dword ptr L2&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; multiply</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sub&nbsp;&nbsp;&nbsp;&nbsp; esp,00000008H</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fstp&nbsp;&nbsp;&nbsp; qword ptr [esp]&nbsp;
&nbsp;&nbsp; ; store into memory</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; offset L1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call&nbsp;&nbsp;&nbsp; printf_</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add&nbsp;&nbsp;&nbsp;&nbsp; esp,0000000cH</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add&nbsp;&nbsp;&nbsp;&nbsp; esp,00000010H</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;&nbsp;&nbsp; edx</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;&nbsp;&nbsp; ebx</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret</TT>
<H4 ID="fpc"> fpc </H4>
<BR>All floating-point arithmetic is done with calls to a floating-point emulation library.&nbsp; If a numeric data processor
is present in the system, it will be used by the library; otherwise floating-point operations are simulated in software.&nbsp;
This option should be used for any of the following reasons:
<OL>
<LI>Speed of floating-point emulation is favoured over code size.
<LI>An application containing floating-point operations is to be stored in ROM and an 80x87 will not be present in the system.
</OL>
<BR>The macro<TT> __SW_FPC</TT> will be predefined if &quot;fpc&quot; is selected.
<HR>
<BR><B><I>&nbsp; Note:</I></B>&nbsp; When any module in an application is compiled with the &quot;fpc&quot; option, then all
modules must be compiled with the &quot;fpc&quot; option.
<BR>&nbsp; Different math libraries are provided for applications which have been compiled with a particular floating-point
option.&nbsp; See the section entitled <A HREF="#Open_Watcom_CDCPP_Math_Libraries">Open Watcom C/C++ Math Libraries</A>.
<HR>
<BR>See the section entitled <A HREF="#The_NO87_Environment_Variable">The NO87 Environment Variable</A> for information on
testing the floating-point simulation code on personal computers equipped with a coprocessor.
<H4 ID="fpi"> fpi </H4>
<BR>(16-bit only) The compiler will generate in-line 80x87 numeric data processor instructions into the object code for floating-point
operations.&nbsp; Depending on which library the code is linked against, these instructions will be left as is or they will
be replaced by special interrupt instructions.&nbsp; In the latter case, floating-point will be emulated if an 80x87 is not
present.&nbsp; This is the default floating-point option if none is specified.
<BR>(32-bit only) The compiler will generate in-line 387-compatible numeric data processor instructions into the object code
for floating-point operations.&nbsp; When any module containing floating-point operations is compiled with the &quot;fpi&quot;
option, coprocessor emulation software will be included in the application when it is linked.
<BR><BR>For 32-bit Open Watcom Windows-extender applications or 32-bit applications run in Windows 3.1 DOS boxes, you must
also include the<TT> WEMU387.386</TT> file in the<TT> [386enh]</TT> section of the<TT> SYSTEM.INI</TT> file.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; device=C:\WATCOM\binw\wemu387.386</TT>
<BR><BR>Note that the<TT> WDEBUG.386</TT> file which is installed by the Open Watcom Installation software contains the emulation
support found in the<TT> WEMU387.386</TT> file.
<BR><BR>Thus, a math coprocessor need not be present at run-time.&nbsp; This is the default floating-point option if none
is specified.&nbsp; The macros<TT> __FPI__</TT> and<TT> __SW_FPI</TT> will be predefined if &quot;fpi&quot; is selected.&nbsp;

<HR>
<BR><B><I>&nbsp; Note:</I></B>&nbsp; When any module in an application is compiled with a particular &quot;floating-point&quot;
option, then all modules must be compiled with the same option.
<BR>&nbsp; If you wish to have floating-point emulation software included in the application, you should select the &quot;fpi&quot;
option.&nbsp; A math coprocessor need not be present at run-time.
<BR><BR>&nbsp; Different math libraries are provided for applications which have been compiled with a particular floating-point
option.&nbsp; See the section entitled <A HREF="#Open_Watcom_CDCPP_Math_Libraries">Open Watcom C/C++ Math Libraries</A>.
<HR>
<BR>See the section entitled <A HREF="#The_NO87_Environment_Variable">The NO87 Environment Variable</A> for information on
testing the math coprocessor emulation code on personal computers equipped with a coprocessor.
<H4 ID="fpi87"> fpi87 </H4>
<BR>(16-bit only) The compiler will generate in-line 80x87 numeric data processor instructions into the object code for floating-point
operations.&nbsp; An 8087 or compatible math coprocessor must be present at run-time.&nbsp; If the &quot;2&quot; option is
used in conjunction with this option, the compiler will generate 287 and upwards compatible instructions; otherwise, the compiler
will generate 8087 compatible instructions.
<BR>(32-bit only) The compiler will generate in-line 387-compatible numeric data processor instructions into the object code
for floating-point operations.&nbsp; When the &quot;fpi87&quot; option is used exclusively, coprocessor emulation software
is not included in the application when it is linked.&nbsp; A 387 or compatible math coprocessor must be present at run-time.
<BR><BR>The macros<TT> __FPI__</TT> and<TT> __SW_FPI87</TT> will be predefined if &quot;fpi87&quot; is selected.&nbsp; See
Note with description of &quot;fpi&quot; option.
<H4 ID="fp2"> fp2 </H4>
<BR>The compiler will generate in-line 80x87 numeric data processor instructions into the object code for floating-point operations.
&nbsp;For Open Watcom compilers generating 16-bit code, this option is the default.&nbsp; For 32-bit applications, use this
option if you wish to support those few 386 systems that are equipped with a 287 numeric data processor (&quot;fp3&quot; is
the default for Open Watcom compilers generating 32-bit code).&nbsp; However, for 32-bit applications, the use of this option
will reduce execution performance.&nbsp; Use this option in conjunction with the &quot;fpi&quot; or &quot;fpi87&quot; options.
&nbsp;The macro<TT> __SW_FP2</TT> will be predefined if &quot;fp2&quot; is selected.
<H4 ID="fp3"> fp3 </H4>
<BR>The compiler will generate in-line 387-compatible numeric data processor instructions into the object code for floating-point
operations.&nbsp; For 16-bit applications, the use of this option will limit the range of systems on which the application
will run but there are execution performance improvements.&nbsp; For Open Watcom compilers generating 32-bit code, this option
is the default.&nbsp; Use this option in conjunction with the &quot;fpi&quot; or &quot;fpi87&quot; options.&nbsp; The macro<TT>
__SW_FP3</TT> will be predefined if &quot;fp3&quot; is selected.
<H4 ID="fp5"> fp5 </H4>
<BR>The compiler will generate in-line 80x87 numeric data processor instructions into the object code for floating-point operations.
&nbsp;The sequence of floating-point instructions will be optimized for greatest possible performance on the Intel Pentium
processor.&nbsp; For 16-bit applications, the use of this option will limit the range of systems on which the application
will run but there are execution performance improvements.&nbsp; Use this option in conjunction with the &quot;fpi&quot; or
&quot;fpi87&quot; options.&nbsp; The macro<TT> __SW_FP5</TT> will be predefined if &quot;fp5&quot; is selected.
<H4 ID="fp6"> fp6 </H4>
<BR>The compiler will generate in-line 80x87 numeric data processor instructions into the object code for floating-point operations.
&nbsp;The sequence of floating-point instructions will be optimized for greatest possible performance on the Intel Pentium
Pro processor.&nbsp; For 16-bit applications, the use of this option will limit the range of systems on which the application
will run but there are execution performance improvements.&nbsp; Use this option in conjunction with the &quot;fpi&quot; or
&quot;fpi87&quot; options.&nbsp; The macro<TT> __SW_FP6</TT> will be predefined if &quot;fp6&quot; is selected.
<H4 ID="fpd"> fpd </H4>
<BR>A subtle problem was detected in the FDIV instruction of Intel's original Pentium CPU.&nbsp; In certain rare cases, the
result of a floating-point divide could have less precision than it should.&nbsp; Contact Intel directly for more information
on the issue.
<BR>As a result, the run-time system startup code has been modified to test for a faulty Pentium.&nbsp; If the FDIV instruction
is found to be flawed, the low order bit of the run-time system variable<TT> __chipbug</TT> will be set.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern unsigned __near __chipbug;</TT>
<BR><BR>If the FDIV instruction does not show the problem, the low order bit will be clear.&nbsp; If the Pentium FDIV flaw
is a concern for your application, there are two approaches that you could take:
<OL>
<LI>You may test the<TT> __chipbug</TT> variable in your code in all floating-point and memory models and take appropriate
action (such as display a warning message or discontinue the application).
<LI>Alternately, you can use the &quot;fpd&quot; option when compiling your code.&nbsp; This option directs the compiler to
generate additional code whenever an FDIV instruction is generated which tests the low order bit of<TT> __chipbug</TT> and,
if on, calls the software workaround code in the math libraries.&nbsp; If the bit is off, an in-line FDIV instruction will
be performed as before.
</OL>
<BR>If you know that your application will never run on a defective Pentium CPU, or your analysis shows that the FDIV problem
will not affect your results, you need not use the &quot;fpd&quot; option.&nbsp; The macro<TT> __SW_FPD</TT> will be predefined
if &quot;fpd&quot; is selected.
<H3 ID="SegmentsDModules"> Segments/Modules </H3>
<BR>This group of options deals with object file data structures that are generated by the compiler.
<H4 ID="gEXcodegroupY"> g=&lt;codegroup&gt; </H4>
<BR>The generated code is placed in the group called &quot;&lt;codegroup&gt;&quot;.&nbsp; The default &quot;text&quot; segment
name will be &quot;&lt;codegroup&gt;_TEXT&quot; but this can be overridden by the &quot;nt&quot; option.
<BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;</TT><B>compiler_name</B><TT> report -g=RPTGROUP -s</TT>
<BR><BR>(16-bit only) &lt;&lt;
<BR><BR>This is useful when compiling applications for small code models where the total application will contain more than
64 kilobytes of code.&nbsp; Each group can contain up to 64 kilobytes of code.&nbsp; The application follows a &quot;mixed&quot;
code model since it contains a mix of small and large code (intra-segment and inter-segment calls).&nbsp; Memory models are
described in the chapter entitled <A HREF="#16Mbit_Memory_Models">16-bit Memory Models</A>.&nbsp; The<TT> far</TT> keyword
is used to describe routines that are referenced from one group/segment but are defined in another group/segment.
<BR><BR>For small code models, the &quot;s&quot; option should be used in conjunction with the &quot;g&quot; option to prevent
the generation of calls to the C run-time &quot;stack overflow check&quot; routine (<TT> __STK</TT> ).&nbsp; You must also
avoid calls to other &quot;small code&quot; C run-time library routines since inter-segment &quot;near&quot; calls to C library
routines are not possible.
<BR><BR>&gt;&gt; (16-bit only)
<H4 ID="ncEXnameY"> nc=&lt;name&gt; </H4>
<BR>The default &quot;code&quot; class name is &quot;CODE&quot;.&nbsp; The small code model &quot;_TEXT&quot; segment and
the large code model &quot;module_name_TEXT&quot; segments belong to the &quot;CODE&quot; class.&nbsp; This option allows
you to select a different class name for these code segments.&nbsp; The name of the &quot;code&quot; class is explicitly set
to &quot;&lt;name&gt;&quot;.
<BR>Note that the default &quot;data&quot; class names are &quot;DATA&quot; (for the &quot;CONST&quot;, &quot;CONST2&quot;
and &quot;_DATA&quot; segments) and &quot;BSS&quot; (for the &quot;_BSS&quot; segment).&nbsp; There is no provision for changing
the data class names.
<H4 ID="ndEXnameY"> nd=&lt;name&gt; </H4>
<BR>This option permits you to define a special prefix for the &quot;CONST&quot;, &quot;CONST2&quot;, &quot;_DATA&quot;, and
&quot;_BSS&quot; segment names.&nbsp; The name of the group to which these segments belong is also changed from &quot;DGROUP&quot;
to &quot;&lt;name&gt;_GROUP&quot;.&nbsp; This option is especially useful in the creation of 16-bit Dynamic Link Library (DLL)
routines.
<BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;</TT><B>compiler_name</B><TT> report -nd=spec</TT>
<BR><BR>In the above example, the segment names become &quot;specCONST&quot;, &quot;specCONST2&quot;, &quot;spec_DATA&quot;,
and &quot;spec_BSS&quot; and the group name becomes &quot;spec_GROUP&quot;.
<BR><BR>By default, the data group &quot;DGROUP&quot; consists of the &quot;CONST&quot;, &quot;CONST2&quot;, &quot;_DATA&quot;,
and &quot;_BSS&quot; segments.&nbsp; The compiler places certain types of data in each segment.&nbsp; The &quot;CONST&quot;
segment contains constant literals that appear in your source code.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char *birds[ 3 ] = { &quot;robin&quot;, &quot;finch&quot;, &quot;wren&quot; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Hello world\n&quot; );</TT>
<BR><BR>In the above example, the strings &quot;Hello world\n&quot;, &quot;robin&quot;, &quot;finch&quot;, etc.&nbsp; appear
in the &quot;CONST&quot; segment.
<BR><BR>The &quot;CONST2&quot; segment contains initialized read-only data.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern const int cvar = 1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int var = 2;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int table[ 5 ] = { 1, 2, 3, 4, 5 };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char *birds[ 3 ] = { &quot;robin&quot;, &quot;finch&quot;, &quot;wren&quot; };</TT>
<BR><BR>In the above example, the constant variable<TT> cvar</TT> is placed in the &quot;CONST2&quot; segment.
<BR><BR>The &quot;_BSS&quot; segment contains uninitialized data such as scalars, structures, or arrays.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int var1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int array1[ 400 ];</TT>
<BR><BR>Other data segments containing data, specifically declared to be<TT> far</TT> or exceeding the data threshold (see
&quot;zt&quot; option), are named either &quot;module_nameN_DATA&quot; when using the C compiler or &quot;module_name_DATAN&quot;
when using the C++ compiler where &quot;N&quot; is some integral number.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int far array2[400];</TT>
<BR><BR>In the above example,<TT> array2</TT> is placed in the segment &quot;report11_DATA&quot; (C) or &quot;report_DATA11&quot;
(C++) provided that the module name is &quot;report&quot;.
<BR><BR>The macro<TT> __SW_ND</TT> will be predefined if &quot;nd&quot; is selected.
<H4 ID="nmEXnameY"> nm=&lt;name&gt; </H4>
<BR>By default, the object file name and the module name that is placed within it are constructed from the source file name.
&nbsp;When the &quot;nm&quot; option is used, the module name that is placed into the object file is &quot;&lt;name&gt;&quot;.
&nbsp;For large code models, the &quot;text&quot; segment name is &quot;&lt;name&gt;_TEXT&quot; unless the &quot;nt&quot;
option is used.
<BR>In the following example, the preprocessed output from<TT> report.c</TT> is stored on drive &quot;D&quot; under the name<TT>
temp.c.</TT>&nbsp; The file is compiled with the &quot;nm&quot; option so that the module name imbedded into the object file
is &quot;REPORT&quot; rather than &quot;TEMP&quot;.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;</TT><B>compiler_name</B><TT> report -pl -fo=d:\temp.c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;</TT><B>compiler_name</B><TT> d:\temp -nm=report -fo=report</TT>
<BR><BR>Since the &quot;fo&quot; option is also used, the resultant object file is called<TT> report.obj.</TT>
<H4 ID="ntEXnameY"> nt=&lt;name&gt; </H4>
<BR>The name of the &quot;text&quot; segment is explicitly set to &quot;&lt;name&gt;&quot;.&nbsp; By default, the &quot;text&quot;
segment name is &quot;_TEXT&quot; for small code models and &quot;module_name_TEXT&quot; for large code models.
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Application Memory&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Code</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Model&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Segment</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ----------- -------&nbsp;&nbsp;&nbsp;&nbsp; -------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 16-bit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tiny&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _TEXT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 32-bit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; flat&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _TEXT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 16/32-bit&nbsp;&nbsp; small&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _TEXT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 16/32-bit&nbsp;&nbsp; medium&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; module_name_TEXT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 16/32-bit&nbsp;&nbsp; compact&nbsp;&nbsp;&nbsp;&nbsp; _TEXT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 16/32-bit&nbsp;&nbsp; large&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; module_name_TEXT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 16-bit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; huge&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; module_name_TEXT</TT>
<H4 ID="zm"> zm </H4>
<BR>The &quot;zm&quot; option instructs the code generator to place each function into a separate segment.
<BR>In small code models, the segment name is &quot;_TEXT&quot; by default.
<BR><BR>(C only) In large code models, the segment name is composed of the function name concatenated with the string &quot;_TEXT&quot;.
<BR><BR>(C++ only) In large code models, the segment name is composed of the module name concatenated with the string &quot;_TEXT&quot;
and a unique integral number.
<BR><BR>The default string &quot;_TEXT&quot; can be altered using the &quot;nt&quot; option (see <A HREF="#ntEXnameY">nt=&lt;name&gt;</A>).
<BR><BR>The advantages to this option are:
<OL>
<LI>Since each function is placed in its own segment, functions that are not required by an application are omitted from the
executable by the linker (when &quot;OPTION ELIMINATE&quot; is specified).
<LI>This can result in smaller executables.
<LI>This benefit applies to both small and large code models.
<LI>This option allows you to create granular libraries without resorting to placing each function in a separate file.
</OL>
<BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static int foo( int x )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return x - 1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static int near foo1( int x )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return x + 1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int foo2( int y )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return foo(y) * foo1(y-1);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int foo3( int x, int y )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return x + y * x;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The disadvantages to this option are:
<OL>
<LI>The &quot;near call&quot; optimization for static functions in large code models is disabled (e.g., the function<TT> foo</TT>
in the example above will never be &quot;near called&quot;.&nbsp; Static functions will always be &quot;far called&quot; in
large code models.
<LI>Near static functions will still be &quot;near called&quot; (e.g., the function<TT> foo1</TT> is &quot;near called&quot;
in the example above).&nbsp; However, this can lead to problems at link time if the caller function ends up in a different
segment from the called function (the linker will issue a message if this is the case).
<LI>The &quot;common epilogue&quot; optimization is lost.
<LI>The linker &quot;OPTION ELIMINATE&quot; must be specified when linking an application to take advantage of the granularity
inherent in object files/libraries compiled with this option.
<LI>Any assumptions about relative position of functions are invalid.&nbsp; Consider the following code which attempts to
determine the size of a code region by subtracting function addresses:
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; region_size = (unsigned long)&amp;function2 - (unsigned long)function1;</TT>
<BR><BR>When &quot;zm&quot; is in effect,<TT> region_size</TT> may be extremely large or even a negative value.&nbsp; For
the above code to work as intended, both<TT> function1</TT> and<TT> function2</TT> (and every function intended to be located
between them) must reside in a single code segment.
</OL>
<BR>This option can be used in paging environments where special segment ordering may be employed.&nbsp; The &quot;alloc_text&quot;
pragma is often used in conjunction with this option to place functions into specific segments.
<BR><BR>The macro<TT> __SW_ZM</TT> will be predefined if &quot;zm&quot; is selected.
<H4 ID="zmf"> zmf </H4>
<BR>(C++ only) This option is identical to the &quot;zm&quot; option (see <A HREF="#zm">zm</A>) except for the following large
code model consideration.
<BR>Instead of placing each function in a segment with a different name, the code generator will place each function in a
segment with the same name (the name of the module suffixed by &quot;_TEXT&quot;).
<BR><BR>The advantages to this option are:
<OL>
<LI>All functions in a module will reside in the same physical segment in an executable.
<LI>The &quot;near call&quot; optimization for static functions in large code models is not disabled (e.g., the function<TT>
foo</TT> in the example above will be &quot;near called&quot;.&nbsp; Static functions will always be &quot;near called&quot;
in large code models.
<LI>The problem associated with calling &quot;near&quot; functions goes away since all functions in a module will reside in
the same physical segment (e.g., the function<TT> foo1</TT> is &quot;near&quot; in the example above).
</OL>
<BR>The disadvantages to this option are:
<OL>
<LI>The size of a physical segment is restricted to 64K in 16-bit applications.&nbsp; Although this may limit the number of
functions that can be placed in the segment, the restriction is only on a &quot;per module&quot; basis.
<LI>Although less constricting, the size of a physical segment is restricted to 4G in a 32-bit application.
</OL>
<H3 ID="80x86_RunMtime_Conventions"> 80x86 Run-time Conventions </H3>
<BR>This group of options deals with the 80x86 run-time environment.
<H4 ID="0"> 0 </H4>
<BR>(16-bit only) The compiler will make use of only 8086 instructions in the generated object code.&nbsp; This is the default.
&nbsp;The resulting code will run on 8086 and all upward compatible processors.&nbsp; The macro<TT> __SW_0</TT> will be predefined
if &quot;0&quot; is selected.
<H4 ID="1"> 1 </H4>
<BR>(16-bit only) The compiler will make use of 186 instructions in the generated object code whenever possible.&nbsp; The
resulting code probably will not run on 8086 compatible processors but it will run on 186 and upward compatible processors.
&nbsp;The macro<TT> __SW_1</TT> will be predefined if &quot;1&quot; is selected.
<H4 ID="2"> 2 </H4>
<BR>(16-bit only) The compiler will make use of 286 instructions in the generated object code whenever possible.&nbsp; The
resulting code probably will not run on 8086 or 186 compatible processors but it will run on 286 and upward compatible processors.
&nbsp;The macro<TT> __SW_2</TT> will be predefined if &quot;2&quot; is selected.
<H4 ID="3"> 3 </H4>
<BR>(16-bit only) The compiler will make use of some 386 instructions and FS or GS (if &quot;zff&quot; or &quot;zgf&quot;
options are used) in the generated object code whenever possible.&nbsp; The code will be optimized for 386 processors.&nbsp;
The resulting code probably will not run on 8086, 186 or 286 compatible processors but it will run on 386 and upward compatible
processors.&nbsp; The macro<TT> __SW_3</TT> will be predefined if &quot;3&quot; is selected.
<H4 ID="4"> 4 </H4>
<BR>(16-bit only) The compiler will make use of some 386 instructions and FS or GS (if &quot;zff&quot; or &quot;zgf&quot;
options are used) in the generated object code whenever possible.&nbsp; The code will be optimized for 486 processors.&nbsp;
The resulting code probably will not run on 8086, 186 or 286 compatible processors but it will run on 386 and upward compatible
processors.&nbsp; The macro<TT> __SW_4</TT> will be predefined if &quot;4&quot; is selected.
<H4 ID="5"> 5 </H4>
<BR>(16-bit only) The compiler will make use of some 386 instructions and FS or GS (if &quot;zff&quot; or &quot;zgf&quot;
options are used) in the generated object code whenever possible.&nbsp; The code will be optimized for the Intel Pentium processor.
&nbsp;The resulting code probably will not run on 8086, 186 or 286 compatible processors but it will run on 386 and upward
compatible processors.&nbsp; The macro<TT> __SW_5</TT> will be predefined if &quot;5&quot; is selected.
<H4 ID="6"> 6 </H4>
<BR>(16-bit only) The compiler will make use of some 386 instructions and FS or GS (if &quot;zff&quot; or &quot;zgf&quot;
options are used) in the generated object code whenever possible.&nbsp; The code will be optimized for the Intel Pentium Pro
processor.&nbsp; The resulting code probably will not run on 8086, 186 or 286 compatible processors but it will run on 386
and upward compatible processors.&nbsp; The macro<TT> __SW_6</TT> will be predefined if &quot;6&quot; is selected.
<H4 ID="3_r_s_"> 3{r|s} </H4>
<BR>(32-bit only) The compiler will generate 386 instructions based on 386 instruction timings (see &quot;4&quot;, &quot;5&quot;
and &quot;6&quot; below).
<BR>If the &quot;r&quot; suffix is specified, the following machine-level code strategy is employed.
<UL>
<LI>The compiler will pass arguments in registers whenever possible.&nbsp; This is the default method used to pass arguments
(unless the &quot;bt=netware&quot; option is specified).
<LI>All registers except EAX are preserved across function calls.
<LI>When any form of the &quot;fpi&quot; option is used, the result of functions of type &quot;float&quot; and &quot;double&quot;
is returned in ST(0).
<LI>When the &quot;fpc&quot; option is used, the result of a function of type &quot;float&quot; is returned in EAX and the
result of a function of type &quot;double&quot; is returned in EDX:EAX.
<LI>The resulting code will be smaller than that which is generated for the stack-based method of passing arguments (see &quot;3s&quot;
below).
<LI>The default naming convention for all global functions is such that an underscore character (&quot;_&quot;) is suffixed
to the symbol name.&nbsp; The default naming convention for all global variables is such that an underscore character (&quot;_&quot;)
is prefixed to the symbol name.
</UL>
<BR>If the &quot;s&quot; suffix is specified, the following machine-level code strategy is employed.
<UL>
<LI>The compiler will pass all arguments on the stack.
<LI>The EAX, ECX and EDX registers are not preserved across function calls.
<LI>The FS and GS registers are not preserved across function calls.
<LI>The result of a function of type &quot;float&quot; is returned in EAX.&nbsp; The result of a function of type &quot;double&quot;
is returned in EDX:EAX.
<LI>The resulting code will be larger than that which is generated for the register method of passing arguments (see &quot;3r&quot;
above).
<LI>The naming convention for all global functions and variables is modified such that no underscore characters (&quot;_&quot;)
are prefixed or suffixed to the symbol name.
</UL>
<BR>The &quot;s&quot; conventions are similar to those used by the MetaWare High C 386 compiler.
<BR><BR>By default, &quot;r&quot; is selected if neither &quot;r&quot; nor &quot;s&quot; is specified.
<BR><BR>The macro<TT> __SW_3</TT> will be predefined if &quot;3&quot; is selected.&nbsp; The macro<TT> __SW_3R</TT> will be
predefined if &quot;r&quot; is selected (or defaulted).&nbsp; The macro<TT> __SW_3S</TT> will be predefined if &quot;s&quot;
is selected.
<H4 ID="4_r_s_"> 4{r|s} </H4>
<BR>(32-bit only) This option is identical to &quot;3{r|s}&quot; except that the compiler will generate 386 instructions based
on 486 instruction timings.&nbsp; The code is optimized for 486 processors rather than 386 processors.&nbsp; By default, &quot;r&quot;
is selected if neither &quot;r&quot; nor &quot;s&quot; is specified.&nbsp; The macro<TT> __SW_4</TT> will be predefined if
&quot;4&quot; is selected.&nbsp; The macro<TT> __SW_3R</TT> will be predefined if &quot;r&quot; is selected (or defaulted).
&nbsp;The macro<TT> __SW_3S</TT> will be predefined if &quot;s&quot; is selected.
<H4 ID="5_r_s_"> 5{r|s} </H4>
<BR>(32-bit only) This option is identical to &quot;3{r|s}&quot; except that the compiler will generate 386 instructions based
on Intel Pentium instruction timings.&nbsp; This is the default.&nbsp; The code is optimized for Intel Pentium processors
rather than 386 processors.&nbsp; By default, &quot;r&quot; is selected if neither &quot;r&quot; nor &quot;s&quot; is specified.
&nbsp;The macro<TT> __SW_5</TT> will be predefined if &quot;5&quot; is selected.&nbsp; The macro<TT> __SW_3R</TT> will be
predefined if &quot;r&quot; is selected (or defaulted).&nbsp; The macro<TT> __SW_3S</TT> will be predefined if &quot;s&quot;
is selected.
<H4 ID="6_r_s_"> 6{r|s} </H4>
<BR>(32-bit only) This option is identical to &quot;3{r|s}&quot; except that the compiler will generate 386 instructions based
on Intel Pentium Pro instruction timings.&nbsp; The code is optimized for Intel Pentium Pro processors rather than 386 processors.
&nbsp;By default, &quot;r&quot; is selected if neither &quot;r&quot; nor &quot;s&quot; is specified.&nbsp; The macro<TT> __SW_6</TT>
will be predefined if &quot;6&quot; is selected.&nbsp; The macro<TT> __SW_3R</TT> will be predefined if &quot;r&quot; is selected
(or defaulted).&nbsp; The macro<TT> __SW_3S</TT> will be predefined if &quot;s&quot; is selected.
<H4 ID="mf"> mf </H4>
<BR>(32-bit only) The &quot;flat&quot; memory model (code and data up to 4 gigabytes) is selected.&nbsp; By default, the 32-bit
compiler will select this memory model unless the target system is Netware in which case &quot;small&quot; is selected.&nbsp;
The following macros will be predefined.&nbsp; 
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; __SW_MF</TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; __FLAT__</TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; M_386FM</TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _M_386FM</TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
<H4 ID="ms"> ms </H4>
<BR>The &quot;small&quot; memory model (small code, small data) is selected.&nbsp; By default, the 16-bit compiler will select
this memory model.&nbsp; When the target system is Netware, the 32-bit compiler will select this memory model.&nbsp; The following
macros will be predefined.&nbsp; 
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; __SW_MS</TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; __SMALL__</TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><BR>additional for 16-bit compiler 
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; M_I86SM</TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _M_I86SM</TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><BR>additional for 32-bit compiler 
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; M_386SM</TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _M_386SM</TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
<H4 ID="mm"> mm </H4>
<BR>The &quot;medium&quot; memory model (big code, small data) is selected.&nbsp; The following macros will be predefined.
&nbsp;
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; __SW_MM</TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; __MEDIUM__</TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><BR>additional for 16-bit compiler 
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; M_I86MM</TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _M_I86MM</TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><BR>additional for 32-bit compiler 
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; M_386MM</TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _M_386MM</TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
<H4 ID="mc"> mc </H4>
<BR>The &quot;compact&quot; memory model (small code, big data) is selected.&nbsp; The following macros will be predefined.
&nbsp;
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; __SW_MC</TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; __COMPACT__</TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><BR>additional for 16-bit compiler 
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; M_I86CM</TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _M_I86CM</TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><BR>additional for 32-bit compiler 
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; M_386CM</TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _M_386CM</TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
<H4 ID="ml"> ml </H4>
<BR>The &quot;large&quot; memory model (big code, big data) is selected.&nbsp; The following macros will be predefined.&nbsp;

<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; __SW_ML</TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; __LARGE__</TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><BR>additional for 16-bit compiler 
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; M_I86LM</TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _M_I86LM</TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><BR>additional for 32-bit compiler 
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; M_386LM</TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _M_386LM</TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
<H4 ID="mh"> mh </H4>
<BR>(16-bit only) The &quot;huge&quot; memory model (big code, huge data) is selected.&nbsp; The following macros will be
predefined.&nbsp; 
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; __SW_MH</TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; __HUGE__</TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; M_I86HM</TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _M_I86HM</TT>
<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
<BR><BR>Memory models are described in the chapters entitled <A HREF="#16Mbit_Memory_Models">16-bit Memory Models</A> and
<A HREF="#32Mbit_Memory_Models">32-bit Memory Models</A>.&nbsp; Other architectural aspects of the Intel 86 family such as
pointer size are discussed in the sections entitled <A HREF="#16Mbit__Sizes_of_Predefined_Types">16-bit:&nbsp; Sizes of Predefined Types</A>
in the chapter entitled <A HREF="#16Mbit_Assembly_Language_Considerations">16-bit Assembly Language Considerations</A> or
<A HREF="#32Mbit__Sizes_of_Predefined_Types">32-bit:&nbsp; Sizes of Predefined Types</A> in the chapter entitled <A HREF="#32Mbit_Assembly_Language_Considerations">32-bit Assembly Language Considerations</A>.
<H4 ID="zd_f_p_"> zd{f,p} </H4>
<BR>The &quot;zdf&quot; option allows the code generator to use the DS register to point to other segments besides &quot;DGROUP&quot;
This is the default in the 16-bit compact, large, and huge memory models (except for 16-bit Windows applications).
<BR>The &quot;zdp&quot; option informs the code generator that the DS register must always point to &quot;DGROUP&quot; This
is the default in the 16-bit small and medium memory models, all of the 16-bit Windows memory models, and the 32-bit small
and flat memory models.&nbsp; The macro<TT> __SW_ZDF</TT> will be predefined if &quot;zdf&quot; is selected.&nbsp; The macro<TT>
__SW_ZDP</TT> will be predefined if &quot;zdp&quot; is selected.
<H4 ID="zdl"> zdl </H4>
<BR>(32-bit only) The &quot;zdl&quot; option causes generation of code to load the DS register directly from DGROUP (rather
than the default run-time call).&nbsp; This option causes the generation of a segment relocation.&nbsp; This option is used
with the &quot;zdp&quot; option but not the &quot;zdf&quot; option.
<H4 ID="zev"> zev </H4>
<BR>The &quot;zev&quot; option is an extension to the Watcom C compiler to allow arithmetic operations on void derived types.
&nbsp;This option has been added for compatibility with some Unix compilers and is not ISO compliant.&nbsp; The use of this
option should be avoided.
<H4 ID="zf_f_p_"> zf{f,p} </H4>
<BR>The &quot;zff&quot; option allows the code generator to use the FS register (default for all but flat memory model).&nbsp;
The &quot;zfp&quot; option informs the code generator that the FS register must not be used (default in flat memory model).
&nbsp;The macro<TT> __SW_ZFF</TT> will be predefined if &quot;zff&quot; is selected.&nbsp; The macro<TT> __SW_ZFP</TT> will
be predefined if &quot;zfp&quot; is selected.
<H4 ID="zfw"> zfw </H4>
<BR>The &quot;zfw&quot; option turns on generation of FWAIT instructions on 386 and later CPUs.&nbsp; Note that when targeting
286 and earlier, this option has no effect because FWAITs are always required for synchronization between CPU and FPU.
<BR>This option generates larger and slower code and should only be used when restartable floating-point exceptions are required.
<BR><BR>The macro<TT> __SW_ZFW</TT> will be predefined if &quot;zfw&quot; is selected.
<H4 ID="zg_f_p_"> zg{f,p} </H4>
<BR>The &quot;zgf&quot; option allows the code generator to use the GS register (default for all memory models).&nbsp; The
&quot;zgp&quot; option informs the code generator that the GS register must not be used.&nbsp; The macro<TT> __SW_ZGF</TT>
will be predefined if &quot;zgf&quot; is selected.&nbsp; The macro<TT> __SW_ZGP</TT> will be predefined if &quot;zgp&quot;
is selected.
<H4 ID="zri"> zri </H4>
<BR>(32-bit only) The &quot;zri&quot; option inlines the code for floating point rounding.&nbsp; Normally a function call
is generated for each float to int conversion which may not be desirable.
<BR>The macro<TT> __SW_ZRI</TT> will be predefined if &quot;zri&quot; is selected.
<H4 ID="zro"> zro </H4>
<BR>The &quot;zro&quot; option omits the code for floating point rounding.&nbsp; This results in non-conformant code - the
rounding mode is not ISO/ANSI C compliant - but the code generated is very fast.
<BR>The macro<TT> __SW_ZRO</TT> will be predefined if &quot;zro&quot; is selected.
<H4 ID="zu"> zu </H4>
<BR>The &quot;zu&quot; option relaxes the restriction that the SS register contains the base address of the default data segment,
&quot;DGROUP&quot;.&nbsp; Normally, all data items are placed into the group &quot;DGROUP&quot; and the SS register contains
the base address of this group.&nbsp; When the &quot;zu&quot; option is selected, the SS register is volatile (assumed to
point to another segment) and any global data references require loading a segment register such as DS with the base address
of &quot;DGROUP&quot;.
<BR>(16-bit only) This option is useful when compiling routines that are to be placed in a Dynamic Link Library (DLL) since
the SS register points to the stack segment of the calling application upon entry to the function.
<BR><BR>The macro<TT> __SW_ZU</TT> will be predefined if &quot;zu&quot; is selected.
<H3 ID="Optimizations"> Optimizations </H3>
<BR>When specified on the command line, optimization options may be specified individually (oa, oi) or the letters may be
strung together (oailt).
<H4 ID="oa"> oa </H4>
<BR>Alias checking is relaxed.&nbsp; When this option is specified, the code optimizer will assume that global variables are
not indirectly referenced through pointers.&nbsp; This assumption may reduce the size of the code that is generated.&nbsp;
The following example helps to illustrate this point.
<BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void rtn( int *pi )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int k;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( k = 0; k &lt; 10; ++k ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (*pi)++;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i++;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>In the above example, if &quot;i&quot; and &quot;*pi&quot; referenced the same integer object then &quot;i&quot; would
be incremented by 2 each time through the &quot;for&quot; loop and we would call the pointer reference &quot;*pi&quot; an
alias for the variable &quot;i&quot;.&nbsp; In this situation, the compiler could not bind the variable &quot;i&quot; to a
register without making sure that the &quot;in-memory&quot; copy of &quot;i&quot; was kept up-to-date.&nbsp; In most cases,
the above situation does not arise.&nbsp; Rarely would we reference the same variable directly by name and indirectly through
a pointer in the same routine.&nbsp; The &quot;oa&quot; option instructs the code generator that such cases do not arise in
the module to be compiled.&nbsp; The code generator will be able to produce more efficient code when it does not have to worry
about the alias &quot;problem&quot;.
<BR><BR>The macro<TT> __SW_OA</TT> will be predefined if &quot;oa&quot; is selected.
<H4 ID="ob"> ob </H4>
<BR>When the &quot;ob&quot; option is specified, the code generator will try to order the blocks of code emitted such that
the &quot;expected&quot; execution path (as determined by a set of simple heuristics) will be straight through, with other
cases being handled by jumps to separate blocks of code &quot;out of line&quot;.&nbsp; This will result in better cache utilization
on the Pentium.&nbsp; If the heuristics do not apply to your code, it could result in a performance decrease.
<H4 ID="oc"> oc </H4>
<BR>This option may be used to disable the optimization where a &quot;CALL&quot; followed by a &quot;RET&quot; (return) is
changed into a &quot;JMP&quot; (jump) instruction.
<BR>(16-bit only) This option is required if you wish to link an overlayed program using the Microsoft DOS Overlay Linker.
&nbsp;The Microsoft DOS Overlay Linker will create overlay calls for a &quot;CALL&quot; instruction only.&nbsp; This option
is not required when using the Open Watcom Linker.
<BR><BR>The macro<TT> __SW_OC</TT> will be predefined if &quot;oc&quot; is selected.
<H4 ID="od"> od </H4>
<BR>Non-optimized code sequences are generated.&nbsp; The resulting code will be much easier to debug when using the Open
Watcom Debugger.&nbsp; By default, the compiler will select &quot;od&quot; if &quot;d2&quot; is specified.&nbsp; If &quot;d2&quot;
is followed by one of the other &quot;o?&quot; options then &quot;od&quot; is overridden.
<BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;</TT><B>compiler_name</B><TT> report -d2 -os</TT>
<BR><BR>The macro<TT> __SW_OD</TT> will be predefined if &quot;od&quot; is selected.
<H4 ID="oeEXnumY"> oe=&lt;num&gt; </H4>
<BR>Certain user functions are expanded in-line.&nbsp; The criteria for which functions are selected for in-line expansion
is based on the &quot;size&quot; of the function in terms of the number of &quot;tree nodes&quot; generated by the function.
&nbsp;Functions are internally represented as tree structures, where each operand and each operator is a node of the tree.
&nbsp;For example, the statement<TT> a = -b * (c + d)</TT> can be represented as a tree with 8 nodes, one for each operand
and operator.
<BR>The number of &quot;nodes&quot; generated corresponds closely with the number of operators used in an expression.&nbsp;
Functions which require more than &quot;&lt;num&gt;&quot; nodes are not expanded in-line.&nbsp; The default number is 20.
&nbsp;With larger &quot;&lt;num&gt;&quot; values, more (larger) functions will be expanded in-line.&nbsp; This optimization
is especially useful when locally-referenced functions are small in size.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;</TT><B>compiler_name</B><TT> dhrystone -oe</TT>
<H4 ID="oh"> oh </H4>
<BR>This option enables repeated optimizations (which can result in longer compiles).
<H4 ID="oi"> oi </H4>
<BR>Certain library functions are generated in-line.&nbsp; You must include the appropriate header file containing the prototype
for the desired function so that it will be generated in-line.&nbsp; The functions that can be generated in-line are:
<BR><TT>abs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _disable&nbsp;&nbsp; div&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _enable
&nbsp;&nbsp; fabs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fmemchr&nbsp;&nbsp; _fmemcmp&nbsp;&nbsp; _fmemcpy&nbsp;&nbsp; _fmemset
&nbsp; _fstrcat&nbsp;&nbsp; _fstrcmp&nbsp;&nbsp; _fstrcpy&nbsp;&nbsp; _fstrlen&nbsp;&nbsp; inpd (2)&nbsp;&nbsp; inpw&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; inp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; labs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ldiv (2)&nbsp;
&nbsp;_lrotl (2) _lrotr (2) memchr&nbsp;&nbsp;&nbsp;&nbsp; memcmp&nbsp;&nbsp;&nbsp;&nbsp; memcpy&nbsp;&nbsp;&nbsp;&nbsp; memset
(1) movedata&nbsp;&nbsp; outpd (2)&nbsp; outpw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _rotl
&nbsp;&nbsp;&nbsp;&nbsp; _rotr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcat&nbsp;&nbsp;&nbsp;&nbsp; strchr&nbsp;&nbsp;&nbsp;&nbsp;
strcmp (1) strcpy&nbsp;&nbsp;&nbsp;&nbsp; strlen&nbsp;&nbsp;&nbsp; </TT>
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp; *1 16-bit only
<BR>&nbsp;&nbsp;&nbsp;&nbsp; *2 32-bit only
<BR><BR>The macros<TT> __INLINE_FUNCTIONS__</TT> and<TT> __SW_OI</TT> will be predefined if &quot;oi&quot; is selected.
<H4 ID="oiP"> oi+ </H4>
<BR>(C++ only) This option encompasses &quot;oi&quot; but also sets<B> inline_depth</B> to its maximum (255).&nbsp; By default,<B>
inline_depth</B> is 3.&nbsp; The<B> inline_depth</B> can also be changed by using the C++<TT> inline_depth</TT> pragma.
<H4 ID="ok"> ok </H4>
<BR>This option enables flowing of register save (from prologue) down into the function's flow graph.&nbsp; This means that
register save/restores will not be executed when it is not necessary (as can be the case when a function consists of an if-else
construct with a simple part that does little and a more complex part that does a lot).
<H4 ID="ol"> ol </H4>
<BR>Loop optimizations are performed.&nbsp; This includes moving loop-invariant expressions outside the loops.&nbsp; The macro<TT>
__SW_OL</TT> will be predefined if &quot;ol&quot; is selected.
<H4 ID="olP"> ol+ </H4>
<BR>Loop optimizations are performed including loop unrolling.&nbsp; This includes moving loop-invariant expressions outside
the loops and turning some loops into straight-line code.&nbsp; The macro<TT> __SW_OL</TT> will be predefined if &quot;ol+&quot;
is selected.
<H4 ID="om"> om </H4>
<BR>Generate in-line 80x87 code for math functions like sin, cos, tan, etc.&nbsp; If this option is selected, it is the programmer's
responsibility to make sure that arguments to these functions are within the range accepted by the<TT> fsin, fcos,</TT> etc.
&nbsp;instructions since no run-time check is made.&nbsp; For 16-bit, you must also include the &quot;fp3&quot; option to
get in-line 80x87 code (except for fabs).&nbsp; The functions that can be generated in-line are:
<BR><TT>atan&nbsp; cos&nbsp;&nbsp; exp&nbsp;&nbsp; fabs&nbsp; log10 log&nbsp;&nbsp; sin&nbsp;&nbsp; sqrt&nbsp; tan&nbsp; </TT>
<BR><BR>The macro<TT> __SW_OM</TT> will be predefined if &quot;om&quot; is selected.
<H4 ID="on"> on </H4>
<BR>This option allows the compiler to replace floating-point divisions with multiplications by the reciprocal.&nbsp; This
generates faster code, but the result may not be the same because the reciprocal may not be exactly representable.&nbsp; The
macro<TT> __SW_ON</TT> will be predefined if &quot;on&quot; is selected.
<H4 ID="oo"> oo </H4>
<BR>By default, the compiler will abort compilation if it runs low on memory.&nbsp; This option forces the compiler to continue
compilation even when low on memory, however, this can result in very poor code being generated.&nbsp; The macro<TT> __SW_OO</TT>
will be predefined if &quot;oo&quot; is selected.
<H4 ID="op"> op </H4>
<BR>This option causes the compiler to store intermediate floating-point results into memory in order to generate consistent
floating-point results rather than keeping values in the 80x87 registers where they have more precision.&nbsp; The macro<TT>
__SW_OP</TT> will be predefined if &quot;op&quot; is selected.
<H4 ID="or"> or </H4>
<BR>This option enables reordering of instructions (instruction scheduling) to achieve better performance on pipelined architectures
such as the Intel 486 and Pentium processors.&nbsp; This option is essential for generating fast code for the Intel Pentium
processor.&nbsp; Selecting this option will make it slightly more difficult to debug because the assembly language instructions
generated for a source statement may be intermixed with instructions generated for surrounding statements.&nbsp; The macro<TT>
__SW_OR</TT> will be predefined if &quot;or&quot; is selected.
<H4 ID="os"> os </H4>
<BR>Space is favoured over time when generating code (smaller code but possibly slower execution).&nbsp; By default, the compiler
selects a balance between &quot;space&quot; and &quot;time&quot;.&nbsp; The macro<TT> __SW_OS</TT> will be predefined if &quot;os&quot;
is selected.
<H4 ID="ot"> ot </H4>
<BR>Time is favoured over space when generating code (faster execution but possibly larger code).&nbsp; By default, the compiler
selects a balance between &quot;space&quot; and &quot;time&quot;.&nbsp; The macro<TT> __SW_OT</TT> will be predefined if &quot;ot&quot;
is selected.
<H4 ID="ou"> ou </H4>
<BR>This option forces the compiler to make sure that all function labels are unique.&nbsp; Thus the compiler will not place
two function labels at the same address even if the code for the two functions are identical.&nbsp; This option is automatically
selected if the &quot;za&quot; option is specified.&nbsp; The macro<TT> __SW_OU</TT> will be predefined if &quot;ou&quot;
is selected.
<H4 ID="ox"> ox </H4>
<BR>The &quot;obmiler&quot; and &quot;s&quot; (no stack overflow checking) options are selected.
<H4 ID="oz"> oz </H4>
<BR>This option prevents the compiler from omitting NULL pointer checks on pointer conversions.&nbsp; By default, the compiler
omits NULL pointer checks on pointer conversions when it is safe to do so.&nbsp; Consider the following example.
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct B1 {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int b1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct B2 {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int b2;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct D : B1, B2 {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int d;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void clear_D( D *p )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p-&gt;d = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B1 *p1 = p;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p1-&gt;b1 = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B2 *p2 = p;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p2-&gt;b2 = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>In this example, the C++ compiler must ensure that<TT> p1</TT> and<TT> p2</TT> become NULL if<TT> p</TT> is NULL (since
no offset adjustment is allowed for a NULL pointer).&nbsp; However, the first executable statement implies that<TT> p</TT>
is not NULL since, in most operating environments, the executing program would crash at the first executable statement if<TT>
p</TT> was NULL.&nbsp; The &quot;oz&quot; option will prevent the compiler from omitting the check for a NULL pointer.
<BR><BR>The macro<TT> __SW_OZ</TT> will be predefined if &quot;oz&quot; is selected.
<BR><BR>When &quot;ox&quot; is combined with the &quot;on&quot;, &quot;oa&quot; and &quot;ot&quot; options (&quot;onatx&quot;)
and the &quot;zp4&quot; option, the code generator will attempt to give you the fastest executing code possible irrespective
of architecture.&nbsp; Other options can give you architecture specific optimizations to further improve the speed of your
code.&nbsp; Note that specifying &quot;onatx&quot; is equivalent to specifying &quot;onatblimer&quot; and &quot;s&quot;.&nbsp;
See the section entitled <A HREF="#Benchmarking_Hints">Benchmarking Hints</A> for more information on generating fast code.
<H3 ID="CPP_Exception_Handling"> C++ Exception Handling </H3>
<BR>The &quot;xd...&quot; options disable exception handling.&nbsp; Consequently, it is not possible to use<B><I> throw</I></B>
,<B><I> try</I></B> , or<B><I> catch</I></B> statements, or to specify a function exception specification.&nbsp; If your program
(or a library which it includes) throws exceptions, then one of the &quot;xs...&quot; options should be used to compile all
the modules in your program; otherwise, any active objects created within the module will not be destructed during exception
processing.
<BR><BR>Multiple schemes are possible, allowing experimentation to determine the optimal scheme for particular circumstances.
&nbsp;You can mix and match schemes on a module basis, with the proviso that exceptions should be enabled wherever it is possible
that a created object should be destructed by the exception mechanism.
<H4 ID="xd"> xd </H4>
<BR>This option disables exception handling.&nbsp; It is the default option if no exception handling option is specified.
&nbsp;When this option is specified (or defaulted):
<UL>
<LI>Destruction of objects is caused by direct calls to the appropriate destructors
<LI>Destructor functions are implemented with direct calls to appropriate destructors to destruct base classes and class members.
</UL>
<H4 ID="xdt"> xdt </H4>
<BR>This option is the same as &quot;xd&quot; (see <A HREF="#xd">xd</A>).
<H4 ID="xds"> xds </H4>
<BR>This option disables exception handling.&nbsp; When this option is specified:
<UL>
<LI>Destruction of objects is caused by direct calls to the appropriate destructors.
<LI>Destruction of base classes and class members is accomplished by interpreting tables.
<LI>This option, in general, generates smaller code, with increased execution time and with more run-time system routines
included by the linker.
</UL>
<H4 ID="xs"> xs </H4>
<BR>This option enables exception handling using a balanced scheme.&nbsp; When this option is specified:
<UL>
<LI>Tables are interpreted to effect destruction of temporaries and automatic objects; destructor functions are implemented
with direct calls to appropriate destructors to destruct base classes and class members.
</UL>
<H4 ID="xst"> xst </H4>
<BR>This option enables exception handling using a time-saving scheme.&nbsp; When this option is specified:
<UL>
<LI>Destruction of temporaries and automatic objects is accomplished with direct calls to appropriate destructors; destructor
functions are implemented with direct calls to appropriate destructors to destruct base classes and class members.
<LI>This scheme will execute faster, but will use more space in general.
</UL>
<H4 ID="xss"> xss </H4>
<BR>This option enables exception handling using a space-saving scheme.&nbsp; When this option is specified:
<UL>
<LI>Tables are interpreted to effect destruction of temporaries and automatic objects; destruction of base classes and class
members is accomplished by interpreting tables.
<LI>This option, in general, generates smaller code, with increased execution time.
</UL>
<H3 ID="DoubleMByteDUnicode_Characters"> Double-Byte/Unicode Characters </H3>
<BR>This group of options deals with compile-time aspects of character sets used in the source code.
<H4 ID="zk_0_1_2_l_"> zk{0,1,2,l} </H4>
<BR>This option causes the compiler to recognize double-byte characters in strings.&nbsp; When the compiler scans a text string
enclosed in quotes (&quot;), it will recognize the first byte of a double-byte character and suppress lexical analysis of
the second byte.&nbsp; This will prevent the compiler from misinterpreting the second byte as a &quot;\&quot; or quote (&quot;)
character.
<DL>
<DT>zk, zk0
<DD>These options cause the compiler to process strings for Japanese double-byte characters (range 0x81 - 0x9F and 0xE0 - 0xFC).
&nbsp;The characters in the range A0 - DF are single-byte Katakana.
<DT>zk1
<DD>This option causes the compiler to process strings for Traditional Chinese and Taiwanese double-byte characters (range 0x81
- 0xFC).
<DT>zk2
<DD>This option causes the compiler to process strings for Korean Hangeul double-byte characters (range 0x81 - 0xFD).
<DT>zkl
<DD>This option causes the compiler to process strings using the current code page.&nbsp; If the local character set includes
double-byte characters then string processing will check for lead bytes.
</DL>
<BR>The macro<TT> __SW_ZK</TT> will be predefined if any &quot;zk&quot; option is selected.
<H4 ID="zk0u"> zk0u </H4>
<BR>This option causes the compiler to process strings for Japanese double-byte characters (range 0x81 - 0x9F and 0xE0 - 0xFC).
&nbsp;The characters in the range A0 - DF are single-byte Katakana.&nbsp; All characters, including Kanji, in wide characters
(L'c') and wide strings (L&quot;string&quot;) are translated to UNICODE.
<BR>When the compiler scans a text string enclosed in quotes (&quot;), it will recognize the first byte of a double-byte character
and suppress lexical analysis of the second byte.&nbsp; This will prevent the compiler from misinterpreting the second byte
as a &quot;\&quot; or quote (&quot;) character.
<H4 ID="zkuEXcodepageY"> zku=&lt;codepage&gt; </H4>
<BR>Characters in wide characters (L'c') and wide strings (L&quot;string&quot;) are translated to UNICODE.&nbsp; The UNICODE
translate table for the specified code page is loaded from a file.&nbsp; The compiler locates this file by searching the paths
listed in the<B> PATH</B> environment variable.&nbsp; The following table lists the supported code pages.
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; codepage | character set&nbsp;&nbsp; | file name</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -------------------------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 437&nbsp;&nbsp; | US-ASCII (DOS)&nbsp; | unicode.437</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 850&nbsp;&nbsp; | Latin-1 (DOS)&nbsp;&nbsp; | unicode.850</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 852&nbsp;&nbsp; | Latin-2 (DOS)&nbsp;&nbsp; | unicode.852</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1250&nbsp;&nbsp; | Latin-2 (Win32) | unicode1.250</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1252&nbsp;&nbsp; | Latin-1 (Win32) | unicode1.252</TT>
<H3 ID="Compatibility_with_Microsoft_Visual_CPP"> Compatibility with Microsoft Visual C++ </H3>
<BR>This group of options deals with compatibility with Microsoft's Visual C++ compiler.
<H4 ID="vc___"> vc... </H4>
<BR>The &quot;vc&quot; option prefix is used to introduce a set of Microsoft Visual C++ compatibility options.&nbsp; At present,
there is only one:&nbsp; vcap.
<H4 ID="vcap"> vcap </H4>
<BR>This options tells the compiler to allow<B><I> _alloca()</I></B> to be used in a parameter list.&nbsp; The optimizer has
to do extra work to allow this but since it is rare (and easily worked around if you can), you have to ask the optimizer to
handle this case.&nbsp; You also may get less efficient code in some cases.
<H3 ID="Compatibility_with_Older_Versions_of_the_80x86_Compilers"> Compatibility with Older Versions of the 80x86 Compilers </H3>
<BR>This group of options deals with compatibility with older versions of Open Watcom's 80x86 compilers.
<H4 ID="r"> r </H4>
<BR>This option instructs the compiler to generate function prologue and epilogue sequences that save and restore any segment
registers that are modified by the function.&nbsp; Caution should be exercised when using this option.&nbsp; If the value
of the segment register being restored matches the value of a segment that was freed within the function, a general protection
fault will occur in protected-mode environments.&nbsp; When this option is used, the compiler also assumes that called functions
save and restore segment registers.&nbsp; By default, the compiler does not generate code to save and restore segment registers.
&nbsp;This option is provided for compatibility with the version 8.0 release.&nbsp; The macro<TT> __SW_R</TT> will be predefined
if &quot;r&quot; is selected.
<H4 ID="fpr"> fpr </H4>
<BR>Use this option if you want to generate floating-point instructions that will be compatible with version 9.0 or earlier
of the compilers.&nbsp; For more information on floating-point conventions see the sections entitled <A HREF="#16Mbit__Using_the_80x87_to_Pass_Arguments">16-bit:&nbsp; Using the 80x87 to Pass Arguments</A>
and <A HREF="#32Mbit__Using_the_80x87_to_Pass_Arguments">32-bit:&nbsp; Using the 80x87 to Pass Arguments</A>.
<H4 ID="zz"> zz </H4>
<BR>Use this option if you want to generate __stdcall function names that will be compatible with version 10.0 of the compilers.
&nbsp;When this option is omitted, all C symbols (extern &quot;C&quot; symbols in C++) are suffixed by &quot;@nnn&quot; where
&quot;nnn&quot; is the sum of the argument sizes (each size is rounded up to a multiple of 4 bytes so that char and short
are size 4).&nbsp; When the argument list contains &quot;...&quot;, the &quot;@nnn&quot; suffix is omitted.&nbsp; This convention
is compatible with Microsoft.&nbsp; For more information on the __stdcall convention see the section entitled <A HREF="#Open_Watcom_CDCPP_Extended_Keywords">Open Watcom C/C++ Extended Keywords</A>.
<H1 ID="The_Open_Watcom_CDCPP_Compilers"> The Open Watcom C/C++ Compilers </H1>
<BR>This chapter covers the following topics.
<UL>
<LI>Command line syntax (see <A HREF="#Open_Watcom_CDCPP_Command_Line_Format">Open Watcom C/C++ Command Line Format</A>)
<LI>Environment variables used by the compilers (see <A HREF="#Environment_Variables">Environment Variables</A>)
<LI>Examples of command line syntax (see <A HREF="#Open_Watcom_CDCPP_Command_Line_Examples">Open Watcom C/C++ Command Line Examples</A>)
<LI>Interpreting diagnostic messages (see <A HREF="#Compiler_Diagnostics">Compiler Diagnostics</A>)
<LI>#include file handling (see <A HREF="#Open_Watcom_CDCPP__include_File_Processing">Open Watcom C/C++ #include File Processing</A>)
<LI>Using the preprocessor built into the compilers (see <A HREF="#Open_Watcom_CDCPP_Preprocessor">Open Watcom C/C++ Preprocessor</A>)
<LI>System-dependent macros predefined by the compilers (see <A HREF="#Open_Watcom_CDCPP_Predefined_Macros">Open Watcom C/C++ Predefined Macros</A>)
<LI>Additional keywords supported by the compilers (see <A HREF="#Open_Watcom_CDCPP_Extended_Keywords">Open Watcom C/C++ Extended Keywords</A>)
<LI>Based pointer support in the compilers (see <A HREF="#Based_Pointers">Based Pointers</A>)
<LI>Notes about the Code Generator (see <A HREF="#The_Open_Watcom_Code_Generator">The Open Watcom Code Generator</A>)
</UL>
<H2 ID="Open_Watcom_CDCPP_Command_Line_Format"> Open Watcom C/C++ Command Line Format </H2>
<BR>The formal Open Watcom C/C++ command line syntax is shown below.&nbsp; 
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; compiler_name [options] [file_spec] [options] [@extra_opts]</TT>
<BR><BR>The square brackets [ ] denote items which are optional.
<DL>
<DT>compiler_name
<DD>is one of the Open Watcom C/C++ compiler command names.&nbsp; 
<DL>
<DT>WCC
<DD>is the Open Watcom C compiler for 16-bit Intel platforms.
<DT>WPP
<DD>is the Open Watcom C++ compiler for 16-bit Intel platforms.
<DT>WCC386
<DD>is the Open Watcom C compiler for 32-bit Intel platforms.
<DT>WPP386
<DD>is the Open Watcom C++ compiler for 32-bit Intel platforms.
</DL>
<DT>file_spec
<DD>is the file name specification of one or more files to be compiled.&nbsp; If file_spec is specified as the single character
&quot;.&quot;, an input file is read from standard input and the output file name defaults to stdin.obj.
<BR><BR>If no drive is specified, the default drive is assumed.
<BR><BR>If no path is specified, the current working directory is assumed.
<BR><BR>If the &quot;xx&quot; option was not specified and the file is not in the current directory then an adjacent &quot;C&quot;
directory (i.e.,<TT> ..\c</TT>) is searched if it exists.
<BR><BR>If no file extension is specified, the compiler will check for a file with one of the following extensions in the
order listed:
<DL>
<DT>.CPP
<DD>(C++ only)
<DT>.CC
<DD>(C++ only)
<DT>.C
<DD>(C/C++)
</DL>
<BR>If a period &quot;.&quot; is specified but not the extension, the file is assumed to have no filename extension.
<BR><BR>If only the compiler name is specified then the compiler will display a list of available options.
<DT>options
<DD>is a list of valid compiler options, each preceded by a slash (&quot;/&quot;) or a dash (&quot;-&quot;).&nbsp; Options may
be specified in any order.
<DT>extra_opts
<DD>is the name of an environment variable or file which contains additional command line options to be processed.&nbsp; If the
specified environment variable does not exist, a search is made for a file with the specified name.&nbsp; If no file extension
is included in the specified name, the default file extension is &quot;.occ&quot;.&nbsp; A search of the current directory
is made.&nbsp; If not successful, an adjacent &quot;OCC&quot; directory (i.e.,<TT> ..\occ</TT>) is searched if it exists.
</DL>
<H2 ID="Open_Watcom_CDCPP_DLLMbased_Compilers"> Open Watcom C/C++ DLL-based Compilers </H2>
<BR>The compilers are also available in Dynamic Link Library (DLL) form.
<DL>
<DT>WCCD
<DD>is the DLL version of the Open Watcom C compiler for 16-bit Intel platforms.
<DT>WPPDI86
<DD>is the DLL version of the Open Watcom C++ compiler for 16-bit Intel platforms.
<DT>WCCD386
<DD>is the DLL version of the Open Watcom C compiler for 32-bit Intel platforms.
<DT>WPPD386
<DD>is the DLL version of the Open Watcom C++ compiler for 32-bit Intel platforms.
</DL>
<BR>The DLL versions of the compilers can be loaded from the Open Watcom Integrated Development Environment (IDE) and Open
Watcom Make.
<H2 ID="Environment_Variables"> Environment Variables </H2>
<BR>Environment variables can be used to specify commonly used compiler options.&nbsp; There is one environment variable for
each compiler (the name of the environment variable is the same as the compiler name).&nbsp; The Open Watcom C/C++ environment
variable names are:&nbsp; 
<DL>
<DT>WCC
<DD>used with the Open Watcom C compiler for 16-bit Intel platforms
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set wcc=-d1 -ot</TT>
<DT>WPP
<DD>used with the Open Watcom C++ compiler for 16-bit Intel platforms
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set wpp=-d1 -ot</TT>
<DT>WCC386
<DD>used with the Open Watcom C compiler for 32-bit Intel platforms
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set wcc386=-d1 -ot</TT>
<DT>WPP386
<DD>used with the Open Watcom C++ compiler for 32-bit Intel platforms
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set wpp386=-d1 -ot</TT>
</DL>
<BR>The options specified in environment variables are processed before options specified on the command line.&nbsp; The above
examples define the default options to be &quot;d1&quot; (include line number debugging information in the object file), and
&quot;ot&quot; (favour time optimizations over size optimizations).
<BR><BR>Whenever you wish to specify an option that requires the use of an &quot;=&quot; character, you can use the &quot;#&quot;
character in its place.&nbsp; This is required by the syntax of the &quot;SET&quot; command.
<BR><BR>Once a particular environment variable has been defined, those options listed become the default each time the associated
compiler is used.&nbsp; The compiler command line can be used to override any options specified in the environment string.
<BR><BR>These environment variables are not examined by the Open Watcom Compile and Link utilities.&nbsp; Since the Open Watcom
Compile and Link utilities pass the relevant options found in their associated environment variables to the compiler command
line, their environment variable options take precedence over the options specified in the environment variables associated
with the compilers.
<BR><BR><B><I>Hint:</I></B>&nbsp; If you are running DOS and you use the same compiler options all the time, you may find
it handy to define the environment variable in your DOS system initialization file,<TT> AUTOEXEC.BAT.</TT>
<BR><BR>If you are running Windows NT, use the &quot;System&quot; icon in the<B> Control Panel</B> to define environment variables.
<BR><BR>If you are running OS/2 and you use the same compiler options all the time, you may find it handy to define the environment
variable in your OS/2 system initialization file,<TT> CONFIG.SYS.</TT>
<H2 ID="Open_Watcom_CDCPP_Command_Line_Examples"> Open Watcom C/C++ Command Line Examples </H2>
<BR>The following are some examples of using Open Watcom C/C++ to compile C/C++ source programs.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;</TT><B>compiler_name</B><TT> report -d1 -s</TT>
<BR><BR>The compiler processes<TT> report.c(pp)</TT> producing an object file which contains source line number information.
&nbsp;Stack overflow checking is omitted from the object code.&nbsp; 
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;</TT><B>compiler_name</B><TT> -mm -fpc calc</TT>
<BR><BR>The compiler compiles<TT> calc.c(pp)</TT> for the Intel &quot;medium&quot; memory model and generates calls to floating-point
library emulation routines for all floating-point operations.&nbsp; Memory models are described in the chapter entitled <A HREF="#16Mbit_Memory_Models">16-bit Memory Models</A>.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;</TT><B>compiler_name</B><TT> kwikdraw -2 -fpi87 -oaxt</TT>
<BR><BR>The compiler processes<TT> kwikdraw.c(pp)</TT> producing 16-bit object code for an Intel 286 system equipped with
an Intel 287 numeric data processor (or any upward compatible 386/387, 486DX, or Pentium system).&nbsp; While the choice of
these options narrows the number of microcomputer systems where this code will execute, the resulting code will be highly
optimized for this type of system.&nbsp; 
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;</TT><B>compiler_name</B><TT> -mf -3s calc</TT>
<BR><BR>The compiler compiles<TT> calc.c(pp)</TT> for the Intel 32-bit &quot;flat&quot; memory model.&nbsp; The compiler will
generate 386 instructions based on 386 instruction timings using the stack-based argument passing convention.&nbsp; The resulting
code will be optimized for Intel 386 systems.&nbsp; Memory models are described in the chapter entitled <A HREF="#32Mbit_Memory_Models">32-bit Memory Models</A>.
&nbsp;Argument passing conventions are described in the chapter entitled <A HREF="#32Mbit_Assembly_Language_Considerations">32-bit Assembly Language Considerations</A>.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;</TT><B>compiler_name</B><TT> kwikdraw -4r -fpi87 -oaimxt</TT>
<BR><BR>The compiler processes<TT> kwikdraw.c(pp)</TT> producing 32-bit object code for an Intel 386-compatible system equipped
with a 387 numeric data processor.&nbsp; The compiler will generate 386 instructions based on 486 instruction timings using
the register-based argument passing convention.&nbsp; The resulting code will be highly optimized for Intel 486 systems.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;</TT><B>compiler_name</B><TT> ..\source\modabs -d2</TT>
<BR><BR>The compiler processes<TT> ..\source\modabs.c(pp)</TT> (a file in a directory which is adjacent to the current one).
&nbsp;The object file is placed in the current directory.&nbsp; Included with the object code and data is information on local
symbols and data types.&nbsp; The code generated is straight-forward, unoptimized code which can be readily debugged with
the Open Watcom Debugger.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set </TT><B>compiler_name</B><TT>=-i#\includes -mc</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;</TT><B>compiler_name</B><TT> \cprogs\grep.tst -fi=iomods.c</TT>
<BR><BR>The compiler processes the program contained in the file<TT> \cprogs\grep.tst.</TT>&nbsp; The file<TT> iomods.c</TT>
is included as if it formed part of the source input stream.&nbsp; The include search path and memory model options are defaults
each time the compiler is invoked.&nbsp; The memory model option could be overridden on the command line.&nbsp; After looking
for an &quot;include&quot; file in the current directory, the compiler will search each directory listed in the &quot;i&quot;
path.&nbsp; See the section entitled <A HREF="#Open_Watcom_CDCPP__include_File_Processing">Open Watcom C/C++ #include File Processing</A>
for more information.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;</TT><B>compiler_name</B><TT> grep -fo=..\obj\</TT>
<BR><BR>The compiler processes the program contained in the file<TT> grep.c(pp)</TT> which is located in the current directory.
&nbsp;The object file is placed in the directory<TT> ..\obj</TT> under the name<TT> grep.obj.</TT>
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;</TT><B>compiler_name</B><TT> -dDBG=1 grep -fo=..\obj\.dbo</TT>
<BR><BR>The compiler processes the program contained in the file<TT> grep.c(pp)</TT> which is located in the current directory.
&nbsp;The macro &quot;DBG&quot; is defined so that conditional debugging statements that have been placed in the source are
compiled.&nbsp; The object file is placed in the directory<TT> ..\obj</TT> and its filename extension will be &quot;.dbo&quot;
(instead of &quot;.obj&quot;).&nbsp; Selection of a different filename extension permits easy identification of object files
that have been compiled with debugging statements.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;</TT><B>compiler_name</B><TT> -g=GKS -s \gks\gopks</TT>
<BR><BR>The compiler generates code for<TT> gopks.c(pp)</TT> and places it into the &quot;GKS&quot; group.&nbsp; If the &quot;g&quot;
option had not been specified, the code would not have been placed in any group.&nbsp; Assume that this file contains the
definition of the routine<TT> gopengks</TT> as follows:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void far gopengks( int workstation, long int h )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>For a small code model, the routine<TT> gopengks</TT> must be defined in this file as<TT> far</TT> since it is placed
in another group.&nbsp; The &quot;s&quot; option is also specified to prevent a run-time call to the stack overflow check
routine which will be placed in a different code segment at link time.&nbsp; The<TT> gopengks</TT> routine must be prototyped
by C routines in other groups as
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void far gopengks( int workstation, long int h );</TT>
<BR><BR>since it will appear in a different code segment.
<H2 ID="Benchmarking_Hints"> Benchmarking Hints </H2>
<BR>The Open Watcom C/C++ compiler contains many options for controlling the code to be produced.&nbsp; It is impossible to
have a certain set of compiler options that will produce the absolute fastest execution times for all possible applications.
&nbsp;With that said, we will list the compiler options that we think will give the best execution times for most applications.
&nbsp;You may have to experiment with different options to see which combination of options generates the fastest code for
your particular application.
<BR><BR>The recommended options for generating the fastest 16-bit Intel code are:&nbsp; 
<DL>
<DT>Pentium Pro
<DD>-onatx -oh -oi+ -ei -zp8 -6 -fpi87 -fp6
<DT>Pentium
<DD>-onatx -oh -oi+ -ei -zp8 -5 -fpi87 -fp5
<DT>486
<DD>-onatx -oh -oi+ -ei -zp8 -4 -fpi87 -fp3
<DT>386
<DD>-onatx -oh -oi+ -ei -zp8 -3 -fpi87 -fp3
<DT>286
<DD>-onatx -oh -oi+ -ei -zp8 -2 -fpi87 -fp2
<DT>186
<DD>-onatx -oh -oi+ -ei -zp8 -1 -fpi87
<DT>8086
<DD>-onatx -oh -oi+ -ei -zp8 -0 -fpi87
</DL>
<BR>The recommended options for generating the fastest 32-bit Intel code are:&nbsp; 
<DL>
<DT>Pentium Pro
<DD>-onatx -oh -oi+ -ei -zp8 -6 -fp6
<DT>Pentium
<DD>-onatx -oh -oi+ -ei -zp8 -5 -fp5
<DT>486
<DD>-onatx -oh -oi+ -ei -zp8 -4 -fp3
<DT>386
<DD>-onatx -oh -oi+ -ei -zp8 -3 -fp3
</DL>
<BR>The &quot;oi+&quot; option is for C++ only.&nbsp; Under some circumstances, the &quot;ob&quot; and &quot;ol+&quot; optimizations
may also give better performance with 32-bit Intel code.
<BR><BR>Option &quot;on&quot; causes the compiler to replace floating-point divisions with multiplications by the reciprocal.
&nbsp;This generates faster code (multiplication is faster than division), but the result may not be the same because the
reciprocal may not be exactly representable.
<BR><BR>Option &quot;oe&quot; causes small user written functions to be expanded in-line rather than generating a call to
the function.&nbsp; Expanding functions in-line can further expose other optimizations that couldn't otherwise be detected
if a call was generated to the function.
<BR><BR>Option &quot;oa&quot; causes the compiler to relax alias checking.
<BR><BR>Option &quot;ot&quot; must be specified to cause the code generator to select code sequences which are faster without
any regard to the size of the code.&nbsp; The default is to select code sequences which strike a balance between size and
speed.
<BR><BR>Option &quot;ox&quot; is equivalent to &quot;obmiler&quot; and &quot;s&quot; which causes the compiler/code generator
to do branch prediction (&quot;ob&quot;), generate 387 instructions in-line for math functions such as sin, cos, sqrt (&quot;om&quot;),
expand intrinsic functions in-line (&quot;oi&quot;), perform loop optimizations (&quot;ol&quot;), expand small user functions
in-line (&quot;oe&quot;), reorder instructions to avoid pipeline stalls (&quot;or&quot;), and to not generate any stack overflow
checking (&quot;s&quot;).&nbsp; Option &quot;or&quot; is very important for generating fast code for the Pentium and Pentium
Pro processors.
<BR><BR>Option &quot;oh&quot; causes the compiler to attempt repeated optimizations (which can result in longer compiles but
more optimal code).
<BR><BR>Option &quot;oi+&quot; causes the C++ compiler to expand intrinsic functions in-line (just like &quot;oi&quot;) but
also sets the<B> inline_depth</B> to its maximum (255).&nbsp; By default,<B> inline_depth</B> is 3.&nbsp; The<B> inline_depth</B>
can also be changed by using the C++<TT> inline_depth</TT> pragma.
<BR><BR>Option &quot;ei&quot; causes the compiler to allocate at least an &quot;int&quot; for all enumerated types.
<BR><BR>Option &quot;zp8&quot; causes all data to be aligned on 8 byte boundaries.&nbsp; The default is &quot;zp2&quot; for
the 16-bit compiler and &quot;zp8&quot; for 32-bit compiler.&nbsp; If, for example, &quot;zp1&quot; packing was specified
then this would pack all data which would reduce the amount of data memory required but would require extra clock cycles to
access data that is not on an appropriate boundary.
<BR><BR>Options &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot; and &quot;6&quot;
emit Intel code sequences optimized for processor-specific instruction set features and timings.&nbsp; For 16-bit Intel applications,
the use of these options may limit the range of systems on which the application will run but there are execution performance
improvements.
<BR><BR>Options &quot;fp2&quot;, &quot;fp3&quot;, &quot;fp5&quot; and &quot;fp6&quot; emit Intel floating-point operations
targetted at specific features of the math coprocessor in the Intel series.&nbsp; For 16-bit Intel applications, the use of
these options may limit the range of systems on which the application will run but there are execution performance improvements.
<BR><BR>Option &quot;fpi87&quot; causes in-line Intel 80x87 numeric data processor instructions to be generated into the object
code for floating-point operations.&nbsp; Floating-point instruction emulation is not included so as to obtain the best floating-point
performance in 16-bit Intel applications.
<BR><BR>For 32-bit Intel applications, the use of the &quot;fp5&quot; option will give good performance on the Intel Pentium
but less than optimal performance on the 386 and 486.&nbsp; The use of the &quot;5&quot; option will give good performance
on the Pentium and minimal, if any, impact on the 386 and 486.&nbsp; Thus, the following set of options gives good overall
performance for the 386, 486 and Pentium processors.
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp; -onatx -oh -oi+ -ei -zp8 -5 -fp3
<H2 ID="Compiler_Diagnostics"> Compiler Diagnostics </H2>
<BR>If the compiler prints diagnostic messages to the screen, it will also place a copy of these messages in a file in your
current directory.&nbsp; The file will have the same file name as the source file and an extension of &quot;.err&quot;.&nbsp;
The compiler issues two types of diagnostic messages, namely warnings or errors.&nbsp; A warning message does not prevent
the production of an object file.&nbsp; However, error messages indicate that a problem is severe enough that it must be corrected
before the compiler will produce an object file.&nbsp; The error file is a handy reference when you wish to correct the errors
in the source file.
<BR><BR>Just to illustrate the diagnostic features of Open Watcom C/C++, we will modify the &quot;hello&quot; program in such
a way as to introduce some errors.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int main()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int x;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Hello world\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( y );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The equivalent C++ program follows:
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;iostream.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;iomanip.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int main()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int x;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; &quot;Hello world&quot; &lt;&lt; endl;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( y );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>In this example, we have added the lines:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int x;</TT>
<BR><BR>and
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; return( y );</TT>
<BR><BR>and changed the keyword<TT> void</TT> to<TT> int</TT> .
<BR><BR>We compile the program with the &quot;warning&quot; option.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;</TT><B>compiler_name</B><TT> hello -w3</TT>
<BR><BR>For the C program, the following output appears on the screen.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; hello.c(7): Error! E1011: Symbol 'y' has not been declared</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; hello.c(5): Warning! W202: Symbol 'x' has been defined, but not</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; referenced</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; hello.c: 8 lines, included 174, 1 warnings, 1 errors</TT>
<BR><BR>For the C++ program, the following output appears on the screen.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; hello.cpp(8): Error! E029: (col 13) symbol 'y' has not been declared</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; hello.cpp(9): Warning! W014: (col 1) no reference to symbol 'x'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; hello.cpp(9): Note! N392: (col 1) 'int x' in 'int main( void )'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; defined
in: hello.cpp(6) (col 9)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; hello.cpp: 9 lines, included 1628, 1 warning, 1 error</TT>
<BR><BR>Here we see an example of both types of messages.&nbsp; An error and a warning message have been issued.&nbsp; As
indicated by the error message, we require a declarative statement for the identifier<TT> y.</TT>&nbsp; The warning message
indicates that, while it is not a violation of the rules of C/C++ to define a variable without ever using it, we probably
did not intend to do so.&nbsp; Upon examining the program, we find that:
<OL>
<LI>the variable<TT> x</TT> should have been assigned a value, and
<LI>the variable<TT> y</TT> has probably been incorrectly typed and should have been entered as<TT> x.</TT>
</OL>
<H2 ID="Open_Watcom_CDCPP__include_File_Processing"> Open Watcom C/C++ #include File Processing </H2>
<BR>When using the<TT> #include</TT> preprocessor directive, a header is identified by a sequence of characters placed between
the &quot;&lt;&quot; and &quot;&gt;&quot; delimiters (e.g., &lt;file&gt;) and a source file is identified by a sequence of
characters enclosed by quotation marks (e.g., &quot;file&quot;).&nbsp; Open Watcom C/C++ makes a distinction between the use
of &quot;&lt;&gt;&quot; or quotation marks to surround the name of the file to be included.&nbsp; The search techniques for
header files and source files are slightly different.&nbsp; Consider the following example.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;&nbsp; /* a system header file */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &quot;stdio.h&quot;&nbsp; /* your own header or source file */</TT>
<BR><BR>You should use &quot;&lt;&quot; and &quot;&gt;&quot; when referring to standard or system header files and quotation
marks when referring to your own header and source files.
<BR><BR>The character sequence placed between the delimiters in an<TT> #include</TT> directive represents the name of the
file to be included.&nbsp; The file name may include drive, path, and extension.
<BR><BR>It is not necessary to include the drive and path specifiers in the file specification when the file resides on a
different drive or in a different directory.&nbsp; Open Watcom C/C++ provides a mechanism for looking up include files which
may be located in various directories and disks of the computer system.&nbsp; Open Watcom C/C++ searches directories for header
and source files in the following order (the search stops once the file has been located):&nbsp; 
<OL>
<LI>If the file specification enclosed in quotation marks (&quot;file-spec&quot;) or angle brackets (&lt;file-spec&gt;) contains
the complete drive and path specification, that file is included (provided it exists).&nbsp; No other searching is performed.
&nbsp;The drive need not be specified in which case the current drive is assumed.
<LI>Next, if the &quot;xx&quot; option was not specified and the file specification is enclosed in quotation marks then the
current directory is searched.
<LI>Next, if the file specification is enclosed in quotation marks, the directory of the file containing the<TT> #include</TT>
directive is searched.
<LI>Next, if the &quot;xx&quot; option was not specified and the current file is also an<TT> #include</TT> file then the directory
of the parent file is searched next.&nbsp; This search continues recursively through all the nested<TT> #include</TT> files
until the original source file's directory is searched.
<LI>Next, if the file specification enclosed in quotation marks (&quot;file-spec&quot;) or in angle brackets (&lt;file-spec&gt;),
each directory listed in the &quot;i&quot; path is searched (in the order that they were specified).
<LI>Next, if the &quot;x&quot; option was not specified, each directory listed in the<B> &lt;os&gt;_INCLUDE</B> environment
variable is searched (in the order that they were specified).&nbsp; The environment variable name is constructed from the
current build target name.&nbsp; The default build targets are:
<DL>
<DT>DOS
<DD>when the host operating system is DOS,
<DT>OS2
<DD>when the host operating system is OS/2,
<DT>NT
<DD>when the host operating system is Windows NT/95, or
<DT>QNX
<DD>when the host operating system is QNX.
<DT>LINUX
<DD>when the host operating system is Linux.
</DL>
<BR>For example, the environment variable<B> OS2_INCLUDE</B> will be searched if the build target is &quot;OS2&quot;.&nbsp;
The build target would be OS/2 if:
<OL>
<LI>the host operating system is OS/2 and the &quot;bt&quot; option was not specified, or
<LI>the &quot;bt=OS2&quot; option was explicitly specified.
</OL>
<LI>Next, if the &quot;x&quot; option was not specified, each directory listed in the<B> INCLUDE</B> environment variable
is searched (in the order that they were specified).
<LI>Finally, if the &quot;xx&quot; option was not specified and the file specification is enclosed in quotation marks then
an adjacent &quot;H&quot; directory (i.e.,<TT> ..\h</TT>) is searched if it exists.
</OL>
<BR>In the above example,<TT> &lt;stdio.h&gt;</TT> and<TT> &quot;stdio.h&quot;</TT> could refer to two different files if
there is a<TT> stdio.h</TT> in the current directory and one in the Open Watcom C/C++ include file directory<TT> (\WATCOM\H)</TT>
and the current directory is not listed in an &quot;i&quot; path or the<B> INCLUDE</B> environment variable.
<BR><BR>The compiler will search the directories listed in &quot;i&quot; paths (see description of the &quot;i&quot; option)
and the<B> INCLUDE</B> environment variable in a manner analogous to that which the operating system shell will use when searching
for programs by using the<B> PATH</B> environment variable.
<BR><BR>The &quot;SET&quot; command is used to define an<B> INCLUDE</B> environment variable that contains a list of directories.
&nbsp;A command of the form
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SET INCLUDE=[d:]path;[d:]path...</TT>
<BR><BR>is issued before running Open Watcom C/C++ the first time.&nbsp; The brackets indicate that the drive &quot;d:&quot;
is optional and the ellipsis indicates that any number of paths may be specified.&nbsp; For Windows NT, use the &quot;System&quot;
icon in the Control Panel to define environment variables.
<BR><BR>We illustrate the use of the<TT> #include</TT> directive in the following example.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;time.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;dos.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &quot;common.c&quot;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int main()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; initialize();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; update_files();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; create_report();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; finalize();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &quot;part1.c&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &quot;part2.c&quot;</TT>
<BR><BR>If the above text is stored in the source file<TT> report.c</TT> in the current directory then we might issue the
following commands to compile the application.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;rem -- Two places to look for include files</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set include=c:\watcom\h;b:\headers</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;rem -- Now compile application specifying a</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;rem&nbsp;&nbsp;&nbsp; third location for include files</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;</TT><B>compiler_name</B><TT> report -fo=..\obj\ -i=..\source</TT>
<BR><BR>In the above example, the &quot;SET&quot; command is used to define the<B> INCLUDE</B> environment variable.&nbsp;
It specifies that the<TT> \watcom\h</TT> directory (of the &quot;C&quot; disk) and the<TT> \headers</TT> directory (a directory
of the &quot;B&quot; disk) are to be searched.
<BR><BR>The Open Watcom C/C++ &quot;i&quot; option defines a third place to search for include files.&nbsp; The advantage
of the<B> INCLUDE</B> environment variable is that it need not be specified each time the compiler is run.
<H2 ID="Open_Watcom_CDCPP_Preprocessor"> Open Watcom C/C++ Preprocessor </H2>
<BR>The Open Watcom C/C++ preprocessor forms an integral part of Open Watcom C/C++.&nbsp; When any form of the &quot;p&quot;
option is specified, only the preprocessor is invoked.&nbsp; No code is generated and no object file is produced.&nbsp; The
output of the preprocessor is written to the standard output file, although it can also be redirected to a file using the
&quot;fo&quot; option.&nbsp; Suppose the following C/C++ program is contained in the file<TT> msgid.c.</TT>
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define _IBMPC 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define _IBMPS2 1</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #if _TARGET == _IBMPS2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char *SysId = { &quot;IBM PS/2&quot; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char *SysId = { &quot;IBM PC&quot; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #endif</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* Return pointer to System Identification */</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char *GetSysId()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( SysId );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>We can use the Open Watcom C/C++ preprocessor to generate the C/C++ code that would actually be compiled by the compiler
by issuing the following command.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;</TT><B>compiler_name</B><TT> msgid -plc -fo -d_TARGET=_IBMPS2</TT>
<BR><BR>The file<TT> msgid.i</TT> will be created and will contain the following C/C++ code.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #line 1 &quot;msgid.c&quot;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char *SysId = { &quot;IBM PS/2&quot; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #line 9 &quot;msgid.c&quot;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /* Return pointer to System Identification */</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char *GetSysId()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( SysId );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>Note that the file<TT> msgid.i</TT> can be used as input to the compiler.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;</TT><B>compiler_name</B><TT> msgid.i</TT>
<BR><BR>Since<TT> #line</TT> directives are present in the file, the compiler can issue error messages in terms of the original
source file line numbers.
<H2 ID="Open_Watcom_CDCPP_Predefined_Macros"> Open Watcom C/C++ Predefined Macros </H2>
<BR>In addition to the standard ISO-defined macros supported by the Open Watcom C/C++ compilers, several additional system-dependent
macros are also defined.&nbsp; These are described in this section.&nbsp; See the<B><I> Open Watcom C Language Reference</I></B>
manual for a description of the standard macros.
<BR><BR>The Open Watcom C/C++ compilers run on various host operating systems including DOS, OS/2, Windows NT, Windows 95
and QNX.&nbsp; Any of the supported host operating systems can be used to develop applications for a number of target systems.
&nbsp;By default, the target operating system for the application is the same as the host operating system unless some option
or combination of options is specified.&nbsp; For example, DOS applications are built on DOS by default, OS/2 applications
are built on OS/2 by default, and so on.&nbsp; But the flexibility is there to build applications for other operating systems/environments.
<BR><BR>The macros described below may be used to identify the target system for which the application is being compiled.
&nbsp;(Note:&nbsp; In several places in the following text, a pair of underscore characters appears as __ which resembles
a single, elongated underscore.)
<BR><BR>The Open Watcom C/C++ compilers support both 16-bit and 32-bit application development.&nbsp; The following macros
are defined for 16-bit and 32-bit target systems.&nbsp; 
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16-bit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32-bit</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ========&nbsp;&nbsp;&nbsp; ========</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; __X86__&nbsp;&nbsp;&nbsp;&nbsp; __X86__</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; __I86__&nbsp;&nbsp;&nbsp;&nbsp; __386__</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; M_I86&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; M_I386</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _M_I86&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _M_I386</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _M_IX86&nbsp;&nbsp;&nbsp;&nbsp; _M_IX86</TT>
<BR><BR><B>Notes:</B>
<OL>
<LI>The<TT> __X86__</TT> identifies the target as an Intel environment.
<LI>The<TT> __I86__</TT> ,<TT> M_I86</TT> and<TT> _M_I86</TT> macros identify the target as a 16-bit Intel environment.
<LI>The<TT> __386__</TT> ,<TT> M_I386</TT> and<TT> _M_I386</TT> macros identify the target as a 32-bit Intel environment.
<LI>The<TT> _M_IX86</TT> macro is identically equal to 100 times the architecture compiler option value (-0, -1, -2, -3, -4,
-5, etc.).&nbsp; If &quot;-5&quot; (Pentium instruction timings) was specified as a compiler option, then the value of<TT>
_M_IX86</TT> would be 500.
</OL>
<BR>The Open Watcom C/C++ compilers support application development for a variety of operating systems.&nbsp; The following
macros are defined for particular target operating systems.&nbsp; 
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Target&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Macros</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ======&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ======================================</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DOS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __DOS__, _DOS, MSDOS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; OS/2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __OS2__</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; QNX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __QNX__, __UNIX__</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Netware&nbsp;&nbsp;&nbsp;&nbsp; __NETWARE__, __NETWARE_386__</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; NT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __NT__</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Windows&nbsp;&nbsp;&nbsp;&nbsp; __WINDOWS__, _WINDOWS, __WINDOWS_386__</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Linux&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __LINUX__, __UNIX__</TT>
<BR><BR><B>Notes:</B>
<OL>
<LI>The<TT> __DOS__</TT> ,<TT> _DOS</TT> and<TT> MSDOS</TT> macros are defined when the build target is &quot;DOS&quot; (16-bit
DOS or 32-bit extended DOS).
<LI>The<TT> __OS2__</TT> macro is defined when the build target is &quot;OS2&quot; (16-bit or 32-bit OS/2).
<LI>The<TT> __QNX__</TT> and<TT> __UNIX__</TT> macros are defined when the build target is &quot;QNX&quot; (16-bit or 32-bit
QNX).
<LI>The<TT> __NETWARE__</TT> and<TT> __NETWARE_386__</TT> macros are defined when the build target is &quot;NETWARE&quot;
(Novell NetWare).
<LI>The<TT> __NT__</TT> macro is defined when the build target is &quot;NT&quot; (Windows NT and Windows 95).
<LI>The<TT> __WINDOWS__</TT> macro is defined when the build target is &quot;WINDOWS&quot; or one of the &quot;zw&quot;, &quot;zW&quot;,
&quot;zWs&quot; options is specified (identifies the target operating system as 16-bit Windows or 32-bit extended Windows
but not Windows NT or Windows 95).
<LI>The<TT> _WINDOWS</TT> macro is defined when the build target is &quot;WINDOWS&quot; or one of the &quot;zw&quot;, &quot;zW&quot;,
&quot;zWs&quot; options is specified and you are using a 16-bit compiler (identifies the target operating system as 16-bit
Windows).
<LI>The<TT> __WINDOWS_386__</TT> macro is defined when the build target is &quot;WINDOWS&quot; or the &quot;zw&quot; option
is specified and you are using a 32-bit compiler (identifies the target operating system as 32-bit extended Windows).
<LI>The<TT> __LINUX__</TT> and<TT> __UNIX__</TT> macros are defined when the build target is &quot;LINUX&quot; (32-bit Linux).
</OL>
<BR>The following macros are defined for the indicated options.&nbsp; 
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Option&nbsp;&nbsp;&nbsp; Macro</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ====== ==================</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; bm&nbsp;&nbsp;&nbsp;&nbsp; _MT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; br&nbsp;&nbsp;&nbsp;&nbsp; _DLL</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; fpi&nbsp;&nbsp;&nbsp; __FPI__</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; fpi87&nbsp; __FPI__</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; j&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __CHAR_SIGNED__</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; oi&nbsp;&nbsp;&nbsp;&nbsp; __INLINE_FUNCTIONS__</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; xr&nbsp;&nbsp;&nbsp;&nbsp; _CPPRTTI (C++ only)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; xs&nbsp;&nbsp;&nbsp;&nbsp; _CPPUNWIND (C++ only)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; xss&nbsp;&nbsp;&nbsp; _CPPUNWIND (C++ only)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; xst&nbsp;&nbsp;&nbsp; _CPPUNWIND (C++ only)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; za&nbsp;&nbsp;&nbsp;&nbsp; NO_EXT_KEYS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; zw&nbsp;&nbsp;&nbsp;&nbsp; __WINDOWS__</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; zW&nbsp;&nbsp;&nbsp;&nbsp; __WINDOWS__</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; zWs&nbsp;&nbsp;&nbsp; __WINDOWS__</TT>
<BR><BR>The following memory model macros are defined for the indicated memory model options.&nbsp; 
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Option&nbsp;&nbsp;&nbsp;&nbsp; All&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16-bit only
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32-bit only</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ====== =========== =================&nbsp;&nbsp;&nbsp; =================</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; mf&nbsp;&nbsp;&nbsp;&nbsp; __FLAT__&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _M_386FM&nbsp; M_386FM</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ms&nbsp;&nbsp;&nbsp;&nbsp; __SMALL__&nbsp;&nbsp; _M_I86SM&nbsp; M_I86SM&nbsp;&nbsp;&nbsp;
_M_386SM&nbsp; M_386SM</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; mm&nbsp;&nbsp;&nbsp;&nbsp; __MEDIUM__&nbsp; _M_I86MM&nbsp; M_I86MM&nbsp;&nbsp;&nbsp; _M_386MM
&nbsp;M_386MM</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; mc&nbsp;&nbsp;&nbsp;&nbsp; __COMPACT__ _M_I86CM&nbsp; M_I86CM&nbsp;&nbsp;&nbsp; _M_386CM
&nbsp;M_386CM</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ml&nbsp;&nbsp;&nbsp;&nbsp; __LARGE__&nbsp;&nbsp; _M_I86LM&nbsp; M_I86LM&nbsp;&nbsp;&nbsp;
_M_386LM&nbsp; M_386LM</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; mh&nbsp;&nbsp;&nbsp;&nbsp; __HUGE__&nbsp;&nbsp;&nbsp; _M_I86HM&nbsp; M_I86HM</TT>
<BR><BR>The following macros indicate which compiler is compiling the C/C++ source code.
<DL>
<DT>__cplusplus
<DD>Open Watcom C++ predefines the macro<TT> __cplusplus</TT> to identify the compiler as a C++ compiler.
<DT>__WATCOMC__
<DD>Open Watcom C/C++ predefines the macro<TT> __WATCOMC__</TT> to identify the compiler as one of the Open Watcom C/C++ compilers.
<BR><BR>The value of the macro depends on the version number of the compiler.&nbsp; The value is 100 times the version number
(version 8.5 yields 850, version 9.0 yields 900, etc.).&nbsp; Note that for Open Watcom 1.0, the value of this macro is 1200,
for Open Watcom 1.1 it is 1210 etc.
<DT>__WATCOM_CPLUSPLUS__
<DD>Open Watcom C++ predefines the macro<TT> __WATCOM_CPLUSPLUS__</TT> to identify the compiler as one of the Open Watcom C++
compilers.
<BR><BR>The value of the macro depends on the version number of the compiler.&nbsp; The value is 100 times the version number
(version 10.0 yields 1000, version 10.5 yields 1050, etc.).&nbsp; Note that for Open Watcom 1.0, the value of this macro is
1200, for Open Watcom 1.1 it is 1210 etc.
</DL>
<BR>The following macros are defined for compatibility with Microsoft.
<DL>
<DT>__CPPRTTI
<DD>Open Watcom C++ predefines the<TT> __CPPRTTI</TT> macro to indicate that C++ Run-Time Type Information (RTTI) is in force.
&nbsp;This macro is predefined if the Open Watcom C++ &quot;xr&quot; compile option is specified and is not defined otherwise.
<DT>__CPPUNWIND
<DD>Open Watcom C++ predefines the<TT> __CPPUNWIND</TT> macro to indicate that C++ exceptions supported.&nbsp; This macro is predefined
if any of the Open Watcom C++ &quot;xs&quot;, &quot;xss&quot; or &quot;xst&quot; compile options are specified and is not
defined otherwise.
<DT>_INTEGRAL_MAX_BITS
<DD>Open Watcom C/C++ predefines the<TT> _INTEGRAL_MAX_BITS</TT> macro to indicate that maximum number of bits supported in an
integral type (see the description of the &quot;__int64&quot; keyword in the next section).&nbsp; Its value is 64 currently.
<DT>_PUSHPOP_SUPPORTED
<DD>Open Watcom C/C++ predefines the<TT> _PUSHPOP_SUPPORTED</TT> macro to indicate that<TT> #pragma pack(push)</TT> and<TT> #pragma
pack(pop)</TT> are supported.
<DT>_STDCALL_SUPPORTED
<DD>Open Watcom C/C++ predefines the<TT> _STDCALL_SUPPORTED</TT> macro to indicate that the standard 32-bit Win32 calling convention
is supported.
</DL>
<BR>The following table summarizes the predefined macros supported by the compilers and the values that the respective compilers
assign to them.&nbsp; A &quot;yes&quot; under the column means that the compiler supports the macro with the indicated value.
&nbsp;Note that the C and C++ compilers sometime support the same macro but with different values (including no value which
means the symbol is defined without a value).
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Predefined Macro&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; Supported by Compiler</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and Setting&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; wcc&nbsp;&nbsp;&nbsp;&nbsp; wcc386&nbsp; wpp&nbsp;&nbsp;&nbsp;&nbsp; wpp386&nbsp; note</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; --------------------------- ------&nbsp; ------&nbsp; ------&nbsp; ------ ---------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; __386__=1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; Yes</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; __3R__=1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Yes</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _based=__based&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp; extension</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _cdecl=__cdecl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp; extension</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; cdecl=__cdecl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp; extension</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; __cplusplus=1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;
&nbsp; Yes</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _CPPRTTI=1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _CPPUNWIND=1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;
&nbsp;&nbsp; Yes</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _export=__export&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp; extension</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _far16=__far16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp; extension</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _far=__far&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;
extension</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; far=__far&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;
extension</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _fastcall=__fastcall&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;
&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp; extension</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; __FLAT__=1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; Yes</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _fortran=__fortran&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Yes
&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp; extension</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; fortran=__fortran&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp; extension</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; __FPI__=1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _huge=__huge&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp; extension</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; huge=__huge&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp; extension</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; __I86__=1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Yes</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _inline=__inline&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp; extension</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _INTEGRAL_MAX_BITS=64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;
&nbsp;Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _interrupt=__interrupt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp;
Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp; extension</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; interrupt=__interrupt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;
&nbsp;Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp; extension</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _loadds=__loadds&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp; extension</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _M_386FM=1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; Yes</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; M_386FM=1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp; extension</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _M_I386=1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; Yes</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; M_I386=1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp; extension</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _M_I86=1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Yes</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; M_I86=1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Yes
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; extension</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _M_I86SM=1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Yes</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; M_I86SM=1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; extension</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _M_IX86=0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Yes</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _M_IX86=500&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; Yes</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _near=__near&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp; extension</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; near=__near&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp; extension</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; __NT__=1 (on Win32 platform)&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp;
Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _pascal=__pascal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp; extension</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; pascal=__pascal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp; extension</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _saveregs=__saveregs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;
&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp; extension</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _segment=__segment&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Yes
&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp; extension</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _segname=__segname&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Yes
&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp; extension</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _self=__self&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp; extension</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; __SMALL__=1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Yes</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SOMDLINK=__far&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; extension</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SOMDLINK=_Syscall&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Yes
&nbsp;extension</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SOMLINK=__cdecl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;Yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; extension</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SOMLINK=_Syscall&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Yes&nbsp; extension</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _STDCALL_SUPPORTED=1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Yes</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; __SW_0=1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Yes</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; __SW_3R=1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; Yes</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; __SW_5=1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Yes</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; __SW_FP287=1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Yes</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; __SW_FP2=1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Yes</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; __SW_FP387=1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Yes</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; __SW_FP3=1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Yes</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; __SW_FPI=1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; __SW_MF=1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; Yes</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; __SW_MS=1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Yes</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; __SW_ZDP=1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; __SW_ZFP=1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; __SW_ZGF=1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; Yes</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; __SW_ZGP=1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Yes</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _stdcall=__stdcall&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Yes
&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp; extension</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _syscall=__syscall&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Yes
&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp; extension</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; __WATCOM_CPLUSPLUS__=2000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; __WATCOMC__=2000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; __X86__=1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes&nbsp;&nbsp;&nbsp;&nbsp; Yes</TT>
<BR><BR>Note:&nbsp; &quot;extension&quot; mean it is old extension macros (non-ISO compliant names).&nbsp; Thay are suppressed
by following options:&nbsp; -zam, -za, -zA
<H2 ID="Open_Watcom_CDCPP_Extended_Keywords"> Open Watcom C/C++ Extended Keywords </H2>
<BR>Open Watcom C/C++ supports the use of some special keywords to describe system dependent attributes of functions and other
object names.&nbsp; These attributes are inspired by the Intel processor architecture and the plethora of function calling
conventions in use by compilers for this architecture.&nbsp; In keeping with the ISO C and C++ language standards, Open Watcom
C/C++ uses the double underscore (i.e., &quot;__&quot;) or single underscore followed by uppercase letter (e.g., &quot;_S&quot;)
prefix with these keywords.&nbsp; To support compatibility with other C/C++ compilers, alternate forms of these keywords are
also supported through predefined macros.
<DL>
<DT>__near
<DD>Open Watcom C/C++ supports the<TT> __near</TT> keyword to describe functions and other object names that are in near memory
and pointers to near objects.
<BR><BR>Open Watcom C/C++ predefines the macros<TT> near</TT> and<TT> _near</TT> to be equivalent to the<TT> __near</TT> keyword.
<DT>__far
<DD>Open Watcom C/C++ supports the<TT> __far</TT> keyword to describe functions and other object names that are in far memory
and pointers to far objects.
<BR><BR>Open Watcom C/C++ predefines the macros<TT> far</TT> ,<TT> _far</TT> and<TT> SOMDLINK</TT> (16-bit only) to be equivalent
to the<TT> __far</TT> keyword.
<DT>__huge
<DD>Open Watcom C/C++ supports the<TT> __huge</TT> keyword to describe functions and other object names that are in huge memory
and pointers to huge objects.&nbsp; The 32-bit compilers treat these as equivalent to far objects.
<BR><BR>Open Watcom C/C++ predefines the macros<TT> huge</TT> and<TT> _huge</TT> to be equivalent to the<TT> __huge</TT> keyword.
<DT>__based
<DD>Open Watcom C/C++ supports the<TT> __based</TT> keyword to describe pointers to objects that appear in other segments or the
objects themselves.&nbsp; See the section entitled <A HREF="#Based_Pointers">Based Pointers</A> for an explanation of the<TT>
__based</TT> keyword.
<BR><BR>Open Watcom C/C++ predefines the macro<TT> _based</TT> to be equivalent to the<TT> __based</TT> keyword.
<DT>__segment
<DD>Open Watcom C/C++ supports the<TT> __segment</TT> keyword which is used when describing objects of type segment.&nbsp; See
the section entitled <A HREF="#Based_Pointers">Based Pointers</A> for an explanation of the<TT> __segment</TT> keyword.
<BR><BR>Open Watcom C/C++ predefines the macro<TT> _segment</TT> to be equivalent to the<TT> __segment</TT> keyword.
<DT>__segname
<DD>Open Watcom C/C++ supports the<TT> __segname</TT> keyword which is used when describing segname constant based pointers or
objects.&nbsp; See the section entitled <A HREF="#Based_Pointers">Based Pointers</A> for an explanation of the<TT> __segname</TT>
keyword.
<BR><BR>Open Watcom C/C++ predefines the macro<TT> _segname</TT> to be equivalent to the<TT> __segname</TT> keyword.
<DT>__self
<DD>Open Watcom C/C++ supports the<TT> __self</TT> keyword which is used when describing self based pointers.&nbsp; See the section
entitled <A HREF="#Based_Pointers">Based Pointers</A> for an explanation of the<TT> __self</TT> keyword.
<BR><BR>Open Watcom C/C++ predefines the macro<TT> _self</TT> to be equivalent to the<TT> __self</TT> keyword.
<DT>__restrict
<DD>Open Watcom C/C++ provides the<B><I> __restrict</I></B> type qualifier as an alternative to the ISO C99<B><I> restrict</I></B>
keyword; it is supported even when C99 keywords aren't visible.&nbsp; This type qualifier is used as an optimization hint.
&nbsp;Any object accessed through a<B><I> restrict</I></B> qualified pointer may only be accessed through that pointer and
the compiler may assume that there will be no aliasing.
<DT>_Packed
<DD>Open Watcom C/C++ supports the<TT> _Packed</TT> keyword which is used when describing a structure.&nbsp; If specified before
the<B><I> struct</I></B> keyword, the compiler will force the structure to be packed (no alignment, no gaps) regardless of
the setting of the command-line option or the<B><I> #pragma</I></B> controlling the alignment of members.
<DT>__cdecl
<DD>Open Watcom C/C++ supports the<TT> __cdecl</TT> keyword to describe C functions that are called using a special convention.
<BR><BR><B>Notes:</B>
<OL>
<LI>All symbols are preceded by an underscore character.
<LI>Arguments are pushed on the stack from right to left.&nbsp; That is, the last argument is pushed first.&nbsp; The calling
routine will remove the arguments from the stack.
<LI>Floating-point values are returned in the same way as structures.&nbsp; When a structure is returned, the called routine
returns a pointer in register AX/EAX to the return value which is stored in the data segment (DGROUP).
<LI>For the 16-bit compiler, registers AX, BX, CX and DX, and segment register ES are not saved and restored when a call is
made.
<LI>For the 32-bit compiler, registers EAX, ECX and EDX are not saved and restored when a call is made.
</OL>
<BR>Open Watcom C/C++ predefines the macros<TT> cdecl</TT> ,<TT> _cdecl</TT> ,<TT> _Cdecl</TT> and<TT> SOMLINK</TT> (16-bit
only) to be equivalent to the<TT> __cdecl</TT> keyword.
<DT>__pascal
<DD>Open Watcom C/C++ supports the<TT> __pascal</TT> keyword to describe Pascal functions that are called using a special convention
described by a pragma in the &quot;stddef.h&quot; header file.
<BR><BR>Open Watcom C/C++ predefines the macros<TT> pascal</TT> ,<TT> _pascal</TT> and<TT> _Pascal</TT> to be equivalent to
the<TT> __pascal</TT> keyword.
<DT>__fortran
<DD>Open Watcom C/C++ supports the<TT> __fortran</TT> keyword to describe functions that are called from FORTRAN.&nbsp; It converts
the name to uppercase letters and suppresses the &quot;_&quot; which is appended to the function name for certain calling
conventions.
<BR><BR>Open Watcom C/C++ predefines the macros<TT> fortran</TT> and<TT> _fortran</TT> to be equivalent to the<TT> __fortran</TT>
keyword.
<DT>__interrupt
<DD>Open Watcom C/C++ supports the<TT> __interrupt</TT> keyword to describe a function that is an interrupt handler.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;i86.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void __interrupt int10( union INTPACK r )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The code generator will emit instructions to save all registers.&nbsp; The registers are saved on the stack in a specific
order so that they may be referenced using the &quot;INTPACK&quot; union as shown in the DOS example above.&nbsp; The code
generator will emit instructions to establish addressability to the program's data segment since the DS segment register contents
are unpredictable.&nbsp; The function will return using an &quot;IRET&quot; (16-bit) or &quot;IRETD&quot; (32-bit) (interrupt
return) instruction.
<BR><BR>Open Watcom C/C++ predefines the macros<TT> interrupt</TT> and<TT> _interrupt</TT> to be equivalent to the<TT> __interrupt</TT>
keyword.
<DT>__declspec( modifier )
<DD>Open Watcom C/C++ supports the<TT> __declspec</TT> keyword for compatibility with Microsoft C++.&nbsp; The<TT> __declspec</TT>
keyword is used to modify storage-class attributes of functions and/or data.&nbsp; There are several modifiers that can be
specified with the<TT> __declspec</TT> keyword:<TT>&nbsp; thread</TT> ,<TT> naked</TT> ,<TT> noreturn</TT> ,<TT> farss</TT>
,<TT> dllimport</TT> ,<TT> dllexport</TT> ,<TT> __pragma( &quot;string&quot; )</TT> ,<TT> __cdecl</TT> ,<TT> __pascal</TT>
,<TT> __fortran</TT> ,<TT> __stdcall</TT> , and<TT> __syscall</TT> .&nbsp; These attributes are a property only of the declaration
of the object or function to which they are applied.&nbsp; Unlike the<TT> __near</TT> and<TT> __far</TT> keywords, which actually
affect the type of object or function (in this case, 2- and 4-byte addresses), these storage-class attributes do not redefine
the type attributes of the object itself.&nbsp; The<TT> __pragma</TT> modifier is supported by Open Watcom C++ only.&nbsp;
The<TT> thread</TT> attribute affects data and objects only.&nbsp; The<TT> naked</TT> ,<TT> noreturn</TT> ,<TT> farss</TT>
,<TT> __pragma</TT> ,<TT> __cdecl</TT> ,<TT> __pascal</TT> ,<TT> __fortran</TT> ,<TT> __stdcall</TT> , and<TT> __syscall</TT>
attributes affect functions only.&nbsp; The<TT> dllimport</TT> and<TT> dllexport</TT> attributes affect functions, data, and
objects.&nbsp; For more information on the<TT> __declspec</TT> keyword, please see the section entitled <A HREF="#The___declspec_Keyword">The __declspec Keyword</A>.
<DT>__export
<DD>Open Watcom C/C++ supports the<TT> __export</TT> keyword to describe functions and other object names that are to be exported
from a Microsoft Windows DLL, OS/2 DLL, or Netware NLM.&nbsp; See also the description of the &quot;zu&quot; option.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void __export _Setcolor( int color )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>Open Watcom C/C++ predefines the macro<TT> _export</TT> to be equivalent to the<TT> __export</TT> keyword.
<DT>__loadds
<DD>Open Watcom C/C++ supports the<TT> __loadds</TT> keyword to describe functions that require specific loading of the DS register
to establish addressability to the function's data segment.&nbsp; This keyword is useful in describing a function that will
be placed in a Microsoft Windows or OS/2 1.x Dynamic Link Library (DLL).&nbsp; See also the description of the &quot;nd&quot;
and &quot;zu&quot; options.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void __export __loadds _Setcolor( int color )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>If the function in an OS/2 1.x Dynamic Link Library requires access to private data, the data segment register must
be loaded with an appropriate value since it will contain the DS value of the calling application upon entry to the function.
<BR><BR>Open Watcom C/C++ predefines the macro<TT> _loadds</TT> to be equivalent to the<TT> __loadds</TT> keyword.
<DT>__saveregs
<DD>Open Watcom C/C++ recognizes the<TT> __saveregs</TT> keyword which is an attribute used by C/C++ compilers to describe a function
that must save and restore all registers.
<BR><BR>Open Watcom C/C++ predefines the macro<TT> _saveregs</TT> to be equivalent to the<TT> __saveregs</TT> keyword.
<DT>__stdcall
<DD>(32-bit only) The<TT> __stdcall</TT> keyword may be used with function definitions, and indicates that the 32-bit Win32 calling
convention is to be used.
<BR><BR><B>Notes:</B>
<OL>
<LI>All symbols are preceded by an underscore character.
<LI>All C symbols (extern &quot;C&quot; symbols in C++) are suffixed by &quot;@nnn&quot; where &quot;nnn&quot; is the sum
of the argument sizes (each size is rounded up to a multiple of 4 bytes so that char and short are size 4).&nbsp; When the
argument list contains &quot;...&quot;, the &quot;@nnn&quot; suffix is omitted.
<LI>Arguments are pushed on the stack from right to left.&nbsp; That is, the last argument is pushed first.&nbsp; The called
routine will remove the arguments from the stack.
<LI>When a structure is returned, the caller allocates space on the stack.&nbsp; The address of the allocated space will be
pushed on the stack immediately before the call instruction.&nbsp; Upon returning from the call, register EAX will contain
address of the space allocated for the return value.&nbsp; Floating-point values are returned in 80x87 register ST(0).
<LI>Registers EAX, ECX and EDX are not saved and restored when a call is made.
</OL>
<DT>__syscall
<DD>(32-bit only) The<TT> __syscall</TT> keyword may be used with function definitions, and indicates that the calling convention
used is compatible with functions provided by 32-bit OS/2.
<BR><BR><B>Notes:</B>
<OL>
<LI>Symbols names are not modified, that is, they are not adorned with leading or trailing underscores.
<LI>Arguments are pushed on the stack from right to left.&nbsp; That is, the last argument is pushed first.&nbsp; The calling
routine will remove the arguments from the stack.
<LI>When a structure is returned, the caller allocates space on the stack.&nbsp; The address of the allocated space will be
pushed on the stack immediately before the call instruction.&nbsp; Upon returning from the call, register EAX will contain
address of the space allocated for the return value.&nbsp; Floating-point values are returned in 80x87 register ST(0).
<LI>Registers EAX, ECX and EDX are not saved and restored when a call is made.
</OL>
<BR>Open Watcom C/C++ predefines the macros<TT> _syscall</TT> ,<TT> _System</TT> ,<TT> SOMLINK</TT> (32-bit only) and<TT>
SOMDLINK</TT> (32-bit only) to be equivalent to the<TT> __syscall</TT> keyword.
<DT>__far16
<DD>(32-bit only) Open Watcom C/C++ recognizes the<TT> __far16</TT> keyword which can be used to define far 16-bit (far16) pointers
(16-bit selector with 16-bit offset) or far 16-bit function prototypes.&nbsp; This keyword can be used under 32-bit OS/2 to
call 16-bit functions from your 32-bit flat model program.&nbsp; Integer arguments will automatically be converted to 16-bit
integers, and 32-bit pointers will be converted to far16 pointers before calling a special thunking layer to transfer control
to the 16-bit function.
<BR><BR>Open Watcom C/C++ predefines the macros<TT> _far16</TT> and<TT> _Far16</TT> to be equivalent to the<TT> __far16</TT>
keyword.&nbsp; This keyword is compatible with Microsoft C.
<BR><BR>In the OS/2 operating system (version 2.0 or higher), the first 512 megabytes of the 4 gigabyte segment referenced
by the DS register is divided into 8192 areas of 64K bytes each.&nbsp; A far16 pointer consists of a 16-bit selector referring
to one of the 64K byte areas, and a 16-bit offset into that area.
<BR><BR>A pointer declared as,
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp; [type] __far16 *name;
<BR><BR>defines an object that is a far16 pointer.&nbsp; If such a pointer is accessed in the 32-bit environment, the compiler
will generate the necessary code to convert between the far16 pointer and a &quot;flat&quot; 32-bit pointer.
<BR><BR>For example, the declaration,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char __far16 *bufptr;</TT>
<BR><BR>declares the object<TT> bufptr</TT> to be a far16 pointer to<B><I> char</I></B> .
<BR><BR>A function declared as,
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp; [type] __far16 func( [arg_list] );
<BR><BR>declares a 16-bit function.&nbsp; Any calls to such a function from the 32-bit environment will cause the compiler
to convert any 32-bit pointer arguments to far16 pointers, and any<B><I> int</I></B> arguments from 32 bits to 16 bits.&nbsp;
(In the 16-bit environment, an object of type<B><I> int</I></B> is only 16 bits.) Any return value from the function will
have its return value converted in an appropriate manner.
<BR><BR>For example, the declaration,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char * __far16 Scan( char *buffer, int len, short err );</TT>
<BR>declares the 16-bit function<TT> Scan.</TT>&nbsp; When this function is called from the 32-bit environment, the<TT> buffer</TT>
argument will be converted from a flat 32-bit pointer to a far16 pointer (which, in the 16-bit environment, would be declared
as<TT> char __far *.</TT>&nbsp; The<TT> len</TT> argument will be converted from a 32-bit integer to a 16-bit integer.&nbsp;
The<TT> err</TT> argument will be passed unchanged.&nbsp; Upon returning, the far16 pointer (far pointer in the 16-bit environment)
will be converted to a 32-bit pointer which describes the equivalent location in the 32-bit address space.
<DT>_Seg16
<DD>(32-bit only) Open Watcom C/C++ recognizes the<TT> _Seg16</TT> keyword which has a similar but not identical function as the<TT>
__far16</TT> keyword described above.&nbsp; This keyword is compatible with IBM C Set/2 and IBM VisualAge C++.
<BR><BR>In the OS/2 operating system (version 2.0 or higher), the first 512 megabytes of the 4 gigabyte segment referenced
by the DS register is divided into 8192 areas of 64K bytes each.&nbsp; A far16 pointer consists of a 16-bit selector referring
to one of the 64K byte areas, and a 16-bit offset into that area.
<BR><BR>Note that<TT> _Seg16</TT> is<B> not</B> interchangeable with<TT> __far16</TT> .
<BR><BR>A pointer declared as,
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp; [type] * _Seg16 name;
<BR><BR>defines an object that is a far16 pointer.&nbsp; Note that the<TT> _Seg16</TT> appears on the right side of the<TT>
*</TT> which is opposite to the<TT> __far16</TT> keyword described above.
<BR><BR>For example,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char * _Seg16 bufptr;</TT>
<BR><BR>declares the object<TT> bufptr</TT> to be a far16 pointer to<B><I> char</I></B> (the same as above).
<BR><BR>The<TT> _Seg16</TT> keyword may not be used to describe a 16-bit function.&nbsp; A<B><I> #pragma</I></B> directive
must be used instead.&nbsp; A function declared as,
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp; [type] * _Seg16 func( [parm_list] );
<BR><BR>declares a 32-bit function that returns a far16 pointer.
<BR><BR>For example, the declaration,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char * _Seg16 Scan( char * buffer, int len, short err );</TT>
<BR><BR>declares the 32-bit function<TT> Scan.</TT>&nbsp; No conversion of the argument list will take place.&nbsp; The return
value is a far16 pointer.
<DT>__pragma
<DD>Open Watcom C++ supports the<TT> __pragma</TT> keyword to support in-lining of member functions.&nbsp; The<TT> __pragma</TT>
keyword must be followed by parentheses containing a string that names an auxiliary pragma.&nbsp; Here is a simplified example
showing usage and syntax.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux fast_mul = \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;imul eax,edx&quot; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __parm __caller [eax] [edx] \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __value __struct;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct fixed {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned v;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; fixed __pragma( &quot;fast_mul&quot;) operator *( fixed, fixed );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; fixed two = { 2 };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; fixed three = { 3 };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; fixed foo()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return two * three;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>See the chapters entitled <A HREF="#16Mbit_Pragmas">16-bit Pragmas</A> and <A HREF="#32Mbit_Pragmas">32-bit Pragmas</A>
for more information on pragmas.
<DT>__int8
<DD>Open Watcom C/C++ supports the<TT> __int8</TT> keyword to define 8-bit integer data objects.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static __int8 smallInt;</TT>
<BR><BR>Also supported are signed and unsigned 8-bit integer constants.&nbsp; The<TT> __int8</TT> data type will be unsigned
by default if the compiler is invoked with the -j switch.
<DT>__int16
<DD>Open Watcom C/C++ supports the<TT> __int16</TT> keyword to define 16-bit integer data objects.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static __int16 shortInt;</TT>
<BR><BR>Also supported are signed and unsigned 16-bit integer constants.
<DT>__int32
<DD>Open Watcom C/C++ supports the<TT> __int32</TT> keyword to define 32-bit integer data objects.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static __int32 longInt;</TT>
<BR><BR>Also supported are signed and unsigned 32-bit integer constants.
<DT>__int64
<DD>Open Watcom C/C++ supports the<TT> __int64</TT> keyword to define 64-bit integer data objects.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static __int64 bigInt;</TT>
<BR><BR>Also supported are signed and unsigned 64-bit integer constants.
<DL>
<DT>signed __int64
<DD>Use the &quot;i64&quot; suffix for a signed 64-bit integer constant.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 12345i64</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 12345I64</TT>
<DT>unsigned __int64
<DD>Use the &quot;ui64&quot; suffix for an unsigned 64-bit integer constant.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 12345Ui64</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 12345uI64</TT>
</DL>
<BR>The run-time library supports formatting of<TT> __int64</TT> items (see the description of the<TT> printf</TT> library
function).
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;limits.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __int64 bigint;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __int64 bigint2;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bigint2 = 8I64 * (LONG_MAX + 1I64);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( bigint = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bigint &lt;= bigint2;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bigint += bigint2 / 16 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Hello world %Ld\n&quot;, bigint
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<DL>
<DT>Restrictions
<DD>
<DT>switch
<DD>An<TT> __int64</TT> expression cannot be used in a<B> switch</B> statement.
<DT>bit fields
<DD>More than 32 bits in a 64-bit bitfield is not supported.
</DL>
</DL>
<H2 ID="Based_Pointers"> Based Pointers </H2>
<BR>Near pointers are generally the most efficient type of pointer because they are small, and the compiler can assume knowledge
about what segment of the computer's memory the pointer (offset) refers to.&nbsp; Far pointers are the most flexible because
they allow the programmer to access any part of the computer's memory, without limitation to a particular segment.&nbsp; However,
far pointers are bigger and slower because of the additional flexibility.
<BR><BR>Based pointers are a compromise between the efficiency of near pointers and the flexibility of far pointers.&nbsp;
With based pointers, the programmer takes responsibility to tell the compiler which segment a near pointer (offset) belongs
to, but may still access segments of the computer's memory outside of the normal data segment (DGROUP).&nbsp; The result is
a pointer type which is as small as and almost as efficient as a near pointer, but with most of the flexibility of a far pointer.
<BR><BR>An object declared as a based pointer falls into one of the following categories:
<UL>
<LI>the based pointer is in the segment described by another object,
<LI>the based pointer, used as a pointer to another object of the same type (as in a linked list), refers to the same segment,
<LI>the based pointer is an offset to no particular segment, and must be combined explicitly with a segment value to produce
a valid pointer.
</UL>
<BR>To support based pointers, the following keywords are provided:&nbsp; 
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; __based</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; __segment</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; __segname</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; __self</TT>
<BR><BR>The following operator is also provided:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; :&gt;</TT>
<BR><BR>These keywords and operator are described in the following sections.
<BR><BR>Two macros, defined in<TT> malloc.h,</TT> are also provided:&nbsp; 
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _NULLSEG</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _NULLOFF</TT>
<BR><BR>They are used in a manner similar to<TT> NULL</TT> , but are used with objects declared as<TT> __segment</TT> and<TT>
__based</TT> respectively.
<H3 ID="Segment_Constant_Based_Pointers_and_Objects"> Segment Constant Based Pointers and Objects </H3>
<BR>A segment constant based pointer or object has its segment value based on a specific, named segment.&nbsp; A segment constant
based object is specified as:
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp; [type] __based( __segname( &quot;segment&quot; ) ) object_name;
<BR><BR>and a segment constant based pointer is specified as:
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp; [type] __based( __segname( &quot;segment&quot; ) ) *object-name;
<BR><BR>where<TT> segment</TT> is the name of the segment in which the pointer or object is based.&nbsp; As shown above, the
segment name is always specified as a string.&nbsp; There are four special segment names recognized by the compiler:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &quot;_CODE&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &quot;_CONST&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &quot;_DATA&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &quot;_STACK&quot;</TT>
<BR><BR>The<TT> &quot;_CODE&quot;</TT> segment is the default code segment.&nbsp; The<TT> &quot;_CONST&quot;</TT> segment
is the segment containing constant values.&nbsp; The<TT> &quot;_DATA&quot;</TT> segment is the default data segment.&nbsp;
The<TT> &quot;_STACK&quot;</TT> segment is the segment containing the stack.&nbsp; If the segment name is not one of the recognized
names, then a segment will be created with that name.&nbsp; If a segment constant based object is being defined, then it will
be placed in the named segment.&nbsp; If a segment constant based pointer is being defined, then it can point at objects in
the named segment.
<BR><BR>The following examples illustrate segment constant based pointers and objects.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int __based( __segname( &quot;_CODE&quot; ) )&nbsp; ival = 3;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int __based( __segname( &quot;_CODE&quot; ) ) *iptr;</TT>
<BR><BR><TT>ival</TT> is an object that resides in the default code segment.<TT>&nbsp; iptr</TT> is an object that resides
in the data segment (the usual place for data objects), but points at an integer which resides in the default code segment.<TT>
&nbsp;iptr</TT> is suitable for pointing at<TT> ival.</TT>
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char __based( __segname( &quot;GOODTHINGS&quot; ) ) thing;</TT>
<BR><BR><TT>thing</TT> is an object which resides in the segment<TT> GOODTHINGS,</TT> which will be created if it does not
already exist.&nbsp; (The creation of segments is done by the linker, and is a method of grouping objects and functions.&nbsp;
Nothing is implicitly created during the execution of the program.)
<H3 ID="Segment_Object_Based_Pointers"> Segment Object Based Pointers </H3>
<BR>A segment object based pointer derives its segment value from another named object.&nbsp; A segment object based pointer
is specified as follows:
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp; [type] __based( segment ) *name;
<BR><BR>where<TT> segment</TT> is an object defined as type<TT> __segment</TT> .
<BR><BR>An object of type<TT> __segment</TT> may contain a segment value.&nbsp; Such an object is particularly designed for
use with segment object based pointers.
<BR><BR>The following example illustrates a segment object based pointer:
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; __segment&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; seg;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char __based( seg ) *cptr;</TT>
<BR><BR>The object<TT> seg</TT> contains only a segment value.&nbsp; Whenever the object<TT> cptr</TT> is used to point to
a character, the actual pointer value will be made up of the segment value found in<TT> seg</TT> and the offset value found
in<TT> cptr.</TT>&nbsp; The object<TT> seg</TT> might be assigned values such as the following:
<UL>
<LI>a constant value (e.g., the segment containing screen memory),
<LI>the result of the library function<B><I> _bheapseg</I></B> ,
<LI>the segment portion of another pointer value, by casting it to the type<TT> __segment</TT> .
</UL>
<H3 ID="Void_Based_Pointers"> Void Based Pointers </H3>
<BR>A void based pointer must be explicitly combined with a segment value to produce a reference to a memory location.&nbsp;
A void based pointer does not infer its segment value from another object.&nbsp; The<TT> :&gt;</TT> (base) operator is used
to combine a segment value and a void based pointer.
<BR><BR>For example, on a personal computer running DOS with a color monitor, the screen memory begins at segment 0xB800,
offset 0.&nbsp; In a video text mode, to examine the first character currently displayed on the screen, the following code
could be used:
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern void main()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __segment&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; screen;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char __based( void ) *scrptr;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; screen = 0xB800;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scrptr = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Top left character is '%c'.\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *(screen:&gt;scrptr)
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The general form of the<TT> :&gt;</TT> operator is:
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp; segment :&gt; offset
<BR><BR>where<TT> segment</TT> is an expression of type<TT> __segment</TT> , and<TT> offset</TT> is an expression of type<TT>
__based( void ) *.</TT>
<H3 ID="Self_Based_Pointers"> Self Based Pointers </H3>
<BR>A self based pointer infers its segment value from itself.&nbsp; It is particularly useful for structures such as linked
lists, where all of the list elements are in the same segment.&nbsp; A self based pointer pointing to one element may be used
to access the next element, and the compiler will use the same segment as the original pointer.
<BR><BR>The following example illustrates a function which will print the values stored in the last two members of a linked
list:
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct a {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct a __based( __self ) *next;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; number;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern void PrintLastTwo( struct a far *list )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __segment&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; seg;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct a __based( seg ) *aptr;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; seg&nbsp; = FP_SEG( list );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aptr = FP_OFF( list );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( ; aptr != _NULLOFF; aptr = aptr-&gt;next ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( aptr-&gt;next == _NULLOFF ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Last item is %d\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aptr-&gt;number
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if( aptr-&gt;next-&gt;next == _NULLOFF ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Second last item is %d\n&quot;,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aptr-&gt;number
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The argument to the function<TT> PrintLastTwo</TT> is a far pointer, pointing to a linked list structure anywhere
in memory.&nbsp; It is assumed that all members of a particular linked list of this type reside in the same segment of the
computer's memory.&nbsp; (Another instance of the linked list might reside entirely in a different segment.) The object<TT>
seg</TT> is given the segment portion of the far pointer.&nbsp; The object<TT> aptr</TT> is given the offset portion, and
is described as being based in the segment stored in<TT> seg.</TT>
<BR><BR>The expression<TT> aptr-&gt;next</TT> refers to the<TT> next</TT> member of the structure stored in memory at the
offset stored in<TT> aptr</TT> and the segment implied by<TT> aptr,</TT> which is the value stored in<TT> seg.</TT>&nbsp;
So far, the behavior is no different than if<TT> next</TT> had been declared as,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct a *next;</TT>
<BR><BR>The expression<TT> aptr-&gt;next-&gt;next</TT> illustrates the difference of using a self based pointer.&nbsp; The
first part of the expression (<TT> aptr-&gt;next</TT>) occurs as described above.&nbsp; However, using the result to point
to the next member occurs by using the offset value found in the<TT> next</TT> member and combining it with the segment value
of the<B> pointer used to get to that member,</B> which is still the segment implied by<TT> aptr,</TT> which is the value
stored in<TT> seg.</TT>&nbsp; If<TT> next</TT> had not been declared using<TT> __based( __self ),</TT> then the second pointing
operation would refer to the offset value found in the<TT> next</TT> member, but with the default data segment (DGROUP), which
may or may not be the same segment as stored in<TT> seg.</TT>
<H2 ID="The___declspec_Keyword"> The __declspec Keyword </H2>
<BR>Open Watcom C/C++ supports the<TT> __declspec</TT> keyword for compatibility with Microsoft C++.&nbsp; The<TT> __declspec</TT>
keyword is used to modify storage-class attributes of functions and/or data.
<DL>
<DT>__declspec( thread )
<DD>is used to define thread local storage (TLS).&nbsp; TLS is the mechanism by which each thread in a multithreaded process allocates
storage for thread-specific data.&nbsp; In standard multithreaded programs, data is shared among all threads of a given process,
whereas thread local storage is the mechanism for allocating per-thread data.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; __declspec(thread) static int tls_data = 0;</TT>
<BR><BR>The following rules apply to the use of the<TT> thread</TT> attribute.
<UL>
<LI>The<TT> thread</TT> attribute can be used with data and objects only.
<LI>You can specify the<TT> thread</TT> attribute only on data items with static storage duration.&nbsp; This includes global
data objects (both<TT> static</TT> and<TT> extern</TT> ), local static objects, and static data members of classes.&nbsp;
Automatic data objects cannot be declared with the<TT> thread</TT> attribute.&nbsp; The following example illustrates this
error:
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define TLS __declspec( thread )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void func1()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TLS int tls_data;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; // Wrong!</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int func2( TLS int tls_data )&nbsp;&nbsp; // Wrong!</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return tls_data;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<LI>The<TT> thread</TT> attribute must be used for both the declaration and the definition of a thread local object, whether
the declaration and definition occur in the same file or separate files.&nbsp; The following example illustrates this error:
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define TLS __declspec( thread )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int tls_data;&nbsp;&nbsp;&nbsp; // This generates an error, because the</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; TLS&nbsp;&nbsp;&nbsp; int tls_data;&nbsp;&nbsp;&nbsp; // declaration and the definition differ.</TT>
<LI>Classes cannot use the<TT> thread</TT> attribute.&nbsp; However, you can instantiate class objects with the<TT> thread</TT>
attribute, as long as the objects do not need to be constructed or destructed.&nbsp; For example, the following code generates
an error:
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define TLS __declspec( thread )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; TLS class A&nbsp;&nbsp;&nbsp;&nbsp; // Wrong! Classes are not objects</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Code</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; A AObject;</TT>
<BR><BR>Because the declaration of objects that use the<TT> thread</TT> attribute is permitted, these two examples are semantically
equivalent:
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define TLS __declspec( thread )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; TLS class B</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Code</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; } BObject;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Okay! BObject declared thread local.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class C</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Code</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; TLS C CObject;&nbsp; // Okay! CObject declared thread local.</TT>
<LI>Standard C permits initialization of an object or variable with an expression involving a reference to itself, but only
for objects of non-static extent.&nbsp; Although C++ normally permits such dynamic initialization of an object with an expression
involving a reference to itself, this type of initialization is not permitted with thread local objects.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define TLS&nbsp; __declspec( thread )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; TLS int tls_i = tls_i;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// C and C++ error</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int j = j;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Okay in C++; C error</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; TLS int tls_k = sizeof( tls_k );&nbsp; // Okay in C and C++</TT>
<BR><BR>Note that a<TT> sizeof</TT> expression that includes the object being initialized does not constitute a reference
to itself and is allowed in C and C++.
</UL>
<DT>__declspec( naked )
<DD>indicates to the code generator that no prologue or epilogue sequence is to be generated for a function.&nbsp; Any statements
other than &quot;_asm&quot; directives or auxiliary pragmas are not compiled.<B><I>&nbsp; _asm</I></B> Essentially, the compiler
will emit a &quot;label&quot; with the specified function name into the code.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int __declspec( naked ) foo( int x )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _asm {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #if defined(__386__)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inc eax</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inc ax</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #endif</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, foo( 1 ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The following rules apply to the use of the<TT> naked</TT> attribute.
<UL>
<LI>The<TT> naked</TT> attribute cannot be used in a data declaration.&nbsp; The following declaration would be flagged in
error.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; __declspec(naked) static int data_object = 0;</TT>
</UL>
<DT>__declspec( noreturn )
<DD>indicates to the C/C++ compiler that function does not return.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int __declspec( noreturn ) foo( int x )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = -x;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit( x );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foo( 0 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>foo</TT> is defined to be a function that does not return.&nbsp; For example, it call<TT> exit</TT> to return
to the system.&nbsp; In this case, Open Watcom C/C++ generates a &quot;jmp&quot; instruction instead of a &quot;call&quot;
instruction to invoke<TT> foo.</TT>
<BR><BR>The following rules apply to the use of the<TT> noreturn</TT> attribute.
<UL>
<LI>The<TT> noreturn</TT> attribute cannot be used in a data declaration.&nbsp; The following declaration would be flagged
in error.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; __declspec(noreturn) static int data_object = 0;</TT>
</UL>
<DT>__declspec( farss )
<DD>indicates to the C/C++ compiler that function suppose SS != DS.&nbsp; Function uses far pointer to access automatic variables
on the stack.&nbsp; It is alternative to -zu compiler option and can be used per function.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; __declspec( farss ) char * foo( char *s );</TT>
<BR><BR>The following rules apply to the use of the<TT> farss</TT> attribute.
<UL>
<LI>The<TT> farss</TT> attribute cannot be used in a data declaration.
</UL>
<DT>__declspec( dllimport )
<DD>is used to declare functions, data and objects imported from a DLL.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define DLLImport __declspec(dllimport)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DLLImport void dll_func();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DLLImport int&nbsp; dll_data;</TT>
<BR><BR>Functions, data and objects are exported from a DLL by use of<TT> __declspec(dllexport)</TT> ct , the<TT> __export</TT>
keyword (for which<TT> __declspec(dllexport)</TT> is the replacement), or through linker &quot;EXPORT&quot; directives.
<BR><BR>Note:&nbsp; When calling functions imported from other modules, it is not strictly necessary to use the<TT> __declspec(dllimport)</TT>
modifier to declare the functions.&nbsp; This modifier however must always be used when importing data or objects to ensure
correct behavior.
<DT>__declspec( dllexport )
<DD>is used to declare functions, data and objects exported from a DLL.&nbsp; Declaring functions as<TT> dllexport</TT> eliminates
the need for linker &quot;EXPORT&quot; directives.&nbsp; The<TT> __declspec(dllexport)</TT> attribute is a replacement for
the<TT> __export</TT> keyword.
<DT>__declspec( __pragma( &quot;string&quot; ) )
<DD>is used to declare functions which adhere to the conventions described by the pragma identified by &quot;string&quot;.
<BR><BR><B>Example:</B>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux my_stdcall &quot;_*&quot; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __parm __routine [] \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __value __struct __struct __caller [] \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __modify [eax ecx edx];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct list {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct list *next;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; flt_value;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define STDCALL __declspec( __pragma(&quot;my_stdcall&quot;) )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; STDCALL struct list foo( int x, char *y, double z );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int a = 1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *b = &quot;Hello there&quot;;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double c = 3.1415926;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct list t;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t = foo( a, b, c );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, t.value );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct list foo( int x, char *y, double z )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct list tmp;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, y );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmp.next = NULL;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmp.value = x;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmp.flt_value = z;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( tmp );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>It is also possible to modify the calling convention of all methods of a class or just an individual method.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux my_thiscall &quot;_*&quot; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __parm __routine [ecx] \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __value __struct __struct __caller [] \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __modify [eax ecx edx];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define THISCALL __declspec( __pragma(&quot;my_thiscall&quot;) )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class THISCALL IWatcom: public IUnknown{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual int method_a( void ) = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual int method_b( void ) = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual int __cdecl method_c( void ) = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR>In this example, any calls generated to the virtual methods 'method_a' or 'method_b' will use the THISCALL ( my_thiscall
) calling convention.&nbsp; Calls generated to 'method_c' will use the prefefined<B><I> __cdecl</I></B> calling convention.
<BR><BR>It is also possible to forward define the class with modifiers for occasions where you do not want to change original
source code.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux my_thiscall &quot;_*&quot; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __parm __routine [ecx] \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __value __struct __struct __caller [] \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __modify [eax ecx edx];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define THISCALL __declspec( __pragma(&quot;my_thiscall&quot;) )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class THISCALL IWatcom;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; class IWatcom: public IUnknown{</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual int method_a( void ) = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual int method_b( void ) = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual int __cdecl method_c( void ) = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR>The<B><I> __pragma</I></B> modifier is supported by Open Watcom C++ only.
<DT>__declspec( __cdecl )
<DD>is used to declare functions which conform to the Microsoft compiler calling convention.
<DT>__declspec( __pascal )
<DD>is used to declare functions which conform to the OS/2 1.x and Windows 3.x calling convention.
<DT>__declspec( __fortran )
<DD>is used to declare functions which conform to the<B><I> __fortran</I></B> calling convention.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define DLLFunc __declspec(dllimport __fortran)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define DLLData __declspec(dllimport)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #ifdef __cplusplus</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern &quot;C&quot; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #endif</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DLLFunc int&nbsp; dll_func( int, int, int );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DLLData int&nbsp; dll_data;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #ifdef __cplusplus</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #endif</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%d %d\n&quot;, dll_func( 1,2,3 ), dll_data );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<DT>__declspec( __stdcall )
<DD>is used to declare functions which conform to the 32-bit Win32 &quot;standard&quot; calling convention.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define DLLFunc __declspec(dllimport __stdcall)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define DLLData __declspec(dllimport)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DLLFunc int&nbsp; dll_func( int, int, int );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DLLData int&nbsp; dll_data;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%d %d\n&quot;, dll_func( 1,2,3 ), dll_data );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<DT>__declspec( __syscall )
<DD>is used to declare functions which conform to the 32-bit OS/2<B><I> __syscall</I></B> calling convention.
</DL>
<H2 ID="The_Open_Watcom_Code_Generator"> The Open Watcom Code Generator </H2>
<BR>The Open Watcom Code Generator performs such optimizations as common subexpression elimination, global flow analysis,
and so on.
<BR><BR>In some cases, the code generator can do a better job of optimizing code if it could utilize more memory.&nbsp; This
is indicated when a
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Not enough memory to optimize procedure 'xxxx'</TT>
<BR><BR>message appears on the screen as the source program is compiled.&nbsp; In such an event, you may wish to make more
memory available to the code generator.
<BR><BR>A special environment variable may be used to obtain memory usage information or set memory usage limits on the code
generator.&nbsp; The<B> WCGMEMORY</B> environment variable may be used to request a report of the amount of memory used by
the compiler's code generator for its work area.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set WCGMEMORY=?</TT>
<BR><BR>When the memory amount is &quot;?&quot; then the code generator will report how much memory was used to generate the
code.
<BR><BR>It may also be used to instruct the compiler's code generator to allocate a fixed amount of memory for a work area.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set WCGMEMORY=128</TT>
<BR><BR>When the memory amount is &quot;nnn&quot; then exactly &quot;nnnK&quot; bytes will be used.&nbsp; In the above example,
128K bytes is requested.&nbsp; If less than &quot;nnnK&quot; is available then the compiler will quit with a fatal error message.
&nbsp;If more than &quot;nnnK&quot; is available then only &quot;nnnK&quot; will be used.
<BR><BR>There are two reasons why this second feature may be quite useful.&nbsp; In general, the more memory available to
the code generator, the more optimal code it will generate.&nbsp; Thus, for two personal computers with different amounts
of memory, the code generator may produce different (although correct) object code.&nbsp; If you have a software quality assurance
requirement that the same results (i.e., code) be produced on two different machines then you should use this feature.&nbsp;
To generate identical code on two personal computers with different memory configurations, you must ensure that the<B> WCGMEMORY</B>
environment variable is set identically on both machines.
<BR><BR>The second reason where this feature is useful is on virtual memory paging systems (e.g., OS/2) where an unlimited
amount of memory can be used by the code generator.&nbsp; If a very large module is being compiled, it may take a very long
time to compile it.&nbsp; The code generator will continue to allocate more and more memory and cause an excessive amount
of paging.&nbsp; By restricting the amount of memory that the code generator can use, you can reduce the amount of time required
to compile a routine.
<H1 ID="Precompiled_Headers"> Precompiled Headers </H1>
<BR>Open Watcom C/C++ supports the use of precompiled headers to decrease the time required to compile several source files
that include the same header file.
<H2 ID="When_to_Precompile_Header_Files"> When to Precompile Header Files </H2>
<BR>Using precompiled headers reduces compilation time when:
<UL>
<LI>You always use a large body of code that changes infrequently.
<LI>Your program comprises multiple modules, all of which use the same first include file and the same compilation options.
&nbsp;In this case, the first include file along with all the files that it includes can be precompiled into one precompiled
header.
</UL>
<BR>Because the compiler only uses the first include file to create a precompiled header, you may want to create a master
or global header file that includes all the other header files that you wish to have precompiled.&nbsp; Then all source files
should include this master header file as the first<TT> #include</TT> in the source file.&nbsp; Even if you don't use a master
header file, you can benefit from using precompiled headers for Windows programs by using<TT> #include &lt;windows.h&gt;</TT>
as the first include file, or by using<TT> #include &lt;afxwin.h&gt;</TT> as the first include file for MFC applications.
<BR><BR>The first compilation - the one that creates the precompiled header file - takes a bit longer than subsequent compilations.
&nbsp;Subsequent compilations can proceed more quickly by including the precompiled header.
<BR><BR>You can precompile C and C++ programs.&nbsp; In C++ programming, it is common practice to separate class interface
information into header files which can later be included in programs that use the class.&nbsp; By precompiling these headers,
you can reduce the time a program takes to compile.
<HR>
<BR><B><I>&nbsp; Note:</I></B>&nbsp; Although you can use only one precompiled header (<TT>.PCH</TT>) file per source file,
you can use multiple<TT> .PCH</TT> files in a project.
<HR>
<H2 ID="Creating_and_Using_Precompiled_Headers"> Creating and Using Precompiled Headers </H2>
<BR>Precompiled code is stored in a file called a precompiled header when you use the precompiled header option (<B> -fh</B>
or<B> -fhq</B>) on the command line.&nbsp; The<B> -fh</B> option causes the compiler to either create a precompiled header
or use the precompiled header if it already exists.&nbsp; The<B> -fhq</B> option is similar but prevents the compiler from
issuing informational or warning messages about precompiled header files.&nbsp; The default name of the precompiled header
file is one of<TT> WCC.PCH, WCC386.PCH, WPP.PCH,</TT> or<TT> WPP386.PCH</TT> (depending on the compiler used).&nbsp; You can
also control the name of the precompiled header that is created or used with the<B> -fh=filename</B> or<B> -fhq=filename</B>
(&quot;specify precompiled header filename&quot;) options.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -fh=projectx.pch</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -fhq=projectx.pch</TT>
<H2 ID="The__MfhUqV__LPrecompiled_HeaderR_Option"> The &quot;-fh[q]&quot; (Precompiled Header) Option </H2>
<BR>The<B> -fh</B> option instructs the compiler to use a precompiled header file with a default name of<TT> WCC.PCH, WCC386.PCH,
WPP.PCH,</TT> or<TT> WPP386.PCH</TT> (depending on the compiler used) if it exists or to create one if it does not.&nbsp;
The file is created in the current directory.&nbsp; You can use the<B> -fh=filename</B> option to change the default name
(and placement) of the precompiled header.&nbsp; Add the letter &quot;q&quot; (for &quot;quiet&quot;) to the option name to
prevent the compiler from displaying precompiled header activity information.
<BR><BR>The following command line uses the<B> -fh</B> option to create a precompiled header.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; wpp -fh myprog.cpp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; wpp386 -fh myprog.cpp</TT>
<BR><BR>The following command line creates a precompiled header named<TT> myprog.pch</TT> and places it in the<TT> \projpch</TT>
directory.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; wpp -fh=\projpch\myprog.pch myprog.cpp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; wpp386 -fh=\projpch\myprog.pch myprog.cpp</TT>
<BR><BR>The precompiled header is created and/or used when the compiler encounters the first<TT> #include</TT> directive that
occurs in the source file.&nbsp; In a subsequent compilation, the compiler performs a consistency check to see if it can use
an existing precompiled header.&nbsp; If the consistency check fails then the compiler discards the existing precompiled header
and builds a new one.
<BR><BR>The<B> -fhq</B> form of the precompiled header option prevents the compiler from issuing warning or informational
messages about precompiled header files.&nbsp; For example, if you change a header file, the compiler will tell you that it
changed and that it must regenerate the precompiled header file.&nbsp; If you specify<B> -fhq</B> then the compiler just generates
the new precompiled header file without displaying a message.
<H2 ID="Consistency_Rules_for_Precompiled_Headers"> Consistency Rules for Precompiled Headers </H2>
<BR>If a precompiled header file exists (either the default file or one specified by<B> -fh=filename</B>), it is compared
to the current compilation for consistency.&nbsp; A new precompiled header file is created and the new file overwrites the
old unless the following requirements are met:
<UL>
<LI>The current compiler options must match those specified when the precompiled header was created.
<LI>The current working directory must match that specified when the precompiled header was created.
<LI>The name of the first<TT> #include</TT> directive must match the one that was specified when the precompiled header was
created.
<LI>All macros defined prior to the first<TT> #include</TT> directive must have the same values as the macros defined when
the precompiled header was created.&nbsp; A sequence of<TT> #define</TT> directives need not occur in exactly the same order
because there are no semantic order dependencies for<TT> #define</TT> directives.
<LI>The value and order of include paths specified on the command line with<B> -i</B> options must match those specified when
the precompiled header was created.
<LI>The time stamps of all the header files (all files specified with<TT> #include</TT> directives) used to build the precompiled
header must match those that existed when the precompiled header was created.
</UL>
<H1 ID="The_Open_Watcom_CDCPP_Libraries"> The Open Watcom C/C++ Libraries </H1>
<BR>The Open Watcom C/C++ library routines are described in the<B><I> Open Watcom C Library Reference</I></B> manual, and
the<B><I> Open Watcom C++ Class Library Reference</I></B> manual.
<H2 ID="Open_Watcom_CDCPP_Library_Directory_Structure"> Open Watcom C/C++ Library Directory Structure </H2>
<BR>Since Open Watcom C/C++ supports both 16-bit and 32-bit application development, libraries are grouped under two major
subdirectories.&nbsp; The<TT> LIB286</TT> directory is used to contain libraries for 16-bit application development.&nbsp;
The<TT> LIB386</TT> directory is used to contain libraries for 32-bit application development.
<BR><BR>For 16-bit application development, the Intel x86 processor-dependent libraries are placed under the<TT> \WATCOM\LIB286</TT>
directory.
<BR><BR>For 32-bit application development, the Intel 386 and upward-compatible processor-dependent libraries are placed under
the<TT> \WATCOM\LIB386</TT> directory.
<BR><BR>Since Open Watcom C/C++ also supports several operating systems, including DOS, OS/2, Windows 3.x and Windows NT,
system-dependent libraries are grouped under different directories underneath the processor-dependent directories.
<BR><BR>For DOS applications, the system-dependent libraries are placed in<TT> \WATCOM\LIB286\DOS</TT> (16-bit applications)
and<TT> \WATCOM\LIB386\DOS</TT> (32-bit applications).
<BR><BR>For OS/2 applications, the system-dependent libraries are placed in<TT> \WATCOM\LIB286\OS2</TT> (16-bit applications)
and<TT> \WATCOM\LIB386\OS2</TT> (32-bit applications).
<BR><BR>For Microsoft Windows applications, the system-dependent libraries are placed in<TT> \WATCOM\LIB286\WIN</TT> (16-bit
applications) and<TT> \WATCOM\LIB386\WIN</TT> (32-bit applications).
<BR><BR>For Microsoft Windows NT applications, the system-dependent libraries are placed in<TT> \WATCOM\LIB386\NT</TT> (32-bit
applications).
<BR><BR>For Novell NetWare 386 applications, the system-dependent libraries are placed in<TT> \WATCOM\LIB386\NETWARE</TT>
(32-bit applications).
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; \watcom</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .-----------+----------------.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lib286&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lib386</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .-------+-------.&nbsp;&nbsp;&nbsp; .-------.-------+-------.-------.</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;
&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; dos&nbsp;&nbsp;&nbsp;&nbsp; os2&nbsp;&nbsp;&nbsp;&nbsp; win&nbsp; dos&nbsp;&nbsp;&nbsp;&nbsp;
os2&nbsp;&nbsp;&nbsp;&nbsp; win&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nt&nbsp;&nbsp; netware</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;
&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<H2 ID="Open_Watcom_CDCPP_C_Libraries"> Open Watcom C/C++ C Libraries </H2>
<BR>Due to the many code generation strategies possible in the 80x86 family of processors, a number of versions of the libraries
are provided.&nbsp; You must use the libraries which coincide with the particular architecture, operating system, and code
generation strategy or model that you have selected.&nbsp; For the type of code generation strategy or model that you intend
to use, refer to the description of the &quot;m?&quot; memory model compiler option.&nbsp; The various code models supported
by Open Watcom C/C++ are described in the chapters entitled <A HREF="#16Mbit_Memory_Models">16-bit Memory Models</A> and <A HREF="#32Mbit_Memory_Models">32-bit Memory Models</A>.
<BR><BR>We have selected a simple naming convention for the libraries that are provided with Open Watcom C/C++.&nbsp; Letters
are affixed to the file name to indicate the particular strategy with which the modules in the library have been compiled.
<DL>
<DT>16-bit only
<DD>
<DT>S
<DD>denotes a version of the Open Watcom C/C++ libraries which have been compiled for the &quot;small&quot; memory model (small
code, small data).&nbsp; 
<DT>M
<DD>denotes a version of the Open Watcom C/C++ libraries which have been compiled for the &quot;medium&quot; memory model (big
code, small data).&nbsp; 
<DT>C
<DD>denotes a version of the Open Watcom C/C++ libraries which have been compiled for the &quot;compact&quot; memory model (small
code, big data).&nbsp; 
<DT>L
<DD>denotes a version of the Open Watcom C/C++ libraries which have been compiled for the &quot;large&quot; memory model (big
code, big data).&nbsp; 
<DT>H
<DD>denotes a version of the Open Watcom C/C++ libraries which have been compiled for the &quot;huge&quot; memory model (big code,
huge data).
<DT>MT
<DD>denotes a version of the Open Watcom C/C++ libraries which may be used with OS/2 multi-threaded applications.
<DT>DL
<DD>denotes a version of the Open Watcom C/C++ libraries which may be used when creating an OS/2 Dynamic Link Library.
</DL>
<DL>
<DT>32-bit only
<DD>
<DT>3R
<DD>denotes a version of the Open Watcom C/C++ libraries that will be used by programs which have been compiled for the &quot;flat/small&quot;
memory models using the &quot;3r&quot;, &quot;4r&quot;, &quot;5r&quot; or &quot;6r&quot; option.
<DT>3S
<DD>denotes a version of the Open Watcom C/C++ libraries that will be used by programs which have been compiled for the &quot;flat/small&quot;
memory models using the &quot;3s&quot;, &quot;4s&quot;, &quot;5s&quot; or &quot;6s&quot; option.
</DL>
<BR>The Open Watcom C/C++ 16-bit libraries are listed below by directory.
<BR><BR><B>Under</B><TT> \WATCOM\LIB286\DOS</TT> 
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CLIBS.LIB&nbsp;&nbsp;&nbsp; (DOS small model support)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CLIBM.LIB&nbsp;&nbsp;&nbsp; (DOS medium model support)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CLIBC.LIB&nbsp;&nbsp;&nbsp; (DOS compact model support)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CLIBL.LIB&nbsp;&nbsp;&nbsp; (DOS large model support)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CLIBH.LIB&nbsp;&nbsp;&nbsp; (DOS huge model support)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; GRAPH.LIB&nbsp;&nbsp;&nbsp; (model independent, DOS graphics support)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DOSLFNS.LIB&nbsp; (DOS LFN small model support)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DOSLFNM.LIB&nbsp; (DOS LFN medium model support)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DOSLFNC.LIB&nbsp; (DOS LFN compact model support)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DOSLFNL.LIB&nbsp; (DOS LFN large model support)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DOSLFNH.LIB&nbsp; (DOS LFN huge model support)</TT>
<BR><BR><B>Under</B><TT> \WATCOM\LIB286\OS2</TT> 
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CLIBS.LIB&nbsp;&nbsp;&nbsp; (OS/2 small model support)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CLIBM.LIB&nbsp;&nbsp;&nbsp; (OS/2 medium model support)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CLIBC.LIB&nbsp;&nbsp;&nbsp; (OS/2 compact model support)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CLIBL.LIB&nbsp;&nbsp;&nbsp; (OS/2 large model support)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CLIBH.LIB&nbsp;&nbsp;&nbsp; (OS/2 huge model support)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CLIBMTL.LIB&nbsp; (OS/2 multi-thread, large model support)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CLIBDLL.LIB&nbsp; (OS/2 DLL, large model support)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DOSPMS.LIB&nbsp;&nbsp; (Phar Lap 286 PM small model support)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DOSPMM.LIB&nbsp;&nbsp; (Phar Lap 286 PM medium model support)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DOSPMC.LIB&nbsp;&nbsp; (Phar Lap 286 PM compact model support)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DOSPML.LIB&nbsp;&nbsp; (Phar Lap 286 PM large model support)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DOSPMH.LIB&nbsp;&nbsp; (Phar Lap 286 PM huge model support)</TT>
<BR><BR><B>Under</B><TT> \WATCOM\LIB286\WIN</TT> 
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CLIBS.LIB&nbsp;&nbsp;&nbsp; (Windows small model support)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CLIBM.LIB&nbsp;&nbsp;&nbsp; (Windows medium model support)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CLIBC.LIB&nbsp;&nbsp;&nbsp; (Windows compact model support)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CLIBL.LIB&nbsp;&nbsp;&nbsp; (Windows large model support)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; WINDOWS.LIB&nbsp; (Windows API library)</TT>
<BR><BR>The Open Watcom C/C++ 32-bit libraries are listed below by directory.
<BR><BR><B>Under</B><TT> \WATCOM\LIB386\DOS</TT> 
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CLIB3R.LIB&nbsp;&nbsp; (flat/small models, &quot;3r&quot;, &quot;4r&quot;, &quot;5r&quot;
or &quot;6r&quot; option)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CLIB3S.LIB&nbsp;&nbsp; (flat/small models, &quot;3s&quot;, &quot;4s&quot;, &quot;5s&quot;
or &quot;6s&quot; option)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; GRAPH.LIB&nbsp;&nbsp;&nbsp; (flat/small models, DOS graphics support)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DOSLFN3R.LIB (flat/small models, DOS LFN support,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;3r&quot;, &quot;4r&quot;,
&quot;5r&quot; or &quot;6r&quot; option)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DOSLFN3S.LIB (flat/small models, DOS LFN support,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;3s&quot;, &quot;4s&quot;,
&quot;5s&quot; or &quot;6s&quot; option)</TT>
<BR><BR>The graphics library<TT> GRAPH.LIB</TT> is independent of the argument passing conventions.
<BR><BR><B>Under</B><TT> \WATCOM\LIB386\OS2</TT> 
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CLIB3R.LIB&nbsp;&nbsp; (flat/small models, &quot;3r&quot;, &quot;4r&quot;, &quot;5r&quot;
or &quot;6r&quot; option)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CLIB3S.LIB&nbsp;&nbsp; (flat/small models, &quot;3s&quot;, &quot;4s&quot;, &quot;5s&quot;
or &quot;6s&quot; option)</TT>
<BR><BR><B>Under</B><TT> \WATCOM\LIB386\WIN</TT> 
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CLIB3R.LIB&nbsp;&nbsp; (flat/small models, &quot;3r&quot;, &quot;4r&quot;, &quot;5r&quot;
or &quot;6r&quot; option)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CLIB3S.LIB&nbsp;&nbsp; (flat/small models, &quot;3s&quot;, &quot;4s&quot;, &quot;5s&quot;
or &quot;6s&quot; option)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; WIN386.LIB&nbsp;&nbsp; (32-bit Windows API)</TT>
<BR><BR><B>Under</B><TT> \WATCOM\LIB386\NT</TT> 
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CLIB3R.LIB&nbsp;&nbsp; (flat/small models, &quot;3r&quot;, &quot;4r&quot;, &quot;5r&quot;
or &quot;6r&quot; option)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CLIB3S.LIB&nbsp;&nbsp; (flat/small models, &quot;3s&quot;, &quot;4s&quot;, &quot;5s&quot;
or &quot;6s&quot; option)</TT>
<H2 ID="Open_Watcom_CDCPP_Class_Libraries"> Open Watcom C/C++ Class Libraries </H2>
<BR>The Open Watcom C/C++ Class Library routines are described in the<B><I> Open Watcom C++ Class Library Reference</I></B>
manual.
<BR><BR>The Open Watcom C++ 16-bit Class Libraries are listed below.
<BR><BR><B>Under</B><TT> \WATCOM\LIB286</TT> 
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (iostream and string class libraries)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; PLIBS.LIB&nbsp;&nbsp;&nbsp; (small model support)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; PLIBM.LIB&nbsp;&nbsp;&nbsp; (medium model support)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; PLIBC.LIB&nbsp;&nbsp;&nbsp; (compact model support)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; PLIBL.LIB&nbsp;&nbsp;&nbsp; (large model support)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; PLIBH.LIB&nbsp;&nbsp;&nbsp; (huge model support)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; PLIBMTL.LIB&nbsp; (OS/2 multi-thread, large model support)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; PLIBDLL.LIB&nbsp; (OS/2 DLL, large model support)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (complex class library for &quot;fpc&quot; option)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CPLXS.LIB&nbsp;&nbsp;&nbsp; (small model support)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CPLXM.LIB&nbsp;&nbsp;&nbsp; (medium model support)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CPLXC.LIB&nbsp;&nbsp;&nbsp; (compact model support)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CPLXL.LIB&nbsp;&nbsp;&nbsp; (large model support)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CPLXH.LIB&nbsp;&nbsp;&nbsp; (huge model support)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (complex class library for &quot;fpi...&quot; options)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CPLX7S.LIB&nbsp;&nbsp; (small model support)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CPLX7M.LIB&nbsp;&nbsp; (medium model support)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CPLX7C.LIB&nbsp;&nbsp; (compact model support)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CPLX7L.LIB&nbsp;&nbsp; (large model support)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CPLX7H.LIB&nbsp;&nbsp; (huge model support)</TT>
<BR><BR>These libraries are independent of the operating system (except those designated for OS/2).&nbsp; The &quot;7&quot;
designates a library compiled with the &quot;7&quot; option.
<BR><BR>The Open Watcom C++ 32-bit Class Libraries are listed below.
<BR><BR><B>Under</B><TT> \WATCOM\LIB386</TT> 
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (iostream and string class libraries)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; PLIB3R.LIB&nbsp;&nbsp; (flat models, &quot;3r&quot;, &quot;4r&quot;, &quot;5r&quot; or &quot;6r&quot;
option)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; PLIB3S.LIB&nbsp;&nbsp; (flat models, &quot;3s&quot;, &quot;4s&quot;, &quot;5s&quot; or &quot;6s&quot;
option)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; PLIBMT3R.LIB (multi-thread library for OS/2 and Windows NT)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; PLIBMT3S.LIB (multi-thread library for OS/2 and Windows NT)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (complex class library for &quot;fpc&quot; option)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CPLX3R.LIB&nbsp;&nbsp; (flat models, &quot;3r&quot;, &quot;4r&quot;, &quot;5r&quot; or &quot;6r&quot;
option)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CPLX3S.LIB&nbsp;&nbsp; (flat models, &quot;3s&quot;, &quot;4s&quot;, &quot;5s&quot; or &quot;6s&quot;
option)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (complex class library for &quot;fpi...&quot; options)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CPLX73R.LIB&nbsp; (flat models, &quot;3r&quot;, &quot;4r&quot;, &quot;5r&quot; or &quot;6r&quot;
option)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CPLX73S.LIB&nbsp; (flat models, &quot;3s&quot;, &quot;4s&quot;, &quot;5s&quot; or &quot;6s&quot;
option)</TT>
<BR><BR>These libraries are independent of the operating system (except those designated for OS/2 and Windows NT).&nbsp; The
&quot;3R&quot; and &quot;3S&quot; suffixes refer to the argument passing convention used.&nbsp; The &quot;7&quot; designates
a library compiled with the &quot;7&quot; option.
<H2 ID="Open_Watcom_CDCPP_Math_Libraries"> Open Watcom C/C++ Math Libraries </H2>
<BR>In general, a Math library is required when floating-point computations are included in the application.&nbsp; The Math
libraries are operating-system independent.
<BR><BR>For the 286 architecture, the Math libraries are placed under the<TT> \WATCOM\LIB286</TT> directory.
<BR><BR>For the 386 architecture, the Math libraries are placed under the<TT> \WATCOM\LIB386</TT> directory.
<BR><BR>An 80x87 emulator library,<TT> emu87.lib</TT>, is also provided which is both operating-system and architecture dependent.
<BR><BR>The following situations indicate that one of the Math libraries should be included when linking the application.
<OL>
<LI>When one or more of the functions described in the<TT> math.h</TT> header file is referenced, then a Math library must
be included.
<LI>If an application is linked and the message
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &quot;_fltused_ is an undefined reference&quot;</TT>
<BR><BR>appears, then a Math library must be included.
<LI>(16-bit only) If an application is linked and the message 
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &quot;__init_87_emulator is an undefined reference&quot;</TT>
<BR><BR>appears, then one of the modules in the application was compiled with one of the &quot;fpi&quot;, &quot;fpi87&quot;,
&quot;fp2&quot;, &quot;fp3&quot; or &quot;fp5&quot; options.&nbsp; If the &quot;fpi&quot; option was used, the 80x87 emulator
library (<TT> emu87.lib</TT> ) or the 80x87 fixup library (<TT> noemu87.lib</TT> ) should be included when linking the application.
<BR><BR>If the &quot;fpi87&quot; option was used, the 80x87 fixup library<TT> noemu87.lib</TT> should be included when linking
the application.
<BR><BR>The 80x87 emulator is contained in<TT> emu87.lib.</TT>&nbsp; Use<TT> noemu87.lib</TT> in place of<TT> emu87.lib</TT>
when the emulator is not wanted.
<LI>(32-bit only) If an application is linked and the message 
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; &quot;__init_387_emulator is an undefined reference&quot;</TT>
<BR><BR>appears, then one of the modules in the application was compiled with one of the &quot;fpi&quot;, &quot;fpi87&quot;,
&quot;fp2&quot;, &quot;fp3&quot; or &quot;fp5&quot; options.&nbsp; If the &quot;fpi&quot; option was used, the 80x87 emulator
library (<TT> emu387.lib</TT>) should be included when linking the application.
<BR><BR>If the &quot;fpi87&quot; option was used, the empty 80x87 emulator library<TT> noemu387.lib</TT> should be included
when linking the application.
<BR><BR>The 80x87 emulator is contained in<TT> emu387.lib.</TT>&nbsp; Use<TT> noemu387.lib</TT> in place of<TT> emu387.lib</TT>
when the emulator is not wanted.
</OL>
<BR>Normally, the compiler and linker will automatically take care of this.&nbsp; Simply ensure that the<B> WATCOM</B> environment
variable includes the location of the Open Watcom C/C++ libraries.
<H2 ID="Open_Watcom_CDCPP_80x87_Math_Libraries"> Open Watcom C/C++ 80x87 Math Libraries </H2>
<BR>One of the following Math libraries must be used if any of the modules of your application were compiled with one of the
Open Watcom C/C++ &quot;fpi&quot;, &quot;fpi87&quot;, &quot;fp2&quot;, &quot;fp3&quot; or &quot;fp5&quot; options and your
application requires floating-point support for the reasons given above.
<BR><BR><B>16-bit libraries:</B>&nbsp; 
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; MATH87S.LIB (small model)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; MATH87M.LIB (medium model)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; MATH87C.LIB (compact model)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; MATH87L.LIB (large model)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; MATH87H.LIB (huge model)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; NOEMU87.LIB</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DOS\EMU87.LIB (DOS dependent)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; OS2\EMU87.LIB (OS/2 dependent)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; WIN\EMU87.LIB (Windows dependent)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; WIN\MATH87C.LIB (Windows dependent)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; WIN\MATH87L.LIB (Windows dependent)</TT>
<BR><BR><B>32-bit libraries:</B>&nbsp; 
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; MATH387R.LIB (flat/small models, &quot;3r&quot;, &quot;4r&quot;, &quot;5r&quot; or &quot;6r&quot;
option)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; MATH387S.LIB (flat/small models, &quot;3s&quot;, &quot;4s&quot;, &quot;5s&quot; or &quot;6s&quot;
option)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DOS\EMU387.LIB (DOS dependent)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; WIN\EMU387.LIB (Windows dependent)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; OS2\EMU387.LIB (OS/2 dependent)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; NT\EMU387.LIB (Windows NT dependent)</TT>
<BR><BR>The &quot;fpi&quot; option causes an 80x87 numeric data processor emulator to be linked into your application in addition
to any 80x87 math routines that were referenced.&nbsp; This emulator will decode and emulate 80x87 instructions when an 80x87
is not present in the system or if the environment variable<B> NO87</B> has been set (this variable is described below).
<BR><BR>For 32-bit Open Watcom Windows-extender applications or 32-bit applications run in Windows 3.1 DOS boxes, you must
also include the<TT> WEMU387.386</TT> file in the<TT> [386enh]</TT> section of the<TT> SYSTEM.INI</TT> file.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; device=C:\WATCOM\binw\wemu387.386</TT>
<BR><BR>Note that the<TT> WDEBUG.386</TT> file which is installed by the Open Watcom Installation software contains the emulation
support found in the<TT> WEMU387.386</TT> file.
<BR><BR>When the &quot;fpi87&quot; option is used exclusively, the emulator is not included.&nbsp; In this case, the application
must be run on personal computer systems equipped with the numeric data processor.
<H2 ID="Open_Watcom_CDCPP_Alternate_Math_Libraries"> Open Watcom C/C++ Alternate Math Libraries </H2>
<BR>One of the following Math libraries must be used if any of the modules of your application were compiled with the Open
Watcom C/C++ &quot;fpc&quot; option and your application requires floating-point support for the reasons given above.&nbsp;
The following Math libraries include support for floating-point which is done out-of-line through run-time calls.
<BR><BR><B>16-bit libraries:</B>&nbsp; 
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; MATHS.LIB (small model)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; MATHM.LIB (medium model)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; MATHC.LIB (compact model)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; MATHL.LIB (large model)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; MATHH.LIB (huge model)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; WIN\MATHC.LIB (Windows dependent)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; WIN\MATHL.LIB (Windows dependent)</TT>
<BR><BR><B>32-bit libraries:</B>&nbsp; 
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; MATH3R.LIB (flat/small models, &quot;3r&quot;, &quot;4r&quot;, &quot;5r&quot; or &quot;6r&quot;
option)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; MATH3S.LIB (flat/small models, &quot;3s&quot;, &quot;4s&quot;, &quot;5s&quot; or &quot;6s&quot;
option)</TT>
<BR><BR>Applications which are linked with one of these libraries do not require a numeric data processor for floating-point
operations.&nbsp; If one is present in the system, it will be used; otherwise floating-point operations are simulated in software.
&nbsp;The numeric data processor will not be used if the environment variable<B> NO87</B> has been set (this variable is described
below).
<H2 ID="The_NO87_Environment_Variable"> The NO87 Environment Variable </H2>
<BR>If you have a numeric data processor (math coprocessor) in your system but you wish to test a version of your application
that will use floating-point emulation (&quot;fpi&quot; option) or simulation (&quot;fpc&quot; option), you can define the<B>
NO87</B> environment variable.&nbsp; 
<BR><BR>(16-bit only) The application must be compiled using the &quot;fpc&quot; (floating-point calls) option and linked
with the appropriate<TT> math?.lib</TT> library or the &quot;fpi&quot; option (default) and linked with the appropriate<TT>
math87?.lib</TT> and<TT> emu87.lib</TT> libraries.
<BR><BR>(32-bit only) The application must be compiled using the &quot;fpc&quot; (floating-point calls) option and linked
with the appropriate<TT> math3?.lib</TT> library or the &quot;fpi&quot; option (default) and linked with the appropriate<TT>
math387?.lib</TT> library.
<BR><BR>Using the &quot;SET&quot; command, define the environment variable as follows:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;SET NO87=1</TT>
<BR><BR>Now, when you run your application, the 80x87 will be ignored.&nbsp; To undefine the environment variable, enter the
command:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;SET NO87=</TT>
<H2 ID="The_LFN_Environment_Variable"> The LFN Environment Variable </H2>
<BR>If you have the application compiled and linked to use DOS Long file name support (LFN) then you can define the<B> LFN</B>
environment variable to suppress usage of DOS LFN on run-time.
<BR><BR>Using the &quot;SET&quot; command, define the environment variable as follows:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;SET LFN=N</TT>
<BR><BR>Now, when you run your application, DOS LFN support will be ignored.&nbsp; To undefine the environment variable, enter
the command:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;SET LFN=</TT>
<H2 ID="The_Open_Watcom_CDCPP_RunMtime_Initialization_Routines"> The Open Watcom C/C++ Run-time Initialization Routines </H2>
<BR>Source files are included in the package for the Open Watcom C/C++ application startup (or initialization) sequence.
<BR><BR>(16-bit only) The initialization code directories/files are listed below:
<BR><BR><B>Under</B><TT> \WATCOM\SRC\STARTUP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; WILDARGV.C&nbsp;&nbsp;&nbsp; (wild card processing for argv)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 8087CW.C&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (value loaded into 80x87 control word)</TT>
<BR><BR><B>Under</B><TT> \WATCOM\SRC\STARTUP\DOS</TT> (DOS initialization)
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CSTRT086.ASM&nbsp; (startup for 16-bit apps)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DOS16M.ASM&nbsp;&nbsp;&nbsp; (startup code for Tenberry Software's DOS/16M)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CMAIN086.C&nbsp;&nbsp;&nbsp; (final part of initialization sequence)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; MDEF.INC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (macros included by assembly code)</TT>
<BR><BR><B> Under</B><TT> \WATCOM\SRC\STARTUP\WIN</TT> (Windows initialization)
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CSTRTW16.ASM&nbsp; (startup for 16-bit Windows apps)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; LIBENTRY.ASM&nbsp; (startup for 16-bit Windows DLLs)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; MDEF.INC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (macros included by assembly code)</TT>
<BR><BR><B>Under</B><TT> \WATCOM\SRC\STARTUP\OS2</TT> (OS/2 initialization)
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CMAIN086.C&nbsp;&nbsp;&nbsp; (final part of initialization sequence)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; MAINO16.C&nbsp;&nbsp;&nbsp;&nbsp; (middle part of initialization sequence)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CSTRTO16.ASM&nbsp; (startup for 16-bit OS/2)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; EXITWMSG.H&nbsp;&nbsp;&nbsp; (header file required by MAINO16.C)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; WOS2.H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (header file required by MAINO16.C)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; INITFINI.H&nbsp;&nbsp;&nbsp; (header file required by MAINO16.C)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; MDEF.INC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (macros included by assembly code)</TT>
<BR><BR>The following is a summary description of the startup files for DOS.&nbsp; The startup files for Windows and OS/2
are similar.&nbsp; The assembler file<TT> CSTRT086.ASM</TT> contains the first part of the initialization code and the remainder
is continued in the file<TT> CMAIN086.C.</TT>&nbsp; It is<TT> CMAIN086.C</TT> that calls your main routine<TT> (main).</TT>
<BR><BR>The<TT> DOS16M.ASM</TT> file is a special version of the<TT> CSTRT086.ASM</TT> file which is required when using the
Tenberry Software, Inc.&nbsp; DOS/16M 286 DOS extender.
<BR><BR>(32-bit only) The initialization code directories/files are listed below:
<BR><BR><B>Under</B><TT> \WATCOM\SRC\STARTUP</TT> 
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; WILDARGV.C&nbsp;&nbsp; (wild card processing for argv)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 8087CW.C&nbsp;&nbsp;&nbsp;&nbsp; (value loaded into 80x87 control word)</TT>
<BR><BR><B>Under</B><TT> \WATCOM\SRC\STARTUP\386</TT> 
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CSTRT386.ASM (startup for most DOS Extenders)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CSTRTW32.ASM (startup for 32-bit Windows)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CSTRTX32.ASM (startup for FlashTek DOS Extender)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; CMAIN386.C&nbsp;&nbsp; (final part of initialization sequence)</TT>
<BR><BR>The assembler files<TT> CSTRT*.ASM</TT> contain the first part of the initialization code and the remainder is continued
in the file<TT> CMAIN386.C.</TT>&nbsp; It is<TT> CMAIN386.C</TT> that calls your main routine<TT> (main).</TT>
<BR><BR>The source code is provided for those who wish to customize the initialization sequence for special applications.
<BR><BR>The file<TT> wildargv.c</TT> contains an alternate form of &quot;argv&quot; processing in which wild card command
line arguments are transformed into lists of matching file names.&nbsp; Wild card arguments are any arguments containing &quot;*&quot;
or &quot;?&quot; characters unless the argument is placed within quotes (&quot;).&nbsp; Consider the following example in
which we run an application called &quot;TOUCH&quot; with the argument &quot;*.c&quot;.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;touch *.c</TT>
<BR><BR>Suppose that the application was linked with the object code for the file<TT> wildargv.c.</TT>&nbsp; Suppose that
the files<TT> ap1.c</TT>,<TT> ap2.c</TT> and<TT> ap3.c</TT> are stored in the current directory.&nbsp; The single argument
&quot;*.c&quot; is transformed into a list of arguments such that:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; argc == 4</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; argv[1] points to &quot;ap1.c&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; argv[2] points to &quot;ap2.c&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; argv[3] points to &quot;ap3.c&quot;</TT>
<BR><BR>The source file<TT> wildargv.c</TT> must be compiled to produce the object file<TT> wildargv.obj.</TT>&nbsp; This
file must be specified before the Open Watcom C/C++ libraries in the linker command file in order to replace the standard
&quot;argv&quot; processing.
<H1 ID="16Mbit_Memory_Models"> 16-bit Memory Models </H1>
<BR><BR>This chapter describes the various 16-bit memory models supported by Open Watcom C/C++.&nbsp; Each memory model is
distinguished by two properties; the code model used to implement function calls and the data model used to reference data.
<H2 ID="16Mbit_Code_Models"> 16-bit Code Models </H2>
<BR>There are two code models;
<OL>
<LI>the small code model and
<LI>the big code model.
</OL>
<BR>A small code model is one in which all calls to functions are made with<B> near calls.</B>&nbsp; In a near call, the destination
address is 16 bits and is relative to the segment value in segment register CS.&nbsp; Hence, in a small code model, all code
comprising your program, including library functions, must be less than 64K.
<BR><BR>A big code model is one in which all calls to functions are made with<B> far calls.</B>&nbsp; In a far call, the destination
address is 32 bits (a segment value and an offset relative to the segment value).&nbsp; This model allows the size of the
code comprising your program to exceed 64K.
<HR>
<BR><B><I>&nbsp; Note:</I></B>&nbsp; If your program contains less than 64K of code, you should use a memory model that employs
the small code model.&nbsp; This will result in smaller and faster code since near calls are smaller instructions and are
processed faster by the CPU.
<HR>
<H2 ID="16Mbit_Data_Models"> 16-bit Data Models </H2>
<BR>There are three data models;
<OL>
<LI>the small data model,
<LI>the big data model and
<LI>the huge data model.
</OL>
<BR>A small data model is one in which all references to data are made with<B> near pointers.</B>&nbsp; Near pointers are
16 bits; all data references are made relative to the segment value in segment register DS.&nbsp; Hence, in a small data model,
all data comprising your program must be less than 64K.
<BR><BR>A big data model is one in which all references to data are made with<B> far pointers.</B>&nbsp; Far pointers are
32 bits (a segment value and an offset relative to the segment value).&nbsp; This removes the 64K limitation on data size
imposed by the small data model.&nbsp; However, when a far pointer is incremented, only the offset is adjusted.&nbsp; Open
Watcom C/C++ assumes that the offset portion of a far pointer will not be incremented beyond 64K.&nbsp; The compiler will
assign an object to a new segment if the grouping of data in a segment will cause the object to cross a segment boundary.
&nbsp;Implicit in this is the requirement that no individual object exceed 64K bytes.&nbsp; For example, an array containing
40,000 integers does not fit into the big data model.&nbsp; An object such as this should be described as<B> huge.</B>
<BR><BR>A huge data model is one in which all references to data are made with far pointers.&nbsp; This is similar to the
big data model.&nbsp; However, in the huge data model, incrementing a far pointer will adjust the offset<B> and</B> the segment
if necessary.&nbsp; The limit on the size of an object pointed to by a far pointer imposed by the big data model is removed
in the huge data model.
<BR><BR><B>Notes:</B>
<OL>
<LI>If your program contains less than 64K of data, you should use the small data model.&nbsp; This will result in smaller
and faster code since references using near pointers produce fewer instructions.
<LI>The huge data model should be used only if needed.&nbsp; The code generated in the huge data model is not very efficient
since a run-time routine is called in order to increment far pointers.&nbsp; This increases the size of the code significantly
and increases execution time.
</OL>
<H2 ID="Summary_of_16Mbit_Memory_Models"> Summary of 16-bit Memory Models </H2>
<BR>As previously mentioned, a memory model is a combination of a code model and a data model.&nbsp; The following table describes
the memory models supported by Open Watcom C/C++.&nbsp; 
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Memory&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Code&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Data
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Default&nbsp;&nbsp;&nbsp;&nbsp; Default</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Model&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Model&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Model
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Code&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Data</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Pointer
&nbsp;&nbsp;&nbsp; Pointer</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; --------&nbsp;&nbsp;&nbsp; --------&nbsp;&nbsp;&nbsp; --------&nbsp;&nbsp;&nbsp; --------
&nbsp;&nbsp; --------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; tiny&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; small&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
small&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; near&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; near</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; small&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; small&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; small
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; near&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; near</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; medium&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; big&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
small&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; far&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; near</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; compact&nbsp;&nbsp;&nbsp;&nbsp; small&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; big&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; near&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; far</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; large&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; big&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
big&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; far&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; far</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; huge&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; big&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;huge&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; far&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; huge</TT>
<H2 ID="Tiny_Memory_Model"> Tiny Memory Model </H2>
<BR>In the tiny memory model, the application's code and data must total less than 64K bytes in size.&nbsp; All code and data
are placed in the same segment.&nbsp; Use of the tiny memory model allows the creation of a COM file for the executable program
instead of an EXE file.&nbsp; For more information, see the section entitled &quot;Creating a Tiny Memory Model Application&quot;
in this chapter.
<H2 ID="Mixed_16Mbit_Memory_Model"> Mixed 16-bit Memory Model </H2>
<BR>A mixed memory model application combines elements from the various code and data models.&nbsp; A mixed memory model application
might be characterized as one that uses the<B><I> near</I></B> ,<B><I> far</I></B> , or<B><I> huge</I></B> keywords when describing
some of its functions or data objects.
<BR><BR>For example, a medium memory model application that uses some far pointers to data can be described as a mixed memory
model.&nbsp; In an application such as this, most of the data is in a 64K segment (DGROUP) and hence can be referenced with
near pointers relative to the segment value in segment register DS.&nbsp; This results in more efficient code being generated
and better execution times than one can expect from a big data model.&nbsp; Data objects outside of the DGROUP segment are
described with the<B><I> far</I></B> keyword.
<H2 ID="Linking_Applications_for_the_Various_16Mbit_Memory_Models"> Linking Applications for the Various 16-bit Memory Models </H2>
<BR>Each memory model requires different run-time and floating-point libraries.&nbsp; Each library assumes a particular memory
model and should be linked only with modules that have been compiled with the same memory model.&nbsp; The following table
lists the libraries that are to be used to link an application that has been compiled for a particular memory model.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Memory&nbsp; Run-time&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Floating-Point&nbsp; Floating-Point</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Model&nbsp;&nbsp; Library&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Calls Library&nbsp;&nbsp; Library
(80x87)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ------- --------&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --------------&nbsp; ---------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; tiny&nbsp;&nbsp;&nbsp; CLIBS.LIB&nbsp;&nbsp;&nbsp;&nbsp; MATHS.LIB&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; MATH87S.LIB</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +CSTART_T.OBJ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +(NO)EMU87.LIB*</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; small&nbsp;&nbsp; CLIBS.LIB&nbsp;&nbsp;&nbsp;&nbsp; MATHS.LIB&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; MATH87S.LIB</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;+(NO)EMU87.LIB*</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; medium&nbsp; CLIBM.LIB&nbsp;&nbsp;&nbsp;&nbsp; MATHM.LIB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;MATH87M.LIB</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;+(NO)EMU87.LIB*</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; compact CLIBC.LIB&nbsp;&nbsp;&nbsp;&nbsp; MATHC.LIB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
MATH87C.LIB</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;+(NO)EMU87.LIB*</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; large&nbsp;&nbsp; CLIBL.LIB&nbsp;&nbsp;&nbsp;&nbsp; MATHL.LIB&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; MATH87L.LIB</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;+(NO)EMU87.LIB*</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; huge&nbsp;&nbsp;&nbsp; CLIBH.LIB&nbsp;&nbsp;&nbsp;&nbsp; MATHH.LIB&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; MATH87H.LIB</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;+(NO)EMU87.LIB*</TT>
<BR><BR>* One of<TT> emu87.lib</TT> or<TT> noemu87.lib</TT> will be used with the 80x87 math libraries depending on the use
of the &quot;fpi&quot; (include emulation) or &quot;fpi87&quot; (do not include emulation) options.
<H2 ID="Creating_a_Tiny_Memory_Model_Application"> Creating a Tiny Memory Model Application </H2>
<BR>Tiny memory model programs are created by compiling all modules with the small memory model option and linking in the
special initialization file &quot;CSTART_T.OBJ&quot;.&nbsp; This file is found in the Open Watcom C/C++<TT> LIB286\DOS</TT>
directory.&nbsp; It must be the first object file specified when linking the program.
<BR><BR>The following sequence will create the executable file &quot;MYPROG.COM&quot; from the file &quot;MYPROG.C&quot;:
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wcc myprog /ms</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wlink system com file myprog</TT>
<BR><BR>Most of the details of linking a &quot;COM&quot; program are handled by the &quot;SYSTEM COM&quot; directive (see
the<TT> wlsystem.lnk</TT> file for details).&nbsp; When linking a &quot;COM&quot; program, the message &quot;Stack segment
not found&quot; is issued.&nbsp; This message may be ignored.
<H2 ID="16Mbit_Memory_Layout"> 16-bit Memory Layout </H2>
<BR>The following describes the segment ordering of an application linked by the Open Watcom Linker.&nbsp; Note that this
assumes that the &quot;DOSSEG&quot; linker option has been specified.&nbsp; 
<OL>
<LI>all segments not belonging to group &quot;DGROUP&quot; with class &quot;CODE&quot;
<LI>all other segments not belonging to group &quot;DGROUP&quot;
<LI>all segments belonging to group &quot;DGROUP&quot; with class &quot;BEGDATA&quot;
<LI>all segments belonging to group &quot;DGROUP&quot; not with class &quot;BEGDATA&quot;, &quot;BSS&quot; or &quot;STACK&quot;
<LI>all segments belonging to group &quot;DGROUP&quot; with class &quot;BSS&quot;
<LI>all segments belonging to group &quot;DGROUP&quot; with class &quot;STACK&quot;
</OL>
<BR>A special segment belonging to class &quot;BEGDATA&quot; is defined when linking with Open Watcom run-time libraries.
&nbsp;This segment is initialized with the hexadecimal byte pattern &quot;01&quot; and is the first segment in group &quot;DGROUP&quot;
so that storing data at location 0 can be detected.
<BR><BR>Segments belonging to class &quot;BSS&quot; contain uninitialized data.&nbsp; Note that this only includes uninitialized
data in segments belonging to group &quot;DGROUP&quot;.&nbsp; Segments belonging to class &quot;STACK&quot; are used to define
the size of the stack used for your application.&nbsp; Segments belonging to the classes &quot;BSS&quot; and &quot;STACK&quot;
are last in the segment ordering so that uninitialized data need not take space in the executable file.
<BR><BR>In addition to these special segments, the following conventions are used by Open Watcom C/C++.
<OL>
<LI>The &quot;CODE&quot; class contains the executable code for your application.&nbsp; In a small code model, this consists
of the segment &quot;_TEXT&quot;.&nbsp; In a big code model, this consists of the segments &quot;&lt;module&gt;_TEXT&quot;
where &lt;module&gt; is the file name of the source file.
<LI>The &quot;FAR_DATA&quot; class consists of the following:
<DL>
<DT>(a)
<DD>data objects whose size exceeds the data threshold in large data memory models (the data threshold is 32K unless changed using
the &quot;zt&quot; compiler option)
<DT>(b)
<DD>data objects defined using the &quot;FAR&quot; or &quot;HUGE&quot; keyword,
<DT>(c)
<DD>literals whose size exceeds the data threshold in large data memory models (the data threshold is 32K unless changed using
the &quot;zt&quot; compiler option)
<DT>(d)
<DD>literals defined using the &quot;FAR&quot; or &quot;HUGE&quot; keyword.
</DL>
</OL>
<BR>You can override the default naming convention used by Open Watcom C/C++ to name segments.
<OL>
<LI>The Open Watcom C/C++ &quot;nm&quot; option can be used to change the name of the module.&nbsp; This, in turn, changes
the name of the code segment when compiling for a big code model.
<LI>The Open Watcom C/C++ &quot;nt&quot; option can be used to specify the name of the code segment regardless of the code
model used.
</OL>
<H1 ID="16Mbit_Assembly_Language_Considerations"> 16-bit Assembly Language Considerations </H1>
<BR>This chapter will deal with the following topics.
<OL>
<LI>The data representation of the basic types supported by Open Watcom C/C++.
<LI>The memory layout of a Open Watcom C/C++ program.
<LI>The method for passing arguments and returning values.
<LI>The two methods for passing floating-point arguments and returning floating-point values.
<BR><BR>One method is used when one of the Open Watcom C/C++ &quot;fpi&quot; or &quot;fpi87&quot; options is specified for
the generation of in-line 80x87 instructions.&nbsp; When the &quot;fpi&quot; option is specified, an 80x87 emulator is included
from a math library if the application includes floating-point operations.&nbsp; When the &quot;fpi87&quot; option is used
exclusively, the 80x87 emulator will not be included.
<BR><BR>The other method is used when the Open Watcom C/C++ &quot;fpc&quot; option is specified.&nbsp; In this case, the compiler
generates calls to floating-point support routines in the alternate math libraries.
</OL>
<BR>An understanding of the Intel 80x86 architecture is assumed.
<H2 ID="16Mbit__Data_Representation"> 16-bit:&nbsp; Data Representation </H2>
<BR>This section describes the internal or machine representation of the basic types supported by Open Watcom C/C++.
<H3 ID="16Mbit__Type__char_"> 16-bit:&nbsp; Type &quot;char&quot; </H3>
<BR>An item of type &quot;char&quot; occupies 1 byte of storage.&nbsp; Its value is in the following range.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0 &lt;= n &lt;= 255</TT>
<BR><BR>Note that &quot;char&quot; is, by default, unsigned.&nbsp; The Open Watcom C/C++ compiler option &quot;j&quot; can
be used to change the default from unsigned to signed.&nbsp; If &quot;char&quot; is signed, an item of type &quot;char&quot;
is in the following range.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -128 &lt;= n &lt;= 127</TT>
<BR><BR>You can force an item of type &quot;char&quot; to be unsigned or signed regardless of the default by defining them
to be of type &quot;unsigned char&quot; or &quot;signed char&quot; respectively.
<H3 ID="16Mbit__Type__short_int_"> 16-bit:&nbsp; Type &quot;short int&quot; </H3>
<BR>An item of type &quot;short int&quot; occupies 2 bytes of storage.&nbsp; Its value is in the following range.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -32768 &lt;= n &lt;= 32767</TT>
<BR><BR>Note that &quot;short int&quot; is signed and hence &quot;short int&quot; and &quot;signed short int&quot; are equivalent.
&nbsp;If an item of type &quot;short int&quot; is to be unsigned, it must be defined as &quot;unsigned short int&quot;.&nbsp;
In this case, its value is in the following range.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0 &lt;= n &lt;= 65535</TT>
<H3 ID="16Mbit__Type__long_int_"> 16-bit:&nbsp; Type &quot;long int&quot; </H3>
<BR>An item of type &quot;long int&quot; occupies 4 bytes of storage.&nbsp; Its value is in the following range.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -2147483648 &lt;= n &lt;= 2147483647</TT>
<BR><BR>Note that &quot;long int&quot; is signed and hence &quot;long int&quot; and &quot;signed long int&quot; are equivalent.
&nbsp;If an item of type &quot;long int&quot; is to be unsigned, it must be defined as &quot;unsigned long int&quot;.&nbsp;
In this case, its value is in the following range.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0 &lt;= n &lt;= 4294967295</TT>
<H3 ID="16Mbit__Type__int_"> 16-bit:&nbsp; Type &quot;int&quot; </H3>
<BR>An item of type &quot;int&quot; occupies 2 bytes of storage.&nbsp; Its value is in the following range.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -32768 &lt;= n &lt;= 32767</TT>
<BR><BR>Note that &quot;int&quot; is signed and hence &quot;int&quot; and &quot;signed int&quot; are equivalent.&nbsp; If
an item of type &quot;int&quot; is to be unsigned, it must be defined as &quot;unsigned int&quot;.&nbsp; In this case its
value is in the following range.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0 &lt;= n &lt;= 65535</TT>
<BR><BR>If you are generating code that executes in 16-bit mode, &quot;short int&quot; and &quot;int&quot; are equivalent,
&quot;unsigned short int&quot; and &quot;unsigned int&quot; are equivalent, and &quot;signed short int&quot; and &quot;signed
int&quot; are equivalent.&nbsp; This may not be the case in other environments where &quot;int&quot; and &quot;long int&quot;
are 4 bytes.
<H3 ID="16Mbit__Type__float_"> 16-bit:&nbsp; Type &quot;float&quot; </H3>
<BR>A datum of type &quot;float&quot; is an approximate representation of a real number.&nbsp; Each datum of type &quot;float&quot;
occupies 4 bytes.&nbsp; If<TT> m</TT> is the magnitude of<TT> x</TT> (an item of type &quot;float&quot;) then<TT> x</TT> can
be approximated if
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -126&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 128</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;= m &lt;&nbsp; 2</TT>
<BR><BR>or in more approximate terms if
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 1.175494e-38 &lt;= m &lt;= 3.402823e38</TT>
<BR><BR>Data of type &quot;float&quot; are represented internally as follows.&nbsp; Note that bytes are stored in memory with
the least significant byte first and the most significant byte last.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +---+---------+---------------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; | S | Biased&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Significand&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; | Exponent|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +---+---------+---------------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 31&nbsp;&nbsp;&nbsp; 30-23&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
22-0</TT>
<DL>
<DT>Notes
<DD>
<DT>S
<DD>S = Sign bit (0=positive, 1=negative)
<DT>Exponent
<DD>The exponent bias is 127 (i.e., exponent value 1 represents 2**-126; exponent value 127 represents 2**0; exponent value 254
represents 2**127; etc.).&nbsp; The exponent field is 8 bits long.
<DT>Significand
<DD>The leading bit of the significand is always 1, hence it is not stored in the significand field.&nbsp; Thus the significand
is always &quot;normalized&quot;.&nbsp; The significand field is 23 bits long.
<DT>Zero
<DD>A real zero quantity occurs when the sign bit, exponent, and significand are all zero.
<DT>Infinity
<DD>When the exponent field is all 1 bits and the significand field is all zero bits then the quantity represents positive or
negative infinity, depending on the sign bit.
<DT>Not Numbers
<DD>When the exponent field is all 1 bits and the significand field is non-zero then the quantity is a special value called a
NAN (Not-A-Number).
<BR><BR>When the exponent field is all 0 bits and the significand field is non-zero then the quantity is a special value called
a &quot;denormal&quot; or nonnormal number.
</DL>
<H3 ID="16Mbit__Type__double_"> 16-bit:&nbsp; Type &quot;double&quot; </H3>
<BR>A datum of type &quot;double&quot; is an approximate representation of a real number.&nbsp; The precision of a datum of
type &quot;double&quot; is greater than or equal to one of type &quot;float&quot;.&nbsp; Each datum of type &quot;double&quot;
occupies 8 bytes.&nbsp; If<TT> m</TT> is the magnitude of<TT> x</TT> (an item of type &quot;double&quot;) then<TT> x</TT>
can be approximated if
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -1022&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1024</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;= m &lt;&nbsp; 2</TT>
<BR><BR>or in more approximate terms if
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 2.2250738585072e-308 &lt;= m &lt;= 1.79769313486232e308</TT>
<BR><BR>Data of type &quot;double&quot; are represented internally as follows.&nbsp; Note that bytes are stored in memory
with the least significant byte first and the most significant byte last.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +---+---------+--------------------------------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; | S | Biased&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;Significand&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; | Exponent|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +---+---------+--------------------------------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 63&nbsp;&nbsp;&nbsp; 62-52&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 51-0</TT>
<DL>
<DT>Notes:
<DD>
<DT>S
<DD>S = Sign bit (0=positive, 1=negative)
<DT>Exponent
<DD>The exponent bias is 1023 (i.e., exponent value 1 represents 2**-1022; exponent value 1023 represents 2**0; exponent value
2046 represents 2**1023; etc.).&nbsp; The exponent field is 11 bits long.
<DT>Significand
<DD>The leading bit of the significand is always 1, hence it is not stored in the significand field.&nbsp; Thus the significand
is always &quot;normalized&quot;.&nbsp; The significand field is 52 bits long.
<DT>Zero
<DD>A double precision zero quantity occurs when the sign bit, exponent, and significand are all zero.
<DT>Infinity
<DD>When the exponent field is all 1 bits and the significand field is all zero bits then the quantity represents positive or
negative infinity, depending on the sign bit.
<DT>Not Numbers
<DD>When the exponent field is all 1 bits and the significand field is non-zero then the quantity is a special value called a
NAN (Not-A-Number).
<BR><BR>When the exponent field is all 0 bits and the significand field is non-zero then the quantity is a special value called
a &quot;denormal&quot; or nonnormal number.
</DL>
<H2 ID="16Mbit__Memory_Layout"> 16-bit:&nbsp; Memory Layout </H2>
<BR>The following describes the segment ordering of an application linked by the Open Watcom Linker.&nbsp; Note that this
assumes that the &quot;DOSSEG&quot; linker option has been specified.&nbsp; 
<OL>
<LI>all segments not belonging to group &quot;DGROUP&quot; with class &quot;CODE&quot;
<LI>all other segments not belonging to group &quot;DGROUP&quot;
<LI>all segments belonging to group &quot;DGROUP&quot; with class &quot;BEGDATA&quot;
<LI>all segments belonging to group &quot;DGROUP&quot; not with class &quot;BEGDATA&quot;, &quot;BSS&quot; or &quot;STACK&quot;
<LI>all segments belonging to group &quot;DGROUP&quot; with class &quot;BSS&quot;
<LI>all segments belonging to group &quot;DGROUP&quot; with class &quot;STACK&quot;
</OL>
<BR>A special segment belonging to class &quot;BEGDATA&quot; is defined when linking with Open Watcom run-time libraries.
&nbsp;This segment is initialized with the hexadecimal byte pattern &quot;01&quot; and is the first segment in group &quot;DGROUP&quot;
so that storing data at location 0 can be detected.
<BR><BR>Segments belonging to class &quot;BSS&quot; contain uninitialized data.&nbsp; Note that this only includes uninitialized
data in segments belonging to group &quot;DGROUP&quot;.&nbsp; Segments belonging to class &quot;STACK&quot; are used to define
the size of the stack used for your application.&nbsp; Segments belonging to the classes &quot;BSS&quot; and &quot;STACK&quot;
are last in the segment ordering so that uninitialized data need not take space in the executable file.
<BR><BR>In addition to these special segments, the following conventions are used by Open Watcom C/C++.
<OL>
<LI>The &quot;CODE&quot; class contains the executable code for your application.&nbsp; In a small code model, this consists
of the segment &quot;_TEXT&quot;.&nbsp; In a big code model, this consists of the segments &quot;&lt;module&gt;_TEXT&quot;
where &lt;module&gt; is the file name of the source file.
<LI>The &quot;FAR_DATA&quot; class consists of the following:
<DL>
<DT>(a)
<DD>data objects whose size exceeds the data threshold in large data memory models (the data threshold is 32K unless changed using
the &quot;zt&quot; compiler option)
<DT>(b)
<DD>data objects defined using the &quot;FAR&quot; or &quot;HUGE&quot; keyword,
<DT>(c)
<DD>literals whose size exceeds the data threshold in large data memory models (the data threshold is 32K unless changed using
the &quot;zt&quot; compiler option)
<DT>(d)
<DD>literals defined using the &quot;FAR&quot; or &quot;HUGE&quot; keyword.
</DL>
</OL>
<BR>You can override the default naming convention used by Open Watcom C/C++ to name segments.
<OL>
<LI>The Open Watcom C/C++ &quot;nm&quot; option can be used to change the name of the module.&nbsp; This, in turn, changes
the name of the code segment when compiling for a big code model.
<LI>The Open Watcom C/C++ &quot;nt&quot; option can be used to specify the name of the code segment regardless of the code
model used.
</OL>
<H2 ID="16Mbit__Calling_Conventions_for_NonM80x87_Applications"> 16-bit:&nbsp; Calling Conventions for Non-80x87 Applications </H2>
<BR>The following sections describe the calling convention used when compiling with the &quot;fpc&quot; compiler option.
<H3 ID="16Mbit__Passing_Arguments_Using_RegisterMBased_Calling_Conventions"> 16-bit:&nbsp; Passing Arguments Using Register-Based Calling Conventions </H3>
<BR>How arguments are passed to a function with register-based calling conventions is determined by the size (in bytes) of
the argument and where in the argument list the argument appears.&nbsp; Depending on the size, arguments are either passed
in registers or on the stack.&nbsp; Arguments such as structures are almost always passed on the stack since they are generally
too large to fit in registers.&nbsp; Since arguments are processed from left to right, the first few arguments are likely
to be passed in registers (if they can fit) and, if the argument list contains many arguments, the last few arguments are
likely to be passed on the stack.
<BR><BR>The registers used to pass arguments to a function are AX, BX, CX and DX.&nbsp; The following algorithm describes
how arguments are passed to functions.
<BR><BR>Initially, we have the following registers available for passing arguments:&nbsp; AX, DX, BX and CX.&nbsp; Note that
registers are selected from this list in the order they appear.&nbsp; That is, the first register selected is AX and the last
is CX.&nbsp; For each argument<B> Ai,</B> starting with the left most argument, perform the following steps.
<OL>
<LI>If the size of<B> Ai</B> is 1 byte, convert it to 2 bytes and proceed to the next step.&nbsp; If<B> Ai</B> is of type
&quot;unsigned char&quot;, it is converted to an &quot;unsigned int&quot;.&nbsp; If<B> Ai</B> is of type &quot;signed char&quot;,
it is converted to a &quot;signed int&quot;.&nbsp; If<B> Ai</B> is a 1-byte structure, the padding is determined by the compiler.
<LI>If an argument has already been assigned a position on the stack,<B> Ai</B> will also be assigned a position on the stack.
&nbsp;Otherwise, proceed to the next step.
<LI>If the size of<B> Ai</B> is 2 bytes, select a register from the list of available registers.&nbsp; If a register is available,<B>
Ai</B> is assigned that register.&nbsp; The register is then removed from the list of available registers.&nbsp; If no registers
are available,<B> Ai</B> will be assigned a position on the stack.
<LI>If the size of<B> Ai</B> is 4 bytes, select a register pair from the following list of combinations:&nbsp; [DX AX] or
[CX BX].&nbsp; The first available register pair is assigned to<B> Ai</B> and removed from the list of available pairs.&nbsp;
The high-order 16 bits of the argument are assigned to the first register in the pair; the low-order 16 bits are assigned
to the second register in the pair.&nbsp; If none of the above register pairs is available,<B> Ai</B> will be assigned a position
on the stack.
<LI>If the type of<B> Ai</B> is &quot;double&quot; or &quot;float&quot; (in the absence of a function prototype), select [AX
BX CX DX] from the list of available registers.&nbsp; All four registers are removed from the list of available registers.
&nbsp;The high-order 16 bits of the argument are assigned to the first register and the low-order 16 bits are assigned to
the fourth register.&nbsp; If any of the four registers is not available,<B> Ai</B> will be assigned a position on the stack.
<LI>All other arguments will be assigned a position on the stack.
</OL>
<BR><B>Notes:</B>
<OL>
<LI>Arguments that are assigned a position on the stack are padded to a multiple of 2 bytes.&nbsp; That is, if a 3-byte structure
is assigned a position on the stack, 4 bytes will be pushed on the stack.
<LI>Arguments that are assigned a position on the stack are pushed onto the stack starting with the rightmost argument.
</OL>
<H3 ID="16Mbit__Sizes_of_Predefined_Types"> 16-bit:&nbsp; Sizes of Predefined Types </H3>
<BR>The following table lists the predefined types, their size as returned by the &quot;sizeof&quot; function, the size of
an argument of that type and the registers used to pass that argument if it was the only argument in the argument list.&nbsp;

<BR><BR><B>&nbsp;&nbsp;&nbsp; Basic</B>
<BR><B>Type&nbsp;&nbsp;&nbsp; &quot;sizeof&quot;&nbsp;&nbsp;&nbsp; Argument&nbsp; Registers</B>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Used</B>
<BR>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; [AX]
<BR>&nbsp;&nbsp;&nbsp; short int 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [AX]
<BR>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; [AX]
<BR>&nbsp;&nbsp;&nbsp; long int&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [DX AX]
<BR>&nbsp;&nbsp;&nbsp; float&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;[AX BX CX DX]
<BR>&nbsp;&nbsp;&nbsp; double&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[AX BX CX DX]
<BR>&nbsp;&nbsp;&nbsp; near
<BR>pointer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[AX]
<BR>&nbsp;&nbsp;&nbsp; far
<BR>pointer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[DX AX]
<BR>&nbsp;&nbsp;&nbsp; huge
<BR>pointer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[DX AX]
<BR><B>Note that the size of the argument listed in the table assumes that no function prototypes are specified.</B>&nbsp;
Function prototypes affect the way arguments are passed.&nbsp; This will be discussed in the section entitled &quot;Effect
of Function Prototypes on Arguments&quot;.
<BR><BR><B>Notes:</B>
<OL>
<LI>Provided no function prototypes exist, an argument will be converted to a default type as described in the following table.
<DL>
<DT>Argument Type
<DD>Passed As
<DT>char
<DD>unsigned int
<DT>signed char
<DD>signed int
<DT>unsigned char
<DD>unsigned int
<DT>float
<DD>double
</DL>
</OL>
<H3 ID="16Mbit__Size_of_Enumerated_Types"> 16-bit:&nbsp; Size of Enumerated Types </H3>
<BR>The integral type of an enumerated type is determined by the values of the enumeration constants.&nbsp; In strict ISO/ANSI
C mode, all enumerated constants are of type<TT> int.</TT>&nbsp; In the extensions mode, the compiler will use the smallest
integral type possible (excluding<TT> long</TT> ints) that can represent all values of the enumerated type.&nbsp; For instance,
if the minimum and maximum values of the enumeration constants are in the range -128 and 127, the enumerated type will be
equivalent to a<TT> signed char</TT> (size = 1 byte).&nbsp; All references to enumerated constants in the previous instance
will have type<TT> signed char.</TT>&nbsp; An enumerated constant is always promoted to an<TT> int</TT> when passed as an
argument.
<H3 ID="16Mbit__Effect_of_Function_Prototypes_on_Arguments"> 16-bit:&nbsp; Effect of Function Prototypes on Arguments </H3>
<BR>Function prototypes define the types of the formal parameters of a function.&nbsp; Their appearance affects the way in
which arguments are passed.&nbsp; An argument will be converted to the type of the corresponding formal parameter in the function
prototype.&nbsp; Consider the following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void prototype( float x, int i );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float x;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = 3.14;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = 314;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prototype( x, i );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rtn( x, i );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The function prototype for<TT> prototype</TT> specifies that the first argument is to be passed as a &quot;float&quot;
and the second argument is to be passed as an &quot;int&quot;.&nbsp; This results in the first argument being passed in registers
DX and AX and the second argument being passed in register BX.
<BR><BR>If no function prototype is given, as is the case for the function<TT> rtn,</TT> the first argument will be passed
as a &quot;double&quot; and the second argument would be passed as an &quot;int&quot;.&nbsp; This results in the first argument
being passed in registers AX, BX, CX and DX and the second argument being passed on the stack.
<BR><BR>Note that even though both<TT> prototype</TT> and<TT> rtn</TT> were called with identical argument lists, the way
in which the arguments were passed was completely different simply because a function prototype for<TT> prototype</TT> was
specified.&nbsp; Function prototyping is an excellent way to guarantee that arguments will be passed as expected to your assembly
language function.
<H3 ID="16Mbit__Interfacing_to_Assembly_Language_Functions"> 16-bit:&nbsp; Interfacing to Assembly Language Functions </H3>
<BR>Consider the following example.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long int x;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long int y;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = 7;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = 77;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y = 777;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myrtn( x, i, y );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>myrtn</TT> is an assembly language function that requires three arguments.&nbsp; The first argument is of type
&quot;long int&quot;, the second argument is of type &quot;int&quot; and the third argument is again of type &quot;long int&quot;.
&nbsp;Using the rules for register-based calling conventions, these arguments will be passed to<TT> myrtn</TT> in the following
way:
<OL>
<LI>The first argument will be passed in registers DX and AX leaving BX and CX as available registers for other arguments.
<LI>The second argument will be passed in register BX leaving CX as an available register for other arguments.
<LI>The third argument will not fit in register CX (its size is 4 bytes) and hence will be pushed on the stack.
</OL>
<BR>Let us look at the stack upon entry to<TT> myrtn.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp; Small Code Model</B>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Offset</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; | return address | &lt;- SP points here</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp; | argument #3&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp; Big Code Model</B>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Offset</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; | return address | &lt;- SP points here</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp; | argument #3&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><BR><B>Notes:</B>
<OL>
<LI>The return address is the top element on the stack.&nbsp; In a small code model, the return address is 1 word (16 bits);
in a big code model, the return address is 2 words (32 bits).
</OL>
<BR>Register SP cannot be used as a base register to address the third argument on the stack.&nbsp; Register BP is normally
used to address arguments on the stack.&nbsp; Upon entry to the function, register BP is set to point to the stack but before
doing so we must save its contents.&nbsp; The following two instructions achieve this.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; BP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; save
current value of BP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; BP,SP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; get access
to arguments</TT>
<BR><BR>After executing these instructions, the stack looks like this.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp; Small Code Model</B>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Offset</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; | saved BP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | &lt;-
BP and SP point here</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp; | return address |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp; | argument #3&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp; Big Code Model</B>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Offset</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; | saved BP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | &lt;-
BP and SP point here</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp; | return address |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6&nbsp;&nbsp;&nbsp;&nbsp; | argument #3&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><BR>As the above diagrams show, the third argument is at offset 4 from register BP in a small code model and offset 6
in a big code model.
<BR><BR>Upon exit from<TT> myrtn,</TT> we must restore the value of BP.&nbsp; The following two instructions achieve this.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; SP,BP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; restore stack
pointer</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;&nbsp;&nbsp; BP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; restore BP</TT>
<BR><BR>The following is a sample assembly language function which implements<TT> myrtn.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp; Small Memory Model (small code, small data)</B>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DGROUP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; group&nbsp;&nbsp; _DATA, _BSS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; segment byte public 'CODE'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assume
&nbsp;CS:_TEXT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assume
&nbsp;DS:DGROUP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public
&nbsp;myrtn_</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; myrtn_&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; proc&nbsp;&nbsp;&nbsp; near</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push
&nbsp;&nbsp; BP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; save
BP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;
&nbsp;&nbsp; BP,SP&nbsp;&nbsp;&nbsp;&nbsp; ; get access to arguments</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ; body of function</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;
&nbsp;&nbsp; SP,BP&nbsp;&nbsp;&nbsp;&nbsp; ; restore SP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;
&nbsp;&nbsp; BP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; restore
BP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret&nbsp;
&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; return and pop last arg</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; myrtn_&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ends</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp; Large Memory Model (big code, big data)</B>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DGROUP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; group&nbsp;&nbsp; _DATA, _BSS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; MYRTN_TEXT segment byte public 'CODE'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assume
&nbsp;CS:MYRTN_TEXT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public
&nbsp;myrtn_</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; myrtn_&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; proc&nbsp;&nbsp;&nbsp; far</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push
&nbsp;&nbsp; BP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; save
BP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;
&nbsp;&nbsp; BP,SP&nbsp;&nbsp;&nbsp;&nbsp; ; get access to arguments</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ; body of function</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;
&nbsp;&nbsp; SP,BP&nbsp;&nbsp;&nbsp;&nbsp; ; restore SP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;
&nbsp;&nbsp; BP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; restore
BP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret&nbsp;
&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; return and pop last arg</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; myrtn_&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; MYRTN_TEXT ends</TT>
<BR><BR><B>Notes:</B>
<OL>
<LI>Global function names must be followed with an underscore.&nbsp; Global variable names must be preceded with an underscore.
<LI>All used 80x86 registers must be saved on entry and restored on exit except those used to pass arguments and return values,
and AX, which is considered a stratch register.&nbsp; Note that segment registers only have to saved and restored if you are
compiling your application with the &quot;r&quot; option.
<LI>The direction flag must be clear before returning to the caller.
<LI>In a small code model, any segment containing executable code must belong to the segment &quot;_TEXT&quot; and the class
&quot;CODE&quot;.&nbsp; The segment &quot;_TEXT&quot; must have a &quot;combine&quot; type of &quot;PUBLIC&quot;.&nbsp; On
entry, CS contains the segment address of the segment &quot;_TEXT&quot;.&nbsp; In a big code model there is no restriction
on the naming of segments which contain executable code.
<LI>In a small data model, segment register DS contains the segment address of the group &quot;DGROUP&quot;.&nbsp; This is
not the case in a big data model.
<LI>When writing assembly language functions for the small code model, you must declare them as &quot;near&quot;.&nbsp; If
you wish to write assembly language functions for the big code model, you must declare them as &quot;far&quot;.
<LI>In general, when naming segments for your code or data, you should follow the conventions described in the section entitled
&quot;Memory Layout&quot; in this chapter.
<LI>If any of the arguments was pushed onto the stack, the called routine must pop those arguments off the stack in the &quot;ret&quot;
instruction.
</OL>
<H3 ID="16Mbit__Functions_with_Variable_Number_of_Arguments"> 16-bit:&nbsp; Functions with Variable Number of Arguments </H3>
<BR>A function prototype with a parameter list that ends with &quot;,...&quot; has a variable number of arguments.&nbsp; In
this case, all arguments are passed on the stack.&nbsp; Since no prototyping information exists for arguments represented
by &quot;,...&quot;, those arguments are passed as described in the section &quot;Passing Arguments&quot;.
<H3 ID="16Mbit__Returning_Values_from_Functions"> 16-bit:&nbsp; Returning Values from Functions </H3>
<BR>The way in which function values are returned depends on the size of the return value.&nbsp; The following examples describe
how function values are to be returned.&nbsp; They are coded for a small code model.&nbsp; 
<OL>
<LI>1-byte values are to be returned in register AL.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXT&nbsp;&nbsp; segment byte public 'CODE'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assume&nbsp; CS:_TEXT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public&nbsp; Ret1_</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Ret1_&nbsp;&nbsp; proc&nbsp;&nbsp;&nbsp; near&nbsp;&nbsp; ; char Ret1()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; AL,'G'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Ret1_&nbsp;&nbsp; endp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXT&nbsp;&nbsp; ends</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<LI>2-byte values are to be returned in register AX.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXT&nbsp;&nbsp; segment byte public 'CODE'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assume&nbsp; CS:_TEXT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public&nbsp; Ret2_</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Ret2_&nbsp;&nbsp; proc&nbsp;&nbsp;&nbsp; near&nbsp;&nbsp; ; short int Ret2()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; AX,77</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Ret2_&nbsp;&nbsp; endp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXT&nbsp;&nbsp; ends</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<LI>4-byte values are to be returned in registers DX and AX with the most significant word in register DX.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXT&nbsp;&nbsp; segment byte public 'CODE'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assume&nbsp; CS:_TEXT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public&nbsp; Ret4_</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Ret4_&nbsp;&nbsp; proc&nbsp;&nbsp;&nbsp; near&nbsp;&nbsp; ; long int Ret4()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; AX,word ptr CS:Val4+0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; DX,word ptr CS:Val4+2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Val4&nbsp;&nbsp;&nbsp; dd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7777777</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Ret4_&nbsp;&nbsp; endp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXT&nbsp;&nbsp; ends</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<LI>8-byte values, except structures, are to be returned in registers AX, BX, CX and DX with the most significant word in
register AX.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .8087</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXT&nbsp;&nbsp; segment byte public 'CODE'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assume&nbsp; CS:_TEXT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public&nbsp; Ret8_</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Ret8_&nbsp;&nbsp; proc&nbsp;&nbsp;&nbsp; near&nbsp;&nbsp; ; double Ret8()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; DX,word ptr CS:Val8+0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; CX,word ptr CS:Val8+2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; BX,word ptr CS:Val8+4</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; AX,word ptr CS:Val8+6</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Val8:&nbsp;&nbsp; dq&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7.7</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Ret8_&nbsp;&nbsp; endp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXT&nbsp;&nbsp; ends</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>The &quot;.8087&quot; pseudo-op must be specified so that all floating-point constants are generated in 8087 format.
&nbsp;When using the &quot;fpc&quot; (floating-point calls) option, &quot;float&quot; and &quot;double&quot; are returned
in registers.&nbsp; See section &quot;Returning Values in 80x87-based Applications&quot; when using the &quot;fpi&quot; or
&quot;fpi87&quot; options.
<LI>Otherwise, the caller allocates space on the stack for the return value and sets register SI to point to this area.&nbsp;
In a big data model, register SI contains an offset relative to the segment value in segment register SS.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXT&nbsp;&nbsp; segment byte public 'CODE'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assume&nbsp; CS:_TEXT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public&nbsp; RetX_</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ; struct int_values {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;&nbsp;&nbsp;&nbsp;&nbsp; int value1, value2, value3, value4, value5;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; RetX_&nbsp;&nbsp; proc&nbsp;&nbsp;&nbsp; near ; struct int_values RetX()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; word ptr SS:0[SI],71</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; word ptr SS:4[SI],72</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; word ptr SS:8[SI],73</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; word ptr SS:12[SI],74</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; word ptr SS:16[SI],75</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; RetX_&nbsp;&nbsp; endp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXT&nbsp;&nbsp; ends</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>When returning values on the stack, remember to use a segment override to the stack segment (SS).
</OL>
<BR>The following is an example of a Open Watcom C/C++ program calling the above assembly language subprograms.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct int_values {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int value1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int value2;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int value3;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int value4;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int value5;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;Ret1(void);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern&nbsp; short int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ret2(void);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern&nbsp; long int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ret4(void);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern&nbsp; double&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ret8(void);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern&nbsp; struct int_values RetX(void);</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct int_values x;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Ret1 = %c\n&quot;, Ret1() );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Ret2 = %d\n&quot;, Ret2() );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Ret4 = %ld\n&quot;, Ret4() );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Ret8 = %f\n&quot;, Ret8() );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = RetX();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;RetX1 = %d\n&quot;, x.value1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;RetX2 = %d\n&quot;, x.value2 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;RetX3 = %d\n&quot;, x.value3 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;RetX4 = %d\n&quot;, x.value4 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;RetX5 = %d\n&quot;, x.value5 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The above function should be compiled for a small code model (use the &quot;ms&quot; or &quot;mc&quot; compiler option).
<H2 ID="16Mbit__Calling_Conventions_for_80x87Mbased_Applications"> 16-bit:&nbsp; Calling Conventions for 80x87-based Applications </H2>
<BR>When a source file is compiled by Open Watcom C/C++ with one of the &quot;fpi&quot; or &quot;fpi87&quot; options, all
floating-point arguments are passed on the 80x86 stack.&nbsp; The rules for passing arguments are as follows.
<OL>
<LI>If the argument is not floating-point, use the procedure described earlier in this chapter.
<LI>If the argument is floating-point, it is assigned a position on the 80x86 stack.
</OL>
<H3 ID="16Mbit__Passing_Values_in_80x87Mbased_Applications"> 16-bit:&nbsp; Passing Values in 80x87-based Applications </H3>
<BR>Consider the following example.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern&nbsp; void&nbsp;&nbsp;&nbsp; myrtn(int,float,double,long int);</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float&nbsp;&nbsp;&nbsp; x;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double&nbsp;&nbsp; y;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long int j;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = 7.7;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = 7;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y = 77.77</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j = 77;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myrtn( i, x, y, j );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>myrtn</TT> is an assembly language function that requires four arguments.&nbsp; The first argument is of type
&quot;int&quot; ( 2 bytes), the second argument is of type &quot;float&quot; (4 bytes), the third argument is of type &quot;double&quot;
(8 bytes) and the fourth argument is of type &quot;long int&quot; (4 bytes).&nbsp; These arguments will be passed to<TT> myrtn</TT>
in the following way:
<OL>
<LI>The first argument will be passed in register AX leaving BX, CX and DX as available registers for other arguments.
<LI>The second argument will be passed on the 80x86 stack since it is a floating-point argument.
<LI>The third argument will also be passed on the 80x86 stack since it is a floating-point argument.
<LI>The fourth argument will be passed on the 80x86 stack since a previous argument has been assigned a position on the 80x86
stack.
</OL>
<BR>Remember, arguments are pushed on the stack from right to left.&nbsp; That is, the rightmost argument is pushed first.
<BR><BR>Any assembly language function must obey the following rule.
<OL>
<LI>All arguments passed on the stack must be removed by the called function.
</OL>
<BR>The following is a sample assembly language function which implements<TT> myrtn.</TT>
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .8087</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXT&nbsp;&nbsp; segment byte public 'CODE'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assume&nbsp; CS:_TEXT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public&nbsp; myrtn_</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; myrtn_&nbsp; proc&nbsp;&nbsp;&nbsp; near</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ; body of function</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret 16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; ; return and pop arguments</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; myrtn_&nbsp; endp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXT&nbsp;&nbsp; ends</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR><B>Notes:</B>
<OL>
<LI>Function names must be followed by an underscore.
<LI>All used 80x86 registers must be saved on entry and restored on exit except those used to pass arguments and return values,
and EAX, which is considered a stratch register.&nbsp; Note that segment registers only have to saved and restored if you
are compiling your application with the &quot;r&quot; option.&nbsp; In this example, AX does not have to be saved as it was
used to pass the first argument.&nbsp; Floating-point registers can be modified without saving their contents.
<LI>The direction flag must be clear before returning to the caller.
<LI>This function has been written for a small code model.&nbsp; Any segment containing executable code must belong to the
class &quot;CODE&quot; and the segment &quot;_TEXT&quot;.&nbsp; On entry, CS contains the segment address of the segment &quot;_TEXT&quot;.
&nbsp;The above restrictions do not apply in a big code memory model.
<LI>When writing assembly language functions for a small code model, you must declare them as &quot;near&quot;.&nbsp; If you
wish to write assembly language functions for a big code model, you must declare them as &quot;far&quot;.
</OL>
<H3 ID="16Mbit__Returning_Values_in_80x87Mbased_Applications"> 16-bit:&nbsp; Returning Values in 80x87-based Applications </H3>
<BR>Floating-point values are returned in ST(0) when using the &quot;fpi&quot; or &quot;fpi87&quot; options.&nbsp; All other
values are returned in the manner described earlier in this chapter.
<H1 ID="16Mbit_Pragmas"> 16-bit Pragmas </H1>
<BR>A pragma is a compiler directive that provides the following capabilities.
<UL>
<LI>Pragmas allow you to specify certain compiler options.
<LI>Pragmas can be used to direct the Open Watcom C/C++ code generator to emit specialized sequences of code for calling functions
which use argument passing and value return techniques that differ from the default used by Open Watcom C/C++.
<LI>Pragmas can be used to describe attributes of functions (such as side effects) that are not possible at the C/C++ language
level.&nbsp; The code generator can use this information to generate more efficient code.
<LI>Any sequence of in-line machine language instructions, including DOS and BIOS function calls, can be generated in the
object code.
</UL>
<BR>Pragmas are specified in the source file using the<B><I> pragma</I></B> directive.&nbsp; A pragma operator of the form,<B><I>
_Pragma</I></B> ( string-literal ) is an alternative method of specifying<B><I> pragma</I></B> directives.
<BR><BR>For example, the following two statements are equivalent.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _Pragma( &quot;library (\&quot;kernel32.lib\&quot;)&quot; )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma library (&quot;kernel32.lib&quot;)</TT>
<BR><BR>The<B><I> _Pragma</I></B> operator can be used in macro definition.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; # define LIBRARY(X) PRAGMA(library (#X))</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; # define PRAGMA(X) _Pragma(#X)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; LIBRARY(kernel32.lib)&nbsp; // same as #pragma library (&quot;kernel32.lib&quot;)</TT>
<BR><BR>The following notation is used to describe the syntax of pragmas.
<DL>
<DT>keywords
<DD>A<TT> keyword</TT> is shown in a mono-spaced courier font.
<DT>program-item
<DD>A<B><I> program-item</I></B> is shown in a roman bold-italics font.&nbsp; A<B><I> program-item</I></B> is a symbol name or
numeric value supplied by the programmer.
<DT>punctuation
<DD>A<TT> punctuation character</TT> shown in a mono-spaced courier font must be entered as is.
<BR><BR>A<B><I> punctuation character</I></B> shown in a roman bold-italics font is used to describe syntax.&nbsp; The following
syntactical notation is used.
<DL>
<DT>[abc]
<DD>The item<B> abc</B> is optional.
<DT>{abc}
<DD>The item<B> abc</B> may be repeated zero or more times.
<DT>a|b|c
<DD>One of<B> a, b</B> or<B> c</B> may be specified.
<DT>a ::= b
<DD>The item<B> a</B> is defined in terms of<B> b.</B>
<DT>(a)
<DD>Item<B> a</B> is evaluated first.
</DL>
</DL>
<BR>The following classes of pragmas are supported.
<UL>
<LI>pragmas that specify options
<LI>pragmas that specify default libraries
<LI>pragmas that describe the way structures are stored in memory
<LI>pragmas that provide auxiliary information used for code generation
</UL>
<H2 ID="16Mbit__Using_Pragmas_to_Specify_Options"> 16-bit:&nbsp; Using Pragmas to Specify Options </H2>
<BR>Currently, the following options can be specified with pragmas:&nbsp; 
<DL>
<DT>unreferenced
<DD>The &quot;unreferenced&quot; option controls the way Open Watcom C/C++ handles unused symbols.&nbsp; For example,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma on (unreferenced);</TT>
<BR><BR>will cause Open Watcom C/C++ to issue warning messages for all unused symbols.&nbsp; This is the default.&nbsp; Specifying
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma off (unreferenced);</TT>
<BR><BR>will cause Open Watcom C/C++ to ignore unused symbols.&nbsp; Note that if the warning level is not high enough, warning
messages for unused symbols will not be issued even if &quot;unreferenced&quot; was specified.
<DT>check_stack
<DD>The &quot;check_stack&quot; option controls the way stack overflows are to be handled.&nbsp; For example,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma on (check_stack);</TT>
<BR><BR>will cause stack overflows to be detected and
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma off (check_stack);</TT>
<BR><BR>will cause stack overflows to be ignored.&nbsp; When &quot;check_stack&quot; is on, Open Watcom C/C++ will generate
a run-time call to a stack-checking routine at the start of every routine compiled.&nbsp; This run-time routine will issue
an error if a stack overflow occurs when invoking the routine.&nbsp; The default is to check for stack overflows.&nbsp; Stack
overflow checking is particularly useful when functions are invoked recursively.&nbsp; Note that if the stack overflows and
stack checking has been suppressed, unpredictable results can occur.
<BR><BR>If a stack overflow does occur during execution and you are sure that your program is not in error (i.e.&nbsp; it
is not unnecessarily recursing), you must increase the stack size.&nbsp; This is done by linking your application again and
specifying the &quot;STACK&quot; option to the Open Watcom Linker with a larger stack size.
<BR><BR>It is also possible to specify more than one option in a pragma as illustrated by the following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma on (check_stack unreferenced);</TT>
<DT>reuse_duplicate_strings (C only)
<DD>(C Only) The &quot;reuse_duplicate_strings&quot; option controls the way Open Watcom C handles identical strings in an expression.
&nbsp;For example,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma on (reuse_duplicate_strings);</TT>
<BR><BR>will cause Open Watcom C to reuse identical strings in an expression.&nbsp; This is the default.&nbsp; Specifying
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma off (reuse_duplicate_strings);</TT>
<BR><BR>will cause Open Watcom C to generate additional copies of the identical string.&nbsp; The following example shows
where this may be of importance to the way the application behaves.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma off (reuse_duplicate_strings)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void poke( char *, char * );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; poke( &quot;Hello world\n&quot;, &quot;Hello world\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void poke( char *x, char *y )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x[3] = 'X';</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( x );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y[4] = 'Y';</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( y );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /*</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Default output:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; HelXo world</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; HelXY world</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
</DL>
<H2 ID="16Mbit__Using_Pragmas_to_Specify_Default_Libraries"> 16-bit:&nbsp; Using Pragmas to Specify Default Libraries </H2>
<BR>Default libraries are specified in special object module records.&nbsp; Library names are extracted from these special
records by the Open Watcom Linker.&nbsp; When unresolved references remain after processing all object modules specified in
linker &quot;FILE&quot; directives, these default libraries are searched after all libraries specified in linker &quot;LIBRARY&quot;
directives have been searched.
<BR><BR>By default, that is if no library pragma is specified, the Open Watcom C/C++ compiler generates, in the object file
defining the main program, default libraries corresponding to the memory model and floating-point model used to compile the
file.&nbsp; For example, if you have compiled the source file containing the main program for the medium memory model and
the floating-point calls floating-point model, the libraries &quot;clibm&quot; and &quot;mathm&quot; will be placed in the
object file.
<BR><BR>If you wish to add your own default libraries to this list, you can do so with a library pragma.&nbsp; Consider the
following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma library (mylib);</TT>
<BR><BR>The name &quot;mylib&quot; will be added to the list of default libraries specified in the object file.
<BR><BR>If the library specification contains characters such as '\', ':' or ',' (i.e., any character not allowed in a C identifier),
you must enclose it in double quotes as in the following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma library (&quot;\watcom\lib286\dos\graph.lib&quot;);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma library (&quot;\watcom\lib386\dos\graph.lib&quot;);</TT>
<BR><BR>If you wish to specify more than one library in a library pragma you must separate them with spaces as in the following
example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma library (mylib &quot;\watcom\lib286\dos\graph.lib&quot;);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma library (mylib &quot;\watcom\lib386\dos\graph.lib&quot;);</TT>
<H2 ID="16Mbit__The_ALIAS_Pragma_LC_OnlyR"> 16-bit:&nbsp; The ALIAS Pragma (C Only) </H2>
<BR>The &quot;alias&quot; pragma can be used to emit alias records in the object file, causing the linker to substitute references
to a specified symbol with references to another symbol.&nbsp; Either identifiers or names (strings) may be used.&nbsp; Strings
are used verbatim, while names corresponding to identifiers are derived as appropriate for the kind and calling convention
of the symbol.&nbsp; The following describes the form of the &quot;alias&quot; pragma.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma alias ( </TT><B>alias</B><TT>, </TT><B>subst</B><TT> ) </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>alias
<DD>is either a name or an identifier of the symbol to be aliased.
<DT>subst
<DD>is either a name or an identifier of the symbol that references to<TT> alias</TT> will be replaced with.
</DL>
<BR>Consider the following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int var;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void fn( void )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var = 3;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma alias ( var, &quot;other_var&quot; );</TT>
<BR><BR>Instead of<TT> var</TT> the linker will reference symbol named &quot;other_var&quot;.&nbsp; Symbol<TT> var</TT> need
not be defined, although &quot;other_var&quot; has to be.
<H2 ID="16Mbit__The_ALLOC_TEXT_Pragma_LC_OnlyR"> 16-bit:&nbsp; The ALLOC_TEXT Pragma (C Only) </H2>
<BR>The &quot;alloc_text&quot; pragma can be used to specify the name of the text segment into which the generated code for
a function, or a list of functions, is to be placed.&nbsp; The following describes the form of the &quot;alloc_text&quot;
pragma.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma alloc_text ( </TT><B>seg_name</B><TT>, </TT><B>fn</B><TT> </TT><B>{</B><TT>, </TT><B>fn}</B><TT>
) </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>seg_name
<DD>is the name of the text segment.
<DT>fn
<DD>is the name of a function.
</DL>
<BR>Consider the following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int fn1(int);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int fn2(void);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma alloc_text ( my_text, fn1, fn2 );</TT>
<BR><BR>The code for the functions<TT> fn1</TT> and<TT> fn2</TT> will be placed in the segment<TT> my_text.</TT>&nbsp; Note:
&nbsp;function prototypes for the named functions must exist prior to the &quot;alloc_text&quot; pragma.
<H2 ID="16Mbit__The_CODE_SEG_Pragma"> 16-bit:&nbsp; The CODE_SEG Pragma </H2>
<BR>The &quot;code_seg&quot; pragma can be used to specify the name of the text segment into which the generated code for
functions is to be placed.&nbsp; The following describes the form of the &quot;code_seg&quot; pragma.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma code_seg ( </TT><B>seg_name</B><TT> </TT><B>[</B><TT>, </TT><B>class_name]</B><TT>
) </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>seg_name
<DD>is the name of the text segment optionally enclosed in quotes.&nbsp; Also,<TT> seg_name</TT> may be a macro as in:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define seg_name &quot;MY_CODE_SEG&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma code_seg ( seg_name );</TT>
<DT>class_name
<DD>is the optional class name of the text segment and may be enclosed in quotes.&nbsp; Please note that in order to be recognized
by the linker as code, a class name has to end in &quot;CODE&quot;.&nbsp; Also,<TT> class_name</TT> may be a macro as in:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define class_name &quot;MY_CODE&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma code_seg ( &quot;MY_CODE_SEG&quot;, class_name );</TT>
</DL>
<BR>Consider the following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma code_seg ( my_text );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int incr( int i )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( i + 1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int decr( int i )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( i - 1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The code for the functions<TT> incr</TT> and<TT> decr</TT> will be placed in the segment<TT> my_text.</TT>
<BR><BR>To return to the default segment, do not specify any string between the opening and closing parenthesis.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma code_seg ();</TT>
<H2 ID="16Mbit__The_COMMENT_Pragma"> 16-bit:&nbsp; The COMMENT Pragma </H2>
<BR>The &quot;comment&quot; pragma can be used to place a comment record in an object file or executable file.&nbsp; The following
describes the form of the &quot;comment&quot; pragma.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma comment ( </TT><B>comment_type</B><TT> </TT><B>[</B><TT>, </TT><B>&quot;comment_string&quot;]</B><TT>
) </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>comment_type
<DD>specifies the type of comment record.&nbsp; The allowable comment types are:
<DL>
<DT>lib
<DD>Default libraries are specified in special object module records.&nbsp; Library names are extracted from these special records
by the Open Watcom Linker.&nbsp; When unresolved references remain after processing all object modules specified in linker
&quot;FILE&quot; directives, these default libraries are searched after all libraries specified in linker &quot;LIBRARY&quot;
directives have been searched.
<BR><BR>The &quot;lib&quot; form of this pragma offers the same features as the &quot;library&quot; pragma.&nbsp; See the
section entitled <A HREF="#16Mbit__Using_Pragmas_to_Specify_Default_Libraries">16-bit:&nbsp; Using Pragmas to Specify Default Libraries</A>
for more information.
</DL>
<DT>&quot;comment_string&quot;
<DD>is an optional string literal that provides additional information for some comment types.
</DL>
<BR>Consider the following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma comment ( lib, &quot;mylib&quot; );</TT>
<H2 ID="16Mbit__The_DATA_SEG_Pragma"> 16-bit:&nbsp; The DATA_SEG Pragma </H2>
<BR>The &quot;data_seg&quot; pragma can be used to specify the name of the segment into which data is to be placed.&nbsp;
The following describes the form of the &quot;data_seg&quot; pragma.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma data_seg ( </TT><B>seg_name</B><TT> </TT><B>[</B><TT>, </TT><B>class_name]</B><TT>
) </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>seg_name
<DD>is the name of the data segment and may be enclosed in quotes.&nbsp; Also,<TT> seg_name</TT> may be a macro as in:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define seg_name &quot;MY_DATA_SEG&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma data_seg ( seg_name );</TT>
<DT>class_name
<DD>is the optional class name of the data segment and may be enclosed in quotes.&nbsp; Also,<TT> class_name</TT> may be a macro
as in:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define class_name &quot;MY_CLASS&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma data_seg ( &quot;MY_DATA_SEG&quot;, class_name );</TT>
</DL>
<BR>Consider the following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma data_seg ( my_data );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static int i;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static int j;</TT>
<BR><BR>The data for<TT> i</TT> and<TT> j</TT> will be placed in the segment<TT> my_data.</TT>
<BR><BR>To return to the default segment, do not specify any string between the opening and closing parenthesis.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma data_seg ();</TT>
<H2 ID="16Mbit__The_DISABLE_MESSAGE_Pragma"> 16-bit:&nbsp; The DISABLE_MESSAGE Pragma </H2>
<BR>The &quot;disable_message&quot; pragma disables the issuance of specified diagnostic messages.&nbsp; The form of the &quot;disable_message&quot;
pragma is as follows.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma disable_message ( </TT><B>msg_num</B><TT> </TT><B>{</B><TT>, </TT><B>msg_num}</B><TT>
) </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>msg_num
<DD>is the number of the diagnostic message.&nbsp; This number corresponds to the number issued by the compiler.&nbsp; Make sure
to strip all leading zeroes from the message number (to avoid interpretation as an octal constant).
</DL>
<BR>See also the description of <A HREF="#16Mbit__The_ENABLE_MESSAGE_Pragma">16-bit:&nbsp; The ENABLE_MESSAGE Pragma</A>.
<H2 ID="16Mbit__The_DUMP_OBJECT_MODEL_Pragma_LCPP_OnlyR"> 16-bit:&nbsp; The DUMP_OBJECT_MODEL Pragma (C++ Only) </H2>
<BR>The &quot;dump_object_model&quot; pragma causes the C++ compiler to print information about the object model for an indicated
class or an enumeration name to the diagnostics file.&nbsp; For class names, this information includes the offsets and sizes
of fields within the class and within base classes.&nbsp; For enumeration names, this information consists of a list of all
the enumeration constants with their values.
<BR><BR>The general form of the &quot;dump_object_model&quot; pragma is as follows.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma dump_object_model </TT><B>class</B><TT> </TT><B>[</B><TT>;</TT><B>]</B>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma dump_object_model </TT><B>enumeration</B><TT> </TT><B>[</B><TT>;</TT><B>]</B>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp; class ::= a defined C++ class free of errors</B>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp; enumeration ::= a defined C++ enumeration name</B>
<HR>
<BR>This pragma is designed to be used for information purposes only.
<H2 ID="16Mbit__The_ENABLE_MESSAGE_Pragma"> 16-bit:&nbsp; The ENABLE_MESSAGE Pragma </H2>
<BR>The &quot;enable_message&quot; pragma re-enables the issuance of specified diagnostic messages that have been previously
disabled.&nbsp; The form of the &quot;enable_message&quot; pragma is as follows.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma enable_message ( </TT><B>msg_num</B><TT> </TT><B>{</B><TT>, </TT><B>msg_num}</B><TT>
) </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>msg_num
<DD>is the number of the diagnostic message.&nbsp; This number corresponds to the number issued by the compiler.&nbsp; Make sure
to strip all leading zeroes from the message number (to avoid interpretation as an octal constant).
</DL>
<BR>See also the description of <A HREF="#16Mbit__The_DISABLE_MESSAGE_Pragma">16-bit:&nbsp; The DISABLE_MESSAGE Pragma</A>.
<H2 ID="16Mbit__The_ENUM_Pragma"> 16-bit:&nbsp; The ENUM Pragma </H2>
<BR>The &quot;enum&quot; pragma affects the underlying storage-definition for subsequent<B> enum</B> declarations.&nbsp; The
forms of the &quot;enum&quot; pragma are as follows.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma enum int </TT><B>[</B><TT>;</TT><B>]</B>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma enum minimum </TT><B>[</B><TT>;</TT><B>]</B>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma enum original </TT><B>[</B><TT>;</TT><B>]</B>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma enum pop </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>int
<DD>Make<B> int</B> the underlying storage definition (same as the &quot;ei&quot; compiler option).
<DT>minimum
<DD>Minimize the underlying storage definition (same as not specifying the &quot;ei&quot; compiler option).
<DT>original
<DD>Reset back to the original compiler option setting (i.e., what was or was not specified on the command line).
<DT>pop
<DD>Restore the previous setting.
</DL>
<BR>The first three forms all push the previous setting before establishing the new setting.
<H2 ID="16Mbit__The_ERROR_Pragma"> 16-bit:&nbsp; The ERROR Pragma </H2>
<BR>The &quot;error&quot; pragma can be used to issue an error message with the specified text.&nbsp; The following describes
the form of the &quot;error&quot; pragma.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma error </TT><B>&quot;error text&quot;</B><TT> </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>&quot;error text&quot;
<DD>is the text of the message that you wish to display.
</DL>
<BR>You should use the ISO<B><I> #error</I></B> directive rather than this pragma.&nbsp; This pragma is provided for compatibility
with legacy code.&nbsp; The following is an example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #if defined(__386__)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #elseif defined(__86__)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma error ( &quot;neither __386__ or __86__ defined&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #endif</TT>
<H2 ID="16Mbit__The_EXTREF_Pragma"> 16-bit:&nbsp; The EXTREF Pragma </H2>
<BR>The &quot;extref&quot; pragma is used to generate a reference to an external function or data item.&nbsp; The form of
the &quot;extref&quot; pragma is as follows.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma extref </TT><B>name</B><TT> </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>name
<DD>is the name of an external function or data item.&nbsp; It must be declared to be an external function or data item before
the pragma is encountered.&nbsp; In C++, when<B> name</B> is a function, it must not be overloaded.
</DL>
<BR>This pragma causes an external reference for the function or data item to be emitted into the object file even if that
function or data item is not referenced in the module.&nbsp; The external reference will cause the linker to include the module
containing that name in the linked program or DLL.
<BR><BR>This is useful for debugging since you can cause debugging routines (callable from within debugger) to be included
into a program or DLL to be debugged.
<BR><BR>In C++, you can also force constructors and/or destructors to be called for a data item without necessarily referencing
the data item anywhere in your code.
<H2 ID="16Mbit__The_FUNCTION_Pragma"> 16-bit:&nbsp; The FUNCTION Pragma </H2>
<BR>Certain functions, such as those listed in the description of the &quot;oi&quot; and &quot;om&quot; options, have intrinsic
forms.&nbsp; These functions are special functions that are recognized by the compiler and processed in a special way.&nbsp;
For example, the compiler may choose to generate in-line code for the function.&nbsp; The intrinsic attribute for these special
functions is set by specifying the &quot;oi&quot; or &quot;om&quot; option or using an &quot;intrinsic&quot; pragma.&nbsp;
The &quot;function&quot; pragma can be used to remove the intrinsic attribute for a specified list of functions.
<BR><BR>The following describes the form of the &quot;function&quot; pragma.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma function ( </TT><B>fn</B><TT> </TT><B>{</B><TT>, </TT><B>fn}</B><TT> ) </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>fn
<DD>is the name of a function.
</DL>
<BR>Suppose the following source code was compiled using the &quot;om&quot; option so that when one of the special math functions
is referenced, the intrinsic form will be used.&nbsp; In our example, we have referenced the function<TT> sin</TT> which does
have an intrinsic form.&nbsp; By specifying<TT> sin</TT> in a &quot;function&quot; pragma, the intrinsic attribute will be
removed, causing the function<TT> sin</TT> to be treated as a regular user-defined function.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;math.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma function( sin );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; double test( double x )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( sin( x ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="16Mbit__The_INCLUDE_ALIAS_Pragma"> 16-bit:&nbsp; The INCLUDE_ALIAS Pragma </H2>
<BR>In certain situations, it can be advantageous to remap the names of include files.&nbsp; Most commonly this occurs on
systems that do not support long file names when building source code that references header files with long names.
<BR><BR>The form of the &quot;include_alias&quot; pragma follows.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma include_alias ( &quot;</TT><B>alias_name</B><TT>&quot;, &quot;</TT><B>real_name</B><TT>&quot;
) </TT><B>[</B><TT>;</TT><B>]</B>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma include_alias ( &lt;</TT><B>alias_name</B><TT>&gt;, &lt;</TT><B>real_name</B><TT>&gt;
) </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>alias_name
<DD>is the name referenced in include directives in source code.
<DT>real_name
<DD>is the translated name that the compiler will reference instead.
</DL>
<BR>The following is an example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma include_alias( &quot;LongFileName.h&quot;, &quot;lfn.h&quot; )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &quot;LongFileName.h&quot;</TT>
<BR><BR>In the example, the compiler will attempt to read lfn.h when LongFileName.h was included.
<BR><BR>Note that only simple textual substitution is performed.&nbsp; The aliased name must match exactly, including double
quotes or angle brackets, as well as any directory separators.&nbsp; Also, double quotes and angle brackets may not be mixed
a single pragma.
<BR><BR>The value of the predefined<TT> __FILE__</TT> symbol, as well as the filename reported in error messages, will be
the true filename after substitution was performed.
<H2 ID="16Mbit__Setting_Priority_of_Static_Data_Initialization_LCPP_OnlyR"> 16-bit:&nbsp; Setting Priority of Static Data Initialization (C++ Only) </H2>
<BR>The &quot;initialize&quot; pragma sets the priority for initialization of static data in the file.&nbsp; This priority
only applies to initialization of static data that requires the execution of code.&nbsp; For example, the initialization of
a class that contains a constructor requires the execution of the constructor.&nbsp; Note that if the sequence in which initialization
of static data in your program takes place has no dependencies, the &quot;initialize&quot; pragma need not be used.
<BR><BR>The general form of the &quot;initialize&quot; pragma is as follows.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma initialize </TT><B>[</B><TT>before </TT><B>|</B><TT> after</TT><B>]</B><TT> </TT><B>priority</B><TT>
</TT><B>[</B><TT>;</TT><B>]</B>
<BR><BR><B>&nbsp;&nbsp;&nbsp;&nbsp; priority ::=</B><TT> </TT><B>n</B><TT> </TT><B>|</B><TT> library </TT><B>|</B><TT> program</TT>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>n
<DD>is a number representing the priority and must be in the range 0-255.&nbsp; The larger the priority, the later the point at
which initialization will occur.
</DL>
<BR>Priorities in the range 0-20 are reserved for the C++ compiler.&nbsp; This is to ensure that proper initialization of
the C++ run-time system takes place before the execution of your program.&nbsp; The &quot;library&quot; keyword represents
a priority of 32 and can be used for class libraries that require initialization before the program is initialized.&nbsp;
The &quot;program&quot; keyword represents a priority of 64 and is the default priority for any compiled code.&nbsp; Specifying
&quot;before&quot; adjusts the priority by subtracting one.&nbsp; Specifying &quot;after&quot; adjusts the priority by adding
one.
<BR><BR>A source file containing the following &quot;initialize&quot; pragma specifies that the initialization of static data
in the file will take place before initialization of all other static data in the program since a priority of 63 will be assigned.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma initialize before program</TT>
<BR><BR>If we specify &quot;after&quot; instead of &quot;before&quot;, the initialization of the static data in the file will
occur after initialization of all other static data in the program since a priority of 65 will be assigned.
<BR><BR>Note that the following is equivalent to the &quot;before&quot; example
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma initialize 63</TT>
<BR><BR>and the following is equivalent to the &quot;after&quot; example.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma initialize 65</TT>
<BR><BR>The use of the &quot;before&quot;, &quot;after&quot;, and &quot;program&quot; keywords are more descriptive in the
intent of the pragmas.
<BR><BR>It is recommended that a priority of 32 (the priority used when the &quot;library&quot; keyword is specified) be used
when developing class libraries.&nbsp; This will ensure that initialization of static data defined by the class library will
take place before initialization of static data defined by the program.&nbsp; The following &quot;initialize&quot; pragma
can be used to achieve this.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma initialize library</TT>
<H2 ID="16Mbit__The_INLINE_DEPTH_Pragma_LCPP_OnlyR"> 16-bit:&nbsp; The INLINE_DEPTH Pragma (C++ Only) </H2>
<BR>When an in-line function is called, the function call may be replaced by the in-line expansion for that function.&nbsp;
This in-line expansion may include calls to other in-line functions which can also be expanded.&nbsp; The &quot;inline_depth&quot;
pragma can be used to set the number of times this expansion of in-line functions will occur for a call.
<BR><BR>The form of the &quot;inline_depth&quot; pragma is as follows.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma inline_depth </TT><B>[</B><TT>(</TT><B>]</B><TT> </TT><B>n</B><TT> </TT><B>[</B><TT>)</TT><B>]</B><TT>
</TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>n
<DD>is the depth of expansion.&nbsp; If<TT> n</TT> is 0, no expansion will occur.&nbsp; If<TT> n</TT> is 1, only the original
call is expanded.&nbsp; If<TT> n</TT> is 2, the original call and the in-line functions invoked by the original function will
be expanded.&nbsp; The default value for<TT> n</TT> is 3.&nbsp; The maximum value for<TT> n</TT> is 255.&nbsp; Note that no
expansion of recursive in-line functions occur unless enabled using the &quot;inline_recursion&quot; pragma.
</DL>
<H2 ID="16Mbit__The_INLINE_RECURSION_Pragma_LCPP_OnlyR"> 16-bit:&nbsp; The INLINE_RECURSION Pragma (C++ Only) </H2>
<BR>The &quot;inline_recursion&quot; pragma controls the recursive expansion of inline functions.&nbsp; The form of the &quot;inline_recursion&quot;
pragma is as follows.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma inline_recursion </TT><B>[</B><TT>(</TT><B>]</B><TT> on </TT><B>|</B><TT> off </TT><B>[</B><TT>)</TT><B>]</B><TT>
</TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<BR>Specifying &quot;on&quot; will enable expansion of recursive inline functions.&nbsp; The depth of expansion is specified
by the &quot;inline_depth&quot; pragma.&nbsp; The default depth is 3.&nbsp; Specifying &quot;off&quot; suppresses expansion
of recursive inline functions.&nbsp; This is the default.
<H2 ID="16Mbit__The_INTRINSIC_Pragma"> 16-bit:&nbsp; The INTRINSIC Pragma </H2>
<BR>Certain functions, those listed in the description of the &quot;oi&quot; option, have intrinsic forms.&nbsp; These functions
are special functions that are recognized by the compiler and processed in a special way.&nbsp; For example, the compiler
may choose to generate in-line code for the function.&nbsp; The intrinsic attribute for these special functions is set by
specifying the &quot;oi&quot; option or using an &quot;intrinsic&quot; pragma.
<BR><BR>The following describes the form of the &quot;intrinsic&quot; pragma.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma intrinsic ( </TT><B>fn</B><TT> </TT><B>{</B><TT>, </TT><B>fn}</B><TT> ) </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>fn
<DD>is the name of a function.
</DL>
<BR>Suppose the following source code was compiled without using the &quot;oi&quot; option so that no function had the intrinsic
attribute.&nbsp; If we wanted the intrinsic form of the<TT> sin</TT> function to be used, we could specify the function in
an &quot;intrinsic&quot; pragma.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;math.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma intrinsic( sin );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; double test( double x )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( sin( x ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="16Mbit__The_MESSAGE_Pragma"> 16-bit:&nbsp; The MESSAGE Pragma </H2>
<BR>The &quot;message&quot; pragma can be used to issue a message with the specified text to the standard output without terminating
compilation.&nbsp; The following describes the form of the &quot;message&quot; pragma.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma message ( </TT><B>&quot;message text&quot;</B><TT> ) </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>&quot;message text&quot;
<DD>is the text of the message that you wish to display.
</DL>
<BR>The following is an example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #if defined(__386__)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma message ( &quot;assuming 16-bit compile&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #endif</TT>
<H2 ID="16Mbit__The_ONCE_Pragma"> 16-bit:&nbsp; The ONCE Pragma </H2>
<BR>The &quot;once&quot; pragma can be used to indicate that the file which contains this pragma should only be opened and
processed &quot;once&quot;.&nbsp; The following describes the form of the &quot;once&quot; pragma.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma once </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<BR>Assume that the file &quot;foo.h&quot; contains the following text.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #ifndef _FOO_H_INCLUDED</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define _FOO_H_INCLUDED</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma once</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #endif</TT>
<BR><BR>The first time that the compiler processes &quot;foo.h&quot; and encounters the &quot;once&quot; pragma, it records
the file's name.&nbsp; Subsequently, whenever the compiler encounters a<TT> #include</TT> statement that refers to &quot;foo.h&quot;,
it will not open the include file again.&nbsp; This can help speed up processing of<TT> #include</TT> files and reduce the
time required to compile an application.
<H2 ID="16Mbit__The_PACK_Pragma"> 16-bit:&nbsp; The PACK Pragma </H2>
<BR>The &quot;pack&quot; pragma can be used to control the way in which structures are stored in memory.&nbsp; There are 4
forms of the &quot;pack&quot; pragma.
<BR><BR>The following form of the &quot;pack&quot; pragma can be used to change the alignment of structures and their fields
in memory.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma pack ( </TT><B>n</B><TT> ) </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>n
<DD>is 1, 2, 4, 8 or 16 and specifies the method of alignment.
</DL>
<BR>The alignment of structure members is described in the following table.&nbsp; If the size of the member is 1, 2, 4, 8
or 16, the alignment is given for each of the &quot;zp&quot; options.&nbsp; If the member of the structure is an array or
structure, the alignment is described by the row &quot;x&quot;.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; zp1&nbsp;&nbsp;&nbsp;&nbsp; zp2&nbsp;&nbsp;&nbsp;&nbsp; zp4&nbsp;&nbsp;&nbsp;&nbsp; zp8&nbsp;&nbsp;
&nbsp; zp16</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; sizeof(member)&nbsp; \---------------------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;
&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;
&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;
&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;
&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;
&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;
&nbsp;aligned to largest member</TT>
<BR><BR>An alignment of 0 means no alignment, 2 means word boundary, 4 means doubleword boundary, etc.&nbsp; If the largest
member of structure &quot;x&quot; is 1 byte then &quot;x&quot; is not aligned.&nbsp; If the largest member of structure &quot;x&quot;
is 2 bytes then &quot;x&quot; is aligned according to row 2.&nbsp; If the largest member of structure &quot;x&quot; is 4 bytes
then &quot;x&quot; is aligned according to row 4.&nbsp; If the largest member of structure &quot;x&quot; is 8 bytes then &quot;x&quot;
is aligned according to row 8.&nbsp; If the largest member of structure &quot;x&quot; is 16 bytes then &quot;x&quot; is aligned
according to row 16.
<BR><BR>If no value is specified in the &quot;pack&quot; pragma, a default value of 2 is used.&nbsp; Note that the default
value can be changed with the &quot;zp&quot; Open Watcom C/C++ compiler command line option.
<BR><BR>The following form of the &quot;pack&quot; pragma can be used to save the current alignment amount on an internal
stack.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma pack ( push ) </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<BR>The following form of the &quot;pack&quot; pragma can be used to save the current alignment amount on an internal stack
and set the current alignment.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma pack ( push, </TT><B>number</B><TT> ) </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<BR>The following form of the &quot;pack&quot; pragma can be used to restore the previous alignment amount from an internal
stack.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma pack ( pop ) </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<H2 ID="16Mbit__The_READ_ONLY_FILE_Pragma"> 16-bit:&nbsp; The READ_ONLY_FILE Pragma </H2>
<BR>Explicit listing of dependencies in a makefile can often be tedious in the development and maintenance phases of a project.
&nbsp;The Open Watcom C/C++ compiler will insert dependency information into the object file as it processes source files
so that a complete snapshot of the files necessary to build the object file are recorded.&nbsp; The &quot;read_only_file&quot;
pragma can be used to prevent the name of the source file that includes it from being included in the dependency information
that is written to the object file.
<BR><BR>This pragma is commonly used in system header files since they change infrequently (and, when they do, there should
be no impact on source files that have included them).
<BR><BR>The form of the &quot;read_only_file&quot; pragma follows.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma read_only_file </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<BR>For more information on make dependencies, see the section entitled &quot;Automatic Dependency Detection (.AUTODEPEND)&quot;
in the<B><I> Open Watcom C/C++ Tools User's Guide.</I></B>
<H2 ID="16Mbit__The_TEMPLATE_DEPTH_Pragma_LCPP_OnlyR"> 16-bit:&nbsp; The TEMPLATE_DEPTH Pragma (C++ Only) </H2>
<BR>The &quot;template_depth&quot; pragma provides a hard limit for the amount of nested template expansions allowed so that
infinite expansion can be detected.
<BR><BR>The form of the &quot;template_depth&quot; pragma is as follows.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma template_depth </TT><B>[</B><TT>(</TT><B>]</B><TT> </TT><B>n</B><TT> </TT><B>[</B><TT>)</TT><B>]</B><TT>
</TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>n
<DD>is the depth of expansion.&nbsp; If the value of<TT> n</TT> is less than 2, if will default to 2.&nbsp; If<TT> n</TT> is not
specified, a warning message will be issued and the default value for<TT> n</TT> will be 100.
</DL>
<BR>The following example of recursive template expansion illustrates why this pragma can be useful.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma template_depth(10);</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; template &lt;class T&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S&lt;T*&gt; x;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; S&lt;char&gt; v;</TT>
<H2 ID="16Mbit__The_WARNING_Pragma_LCPP_OnlyR"> 16-bit:&nbsp; The WARNING Pragma (C++ Only) </H2>
<BR>The &quot;warning&quot; pragma sets the level of warning messages.&nbsp; The form of the &quot;warning&quot; pragma is
as follows.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma warning </TT><B>msg_num</B><TT> </TT><B>level</B><TT> </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>msg_num
<DD>is the number of the warning message.&nbsp; This number corresponds to the number issued by the compiler.&nbsp; If<TT> msg_num</TT>
is &quot;*&quot;, the level of all warning messages is changed to the specified level.&nbsp; Make sure to strip all leading
zeroes from the message number (to avoid interpretation as an octal constant).
<DT>level
<DD>is a number from 0 to 9 and represents the level of the warning message.&nbsp; When a value of zero is specified, the warning
becomes an error.
</DL>
<H2 ID="16Mbit__Auxiliary_Pragmas"> 16-bit:&nbsp; Auxiliary Pragmas </H2>
<BR>The following sections describe the capabilities provided by auxiliary pragmas.
<H3 ID="16Mbit__Specifying_Symbol_Attributes"> 16-bit:&nbsp; Specifying Symbol Attributes </H3>
<BR>Auxiliary pragmas are used to describe attributes that affect code generation.&nbsp; Initially, the compiler defines a
default set of attributes.&nbsp; Each auxiliary pragma refers to one of the following.
<OL>
<LI>a symbol (such as a variable or function)
<LI>a type definition that resolves to a function type
<LI>the default set of attributes defined by the compiler
</OL>
<BR>When an auxiliary pragma refers to a particular symbol, a copy of the current set of default attributes is made and merged
with the attributes specified in the auxiliary pragma.&nbsp; The resulting attributes are assigned to the specified symbol
and can only be changed by another auxiliary pragma that refers to the same symbol.
<BR><BR>An example of a type definition that resolves to a function type is the following.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef void (*func_type)();</TT>
<BR><BR>When an auxiliary pragma refers to a such a type definition, a copy of the current set of default attributes is made
and merged with the attributes specified in the auxiliary pragma.&nbsp; The resulting attributes are assigned to each function
whose type matches the specified type definition.
<BR><BR>When &quot;default&quot; is specified instead of a symbol name, the attributes specified by the auxiliary pragma change
the default set of attributes.&nbsp; The resulting attributes are used by all symbols that have not been specifically referenced
by a previous auxiliary pragma.
<BR><BR>Note that all auxiliary pragmas are processed before code generation begins.&nbsp; Consider the following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; code in which symbol x is referenced</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux y &lt;attrs_1&gt;;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; code in which symbol y is referenced</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; code in which symbol z is referenced</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux default &lt;attrs_2&gt;;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux x &lt;attrs_3&gt;;</TT>
<BR><BR>Auxiliary attributes are assigned to<TT> x, y</TT> and<TT> z</TT> in the following way.
<OL>
<LI>Symbol<TT> x</TT> is assigned the initial default attributes merged with the attributes specified by<TT> &lt;attrs_2&gt;</TT>
and<TT> &lt;attrs_3&gt;.</TT>
<LI>Symbol<TT> y</TT> is assigned the initial default attributes merged with the attributes specified by<TT> &lt;attrs_1&gt;.</TT>
<LI>Symbol<TT> z</TT> is assigned the initial default attributes merged with the attributes specified by<TT> &lt;attrs_2&gt;.</TT>
</OL>
<H3 ID="16Mbit__Alias_Names"> 16-bit:&nbsp; Alias Names </H3>
<BR>When a symbol referred to by an auxiliary pragma includes an alias name, the attributes of the alias name are also assumed
by the specified symbol.
<BR><BR>There are two methods of specifying alias information.&nbsp; In the first method, the symbol assumes only the attributes
of the alias name; no additional attributes can be specified.&nbsp; The second method is more general since it is possible
to specify an alias name as well as additional auxiliary information.&nbsp; In this case, the symbol assumes the attributes
of the alias name as well as the attributes specified by the additional auxiliary information.
<BR><BR>The simple form of the auxiliary pragma used to specify an alias is as follows.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux ( </TT><B>sym</B><TT>, </TT><B>alias</B><TT> ) </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is any valid C/C++ identifier.
<DT>alias
<DD>is the alias name and is any valid C/C++ identifier.
</DL>
<BR>Consider the following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux push_args parm [] ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux ( rtn, push_args ) ;</TT>
<BR><BR>The routine<TT> rtn</TT> assumes the attributes of the alias name<TT> push_args</TT> which specifies that the arguments
to<TT> rtn</TT> are passed on the stack.
<BR><BR>Let us look at an example in which the symbol is a type definition.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef void (func_type)(int);</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux push_args parm [];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux ( func_type, push_args );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern func_type rtn1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern func_type rtn2;</TT>
<BR><BR>The first auxiliary pragma defines an alias name called<TT> push_args</TT> that specifies the mechanism to be used
to pass arguments.&nbsp; The mechanism is to pass all arguments on the stack.&nbsp; The second auxiliary pragma associates
the attributes specified in the first pragma with the type definition<TT> func_type.</TT>&nbsp; Since<TT> rtn1</TT> and<TT>
rtn2</TT> are of type<TT> func_type,</TT> arguments to either of those functions will be passed on the stack.
<BR><BR>The general form of an auxiliary pragma that can be used to specify an alias is as follows.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux ( </TT><B>alias</B><TT> ) </TT><B>sym</B><TT> </TT><B>aux_attrs</B><TT> </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>alias
<DD>is the alias name and is any valid C/C++ identifier.
<DT>sym
<DD>is any valid C/C++ identifier.
<DT>aux_attrs
<DD>are attributes that can be specified with the auxiliary pragma.
</DL>
<BR>Consider the following example.&nbsp; 
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux MS_C &quot;_*&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;\</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; parm caller []&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; value struct float struct routine [ax]\</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; modify [ax bx cx dx es];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux (MS_C) rtn1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux (MS_C) rtn2;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux (MS_C) rtn3;</TT>
<BR><BR>The routines<TT> rtn1, rtn2</TT> and<TT> rtn3</TT> assume the same attributes as the alias name<TT> MS_C</TT> which
defines the calling convention used by the Microsoft C compiler.&nbsp; Whenever calls are made to<TT> rtn1, rtn2</TT> and<TT>
rtn3,</TT> the Microsoft C calling convention will be used.
<BR><BR>Note that if the attributes of<TT> MS_C</TT> change, only one pragma needs to be changed.&nbsp; If we had not used
an alias name and specified the attributes in each of the three pragmas for<TT> rtn1, rtn2</TT> and<TT> rtn3,</TT> we would
have to change all three pragmas.&nbsp; This approach also reduces the amount of memory required by the compiler to process
the source file.
<HR>
<BR><B><I>&nbsp; WARNING!</I></B>&nbsp; The alias name<TT> MS_C</TT> is just another symbol.&nbsp; If<TT> MS_C</TT> appeared
in your source code, it would assume the attributes specified in the pragma for<TT> MS_C.</TT>
<HR>
<H3 ID="16Mbit__Predefined_Aliases"> 16-bit:&nbsp; Predefined Aliases </H3>
<BR>A number of symbols are predefined by the compiler with a set of attributes that describe a particular calling convention.
&nbsp;These symbols can be used as aliases.&nbsp; The following is a list of these symbols.
<DL>
<DT>__cdecl
<DD><TT> __cdecl</TT> or <TT> cdecl</TT> defines the calling convention used by Microsoft compilers.
<DT>__fastcall
<DD><TT> __fastcall</TT> or <TT> fastcall</TT> defines the calling convention used by Microsoft compilers.
<DT>__fortran
<DD><TT> __fortran</TT> or <TT> fortran</TT> defines the calling convention used by Open Watcom FORTRAN compilers.
<DT>__pascal
<DD><TT> __pascal</TT> or <TT> pascal</TT> defines the calling convention used by OS/2 1.x and Windows 3.x API functions.
<DT>__stdcall
<DD><TT> __stdcall</TT> or <TT> stdcall</TT> defines the calling convention used by Microsoft compilers.
<DT>__watcall
<DD><TT> __watcall</TT> or <TT> watcall</TT> defines the calling convention used by Open Watcom compilers.
</DL>
<BR>The following describes the attributes of the above alias names.
<H4 ID="16Mbit__Predefined____cdecl__Alias"> 16-bit:&nbsp; Predefined &quot;__cdecl&quot; Alias </H4>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux __cdecl &quot;_*&quot; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parm caller [] \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value struct float struct
routine [ax] \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; modify [ax bx cx dx es]</TT>
<BR><BR><B>Notes:</B>
<OL>
<LI>All symbols are preceded by an underscore character.
<LI>Arguments are pushed on the stack from right to left.&nbsp; That is, the last argument is pushed first.&nbsp; The calling
routine will remove the arguments from the stack.
<LI>Floating-point values are returned in the same way as structures.&nbsp; When a structure is returned, the called routine
allocates space for the return value and returns a pointer to the return value in register AX.
<LI>Registers AX, BX, CX and DX, and segment register ES are not saved and restored when a call is made.
</OL>
<H4 ID="16Mbit__Predefined____pascal__Alias"> 16-bit:&nbsp; Predefined &quot;__pascal&quot; Alias </H4>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux __pascal &quot;^&quot; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parm reverse routine []
\</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value struct float struct
caller [] \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; modify [ax bx cx dx es]</TT>
<BR><BR><B>Notes:</B>
<OL>
<LI>All symbols are mapped to upper case.
<LI>Arguments are pushed on the stack in reverse order.&nbsp; That is, the first argument is pushed first, the second argument
is pushed next, and so on.&nbsp; The routine being called will remove the arguments from the stack.
<LI>Floating-point values are returned in the same way as structures.&nbsp; When a structure is returned, the caller allocates
space on the stack.&nbsp; The address of the allocated space will be pushed on the stack immediately before the call instruction.
&nbsp;Upon returning from the call, register AX will contain address of the space allocated for the return value.
<LI>Registers AX, BX, CX and DX, and segment register ES are not saved and restored when a call is made.
</OL>
<H4 ID="16Mbit__Predefined____watcall__Alias"> 16-bit:&nbsp; Predefined &quot;__watcall&quot; Alias </H4>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux __watcall &quot;*_&quot; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parm routine [ax bx cx
dx] \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value struct caller</TT>
<BR><BR><B>Notes:</B>
<OL>
<LI>Symbol names are followed by an underscore character.
<LI>Arguments are processed from left to right.&nbsp; The leftmost arguments are passed in registers and the rightmost arguments
are passed on the stack (if the registers used for argument passing have been exhausted).&nbsp; Arguments that are passed
on the stack are pushed from right to left.&nbsp; The calling routine will remove the arguments if any were pushed on the
stack.
<LI>When a structure is returned, the caller allocates space on the stack.&nbsp; The address of the allocated space is put
into SI register.&nbsp; The called routine then places the return value there.&nbsp; Upon returning from the call, register
AX will contain address of the space allocated for the return value.
<LI>Floating-point values are returned using 80x86 registers (&quot;fpc&quot; option) or using 80x87 floating-point registers
(&quot;fpi&quot; or &quot;fpi87&quot; option).
<LI>All registers must be preserved by the called routine.
</OL>
<H3 ID="16Mbit__Alternate_Names_for_Symbols"> 16-bit:&nbsp; Alternate Names for Symbols </H3>
<BR>The following form of the auxiliary pragma can be used to describe the mapping of a symbol from its source form to its
object form.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux </TT><B>sym</B><TT> </TT><B>obj_name</B><TT> </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is any valid C/C++ identifier.
<DT>obj_name
<DD>is any character string enclosed in double quotes.
</DL>
<BR>When specifying<TT> obj_name,</TT> some characters have a special meaning:
<DL>
<DT>where
<DD><B>description</B>
<DT>*
<DD>is unmodified symbol name
<DT>^
<DD>is symbol name converted to uppercase
<DT>!
<DD>is symbol name converted to lowercase
<DT>#
<DD>is a placeholder for &quot;@nnn&quot;, where nnn is size of all function parameters on the stack; it is ignored for functions
with variable argument lists, or for symbols that are not functions
<DT>\
<DD>next character is treated as literal
</DL>
<BR>Several examples of source to object form symbol name translation follow:
<BR><BR>In the following example, the name &quot;MyRtn&quot; will be replaced by &quot;MyRtn_&quot; in the object file.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux MyRtn &quot;*_&quot;;</TT>
<BR><BR>This is the default for all function names.
<BR><BR>In the following example, the name &quot;MyVar&quot; will be replaced by &quot;_MyVar&quot; in the object file.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux MyVar &quot;_*&quot;;</TT>
<BR><BR>This is the default for all variable names.
<BR><BR>In the following example, the lower case version &quot;myrtn&quot; will be placed in the object file.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux MyRtn &quot;!&quot;;</TT>
<BR><BR>In the following example, the upper case version &quot;MYRTN&quot; will be placed in the object file.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux MyRtn &quot;^&quot;;</TT>
<BR><BR>In the following example, the name &quot;MyRtn&quot; will be replaced by &quot;_MyRtn@nnn&quot; in the object file.
&nbsp;&quot;nnn&quot; represents the size of all function parameters.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux MyRtn &quot;_*#&quot;;</TT>
<BR><BR>In the following example, the name &quot;MyRtn&quot; will be replaced by &quot;_MyRtn#&quot; in the object file.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux MyRtn &quot;_*\#&quot;;</TT>
<BR><BR>The default mapping for all symbols can also be changed as illustrated by the following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux default &quot;_*_&quot;;</TT>
<BR><BR>The above auxiliary pragma specifies that all names will be prefixed and suffixed by an underscore character ('_').
<H3 ID="16Mbit__Describing_Calling_Information"> 16-bit:&nbsp; Describing Calling Information </H3>
<BR>The following form of the auxiliary pragma can be used to describe the way a function is to be called.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux </TT><B>sym</B><TT> far </TT><B>[</B><TT>;</TT><B>]</B>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux </TT><B>sym</B><TT> near </TT><B>[</B><TT>;</TT><B>]</B>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux </TT><B>sym</B><TT> = </TT><B>in_line</B><TT> </TT><B>[</B><TT>;</TT><B>]</B>
<BR><BR><B>&nbsp;&nbsp;&nbsp;&nbsp; in_line ::= { const | (</B><TT>seg</TT><B> id) | (</B><TT>offset</TT><B> id) | (</B><TT>reloff</TT><B>
id)</B>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; | (</B><TT>float</TT><B> fpinst) | </B><TT>&quot;</TT><B>asm</B><TT>&quot; </TT><B>}</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a function name.
<DT>const
<DD>is a valid C/C++ integer constant.
<DT>id
<DD>is any valid C/C++ identifier.
<DT>fpinst
<DD>is a sequence of bytes that forms a valid 80x87 instruction.&nbsp; The keyword<B><I> float</I></B> must precede<TT> fpinst</TT>
so that special fixups are applied to the 80x87 instruction.
<DT>seg
<DD>specifies the segment of the symbol<TT> id.</TT>
<DT>offset
<DD>specifies the offset of the symbol<TT> id.</TT>
<DT>reloff
<DD>specifies the relative offset of the symbol<TT> id</TT> for near control transfers.
<DT>asm
<DD>is an assembly language instruction or directive.
</DL>
<BR>In the following example, Open Watcom C/C++ will generate a far call to the function<TT> myrtn.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux myrtn far;</TT>
<BR><BR>Note that this overrides the calling sequence that would normally be generated for a particular memory model.&nbsp;
In other words, a far call will be generated even if you are compiling for a memory model with a small code model.
<BR><BR>In the following example, Open Watcom C/C++ will generate a near call to the function<TT> myrtn.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux myrtn near;</TT>
<BR><BR>Note that this overrides the calling sequence that would normally be generated for a particular memory model.&nbsp;
In other words, a near call will be generated even if you are compiling for a memory model with a big code model.
<BR><BR>In the following DOS example, Open Watcom C/C++ will generate the sequence of bytes following the &quot;=&quot; character
in the auxiliary pragma whenever a call to<TT> mode4</TT> is encountered.<TT>&nbsp; mode4</TT> is called an in-line function.
&nbsp;
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void mode4(void);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux mode4 =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xb4 0x00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* mov AH,0 */ \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xb0 0x04&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* mov AL,4 */ \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xcd 0x10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* int 10H&nbsp; */
\</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; modify [ AH AL ];</TT>
<BR><BR>The sequence in the above DOS example represents the following lines of assembly language instructions.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp; AH,0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; select function &quot;set mode&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp; AL,4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; specify mode (mode 4)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; 10H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; BIOS video call</TT>
<BR><BR>The above example demonstrates how to generate BIOS function calls in-line without writing an assembly language function
and calling it from your C/C++ program.&nbsp; The C prototype for the function<TT> mode4</TT> is not necessary but is included
so that we can take advantage of the argument type checking provided by Open Watcom C/C++.
<BR><BR>The following DOS example is equivalent to the above example but mnemonics for the assembly language instructions
are used instead of the binary encoding of the assembly language instructions.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void mode4(void);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux mode4 =&nbsp;&nbsp;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mov AH,0&quot;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mov AL,4&quot;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;int 10H&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; modify [ AH AL ];</TT>
<BR><BR>If a sequence of in-line assembly language instructions contains 80x87 floating-point instructions, each floating-point
instruction must be preceded by &quot;float&quot;.&nbsp; Note that this is only required if you have specified the &quot;fpi&quot;
compiler option; otherwise it will be ignored.
<BR><BR>The following example generates the 80x87 &quot;square root&quot; instruction.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; double mysqrt(double);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux mysqrt parm [8087] = \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float 0xd9 0xfa /* fsqrt */;</TT>
<BR><BR>A sequence of in-line assembly language instructions may contain symbolic references.&nbsp; In the following example,
a near call to the function<TT> myalias</TT> is made whenever<TT> myrtn</TT> is called.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern void myalias(void);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void myrtn(void);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux myrtn =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xe8 reloff myalias /* near call */;</TT>
<BR><BR>In the following example, a far call to the function<TT> myalias</TT> is made whenever<TT> myrtn</TT> is called.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern void myalias(void);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void myrtn(void);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux myrtn =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x9a offset myalias seg myalias /* far call */;</TT>
<H4 ID="16Mbit__Loading_Data_Segment_Register"> 16-bit:&nbsp; Loading Data Segment Register </H4>
<BR>An application may have been compiled so that the segment register DS does not contain the segment address of the default
data segment (group &quot;DGROUP&quot;).&nbsp; This is usually the case if you are using a large data memory model.&nbsp;
Suppose you wish to call a function that assumes that the segment register DS contains the segment address of the default
data segment.&nbsp; It would be very cumbersome if you were forced to compile your application so that the segment register
DS contained the default data segment (a small data memory model).
<BR><BR>The following form of the auxiliary pragma will cause the segment register DS to be loaded with the segment address
of the default data segment before calling the specified function.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux </TT><B>sym</B><TT> parm loadds </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a function name.
</DL>
<BR>Alternatively, the following form of the auxiliary pragma will cause the segment register DS to be loaded with the segment
address of the default data segment as part of the prologue sequence for the specified function.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux </TT><B>sym</B><TT> loadds </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a function name.
</DL>
<H4 ID="16Mbit__Defining_Exported_Symbols_in_Dynamic_Link_Libraries"> 16-bit:&nbsp; Defining Exported Symbols in Dynamic Link Libraries </H4>
<BR>An exported symbol in a dynamic link library is a symbol that can be referenced by an application that is linked with
that dynamic link library.&nbsp; Normally, symbols in dynamic link libraries are exported using the Open Watcom Linker &quot;EXPORT&quot;
directive.&nbsp; An alternative method is to use the following form of the auxiliary pragma.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux </TT><B>sym</B><TT> export </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a function name.
</DL>
<H4 ID="16Mbit__Defining_Windows_Callback_Functions"> 16-bit:&nbsp; Defining Windows Callback Functions </H4>
<BR>When compiling a Microsoft Windows application, you must use the &quot;zW&quot; option so that special prologue/epilogue
sequences are generated.&nbsp; Furthermore, callback functions require larger prologue/epilogue sequences than those generated
when the &quot;zW&quot; compiler option is specified.&nbsp; The following form of the auxiliary pragma will cause a callback
prologue/epilogue sequence to be generated for a callback function when compiled using the &quot;zW&quot; option.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux </TT><B>sym</B><TT> export </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a callback function name.
</DL>
<BR>Alternatively, the &quot;zw&quot; compiler option can be used to generate callback prologue/epilogue sequences.&nbsp;
However, all functions contained in a module compiled using the &quot;zw&quot; option will have a callback prologue/epilogue
sequence even if the functions are not callback functions.
<H4 ID="16Mbit__Forcing_a_Stack_Frame"> 16-bit:&nbsp; Forcing a Stack Frame </H4>
<BR>Normally, a function contains a stack frame if arguments are passed on the stack or an automatic variable is allocated
on the stack.&nbsp; No stack frame will be generated if the above conditions are not satisfied.&nbsp; The following form of
the auxiliary pragma will force a stack frame to be generated under any circumstance.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux </TT><B>sym</B><TT> frame </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a function name.
</DL>
<H3 ID="16Mbit__Describing_Argument_Information"> 16-bit:&nbsp; Describing Argument Information </H3>
<BR>Using auxiliary pragmas, you can describe the calling convention that Open Watcom C/C++ is to use for calling functions.
&nbsp;This is particularly useful when interfacing to functions that have been compiled by other compilers or functions written
in other programming languages.
<BR><BR>The general form of an auxiliary pragma that describes argument passing is the following.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux </TT><B>sym</B><TT> parm </TT><B>{ pop_info | </B><TT>reverse</TT><B> | {reg_set}
}</B><TT> </TT><B>[</B><TT>;</TT><B>]</B>
<BR><BR><B>&nbsp;&nbsp;&nbsp;&nbsp; pop_info ::=</B><TT> caller </TT><B>|</B><TT> routine</TT>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a function name.
<DT>reg_set
<DD>is called a register set.&nbsp; The register sets specify the registers that are to be used for argument passing.&nbsp; A
register set is a list of registers separated by spaces and enclosed in square brackets.
</DL>
<H4 ID="16Mbit__Passing_Arguments_in_Registers"> 16-bit:&nbsp; Passing Arguments in Registers </H4>
<BR>The following form of the auxiliary pragma can be used to specify the registers that are to be used to pass arguments
to a particular function.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux </TT><B>sym</B><TT> parm </TT><B>{reg_set}</B><TT> </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a function name.
<DT>reg_set
<DD>is called a register set.&nbsp; The register sets specify the registers that are to be used for argument passing.&nbsp; A
register set is a list of registers separated by spaces and enclosed in square brackets.
</DL>
<BR>Register sets establish a priority for register allocation during argument list processing.&nbsp; Register sets are processed
from left to right.&nbsp; However, within a register set, registers are chosen in any order.&nbsp; Once all register sets
have been processed, any remaining arguments are pushed on the stack.
<BR><BR>Note that regardless of the register sets specified, only certain combinations of registers will be selected for arguments
of a particular type.
<BR><BR>Note that arguments of type<B> float</B> and<B> double</B> are always pushed on the stack when the &quot;fpi&quot;
or &quot;fpi87&quot; option is used.
<DL>
<DT>double
<DD>Arguments of type<B> double</B> can only be passed in the following register combination:&nbsp; AX:BX:CX:DX.&nbsp; For example,
if the following register set was specified for a routine having an argument of type<B> double</B>,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [AX BX SI DI]</TT>
<BR><BR>the argument would be pushed on the stack since a valid register combination for 8-byte arguments is not contained
in the register set.&nbsp; Note that this method for passing arguments of type<B> double</B> is supported only when the &quot;fpc&quot;
option is used.&nbsp; Note that this argument passing method does not include the passing of 8-byte structures.
<DT>far pointer
<DD>A far pointer can only be passed in one of the following register pairs:&nbsp; DX:AX, CX:BX, CX:AX, CX:SI, DX:BX, DI:AX, CX:DI,
DX:SI, DI:BX, SI:AX, CX:DX, DX:DI, DI:SI, SI:BX, BX:AX, DS:CX, DS:DX, DS:DI, DS:SI, DS:BX, DS:AX, ES:CX, ES:DX, ES:DI, ES:SI,
ES:BX or ES:AX.&nbsp; For example, if a far pointer is passed to a function with the following register set,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [ES BP]</TT>
<BR><BR>the argument would be pushed on the stack since a valid register combination for a far pointer is not contained in
the register set.
<DT>long int, float
<DD>The only registers that will be assigned to 4-byte arguments (e.g., arguments of type<B> long int</B>,) are:&nbsp; DX:AX,
CX:BX, CX:AX, CX:SI, DX:BX, DI:AX, CX:DI, DX:SI, DI:BX, SI:AX, CX:DX, DX:DI, DI:SI, SI:BX and BX:AX.&nbsp; For example, if
the following register set was specified for a routine with one argument of type<B> long int</B>,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [ES DI]</TT>
<BR><BR>the argument would be pushed on the stack since a valid register combination for 4-byte arguments is not contained
in the register set.&nbsp; Note that this argument passing method includes 4-byte structures.&nbsp; Note that this argument
passing method includes arguments of type<B> float</B> but only when the &quot;fpc&quot; option is used.
<DT>int
<DD>The only registers that will be assigned to 2-byte arguments (e.g., arguments of type<B> int</B>) are:&nbsp; AX, BX, CX, DX,
SI and DI.&nbsp; For example, if the following register set was specified for a routine with one argument of type<B> int</B>,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [BP]</TT>
<BR><BR>the argument would be pushed on the stack since a valid register combination for 2-byte arguments is not contained
in the register set.
<DT>char
<DD>Arguments whose size is 1 byte (e.g., arguments of type<B> char</B>) are promoted to 2 bytes and are then assigned registers
as if they were 2-byte arguments.
<DT>others
<DD>Arguments that do not fall into one of the above categories cannot be passed in registers and are pushed on the stack.&nbsp;
Once an argument has been assigned a position on the stack, all remaining arguments will be assigned a position on the stack
even if all register sets have not yet been exhausted.
</DL>
<BR><B>Notes:</B>
<OL>
<LI>The default register set is [AX BX CX DX].
<LI>Specifying registers AH and AL is equivalent to specifying register AX.&nbsp; Specifying registers DH and DL is equivalent
to specifying register DX.&nbsp; Specifying registers CH and CL is equivalent to specifying register CX.&nbsp; Specifying
registers BH and BL is equivalent to specifying register BX.
<LI>If you are compiling for a memory model with a small data model, or the &quot;zdp&quot; compiler option is specified,
any register combination containing register DS becomes illegal.&nbsp; In a small data model, segment register DS must remain
unchanged as it points to the program's data segment.&nbsp; Note that the &quot;zdf&quot; compiler option can be used to specify
that register DS does not contain that segment address of the program's data segment.&nbsp; In this case, register combinations
containing register DS are legal.
</OL>
<BR>Consider the following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux myrtn parm [ax bx cx dx] [bp si];</TT>
<BR><BR>Suppose<TT> myrtn</TT> is a routine with 3 arguments each of type<B> long int</B>.
<OL>
<LI>The first argument will be passed in the register pair DX:AX.
<LI>The second argument will be passed in the register pair CX:BX.
<LI>The third argument will be pushed on the stack since BP:SI is not a valid register pair for arguments of type<B> long
int</B>.
</OL>
<BR>It is possible for registers from the second register set to be used before registers from the first register set are
used.&nbsp; Consider the following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux myrtn parm [ax bx cx dx] [si di];</TT>
<BR><BR>Suppose<TT> myrtn</TT> is a routine with 3 arguments, the first of type<B> int</B> and the second and third of type<B>
long int</B>.
<OL>
<LI>The first argument will be passed in the register AX.
<LI>The second argument will be passed in the register pair CX:BX.
<LI>The third argument will be passed in the register set DI:SI.
</OL>
<BR>Note that registers are no longer selected from a register set after registers are selected from subsequent register sets,
even if all registers from the original register set have not been exhausted.
<BR><BR>An empty register set is permitted.&nbsp; All subsequent register sets appearing after an empty register set are ignored;
all remaining arguments are pushed on the stack.
<BR><BR><B>Notes:</B>
<OL>
<LI>If a single empty register set is specified, all arguments are passed on the stack.
<LI>If no register set is specified, the default register set [AX BX CX DX] is used.
</OL>
<H4 ID="16Mbit__Forcing_Arguments_into_Specific_Registers"> 16-bit:&nbsp; Forcing Arguments into Specific Registers </H4>
<BR>It is possible to force arguments into specific registers.&nbsp; Suppose you have a function, say &quot;mycopy&quot;,
that copies data.&nbsp; The first argument is the source, the second argument is the destination, and the third argument is
the length to copy.&nbsp; If we want the first argument to be passed in the register SI, the second argument to be passed
in register DI and the third argument to be passed in register CX, the following auxiliary pragma can be used.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void mycopy( char near *, char *, int );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux mycopy parm [SI] [DI] [CX];</TT>
<BR><BR>Note that you must be aware of the size of the arguments to ensure that the arguments get passed in the appropriate
registers.
<H4 ID="16Mbit__Passing_Arguments_to_InMLine_Functions"> 16-bit:&nbsp; Passing Arguments to In-Line Functions </H4>
<BR>For functions whose code is generated by Open Watcom C/C++ and whose argument list is described by an auxiliary pragma,
Open Watcom C/C++ has some freedom in choosing how arguments are assigned to registers.&nbsp; Since the code for in-line functions
is specified by the programmer, the description of the argument list must be very explicit.&nbsp; To achieve this, Open Watcom
C/C++ assumes that each register set corresponds to an argument.&nbsp; Consider the following DOS example of an in-line function
called<TT> scrollactivepgup.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void scrollactivepgup(char,char,char,char,char,char);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux scrollactivepgup = \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mov AH,6&quot;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;int 10h&quot;&nbsp;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parm [ch] [cl] [dh] [dl] [al] [bh] \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; modify [ah];</TT>
<BR><BR>The BIOS video call to scroll the active page up requires the following arguments.
<OL>
<LI>The row and column of the upper left corner of the scroll window is passed in registers CH and CL respectively.
<LI>The row and column of the lower right corner of the scroll window is passed in registers DH and DL respectively.
<LI>The number of lines blanked at the bottom of the window is passed in register AL.
<LI>The attribute to be used on the blank lines is passed in register BH.
</OL>
<BR>When passing arguments, Open Watcom C/C++ will convert the argument so that it fits in the register(s) specified in the
register set for that argument.&nbsp; For example, in the above example, if the first argument to<TT> scrollactivepgup</TT>
was called with an argument whose type was<B> int</B>, it would first be converted to<B> char</B> before assigning it to register
CH.&nbsp; Similarly, if an in-line function required its argument in register pair DX:AX and the argument was of type<B> short
int</B>, the argument would be converted to<B> long int</B> before assigning it to register pair DX:AX.
<BR><BR>In general, Open Watcom C/C++ assigns the following types to register sets.
<OL>
<LI>A register set consisting of a single 8-bit register (1 byte) is assigned a type of<B> unsigned char</B>.
<LI>A register set consisting of a single 16-bit register (2 bytes) is assigned a type of<B> unsigned short int</B>.
<LI>A register set consisting of two 16-bit registers (4 bytes) is assigned a type of<B> unsigned long int</B>.
<LI>A register set consisting of four 16-bit registers (8 bytes) is assigned a type of<B> double</B>.
</OL>
<H4 ID="16Mbit__Removing_Arguments_from_the_Stack"> 16-bit:&nbsp; Removing Arguments from the Stack </H4>
<BR>The following form of the auxiliary pragma specifies who removes from the stack arguments that were pushed on the stack.
&nbsp;
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux </TT><B>sym</B><TT> parm </TT><B>(</B><TT>caller </TT><B>|</B><TT> routine</TT><B>)</B><TT>
</TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a function name.
</DL>
<BR>&quot;caller&quot; specifies that the caller will pop the arguments from the stack; &quot;routine&quot; specifies that
the called routine will pop the arguments from the stack.&nbsp; If &quot;caller&quot; or &quot;routine&quot; is omitted, &quot;routine&quot;
is assumed unless the default has been changed in a previous auxiliary pragma, in which case the new default is assumed.
<H4 ID="16Mbit__Passing_Arguments_in_Reverse_Order"> 16-bit:&nbsp; Passing Arguments in Reverse Order </H4>
<BR>The following form of the auxiliary pragma specifies that arguments are passed in the reverse order.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux </TT><B>sym</B><TT> parm reverse </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a function name.
</DL>
<BR>Normally, arguments are processed from left to right.&nbsp; The leftmost arguments are passed in registers and the rightmost
arguments are passed on the stack (if the registers used for argument passing have been exhausted).&nbsp; Arguments that are
passed on the stack are pushed from right to left.
<BR><BR>When arguments are reversed, the rightmost arguments are passed in registers and the leftmost arguments are passed
on the stack (if the registers used for argument passing have been exhausted).&nbsp; Arguments that are passed on the stack
are pushed from left to right.
<BR><BR>Reversing arguments is most useful for functions that require arguments to be passed on the stack in an order opposite
from the default.&nbsp; The following auxiliary pragma demonstrates such a function.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux rtn parm reverse [];</TT>
<H3 ID="16Mbit__Describing_Function_Return_Information"> 16-bit:&nbsp; Describing Function Return Information </H3>
<BR>Using auxiliary pragmas, you can describe the way functions are to return values.&nbsp; This is particularly useful when
interfacing to functions that have been compiled by other compilers or functions written in other programming languages.
<BR><BR>The general form of an auxiliary pragma that describes the way a function returns its value is the following.&nbsp;

<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux </TT><B>sym</B><TT> value </TT><B>{</B><TT>no8087 </TT><B>|</B><TT> </TT><B>reg_set</B><TT>
</TT><B>|</B><TT> </TT><B>struct_info}</B><TT> </TT><B>[</B><TT>;</TT><B>]</B>
<BR><BR><B>&nbsp;&nbsp;&nbsp;&nbsp; struct_info ::=</B><TT> struct </TT><B>{</B><TT>float </TT><B>|</B><TT> struct </TT><B>|</B><TT>
</TT><B>(</B><TT>routine </TT><B>|</B><TT> caller</TT><B>)</B><TT> </TT><B>|</B><TT> </TT><B>reg_set}</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a function name.
<DT>reg_set
<DD>is called a register set.&nbsp; The register sets specify the registers that are to be used for argument passing.&nbsp; A
register set is a list of registers separated by spaces and enclosed in square brackets.
</DL>
<H4 ID="16Mbit__Returning_Function_Values_in_Registers"> 16-bit:&nbsp; Returning Function Values in Registers </H4>
<BR>The following form of the auxiliary pragma can be used to specify the registers that are to be used to return a function's
value.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux </TT><B>sym</B><TT> value </TT><B>reg_set</B><TT> </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a function name.
<DT>reg_set
<DD>is a register set.
</DL>
<BR>Note that the method described below for returning values of type<B> float</B> or<B> double</B> is supported only when
the &quot;fpc&quot; option is used.
<BR><BR>Depending on the type of the return value, only certain registers are allowed in<B> reg_set.</B>
<DL>
<DT>1-byte
<DD>For 1-byte return values, only the following registers are allowed:&nbsp; AL, AH, DL, DH, BL, BH, CL or CH.&nbsp; If no register
set is specified, register AL will be used.
<DT>2-byte
<DD>For 2-byte return values, only the following registers are allowed:&nbsp; AX, DX, BX, CX, SI or DI.&nbsp; If no register set
is specified, register AX will be used.
<DT>4-byte
<DD>For 4-byte return values (except far pointers), only the following register pairs are allowed:&nbsp; DX:AX, CX:BX, CX:AX,
CX:SI, DX:BX, DI:AX, CX:DI, DX:SI, DI:BX, SI:AX, CX:DX, DX:DI, DI:SI, SI:BX or BX:AX.&nbsp; If no register set is specified,
registers DX:AX will be used.&nbsp; This form of the auxiliary pragma is legal for functions of type<B> float</B> when using
the &quot;fpc&quot; option only.
<DT>far pointer
<DD>For functions that return far pointers, the following register pairs are allowed:&nbsp; DX:AX, CX:BX, CX:AX, CX:SI, DX:BX,
DI:AX, CX:DI, DX:SI, DI:BX, SI:AX, CX:DX, DX:DI, DI:SI, SI:BX, BX:AX, DS:CX, DS:DX, DS:DI, DS:SI, DS:BX, DS:AX, ES:CX, ES:DX,
ES:DI, ES:SI, ES:BX or ES:AX.&nbsp; If no register set is specified, the registers DX:AX will be used.
<DT>8-byte
<DD>For 8-byte return values (including functions of type<B> double</B>), only the following register combination is allowed:
&nbsp;AX:BX:CX:DX.&nbsp; If no register set is specified, the registers AX:BX:CX:DX will be used.&nbsp; This form of the auxiliary
pragma is legal for functions of type<B> double</B> when using the &quot;fpc&quot; option only.
</DL>
<BR><B>Notes:</B>
<OL>
<LI>An empty register set is not allowed.
<LI>If you are compiling for a memory model which has a small data model, any of the above register combinations containing
register DS becomes illegal.&nbsp; In a small data model, segment register DS must remain unchanged as it points to the program's
data segment.
</OL>
<H4 ID="16Mbit__Returning_Structures"> 16-bit:&nbsp; Returning Structures </H4>
<BR>Typically, structures are not returned in registers.&nbsp; Instead, the caller allocates space on the stack for the return
value and sets register SI to point to it.&nbsp; The called routine then places the return value at the location pointed to
by register SI.
<BR><BR>The following form of the auxiliary pragma can be used to specify the register that is to be used to point to the
return value.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux </TT><B>sym</B><TT> value struct </TT><B>(</B><TT>caller</TT><B>|</B><TT>routine</TT><B>)</B><TT>
</TT><B>reg_set</B><TT> </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a function name.
<DT>reg_set
<DD>is a register set.
</DL>
<BR>&quot;caller&quot; specifies that the caller will allocate memory for the return value.&nbsp; The address of the memory
allocated for the return value is placed in the register specified in the register set by the caller before the function is
called.&nbsp; If an empty register set is specified, the address of the memory allocated for the return value will be pushed
on the stack immediately before the call and will be returned in register AX by the called routine.&nbsp; It is assumed that
the memory for the return value is allocated from the stack segment (the stack segment is contained in segment register SS).
<BR><BR>&quot;routine&quot; specifies that the called routine will allocate memory for the return value.&nbsp; Upon returning
to the caller, the register specified in the register set will contain the address of the return value.&nbsp; An empty register
set is not allowed.
<BR><BR>Only the following registers are allowed in the register set:&nbsp; AX, DX, BX, CX, SI or DI.&nbsp; Note that in a
big data model, the address in the return register is assumed to be in the segment specified by the value in the SS segment
register.
<BR><BR>If the size of the structure being returned is 1, 2 or 4 bytes, it will be returned in registers.&nbsp; The return
register will be selected from the register set in the following way.
<OL>
<LI>A 1-byte structure will be returned in one of the following registers:&nbsp; AL, AH, DL, DH, BL, BH, CL or CH.&nbsp; If
no register set is specified, register AL will be used.
<LI>A 2-byte structure will be returned in one of the following registers:&nbsp; AX, DX, BX, CX, SI or DI.&nbsp; If no register
set is specified, register AX will be used.
<LI>A 4-byte structure will be returned in one of the following register pairs:&nbsp; DX:AX, CX:BX, CX:AX, CX:SI, DX:BX, DI:AX,
CX:DI, DX:SI, DI:BX, SI:AX, CX:DX, DX:DI, DI:SI, SI:BX or BX:AX.&nbsp; If no register set is specified, register pair DX:AX
will be used.
</OL>
<BR>The following form of the auxiliary pragma can be used to specify that structures whose size is 1, 2 or 4 bytes are not
to be returned in registers.&nbsp; Instead, the caller will allocate space on the stack for the structure return value and
point register SI to it.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux </TT><B>sym</B><TT> value struct struct </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a function name.
</DL>
<H4 ID="16Mbit__Returning_FloatingMPoint_Data"> 16-bit:&nbsp; Returning Floating-Point Data </H4>
<BR>There are a few ways available for specifying how the value for a function whose type is<B> float</B> or<B> double</B>
is to be returned.
<BR><BR>The following form of the auxiliary pragma can be used to specify that function return values whose type is<B> float</B>
or<B> double</B> are not to be returned in registers.&nbsp; Instead, the caller will allocate space on the stack for the return
value and point register SI to it.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux </TT><B>sym</B><TT> value struct float </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a function name.
</DL>
<BR>In other words, floating-point values are to be returned in the same way structures are returned.
<BR><BR>The following form of the auxiliary pragma can be used to specify that function return values whose type is<B> float</B>
or<B> double</B> are not to be returned in 80x87 registers when compiling with the &quot;fpi&quot; or &quot;fpi87&quot; option.
&nbsp;Instead, the value will be returned in 80x86 registers.&nbsp; This is the default behaviour for the &quot;fpc&quot;
option.&nbsp; Function return values whose type is<B> float</B> will be returned in registers DX:AX.&nbsp; Function return
values whose type is<B> double</B> will be returned in registers AX:BX:CX:DX.&nbsp; This is the default method for the &quot;fpc&quot;
option.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux </TT><B>sym</B><TT> value no8087 </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a function name.
</DL>
<BR>The following form of the auxiliary pragma can be used to specify that function return values whose type is<B> float</B>
or<B> double</B> are to be returned in ST(0) when compiling with the &quot;fpi&quot; or &quot;fpi87&quot; option.&nbsp; This
form of the auxiliary pragma is not legal for the &quot;fpc&quot; option.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux </TT><B>sym</B><TT> value [8087] </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a function name.
</DL>
<H3 ID="16Mbit__A_Function_that_Never_Returns"> 16-bit:&nbsp; A Function that Never Returns </H3>
<BR>The following form of the auxiliary pragma can be used to describe a function that does not return to the caller.&nbsp;

<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux </TT><B>sym</B><TT> aborts </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a function name.
</DL>
<BR>Consider the following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux exitrtn aborts;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern void exitrtn(void);</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void rtn()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exitrtn();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>exitrtn</TT> is defined to be a function that does not return.&nbsp; For example, it may call<TT> exit</TT> to
return to the system.&nbsp; In this case, Open Watcom C/C++ generates a &quot;jmp&quot; instruction instead of a &quot;call&quot;
instruction to invoke<TT> exitrtn.</TT>
<H3 ID="16Mbit__Describing_How_Functions_Use_Memory"> 16-bit:&nbsp; Describing How Functions Use Memory </H3>
<BR>The following form of the auxiliary pragma can be used to describe a function that does not modify any memory (i.e., global
or static variables) that is used directly or indirectly by the caller.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux </TT><B>sym</B><TT> modify nomemory </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a function name.
</DL>
<BR>Consider the following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma off (check_stack);</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern void myrtn(void);</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int i = { 1033 };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern Rtn() {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( i &lt; 10000 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i += 383;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myrtn();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i += 13143;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR>To compile the above program, &quot;rtn.c&quot;, we issue the following command.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wcc rtn -oai -d1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wpp rtn -oai -d1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wcc386 rtn -oai -d1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wpp386 rtn -oai -d1</TT>
<BR><BR>For illustrative purposes, we omit loop optimizations from the list of code optimizations that we want the compiler
to perform.&nbsp; The &quot;d1&quot; compiler option is specified so that the object file produced by Open Watcom C/C++ contains
source line information.
<BR><BR>We can generate a file containing a disassembly of<TT> rtn.obj</TT> by issuing the following command.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wdis rtn -l -s -r</TT>
<BR><BR>The &quot;s&quot; option is specified so that the listing file produced by the Open Watcom Disassembler contains source
lines taken from<TT> rtn.c.</TT>&nbsp; The listing file<TT> rtn.lst</TT> appears as follows.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Module: rtn.c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Group: 'DGROUP' CONST,_DATA</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Segment: '_TEXT' BYTE&nbsp; 0026 bytes</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma off (check_stack);</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern void MyRtn( void );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int i = { 1033 };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern Rtn()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0000&nbsp; 52&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; Rtn_&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; DX</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0001&nbsp; 8b 16 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; DX,_i</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( i &lt; 10000 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0005&nbsp; 81 fa 10 27&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; L1&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmp&nbsp;&nbsp;&nbsp;&nbsp; DX,2710H</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0009&nbsp; 7d 06&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jge&nbsp;&nbsp;&nbsp;&nbsp;
L2</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i += 383;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 000b&nbsp; 81 c2 7f 01&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add&nbsp;&nbsp;&nbsp;&nbsp; DX,017fH</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 000f&nbsp; eb f4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jmp&nbsp;&nbsp;&nbsp;&nbsp;
L1</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyRtn();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0011&nbsp; 89 16 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; L2&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; _i,DX</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0015&nbsp; e8 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call&nbsp;&nbsp;&nbsp; MyRtn_</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0018&nbsp; 8b 16 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; DX,_i</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i += 13143;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 001c&nbsp; 81 c2 57 33&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add&nbsp;&nbsp;&nbsp;&nbsp; DX,3357H</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0020&nbsp; 89 16 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; _i,DX</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0024&nbsp; 5a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;
&nbsp; DX</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0025&nbsp; c3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; No disassembly errors</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ------------------------------------------------------------</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Segment: '_DATA' WORD&nbsp; 0002 bytes</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0000&nbsp; 09 04&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _i&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - ..</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; No disassembly errors</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ------------------------------------------------------------</TT>
<BR><BR>Let us add the following auxiliary pragma to the source file.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux myrtn modify nomemory;</TT>
<BR><BR>If we compile the source file with the above pragma and disassemble the object file using the Open Watcom Disassembler,
we get the following listing file.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Module: rtn.c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Group: 'DGROUP' CONST,_DATA</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Segment: '_TEXT' BYTE&nbsp; 0022 bytes</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma off (check_stack);</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern void MyRtn( void );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux MyRtn modify nomemory;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int i = { 1033 };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern Rtn()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0000&nbsp; 52&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; Rtn_&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; DX</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0001&nbsp; 8b 16 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; DX,_i</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( i &lt; 10000 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0005&nbsp; 81 fa 10 27&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; L1&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmp&nbsp;&nbsp;&nbsp;&nbsp; DX,2710H</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0009&nbsp; 7d 06&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jge&nbsp;&nbsp;&nbsp;&nbsp;
L2</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i += 383;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 000b&nbsp; 81 c2 7f 01&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add&nbsp;&nbsp;&nbsp;&nbsp; DX,017fH</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 000f&nbsp; eb f4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jmp&nbsp;&nbsp;&nbsp;&nbsp;
L1</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyRtn();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0011&nbsp; 89 16 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; L2&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; _i,DX</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0015&nbsp; e8 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call&nbsp;&nbsp;&nbsp; MyRtn_</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i += 13143;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0018&nbsp; 81 c2 57 33&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add&nbsp;&nbsp;&nbsp;&nbsp; DX,3357H</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 001c&nbsp; 89 16 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; _i,DX</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0020&nbsp; 5a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;
&nbsp; DX</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0021&nbsp; c3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; No disassembly errors</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ------------------------------------------------------------</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Segment: '_DATA' WORD&nbsp; 0002 bytes</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0000&nbsp; 09 04&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _i&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - ..</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; No disassembly errors</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ------------------------------------------------------------</TT>
<BR><BR>Notice that the value of<TT> i</TT> is in register DX after completion of the &quot;while&quot; loop.&nbsp; After
the call to<TT> myrtn,</TT> the value of<TT> i</TT> is not loaded from memory into a register to perform the final addition.
&nbsp;The auxiliary pragma informs the compiler that<TT> myrtn</TT> does not modify any memory (i.e., global or static variables)
that is used directly or indirectly by<TT> Rtn</TT> and hence register DX contains the correct value of<TT> i.</TT>
<BR><BR>The preceding auxiliary pragma deals with routines that modify memory.&nbsp; Let us consider the case where routines
reference memory.&nbsp; The following form of the auxiliary pragma can be used to describe a function that does not reference
any memory (i.e., global or static variables) that is used directly or indirectly by the caller.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux </TT><B>sym</B><TT> parm nomemory modify nomemory </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a function name.
</DL>
<BR><B>Notes:</B>
<OL>
<LI>You must specify both &quot;parm nomemory&quot; and &quot;modify nomemory&quot;.
</OL>
<BR>Let us replace the auxiliary pragma in the above example with the following auxiliary pragma.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux myrtn parm nomemory modify nomemory;</TT>
<BR><BR>If you now compile our source file and disassemble the object file using WDIS, the result is the following listing
file.
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Module: rtn.c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Group: 'DGROUP' CONST,_DATA</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Segment: '_TEXT' BYTE&nbsp; 001e bytes</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma off (check_stack);</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern void MyRtn( void );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux MyRtn parm nomemory modify nomemory;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int i = { 1033 };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern Rtn()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0000&nbsp; 52&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; Rtn_&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; DX</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0001&nbsp; 8b 16 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; DX,_i</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( i &lt; 10000 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0005&nbsp; 81 fa 10 27&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; L1&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmp&nbsp;&nbsp;&nbsp;&nbsp; DX,2710H</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0009&nbsp; 7d 06&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jge&nbsp;&nbsp;&nbsp;&nbsp;
L2</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i += 383;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 000b&nbsp; 81 c2 7f 01&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add&nbsp;&nbsp;&nbsp;&nbsp; DX,017fH</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 000f&nbsp; eb f4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jmp&nbsp;&nbsp;&nbsp;&nbsp;
L1</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyRtn();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0011&nbsp; e8 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; L2&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call&nbsp;&nbsp;&nbsp; MyRtn_</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i += 13143;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0014&nbsp; 81 c2 57 33&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add&nbsp;&nbsp;&nbsp;&nbsp; DX,3357H</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0018&nbsp; 89 16 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; _i,DX</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 001c&nbsp; 5a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;
&nbsp; DX</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 001d&nbsp; c3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; No disassembly errors</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ------------------------------------------------------------</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Segment: '_DATA' WORD&nbsp; 0002 bytes</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0000&nbsp; 09 04&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _i&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - ..</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; No disassembly errors</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ------------------------------------------------------------</TT>
<BR><BR>Notice that after completion of the &quot;while&quot; loop we did not have to update<TT> i</TT> with the value in
register DX before calling<TT> myrtn.</TT>&nbsp; The auxiliary pragma informs the compiler that<TT> myrtn</TT> does not reference
any memory (i.e., global or static variables) that is used directly or indirectly by<TT> myrtn</TT> so updating<TT> i</TT>
was not necessary before calling<TT> myrtn.</TT>
<H3 ID="16Mbit__Describing_the_Registers_Modified_by_a_Function"> 16-bit:&nbsp; Describing the Registers Modified by a Function </H3>
<BR>The following form of the auxiliary pragma can be used to describe the registers that a function will use without saving.
&nbsp;
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux </TT><B>sym</B><TT> modify </TT><B>[</B><TT>exact</TT><B>]</B><TT> </TT><B>reg_set</B><TT>
</TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a function name.
<DT>reg_set
<DD>is a register set.
</DL>
<BR>Specifying a register set informs Open Watcom C/C++ that the registers belonging to the register set are modified by the
function.&nbsp; That is, the value in a register before calling the function is different from its value after execution of
the function.
<BR><BR>Registers that are used to pass arguments are assumed to be modified and hence do not have to be saved and restored
by the called function.&nbsp; Also, since the AX register is frequently used to return a value, it is always assumed to be
modified.&nbsp; If necessary, the caller will contain code to save and restore the contents of registers used to pass arguments.
&nbsp;Note that saving and restoring the contents of these registers may not be necessary if the called function does not
modify them.&nbsp; The following form of the auxiliary pragma can be used to describe exactly those registers that will be
modified by the called function.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux </TT><B>sym</B><TT> modify exact </TT><B>reg_set</B><TT> </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a function name.
<DT>reg_set
<DD>is a register set.
</DL>
<BR>The above form of the auxiliary pragma tells Open Watcom C/C++ not to assume that the registers used to pass arguments
will be modified by the called function.&nbsp; Instead, only the registers specified in the register set will be modified.
&nbsp;This will prevent generation of the code which unnecessarily saves and restores the contents of the registers used to
pass arguments.
<BR><BR>Also, any registers that are specified in the<TT> value</TT> register set are assumed to be unmodified unless explicitly
listed in the<TT> exact</TT> register set.&nbsp; In the following example, the code generator will not generate code to save
and restore the value of the stack pointer register since we have told it that &quot;GetSP&quot; does not modify any register
whatsoever.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned GetSP(void);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #if defined(__386__)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux GetSP = value [esp] modify exact [];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux GetSP = value [sp] modify exact [];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #endif</TT>
<H3 ID="16Mbit__An_Example"> 16-bit:&nbsp; An Example </H3>
<BR>As mentioned in an earlier section, the following pragma defines the calling convention for functions compiled by Microsoft
C.&nbsp; 
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux MS_C &quot;_*&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;\</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; parm caller []&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; value struct float struct routine [ax]\</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; modify [ax bx cx dx es];</TT>
<BR><BR>Let us discuss this pragma in detail.
<DL>
<DT>&quot;_*&quot;
<DD>specifies that all function and variable names are preceded by the underscore character (_) when translated from source form
to object form.
<DT>parm caller []
<DD>specifies that all arguments are to be passed on the stack (an empty register set was specified) and the caller will remove
the arguments from the stack.
<DT>value struct
<DD>marks the section describing how the called routine returns structure information.
<DL>
<DT>float
<DD>specifies that floating-point arguments are returned in the same way as structures are returned.
<DT>struct
<DD>specifies that 1, 2 and 4-byte structures are not to be returned in registers.
<DT>routine
<DD>specifies that the called routine allocates storage for the return structure and returns with a register pointing at it.
<DT>[ax]
<DD>specifies that register AX is used to point to the structure return value.
</DL>
<DT>modify [ax bx cx dx es]
<DD>
<BR><BR>specifies that registers AX, BX, CX, DX and ES are not preserved by the called routine.
</DL>
<BR>Note that the default method of returning integer values is used; 1-byte characters are returned in register AL, 2-byte
integers are returned in register AX, and 4-byte integers are returned in the register pair DX:AX.
<H3 ID="16Mbit__Auxiliary_Pragmas_and_the_80x87"> 16-bit:&nbsp; Auxiliary Pragmas and the 80x87 </H3>
<BR>This section deals with those aspects of auxiliary pragmas that are specific to the 80x87.&nbsp; The discussion in this
chapter assumes that one of the &quot;fpi&quot; or &quot;fpi87&quot; options is used to compile functions.&nbsp; The following
areas are affected by the use of these options.
<OL>
<LI>passing floating-point arguments to functions,
<LI>returning floating-point values from functions and
<LI>which 80x87 floating-point registers are allowed to be modified by the called routine.
</OL>
<H4 ID="16Mbit__Using_the_80x87_to_Pass_Arguments"> 16-bit:&nbsp; Using the 80x87 to Pass Arguments </H4>
<BR>By default, floating-point arguments are passed on the 80x86 stack.&nbsp; The 80x86 registers are never used to pass floating-point
arguments when a function is compiled with the &quot;fpi&quot; or &quot;fpi87&quot; option.&nbsp; However, they can be used
to pass arguments whose type is not floating-point such as arguments of type &quot;int&quot;.
<BR><BR>The following form of the auxiliary pragma can be used to describe the registers that are to be used to pass arguments
to functions.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux </TT><B>sym</B><TT> parm </TT><B>{reg_set}</B><TT> </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a function name.
<DT>reg_set
<DD>is a register set.&nbsp; The register set can contain 80x86 registers and/or the string &quot;8087&quot;.
</DL>
<BR><B>Notes:</B>
<OL>
<LI>If an empty register set is specified, all arguments, including floating-point arguments, will be passed on the 80x86
stack.
</OL>
<BR>When the string &quot;8087&quot; appears in a register set, it simply means that floating-point arguments can be passed
in 80x87 floating-point registers if the source file is compiled with the &quot;fpi&quot; or &quot;fpi87&quot; option.&nbsp;
Before discussing argument passing in detail, some general notes on the use of the 80x87 floating-point registers are given.
<BR><BR>The 80x87 contains 8 floating-point registers which essentially form a stack.&nbsp; The stack pointer is called ST
and is a number between 0 and 7 identifying which 80x87 floating-point register is at the top of the stack.&nbsp; ST is initially
0.&nbsp; 80x87 instructions reference these registers by specifying a floating-point register number.&nbsp; This number is
then added to the current value of ST.&nbsp; The sum (taken modulo 8) specifies the 80x87 floating-point register to be used.
&nbsp;The notation ST(n), where &quot;n&quot; is between 0 and 7, is used to refer to the position of an 80x87 floating-point
register relative to ST.
<BR><BR>When a floating-point value is loaded onto the 80x87 floating-point register stack, ST is decremented (modulo 8),
and the value is loaded into ST(0).&nbsp; When a floating-point value is stored and popped from the 80x87 floating-point register
stack, ST is incremented (modulo 8) and ST(1) becomes ST(0).&nbsp; The following illustrates the use of the 80x87 floating-point
registers as a stack, assuming that the value of ST is 4 (4 values have been loaded onto the 80x87 floating-point register
stack).
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; | 4th from top&nbsp;&nbsp;
|&nbsp; ST(4)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp; | 5th from top&nbsp;&nbsp;
|&nbsp; ST(5)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp; | 6th from top&nbsp;&nbsp;
|&nbsp; ST(6)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp; | 7th from top&nbsp;&nbsp;
|&nbsp; ST(7)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ST -&gt; 4&nbsp;&nbsp;&nbsp;&nbsp; | top of stack&nbsp;&nbsp; |&nbsp; ST(0)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5&nbsp;&nbsp;&nbsp;&nbsp; | 1st from top&nbsp;&nbsp;
|&nbsp; ST(1)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6&nbsp;&nbsp;&nbsp;&nbsp; | 2nd from top&nbsp;&nbsp;
|&nbsp; ST(2)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7&nbsp;&nbsp;&nbsp;&nbsp; | 3rd from top&nbsp;&nbsp;
|&nbsp; ST(3)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><BR>Starting with version 9.5, the Open Watcom compilers use all eight of the 80x87 registers as a stack.&nbsp; The initial
state of the 80x87 register stack is empty before a program begins execution.
<DL>
<DT>Note:
<DD>For compatibility with code compiled with version 9.0 and earlier, you can compile with the &quot;fpr&quot; option.&nbsp;
In this case only four of the eight 80x87 registers are used as a stack.&nbsp; These four registers were used to pass arguments.
&nbsp;The other four registers form what was called the 80x87 cache.&nbsp; The cache was used for local floating-point variables.
&nbsp;The state of the 80x87 registers before a program began execution was as follows.
<OL>
<LI>The four 80x87 floating-point registers that form the stack are uninitialized.
<LI>The four 80x87 floating-point registers that form the 80x87 cache are initialized with zero.
</OL>
<BR>Hence, initially the 80x87 cache was comprised of ST(0), ST(1), ST(2) and ST(3).&nbsp; ST had the value 4 as in the above
diagram.&nbsp; When a floating-point value was pushed on the stack (as is the case when passing floating-point arguments),
it became ST(0) and the 80x87 cache was comprised of ST(1), ST(2), ST(3) and ST(4).&nbsp; When the 80x87 stack was full, ST(0),
ST(1), ST(2) and ST(3) formed the stack and ST(4), ST(5), ST(6) and ST(7) formed the 80x87 cache.&nbsp; Version 9.5 and later
no longer use this strategy.
</DL>
<BR>The rules for passing arguments are as follows.
<OL>
<LI>If the argument is not floating-point, use the procedure described earlier in this chapter.
<LI>If the argument is floating-point, and a previous argument has been assigned a position on the 80x86 stack (instead of
the 80x87 stack), the floating-point argument is also assigned a position on the 80x86 stack.&nbsp; Otherwise proceed to the
next step.
<LI>If the string &quot;8087&quot; appears in a register set in the pragma, and if the 80x87 stack is not full, the floating-point
argument is assigned floating-point register ST(0) (the top element of the 80x87 stack).&nbsp; The previous top element (if
there was one) is now in ST(1).&nbsp; Since arguments are pushed on the stack from right to left, the leftmost floating-point
argument will be in ST(0).&nbsp; Otherwise the floating-point argument is assigned a position on the 80x86 stack.
</OL>
<BR>Consider the following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux myrtn parm [8087];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float&nbsp;&nbsp;&nbsp; x;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double&nbsp;&nbsp; y;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long int j;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = 7.7;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = 7;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y = 77.77;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j = 77;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myrtn( x, i, y, j );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>myrtn</TT> is an assembly language function that requires four arguments.&nbsp; The first argument of type<B>
float</B> (4 bytes), the second argument is of type<B> int</B> (2 bytes), the third argument is of type<B> double</B> (8 bytes)
and the fourth argument is of type<B> long int</B> (4 bytes).&nbsp; These arguments will be passed to<TT> myrtn</TT> in the
following way.
<OL>
<LI>Since &quot;8087&quot; was specified in the register set, the first argument, being of type<B> float</B>, will be passed
in an 80x87 floating-point register.
<LI>The second argument will be passed on the stack since no 80x86 registers were specified in the register set.
<LI>The third argument will also be passed on the stack.&nbsp; Remember the following rule:&nbsp; once an argument is assigned
a position on the stack, all remaining arguments will be assigned a position on the stack.&nbsp; Note that the above rule
holds even though there are some 80x87 floating-point registers available for passing floating-point arguments.
<LI>The fourth argument will also be passed on the stack.
</OL>
<BR>Let us change the auxiliary pragma in the above example as follows.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux myrtn parm [ax 8087];</TT>
<BR><BR>The arguments will now be passed to<TT> myrtn</TT> in the following way.
<OL>
<LI>Since &quot;8087&quot; was specified in the register set, the first argument, being of type<B> float</B> will be passed
in an 80x87 floating-point register.
<LI>The second argument will be passed in register AX, exhausting the set of available 80x86 registers for argument passing.
<LI>The third argument, being of type<B> double</B>, will also be passed in an 80x87 floating-point register.
<LI>The fourth argument will be passed on the stack since no 80x86 registers remain in the register set.
</OL>
<H4 ID="16Mbit__Using_the_80x87_to_Return_Function_Values"> 16-bit:&nbsp; Using the 80x87 to Return Function Values </H4>
<BR>The following form of the auxiliary pragma can be used to describe a function that returns a floating-point value in ST(0).
&nbsp;
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux </TT><B>sym</B><TT> value </TT><B>reg_set</B><TT> </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a function name.
<DT>reg_set
<DD>is a register set containing the string &quot;8087&quot;, i.e.&nbsp; [8087].
</DL>
<H4 ID="16Mbit__Preserving_80x87_FloatingMPoint_Registers_Across_Calls"> 16-bit:&nbsp; Preserving 80x87 Floating-Point Registers Across Calls </H4>
<BR>The code generator assumes that all eight 80x87 floating-point registers are available for use within a function unless
the &quot;fpr&quot; option is used to generate backward compatible code (older Open Watcom compilers used four registers as
a cache).&nbsp; The following form of the auxiliary pragma specifies that the floating-point registers in the 80x87 cache
may be modified by the specified function.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux </TT><B>sym</B><TT> modify </TT><B>reg_set</B><TT> </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a function name.
<DT>reg_set
<DD>is a register set containing the string &quot;8087&quot;, i.e.&nbsp; [8087].
</DL>
<BR>This instructs Open Watcom C/C++ to save any local variables that are located in the 80x87 cache before calling the specified
routine.
<H1 ID="32Mbit_Memory_Models"> 32-bit Memory Models </H1>
<BR><BR>This chapter describes the various 32-bit memory models supported by Open Watcom C/C++.&nbsp; Each memory model is
distinguished by two properties; the code model used to implement function calls and the data model used to reference data.
<H2 ID="32Mbit_Code_Models"> 32-bit Code Models </H2>
<BR>There are two code models;
<OL>
<LI>the small code model and
<LI>the big code model.
</OL>
<BR>A small code model is one in which all calls to functions are made with<B> near calls.</B>&nbsp; In a near call, the destination
address is 32 bits and is relative to the segment value in segment register CS.&nbsp; Hence, in a small code model, all code
comprising your program, including library functions, must be less than 4GB.
<BR><BR>A big code model is one in which all calls to functions are made with<B> far calls.</B>&nbsp; In a far call, the destination
address is 48 bits (a 16-bit segment value and a 32-bit offset relative to the segment value).&nbsp; This model allows the
size of the code comprising your program to exceed 4GB.
<HR>
<BR><B><I>&nbsp; Note:</I></B>&nbsp; If your program contains less than 4GB of code, you should use a memory model that employs
the small code model.&nbsp; This will result in smaller and faster code since near calls are smaller instructions and are
processed faster by the CPU.
<HR>
<H2 ID="32Mbit_Data_Models"> 32-bit Data Models </H2>
<BR>There are two data models;
<OL>
<LI>the small data model and
<LI>the big data model.
</OL>
<BR>A small data model is one in which all references to data are made with<B> near pointers.</B>&nbsp; Near pointers are
32 bits; all data references are made relative to the segment value in segment register DS.&nbsp; Hence, in a small data model,
all data comprising your program must be less than 4GB.
<BR><BR>A big data model is one in which all references to data are made with<B> far pointers.</B>&nbsp; Far pointers are
48 bits (a 16-bit segment value and a 32-bit offset relative to the segment value).&nbsp; This removes the 4GB limitation
on data size imposed by the small data model.&nbsp; However, when a far pointer is incremented, only the offset is adjusted.
&nbsp;Open Watcom C/C++ assumes that the offset portion of a far pointer will not be incremented beyond 4GB.&nbsp; The compiler
will assign an object to a new segment if the grouping of data in a segment will cause the object to cross a segment boundary.
&nbsp;Implicit in this is the requirement that no individual object exceed 4GB.
<HR>
<BR><B><I>&nbsp; Note:</I></B>&nbsp; If your program contains less than 4GB of data, you should use the small data model.
&nbsp;This will result in smaller and faster code since references using near pointers produce fewer instructions.
<HR>
<H2 ID="Summary_of_32Mbit_Memory_Models"> Summary of 32-bit Memory Models </H2>
<BR>As previously mentioned, a memory model is a combination of a code model and a data model.&nbsp; The following table describes
the memory models supported by Open Watcom C/C++.&nbsp; 
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Memory&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Code&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Data
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Default&nbsp;&nbsp;&nbsp;&nbsp; Default</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Model&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Model&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Model
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Code&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Data</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Pointer
&nbsp;&nbsp;&nbsp; Pointer</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; --------&nbsp;&nbsp;&nbsp; --------&nbsp;&nbsp;&nbsp; --------&nbsp;&nbsp;&nbsp; --------
&nbsp;&nbsp; --------</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; flat&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; small&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
small&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; near&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; near</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; small&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; small&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; small
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; near&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; near</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; medium&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; big&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
small&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; far&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; near</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; compact&nbsp;&nbsp;&nbsp;&nbsp; small&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; big&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; near&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; far</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; large&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; big&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;big&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; far&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; far</TT>
<H2 ID="Flat_Memory_Model"> Flat Memory Model </H2>
<BR>In the flat memory model, the application's code and data must total less than 4GB in size.&nbsp; Segment registers CS,
DS, SS and ES point to the same linear address space (this does not imply that the segment registers contain the same value).
&nbsp;That is, a given offset in one segment refers to the same memory location as that offset in another segment.&nbsp; Essentially,
a flat model operates as if there were no segments.
<H2 ID="Mixed_32Mbit_Memory_Model"> Mixed 32-bit Memory Model </H2>
<BR>A mixed memory model application combines elements from the various code and data models.&nbsp; A mixed memory model application
might be characterized as one that uses the<B><I> near</I></B> ,<B><I> far</I></B> , or<B><I> huge</I></B> keywords when describing
some of its functions or data objects.
<BR><BR>For example, a medium memory model application that uses some far pointers to data can be described as a mixed memory
model.&nbsp; In an application such as this, most of the data is in a 4GB segment (DGROUP) and hence can be referenced with
near pointers relative to the segment value in segment register DS.&nbsp; This results in more efficient code being generated
and better execution times than one can expect from a big data model.&nbsp; Data objects outside of the DGROUP segment are
described with the<B><I> far</I></B> keyword.
<H2 ID="Linking_Applications_for_the_Various_32Mbit_Memory_Models"> Linking Applications for the Various 32-bit Memory Models </H2>
<BR>Each memory model requires different run-time and floating-point libraries.&nbsp; Each library assumes a particular memory
model and should be linked only with modules that have been compiled with the same memory model.&nbsp; The following table
lists the libraries that are to be used to link an application that has been compiled for a particular memory model.&nbsp;
Currently, only libraries for the flat/small memory model are provided.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Memory&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Run-time&nbsp;&nbsp;&nbsp; Floating-Point&nbsp;&nbsp;
Floating-Point</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Model&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Library&nbsp;&nbsp;&nbsp;&nbsp; Library (80x87)
&nbsp;Library (f-p calls)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ----------&nbsp; ----------&nbsp; ---------------&nbsp; -------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; flat/small&nbsp; CLIB3R.LIB&nbsp;&nbsp;&nbsp; MATH387R.LIB&nbsp;&nbsp;&nbsp;&nbsp; MATH3R.LIB</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CLIB3S.LIB&nbsp;
&nbsp; MATH387S.LIB&nbsp;&nbsp;&nbsp;&nbsp; MATH3S.LIB</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PLIB3R.LIB&nbsp;
&nbsp; CPLX73R.LIB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CPLX3R.LIB</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PLIB3S.LIB&nbsp;
&nbsp; CPLX73S.LIB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CPLX3S.LIB</TT>
<BR><BR>The letter &quot;R&quot; or &quot;S&quot; which is affixed to the file name indicates the particular strategy with
which the modules in the library have been compiled.
<DL>
<DT>R
<DD>denotes a version of the Open Watcom C/C++ 32-bit libraries which have been compiled for the &quot;flat/small&quot; memory
models using the &quot;3r&quot;, &quot;4r&quot; or &quot;5r&quot; option.
<DT>S
<DD>denotes a version of the Open Watcom C/C++ 32-bit libraries which have been compiled for the &quot;flat/small&quot; memory
models using the &quot;3s&quot;, &quot;4s&quot; or &quot;5s&quot; option.
</DL>
<H2 ID="32Mbit_Memory_Layout"> 32-bit Memory Layout </H2>
<BR>The following describes the segment ordering of an application linked by the Open Watcom Linker.&nbsp; Note that this
assumes that the &quot;DOSSEG&quot; linker option has been specified.&nbsp; 
<OL>
<LI>all &quot;USE16&quot; segments.&nbsp; These segments are present in applications that execute in both real mode and protected
mode.&nbsp; They are first in the segment ordering so that the &quot;REALBREAK&quot; option of the &quot;RUNTIME&quot; directive
can be used to separate the real-mode part of the application from the protected-mode part of the application.&nbsp; Currently,
the &quot;RUNTIME&quot; directive is valid for Phar Lap executables only.
<LI>all segments not belonging to group &quot;DGROUP&quot; with class &quot;CODE&quot;
<LI>all other segments not belonging to group &quot;DGROUP&quot;
<LI>all segments belonging to group &quot;DGROUP&quot; with class &quot;BEGDATA&quot;
<LI>all segments belonging to group &quot;DGROUP&quot; not with class &quot;BEGDATA&quot;, &quot;BSS&quot; or &quot;STACK&quot;
<LI>all segments belonging to group &quot;DGROUP&quot; with class &quot;BSS&quot;
<LI>all segments belonging to group &quot;DGROUP&quot; with class &quot;STACK&quot;
</OL>
<BR>Segments belonging to class &quot;BSS&quot; contain uninitialized data.&nbsp; Note that this only includes uninitialized
data in segments belonging to group &quot;DGROUP&quot;.&nbsp; Segments belonging to class &quot;STACK&quot; are used to define
the size of the stack used for your application.&nbsp; Segments belonging to the classes &quot;BSS&quot; and &quot;STACK&quot;
are last in the segment ordering so that uninitialized data need not take space in the executable file.
<BR><BR>In addition to these special segments, the following conventions are used by Open Watcom C/C++.
<OL>
<LI>The &quot;CODE&quot; class contains the executable code for your application.&nbsp; In a small code model, this consists
of the segment &quot;_TEXT&quot;.&nbsp; In a big code model, this consists of the segments &quot;&lt;module&gt;_TEXT&quot;
where &lt;module&gt; is the file name of the source file.
<LI>The &quot;FAR_DATA&quot; class consists of the following:
<DL>
<DT>(a)
<DD>data objects whose size exceeds the data threshold in large data memory models (the data threshold is 32K unless changed using
the &quot;zt&quot; compiler option)
<DT>(b)
<DD>data objects defined using the &quot;FAR&quot; or &quot;HUGE&quot; keyword,
<DT>(c)
<DD>literals whose size exceeds the data threshold in large data memory models (the data threshold is 32K unless changed using
the &quot;zt&quot; compiler option)
<DT>(d)
<DD>literals defined using the &quot;FAR&quot; or &quot;HUGE&quot; keyword.
</DL>
</OL>
<BR>You can override the default naming convention used by Open Watcom C/C++ to name segments.
<OL>
<LI>The Open Watcom C/C++ &quot;nm&quot; option can be used to change the name of the module.&nbsp; This, in turn, changes
the name of the code segment when compiling for a big code model.
<LI>The Open Watcom C/C++ &quot;nt&quot; option can be used to specify the name of the code segment regardless of the code
model used.
</OL>
<H1 ID="32Mbit_Assembly_Language_Considerations"> 32-bit Assembly Language Considerations </H1>
<BR>This chapter will deal with the following topics.
<OL>
<LI>The data representation of the basic types supported by Open Watcom C/C++.
<LI>The memory layout of a Open Watcom C/C++ program.
<LI>The method for passing arguments and returning values.
<LI>The two methods for passing floating-point arguments and returning floating-point values.
<BR><BR>One method is used when one of the Open Watcom C/C++ &quot;fpi&quot; or &quot;fpi87&quot; options is specified for
the generation of in-line 80x87 instructions.&nbsp; When the &quot;fpi&quot; option is specified, an 80x87 emulator is included
from a math library if the application includes floating-point operations.&nbsp; When the &quot;fpi87&quot; option is used
exclusively, the 80x87 emulator will not be included.
<BR><BR>The other method is used when the Open Watcom C/C++ &quot;fpc&quot; option is specified.&nbsp; In this case, the compiler
generates calls to floating-point support routines in the alternate math libraries.
</OL>
<BR>An understanding of the Intel 80x86 architecture is assumed.
<H2 ID="32Mbit__Data_Representation"> 32-bit:&nbsp; Data Representation </H2>
<BR>This section describes the internal or machine representation of the basic types supported by Open Watcom C/C++.
<H3 ID="32Mbit__Type__char_"> 32-bit:&nbsp; Type &quot;char&quot; </H3>
<BR>An item of type &quot;char&quot; occupies 1 byte of storage.&nbsp; Its value is in the following range.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0 &lt;= n &lt;= 255</TT>
<BR><BR>Note that &quot;char&quot; is, by default, unsigned.&nbsp; The Open Watcom C/C++ compiler option &quot;j&quot; can
be used to change the default from unsigned to signed.&nbsp; If &quot;char&quot; is signed, an item of type &quot;char&quot;
is in the following range.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -128 &lt;= n &lt;= 127</TT>
<BR><BR>You can force an item of type &quot;char&quot; to be unsigned or signed regardless of the default by defining them
to be of type &quot;unsigned char&quot; or &quot;signed char&quot; respectively.
<H3 ID="32Mbit__Type__short_int_"> 32-bit:&nbsp; Type &quot;short int&quot; </H3>
<BR>An item of type &quot;short int&quot; occupies 2 bytes of storage.&nbsp; Its value is in the following range.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -32768 &lt;= n &lt;= 32767</TT>
<BR><BR>Note that &quot;short int&quot; is signed and hence &quot;short int&quot; and &quot;signed short int&quot; are equivalent.
&nbsp;If an item of type &quot;short int&quot; is to be unsigned, it must be defined as &quot;unsigned short int&quot;.&nbsp;
In this case, its value is in the following range.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0 &lt;= n &lt;= 65535</TT>
<H3 ID="32Mbit__Type__long_int_"> 32-bit:&nbsp; Type &quot;long int&quot; </H3>
<BR>An item of type &quot;long int&quot; occupies 4 bytes of storage.&nbsp; Its value is in the following range.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -2147483648 &lt;= n &lt;= 2147483647</TT>
<BR><BR>Note that &quot;long int&quot; is signed and hence &quot;long int&quot; and &quot;signed long int&quot; are equivalent.
&nbsp;If an item of type &quot;long int&quot; is to be unsigned, it must be defined as &quot;unsigned long int&quot;.&nbsp;
In this case, its value is in the following range.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0 &lt;= n &lt;= 4294967295</TT>
<H3 ID="32Mbit__Type__int_"> 32-bit:&nbsp; Type &quot;int&quot; </H3>
<BR>An item of type &quot;int&quot; occupies 4 bytes of storage.&nbsp; Its value is in the following range.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -2147483648 &lt;= n &lt;= 2147483647</TT>
<BR><BR>Note that &quot;int&quot; is signed and hence &quot;int&quot; and &quot;signed int&quot; are equivalent.&nbsp; If
an item of type &quot;int&quot; is to be unsigned, it must be defined as &quot;unsigned int&quot;.&nbsp; In this case its
value is in the following range.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0 &lt;= n &lt;= 4294967295</TT>
<BR><BR>If you are generating code that executes in 32-bit mode, &quot;long int&quot; and &quot;int&quot; are equivalent,
&quot;unsigned long int&quot; and &quot;unsigned int&quot; are equivalent, and &quot;signed long int&quot; and &quot;signed
int&quot; are equivalent.&nbsp; This may not be the case in other environments where &quot;int&quot; and &quot;short int&quot;
are 2 bytes.
<H3 ID="32Mbit__Type__float_"> 32-bit:&nbsp; Type &quot;float&quot; </H3>
<BR>A datum of type &quot;float&quot; is an approximate representation of a real number.&nbsp; Each datum of type &quot;float&quot;
occupies 4 bytes.&nbsp; If<TT> m</TT> is the magnitude of<TT> x</TT> (an item of type &quot;float&quot;) then<TT> x</TT> can
be approximated if
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -126&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 128</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;= m &lt;&nbsp; 2</TT>
<BR><BR>or in more approximate terms if
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 1.175494e-38 &lt;= m &lt;= 3.402823e38</TT>
<BR><BR>Data of type &quot;float&quot; are represented internally as follows.&nbsp; Note that bytes are stored in memory with
the least significant byte first and the most significant byte last.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +---+---------+---------------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; | S | Biased&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Significand&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; | Exponent|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +---+---------+---------------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 31&nbsp;&nbsp;&nbsp; 30-23&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
22-0</TT>
<DL>
<DT>Notes
<DD>
<DT>S
<DD>S = Sign bit (0=positive, 1=negative)
<DT>Exponent
<DD>The exponent bias is 127 (i.e., exponent value 1 represents 2**-126; exponent value 127 represents 2**0; exponent value 254
represents 2**127; etc.).&nbsp; The exponent field is 8 bits long.
<DT>Significand
<DD>The leading bit of the significand is always 1, hence it is not stored in the significand field.&nbsp; Thus the significand
is always &quot;normalized&quot;.&nbsp; The significand field is 23 bits long.
<DT>Zero
<DD>A real zero quantity occurs when the sign bit, exponent, and significand are all zero.
<DT>Infinity
<DD>When the exponent field is all 1 bits and the significand field is all zero bits then the quantity represents positive or
negative infinity, depending on the sign bit.
<DT>Not Numbers
<DD>When the exponent field is all 1 bits and the significand field is non-zero then the quantity is a special value called a
NAN (Not-A-Number).
<BR><BR>When the exponent field is all 0 bits and the significand field is non-zero then the quantity is a special value called
a &quot;denormal&quot; or nonnormal number.
</DL>
<H3 ID="32Mbit__Type__double_"> 32-bit:&nbsp; Type &quot;double&quot; </H3>
<BR>A datum of type &quot;double&quot; is an approximate representation of a real number.&nbsp; The precision of a datum of
type &quot;double&quot; is greater than or equal to one of type &quot;float&quot;.&nbsp; Each datum of type &quot;double&quot;
occupies 8 bytes.&nbsp; If<TT> m</TT> is the magnitude of<TT> x</TT> (an item of type &quot;double&quot;) then<TT> x</TT>
can be approximated if
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -1022&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1024</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;= m &lt;&nbsp; 2</TT>
<BR><BR>or in more approximate terms if
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 2.2250738585072e-308 &lt;= m &lt;= 1.79769313486232e308</TT>
<BR><BR>Data of type &quot;double&quot; are represented internally as follows.&nbsp; Note that bytes are stored in memory
with the least significant byte first and the most significant byte last.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +---+---------+--------------------------------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; | S | Biased&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;Significand&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; | Exponent|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; +---+---------+--------------------------------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 63&nbsp;&nbsp;&nbsp; 62-52&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 51-0</TT>
<DL>
<DT>Notes:
<DD>
<DT>S
<DD>S = Sign bit (0=positive, 1=negative)
<DT>Exponent
<DD>The exponent bias is 1023 (i.e., exponent value 1 represents 2**-1022; exponent value 1023 represents 2**0; exponent value
2046 represents 2**1023; etc.).&nbsp; The exponent field is 11 bits long.
<DT>Significand
<DD>The leading bit of the significand is always 1, hence it is not stored in the significand field.&nbsp; Thus the significand
is always &quot;normalized&quot;.&nbsp; The significand field is 52 bits long.
<DT>Zero
<DD>A double precision zero quantity occurs when the sign bit, exponent, and significand are all zero.
<DT>Infinity
<DD>When the exponent field is all 1 bits and the significand field is all zero bits then the quantity represents positive or
negative infinity, depending on the sign bit.
<DT>Not Numbers
<DD>When the exponent field is all 1 bits and the significand field is non-zero then the quantity is a special value called a
NAN (Not-A-Number).
<BR><BR>When the exponent field is all 0 bits and the significand field is non-zero then the quantity is a special value called
a &quot;denormal&quot; or nonnormal number.
</DL>
<H2 ID="32Mbit__Memory_Layout"> 32-bit:&nbsp; Memory Layout </H2>
<BR>The following describes the segment ordering of an application linked by the Open Watcom Linker.&nbsp; Note that this
assumes that the &quot;DOSSEG&quot; linker option has been specified.&nbsp; 
<OL>
<LI>all &quot;USE16&quot; segments.&nbsp; These segments are present in applications that execute in both real mode and protected
mode.&nbsp; They are first in the segment ordering so that the &quot;REALBREAK&quot; option of the &quot;RUNTIME&quot; directive
can be used to separate the real-mode part of the application from the protected-mode part of the application.&nbsp; Currently,
the &quot;RUNTIME&quot; directive is valid for Phar Lap executables only.
<LI>all segments not belonging to group &quot;DGROUP&quot; with class &quot;CODE&quot;
<LI>all other segments not belonging to group &quot;DGROUP&quot;
<LI>all segments belonging to group &quot;DGROUP&quot; with class &quot;BEGDATA&quot;
<LI>all segments belonging to group &quot;DGROUP&quot; not with class &quot;BEGDATA&quot;, &quot;BSS&quot; or &quot;STACK&quot;
<LI>all segments belonging to group &quot;DGROUP&quot; with class &quot;BSS&quot;
<LI>all segments belonging to group &quot;DGROUP&quot; with class &quot;STACK&quot;
</OL>
<BR>Segments belonging to class &quot;BSS&quot; contain uninitialized data.&nbsp; Note that this only includes uninitialized
data in segments belonging to group &quot;DGROUP&quot;.&nbsp; Segments belonging to class &quot;STACK&quot; are used to define
the size of the stack used for your application.&nbsp; Segments belonging to the classes &quot;BSS&quot; and &quot;STACK&quot;
are last in the segment ordering so that uninitialized data need not take space in the executable file.
<BR><BR>In addition to these special segments, the following conventions are used by Open Watcom C/C++.
<OL>
<LI>The &quot;CODE&quot; class contains the executable code for your application.&nbsp; In a small code model, this consists
of the segment &quot;_TEXT&quot;.&nbsp; In a big code model, this consists of the segments &quot;&lt;module&gt;_TEXT&quot;
where &lt;module&gt; is the file name of the source file.
<LI>The &quot;FAR_DATA&quot; class consists of the following:
<DL>
<DT>(a)
<DD>data objects whose size exceeds the data threshold in large data memory models (the data threshold is 32K unless changed using
the &quot;zt&quot; compiler option)
<DT>(b)
<DD>data objects defined using the &quot;FAR&quot; or &quot;HUGE&quot; keyword,
<DT>(c)
<DD>literals whose size exceeds the data threshold in large data memory models (the data threshold is 32K unless changed using
the &quot;zt&quot; compiler option)
<DT>(d)
<DD>literals defined using the &quot;FAR&quot; or &quot;HUGE&quot; keyword.
</DL>
</OL>
<BR>You can override the default naming convention used by Open Watcom C/C++ to name segments.
<OL>
<LI>The Open Watcom C/C++ &quot;nm&quot; option can be used to change the name of the module.&nbsp; This, in turn, changes
the name of the code segment when compiling for a big code model.
<LI>The Open Watcom C/C++ &quot;nt&quot; option can be used to specify the name of the code segment regardless of the code
model used.
</OL>
<H2 ID="32Mbit__Calling_Conventions_for_NonM80x87_Applications"> 32-bit:&nbsp; Calling Conventions for Non-80x87 Applications </H2>
<BR>The following sections describe the calling convention used when compiling with the &quot;fpc&quot; compiler option.
<H3 ID="32Mbit__Passing_Arguments_Using_RegisterMBased_Calling_Conventions"> 32-bit:&nbsp; Passing Arguments Using Register-Based Calling Conventions </H3>
<BR>How arguments are passed to a function with register-based calling conventions is determined by the size (in bytes) of
the argument and where in the argument list the argument appears.&nbsp; Depending on the size, arguments are either passed
in registers or on the stack.&nbsp; Arguments such as structures are almost always passed on the stack since they are generally
too large to fit in registers.&nbsp; Since arguments are processed from left to right, the first few arguments are likely
to be passed in registers (if they can fit) and, if the argument list contains many arguments, the last few arguments are
likely to be passed on the stack.
<BR><BR>The registers used to pass arguments to a function are EAX, EBX, ECX and EDX.&nbsp; The following algorithm describes
how arguments are passed to functions.
<BR><BR>Initially, we have the following registers available for passing arguments:&nbsp; EAX, EDX, EBX and ECX.&nbsp; Note
that registers are selected from this list in the order they appear.&nbsp; That is, the first register selected is EAX and
the last is ECX.&nbsp; For each argument<B> Ai,</B> starting with the left most argument, perform the following steps.
<OL>
<LI>If the size of<B> Ai</B> is 1 byte or 2 bytes, convert it to 4 bytes and proceed to the next step.&nbsp; If<B> Ai</B>
is of type &quot;unsigned char&quot; or &quot;unsigned short int&quot;, it is converted to an &quot;unsigned int&quot;.&nbsp;
If<B> Ai</B> is of type &quot;signed char&quot; or &quot;signed short int&quot;, it is converted to a &quot;signed int&quot;.
&nbsp;If<B> Ai</B> is a 1-byte or 2-byte structure, the padding is determined by the compiler.
<LI>If an argument has already been assigned a position on the stack,<B> Ai</B> will also be assigned a position on the stack.
&nbsp;Otherwise, proceed to the next step.
<LI>If the size of<B> Ai</B> is 4 bytes, select a register from the list of available registers.&nbsp; If a register is available,<B>
Ai</B> is assigned that register.&nbsp; The register is then removed from the list of available registers.&nbsp; If no registers
are available,<B> Ai</B> will be assigned a position on the stack.
<LI>If the type of<B> Ai</B> is &quot;far pointer&quot;, select a register pair from the following list of combinations:&nbsp;
[EDX EAX] or [ECX EBX].&nbsp; The first available register pair is assigned to<B> Ai</B> and removed from the list of available
pairs.&nbsp; The segment value will actually be passed in register DX or CX and the offset in register EAX or EBX.&nbsp; If
none of the above register pairs is available,<B> Ai</B> will be assigned a position on the stack.&nbsp; Note that 8 bytes
will be pushed on the stack even though the size of an item of type &quot;far pointer&quot; is 6 bytes.
<LI>If the type of<B> Ai</B> is &quot;double&quot; or &quot;float&quot; (in the absence of a function prototype), select a
register pair from the following list of combinations:&nbsp; [EDX EAX] or [ECX EBX].&nbsp; The first available register pair
is assigned to<B> Ai</B> and removed from the list of available pairs.&nbsp; The high-order 32 bits of the argument are assigned
to the first register in the pair; the low-order 32 bits are assigned to the second register in the pair.&nbsp; If none of
the above register pairs is available,<B> Ai</B> will be assigned a position on the stack.
<LI>All other arguments will be assigned a position on the stack.
</OL>
<BR><B>Notes:</B>
<OL>
<LI>Arguments that are assigned a position on the stack are padded to a multiple of 4 bytes.&nbsp; That is, if a 3-byte structure
is assigned a position on the stack, 4 bytes will be pushed on the stack.
<LI>Arguments that are assigned a position on the stack are pushed onto the stack starting with the rightmost argument.
</OL>
<H3 ID="32Mbit__Sizes_of_Predefined_Types"> 32-bit:&nbsp; Sizes of Predefined Types </H3>
<BR>The following table lists the predefined types, their size as returned by the &quot;sizeof&quot; function, the size of
an argument of that type and the registers used to pass that argument if it was the only argument in the argument list.&nbsp;

<BR><BR><B>&nbsp;&nbsp;&nbsp; Basic</B>
<BR><B>Type&nbsp;&nbsp;&nbsp; &quot;sizeof&quot;&nbsp;&nbsp;&nbsp; Argument&nbsp; Registers</B>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Used</B>
<BR>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; [EAX]
<BR>&nbsp;&nbsp;&nbsp; short int 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [EAX]
<BR>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; [EAX]
<BR>&nbsp;&nbsp;&nbsp; long int&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [EAX]
<BR>&nbsp;&nbsp;&nbsp; float&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;[EDX EAX]
<BR>&nbsp;&nbsp;&nbsp; double&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[EDX EAX]
<BR>&nbsp;&nbsp;&nbsp; near
<BR>pointer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[EAX]
<BR>&nbsp;&nbsp;&nbsp; far
<BR>pointer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[EDX EAX]
<BR><B>Note that the size of the argument listed in the table assumes that no function prototypes are specified.</B>&nbsp;
Function prototypes affect the way arguments are passed.&nbsp; This will be discussed in the section entitled &quot;Effect
of Function Prototypes on Arguments&quot;.
<BR><BR><B>Notes:</B>
<OL>
<LI>Provided no function prototypes exist, an argument will be converted to a default type as described in the following table.
<DL>
<DT>Argument Type
<DD>Passed As
<DT>char
<DD>unsigned int
<DT>signed char
<DD>signed int
<DT>unsigned char
<DD>unsigned int
<DT>short
<DD>unsigned int
<DT>signed short
<DD>signed int
<DT>unsigned short
<DD>unsigned int
<DT>float
<DD>double
</DL>
</OL>
<H3 ID="32Mbit__Size_of_Enumerated_Types"> 32-bit:&nbsp; Size of Enumerated Types </H3>
<BR>The integral type of an enumerated type is determined by the values of the enumeration constants.&nbsp; In strict ISO/ANSI
C mode, all enumerated constants are of type<TT> int.</TT>&nbsp; In the extensions mode, the compiler will use the smallest
integral type possible (excluding<TT> long</TT> ints) that can represent all values of the enumerated type.&nbsp; For instance,
if the minimum and maximum values of the enumeration constants are in the range -128 and 127, the enumerated type will be
equivalent to a<TT> signed char</TT> (size = 1 byte).&nbsp; All references to enumerated constants in the previous instance
will have type<TT> signed char.</TT>&nbsp; An enumerated constant is always promoted to an<TT> int</TT> when passed as an
argument.
<H3 ID="32Mbit__Effect_of_Function_Prototypes_on_Arguments"> 32-bit:&nbsp; Effect of Function Prototypes on Arguments </H3>
<BR>Function prototypes define the types of the formal parameters of a function.&nbsp; Their appearance affects the way in
which arguments are passed.&nbsp; An argument will be converted to the type of the corresponding formal parameter in the function
prototype.&nbsp; Consider the following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void prototype( float x, int i );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float x;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = 3.14;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = 314;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prototype( x, i );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rtn( x, i );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The function prototype for<TT> prototype</TT> specifies that the first argument is to be passed as a &quot;float&quot;
and the second argument is to be passed as an &quot;int&quot;.&nbsp; This results in the first argument being passed in register
EAX and the second argument being passed in register EDX.
<BR><BR>If no function prototype is given, as is the case for the function<TT> rtn,</TT> the first argument will be passed
as a &quot;double&quot; and the second argument would be passed as an &quot;int&quot;.&nbsp; This results in the first argument
being passed in registers EDX and EAX and the second argument being passed in register EBX.
<BR><BR>Note that even though both<TT> prototype</TT> and<TT> rtn</TT> were called with identical argument lists, the way
in which the arguments were passed was completely different simply because a function prototype for<TT> prototype</TT> was
specified.&nbsp; Function prototyping is an excellent way to guarantee that arguments will be passed as expected to your assembly
language function.
<H3 ID="32Mbit__Interfacing_to_Assembly_Language_Functions"> 32-bit:&nbsp; Interfacing to Assembly Language Functions </H3>
<BR>Consider the following example.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double&nbsp;&nbsp; x;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double&nbsp;&nbsp; y;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = 7;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = 77;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y = 777;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myrtn( x, i, y );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>myrtn</TT> is an assembly language function that requires three arguments.&nbsp; The first argument is of type
&quot;double&quot;, the second argument is of type &quot;int&quot; and the third argument is again of type &quot;double&quot;.
&nbsp;Using the rules for register-based calling conventions, these arguments will be passed to<TT> myrtn</TT> in the following
way:
<OL>
<LI>The first argument will be passed in registers EDX and EAX leaving EBX and ECX as available registers for other arguments.
<LI>The second argument will be passed in register EBX leaving ECX as an available register for other arguments.
<LI>The third argument will not fit in register ECX (its size is 8 bytes) and hence will be pushed on the stack.
</OL>
<BR>Let us look at the stack upon entry to<TT> myrtn.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp; Small Code Model</B>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Offset</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; | return address | &lt;- ESP points here</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp; | argument #3&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 12&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp; Big Code Model</B>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Offset</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; | return address | &lt;- ESP points here</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp;&nbsp;&nbsp; | argument #3&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><BR><B>Notes:</B>
<OL>
<LI>The return address is the top element on the stack.&nbsp; In a small code model, the return address is 1 double word (32
bits); in a big code model, the return address is 2 double words (64 bits).
</OL>
<BR>Register EBP is normally used to address arguments on the stack.&nbsp; Upon entry to the function, register EBP is set
to point to the stack but before doing so we must save its contents.&nbsp; The following two instructions achieve this.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; EBP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;
save current value of EBP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; EBP,ESP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; get access to arguments</TT>
<BR><BR>After executing these instructions, the stack looks like this.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp; Small Code Model</B>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Offset</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; | saved EBP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | &lt;- EBP
and ESP point here</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp; | return address |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp;&nbsp;&nbsp; | argument #3&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp; Big Code Model</B>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Offset</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; | saved EBP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | &lt;- EBP
and ESP point here</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp; | return address |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 12&nbsp;&nbsp;&nbsp;&nbsp; | argument #3&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 20&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><BR>As the above diagrams show, the third argument is at offset 8 from register EBP in a small code model and offset 12
in a big code model.
<BR><BR>Upon exit from<TT> myrtn,</TT> we must restore the value of EBP.&nbsp; The following two instructions achieve this.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ESP,EBP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; restore stack pointer</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;&nbsp;&nbsp; EBP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; restore EBP</TT>
<BR><BR>The following is a sample assembly language function which implements<TT> myrtn.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp; Small Memory Model (small code, small data)</B>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DGROUP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; group&nbsp;&nbsp; _DATA, _BSS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; segment byte public 'CODE'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assume
&nbsp;CS:_TEXT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assume
&nbsp;DS:DGROUP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public
&nbsp;myrtn_</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; myrtn_&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; proc&nbsp;&nbsp;&nbsp; near</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push
&nbsp;&nbsp; EBP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; save
EBP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;
&nbsp;&nbsp; EBP,ESP&nbsp;&nbsp; ; get access to arguments</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ; body of function</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;
&nbsp;&nbsp; ESP,EBP&nbsp;&nbsp; ; restore ESP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;
&nbsp;&nbsp; EBP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; restore
EBP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret&nbsp;
&nbsp;&nbsp; 8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; return and pop last arg</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; myrtn_&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ends</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp; Large Memory Model (big code, big data)</B>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DGROUP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; group&nbsp;&nbsp; _DATA, _BSS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; MYRTN_TEXT segment byte public 'CODE'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assume
&nbsp;CS:MYRTN_TEXT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public
&nbsp;myrtn_</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; myrtn_&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; proc&nbsp;&nbsp;&nbsp; far</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push
&nbsp;&nbsp; EBP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; save
EBP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;
&nbsp;&nbsp; EBP,ESP&nbsp;&nbsp; ; get access to arguments</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ; body of function</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;
&nbsp;&nbsp; ESP,EBP&nbsp;&nbsp; ; restore ESP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;
&nbsp;&nbsp; EBP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; restore
EBP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret&nbsp;
&nbsp;&nbsp; 8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; return and pop last arg</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; myrtn_&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; MYRTN_TEXT ends</TT>
<BR><BR><B>Notes:</B>
<OL>
<LI>Global function names must be followed with an underscore.&nbsp; Global variable names must be preceded with an underscore.
<LI>All used 80x86 registers must be saved on entry and restored on exit except those used to pass arguments and return values,
and AX, which is considered a stratch register.&nbsp; Note that segment registers only have to saved and restored if you are
compiling your application with the &quot;r&quot; option.
<LI>The direction flag must be clear before returning to the caller.
<LI>In a small code model, any segment containing executable code must belong to the segment &quot;_TEXT&quot; and the class
&quot;CODE&quot;.&nbsp; The segment &quot;_TEXT&quot; must have a &quot;combine&quot; type of &quot;PUBLIC&quot;.&nbsp; On
entry, CS contains the segment address of the segment &quot;_TEXT&quot;.&nbsp; In a big code model there is no restriction
on the naming of segments which contain executable code.
<LI>In a small data model, segment register DS contains the segment address of the group &quot;DGROUP&quot;.&nbsp; This is
not the case in a big data model.
<LI>When writing assembly language functions for the small code model, you must declare them as &quot;near&quot;.&nbsp; If
you wish to write assembly language functions for the big code model, you must declare them as &quot;far&quot;.
<LI>In general, when naming segments for your code or data, you should follow the conventions described in the section entitled
&quot;Memory Layout&quot; in this chapter.
<LI>If any of the arguments was pushed onto the stack, the called routine must pop those arguments off the stack in the &quot;ret&quot;
instruction.
</OL>
<H3 ID="32Mbit__Using_StackMBased_Calling_Conventions"> 32-bit:&nbsp; Using Stack-Based Calling Conventions </H3>
<BR>Let us now consider the example in the previous section except this time we will use the stack-based calling convention.
&nbsp;The most significant difference between the stack-based calling convention and the register-based calling convention
is the way the arguments are passed.&nbsp; When using the stack-based calling conventions, no registers are used to pass arguments.
&nbsp;Instead, all arguments are passed on the stack.
<BR><BR>Let us look at the stack upon entry to<TT> myrtn.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp; Small Code Model</B>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Offset</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; | return address | &lt;- ESP points here</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp; | argument #1&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 12&nbsp;&nbsp;&nbsp;&nbsp; | argument #2&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16&nbsp;&nbsp;&nbsp;&nbsp; | argument #3&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 24&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp; Big Code Model</B>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Offset</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; | return address | &lt;- ESP points here</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp;&nbsp;&nbsp; | argument #1&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16&nbsp;&nbsp;&nbsp;&nbsp; | argument #2&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 20&nbsp;&nbsp;&nbsp;&nbsp; | argument #3&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 28&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><BR><B>Notes:</B>
<OL>
<LI>The return address is the top element on the stack.&nbsp; In a small code model, the return address is 1 double word (32
bits); in a big code model, the return address is 2 double words (64 bits).
</OL>
<BR>Register EBP is normally used to address arguments on the stack.&nbsp; Upon entry to the function, register EBP is set
to point to the stack but before doing so we must save its contents.&nbsp; The following two instructions achieve this.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; EBP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;
save current value of EBP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; EBP,ESP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; get access to arguments</TT>
<BR><BR>After executing these instructions, the stack looks like this.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp; Small Code Model</B>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Offset</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; | saved EBP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | &lt;- EBP
and ESP point here</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp; | return address |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp;&nbsp;&nbsp; | argument #1&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16&nbsp;&nbsp;&nbsp;&nbsp; | argument #2&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 20&nbsp;&nbsp;&nbsp;&nbsp; | argument #3&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 28&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp; Big Code Model</B>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Offset</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; | saved EBP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | &lt;- EBP
and ESP point here</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp; | return address |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 12&nbsp;&nbsp;&nbsp;&nbsp; | argument #1&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 20&nbsp;&nbsp;&nbsp;&nbsp; | argument #2&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 24&nbsp;&nbsp;&nbsp;&nbsp; | argument #3&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</TT>
<BR><BR>As the above diagrams show, the argument are all on the stack and are referenced by specifying an offset from register
EBP.
<BR><BR>Upon exit from<TT> myrtn,</TT> we must restore the value of EBP.&nbsp; The following two instructions achieve this.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ESP,EBP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; restore stack pointer</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;&nbsp;&nbsp; EBP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; restore EBP</TT>
<BR><BR>The following is a sample assembly language function which implements<TT> myrtn.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp; Small Memory Model (small code, small data)</B>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DGROUP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; group&nbsp;&nbsp; _DATA, _BSS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; segment byte public 'CODE'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assume
&nbsp;CS:_TEXT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assume
&nbsp;DS:DGROUP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public
&nbsp;myrtn</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; myrtn&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; proc&nbsp;&nbsp;&nbsp; near</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push
&nbsp;&nbsp; EBP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; save
EBP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;
&nbsp;&nbsp; EBP,ESP&nbsp;&nbsp; ; get access to arguments</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ; body of function</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;
&nbsp;&nbsp; ESP,EBP&nbsp;&nbsp; ; restore ESP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;
&nbsp;&nbsp; EBP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; restore
EBP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret&nbsp;
&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; return</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; myrtn&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ends</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp; Large Memory Model (big code, big data)</B>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; DGROUP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; group&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _DATA, _BSS</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; MYRTN_TEXT segment byte public 'CODE'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assume
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CS:MYRTN_TEXT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myrtn</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; myrtn&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; proc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; far</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EBP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; save
EBP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EBP,ESP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; get
access to arguments</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ; body of function</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ESP,EBP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; restore
ESP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EBP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; restore
EBP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret&nbsp;
&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; return</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; myrtn&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; MYRTN_TEXT ends</TT>
<BR><BR><B>Notes:</B>
<OL>
<LI>Global function names must not be followed with an underscore as was the case with the register-based calling convention.
&nbsp;Global variable names must not be preceded with an underscore as was the case with the register-based calling convention.
<LI>All used 80x86 registers except registers EAX, ECX and EDX must be saved on entry and restored on exit.&nbsp; Segment
registers DS and ES must also be saved on entry and restored on exit.&nbsp; Segment register ES does not have to be saved
and restored when using a memory model that is not a small data model.&nbsp; Note that segment registers only have to be saved
and restored if you are compiling your application with the &quot;r&quot; option.
<LI>The direction flag must be clear before returning to the caller.
<LI>In a small code model, any segment containing executable code must belong to the segment &quot;_TEXT&quot; and the class
&quot;CODE&quot;.&nbsp; The segment &quot;_TEXT&quot; must have a &quot;combine&quot; type of &quot;PUBLIC&quot;.&nbsp; On
entry, CS contains the segment address of the segment &quot;_TEXT&quot;.&nbsp; In a big code model there is no restriction
on the naming of segments which contain executable code.
<LI>In a small data model, segment register DS contains the segment address of the group &quot;DGROUP&quot;.&nbsp; This is
not the case in a big data model.
<LI>When writing assembly language functions for the small code model, you must declare them as &quot;near&quot;.&nbsp; If
you wish to write assembly language functions for the big code model, you must declare them as &quot;far&quot;.
<LI>In general, when naming segments for your code or data, you should follow the conventions described in the section entitled
&quot;Memory Layout&quot; in this chapter.
<LI>The caller is responsible for removing arguments from the stack.
</OL>
<H3 ID="32Mbit__Functions_with_Variable_Number_of_Arguments"> 32-bit:&nbsp; Functions with Variable Number of Arguments </H3>
<BR>A function prototype with a parameter list that ends with &quot;,...&quot; has a variable number of arguments.&nbsp; In
this case, all arguments are passed on the stack.&nbsp; Since no prototyping information exists for arguments represented
by &quot;,...&quot;, those arguments are passed as described in the section &quot;Passing Arguments&quot;.
<H3 ID="32Mbit__Returning_Values_from_Functions"> 32-bit:&nbsp; Returning Values from Functions </H3>
<BR>The way in which function values are returned depends on the size of the return value.&nbsp; The following examples describe
how function values are to be returned.&nbsp; They are coded for a small code model.&nbsp; 
<OL>
<LI>1-byte values are to be returned in register AL.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXT&nbsp;&nbsp; segment byte public 'CODE'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assume&nbsp; CS:_TEXT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public&nbsp; Ret1_</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Ret1_&nbsp;&nbsp; proc&nbsp;&nbsp;&nbsp; near&nbsp;&nbsp; ; char Ret1()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; AL,'G'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Ret1_&nbsp;&nbsp; endp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXT&nbsp;&nbsp; ends</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<LI>2-byte values are to be returned in register AX.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXT&nbsp;&nbsp; segment byte public 'CODE'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assume&nbsp; CS:_TEXT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public&nbsp; Ret2_</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Ret2_&nbsp;&nbsp; proc&nbsp;&nbsp;&nbsp; near&nbsp;&nbsp; ; short int Ret2()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; AX,77</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Ret2_&nbsp;&nbsp; endp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXT&nbsp;&nbsp; ends</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<LI>4-byte values are to be returned in register EAX.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXT&nbsp;&nbsp; segment byte public 'CODE'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assume&nbsp; CS:_TEXT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public&nbsp; Ret4_</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Ret4_&nbsp;&nbsp; proc&nbsp;&nbsp;&nbsp; near&nbsp;&nbsp; ; int Ret4()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; EAX,7777777</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Ret4_&nbsp;&nbsp; endp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXT&nbsp;&nbsp; ends</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<LI>8-byte values, except structures, are to be returned in registers EDX and EAX.&nbsp; When using the &quot;fpc&quot; (floating-point
calls) option, &quot;float&quot; and &quot;double&quot; are returned in registers.&nbsp; See section &quot;Returning Values
in 80x87-based Applications&quot; when using the &quot;fpi&quot; or &quot;fpi87&quot; options.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .8087</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXT&nbsp;&nbsp; segment byte public 'CODE'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assume&nbsp; CS:_TEXT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public&nbsp; Ret8_</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Ret8_&nbsp;&nbsp; proc&nbsp;&nbsp;&nbsp; near&nbsp;&nbsp; ; double Ret8()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; EDX,dword ptr
CS:Val8+4</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; EAX,dword ptr
CS:Val8</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Val8:&nbsp;&nbsp; dq&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7.7</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Ret8_&nbsp;&nbsp; endp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXT&nbsp;&nbsp; ends</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>The &quot;.8087&quot; pseudo-op must be specified so that all floating-point constants are generated in 8087 format.
<LI>Otherwise, the caller allocates space on the stack for the return value and sets register ESI to point to this area.&nbsp;
In a big data model, register ESI contains an offset relative to the segment value in segment register SS.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXT&nbsp;&nbsp; segment byte public 'CODE'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assume&nbsp; CS:_TEXT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public&nbsp; RetX_</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ; struct int_values {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;&nbsp;&nbsp;&nbsp;&nbsp; int value1, value2, value3, value4, value5;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; RetX_&nbsp;&nbsp; proc&nbsp;&nbsp;&nbsp; near ; struct int_values RetX()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; dword ptr SS:0[ESI],71</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; dword ptr SS:4[ESI],72</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; dword ptr SS:8[ESI],73</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; dword ptr SS:12[ESI],74</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; dword ptr SS:16[ESI],75</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; RetX_&nbsp;&nbsp; endp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXT&nbsp;&nbsp; ends</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR>When returning values on the stack, remember to use a segment override to the stack segment (SS).
</OL>
<BR>The following is an example of a Open Watcom C/C++ program calling the above assembly language subprograms.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct int_values {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int value1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int value2;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int value3;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int value4;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int value5;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;Ret1(void);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern&nbsp; short int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ret2(void);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern&nbsp; long int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ret4(void);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern&nbsp; double&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ret8(void);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern&nbsp; struct int_values RetX(void);</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct int_values x;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Ret1 = %c\n&quot;, Ret1() );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Ret2 = %d\n&quot;, Ret2() );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Ret4 = %ld\n&quot;, Ret4() );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Ret8 = %f\n&quot;, Ret8() );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = RetX();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;RetX1 = %d\n&quot;, x.value1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;RetX2 = %d\n&quot;, x.value2 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;RetX3 = %d\n&quot;, x.value3 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;RetX4 = %d\n&quot;, x.value4 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;RetX5 = %d\n&quot;, x.value5 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The above function should be compiled for a small code model (use the &quot;mf&quot;, &quot;ms&quot; or &quot;mc&quot;
compiler option).
<HR>
<BR><B><I>&nbsp; Note:</I></B>&nbsp; Returning values from functions in the stack-based calling convention is the same as
returning values from functions in the register-based calling convention when using the &quot;fpc&quot; option.
<HR>
<H2 ID="32Mbit__Calling_Conventions_for_80x87Mbased_Applications"> 32-bit:&nbsp; Calling Conventions for 80x87-based Applications </H2>
<BR>When a source file is compiled by Open Watcom C/C++ with one of the &quot;fpi&quot; or &quot;fpi87&quot; options, all
floating-point arguments are passed on the 80x86 stack.&nbsp; The rules for passing arguments are as follows.
<OL>
<LI>If the argument is not floating-point, use the procedure described earlier in this chapter.
<LI>If the argument is floating-point, it is assigned a position on the 80x86 stack.
</OL>
<HR>
<BR><B><I>&nbsp; Note:</I></B>&nbsp; When compiling using the &quot;fpi&quot; or &quot;fpi87&quot; options, the method used
for passing floating-point arguments in the stack-based calling convention is identical to the method used in the register-based
calling convention.&nbsp; However, when compiling using the &quot;fpi&quot; or &quot;fpi87&quot; options, the method used
for returning floating-point values in the stack-based calling convention is different from the method used in the register-based
calling convention.&nbsp; The register-based calling convention returns floating-point values in ST(0), whereas the stack-based
calling convention returns floating-point values in EDX and EAX.
<HR>
<H3 ID="32Mbit__Passing_Values_in_80x87Mbased_Applications"> 32-bit:&nbsp; Passing Values in 80x87-based Applications </H3>
<BR>Consider the following example.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern&nbsp; void&nbsp;&nbsp;&nbsp; myrtn(int,float,double,long int);</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float&nbsp;&nbsp;&nbsp; x;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double&nbsp;&nbsp; y;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long int j;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = 7.7;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = 7;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y = 77.77</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j = 77;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myrtn( i, x, y, j );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>myrtn</TT> is an assembly language function that requires four arguments.&nbsp; The first argument is of type
&quot;int&quot; ( 4 bytes), the second argument is of type &quot;float&quot; (4 bytes), the third argument is of type &quot;double&quot;
(8 bytes) and the fourth argument is of type &quot;long int&quot; (4 bytes).
<BR><BR>When using the stack-based calling conventions, all of the arguments will be passed on the stack.&nbsp; When using
the register-based calling conventions, the above arguments will be passed to<TT> myrtn</TT> in the following way:
<OL>
<LI>The first argument will be passed in register EAX leaving EBX, ECX and EDX as available registers for other arguments.
<LI>The second argument will be passed on the 80x86 stack since it is a floating-point argument.
<LI>The third argument will also be passed on the 80x86 stack since it is a floating-point argument.
<LI>The fourth argument will be passed on the 80x86 stack since a previous argument has been assigned a position on the 80x86
stack.
</OL>
<BR>Remember, arguments are pushed on the stack from right to left.&nbsp; That is, the rightmost argument is pushed first.
<BR><BR>Any assembly language function must obey the following rule.
<OL>
<LI>All arguments passed on the stack must be removed by the called function.
</OL>
<BR>The following is a sample assembly language function which implements<TT> myrtn.</TT>
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .8087</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXT&nbsp;&nbsp; segment byte public 'CODE'</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assume&nbsp; CS:_TEXT</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public&nbsp; myrtn_</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; myrtn_&nbsp; proc&nbsp;&nbsp;&nbsp; near</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ; body of function</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret 16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; ; return and pop arguments</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; myrtn_&nbsp; endp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _TEXT&nbsp;&nbsp; ends</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
<BR><BR><B>Notes:</B>
<OL>
<LI>Function names must be followed by an underscore.
<LI>All used 80x86 registers must be saved on entry and restored on exit except those used to pass arguments and return values,
and EAX, which is considered a stratch register.&nbsp; Note that segment registers only have to saved and restored if you
are compiling your application with the &quot;r&quot; option.&nbsp; In this example, EAX does not have to be saved as it was
used to pass the first argument.&nbsp; Floating-point registers can be modified without saving their contents.
<LI>The direction flag must be clear before returning to the caller.
<LI>This function has been written for a small code model.&nbsp; Any segment containing executable code must belong to the
class &quot;CODE&quot; and the segment &quot;_TEXT&quot;.&nbsp; On entry, CS contains the segment address of the segment &quot;_TEXT&quot;.
&nbsp;The above restrictions do not apply in a big code memory model.
<LI>When writing assembly language functions for a small code model, you must declare them as &quot;near&quot;.&nbsp; If you
wish to write assembly language functions for a big code model, you must declare them as &quot;far&quot;.
</OL>
<H3 ID="32Mbit__Returning_Values_in_80x87Mbased_Applications"> 32-bit:&nbsp; Returning Values in 80x87-based Applications </H3>
<BR>When using the stack-based calling conventions with &quot;fpi&quot; or &quot;fpi87&quot;, floating-point values are returned
in registers.&nbsp; Single precision values are returned in EAX, and double precision values are returned in EDX:EAX.
<BR><BR>When using the register-based calling conventions with &quot;fpi&quot; or &quot;fpi87&quot;, floating-point values
are returned in ST(0).&nbsp; All other values are returned in the manner described earlier in this chapter.
<H1 ID="32Mbit_Pragmas"> 32-bit Pragmas </H1>
<BR>A pragma is a compiler directive that provides the following capabilities.
<UL>
<LI>Pragmas allow you to specify certain compiler options.
<LI>Pragmas can be used to direct the Open Watcom C/C++ code generator to emit specialized sequences of code for calling functions
which use argument passing and value return techniques that differ from the default used by Open Watcom C/C++.
<LI>Pragmas can be used to describe attributes of functions (such as side effects) that are not possible at the C/C++ language
level.&nbsp; The code generator can use this information to generate more efficient code.
<LI>Any sequence of in-line machine language instructions, including DOS and BIOS function calls, can be generated in the
object code.
</UL>
<BR>Pragmas are specified in the source file using the<B><I> pragma</I></B> directive.&nbsp; A pragma operator of the form,<B><I>
_Pragma</I></B> ( string-literal ) is an alternative method of specifying<B><I> pragma</I></B> directives.
<BR><BR>For example, the following two statements are equivalent.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _Pragma( &quot;library (\&quot;kernel32.lib\&quot;)&quot; )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma library (&quot;kernel32.lib&quot;)</TT>
<BR><BR>The<B><I> _Pragma</I></B> operator can be used in macro definition.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; # define LIBRARY(X) PRAGMA(library (#X))</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; # define PRAGMA(X) _Pragma(#X)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; LIBRARY(kernel32.lib)&nbsp; // same as #pragma library (&quot;kernel32.lib&quot;)</TT>
<BR><BR>The following notation is used to describe the syntax of pragmas.
<DL>
<DT>keywords
<DD>A<TT> keyword</TT> is shown in a mono-spaced courier font.
<DT>program-item
<DD>A<B><I> program-item</I></B> is shown in a roman bold-italics font.&nbsp; A<B><I> program-item</I></B> is a symbol name or
numeric value supplied by the programmer.
<DT>punctuation
<DD>A<TT> punctuation character</TT> shown in a mono-spaced courier font must be entered as is.
<BR><BR>A<B><I> punctuation character</I></B> shown in a roman bold-italics font is used to describe syntax.&nbsp; The following
syntactical notation is used.
<DL>
<DT>[abc]
<DD>The item<B> abc</B> is optional.
<DT>{abc}
<DD>The item<B> abc</B> may be repeated zero or more times.
<DT>a|b|c
<DD>One of<B> a, b</B> or<B> c</B> may be specified.
<DT>a ::= b
<DD>The item<B> a</B> is defined in terms of<B> b.</B>
<DT>(a)
<DD>Item<B> a</B> is evaluated first.
</DL>
</DL>
<BR>The following classes of pragmas are supported.
<UL>
<LI>pragmas that specify options
<LI>pragmas that specify default libraries
<LI>pragmas that describe the way structures are stored in memory
<LI>pragmas that provide auxiliary information used for code generation
</UL>
<H2 ID="32Mbit__Using_Pragmas_to_Specify_Options"> 32-bit:&nbsp; Using Pragmas to Specify Options </H2>
<BR>Currently, the following options can be specified with pragmas:&nbsp; 
<DL>
<DT>unreferenced
<DD>The &quot;unreferenced&quot; option controls the way Open Watcom C/C++ handles unused symbols.&nbsp; For example,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma on (unreferenced);</TT>
<BR><BR>will cause Open Watcom C/C++ to issue warning messages for all unused symbols.&nbsp; This is the default.&nbsp; Specifying
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma off (unreferenced);</TT>
<BR><BR>will cause Open Watcom C/C++ to ignore unused symbols.&nbsp; Note that if the warning level is not high enough, warning
messages for unused symbols will not be issued even if &quot;unreferenced&quot; was specified.
<DT>check_stack
<DD>The &quot;check_stack&quot; option controls the way stack overflows are to be handled.&nbsp; For example,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma on (check_stack);</TT>
<BR><BR>will cause stack overflows to be detected and
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma off (check_stack);</TT>
<BR><BR>will cause stack overflows to be ignored.&nbsp; When &quot;check_stack&quot; is on, Open Watcom C/C++ will generate
a run-time call to a stack-checking routine at the start of every routine compiled.&nbsp; This run-time routine will issue
an error if a stack overflow occurs when invoking the routine.&nbsp; The default is to check for stack overflows.&nbsp; Stack
overflow checking is particularly useful when functions are invoked recursively.&nbsp; Note that if the stack overflows and
stack checking has been suppressed, unpredictable results can occur.
<BR><BR>If a stack overflow does occur during execution and you are sure that your program is not in error (i.e.&nbsp; it
is not unnecessarily recursing), you must increase the stack size.&nbsp; This is done by linking your application again and
specifying the &quot;STACK&quot; option to the Open Watcom Linker with a larger stack size.
<BR><BR>It is also possible to specify more than one option in a pragma as illustrated by the following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma on (check_stack unreferenced);</TT>
<DT>reuse_duplicate_strings (C only)
<DD>(C Only) The &quot;reuse_duplicate_strings&quot; option controls the way Open Watcom C handles identical strings in an expression.
&nbsp;For example,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma on (reuse_duplicate_strings);</TT>
<BR><BR>will cause Open Watcom C to reuse identical strings in an expression.&nbsp; This is the default.&nbsp; Specifying
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma off (reuse_duplicate_strings);</TT>
<BR><BR>will cause Open Watcom C to generate additional copies of the identical string.&nbsp; The following example shows
where this may be of importance to the way the application behaves.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma off (reuse_duplicate_strings)</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void poke( char *, char * );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; poke( &quot;Hello world\n&quot;, &quot;Hello world\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void poke( char *x, char *y )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x[3] = 'X';</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( x );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y[4] = 'Y';</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( y );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; /*</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Default output:</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; HelXo world</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; HelXY world</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
</DL>
<H2 ID="32Mbit__Using_Pragmas_to_Specify_Default_Libraries"> 32-bit:&nbsp; Using Pragmas to Specify Default Libraries </H2>
<BR>Default libraries are specified in special object module records.&nbsp; Library names are extracted from these special
records by the Open Watcom Linker.&nbsp; When unresolved references remain after processing all object modules specified in
linker &quot;FILE&quot; directives, these default libraries are searched after all libraries specified in linker &quot;LIBRARY&quot;
directives have been searched.
<BR><BR>By default, that is if no library pragma is specified, the Open Watcom C/C++ compiler generates, in the object file
defining the main program, default libraries corresponding to the memory model and floating-point model used to compile the
file.&nbsp; For example, if you have compiled the source file containing the main program for the flat memory model and the
floating-point calls floating-point model, the libraries &quot;clib3r&quot; and &quot;math3r&quot; will be placed in the object
file.
<BR><BR>If you wish to add your own default libraries to this list, you can do so with a library pragma.&nbsp; Consider the
following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma library (mylib);</TT>
<BR><BR>The name &quot;mylib&quot; will be added to the list of default libraries specified in the object file.
<BR><BR>If the library specification contains characters such as '\', ':' or ',' (i.e., any character not allowed in a C identifier),
you must enclose it in double quotes as in the following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma library (&quot;\watcom\lib286\dos\graph.lib&quot;);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma library (&quot;\watcom\lib386\dos\graph.lib&quot;);</TT>
<BR><BR>If you wish to specify more than one library in a library pragma you must separate them with spaces as in the following
example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma library (mylib &quot;\watcom\lib286\dos\graph.lib&quot;);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma library (mylib &quot;\watcom\lib386\dos\graph.lib&quot;);</TT>
<H2 ID="32Mbit__The_ALIAS_Pragma_LC_OnlyR"> 32-bit:&nbsp; The ALIAS Pragma (C Only) </H2>
<BR>The &quot;alias&quot; pragma can be used to emit alias records in the object file, causing the linker to substitute references
to a specified symbol with references to another symbol.&nbsp; Either identifiers or names (strings) may be used.&nbsp; Strings
are used verbatim, while names corresponding to identifiers are derived as appropriate for the kind and calling convention
of the symbol.&nbsp; The following describes the form of the &quot;alias&quot; pragma.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma alias ( </TT><B>alias</B><TT>, </TT><B>subst</B><TT> ) </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>alias
<DD>is either a name or an identifier of the symbol to be aliased.
<DT>subst
<DD>is either a name or an identifier of the symbol that references to<TT> alias</TT> will be replaced with.
</DL>
<BR>Consider the following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int var;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void fn( void )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var = 3;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma alias ( var, &quot;other_var&quot; );</TT>
<BR><BR>Instead of<TT> var</TT> the linker will reference symbol named &quot;other_var&quot;.&nbsp; Symbol<TT> var</TT> need
not be defined, although &quot;other_var&quot; has to be.
<H2 ID="32Mbit__The_ALLOC_TEXT_Pragma_LC_OnlyR"> 32-bit:&nbsp; The ALLOC_TEXT Pragma (C Only) </H2>
<BR>The &quot;alloc_text&quot; pragma can be used to specify the name of the text segment into which the generated code for
a function, or a list of functions, is to be placed.&nbsp; The following describes the form of the &quot;alloc_text&quot;
pragma.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma alloc_text ( </TT><B>seg_name</B><TT>, </TT><B>fn</B><TT> </TT><B>{</B><TT>, </TT><B>fn}</B><TT>
) </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>seg_name
<DD>is the name of the text segment.
<DT>fn
<DD>is the name of a function.
</DL>
<BR>Consider the following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int fn1(int);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern int fn2(void);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma alloc_text ( my_text, fn1, fn2 );</TT>
<BR><BR>The code for the functions<TT> fn1</TT> and<TT> fn2</TT> will be placed in the segment<TT> my_text.</TT>&nbsp; Note:
&nbsp;function prototypes for the named functions must exist prior to the &quot;alloc_text&quot; pragma.
<H2 ID="32Mbit__The_CODE_SEG_Pragma"> 32-bit:&nbsp; The CODE_SEG Pragma </H2>
<BR>The &quot;code_seg&quot; pragma can be used to specify the name of the text segment into which the generated code for
functions is to be placed.&nbsp; The following describes the form of the &quot;code_seg&quot; pragma.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma code_seg ( </TT><B>seg_name</B><TT> </TT><B>[</B><TT>, </TT><B>class_name]</B><TT>
) </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>seg_name
<DD>is the name of the text segment optionally enclosed in quotes.&nbsp; Also,<TT> seg_name</TT> may be a macro as in:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define seg_name &quot;MY_CODE_SEG&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma code_seg ( seg_name );</TT>
<DT>class_name
<DD>is the optional class name of the text segment and may be enclosed in quotes.&nbsp; Please note that in order to be recognized
by the linker as code, a class name has to end in &quot;CODE&quot;.&nbsp; Also,<TT> class_name</TT> may be a macro as in:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define class_name &quot;MY_CODE&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma code_seg ( &quot;MY_CODE_SEG&quot;, class_name );</TT>
</DL>
<BR>Consider the following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma code_seg ( my_text );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int incr( int i )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( i + 1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int decr( int i )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( i - 1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The code for the functions<TT> incr</TT> and<TT> decr</TT> will be placed in the segment<TT> my_text.</TT>
<BR><BR>To return to the default segment, do not specify any string between the opening and closing parenthesis.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma code_seg ();</TT>
<H2 ID="32Mbit__The_COMMENT_Pragma"> 32-bit:&nbsp; The COMMENT Pragma </H2>
<BR>The &quot;comment&quot; pragma can be used to place a comment record in an object file or executable file.&nbsp; The following
describes the form of the &quot;comment&quot; pragma.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma comment ( </TT><B>comment_type</B><TT> </TT><B>[</B><TT>, </TT><B>&quot;comment_string&quot;]</B><TT>
) </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>comment_type
<DD>specifies the type of comment record.&nbsp; The allowable comment types are:
<DL>
<DT>lib
<DD>Default libraries are specified in special object module records.&nbsp; Library names are extracted from these special records
by the Open Watcom Linker.&nbsp; When unresolved references remain after processing all object modules specified in linker
&quot;FILE&quot; directives, these default libraries are searched after all libraries specified in linker &quot;LIBRARY&quot;
directives have been searched.
<BR><BR>The &quot;lib&quot; form of this pragma offers the same features as the &quot;library&quot; pragma.&nbsp; See the
section entitled <A HREF="#32Mbit__Using_Pragmas_to_Specify_Default_Libraries">32-bit:&nbsp; Using Pragmas to Specify Default Libraries</A>
for more information.
</DL>
<DT>&quot;comment_string&quot;
<DD>is an optional string literal that provides additional information for some comment types.
</DL>
<BR>Consider the following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma comment ( lib, &quot;mylib&quot; );</TT>
<H2 ID="32Mbit__The_DATA_SEG_Pragma"> 32-bit:&nbsp; The DATA_SEG Pragma </H2>
<BR>The &quot;data_seg&quot; pragma can be used to specify the name of the segment into which data is to be placed.&nbsp;
The following describes the form of the &quot;data_seg&quot; pragma.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma data_seg ( </TT><B>seg_name</B><TT> </TT><B>[</B><TT>, </TT><B>class_name]</B><TT>
) </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>seg_name
<DD>is the name of the data segment and may be enclosed in quotes.&nbsp; Also,<TT> seg_name</TT> may be a macro as in:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define seg_name &quot;MY_DATA_SEG&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma data_seg ( seg_name );</TT>
<DT>class_name
<DD>is the optional class name of the data segment and may be enclosed in quotes.&nbsp; Also,<TT> class_name</TT> may be a macro
as in:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define class_name &quot;MY_CLASS&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma data_seg ( &quot;MY_DATA_SEG&quot;, class_name );</TT>
</DL>
<BR>Consider the following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma data_seg ( my_data );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static int i;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static int j;</TT>
<BR><BR>The data for<TT> i</TT> and<TT> j</TT> will be placed in the segment<TT> my_data.</TT>
<BR><BR>To return to the default segment, do not specify any string between the opening and closing parenthesis.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma data_seg ();</TT>
<H2 ID="32Mbit__The_DISABLE_MESSAGE_Pragma"> 32-bit:&nbsp; The DISABLE_MESSAGE Pragma </H2>
<BR>The &quot;disable_message&quot; pragma disables the issuance of specified diagnostic messages.&nbsp; The form of the &quot;disable_message&quot;
pragma is as follows.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma disable_message ( </TT><B>msg_num</B><TT> </TT><B>{</B><TT>, </TT><B>msg_num}</B><TT>
) </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>msg_num
<DD>is the number of the diagnostic message.&nbsp; This number corresponds to the number issued by the compiler.&nbsp; Make sure
to strip all leading zeroes from the message number (to avoid interpretation as an octal constant).
</DL>
<BR>See also the description of <A HREF="#32Mbit__The_ENABLE_MESSAGE_Pragma">32-bit:&nbsp; The ENABLE_MESSAGE Pragma</A>.
<H2 ID="32Mbit__The_DUMP_OBJECT_MODEL_Pragma_LCPP_OnlyR"> 32-bit:&nbsp; The DUMP_OBJECT_MODEL Pragma (C++ Only) </H2>
<BR>The &quot;dump_object_model&quot; pragma causes the C++ compiler to print information about the object model for an indicated
class or an enumeration name to the diagnostics file.&nbsp; For class names, this information includes the offsets and sizes
of fields within the class and within base classes.&nbsp; For enumeration names, this information consists of a list of all
the enumeration constants with their values.
<BR><BR>The general form of the &quot;dump_object_model&quot; pragma is as follows.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma dump_object_model </TT><B>class</B><TT> </TT><B>[</B><TT>;</TT><B>]</B>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma dump_object_model </TT><B>enumeration</B><TT> </TT><B>[</B><TT>;</TT><B>]</B>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp; class ::= a defined C++ class free of errors</B>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp; enumeration ::= a defined C++ enumeration name</B>
<HR>
<BR>This pragma is designed to be used for information purposes only.
<H2 ID="32Mbit__The_ENABLE_MESSAGE_Pragma"> 32-bit:&nbsp; The ENABLE_MESSAGE Pragma </H2>
<BR>The &quot;enable_message&quot; pragma re-enables the issuance of specified diagnostic messages that have been previously
disabled.&nbsp; The form of the &quot;enable_message&quot; pragma is as follows.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma enable_message ( </TT><B>msg_num</B><TT> </TT><B>{</B><TT>, </TT><B>msg_num}</B><TT>
) </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>msg_num
<DD>is the number of the diagnostic message.&nbsp; This number corresponds to the number issued by the compiler.&nbsp; Make sure
to strip all leading zeroes from the message number (to avoid interpretation as an octal constant).
</DL>
<BR>See also the description of <A HREF="#32Mbit__The_DISABLE_MESSAGE_Pragma">32-bit:&nbsp; The DISABLE_MESSAGE Pragma</A>.
<H2 ID="32Mbit__The_ENUM_Pragma"> 32-bit:&nbsp; The ENUM Pragma </H2>
<BR>The &quot;enum&quot; pragma affects the underlying storage-definition for subsequent<B> enum</B> declarations.&nbsp; The
forms of the &quot;enum&quot; pragma are as follows.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma enum int </TT><B>[</B><TT>;</TT><B>]</B>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma enum minimum </TT><B>[</B><TT>;</TT><B>]</B>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma enum original </TT><B>[</B><TT>;</TT><B>]</B>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma enum pop </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>int
<DD>Make<B> int</B> the underlying storage definition (same as the &quot;ei&quot; compiler option).
<DT>minimum
<DD>Minimize the underlying storage definition (same as not specifying the &quot;ei&quot; compiler option).
<DT>original
<DD>Reset back to the original compiler option setting (i.e., what was or was not specified on the command line).
<DT>pop
<DD>Restore the previous setting.
</DL>
<BR>The first three forms all push the previous setting before establishing the new setting.
<H2 ID="32Mbit__The_ERROR_Pragma"> 32-bit:&nbsp; The ERROR Pragma </H2>
<BR>The &quot;error&quot; pragma can be used to issue an error message with the specified text.&nbsp; The following describes
the form of the &quot;error&quot; pragma.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma error </TT><B>&quot;error text&quot;</B><TT> </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>&quot;error text&quot;
<DD>is the text of the message that you wish to display.
</DL>
<BR>You should use the ISO<B><I> #error</I></B> directive rather than this pragma.&nbsp; This pragma is provided for compatibility
with legacy code.&nbsp; The following is an example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #if defined(__386__)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #elseif defined(__86__)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma error ( &quot;neither __386__ or __86__ defined&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #endif</TT>
<H2 ID="32Mbit__The_EXTREF_Pragma"> 32-bit:&nbsp; The EXTREF Pragma </H2>
<BR>The &quot;extref&quot; pragma is used to generate a reference to an external function or data item.&nbsp; The form of
the &quot;extref&quot; pragma is as follows.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma extref </TT><B>name</B><TT> </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>name
<DD>is the name of an external function or data item.&nbsp; It must be declared to be an external function or data item before
the pragma is encountered.&nbsp; In C++, when<B> name</B> is a function, it must not be overloaded.
</DL>
<BR>This pragma causes an external reference for the function or data item to be emitted into the object file even if that
function or data item is not referenced in the module.&nbsp; The external reference will cause the linker to include the module
containing that name in the linked program or DLL.
<BR><BR>This is useful for debugging since you can cause debugging routines (callable from within debugger) to be included
into a program or DLL to be debugged.
<BR><BR>In C++, you can also force constructors and/or destructors to be called for a data item without necessarily referencing
the data item anywhere in your code.
<H2 ID="32Mbit__The_FUNCTION_Pragma"> 32-bit:&nbsp; The FUNCTION Pragma </H2>
<BR>Certain functions, such as those listed in the description of the &quot;oi&quot; and &quot;om&quot; options, have intrinsic
forms.&nbsp; These functions are special functions that are recognized by the compiler and processed in a special way.&nbsp;
For example, the compiler may choose to generate in-line code for the function.&nbsp; The intrinsic attribute for these special
functions is set by specifying the &quot;oi&quot; or &quot;om&quot; option or using an &quot;intrinsic&quot; pragma.&nbsp;
The &quot;function&quot; pragma can be used to remove the intrinsic attribute for a specified list of functions.
<BR><BR>The following describes the form of the &quot;function&quot; pragma.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma function ( </TT><B>fn</B><TT> </TT><B>{</B><TT>, </TT><B>fn}</B><TT> ) </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>fn
<DD>is the name of a function.
</DL>
<BR>Suppose the following source code was compiled using the &quot;om&quot; option so that when one of the special math functions
is referenced, the intrinsic form will be used.&nbsp; In our example, we have referenced the function<TT> sin</TT> which does
have an intrinsic form.&nbsp; By specifying<TT> sin</TT> in a &quot;function&quot; pragma, the intrinsic attribute will be
removed, causing the function<TT> sin</TT> to be treated as a regular user-defined function.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;math.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma function( sin );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; double test( double x )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( sin( x ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="32Mbit__The_INCLUDE_ALIAS_Pragma"> 32-bit:&nbsp; The INCLUDE_ALIAS Pragma </H2>
<BR>In certain situations, it can be advantageous to remap the names of include files.&nbsp; Most commonly this occurs on
systems that do not support long file names when building source code that references header files with long names.
<BR><BR>The form of the &quot;include_alias&quot; pragma follows.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma include_alias ( &quot;</TT><B>alias_name</B><TT>&quot;, &quot;</TT><B>real_name</B><TT>&quot;
) </TT><B>[</B><TT>;</TT><B>]</B>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma include_alias ( &lt;</TT><B>alias_name</B><TT>&gt;, &lt;</TT><B>real_name</B><TT>&gt;
) </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>alias_name
<DD>is the name referenced in include directives in source code.
<DT>real_name
<DD>is the translated name that the compiler will reference instead.
</DL>
<BR>The following is an example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma include_alias( &quot;LongFileName.h&quot;, &quot;lfn.h&quot; )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &quot;LongFileName.h&quot;</TT>
<BR><BR>In the example, the compiler will attempt to read lfn.h when LongFileName.h was included.
<BR><BR>Note that only simple textual substitution is performed.&nbsp; The aliased name must match exactly, including double
quotes or angle brackets, as well as any directory separators.&nbsp; Also, double quotes and angle brackets may not be mixed
a single pragma.
<BR><BR>The value of the predefined<TT> __FILE__</TT> symbol, as well as the filename reported in error messages, will be
the true filename after substitution was performed.
<H2 ID="32Mbit__Setting_Priority_of_Static_Data_Initialization_LCPP_OnlyR"> 32-bit:&nbsp; Setting Priority of Static Data Initialization (C++ Only) </H2>
<BR>The &quot;initialize&quot; pragma sets the priority for initialization of static data in the file.&nbsp; This priority
only applies to initialization of static data that requires the execution of code.&nbsp; For example, the initialization of
a class that contains a constructor requires the execution of the constructor.&nbsp; Note that if the sequence in which initialization
of static data in your program takes place has no dependencies, the &quot;initialize&quot; pragma need not be used.
<BR><BR>The general form of the &quot;initialize&quot; pragma is as follows.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma initialize </TT><B>[</B><TT>before </TT><B>|</B><TT> after</TT><B>]</B><TT> </TT><B>priority</B><TT>
</TT><B>[</B><TT>;</TT><B>]</B>
<BR><BR><B>&nbsp;&nbsp;&nbsp;&nbsp; priority ::=</B><TT> </TT><B>n</B><TT> </TT><B>|</B><TT> library </TT><B>|</B><TT> program</TT>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>n
<DD>is a number representing the priority and must be in the range 0-255.&nbsp; The larger the priority, the later the point at
which initialization will occur.
</DL>
<BR>Priorities in the range 0-20 are reserved for the C++ compiler.&nbsp; This is to ensure that proper initialization of
the C++ run-time system takes place before the execution of your program.&nbsp; The &quot;library&quot; keyword represents
a priority of 32 and can be used for class libraries that require initialization before the program is initialized.&nbsp;
The &quot;program&quot; keyword represents a priority of 64 and is the default priority for any compiled code.&nbsp; Specifying
&quot;before&quot; adjusts the priority by subtracting one.&nbsp; Specifying &quot;after&quot; adjusts the priority by adding
one.
<BR><BR>A source file containing the following &quot;initialize&quot; pragma specifies that the initialization of static data
in the file will take place before initialization of all other static data in the program since a priority of 63 will be assigned.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma initialize before program</TT>
<BR><BR>If we specify &quot;after&quot; instead of &quot;before&quot;, the initialization of the static data in the file will
occur after initialization of all other static data in the program since a priority of 65 will be assigned.
<BR><BR>Note that the following is equivalent to the &quot;before&quot; example
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma initialize 63</TT>
<BR><BR>and the following is equivalent to the &quot;after&quot; example.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma initialize 65</TT>
<BR><BR>The use of the &quot;before&quot;, &quot;after&quot;, and &quot;program&quot; keywords are more descriptive in the
intent of the pragmas.
<BR><BR>It is recommended that a priority of 32 (the priority used when the &quot;library&quot; keyword is specified) be used
when developing class libraries.&nbsp; This will ensure that initialization of static data defined by the class library will
take place before initialization of static data defined by the program.&nbsp; The following &quot;initialize&quot; pragma
can be used to achieve this.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma initialize library</TT>
<H2 ID="32Mbit__The_INLINE_DEPTH_Pragma_LCPP_OnlyR"> 32-bit:&nbsp; The INLINE_DEPTH Pragma (C++ Only) </H2>
<BR>When an in-line function is called, the function call may be replaced by the in-line expansion for that function.&nbsp;
This in-line expansion may include calls to other in-line functions which can also be expanded.&nbsp; The &quot;inline_depth&quot;
pragma can be used to set the number of times this expansion of in-line functions will occur for a call.
<BR><BR>The form of the &quot;inline_depth&quot; pragma is as follows.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma inline_depth </TT><B>[</B><TT>(</TT><B>]</B><TT> </TT><B>n</B><TT> </TT><B>[</B><TT>)</TT><B>]</B><TT>
</TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>n
<DD>is the depth of expansion.&nbsp; If<TT> n</TT> is 0, no expansion will occur.&nbsp; If<TT> n</TT> is 1, only the original
call is expanded.&nbsp; If<TT> n</TT> is 2, the original call and the in-line functions invoked by the original function will
be expanded.&nbsp; The default value for<TT> n</TT> is 3.&nbsp; The maximum value for<TT> n</TT> is 255.&nbsp; Note that no
expansion of recursive in-line functions occur unless enabled using the &quot;inline_recursion&quot; pragma.
</DL>
<H2 ID="32Mbit__The_INLINE_RECURSION_Pragma_LCPP_OnlyR"> 32-bit:&nbsp; The INLINE_RECURSION Pragma (C++ Only) </H2>
<BR>The &quot;inline_recursion&quot; pragma controls the recursive expansion of inline functions.&nbsp; The form of the &quot;inline_recursion&quot;
pragma is as follows.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma inline_recursion </TT><B>[</B><TT>(</TT><B>]</B><TT> on </TT><B>|</B><TT> off </TT><B>[</B><TT>)</TT><B>]</B><TT>
</TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<BR>Specifying &quot;on&quot; will enable expansion of recursive inline functions.&nbsp; The depth of expansion is specified
by the &quot;inline_depth&quot; pragma.&nbsp; The default depth is 3.&nbsp; Specifying &quot;off&quot; suppresses expansion
of recursive inline functions.&nbsp; This is the default.
<H2 ID="32Mbit__The_INTRINSIC_Pragma"> 32-bit:&nbsp; The INTRINSIC Pragma </H2>
<BR>Certain functions, those listed in the description of the &quot;oi&quot; option, have intrinsic forms.&nbsp; These functions
are special functions that are recognized by the compiler and processed in a special way.&nbsp; For example, the compiler
may choose to generate in-line code for the function.&nbsp; The intrinsic attribute for these special functions is set by
specifying the &quot;oi&quot; option or using an &quot;intrinsic&quot; pragma.
<BR><BR>The following describes the form of the &quot;intrinsic&quot; pragma.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma intrinsic ( </TT><B>fn</B><TT> </TT><B>{</B><TT>, </TT><B>fn}</B><TT> ) </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>fn
<DD>is the name of a function.
</DL>
<BR>Suppose the following source code was compiled without using the &quot;oi&quot; option so that no function had the intrinsic
attribute.&nbsp; If we wanted the intrinsic form of the<TT> sin</TT> function to be used, we could specify the function in
an &quot;intrinsic&quot; pragma.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;math.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma intrinsic( sin );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; double test( double x )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( sin( x ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<H2 ID="32Mbit__The_MESSAGE_Pragma"> 32-bit:&nbsp; The MESSAGE Pragma </H2>
<BR>The &quot;message&quot; pragma can be used to issue a message with the specified text to the standard output without terminating
compilation.&nbsp; The following describes the form of the &quot;message&quot; pragma.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma message ( </TT><B>&quot;message text&quot;</B><TT> ) </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>&quot;message text&quot;
<DD>is the text of the message that you wish to display.
</DL>
<BR>The following is an example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #if defined(__386__)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma message ( &quot;assuming 16-bit compile&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #endif</TT>
<H2 ID="32Mbit__The_ONCE_Pragma"> 32-bit:&nbsp; The ONCE Pragma </H2>
<BR>The &quot;once&quot; pragma can be used to indicate that the file which contains this pragma should only be opened and
processed &quot;once&quot;.&nbsp; The following describes the form of the &quot;once&quot; pragma.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma once </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<BR>Assume that the file &quot;foo.h&quot; contains the following text.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #ifndef _FOO_H_INCLUDED</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define _FOO_H_INCLUDED</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma once</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #endif</TT>
<BR><BR>The first time that the compiler processes &quot;foo.h&quot; and encounters the &quot;once&quot; pragma, it records
the file's name.&nbsp; Subsequently, whenever the compiler encounters a<TT> #include</TT> statement that refers to &quot;foo.h&quot;,
it will not open the include file again.&nbsp; This can help speed up processing of<TT> #include</TT> files and reduce the
time required to compile an application.
<H2 ID="32Mbit__The_PACK_Pragma"> 32-bit:&nbsp; The PACK Pragma </H2>
<BR>The &quot;pack&quot; pragma can be used to control the way in which structures are stored in memory.&nbsp; There are 4
forms of the &quot;pack&quot; pragma.
<BR><BR>The following form of the &quot;pack&quot; pragma can be used to change the alignment of structures and their fields
in memory.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma pack ( </TT><B>n</B><TT> ) </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>n
<DD>is 1, 2, 4, 8 or 16 and specifies the method of alignment.
</DL>
<BR>The alignment of structure members is described in the following table.&nbsp; If the size of the member is 1, 2, 4, 8
or 16, the alignment is given for each of the &quot;zp&quot; options.&nbsp; If the member of the structure is an array or
structure, the alignment is described by the row &quot;x&quot;.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; zp1&nbsp;&nbsp;&nbsp;&nbsp; zp2&nbsp;&nbsp;&nbsp;&nbsp; zp4&nbsp;&nbsp;&nbsp;&nbsp; zp8&nbsp;&nbsp;
&nbsp; zp16</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; sizeof(member)&nbsp; \---------------------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;
&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;
&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;
&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;
&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;
&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;
&nbsp;aligned to largest member</TT>
<BR><BR>An alignment of 0 means no alignment, 2 means word boundary, 4 means doubleword boundary, etc.&nbsp; If the largest
member of structure &quot;x&quot; is 1 byte then &quot;x&quot; is not aligned.&nbsp; If the largest member of structure &quot;x&quot;
is 2 bytes then &quot;x&quot; is aligned according to row 2.&nbsp; If the largest member of structure &quot;x&quot; is 4 bytes
then &quot;x&quot; is aligned according to row 4.&nbsp; If the largest member of structure &quot;x&quot; is 8 bytes then &quot;x&quot;
is aligned according to row 8.&nbsp; If the largest member of structure &quot;x&quot; is 16 bytes then &quot;x&quot; is aligned
according to row 16.
<BR><BR>If no value is specified in the &quot;pack&quot; pragma, a default value of 8 is used.&nbsp; Note that the default
value can be changed with the &quot;zp&quot; Open Watcom C/C++ compiler command line option.
<BR><BR>The following form of the &quot;pack&quot; pragma can be used to save the current alignment amount on an internal
stack.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma pack ( push ) </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<BR>The following form of the &quot;pack&quot; pragma can be used to save the current alignment amount on an internal stack
and set the current alignment.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma pack ( push, </TT><B>number</B><TT> ) </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<BR>The following form of the &quot;pack&quot; pragma can be used to restore the previous alignment amount from an internal
stack.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma pack ( pop ) </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<H2 ID="32Mbit__The_READ_ONLY_FILE_Pragma"> 32-bit:&nbsp; The READ_ONLY_FILE Pragma </H2>
<BR>Explicit listing of dependencies in a makefile can often be tedious in the development and maintenance phases of a project.
&nbsp;The Open Watcom C/C++ compiler will insert dependency information into the object file as it processes source files
so that a complete snapshot of the files necessary to build the object file are recorded.&nbsp; The &quot;read_only_file&quot;
pragma can be used to prevent the name of the source file that includes it from being included in the dependency information
that is written to the object file.
<BR><BR>This pragma is commonly used in system header files since they change infrequently (and, when they do, there should
be no impact on source files that have included them).
<BR><BR>The form of the &quot;read_only_file&quot; pragma follows.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma read_only_file </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<BR>For more information on make dependencies, see the section entitled &quot;Automatic Dependency Detection (.AUTODEPEND)&quot;
in the<B><I> Open Watcom C/C++ Tools User's Guide.</I></B>
<H2 ID="32Mbit__The_TEMPLATE_DEPTH_Pragma_LCPP_OnlyR"> 32-bit:&nbsp; The TEMPLATE_DEPTH Pragma (C++ Only) </H2>
<BR>The &quot;template_depth&quot; pragma provides a hard limit for the amount of nested template expansions allowed so that
infinite expansion can be detected.
<BR><BR>The form of the &quot;template_depth&quot; pragma is as follows.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma template_depth </TT><B>[</B><TT>(</TT><B>]</B><TT> </TT><B>n</B><TT> </TT><B>[</B><TT>)</TT><B>]</B><TT>
</TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>n
<DD>is the depth of expansion.&nbsp; If the value of<TT> n</TT> is less than 2, if will default to 2.&nbsp; If<TT> n</TT> is not
specified, a warning message will be issued and the default value for<TT> n</TT> will be 100.
</DL>
<BR>The following example of recursive template expansion illustrates why this pragma can be useful.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma template_depth(10);</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; template &lt;class T&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct S {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S&lt;T*&gt; x;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; S&lt;char&gt; v;</TT>
<H2 ID="32Mbit__The_WARNING_Pragma_LCPP_OnlyR"> 32-bit:&nbsp; The WARNING Pragma (C++ Only) </H2>
<BR>The &quot;warning&quot; pragma sets the level of warning messages.&nbsp; The form of the &quot;warning&quot; pragma is
as follows.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma warning </TT><B>msg_num</B><TT> </TT><B>level</B><TT> </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>msg_num
<DD>is the number of the warning message.&nbsp; This number corresponds to the number issued by the compiler.&nbsp; If<TT> msg_num</TT>
is &quot;*&quot;, the level of all warning messages is changed to the specified level.&nbsp; Make sure to strip all leading
zeroes from the message number (to avoid interpretation as an octal constant).
<DT>level
<DD>is a number from 0 to 9 and represents the level of the warning message.&nbsp; When a value of zero is specified, the warning
becomes an error.
</DL>
<H2 ID="32Mbit__Auxiliary_Pragmas"> 32-bit:&nbsp; Auxiliary Pragmas </H2>
<BR>The following sections describe the capabilities provided by auxiliary pragmas.
<H3 ID="32Mbit__Specifying_Symbol_Attributes"> 32-bit:&nbsp; Specifying Symbol Attributes </H3>
<BR>Auxiliary pragmas are used to describe attributes that affect code generation.&nbsp; Initially, the compiler defines a
default set of attributes.&nbsp; Each auxiliary pragma refers to one of the following.
<OL>
<LI>a symbol (such as a variable or function)
<LI>a type definition that resolves to a function type
<LI>the default set of attributes defined by the compiler
</OL>
<BR>When an auxiliary pragma refers to a particular symbol, a copy of the current set of default attributes is made and merged
with the attributes specified in the auxiliary pragma.&nbsp; The resulting attributes are assigned to the specified symbol
and can only be changed by another auxiliary pragma that refers to the same symbol.
<BR><BR>An example of a type definition that resolves to a function type is the following.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef void (*func_type)();</TT>
<BR><BR>When an auxiliary pragma refers to a such a type definition, a copy of the current set of default attributes is made
and merged with the attributes specified in the auxiliary pragma.&nbsp; The resulting attributes are assigned to each function
whose type matches the specified type definition.
<BR><BR>When &quot;default&quot; is specified instead of a symbol name, the attributes specified by the auxiliary pragma change
the default set of attributes.&nbsp; The resulting attributes are used by all symbols that have not been specifically referenced
by a previous auxiliary pragma.
<BR><BR>Note that all auxiliary pragmas are processed before code generation begins.&nbsp; Consider the following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; code in which symbol x is referenced</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux y &lt;attrs_1&gt;;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; code in which symbol y is referenced</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; code in which symbol z is referenced</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux default &lt;attrs_2&gt;;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux x &lt;attrs_3&gt;;</TT>
<BR><BR>Auxiliary attributes are assigned to<TT> x, y</TT> and<TT> z</TT> in the following way.
<OL>
<LI>Symbol<TT> x</TT> is assigned the initial default attributes merged with the attributes specified by<TT> &lt;attrs_2&gt;</TT>
and<TT> &lt;attrs_3&gt;.</TT>
<LI>Symbol<TT> y</TT> is assigned the initial default attributes merged with the attributes specified by<TT> &lt;attrs_1&gt;.</TT>
<LI>Symbol<TT> z</TT> is assigned the initial default attributes merged with the attributes specified by<TT> &lt;attrs_2&gt;.</TT>
</OL>
<H3 ID="32Mbit__Alias_Names"> 32-bit:&nbsp; Alias Names </H3>
<BR>When a symbol referred to by an auxiliary pragma includes an alias name, the attributes of the alias name are also assumed
by the specified symbol.
<BR><BR>There are two methods of specifying alias information.&nbsp; In the first method, the symbol assumes only the attributes
of the alias name; no additional attributes can be specified.&nbsp; The second method is more general since it is possible
to specify an alias name as well as additional auxiliary information.&nbsp; In this case, the symbol assumes the attributes
of the alias name as well as the attributes specified by the additional auxiliary information.
<BR><BR>The simple form of the auxiliary pragma used to specify an alias is as follows.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux ( </TT><B>sym</B><TT>, </TT><B>[</B><TT>far16</TT><B>]</B><TT> </TT><B>alias</B><TT>
) </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is any valid C/C++ identifier.
<DT>alias
<DD>is the alias name and is any valid C/C++ identifier.
</DL>
<BR>The<TT> __far16</TT> attribute should only be used on systems that permit the calling of 16-bit code from 32-bit code.
&nbsp;Currently, the only supported operating system that allows this is 32-bit OS/2.&nbsp; If you have any libraries of functions
or APIs that are only available as 16-bit code and you wish to access these functions and APIs from 32-bit code, you must
specify the<TT> __far16</TT> attribute.&nbsp; If the<TT> __far16</TT> attribute is specified, the compiler will generate special
code which allows the 16-bit code to be called from 32-bit code.&nbsp; Note that a<TT> __far16</TT> function must be a function
whose attributes are those specified by one of the alias names<TT> __cdecl</TT> or<TT> __pascal</TT> .&nbsp; These alias names
will be described in a later section.
<BR><BR>Consider the following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux push_args parm [] ;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux ( rtn, push_args ) ;</TT>
<BR><BR>The routine<TT> rtn</TT> assumes the attributes of the alias name<TT> push_args</TT> which specifies that the arguments
to<TT> rtn</TT> are passed on the stack.
<BR><BR>Let us look at an example in which the symbol is a type definition.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; typedef void (func_type)(int);</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux push_args parm [];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux ( func_type, push_args );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern func_type rtn1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern func_type rtn2;</TT>
<BR><BR>The first auxiliary pragma defines an alias name called<TT> push_args</TT> that specifies the mechanism to be used
to pass arguments.&nbsp; The mechanism is to pass all arguments on the stack.&nbsp; The second auxiliary pragma associates
the attributes specified in the first pragma with the type definition<TT> func_type.</TT>&nbsp; Since<TT> rtn1</TT> and<TT>
rtn2</TT> are of type<TT> func_type,</TT> arguments to either of those functions will be passed on the stack.
<BR><BR>The general form of an auxiliary pragma that can be used to specify an alias is as follows.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux ( </TT><B>alias</B><TT> ) </TT><B>sym</B><TT> </TT><B>aux_attrs</B><TT> </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>alias
<DD>is the alias name and is any valid C/C++ identifier.
<DT>sym
<DD>is any valid C/C++ identifier.
<DT>aux_attrs
<DD>are attributes that can be specified with the auxiliary pragma.
</DL>
<BR>Consider the following example.&nbsp; 
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux HIGH_C &quot;*&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; parm caller []&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; value no8087&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; modify [eax ecx edx fs gs];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux (HIGH_C) rtn1;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux (HIGH_C) rtn2;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux (HIGH_C) rtn3;</TT>
<BR><BR>The routines<TT> rtn1, rtn2</TT> and<TT> rtn3</TT> assume the same attributes as the alias name<TT> HIGH_C</TT> which
defines the calling convention used by the MetaWare High C compiler.&nbsp; Note that register ES must also be specified in
the &quot;modify&quot; register set when using a memory model that is not a small data model.&nbsp; Whenever calls are made
to<TT> rtn1, rtn2</TT> and<TT> rtn3,</TT> the MetaWare High C calling convention will be used.
<BR><BR>Note that if the attributes of<TT> HIGH_C</TT> change, only one pragma needs to be changed.&nbsp; If we had not used
an alias name and specified the attributes in each of the three pragmas for<TT> rtn1, rtn2</TT> and<TT> rtn3,</TT> we would
have to change all three pragmas.&nbsp; This approach also reduces the amount of memory required by the compiler to process
the source file.
<HR>
<BR><B><I>&nbsp; WARNING!</I></B>&nbsp; The alias name<TT> HIGH_C</TT> is just another symbol.&nbsp; If<TT> HIGH_C</TT> appeared
in your source code, it would assume the attributes specified in the pragma for<TT> HIGH_C.</TT>
<HR>
<H3 ID="32Mbit__Predefined_Aliases"> 32-bit:&nbsp; Predefined Aliases </H3>
<BR>A number of symbols are predefined by the compiler with a set of attributes that describe a particular calling convention.
&nbsp;These symbols can be used as aliases.&nbsp; The following is a list of these symbols.
<DL>
<DT>__cdecl
<DD><TT> __cdecl</TT> or <TT> cdecl</TT> defines the calling convention used by Microsoft compilers.
<DT>__fastcall
<DD><TT> __fastcall</TT> or <TT> fastcall</TT> defines the calling convention used by Microsoft compilers.
<DT>__fortran
<DD><TT> __fortran</TT> or <TT> fortran</TT> defines the calling convention used by Open Watcom FORTRAN compilers.
<DT>__pascal
<DD><TT> __pascal</TT> or <TT> pascal</TT> defines the calling convention used by OS/2 1.x and Windows 3.x API functions.
<DT>__stdcall
<DD><TT> __stdcall</TT> or <TT> stdcall</TT> defines a special calling convention used by the Win32 API functions.
<DT>__syscall
<DD><TT> __syscall</TT> or <TT> syscall</TT> defines the calling convention used by the 32-bit OS/2 API functions.
<DT>__system
<DD><TT> __system</TT> or <TT> system</TT> are identical to<TT> __syscall</TT> .
<DT>__watcall
<DD><TT> __watcall</TT> or <TT> watcall</TT> defines the calling convention used by Open Watcom compilers.
</DL>
<BR>The following describes the attributes of the above alias names.
<H4 ID="32Mbit__Predefined____cdecl__Alias"> 32-bit:&nbsp; Predefined &quot;__cdecl&quot; Alias </H4>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux __cdecl &quot;_*&quot; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parm caller [] \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value struct float struct
routine [eax] \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; modify [eax ecx edx]</TT>
<BR><BR><B>Notes:</B>
<OL>
<LI>All symbols are preceded by an underscore character.
<LI>Arguments are pushed on the stack from right to left.&nbsp; That is, the last argument is pushed first.&nbsp; The calling
routine will remove the arguments from the stack.
<LI>Floating-point values are returned in the same way as structures.&nbsp; When a structure is returned, the called routine
allocates space for the return value and returns a pointer to the return value in register EAX.
<LI>Registers EAX, ECX and EDX are not saved and restored when a call is made.
</OL>
<H4 ID="32Mbit__Predefined____pascal__Alias"> 32-bit:&nbsp; Predefined &quot;__pascal&quot; Alias </H4>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux __pascal &quot;^&quot; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parm reverse routine []
\</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value struct float struct
caller [] \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; modify [eax ebx ecx edx]</TT>
<BR><BR><B>Notes:</B>
<OL>
<LI>All symbols are mapped to upper case.
<LI>Arguments are pushed on the stack in reverse order.&nbsp; That is, the first argument is pushed first, the second argument
is pushed next, and so on.&nbsp; The routine being called will remove the arguments from the stack.
<LI>Floating-point values are returned in the same way as structures.&nbsp; When a structure is returned, the caller allocates
space on the stack.&nbsp; The address of the allocated space will be pushed on the stack immediately before the call instruction.
&nbsp;Upon returning from the call, register EAX will contain address of the space allocated for the return value.
<LI>Registers EAX, EBX, ECX and EDX are not saved and restored when a call is made.
</OL>
<H4 ID="32Mbit__Predefined____stdcall__Alias"> 32-bit:&nbsp; Predefined &quot;__stdcall&quot; Alias </H4>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux __stdcall &quot;_*@nnn&quot; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parm routine [] \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value struct struct caller
[] \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; modify [eax ecx edx]</TT>
<BR><BR><B>Notes:</B>
<OL>
<LI>All symbols are preceded by an underscore character.
<LI>All C symbols (extern &quot;C&quot; symbols in C++) are suffixed by &quot;@nnn&quot; where &quot;nnn&quot; is the sum
of the argument sizes (each size is rounded up to a multiple of 4 bytes so that char and short are size 4).&nbsp; When the
argument list contains &quot;...&quot;, the &quot;@nnn&quot; suffix is omitted.
<LI>Arguments are pushed on the stack from right to left.&nbsp; That is, the last argument is pushed first.&nbsp; The called
routine will remove the arguments from the stack.
<LI>When a structure is returned, the caller allocates space on the stack.&nbsp; The address of the allocated space will be
pushed on the stack immediately before the call instruction.&nbsp; Upon returning from the call, register EAX will contain
address of the space allocated for the return value.&nbsp; Floating-point values are returned in 80x87 register ST(0).
<LI>Registers EAX, ECX and EDX are not saved and restored when a call is made.
</OL>
<H4 ID="32Mbit__Predefined____syscall__Alias"> 32-bit:&nbsp; Predefined &quot;__syscall&quot; Alias </H4>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux __syscall &quot;*&quot; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parm caller [] \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value struct struct caller
[] \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; modify [eax ecx edx]</TT>
<BR><BR><B>Notes:</B>
<OL>
<LI>Symbols names are not modified, that is, they are not adorned with leading or trailing underscores.
<LI>Arguments are pushed on the stack from right to left.&nbsp; That is, the last argument is pushed first.&nbsp; The calling
routine will remove the arguments from the stack.
<LI>When a structure is returned, the caller allocates space on the stack.&nbsp; The address of the allocated space will be
pushed on the stack immediately before the call instruction.&nbsp; Upon returning from the call, register EAX will contain
address of the space allocated for the return value.&nbsp; Floating-point values are returned in 80x87 register ST(0).
<LI>Registers EAX, ECX and EDX are not saved and restored when a call is made.
</OL>
<H4 ID="32Mbit__Predefined____watcall__Alias_Lregister_calling_conventionR"> 32-bit:&nbsp; Predefined &quot;__watcall&quot; Alias (register calling convention) </H4>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux __watcall &quot;*_&quot; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parm routine [eax ebx ecx
edx] \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value struct caller</TT>
<BR><BR><B>Notes:</B>
<OL>
<LI>Symbol names are followed by an underscore character.
<LI>Arguments are processed from left to right.&nbsp; The leftmost arguments are passed in registers and the rightmost arguments
are passed on the stack (if the registers used for argument passing have been exhausted).&nbsp; Arguments that are passed
on the stack are pushed from right to left.&nbsp; The calling routine will remove the arguments if any were pushed on the
stack.
<LI>When a structure is returned, the caller allocates space on the stack.&nbsp; The address of the allocated space is put
into ESI register.&nbsp; The called routine then places the return value there.&nbsp; Upon returning from the call, register
EAX will contain address of the space allocated for the return value.
<LI>Floating-point values are returned using 80x86 registers (&quot;fpc&quot; option) or using 80x87 floating-point registers
(&quot;fpi&quot; or &quot;fpi87&quot; option).
<LI>All registers must be preserved by the called routine.
</OL>
<H4 ID="32Mbit__Predefined____watcall__Alias_Lstack_calling_conventionR"> 32-bit:&nbsp; Predefined &quot;__watcall&quot; Alias (stack calling convention) </H4>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux __watcall &quot;*&quot; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parm caller [] \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value no8087 struct caller
\</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; modify [eax ecx edx 8087]</TT>
<BR><BR><B>Notes:</B>
<OL>
<LI>All symbols appear in object form as they do in source form.
<LI>Arguments are pushed on the stack from right to left.&nbsp; That is, the last argument is pushed first.&nbsp; The calling
routine will remove the arguments from the stack.
<LI>When a structure is returned, the caller allocates space on the stack.&nbsp; The address of the allocated space will be
pushed on the stack immediately before the call instruction.&nbsp; Upon returning from the call, register EAX will contain
address of the space allocated for the return value.
<LI>Floating-point values are returned only using 80x86 registers.
<LI>Registers EAX, ECX and EDX are not preserved by the called routine.
<LI>Any local variables that are located in the 80x87 cache are not preserved by the called routine.
</OL>
<H3 ID="32Mbit__Alternate_Names_for_Symbols"> 32-bit:&nbsp; Alternate Names for Symbols </H3>
<BR>The following form of the auxiliary pragma can be used to describe the mapping of a symbol from its source form to its
object form.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux </TT><B>sym</B><TT> </TT><B>obj_name</B><TT> </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is any valid C/C++ identifier.
<DT>obj_name
<DD>is any character string enclosed in double quotes.
</DL>
<BR>When specifying<TT> obj_name,</TT> some characters have a special meaning:
<DL>
<DT>where
<DD><B>description</B>
<DT>*
<DD>is unmodified symbol name
<DT>^
<DD>is symbol name converted to uppercase
<DT>!
<DD>is symbol name converted to lowercase
<DT>#
<DD>is a placeholder for &quot;@nnn&quot;, where nnn is size of all function parameters on the stack; it is ignored for functions
with variable argument lists, or for symbols that are not functions
<DT>\
<DD>next character is treated as literal
</DL>
<BR>Several examples of source to object form symbol name translation follow:
<BR><BR>In the following example, the name &quot;MyRtn&quot; will be replaced by &quot;MyRtn_&quot; in the object file.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux MyRtn &quot;*_&quot;;</TT>
<BR><BR>This is the default for all function names.
<BR><BR>In the following example, the name &quot;MyVar&quot; will be replaced by &quot;_MyVar&quot; in the object file.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux MyVar &quot;_*&quot;;</TT>
<BR><BR>This is the default for all variable names.
<BR><BR>In the following example, the lower case version &quot;myrtn&quot; will be placed in the object file.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux MyRtn &quot;!&quot;;</TT>
<BR><BR>In the following example, the upper case version &quot;MYRTN&quot; will be placed in the object file.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux MyRtn &quot;^&quot;;</TT>
<BR><BR>In the following example, the name &quot;MyRtn&quot; will be replaced by &quot;_MyRtn@nnn&quot; in the object file.
&nbsp;&quot;nnn&quot; represents the size of all function parameters.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux MyRtn &quot;_*#&quot;;</TT>
<BR><BR>In the following example, the name &quot;MyRtn&quot; will be replaced by &quot;_MyRtn#&quot; in the object file.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux MyRtn &quot;_*\#&quot;;</TT>
<BR><BR>The default mapping for all symbols can also be changed as illustrated by the following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux default &quot;_*_&quot;;</TT>
<BR><BR>The above auxiliary pragma specifies that all names will be prefixed and suffixed by an underscore character ('_').
<H3 ID="32Mbit__Describing_Calling_Information"> 32-bit:&nbsp; Describing Calling Information </H3>
<BR>The following form of the auxiliary pragma can be used to describe the way a function is to be called.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux </TT><B>sym</B><TT> far </TT><B>[</B><TT>;</TT><B>]</B>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux </TT><B>sym</B><TT> near </TT><B>[</B><TT>;</TT><B>]</B>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux </TT><B>sym</B><TT> = </TT><B>in_line</B><TT> </TT><B>[</B><TT>;</TT><B>]</B>
<BR><BR><B>&nbsp;&nbsp;&nbsp;&nbsp; in_line ::= { const | (</B><TT>seg</TT><B> id) | (</B><TT>offset</TT><B> id) | (</B><TT>reloff</TT><B>
id)</B>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; | </B><TT>&quot;</TT><B>asm</B><TT>&quot; </TT><B>}</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a function name.
<DT>const
<DD>is a valid C/C++ integer constant.
<DT>id
<DD>is any valid C/C++ identifier.
<DT>seg
<DD>specifies the segment of the symbol<TT> id.</TT>
<DT>offset
<DD>specifies the offset of the symbol<TT> id.</TT>
<DT>reloff
<DD>specifies the relative offset of the symbol<TT> id</TT> for near control transfers.
<DT>asm
<DD>is an assembly language instruction or directive.
</DL>
<BR>In the following example, Open Watcom C/C++ will generate a far call to the function<TT> myrtn.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux myrtn far;</TT>
<BR><BR>Note that this overrides the calling sequence that would normally be generated for a particular memory model.&nbsp;
In other words, a far call will be generated even if you are compiling for a memory model with a small code model.
<BR><BR>In the following example, Open Watcom C/C++ will generate a near call to the function<TT> myrtn.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux myrtn near;</TT>
<BR><BR>Note that this overrides the calling sequence that would normally be generated for a particular memory model.&nbsp;
In other words, a near call will be generated even if you are compiling for a memory model with a big code model.
<BR><BR>In the following DOS example, Open Watcom C/C++ will generate the sequence of bytes following the &quot;=&quot; character
in the auxiliary pragma whenever a call to<TT> mode4</TT> is encountered.<TT>&nbsp; mode4</TT> is called an in-line function.
&nbsp;
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void mode4(void);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux mode4 =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xb4 0x00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* mov AH,0 */ \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xb0 0x04&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* mov AL,4 */ \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xcd 0x10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* int 10H&nbsp; */
\</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; modify [ AH AL ];</TT>
<BR><BR>The sequence in the above DOS example represents the following lines of assembly language instructions.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp; AH,0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; select function &quot;set mode&quot;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp; AL,4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; specify mode (mode 4)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; 10H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; BIOS video call</TT>
<BR><BR>The above example demonstrates how to generate BIOS function calls in-line without writing an assembly language function
and calling it from your C/C++ program.&nbsp; The C prototype for the function<TT> mode4</TT> is not necessary but is included
so that we can take advantage of the argument type checking provided by Open Watcom C/C++.
<BR><BR>The following DOS example is equivalent to the above example but mnemonics for the assembly language instructions
are used instead of the binary encoding of the assembly language instructions.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void mode4(void);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux mode4 =&nbsp;&nbsp;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mov AH,0&quot;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mov AL,4&quot;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;int 10H&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; modify [ AH AL ];</TT>
<BR><BR>A sequence of in-line assembly language instructions may contain symbolic references.&nbsp; In the following example,
a near call to the function<TT> myalias</TT> is made whenever<TT> myrtn</TT> is called.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern void myalias(void);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void myrtn(void);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux myrtn =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xe8 reloff myalias /* near call */;</TT>
<BR><BR>In the following example, a far call to the function<TT> myalias</TT> is made whenever<TT> myrtn</TT> is called.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern void myalias(void);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void myrtn(void);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux myrtn =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x9a offset myalias seg myalias /* far call */;</TT>
<H4 ID="32Mbit__Loading_Data_Segment_Register"> 32-bit:&nbsp; Loading Data Segment Register </H4>
<BR>An application may have been compiled so that the segment register DS does not contain the segment address of the default
data segment (group &quot;DGROUP&quot;).&nbsp; This is usually the case if you are using a large data memory model.&nbsp;
Suppose you wish to call a function that assumes that the segment register DS contains the segment address of the default
data segment.&nbsp; It would be very cumbersome if you were forced to compile your application so that the segment register
DS contained the default data segment (a small data memory model).
<BR><BR>The following form of the auxiliary pragma will cause the segment register DS to be loaded with the segment address
of the default data segment before calling the specified function.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux </TT><B>sym</B><TT> parm loadds </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a function name.
</DL>
<BR>Alternatively, the following form of the auxiliary pragma will cause the segment register DS to be loaded with the segment
address of the default data segment as part of the prologue sequence for the specified function.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux </TT><B>sym</B><TT> loadds </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a function name.
</DL>
<H4 ID="32Mbit__Defining_Exported_Symbols_in_Dynamic_Link_Libraries"> 32-bit:&nbsp; Defining Exported Symbols in Dynamic Link Libraries </H4>
<BR>An exported symbol in a dynamic link library is a symbol that can be referenced by an application that is linked with
that dynamic link library.&nbsp; Normally, symbols in dynamic link libraries are exported using the Open Watcom Linker &quot;EXPORT&quot;
directive.&nbsp; An alternative method is to use the following form of the auxiliary pragma.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux </TT><B>sym</B><TT> export </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a function name.
</DL>
<H4 ID="32Mbit__Forcing_a_Stack_Frame"> 32-bit:&nbsp; Forcing a Stack Frame </H4>
<BR>Normally, a function contains a stack frame if arguments are passed on the stack or an automatic variable is allocated
on the stack.&nbsp; No stack frame will be generated if the above conditions are not satisfied.&nbsp; The following form of
the auxiliary pragma will force a stack frame to be generated under any circumstance.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux </TT><B>sym</B><TT> frame </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a function name.
</DL>
<H3 ID="32Mbit__Describing_Argument_Information"> 32-bit:&nbsp; Describing Argument Information </H3>
<BR>Using auxiliary pragmas, you can describe the calling convention that Open Watcom C/C++ is to use for calling functions.
&nbsp;This is particularly useful when interfacing to functions that have been compiled by other compilers or functions written
in other programming languages.
<BR><BR>The general form of an auxiliary pragma that describes argument passing is the following.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux </TT><B>sym</B><TT> parm </TT><B>{ pop_info | </B><TT>reverse</TT><B> | {reg_set}
}</B><TT> </TT><B>[</B><TT>;</TT><B>]</B>
<BR><BR><B>&nbsp;&nbsp;&nbsp;&nbsp; pop_info ::=</B><TT> caller </TT><B>|</B><TT> routine</TT>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a function name.
<DT>reg_set
<DD>is called a register set.&nbsp; The register sets specify the registers that are to be used for argument passing.&nbsp; A
register set is a list of registers separated by spaces and enclosed in square brackets.
</DL>
<H4 ID="32Mbit__Passing_Arguments_in_Registers"> 32-bit:&nbsp; Passing Arguments in Registers </H4>
<BR>The following form of the auxiliary pragma can be used to specify the registers that are to be used to pass arguments
to a particular function.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux </TT><B>sym</B><TT> parm </TT><B>{reg_set}</B><TT> </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a function name.
<DT>reg_set
<DD>is called a register set.&nbsp; The register sets specify the registers that are to be used for argument passing.&nbsp; A
register set is a list of registers separated by spaces and enclosed in square brackets.
</DL>
<BR>Register sets establish a priority for register allocation during argument list processing.&nbsp; Register sets are processed
from left to right.&nbsp; However, within a register set, registers are chosen in any order.&nbsp; Once all register sets
have been processed, any remaining arguments are pushed on the stack.
<BR><BR>Note that regardless of the register sets specified, only certain combinations of registers will be selected for arguments
of a particular type.
<BR><BR>Note that arguments of type<B> float</B> and<B> double</B> are always pushed on the stack when the &quot;fpi&quot;
or &quot;fpi87&quot; option is used.
<DL>
<DT>double
<DD>Arguments of type<B> double</B> can only be passed in one of the following register pairs:&nbsp; EDX:EAX, ECX:EBX, ECX:EAX,
ECX:ESI, EDX:EBX, EDI:EAX, ECX:EDI, EDX:ESI, EDI:EBX, ESI:EAX, ECX:EDX, EDX:EDI, EDI:ESI, ESI:EBX or EBX:EAX.&nbsp; For example,
if the following register set was specified for a routine having an argument of type<B> double</B>,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [EBP EBX]</TT>
<BR><BR>the argument would be pushed on the stack since a valid register combination for 8-byte arguments is not contained
in the register set.&nbsp; Note that this method for passing arguments of type<B> double</B> is supported only when the &quot;fpc&quot;
option is used.&nbsp; Note that this argument passing method does not include the passing of 8-byte structures.
<DT>far pointer
<DD>A far pointer can only be passed in one of the following register pairs:&nbsp; DX:EAX, CX:EBX, CX:EAX, CX:ESI, DX:EBX, DI:EAX,
CX:EDI, DX:ESI, DI:EBX, SI:EAX, CX:EDX, DX:EDI, DI:ESI, SI:EBX, BX:EAX, FS:ECX, FS:EDX, FS:EDI, FS:ESI, FS:EBX, FS:EAX, GS:ECX,
GS:EDX, GS:EDI, GS:ESI, GS:EBX, GS:EAX, DS:ECX, DS:EDX, DS:EDI, DS:ESI, DS:EBX, DS:EAX, ES:ECX, ES:EDX, ES:EDI, ES:ESI, ES:EBX
or ES:EAX.&nbsp; For example, if a far pointer is passed to a function with the following register set,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [ES EBP]</TT>
<BR><BR>the argument would be pushed on the stack since a valid register combination for a far pointer is not contained in
the register set.
<DT>int
<DD>The only registers that will be assigned to 4-byte arguments (e.g., arguments of type<B> int</B>) are:&nbsp; EAX, EBX, ECX,
EDX, ESI and EDI.&nbsp; For example, if the following register set was specified for a routine with one argument of type<B>
int</B>,
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [EBP]</TT>
<BR><BR>the argument would be pushed on the stack since a valid register combination for 4-byte arguments is not contained
in the register set.&nbsp; Note that this argument passing method includes 4-byte structures.&nbsp; Note that this argument
passing method also includes arguments of type<B> float</B> but only when the &quot;fpc&quot; option is used.
<DT>char, short int
<DD>Arguments whose size is 1 byte or 2 bytes (e.g., arguments of type<B> char</B> and<B> short int</B> as well as 2-byte structures)
are promoted to 4 bytes and are then assigned registers as if they were 4-byte arguments.
<DT>others
<DD>Arguments that do not fall into one of the above categories cannot be passed in registers and are pushed on the stack.&nbsp;
Once an argument has been assigned a position on the stack, all remaining arguments will be assigned a position on the stack
even if all register sets have not yet been exhausted.
</DL>
<BR><B>Notes:</B>
<OL>
<LI>The default register set is [EAX EBX ECX EDX].
<LI>Specifying registers AH and AL is equivalent to specifying register AX.&nbsp; Specifying registers DH and DL is equivalent
to specifying register DX.&nbsp; Specifying registers CH and CL is equivalent to specifying register CX.&nbsp; Specifying
registers BH and BL is equivalent to specifying register BX.&nbsp; Specifying register EAX implies that register AX has been
specified.&nbsp; Specifying register EBX implies that register BX has been specified.&nbsp; Specifying register ECX implies
that register CX has been specified.&nbsp; Specifying register EDX implies that register DX has been specified.&nbsp; Specifying
register EDI implies that register DI has been specified.&nbsp; Specifying register ESI implies that register SI has been
specified.&nbsp; Specifying register EBP implies that register BP has been specified.&nbsp; Specifying register ESP implies
that register SP has been specified.
<LI>If you are compiling for a memory model with a small data model, or the &quot;zdp&quot; compiler option is specified,
any register combination containing register DS becomes illegal.&nbsp; In a small data model, segment register DS must remain
unchanged as it points to the program's data segment.&nbsp; Note that the &quot;zdf&quot; compiler option can be used to specify
that register DS does not contain that segment address of the program's data segment.&nbsp; In this case, register combinations
containing register DS are legal.
<LI>If you are compiling for the flat memory model, any register combination containing DS or ES becomes illegal.&nbsp; In
a flat memory model, code and data reside in the same segment.&nbsp; Segment registers DS and ES point to this segment and
must remain unchanged.
</OL>
<BR>Consider the following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux myrtn parm [eax ebx ecx edx] [ebp esi];</TT>
<BR><BR>Suppose<TT> myrtn</TT> is a routine with 3 arguments each of type<B> double</B>.
<OL>
<LI>The first argument will be passed in the register pair EDX:EAX.
<LI>The second argument will be passed in the register pair ECX:EBX.
<LI>The third argument will be pushed on the stack since EBP:ESI is not a valid register pair for arguments of type<B> double</B>.
</OL>
<BR>It is possible for registers from the second register set to be used before registers from the first register set are
used.&nbsp; Consider the following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux myrtn parm [eax ebx ecx edx] [esi edi];</TT>
<BR><BR>Suppose<TT> myrtn</TT> is a routine with 3 arguments, the first of type<B> int</B> and the second and third of type<B>
double</B>.
<OL>
<LI>The first argument will be passed in the register EAX.
<LI>The second argument will be passed in the register pair ECX:EBX.
<LI>The third argument will be passed in the register set EDI:ESI.
</OL>
<BR>Note that registers are no longer selected from a register set after registers are selected from subsequent register sets,
even if all registers from the original register set have not been exhausted.
<BR><BR>An empty register set is permitted.&nbsp; All subsequent register sets appearing after an empty register set are ignored;
all remaining arguments are pushed on the stack.
<BR><BR><B>Notes:</B>
<OL>
<LI>If a single empty register set is specified, all arguments are passed on the stack.
<LI>If no register set is specified, the default register set [EAX EBX ECX EDX] is used.
</OL>
<H4 ID="32Mbit__Forcing_Arguments_into_Specific_Registers"> 32-bit:&nbsp; Forcing Arguments into Specific Registers </H4>
<BR>It is possible to force arguments into specific registers.&nbsp; Suppose you have a function, say &quot;mycopy&quot;,
that copies data.&nbsp; The first argument is the source, the second argument is the destination, and the third argument is
the length to copy.&nbsp; If we want the first argument to be passed in the register ESI, the second argument to be passed
in register EDI and the third argument to be passed in register ECX, the following auxiliary pragma can be used.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void mycopy( char near *, char *, int );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux mycopy parm [ESI] [EDI] [ECX];</TT>
<BR><BR>Note that you must be aware of the size of the arguments to ensure that the arguments get passed in the appropriate
registers.
<H4 ID="32Mbit__Passing_Arguments_to_InMLine_Functions"> 32-bit:&nbsp; Passing Arguments to In-Line Functions </H4>
<BR>For functions whose code is generated by Open Watcom C/C++ and whose argument list is described by an auxiliary pragma,
Open Watcom C/C++ has some freedom in choosing how arguments are assigned to registers.&nbsp; Since the code for in-line functions
is specified by the programmer, the description of the argument list must be very explicit.&nbsp; To achieve this, Open Watcom
C/C++ assumes that each register set corresponds to an argument.&nbsp; Consider the following DOS example of an in-line function
called<TT> scrollactivepgup.</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void scrollactivepgup(char,char,char,char,char,char);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux scrollactivepgup = \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mov AH,6&quot;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;int 10h&quot;&nbsp;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parm [ch] [cl] [dh] [dl] [al] [bh] \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; modify [ah];</TT>
<BR><BR>The BIOS video call to scroll the active page up requires the following arguments.
<OL>
<LI>The row and column of the upper left corner of the scroll window is passed in registers CH and CL respectively.
<LI>The row and column of the lower right corner of the scroll window is passed in registers DH and DL respectively.
<LI>The number of lines blanked at the bottom of the window is passed in register AL.
<LI>The attribute to be used on the blank lines is passed in register BH.
</OL>
<BR>When passing arguments, Open Watcom C/C++ will convert the argument so that it fits in the register(s) specified in the
register set for that argument.&nbsp; For example, in the above example, if the first argument to<TT> scrollactivepgup</TT>
was called with an argument whose type was<B> int</B>, it would first be converted to<B> char</B> before assigning it to register
CH.&nbsp; Similarly, if an in-line function required its argument in register EAX and the argument was of type<B> short int</B>,
the argument would be converted to<B> long int</B> before assigning it to register EAX.
<BR><BR>In general, Open Watcom C/C++ assigns the following types to register sets.
<OL>
<LI>A register set consisting of a single 8-bit register (1 byte) is assigned a type of<B> unsigned char</B>.
<LI>A register set consisting of a single 16-bit register (2 bytes) is assigned a type of<B> unsigned short int</B>.
<LI>A register set consisting of a single 32-bit register (4 bytes) is assigned a type of<B> unsigned long int</B>.
<LI>A register set consisting of two 32-bit registers (8 bytes) is assigned a type of<B> double</B>.
</OL>
<H4 ID="32Mbit__Removing_Arguments_from_the_Stack"> 32-bit:&nbsp; Removing Arguments from the Stack </H4>
<BR>The following form of the auxiliary pragma specifies who removes from the stack arguments that were pushed on the stack.
&nbsp;
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux </TT><B>sym</B><TT> parm </TT><B>(</B><TT>caller </TT><B>|</B><TT> routine</TT><B>)</B><TT>
</TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a function name.
</DL>
<BR>&quot;caller&quot; specifies that the caller will pop the arguments from the stack; &quot;routine&quot; specifies that
the called routine will pop the arguments from the stack.&nbsp; If &quot;caller&quot; or &quot;routine&quot; is omitted, &quot;routine&quot;
is assumed unless the default has been changed in a previous auxiliary pragma, in which case the new default is assumed.
<H4 ID="32Mbit__Passing_Arguments_in_Reverse_Order"> 32-bit:&nbsp; Passing Arguments in Reverse Order </H4>
<BR>The following form of the auxiliary pragma specifies that arguments are passed in the reverse order.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux </TT><B>sym</B><TT> parm reverse </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a function name.
</DL>
<BR>Normally, arguments are processed from left to right.&nbsp; The leftmost arguments are passed in registers and the rightmost
arguments are passed on the stack (if the registers used for argument passing have been exhausted).&nbsp; Arguments that are
passed on the stack are pushed from right to left.
<BR><BR>When arguments are reversed, the rightmost arguments are passed in registers and the leftmost arguments are passed
on the stack (if the registers used for argument passing have been exhausted).&nbsp; Arguments that are passed on the stack
are pushed from left to right.
<BR><BR>Reversing arguments is most useful for functions that require arguments to be passed on the stack in an order opposite
from the default.&nbsp; The following auxiliary pragma demonstrates such a function.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux rtn parm reverse [];</TT>
<H3 ID="32Mbit__Describing_Function_Return_Information"> 32-bit:&nbsp; Describing Function Return Information </H3>
<BR>Using auxiliary pragmas, you can describe the way functions are to return values.&nbsp; This is particularly useful when
interfacing to functions that have been compiled by other compilers or functions written in other programming languages.
<BR><BR>The general form of an auxiliary pragma that describes the way a function returns its value is the following.&nbsp;

<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux </TT><B>sym</B><TT> value </TT><B>{</B><TT>no8087 </TT><B>|</B><TT> </TT><B>reg_set</B><TT>
</TT><B>|</B><TT> </TT><B>struct_info}</B><TT> </TT><B>[</B><TT>;</TT><B>]</B>
<BR><BR><B>&nbsp;&nbsp;&nbsp;&nbsp; struct_info ::=</B><TT> struct </TT><B>{</B><TT>float </TT><B>|</B><TT> struct </TT><B>|</B><TT>
</TT><B>(</B><TT>routine </TT><B>|</B><TT> caller</TT><B>)</B><TT> </TT><B>|</B><TT> </TT><B>reg_set}</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a function name.
<DT>reg_set
<DD>is called a register set.&nbsp; The register sets specify the registers that are to be used for argument passing.&nbsp; A
register set is a list of registers separated by spaces and enclosed in square brackets.
</DL>
<H4 ID="32Mbit__Returning_Function_Values_in_Registers"> 32-bit:&nbsp; Returning Function Values in Registers </H4>
<BR>The following form of the auxiliary pragma can be used to specify the registers that are to be used to return a function's
value.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux </TT><B>sym</B><TT> value </TT><B>reg_set</B><TT> </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a function name.
<DT>reg_set
<DD>is a register set.
</DL>
<BR>Note that the method described below for returning values of type<B> float</B> or<B> double</B> is supported only when
the &quot;fpc&quot; option is used.
<BR><BR>Depending on the type of the return value, only certain registers are allowed in<B> reg_set.</B>
<DL>
<DT>1-byte
<DD>For 1-byte return values, only the following registers are allowed:&nbsp; AL, AH, DL, DH, BL, BH, CL or CH.&nbsp; If no register
set is specified, register AL will be used.
<DT>2-byte
<DD>For 2-byte return values, only the following registers are allowed:&nbsp; AX, DX, BX, CX, SI or DI.&nbsp; If no register set
is specified, register AX will be used.
<DT>4-byte
<DD>For 4-byte return values (including near pointers), only the following register are allowed:&nbsp; EAX, EDX, EBX, ECX, ESI
or EDI.&nbsp; If no register set is specified, register EAX will be used.&nbsp; This form of the auxiliary pragma is legal
for functions of type<B> float</B> when using the &quot;fpc&quot; option only.
<DT>far pointer
<DD>For functions that return far pointers, the following register pairs are allowed:&nbsp; DX:EAX, CX:EBX, CX:EAX, CX:ESI, DX:EBX,
DI:EAX, CX:EDI, DX:ESI, DI:EBX, SI:EAX, CX:EDX, DX:EDI, DI:ESI, SI:EBX, BX:EAX, FS:ECX, FS:EDX, FS:EDI, FS:ESI, FS:EBX, FS:EAX,
GS:ECX, GS:EDX, GS:EDI, GS:ESI, GS:EBX, GS:EAX, DS:ECX, DS:EDX, DS:EDI, DS:ESI, DS:EBX, DS:EAX, ES:ECX, ES:EDX, ES:EDI, ES:ESI,
ES:EBX or ES:EAX.&nbsp; If no register set is specified, the registers DX:EAX will be used.
<DT>8-byte
<DD>For 8-byte return values (including functions of type<B> double</B>), only the following register pairs are allowed:&nbsp;
EDX:EAX, ECX:EBX, ECX:EAX, ECX:ESI, EDX:EBX, EDI:EAX, ECX:EDI, EDX:ESI, EDI:EBX, ESI:EAX, ECX:EDX, EDX:EDI, EDI:ESI, ESI:EBX
or EBX:EAX.&nbsp; If no register set is specified, the registers EDX:EAX will be used.&nbsp; This form of the auxiliary pragma
is legal for functions of type<B> double</B> when using the &quot;fpc&quot; option only.
</DL>
<BR><B>Notes:</B>
<OL>
<LI>An empty register set is not allowed.
<LI>If you are compiling for a memory model which has a small data model, any of the above register combinations containing
register DS becomes illegal.&nbsp; In a small data model, segment register DS must remain unchanged as it points to the program's
data segment.
<LI>If you are compiling for the flat memory model, any register combination containing DS or ES becomes illegal.&nbsp; In
a flat memory model, code and data reside in the same segment.&nbsp; Segment registers DS and ES point to this segment and
must remain unchanged.
</OL>
<H4 ID="32Mbit__Returning_Structures"> 32-bit:&nbsp; Returning Structures </H4>
<BR>Typically, structures are not returned in registers.&nbsp; Instead, the caller allocates space on the stack for the return
value and sets register ESI to point to it.&nbsp; The called routine then places the return value at the location pointed
to by register ESI.
<BR><BR>The following form of the auxiliary pragma can be used to specify the register that is to be used to point to the
return value.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux </TT><B>sym</B><TT> value struct </TT><B>(</B><TT>caller</TT><B>|</B><TT>routine</TT><B>)</B><TT>
</TT><B>reg_set</B><TT> </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a function name.
<DT>reg_set
<DD>is a register set.
</DL>
<BR>&quot;caller&quot; specifies that the caller will allocate memory for the return value.&nbsp; The address of the memory
allocated for the return value is placed in the register specified in the register set by the caller before the function is
called.&nbsp; If an empty register set is specified, the address of the memory allocated for the return value will be pushed
on the stack immediately before the call and will be returned in register EAX by the called routine.
<BR><BR>&quot;routine&quot; specifies that the called routine will allocate memory for the return value.&nbsp; Upon returning
to the caller, the register specified in the register set will contain the address of the return value.&nbsp; An empty register
set is not allowed.
<BR><BR>Only the following registers are allowed in the register set:&nbsp; EAX, EDX, EBX, ECX, ESI or EDI.&nbsp; Note that
in a big data model, the address in the return register is assumed to be in the segment specified by the value in the SS segment
register.
<BR><BR>If the size of the structure being returned is 1, 2 or 4 bytes, it will be returned in registers.&nbsp; The return
register will be selected from the register set in the following way.
<OL>
<LI>A 1-byte structure will be returned in one of the following registers:&nbsp; AL, AH, DL, DH, BL, BH, CL or CH.&nbsp; If
no register set is specified, register AL will be used.
<LI>A 2-byte structure will be returned in one of the following registers:&nbsp; AX, DX, BX, CX, SI or DI.&nbsp; If no register
set is specified, register AX will be used.
<LI>A 4-byte structure will be returned in one of the following registers:&nbsp; EAX, EDX, EBX, ECX, ESI or EDI.&nbsp; If
no register set is specified, register EAX will be used.
</OL>
<BR>The following form of the auxiliary pragma can be used to specify that structures whose size is 1, 2 or 4 bytes are not
to be returned in registers.&nbsp; Instead, the caller will allocate space on the stack for the structure return value and
point register ESI to it.
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux </TT><B>sym</B><TT> value struct struct </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a function name.
</DL>
<H4 ID="32Mbit__Returning_FloatingMPoint_Data"> 32-bit:&nbsp; Returning Floating-Point Data </H4>
<BR>There are a few ways available for specifying how the value for a function whose type is<B> float</B> or<B> double</B>
is to be returned.
<BR><BR>The following form of the auxiliary pragma can be used to specify that function return values whose type is<B> float</B>
or<B> double</B> are not to be returned in registers.&nbsp; Instead, the caller will allocate space on the stack for the return
value and point register ESI to it.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux </TT><B>sym</B><TT> value struct float </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a function name.
</DL>
<BR>In other words, floating-point values are to be returned in the same way structures are returned.
<BR><BR>The following form of the auxiliary pragma can be used to specify that function return values whose type is<B> float</B>
or<B> double</B> are not to be returned in 80x87 registers when compiling with the &quot;fpi&quot; or &quot;fpi87&quot; option.
&nbsp;Instead, the value will be returned in 80x86 registers.&nbsp; This is the default behaviour for the &quot;fpc&quot;
option.&nbsp; Function return values whose type is<B> float</B> will be returned in register EAX.&nbsp; Function return values
whose type is<B> double</B> will be returned in registers EDX:EAX.&nbsp; This is the default method for the &quot;fpc&quot;
option.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux </TT><B>sym</B><TT> value no8087 </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a function name.
</DL>
<BR>The following form of the auxiliary pragma can be used to specify that function return values whose type is<B> float</B>
or<B> double</B> are to be returned in ST(0) when compiling with the &quot;fpi&quot; or &quot;fpi87&quot; option.&nbsp; This
form of the auxiliary pragma is not legal for the &quot;fpc&quot; option.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux </TT><B>sym</B><TT> value [8087] </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a function name.
</DL>
<H3 ID="32Mbit__A_Function_that_Never_Returns"> 32-bit:&nbsp; A Function that Never Returns </H3>
<BR>The following form of the auxiliary pragma can be used to describe a function that does not return to the caller.&nbsp;

<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux </TT><B>sym</B><TT> aborts </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a function name.
</DL>
<BR>Consider the following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux exitrtn aborts;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern void exitrtn(void);</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void rtn()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exitrtn();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>exitrtn</TT> is defined to be a function that does not return.&nbsp; For example, it may call<TT> exit</TT> to
return to the system.&nbsp; In this case, Open Watcom C/C++ generates a &quot;jmp&quot; instruction instead of a &quot;call&quot;
instruction to invoke<TT> exitrtn.</TT>
<H3 ID="32Mbit__Describing_How_Functions_Use_Memory"> 32-bit:&nbsp; Describing How Functions Use Memory </H3>
<BR>The following form of the auxiliary pragma can be used to describe a function that does not modify any memory (i.e., global
or static variables) that is used directly or indirectly by the caller.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux </TT><B>sym</B><TT> modify nomemory </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a function name.
</DL>
<BR>Consider the following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma off (check_stack);</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern void myrtn(void);</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int i = { 1033 };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern Rtn() {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( i &lt; 10000 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i += 383;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myrtn();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i += 13143;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR>To compile the above program, &quot;rtn.c&quot;, we issue the following command.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wcc rtn -oai -d1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wpp rtn -oai -d1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wcc386 rtn -oai -d1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wpp386 rtn -oai -d1</TT>
<BR><BR>For illustrative purposes, we omit loop optimizations from the list of code optimizations that we want the compiler
to perform.&nbsp; The &quot;d1&quot; compiler option is specified so that the object file produced by Open Watcom C/C++ contains
source line information.
<BR><BR>We can generate a file containing a disassembly of<TT> rtn.obj</TT> by issuing the following command.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wdis rtn -l -s -r</TT>
<BR><BR>The &quot;s&quot; option is specified so that the listing file produced by the Open Watcom Disassembler contains source
lines taken from<TT> rtn.c.</TT>&nbsp; The listing file<TT> rtn.lst</TT> appears as follows.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Module: rtn.c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Group: 'DGROUP' CONST,_DATA</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Segment: '_TEXT' BYTE USE32&nbsp; 00000036 bytes</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma off (check_stack);</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern void myrtn(void);</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int i = { 1033 };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern Rtn() {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0000&nbsp; 52&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; Rtn_&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; EDX</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0001&nbsp; 8b 15 00 00 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; EDX,_i</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( i &lt; 10000 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0007&nbsp; 81 fa 10 27 00 00 L1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; cmp&nbsp;&nbsp;&nbsp;&nbsp; EDX,00002710H</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 000d&nbsp; 7d 08&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jge&nbsp;&nbsp;&nbsp;&nbsp;
L2</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i += 383;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 000f&nbsp; 81 c2 7f 01 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add&nbsp;&nbsp;&nbsp;&nbsp; EDX,0000017fH</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0015&nbsp; eb f0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jmp&nbsp;&nbsp;&nbsp;&nbsp;
L1</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myrtn();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0017&nbsp; 89 15 00 00 00 00 L2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; _i,EDX</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 001d&nbsp; e8 00 00 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call&nbsp;&nbsp;&nbsp; myrtn_</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0022&nbsp; 8b 15 00 00 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; EDX,_i</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i += 13143;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0028&nbsp; 81 c2 57 33 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add&nbsp;&nbsp;&nbsp;&nbsp; EDX,00003357H</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 002e&nbsp; 89 15 00 00 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; _i,EDX</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0034&nbsp; 5a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;
&nbsp; EDX</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0035&nbsp; c3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; No disassembly errors</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ------------------------------------------------------------</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Segment: '_DATA' WORD USE32&nbsp; 00000004 bytes</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0000&nbsp; 09 04 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; _i&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - ....</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; No disassembly errors</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ------------------------------------------------------------</TT>
<BR><BR>Let us add the following auxiliary pragma to the source file.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux myrtn modify nomemory;</TT>
<BR><BR>If we compile the source file with the above pragma and disassemble the object file using the Open Watcom Disassembler,
we get the following listing file.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Module: rtn.c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Group: 'DGROUP' CONST,_DATA</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Segment: '_TEXT' BYTE USE32&nbsp; 00000030 bytes</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma off (check_stack);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux myrtn modify nomemory;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern void myrtn(void);</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int i = { 1033 };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern Rtn() {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0000&nbsp; 52&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; Rtn_&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; EDX</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0001&nbsp; 8b 15 00 00 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; EDX,_i</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( i &lt; 10000 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0007&nbsp; 81 fa 10 27 00 00 L1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; cmp&nbsp;&nbsp;&nbsp;&nbsp; EDX,00002710H</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 000d&nbsp; 7d 08&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jge&nbsp;&nbsp;&nbsp;&nbsp;
L2</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i += 383;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 000f&nbsp; 81 c2 7f 01 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add&nbsp;&nbsp;&nbsp;&nbsp; EDX,0000017fH</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0015&nbsp; eb f0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jmp&nbsp;&nbsp;&nbsp;&nbsp;
L1</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myrtn();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0017&nbsp; 89 15 00 00 00 00 L2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; _i,EDX</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 001d&nbsp; e8 00 00 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call&nbsp;&nbsp;&nbsp; myrtn_</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i += 13143;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0022&nbsp; 81 c2 57 33 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add&nbsp;&nbsp;&nbsp;&nbsp; EDX,00003357H</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0028&nbsp; 89 15 00 00 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; _i,EDX</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 002e&nbsp; 5a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;
&nbsp; EDX</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 002f&nbsp; c3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; No disassembly errors</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ------------------------------------------------------------</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Segment: '_DATA' WORD USE32&nbsp; 00000004 bytes</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0000&nbsp; 09 04 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; _i&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - ....</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; No disassembly errors</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ------------------------------------------------------------</TT>
<BR><BR>Notice that the value of<TT> i</TT> is in register EDX after completion of the &quot;while&quot; loop.&nbsp; After
the call to<TT> myrtn,</TT> the value of<TT> i</TT> is not loaded from memory into a register to perform the final addition.
&nbsp;The auxiliary pragma informs the compiler that<TT> myrtn</TT> does not modify any memory (i.e., global or static variables)
that is used directly or indirectly by<TT> Rtn</TT> and hence register EDX contains the correct value of<TT> i.</TT>
<BR><BR>The preceding auxiliary pragma deals with routines that modify memory.&nbsp; Let us consider the case where routines
reference memory.&nbsp; The following form of the auxiliary pragma can be used to describe a function that does not reference
any memory (i.e., global or static variables) that is used directly or indirectly by the caller.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux </TT><B>sym</B><TT> parm nomemory modify nomemory </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a function name.
</DL>
<BR><B>Notes:</B>
<OL>
<LI>You must specify both &quot;parm nomemory&quot; and &quot;modify nomemory&quot;.
</OL>
<BR>Let us replace the auxiliary pragma in the above example with the following auxiliary pragma.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux myrtn parm nomemory modify nomemory;</TT>
<BR><BR>If you now compile our source file and disassemble the object file using WDIS, the result is the following listing
file.
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Module: rtn.c</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Group: 'DGROUP' CONST,_DATA</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Segment: '_TEXT' BYTE USE32&nbsp; 0000002a bytes</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma off (check_stack);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux myrtn parm nomemory modify nomemory;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern void myrtn(void);</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int i = { 1033 };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern Rtn() {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0000&nbsp; 52&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; Rtn_&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; EDX</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0001&nbsp; 8b 15 00 00 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; EDX,_i</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( i &lt; 10000 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0007&nbsp; 81 fa 10 27 00 00 L1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; cmp&nbsp;&nbsp;&nbsp;&nbsp; EDX,00002710H</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 000d&nbsp; 7d 08&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jge&nbsp;&nbsp;&nbsp;&nbsp;
L2</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i += 383;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 000f&nbsp; 81 c2 7f 01 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add&nbsp;&nbsp;&nbsp;&nbsp; EDX,0000017fH</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0015&nbsp; eb f0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jmp&nbsp;&nbsp;&nbsp;&nbsp;
L1</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myrtn();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0017&nbsp; e8 00 00 00 00&nbsp;&nbsp;&nbsp; L2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call&nbsp;&nbsp;&nbsp; myrtn_</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i += 13143;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 001c&nbsp; 81 c2 57 33 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add&nbsp;&nbsp;&nbsp;&nbsp; EDX,00003357H</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0022&nbsp; 89 15 00 00 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; _i,EDX</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0028&nbsp; 5a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;
&nbsp; EDX</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0029&nbsp; c3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; No disassembly errors</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ------------------------------------------------------------</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Segment: '_DATA' WORD USE32&nbsp; 00000004 bytes</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0000&nbsp; 09 04 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; _i&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - ....</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; No disassembly errors</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ------------------------------------------------------------</TT>
<BR><BR>Notice that after completion of the &quot;while&quot; loop we did not have to update<TT> i</TT> with the value in
register EDX before calling<TT> myrtn.</TT>&nbsp; The auxiliary pragma informs the compiler that<TT> myrtn</TT> does not reference
any memory (i.e., global or static variables) that is used directly or indirectly by<TT> myrtn</TT> so updating<TT> i</TT>
was not necessary before calling<TT> myrtn.</TT>
<H3 ID="32Mbit__Describing_the_Registers_Modified_by_a_Function"> 32-bit:&nbsp; Describing the Registers Modified by a Function </H3>
<BR>The following form of the auxiliary pragma can be used to describe the registers that a function will use without saving.
&nbsp;
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux </TT><B>sym</B><TT> modify </TT><B>[</B><TT>exact</TT><B>]</B><TT> </TT><B>reg_set</B><TT>
</TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a function name.
<DT>reg_set
<DD>is a register set.
</DL>
<BR>Specifying a register set informs Open Watcom C/C++ that the registers belonging to the register set are modified by the
function.&nbsp; That is, the value in a register before calling the function is different from its value after execution of
the function.
<BR><BR>Registers that are used to pass arguments are assumed to be modified and hence do not have to be saved and restored
by the called function.&nbsp; Also, since the EAX register is frequently used to return a value, it is always assumed to be
modified.&nbsp; If necessary, the caller will contain code to save and restore the contents of registers used to pass arguments.
&nbsp;Note that saving and restoring the contents of these registers may not be necessary if the called function does not
modify them.&nbsp; The following form of the auxiliary pragma can be used to describe exactly those registers that will be
modified by the called function.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux </TT><B>sym</B><TT> modify exact </TT><B>reg_set</B><TT> </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a function name.
<DT>reg_set
<DD>is a register set.
</DL>
<BR>The above form of the auxiliary pragma tells Open Watcom C/C++ not to assume that the registers used to pass arguments
will be modified by the called function.&nbsp; Instead, only the registers specified in the register set will be modified.
&nbsp;This will prevent generation of the code which unnecessarily saves and restores the contents of the registers used to
pass arguments.
<BR><BR>Also, any registers that are specified in the<TT> value</TT> register set are assumed to be unmodified unless explicitly
listed in the<TT> exact</TT> register set.&nbsp; In the following example, the code generator will not generate code to save
and restore the value of the stack pointer register since we have told it that &quot;GetSP&quot; does not modify any register
whatsoever.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned GetSP(void);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #if defined(__386__)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux GetSP = value [esp] modify exact [];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #else</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux GetSP = value [sp] modify exact [];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #endif</TT>
<H3 ID="32Mbit__An_Example"> 32-bit:&nbsp; An Example </H3>
<BR>As mentioned in an earlier section, the following pragma defines the calling convention for functions compiled by MetaWare's
High C compiler.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux HIGH_C &quot;*&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; parm caller []&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; value no8087&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; modify [eax ecx edx fs gs];</TT>
<BR><BR>Note that register ES must also be specified in the &quot;modify&quot; register set when using a memory model with
a non-small data model.&nbsp; Let us discuss this pragma in detail.
<DL>
<DT>&quot;*&quot;
<DD>specifies that all function and variable names appear in object form as they do in source form.
<DT>parm caller []
<DD>specifies that all arguments are to be passed on the stack (an empty register set was specified) and the caller will remove
the arguments from the stack.
<DT>value no8087
<DD>specifies that floating-point values are to be returned using 80x86 registers and not 80x87 floating-point registers.
<DT>modify [eax ecx edx fs gs]
<DD>specifies that registers EAX, ECX, EDX, FS and GS are not preserved by the called routine.
</DL>
<BR>Note that the default method of returning integer values is used; 1-byte characters are returned in register AL, 2-byte
integers are returned in register AX, and 4-byte integers are returned in register EAX.
<H3 ID="32Mbit__Auxiliary_Pragmas_and_the_80x87"> 32-bit:&nbsp; Auxiliary Pragmas and the 80x87 </H3>
<BR>This section deals with those aspects of auxiliary pragmas that are specific to the 80x87.&nbsp; The discussion in this
chapter assumes that one of the &quot;fpi&quot; or &quot;fpi87&quot; options is used to compile functions.&nbsp; The following
areas are affected by the use of these options.
<OL>
<LI>passing floating-point arguments to functions,
<LI>returning floating-point values from functions and
<LI>which 80x87 floating-point registers are allowed to be modified by the called routine.
</OL>
<H4 ID="32Mbit__Using_the_80x87_to_Pass_Arguments"> 32-bit:&nbsp; Using the 80x87 to Pass Arguments </H4>
<BR>By default, floating-point arguments are passed on the 80x86 stack.&nbsp; The 80x86 registers are never used to pass floating-point
arguments when a function is compiled with the &quot;fpi&quot; or &quot;fpi87&quot; option.&nbsp; However, they can be used
to pass arguments whose type is not floating-point such as arguments of type &quot;int&quot;.
<BR><BR>The following form of the auxiliary pragma can be used to describe the registers that are to be used to pass arguments
to functions.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux </TT><B>sym</B><TT> parm </TT><B>{reg_set}</B><TT> </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a function name.
<DT>reg_set
<DD>is a register set.&nbsp; The register set can contain 80x86 registers and/or the string &quot;8087&quot;.
</DL>
<BR><B>Notes:</B>
<OL>
<LI>If an empty register set is specified, all arguments, including floating-point arguments, will be passed on the 80x86
stack.
</OL>
<BR>When the string &quot;8087&quot; appears in a register set, it simply means that floating-point arguments can be passed
in 80x87 floating-point registers if the source file is compiled with the &quot;fpi&quot; or &quot;fpi87&quot; option.&nbsp;
Before discussing argument passing in detail, some general notes on the use of the 80x87 floating-point registers are given.
<BR><BR>The 80x87 contains 8 floating-point registers which essentially form a stack.&nbsp; The stack pointer is called ST
and is a number between 0 and 7 identifying which 80x87 floating-point register is at the top of the stack.&nbsp; ST is initially
0.&nbsp; 80x87 instructions reference these registers by specifying a floating-point register number.&nbsp; This number is
then added to the current value of ST.&nbsp; The sum (taken modulo 8) specifies the 80x87 floating-point register to be used.
&nbsp;The notation ST(n), where &quot;n&quot; is between 0 and 7, is used to refer to the position of an 80x87 floating-point
register relative to ST.
<BR><BR>When a floating-point value is loaded onto the 80x87 floating-point register stack, ST is decremented (modulo 8),
and the value is loaded into ST(0).&nbsp; When a floating-point value is stored and popped from the 80x87 floating-point register
stack, ST is incremented (modulo 8) and ST(1) becomes ST(0).&nbsp; The following illustrates the use of the 80x87 floating-point
registers as a stack, assuming that the value of ST is 4 (4 values have been loaded onto the 80x87 floating-point register
stack).
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; | 4th from top&nbsp;&nbsp;
|&nbsp; ST(4)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp; | 5th from top&nbsp;&nbsp;
|&nbsp; ST(5)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp; | 6th from top&nbsp;&nbsp;
|&nbsp; ST(6)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp; | 7th from top&nbsp;&nbsp;
|&nbsp; ST(7)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; ST -&gt; 4&nbsp;&nbsp;&nbsp;&nbsp; | top of stack&nbsp;&nbsp; |&nbsp; ST(0)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5&nbsp;&nbsp;&nbsp;&nbsp; | 1st from top&nbsp;&nbsp;
|&nbsp; ST(1)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6&nbsp;&nbsp;&nbsp;&nbsp; | 2nd from top&nbsp;&nbsp;
|&nbsp; ST(2)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7&nbsp;&nbsp;&nbsp;&nbsp; | 3rd from top&nbsp;&nbsp;
|&nbsp; ST(3)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+</TT>
<BR><BR>Starting with version 9.5, the Open Watcom compilers use all eight of the 80x87 registers as a stack.&nbsp; The initial
state of the 80x87 register stack is empty before a program begins execution.
<DL>
<DT>Note:
<DD>For compatibility with code compiled with version 9.0 and earlier, you can compile with the &quot;fpr&quot; option.&nbsp;
In this case only four of the eight 80x87 registers are used as a stack.&nbsp; These four registers were used to pass arguments.
&nbsp;The other four registers form what was called the 80x87 cache.&nbsp; The cache was used for local floating-point variables.
&nbsp;The state of the 80x87 registers before a program began execution was as follows.
<OL>
<LI>The four 80x87 floating-point registers that form the stack are uninitialized.
<LI>The four 80x87 floating-point registers that form the 80x87 cache are initialized with zero.
</OL>
<BR>Hence, initially the 80x87 cache was comprised of ST(0), ST(1), ST(2) and ST(3).&nbsp; ST had the value 4 as in the above
diagram.&nbsp; When a floating-point value was pushed on the stack (as is the case when passing floating-point arguments),
it became ST(0) and the 80x87 cache was comprised of ST(1), ST(2), ST(3) and ST(4).&nbsp; When the 80x87 stack was full, ST(0),
ST(1), ST(2) and ST(3) formed the stack and ST(4), ST(5), ST(6) and ST(7) formed the 80x87 cache.&nbsp; Version 9.5 and later
no longer use this strategy.
</DL>
<BR>The rules for passing arguments are as follows.
<OL>
<LI>If the argument is not floating-point, use the procedure described earlier in this chapter.
<LI>If the argument is floating-point, and a previous argument has been assigned a position on the 80x86 stack (instead of
the 80x87 stack), the floating-point argument is also assigned a position on the 80x86 stack.&nbsp; Otherwise proceed to the
next step.
<LI>If the string &quot;8087&quot; appears in a register set in the pragma, and if the 80x87 stack is not full, the floating-point
argument is assigned floating-point register ST(0) (the top element of the 80x87 stack).&nbsp; The previous top element (if
there was one) is now in ST(1).&nbsp; Since arguments are pushed on the stack from right to left, the leftmost floating-point
argument will be in ST(0).&nbsp; Otherwise the floating-point argument is assigned a position on the 80x86 stack.
</OL>
<BR>Consider the following example.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux myrtn parm [8087];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float&nbsp;&nbsp;&nbsp; x;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double&nbsp;&nbsp; y;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long int j;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = 7.7;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = 7;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y = 77.77;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j = 77;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myrtn( x, i, y, j );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>myrtn</TT> is an assembly language function that requires four arguments.&nbsp; The first argument of type<B>
float</B> (4 bytes), the second argument is of type<B> int</B> (4 bytes), the third argument is of type<B> double</B> (8 bytes)
and the fourth argument is of type<B> long int</B> (4 bytes).&nbsp; These arguments will be passed to<TT> myrtn</TT> in the
following way.
<OL>
<LI>Since &quot;8087&quot; was specified in the register set, the first argument, being of type<B> float</B>, will be passed
in an 80x87 floating-point register.
<LI>The second argument will be passed on the stack since no 80x86 registers were specified in the register set.
<LI>The third argument will also be passed on the stack.&nbsp; Remember the following rule:&nbsp; once an argument is assigned
a position on the stack, all remaining arguments will be assigned a position on the stack.&nbsp; Note that the above rule
holds even though there are some 80x87 floating-point registers available for passing floating-point arguments.
<LI>The fourth argument will also be passed on the stack.
</OL>
<BR>Let us change the auxiliary pragma in the above example as follows.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux myrtn parm [eax 8087];</TT>
<BR><BR>The arguments will now be passed to<TT> myrtn</TT> in the following way.
<OL>
<LI>Since &quot;8087&quot; was specified in the register set, the first argument, being of type<B> float</B> will be passed
in an 80x87 floating-point register.
<LI>The second argument will be passed in register EAX, exhausting the set of available 80x86 registers for argument passing.
<LI>The third argument, being of type<B> double</B>, will also be passed in an 80x87 floating-point register.
<LI>The fourth argument will be passed on the stack since no 80x86 registers remain in the register set.
</OL>
<H4 ID="32Mbit__Using_the_80x87_to_Return_Function_Values"> 32-bit:&nbsp; Using the 80x87 to Return Function Values </H4>
<BR>The following form of the auxiliary pragma can be used to describe a function that returns a floating-point value in ST(0).
&nbsp;
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux </TT><B>sym</B><TT> value </TT><B>reg_set</B><TT> </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a function name.
<DT>reg_set
<DD>is a register set containing the string &quot;8087&quot;, i.e.&nbsp; [8087].
</DL>
<H4 ID="32Mbit__Preserving_80x87_FloatingMPoint_Registers_Across_Calls"> 32-bit:&nbsp; Preserving 80x87 Floating-Point Registers Across Calls </H4>
<BR>The code generator assumes that all eight 80x87 floating-point registers are available for use within a function unless
the &quot;fpr&quot; option is used to generate backward compatible code (older Open Watcom compilers used four registers as
a cache).&nbsp; The following form of the auxiliary pragma specifies that the floating-point registers in the 80x87 cache
may be modified by the specified function.&nbsp; 
<HR>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux </TT><B>sym</B><TT> modify </TT><B>reg_set</B><TT> </TT><B>[</B><TT>;</TT><B>]</B>
<HR>
<DL>
<DT>where
<DD><B>description</B>
<DT>sym
<DD>is a function name.
<DT>reg_set
<DD>is a register set containing the string &quot;8087&quot;, i.e.&nbsp; [8087].
</DL>
<BR>This instructs Open Watcom C/C++ to save any local variables that are located in the 80x87 cache before calling the specified
routine.
<H1 ID="InMline_Assembly_Language"> In-line Assembly Language </H1>
<BR><BR>The chapters entitled <A HREF="#16Mbit_Pragmas">16-bit Pragmas</A> and <A HREF="#32Mbit_Pragmas">32-bit Pragmas</A>
briefly describe the use of the auxiliary pragma to create a sequence of assembly language instructions that can be placed
anywhere executable C/C++ statements can appear in your source code.&nbsp; This chapter is devoted to an in-depth look at
in-line assembly language programming.
<BR><BR>The reasons for resorting to in-line assembly code are varied:
<UL>
<LI>Speed - You may be interested in optimizing a heavily-used section of code.
<LI>Size - You may wish to optimize a module for size by replacing a library function call with a direct system call.
<LI>Architecture - You may want to access certain features of the Intel x86 architecture that cannot be done so with C/C++
statements.
</UL>
<BR>There are also some reasons for not resorting to in-line assembly code.
<UL>
<LI>Portability - The code is not portable to different architectures.
<LI>Optimization - Sometimes an optimizing compiler can do a better job of arranging the instruction stream so that it is
optimal for a particular processor (such as the 486 or Pentium).
</UL>
<H2 ID="InMline_Assembly_Language_Default_Environment"> In-line Assembly Language Default Environment </H2>
<BR>In next table is description of the default in-line assembler environment in dependency on C/C++ compilers CPU switch
for x86 target platform.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Compiler&nbsp; CPU&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FPU&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; CPU extension</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; directive&nbsp; directive&nbsp;
directives</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; --------&nbsp; ---------&nbsp; ---------&nbsp; --------------------------</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .8086&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .8087</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .186&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .8087</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .286p&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .287</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .386p&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .387</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .486p&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .387</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .586p&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .387&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; .K3D+.MMX</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; -6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .686p&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .387&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; .K3D+.MMX+.XMM+.XMM2+.XMM3</TT>
<BR><BR>This environment can be simply changed by appropriate directives.
<BR><BR><B>Note:</B>
<BR><BR>This change is valid only for the block of assembly source code.&nbsp; After this block, default setting is restored.
<H2 ID="InMline_Assembly_Language_Tutorial"> In-line Assembly Language Tutorial </H2>
<BR>Doing in-line assembly is reasonably straight-forward with Open Watcom C/C++ although care must be exercised.&nbsp; You
can generate a sequence of in-line assembly anywhere in your C/C++ code stream.&nbsp; The first step is to define the sequence
of instructions that you wish to place in-line.&nbsp; The auxiliary pragma is used to do this.&nbsp; Here is a simple example
based on a DOS function call that returns a far pointer to the Double-Byte Character Set (DBCS) encoding table.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern unsigned short far *dbcs_table( void );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux dbcs_table = \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mov ax,6300h&quot;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;int 21h&quot;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __value&nbsp; [ds si] \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __modify [ax];</TT>
<BR><BR>To set up the DOS call, the AH register must contain the hexadecimal value &quot;63&quot; (63h).&nbsp; A DOS function
call is invoked by interrupt 21h.&nbsp; DOS returns a far pointer in DS:SI to a table of byte pairs in the form (start of
range, end of range).&nbsp; On a non-DBCS system, the first pair will be (0,0).&nbsp; On a Japanese DBCS system, the first
pair will be (81h,9Fh).
<BR><BR>With each pragma, we define a corresponding function prototype that explains the behaviour of the function in terms
of C/C++.&nbsp; Essentially, it is a function that does not take any arguments and that returns a far pointer to a unsigned
short item.
<BR><BR>The pragma indicates that the result of this &quot;function&quot; is returned in DS:SI (value [ds si]).&nbsp; The
pragma also indicates that the AX register is modified by the sequence of in-line assembly code (modify [ax]).
<BR><BR>Having defined our in-line assembly code, let us see how it is used in actual C code.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern unsigned short far *dbcs_table( void );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux dbcs_table = \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mov ax,6300h&quot;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;int 21h&quot;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __value&nbsp; [ds si] \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __modify [ax];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( *dbcs_table() != 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; we are running on
a DOS system that</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; supports double-byte
characters</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;DBCS supported\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>Before you attempt to compile and run this example, consider this:&nbsp; The program will not work!&nbsp; At least,
it will not work in most 16-bit memory models.&nbsp; And it doesn't work at all in 32-bit protected mode using a DOS extender.
&nbsp;What is wrong with it?
<BR><BR>We can examine the disassembled code for this program in order to see why it does not always work in 16-bit real-mode
applications.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( *dbcs_table() != 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; we are running on
a DOS system that</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; supports double-byte
characters</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0007&nbsp; b8 00 63&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax,6300H</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 000a&nbsp; cd 21&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;
21H</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 000c&nbsp; 83 3c 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmp&nbsp;&nbsp;&nbsp;&nbsp; word ptr [si],0000H</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 000f&nbsp; 74 0a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; je&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;L1</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;DBCS supported\n&quot;
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0011&nbsp; be 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; si,offset L2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0014&nbsp; 56&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;
&nbsp;si</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0015&nbsp; e8 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call&nbsp;&nbsp;&nbsp; printf_</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0018&nbsp; 83 c4 02&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add&nbsp;&nbsp;&nbsp;&nbsp; sp,0002H</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>After the DOS interrupt call, the DS register has been altered and the code generator does nothing to recover the
previous value.&nbsp; In the small memory model, the contents of the DS register never change (and any code that causes a
change to DS must save and restore its value).&nbsp; It is the programmer's responsibility to be aware of the restrictions
imposed by certain memory models especially with regards to the use of segmentation registers.&nbsp; So we must make a small
change to the pragma.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern unsigned short far *dbcs_table( void );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux dbcs_table = \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;push ds&quot;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mov ax,6300h&quot;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;int 21h&quot;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mov di,ds&quot;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;\</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;pop ds&quot;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __value&nbsp; [di si] \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __modify [ax];</TT>
<BR><BR>If we compile and run this example with a 16-bit compiler, it will work properly.&nbsp; We can examine the disassembled
code for this revised program.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( *dbcs_table() != 0 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; we are running on
a DOS system that</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; supports double-byte
characters</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0008&nbsp; 1e&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;
&nbsp;ds</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0009&nbsp; b8 00 63&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax,6300H</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 000c&nbsp; cd 21&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;
21H</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 000e&nbsp; 8c df&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp;
di,ds</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0010&nbsp; 1f&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;
&nbsp; ds</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0011&nbsp; 8e c7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp;
es,di</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0013&nbsp; 26 83 3c 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmp&nbsp;&nbsp;&nbsp;&nbsp; word ptr es:[si],0000H</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0017&nbsp; 74 0a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; je&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;L1</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;DBCS supported\n&quot;
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0019&nbsp; be 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; si,offset L2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 001c&nbsp; 56&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;
&nbsp;si</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 001d&nbsp; e8 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call&nbsp;&nbsp;&nbsp; printf_</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0020&nbsp; 83 c4 02&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add&nbsp;&nbsp;&nbsp;&nbsp; sp,0002H</TT>
<BR><BR>If you examine this code, you can see that the DS register is saved and restored by the in-line assembly code.&nbsp;
The code generator, having been informed that the far pointer is returned in (DI:SI), loads up the ES register from DI in
order to reference the far data correctly.
<BR><BR>That takes care of the 16-bit real-mode case.&nbsp; What about 32-bit protected mode?&nbsp; When using a DOS extender,
you must examine the accompanying documentation to see if the system call that you wish to make is supported by the DOS extender.
&nbsp;One of the reasons that this particular DOS call is not so clear-cut is that it returns a 16-bit real-mode segment:offset
pointer.&nbsp; A real-mode pointer must be converted by the DOS extender into a protected-mode pointer in order to make it
useful.&nbsp; As it turns out, neither the Tenberry Software DOS/4G(W) nor Phar Lap DOS extenders support this particular
DOS call (although others may).&nbsp; The issues with each DOS extender are complex enough that the relative merits of using
in-line assembly code are not worth it.&nbsp; We present an excerpt from the final solution to this problem.&nbsp; 
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #ifndef __386__</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern unsigned short far *dbcs_table( void );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux dbcs_table = \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;push ds&quot;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mov ax,6300h&quot;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;int 21h&quot;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mov di,ds&quot;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;\</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;pop ds&quot;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __value&nbsp; [di si] \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __modify [ax];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #else</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; unsigned short far * dbcs_table( void )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; union REGPACK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; regs;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static short&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dbcs_dummy
= 0;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memset( &amp;regs, 0, sizeof( regs ) );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( _IsPharLap() ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PHARLAP_block pblock;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memset( &amp;pblock, 0, sizeof( pblock
) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pblock.real_eax = 0x6300;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; /* get DBCS vector table */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pblock.int_num = 0x21;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* DOS call */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; regs.x.eax = 0x2511;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* issue real-mode interrupt */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; regs.x.edx = FP_OFF( &amp;pblock ); /* DS:EDX
-&gt; parameter block */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; regs.w.ds = FP_SEG( &amp;pblock );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; intr( 0x21, &amp;regs );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( firstmeg( pblock.real_ds, regs.w.si
) );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if( _IsDOS4G() ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DPMI_block dblock;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memset( &amp;dblock, 0, sizeof( dblock
) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dblock.eax = 0x6300;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* get DBCS vector table */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; regs.w.ax = 0x300;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* DPMI Simulate R-M intr */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; regs.h.bl = 0x21;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* DOS call */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; regs.h.bh = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* flags */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; regs.w.cx = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* # bytes from stack */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; regs.x.edi = FP_OFF( &amp;dblock );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; regs.x.es = FP_SEG( &amp;dblock );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; intr( 0x31, &amp;regs );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( firstmeg( dblock.ds, dblock.esi )
);</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( &amp;dbcs_dummy );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #endif</TT>
<BR><BR>The 16-bit version will use in-line assembly code but the 32-bit version will use a C function that has been crafted
to work with both Tenberry Software DOS/4G(W) and Phar Lap DOS extenders.&nbsp; The<TT> firstmeg</TT> function used in the
example is shown below.&nbsp; 
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define REAL_SEGMENT&nbsp;&nbsp;&nbsp; 0x34</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void far *firstmeg( unsigned segment, unsigned offset )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void far&nbsp;&nbsp;&nbsp; *meg1;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( _IsDOS4G() ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; meg1 = MK_FP( FP_SEG( &amp;meg1 ), ( segment
&lt;&lt; 4 ) + offset );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; meg1 = MK_FP( REAL_SEGMENT, ( segment &lt;&lt;
4 ) + offset );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( meg1 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>We have taken a brief look at two features of the auxiliary pragma, the &quot;modify&quot; and &quot;value&quot; attributes.
<BR><BR>The &quot;modify&quot; attribute describes those registers that are modified by the execution of the sequence of in-line
code.&nbsp; You usually have two choices here; you can save/restore registers that are affected by the code sequence in which
case they need not appear in the modify list or you can let the code generator handle the fact that the registers are modified
by the code sequence.&nbsp; When you invoke a system function (such as a DOS or BIOS call), you should be careful about any
side effects that the call has on registers.&nbsp; If a register is modified by a call and you have not listed it in the modify
list or saved/restored it, this can have a disastrous affect on the rest of the code in the function where you are including
the in-line code.
<BR><BR>The &quot;value&quot; attribute describes the register or registers in which a value is returned (we use the term
&quot;returned&quot;, not in the sense that a function returns a value, but in the sense that a result is available after
execution of the code sequence).
<BR><BR>This leads the discussion into the third feature of the auxiliary pragma, the feature that allows us to place the
results of C expressions into specific registers as part of the &quot;setup&quot; for the sequence of in-line code.&nbsp;
To illustrate this, let us look at another example.
<BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern void BIOSSetCurPos( unsigned short __rowcol,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char __page );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux BIOSSetCurPos =&nbsp;&nbsp;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;push bp&quot;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mov ah,2&quot;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;int 10h&quot;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;pop bp&quot;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __parm&nbsp;&nbsp; [dx] [bh]&nbsp;&nbsp;
&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __modify [ah];</TT>
<BR><BR>The &quot;parm&quot; attribute specifies the list of registers into which values are to be placed as part of the prologue
to the in-line code sequence.&nbsp; In the above example, the &quot;set cursor position&quot; function requires three pieces
of information.&nbsp; It requires that the cursor row value be placed in the DH register, that the cursor column value be
placed in the DL register, and that the screen page number be placed in the BH register.&nbsp; In this example, we have decided
to combine the row and column information into a single &quot;argument&quot; to the function.&nbsp; Note that the function
prototype for<TT> BIOSSetCurPos</TT> is important.&nbsp; It describes the types and number of arguments to be set up for the
in-line code.&nbsp; It also describes the type of the return value (in this case there is none).
<BR><BR>Once again, having defined our in-line assembly code, let us see how it is used in actual C code.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern void BIOSSetCurPos( unsigned short __rowcol,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char __page );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux BIOSSetCurPos =&nbsp;&nbsp;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;push bp&quot;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mov ah,2&quot;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;int 10h&quot;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;pop bp&quot;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __parm&nbsp;&nbsp; [dx] [bh]&nbsp;&nbsp;
&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __modify [ah];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BIOSSetCurPos( (5 &lt;&lt; 8) | 20, 0 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Hello world\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>To see how the code generator set up the register values for the in-line code, let us take a look at the disassembled
code.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BIOSSetCurPos( (5 &lt;&lt; 8) | 20, 0 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0008&nbsp; ba 14 05&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; dx,0514H</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 000b&nbsp; 30 ff&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xor&nbsp;&nbsp;&nbsp;&nbsp;
bh,bh</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 000d&nbsp; 55&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;
&nbsp;bp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 000e&nbsp; b4 02&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp;
ah,02H</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0010&nbsp; cd 10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;
10H</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0012&nbsp; 5d&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;
&nbsp; bp</TT>
<BR><BR>As we expected, the result of the expression for the row and column is placed in the DX register and the page number
is placed in the BH register.&nbsp; The remaining instructions are our in-line code sequence.
<BR><BR>Although our examples have been simple, you should be able to generalize them to your situation.
<BR><BR>To review, the &quot;parm&quot;, &quot;value&quot; and &quot;modify&quot; attributes are used to:
<OL>
<LI>convey information to the code generator about the way data values are to be placed in registers in preparation for the
code burst (parm),
<LI>convey information to the code generator about the result, if any, from the code burst (value), and
<LI>convey information to the code generator about any side effects to the registers after the code burst has executed (modify).
&nbsp;It is important to let the code generator know all of the side effects on registers when the in-line code is executed;
otherwise it assumes that all registers, other than those used for parameters, are preserved.&nbsp; In our examples, we chose
to push/pop some of the registers that are modified by the code burst.
</OL>
<H2 ID="Labels_in_InMline_Assembly_Code"> Labels in In-line Assembly Code </H2>
<BR>Labels can be used in in-line assembly code.&nbsp; Here is an example.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern void _disable_video( unsigned );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux _disable_video =&nbsp;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;again: in al,dx&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;test al,8&quot;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;jz again&quot;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mov dx,03c0h&quot;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mov al,11h&quot;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;out dx,al&quot;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mov al,0&quot;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;out dx,al&quot;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __parm [dx]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __modify [al dx];</TT>
<H2 ID="Variables_in_InMline_Assembly_Code"> Variables in In-line Assembly Code </H2>
<BR>To finish our discussion, we provide examples that illustrate the use of variables in the in-line assembly code.&nbsp;
The following example illustrates the use of static variable references in the auxiliary pragma.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static short&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _rowcol;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; static unsigned char _page;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; extern void BIOSSetCurPos( void );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #pragma aux BIOSSetCurPos =&nbsp;&nbsp;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mov&nbsp; dx,_rowcol&quot;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mov&nbsp; bh,_page&quot;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;push bp&quot;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mov ah,2&quot;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;int 10h&quot;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;pop bp&quot;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __modify [ah bx dx];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _rowcol = (5 &lt;&lt; 8) | 20;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _page = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BIOSSetCurPos();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Hello world\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The only rule to follow here is that the auxiliary pragma must be defined after the variables are defined.&nbsp; The
in-line assembler is passed information regarding the sizes of variables so they must be defined first.
<BR><BR>If we look at a fragment of the disassembled code, we can see the result.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _rowcol = (5 &lt;&lt; 8) | 20;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0008&nbsp; c7 06 00 00 14 05&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; word ptr __rowcol,0514H</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _page = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 000e&nbsp; c6 06 00 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; byte ptr __page,00H</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BIOSSetCurPos();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0013&nbsp; 8b 16 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; dx,__rowcol</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0017&nbsp; 8a 3e 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; bh,__page</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 001b&nbsp; 55&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;
&nbsp;bp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 001c&nbsp; b4 02&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp;
ah,02H</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 001e&nbsp; cd 10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;
10H</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0020&nbsp; 5d&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;
&nbsp; bp</TT>
<BR><BR>The following example illustrates the use of automatic variable references in the auxiliary pragma.&nbsp; Again, the
auxiliary pragma must be defined after the variables are defined so the pragma is placed in-line with the function.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _rowcol;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char _page;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; extern void BIOSSetCurPos( void );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp; pragma aux&nbsp; BIOSSetCurPos = \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mov&nbsp; dx,_rowcol&quot;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mov&nbsp; bh,_page&quot;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;push bp&quot;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mov ah,2&quot;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;int 10h&quot;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;pop bp&quot;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __modify [ah bx dx];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _rowcol = (5 &lt;&lt; 8) | 20;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _page = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BIOSSetCurPos();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Hello world\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>If we look at a fragment of the disassembled code, we can see the result.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _rowcol = (5 &lt;&lt; 8) | 20;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 000e&nbsp; c7 46 fc 14 05&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; word ptr -4H[bp],0514H</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _page = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0013&nbsp; c6 46 fe 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; byte ptr -2H[bp],00H</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BIOSSetCurPos();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0017&nbsp; 8b 96 fc ff&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; dx,-4H[bp]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 001b&nbsp; 8a be fe ff&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; bh,-2H[bp]</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 001f&nbsp; 55&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;
&nbsp;bp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0020&nbsp; b4 02&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp;
ah,02H</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0022&nbsp; cd 10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;
10H</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0024&nbsp; 5d&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;
&nbsp; bp</TT>
<BR><BR>You should try to avoid references to automatic variables as illustrated by this last example.&nbsp; Referencing automatic
variables in this manner causes them to be marked as volatile and the optimizer will not be able to do a good job of optimizing
references to these variables.
<H2 ID="InMline_Assembly_Language_using__asm"> In-line Assembly Language using _asm </H2>
<BR>There is an alternative to Open Watcom's auxiliary pragma method for creating in-line assembly code.&nbsp; You can use
one of the<B><I> _asm</I></B> or<B><I> __asm</I></B> keywords to imbed assembly code into the generated code.&nbsp; The following
is a revised example of the cursor positioning example introduced above.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned short _rowcol;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char _page;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _rowcol = (5 &lt;&lt; 8) | 20;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _page = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _asm {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; dx,_rowcol</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; bh,_page</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; bp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ah,2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; 10h</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;&nbsp;&nbsp; bp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Hello world\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The assembly language sequence can reference program variables to retrieve or store results.&nbsp; There are a few
incompatibilities between Microsoft and Open Watcom implementation of this directive.
<DL>
<DT>__LOCAL_SIZE
<DD>is not supported by Open Watcom C/C++.&nbsp; This is illustrated in the following example.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int i;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int j;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _asm {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; bp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; bp,sp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sub&nbsp;&nbsp;&nbsp;&nbsp; sp,__LOCAL_SIZE</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<DT>structure
<DD>references are not supported by Open Watcom C/C++.&nbsp; This is illustrated in the following example.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; struct rowcol {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char col;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char row;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main()</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct rowcol _pos;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char _page;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _pos.row = 5;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _pos.col = 20;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _page = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _asm {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; dl,_pos.col</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; dh,_pos.row</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; bh,_page</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; bp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ah,2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; 10h</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;&nbsp;&nbsp; bp</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Hello world\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
</DL>
<H2 ID="InMline_Assembly_Directives_and_Opcodes"> In-line Assembly Directives and Opcodes </H2>
<BR>It is not the intention of this chapter to describe assembly-language programming in any detail.&nbsp; You should consult
a book that deals with this topic.&nbsp; However, we present a list of the directives, opcodes and register names that are
recognized by the assembler built into the compiler's auxiliary pragma processor.&nbsp; 
<BR><BR><TT>.186&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .286&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; .286c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .286p&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;.287&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .386&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; .386p&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .387&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;.486&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .486p&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;.586&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .586p&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;.686&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .686p&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;.8086&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .8087&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
byte&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; dd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; df&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dq&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
dup&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; dword&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; far&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; .k3d&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .mmx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; near&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .no87&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; offset&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oword&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ptr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pword&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;qword&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; seg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; tbyte&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; word&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;.xmm&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .xmm2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;.xmm3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><BR><TT>aaa&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aad&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; aam&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aas&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; adc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addpd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addps&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addsd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addss&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; addsubpd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addsubps&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; andnpd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; andnps&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; andpd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; andps&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; arpl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bound&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; bp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsf&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bswap&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; btc&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; btr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
bts&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; callf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cbw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; cdq&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; cld&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clflush&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; cli&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clts&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; cmc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmova&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; cmovae&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmovb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;cmovbe&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmovc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmove
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmovg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmovge&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmovl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmovle&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; cmovna&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmovnae&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;cmovnb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmovnbe&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmovnc&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmovne&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmovng&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; cmovnge&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmovnl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
cmovnle&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmovno&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmovnp&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmovns&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmovnz&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; cmovo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmovp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;cmovpe&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmovpo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmovs
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmovz&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmp&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmpeqpd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmpeqps&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; cmpeqsd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmpeqss&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmplepd
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmpleps&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmplesd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; cmpless&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmpltpd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmpltps&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; cmpltsd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmpltss&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
cmpneqpd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmpneqps&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmpneqsd&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; cmpneqss&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmpnlepd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmpnleps&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; cmpnlesd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmpnless&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmpnltpd&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; cmpnltps&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmpnltsd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmpnltss&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; cmpordpd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmpordps&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmpordsd
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmpordss&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmppd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; cmpps&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmps&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;cmpsb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmpsd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
cmpss&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmpsw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmpunordpd
&nbsp;&nbsp;&nbsp; cmpunordps&nbsp;&nbsp;&nbsp;&nbsp; cmpunordsd&nbsp;&nbsp;&nbsp;&nbsp; cmpunordss&nbsp;&nbsp;&nbsp;&nbsp;
cmpxchg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmpxchg8b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; comisd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; comiss&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpuid&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;cvtdq2pd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cvtdq2ps&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cvtpd2dq&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; cvtpd2pi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cvtpd2ps&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cvtpi2pd&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; cvtpi2ps&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cvtps2dq&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cvtps2pd&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; cvtps2pi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cvtsd2si&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cvtsd2ss
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cvtsi2sd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cvtsi2ss&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cvtss2sd
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cvtss2si&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cvttpd2dq&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cvttpd2pi
&nbsp;&nbsp;&nbsp;&nbsp; cvttps2dq&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cvttps2pi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cvttsd2si&nbsp;&nbsp;
&nbsp; </TT>
<BR><TT>cvttss2si&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cwd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cwde
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; daa&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
das&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dec&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; div&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; divpd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; divps&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; divsd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;divss&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; emms&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;enter&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f2xm1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
fabs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fadd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;faddp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fbld&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;fbstp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fchs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;fclex&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fcmovb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fcmovbe
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fcmove&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fcmovnb&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; fcmovnbe&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fcmovne&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fcmovnu&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fcmovu&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fcom&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; fcomi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fcomip&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; fcomp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fcompp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
fcos&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fdecstp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fdisi&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fdiv&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fdivp&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fdivr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fdivrp&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; femms&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; feni&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; ffree&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fiadd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; ficom&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ficomp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
fidiv&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fidivr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fild&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fimul&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fincstp&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; finit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fist&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; fistp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fisttp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; fisub&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fisubr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;flat&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fld&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; fld1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fldcw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; fldenv&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fldenvd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fldenvw&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fldl2e&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fldl2t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; fldlg2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fldln2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
fldpi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fldz&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
fmul&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fmulp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
fnclex&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fndisi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fneni&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fninit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fnop&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fnrstor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fnrstord&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
fnrstorw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fnsave&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fnsaved&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; fnsavew&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fnstcw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
fnstenv&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fnstenvd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fnstenvw&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; fnstsw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fpatan&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
fprem&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprem1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fptan&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; frndint&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; frstor&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; frstord&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; frstorw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fsave
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fsaved&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fsavew&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fscale&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fsetpm&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; fsin&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fsincos&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;fsqrt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fst&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; fstcw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fstenv&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
fstenvd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fstenvw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fstp&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fstsw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fsub&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fsubp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fsubr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; fsubrp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ftst&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; fucom&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fucomi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
fucomip&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fucomp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fucompp&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; fwait&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fxam&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; fxch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fxrstor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; fxsave&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fxtract&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fyl2x&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fyl2xp1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; haddpd&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; haddps&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hlt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; </TT>
<BR><TT>hsubpd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hsubps&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; idiv
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; imul&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; ins&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; insb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; insd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; insw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; into&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; invd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; invlpg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; iret&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iretd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;iretdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iretf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ja
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jae&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; jb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jbe&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; jc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jcxz&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; je&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jecxz&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jge
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; jle&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jmp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; jmpf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jna&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; jnae&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jnb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jnbe&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jnc&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jne&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jng&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jnge&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jnl&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jnle&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jno
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jnp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;jns&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jnz&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; jo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jpe&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jpo&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; js&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
jz&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lahf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; lar&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lddqu&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; ldmxcsr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lds&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;lea&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; leave&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; les&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lfence&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;lfs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lgdt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; lgs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lidt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; lldt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lmsw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; lock&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lods&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; lodsb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lodsd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; lodsw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; loop&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;loopd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; loope&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
looped&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; loopew&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; loopne&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; loopned&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; loopnew&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; loopnz&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; loopnzd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; loopnzw&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; loopw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; loopz&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; loopzd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; loopzw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;lsl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lss&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; ltr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; maskmovdqu&nbsp;&nbsp;&nbsp;&nbsp;
maskmovq&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; maxpd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; maxps&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; maxsd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; maxss&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; mfence&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; minpd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; minps&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; minsd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;minss&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; monitor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movapd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movaps&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movddup&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; movdq2q&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movdqa&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;movdqu&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movhlps&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movhpd&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movhps&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movlhps&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; movlpd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movlps&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
movmskpd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movmskps&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movntdq&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; movnti&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movntpd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movntps
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movntq&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movq&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; movq2dq&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; movsb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movsd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;movshdup&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movsldup&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movss&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; movsw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movsx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; </TT>
<BR><TT>movupd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movups&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movzx
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mul&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mulpd
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mulps&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mulsd&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mulss&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mwait&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; near&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; neg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nop&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; not&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; orpd
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; orps&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; out
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
outsb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outsd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outsw
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; packssdw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; packsswb&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; packuswb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; paddb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; paddd&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; paddq&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; paddsb&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; paddsw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; paddusb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; paddusw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; paddw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pand
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pandn&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pavgb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pavgusb&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; pavgw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pcmpeqb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; pcmpeqd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pcmpeqw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pcmpgtb&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; pcmpgtd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pcmpgtw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
pextrw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pf2id&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pf2iw&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pfacc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pfadd&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pfcmpeq&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pfcmpge&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;pfcmpgt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pfmax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pfmin
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pfmul&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pfnacc&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pfpnacc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pfrcp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; pfrcpit1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pfrcpit2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pfrsqit1&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; pfrsqrt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pfsub&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; pfsubr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pi2fd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
pi2fw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pinsrw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pmaddwd
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pmaxsw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pmaxub&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; pminsw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pminub&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;pmovmskb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pmulhrw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pmulhuw&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; pmulhw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pmullw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;pmuludq&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
popa&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; popad&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
popf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; popfd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
por&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prefetch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prefetchnta
&nbsp;&nbsp; prefetcht0&nbsp;&nbsp;&nbsp;&nbsp; prefetcht1&nbsp;&nbsp;&nbsp;&nbsp; prefetcht2&nbsp;&nbsp;&nbsp;&nbsp; prefetchw
&nbsp;&nbsp;&nbsp;&nbsp; psadbw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pshufd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; pshufhw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pshuflw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pshufw&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pslld&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pslldq&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; psllq&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; psllw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; psrad&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; psraw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
psrld&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; psrldq&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; psrlq&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; psrlw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; psubb&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; psubd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; psubq&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; psubsb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; psubsw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;psubusb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; psubusw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; psubw&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pswapd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; punpckhbw&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;punpckhdq&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; punpckhqdq&nbsp;&nbsp;&nbsp;&nbsp; punpckhwd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; punpcklbw
&nbsp;&nbsp;&nbsp;&nbsp; punpckldq&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; punpcklqdq&nbsp;&nbsp;&nbsp;&nbsp; punpcklwd&nbsp;&nbsp;
&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pusha&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; pushad&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pushd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
pushf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pushfd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pushw&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pxor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rcl&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rcpps&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rcpss&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>rcr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rdmsr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; rdpmc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rdtsc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
rep&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; repe&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; repne&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; repnz&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
rept&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; repz&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;ret&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; retd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; retf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; retfd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; retn&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rol&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; ror&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rsm&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; rsqrtps&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rsqrtss&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
sahf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; sar&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sbb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; scas&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scasb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; scasd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scasw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;seta&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setae&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;setb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setbe&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;setc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sete&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; setg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setge&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;setl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setle&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;setna&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setnae&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setnb
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setnbe&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setnc&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setne&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setng&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; setnge&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setnl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; setnle&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setno&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;setnp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setns&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
setnz&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; seto&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
setp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setpe&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
setpo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sets&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
setz&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sfence&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sgdt
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; shl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
shld&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
shr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; shrd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; shufpd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; shufps&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sidt
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sldt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; smsw
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;sqrtpd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sqrtps&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sqrtsd
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sqrtss&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stc&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sti&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stmxcsr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stos&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stosb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stosd&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; stosw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; str&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; sub&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subpd&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; subps&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subsd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; subss&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sysenter&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sysexit
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; test&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ucomisd&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; ucomiss&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unpckhpd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unpckhps
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unpcklpd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unpcklps&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; verr
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; verw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wait
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wbinvd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wrmsr&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xadd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xchg&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xlat&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xlatb&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xorpd&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xorps&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><BR><TT>ah&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; al&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bh&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
bx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; cl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cr0&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cr2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cr3&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cr4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cs
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; dh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; di&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dr0&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dr1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dr2
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dr3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;dr6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dr7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; ds&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ebp&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ebx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ecx
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; edi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;edx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; es&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; esi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; esp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gs&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mm0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mm1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mm2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;mm3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mm4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; mm5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mm6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mm7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; si&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ss&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
st&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; st1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; st3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st4&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st6&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tr3
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tr4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;tr5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tr6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; tr7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xmm0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; xmm1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xmm2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; xmm3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xmm4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; xmm5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xmm6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; xmm7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><BR>A separate assembler is also included with this product and is described in the<B><I> Open Watcom C/C++ Tools User's
Guide</I></B>
<H1 ID="Structured_Exception_Handling"> Structured Exception Handling </H1>
<BR>Microsoft-style Structured Exception Handling (SEH) is supported by the Open Watcom C compiler only.&nbsp; MS SEH is supported
under the Win32, Win32s and OS/2 platforms.&nbsp; You should not confuse SEH with C++ exception handling.&nbsp; The Open Watcom
C++ compiler supports the standard C++ syntax for exception handling.
<BR><BR>The following sections introduce some of the aspects of SEH.&nbsp; For a good description of SEH, please refer to<B><I>
Advanced Windows NT</I></B> by Jeffrey Richter (Microsoft Press, 1994).&nbsp; You may also wish to read the article &quot;Clearer,
More Comprehensive Error Processing with Win32 Structured Exception Handling&quot; by Kevin Goodman in the January, 1994 issue
of Microsoft Systems Journal.
<H2 ID="Termination_Handlers"> Termination Handlers </H2>
<BR>We begin our look at SEH with a simple model.&nbsp; In this model, there are two blocks of code - the &quot;guarded&quot;
block and the &quot;termination&quot; block.&nbsp; The termination code is guaranteed to be executed regardless of how the
&quot;guarded&quot; block of code is exited (including execution of any &quot;return&quot; statement).
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _try {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* guarded code */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _finally {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* termination handler */</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The<B><I> _finally</I></B> block of code is guaranteed to be executed no matter how the guarded block is exited (<B><I>
break</I></B> ,<B><I> continue</I></B> ,<B><I> return</I></B> ,<B><I> goto</I></B> , or<B><I> longjmp</I></B> ).&nbsp; Exceptions
to this are calls to<B><I> abort</I></B> ,<B><I> exit</I></B> or<B><I> _exit</I></B> which terminate the execution of the
process.
<BR><BR>There can be no intervening code between<B> try</B> and<B> finally</B> blocks.
<BR><BR>The following is a contrived example of the use of<B><I> _try</I></B> and<B><I> _finally</I></B> .
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdlib.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;excpt.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int docopy( char *in, char *out )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FILE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *in_file = NULL;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FILE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *out_file = NULL;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buffer[256];</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _try {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in_file = fopen( in, &quot;r&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( in_file == NULL ) return( EXIT_FAILURE );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; out_file = fopen( out, &quot;w&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( out_file == NULL ) return( EXIT_FAILURE );</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( fgets((char *)buffer, 255, in_file) != NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fputs( (char *)buffer, out_file );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _finally {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( in_file != NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Closing input file\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( in_file );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( out_file != NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Closing output file\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( out_file );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;End of processing\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( EXIT_SUCCESS );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main( int argc, char **argv )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( argc &lt; 3 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Usage: mv [in_filename] [out_filename]\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit( EXIT_FAILURE );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit( docopy( argv[1], argv[2] ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The<B> try</B> block ignores the messy details of what to do when either one of the input or output files cannot be
opened.&nbsp; It simply tests whether a file can be opened and quits if it cannot.&nbsp; The<B> finally</B> block ensures
that the files are closed if they were opened, releasing the resources associated with open files.&nbsp; This simple example
could have been written in C without the use of SEH.
<BR><BR>There are two ways to enter the<B> finally</B> block.&nbsp; One way is to exit the<B> try</B> block using a statement
like<B><I> return</I></B> .&nbsp; The other way is to fall through the end of the<B> try</B> block and into the<B> finally</B>
block (the normal execution flow for this program).&nbsp; Any code following the<B> finally</B> block is only executed in
the second case.&nbsp; You can think of the<B> finally</B> block as a special function that is invoked whenever an exit (other
than falling out the bottom) is attempted from a corresponding<B> try</B> block.
<BR><BR>More formally stated, a local unwind occurs when the system executes the contents of a<B> finally</B> block because
of the premature exit of code in a<B> try</B> block.
<HR>
<BR><B><I>&nbsp; Note:</I></B>&nbsp; Kevin Goodman describes &quot;unwinds&quot; in his article.&nbsp; &quot;There are two
types of unwinds:&nbsp; global and local.&nbsp; A global unwind occurs when there are nested functions and an exception takes
place.&nbsp; A local unwind takes place when there are multiple handlers within one function.&nbsp; Unwinding means that the
stack is going to be clean by the time your handler's code gets executed.&quot;
<HR>
<BR>The<B> try/finally</B> structure is a rejection mechanism which is useful when a set of statements is to be conditionally
chosen for execution, but not all of the conditions required to make the selection are available beforehand.&nbsp; It is an
extension to the C language.&nbsp; You start out with the assumption that a certain task can be accomplished.&nbsp; You then
introduce statements into the code that test your hypothesis.&nbsp; The<B> try</B> block consists of the code that you assume,
under normal conditions, will succeed.&nbsp; Statements like<B> if ...&nbsp; return</B> can be used as tests.&nbsp; Execution
begins with the statements in the<B> try</B> block.&nbsp; If a condition is detected which indicates that the assumption of
a normal state of affairs is wrong, a<B><I> return</I></B> statement may be executed to cause control to be passed to the
statements in the<B> finally</B> block.&nbsp; If the<B> try</B> block completes execution without executing a<B><I> return</I></B>
statement (i.e., all statements are executed up to the final brace), then control is passed to the first statement following
the<B> try</B> block (i.e., the first statement in the<B> finally</B> block).
<BR><BR>In the following example, two sets of codes and letters are read in and some simple sequence checking is performed.
&nbsp;If a sequence error is detected, an error message is printed and processing terminates; otherwise the numbers are processed
and another pair of numbers is read.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdlib.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;excpt.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main( int argc, char **argv )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; read_file( fopen( argv[1], &quot;r&quot; ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void read_file( FILE *input )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; line = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buffer[256];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; icode;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x, y;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( input == NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Unable to open file\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _try {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(;;) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; line++;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( fgets( buffer, 255, input ) == NULL ) break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; icode = buffer[0];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( icode != '1' ) return;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = buffer[1];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; line++;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( fgets( buffer, 255, input ) == NULL ) return;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; icode = buffer[0];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( icode != '2' ) return;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y = buffer[1];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; process( x, y );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Processing complete\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( input );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; input = NULL;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _finally {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( input != NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Invalid sequence: line = %d\n&quot;, line
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( input );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void process( char x, char y )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;processing pair %c,%c\n&quot;, x, y );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The above example attempts to read a code and letter.&nbsp; If an end of file occurs then the loop is terminated by
the<B><I> break</I></B> statement.
<BR><BR>If the code is not 1 then we did not get what we expected and an error condition has arisen.&nbsp; Control is passed
to the first statement in the<B> finally</B> block by the<B><I> return</I></B> statement.&nbsp; An error message is printed
and the open file is closed.
<BR><BR>If the code is 1 then a second code and number are read.&nbsp; If an end of file occurs then we are missing a complete
set of data and an error condition has arisen.&nbsp; Control is passed to the first statement in the<B> finally</B> block
by the<B><I> return</I></B> statement.&nbsp; An error message is printed and the open file is closed.
<BR><BR>Similarly if the expected code is not 2 an error condition has arisen.&nbsp; The same error handling procedure occurs.
<BR><BR>If the second code is 2, the values of variables<TT> x</TT> and<TT> y</TT> are processed (printed).&nbsp; The<B><I>
for</I></B> loop is repeated again.
<BR><BR>The above example illustrates the point that all the information required to test an assumption (that the file contains
valid pairs of data) is not available from the start.&nbsp; We write our code with the assumption that the data values are
correct (our hypothesis) and then test the assumption at various points in the algorithm.&nbsp; If any of the tests fail,
we reject the hypothesis.
<BR><BR>Consider the following example.&nbsp; What values are printed by the program?
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdlib.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;excpt.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main( int argc, char **argv )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int ctr = 0;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( ctr &lt; 10 ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, ctr );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _try {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( ctr == 2 ) continue;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( ctr == 3 ) break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _finally {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ctr++;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ctr++;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, ctr );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>At the top of the loop, the value of<TT> ctr</TT> is 0.&nbsp; The next time we reach the top of the loop, the value
of<TT> ctr</TT> is 2 (having been incremented twice, once by the<B> finally</B> block and once at the bottom of the loop).
&nbsp;When<TT> ctr</TT> has the value 2, the<B><I> continue</I></B> statement will cause the<B> finally</B> block to be executed
(resulting in<TT> ctr</TT> being incremented to 3), after which execution continues at the top of the<B><I> while</I></B>
loop.&nbsp; When<TT> ctr</TT> has the value 3, the<B><I> break</I></B> statement will cause the<B> finally</B> block to be
executed (resulting in<TT> ctr</TT> being incremented to 4), after which execution continues after the<B><I> while</I></B>
loop.&nbsp; Thus the output is:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 3</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; 4</TT>
<BR><BR>The point of this exercise was that after the<B> finally</B> block is executed, the normal flow of execution is resumed
at the<B><I> break</I></B> ,<B><I> continue</I></B> ,<B><I> return</I></B> , etc.&nbsp; statement and the normal behaviour
for that statement occurs.&nbsp; It is as if the compiler had inserted a function call just before the statement that exits
the<B> try</B> block.
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; _try {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( ctr == 2 ) invoke_finally_block() continue;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( ctr == 3 ) invoke_finally_block() break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>There is some overhead associated with local unwinds such as that incurred by the use of<B><I> break</I></B> ,<B><I>
continue</I></B> ,<B><I> return</I></B> , etc.&nbsp; To avoid this overhead, a new transfer keyword called<B><I> _leave</I></B>
can be used.&nbsp; The use of this keyword causes a jump to the end of the<B> try block.</B>&nbsp; Consider the following
modified version of an earlier example.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdlib.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;excpt.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main( int argc, char **argv )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; read_file( fopen( argv[1], &quot;r&quot; ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void read_file( FILE *input )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; line = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buffer[256];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; icode;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x, y;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( input == NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Unable to open file\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _try {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(;;) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; line++;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( fgets( buffer, 255, input ) == NULL ) break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; icode = buffer[0];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( icode != '1' ) _leave;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = buffer[1];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; line++;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( fgets( buffer, 255, input ) == NULL ) _leave;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; icode = buffer[0];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( icode != '2' ) _leave;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y = buffer[1];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; process( x, y );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Processing complete\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( input );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; input = NULL;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _finally {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( input != NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Invalid sequence: line = %d\n&quot;, line
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( input );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void process( char x, char y )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;processing pair %c,%c\n&quot;, x, y );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>There are two ways to enter the<B> finally</B> block.&nbsp; One way is caused by unwinds - either local (by the use
of<B><I> break</I></B> ,<B><I> continue</I></B> ,<B><I> return</I></B> , or<B><I> goto</I></B> ) or global (more on global
unwinds later).&nbsp; The other way is through the normal flow of execution (i.e., simply by falling through the bottom of
the<B> try</B> block).&nbsp; There is a function called<B><I> AbnormalTermination</I></B> that can be used to determine which
of these two methods was used to enter the<B> finally</B> block.&nbsp; If the function returns<TT> TRUE</TT> (1) then the<B>
finally</B> block was entered using the first method; if the function returns<TT> FALSE</TT> (0) then the<B> finally</B> block
was entered using the second method.&nbsp; This information may be useful in some circumstances.&nbsp; For example, you may
wish to avoid executing any code in a<B> finally</B> block if the block was entered through the normal flow of execution.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdlib.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;excpt.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main( int argc, char **argv )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; read_file( fopen( argv[1], &quot;r&quot; ) );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void read_file( FILE *input )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; line = 0;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buffer[256];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; icode;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x, y;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( input == NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Unable to open file\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _try {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(;;) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; line++;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( fgets( buffer, 255, input ) == NULL ) break;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; icode = buffer[0];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( icode != '1' ) return;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = buffer[1];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; line++;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( fgets( buffer, 255, input ) == NULL ) return;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; icode = buffer[0];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( icode != '2' ) return;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y = buffer[1];</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; process( x, y );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Processing complete\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _finally {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( AbnormalTermination() )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Invalid sequence: line = %d\n&quot;,
line );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( input );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void process( char x, char y )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;processing pair %c,%c\n&quot;, x, y );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>In the above example, we reverted back to the use of the<B><I> return</I></B> statement since the execution of a<B><I>
_leave</I></B> statement is considered part of the normal flow of execution and is not considered an &quot;abnormal termination&quot;
of the<B> try</B> block.&nbsp; Note that since it is not possible to determine whether the<B> finally</B> block is executing
as the result of a local or global unwind, it may not be appropriate to use the<B><I> AbnormalTermination</I></B> function
as a way to determine what has gone on.&nbsp; However, in our simple example, we expect that nothing could go wrong in the
&quot;processing&quot; routine.
<H2 ID="Exception_Filters_and_Exception_Handlers"> Exception Filters and Exception Handlers </H2>
<BR>We would all like to create flawless software but situations arise for which we did not plan.&nbsp; An event that we did
not expect which causes the software to cease to function properly is called an exception.&nbsp; The computer can generate
a hardware exception when the software attempts to execute an illegal instruction.&nbsp; We can force this quite easily in
C by dereferencing a NULL pointer as shown in the following sample fragment of code.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *nullp = NULL;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *nullp = '\1';</TT>
<BR><BR>We can also generate software exceptions from software by calling a special function for this purpose.&nbsp; We will
look at software exceptions in more detail later on.
<BR><BR>Given that exceptions are generally very difficult to avoid in large software projects, we can acknowledge that they
are a fact of life and prepare for them.&nbsp; A mechanism similar to<B> try/finally</B> has been devised that makes it possible
to gain control when an exception occurs and to execute procedures to handle the situation.
<BR><BR>The exception handling mechanism involves the pairing up of a<B><I> _try</I></B> block with an<B><I> _except</I></B>
block.&nbsp; This is illustrated in the following example.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdlib.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;excpt.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main( int argc, char **argv )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *nullp = NULL;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Attempting illegal memory reference.\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _try {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *nullp = '\1';</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _except (EXCEPTION_EXECUTE_HANDLER) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Oh no! We had an exception!\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;We recovered fine...\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>In this example, any exception that occurs while executing &quot;inside&quot; the<B> try</B> block will cause the<B>
except</B> block to execute.&nbsp; Unlike the<B> finally</B> block, execution of the<B> except</B> block occurs only when
an exception is generated and only when the expression after the<B><I> _except</I></B> keyword evaluates to <TT> EXCEPTION_EXECUTE_HANDLER.</TT>
&nbsp;The expression can be quite complex and can involve the execution of a function that returns one of the permissible
values.&nbsp; The expression is called the exception &quot;filter&quot; since it determines whether or not the exception is
to be handled by the<B> except</B> block.&nbsp; The permissible result values for the exception filer are:
<DL>
<DT>EXCEPTION_EXECUTE_HANDLER
<DD>meaning &quot;I will handle the exception&quot;.
<DT>EXCEPTION_CONTINUE_EXECUTION
<DD>meaning &quot;I want to resume execution at the point where the exception was generated&quot;.
<DT>EXCEPTION_CONTINUE_SEARCH
<DD>meaning &quot;I do not want to handle the exception so continue looking down the<B> try/except</B> chain until you find an
exception handler that does want to handle the exception&quot;.
</DL>
<H2 ID="Resuming_Execution_After_an_Exception"> Resuming Execution After an Exception </H2>
<BR>Why would you want to resume execution of the instruction that caused the exception?&nbsp; Since the exception filter
can involve a function call, that function can attempt to correct the problem.&nbsp; For example, if it is determined that
the exception has occurred because of the NULL pointer dereference, the function could modify the pointer so that it is no
longer NULL.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdlib.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;excpt.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; char *NullP = NULL;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int filter( void )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( NullP == NULL ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NullP = malloc( 20 );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( EXCEPTION_CONTINUE_EXECUTION )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( EXCEPTION_EXECUTE_HANDLER )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main( int argc, char **argv )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Attempting illegal memory reference.\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _try {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *NullP = '\1';</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _except (filter()) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Oh no! We had an exception!\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;We recovered fine...\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>Unfortunately, this is does not solve the problem.&nbsp; Understanding why it does not involves looking at the sequence
of computer instructions that is generated for the expression in question.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *NullP = '\1';</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; eax,dword ptr
_NullP</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; byte ptr [eax],01H</TT>
<BR><BR>The exception is caused by the second instruction which contains a pointer to the referenced memory location (i.e.,
0) in register EAX.&nbsp; This is the instruction that will be repeated when the filter returns<TT> EXCEPTION_CONTINUE_EXECUTION.</TT>
&nbsp;Since EAX did not get changed by our fix, the exception will reoccur.&nbsp; Fortunately,<TT> NullP</TT> is changed and
this prevents our program from looping forever.&nbsp; The moral here is that there are very few instances where you can correct
&quot;on the fly&quot; a problem that is causing an exception to occur.&nbsp; Certainly, any attempt to do so must involve
a careful inspection of the computer instruction sequence that is generated by the compiler (and this sequence usually varies
with the selection of compiler optimization options).&nbsp; The best solution is to add some more code to detect the problem
before the exception occurs.
<H2 ID="Mixing_and_Matching__tryD_finally_and__tryD_except"> Mixing and Matching _try/_finally and _try/_except </H2>
<BR>Where things really get interesting is in the interaction between<B> try/finally</B> blocks and<B> try/except</B> blocks.
&nbsp;These blocks can be nested within each other.&nbsp; In an earlier part of the discussion, we talked about global unwinds
and how they can be caused by exceptions being generated in nested function calls.&nbsp; All of this should become clear after
studying the following example.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdio.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;stdlib.h&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;excpt.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void func_level4( void )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *nullp = NULL;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Attempting illegal memory reference\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _try {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *nullp = '\1';</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _finally {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( AbnormalTermination() )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Unwind in func_level4\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Normal return from func_level4\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void func_level3( void )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _try {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; func_level4();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _finally {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( AbnormalTermination() )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Unwind in func_level3\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Normal return from func_level3\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void func_level2( void )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _try {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _try {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; func_level3();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _except (EXCEPTION_CONTINUE_SEARCH) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Exception never handled in func_level2\n&quot;
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _finally {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( AbnormalTermination() )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Unwind in func_level2\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Normal return from func_level2\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void func_level1( void )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _try {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; func_level2();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _finally {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( AbnormalTermination() )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Unwind in func_level1\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Normal return from func_level1\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void func_level0( void )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _try {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _try {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; func_level1();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _except (EXCEPTION_EXECUTE_HANDLER) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Exception handled in func_level0\n&quot;
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _finally {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( AbnormalTermination() )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Unwind in func_level0\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Normal return from func_level0\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void main( int argc, char **argv )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _try {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _try {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; func_level0();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _except (EXCEPTION_EXECUTE_HANDLER) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Exception handled in main\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _finally {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( AbnormalTermination() )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Unwind in main\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Normal return from main\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>In this example,
<OL>
<LI><TT> main</TT> calls<TT> func_level0</TT>
<LI><TT> func_level0</TT> calls<TT> func_level1</TT>
<LI><TT> func_level1</TT> calls<TT> func_level2</TT>
<LI><TT> func_level2</TT> calls<TT> func_level3</TT>
<LI><TT> func_level3</TT> calls<TT> func_level4</TT>
</OL>
<BR>It is in<TT> func_level4</TT> where the exception occurs.&nbsp; The run-time system traps the exception and performs a
search of the active<B> try</B> blocks looking for one that is paired up with an<B> except</B> block.
<BR><BR>When it finds one, the filter is executed and, if the result is<TT> EXCEPTION_EXECUTE_HANDLER,</TT> then the<B> except</B>
block is executed after performing a global unwind.
<BR><BR>If the result is<TT> EXCEPTION_CONTINUE_EXECUTION,</TT> the run-time system resumes execution at the instruction that
caused the exception.
<BR><BR>If the result is<TT> EXCEPTION_CONTINUE_SEARCH,</TT> the run-time system continues its search for an<B> except</B>
block with a filter that returns one of the other possible values.&nbsp; If it does not find any exception handler that is
prepared to handle the exception, the application will be terminated with the appropriate exception notification.
<BR><BR>Let us look at the result of executing the example program.&nbsp; The following messages are printed.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Attempting illegal memory reference</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Unwind in func_level4</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Unwind in func_level3</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Unwind in func_level2</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Unwind in func_level1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Exception handled in func_level0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Normal return from func_level0</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; Normal return from main</TT>
<BR><BR>The run-time system searched down the<B> try/except</B> chain until it got to<TT> func_level0</TT> which had an<B>
except</B> filter that evaluated to<TT> EXCEPTION_EXECUTE_HANDLER.</TT>&nbsp; It then performed a global unwind in which the<B>
try/finally</B> blocks of<TT> func_level4, func_level3, func_level2,</TT> and<TT> func_level1</TT> were executed.&nbsp; After
this, the exception handler in<TT> func_level0</TT> did its thing and execution resumed in<TT> func_level0</TT> which returned
back to<TT> main</TT> which returned to the run-time system for normal program termination.&nbsp; Note the use of the built-in<B><I>
AbnormalTermination</I></B> function in the<B> finally</B> blocks of each function.
<BR><BR>This sequence of events permits each function to do any cleaning up that it deems necessary before it is wiped off
the execution stack.
<H2 ID="Refining_Exception_Handling"> Refining Exception Handling </H2>
<BR>The decision to handle an exception must be weighed carefully.&nbsp; It is not necessarily a desirable thing for an exception
handler to handle all exceptions.&nbsp; In the previous example, the expression in the exception filter in<TT> func_level0</TT>
always evaluates to<TT> EXCEPTION_EXECUTE_HANDLER</TT> which means it will snag every exception that comes its way.&nbsp;
There may be other exception handlers further on down the chain that are better equipped to handle certain types of exceptions.
&nbsp;There is a way to determine the exact type of exception using the built-in<TT> GetExceptionCode()</TT> function.&nbsp;
It may be called only from within the exception handler filter expression or within the exception handler block.&nbsp; Here
is a description of the possible return values from the<TT> GetExceptionCode()</TT> function.
<DL>
<DT>Value
<DD>Meaning
<DT>EXCEPTION_ACCESS_VIOLATION
<DD>The thread tried to read from or write to a virtual address for which it does not have the appropriate access.
<DT>EXCEPTION_BREAKPOINT
<DD>A breakpoint was encountered.
<DT>EXCEPTION_DATATYPE_MISALIGNMENT
<DD>The thread tried to read or write data that is misaligned on hardware that does not provide alignment.&nbsp; For example,
16-bit values must be aligned on 2-byte boundaries; 32-bit values on 4-byte boundaries, and so on.
<DT>EXCEPTION_SINGLE_STEP
<DD>A trace trap or other single-instruction mechanism signaled that one instruction has been executed.
<DT>EXCEPTION_ARRAY_BOUNDS_EXCEEDED
<DD>The thread tried to access an array element that is out of bounds and the underlying hardware supports bounds checking.
<DT>EXCEPTION_FLT_DENORMAL_OPERAND
<DD>One of the operands in a floating-point operation is denormal.&nbsp; A denormal value is one that is too small to represent
as a standard floating-point value.
<DT>EXCEPTION_FLT_DIVIDE_BY_ZERO
<DD>The thread tried to divide a floating-point value by a floating-point divisor of zero.
<DT>EXCEPTION_FLT_INEXACT_RESULT
<DD>The result of a floating-point operation cannot be represented exactly as a decimal fraction.
<DT>EXCEPTION_FLT_INVALID_OPERATION
<DD>This exception represents any floating-point exception not included in this list.
<DT>EXCEPTION_FLT_OVERFLOW
<DD>The exponent of a floating-point operation is greater than the magnitude allowed by the corresponding type.
<DT>EXCEPTION_FLT_STACK_CHECK
<DD>The stack overflowed or underflowed as the result of a floating-point operation.
<DT>EXCEPTION_FLT_UNDERFLOW
<DD>The exponent of a floating-point operation is less than the magnitude allowed by the corresponding type.
<DT>EXCEPTION_INT_DIVIDE_BY_ZERO
<DD>The thread tried to divide an integer value by an integer divisor of zero.
<DT>EXCEPTION_INT_OVERFLOW
<DD>The result of an integer operation caused a carry out of the most significant bit of the result.
<DT>EXCEPTION_PRIV_INSTRUCTION
<DD>The thread tried to execute an instruction whose operation is not allowed in the current machine mode.
<DT>EXCEPTION_NONCONTINUABLE_EXCEPTION
<DD>The thread tried to continue execution after a non-continuable exception occurred.
</DL>
<BR>These constants are defined by including<TT> WINDOWS.H</TT> in the source code.
<BR><BR>The following example is a refinement of the<TT> func_level1()</TT> function in our previous example.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;windows.h&gt;</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void func_level0( void )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _try {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _try {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; func_level1();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _except (</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ? EXCEPTION_EXECUTE_HANDLER</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : EXCEPTION_CONTINUE_SEARCH</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Exception handled in func_level0\n&quot;
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _finally {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( AbnormalTermination() )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Unwind in func_level0\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Normal return from func_level0\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>In this version, only an &quot;access violation&quot; will be handled by the exception handler in the<TT> func_level0()</TT>
function.&nbsp; All other types of exceptions will be passed on to<TT> main</TT> (which can also be modified to be somewhat
more selective about the types of exceptions it should handle).
<BR><BR>More information on the exception that has occurred can be obtained by the use of the<TT> GetExceptionInformation()</TT>
function.&nbsp; The use of this function is also restricted.&nbsp; It can be called only from within the filter expression
of an exception handler.&nbsp; However, the return value of<TT> GetExceptionInformation()</TT> can be passed as a parameter
to a filter function.&nbsp; This is illustrated in the following example.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; int GetCode( LPEXCEPTION_POINTERS exceptptrs )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (exceptptrs-&gt;ExceptionRecord-&gt;ExceptionCode );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; void func_level0( void )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _try {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _try {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; func_level1();</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _except (</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (GetCode( GetExceptionInformation() )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; == EXCEPTION_ACCESS_VIOLATION)</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ? EXCEPTION_EXECUTE_HANDLER</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : EXCEPTION_CONTINUE_SEARCH</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Exception handled in func_level0\n&quot;
);</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _finally {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( AbnormalTermination() )</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Unwind in func_level0\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Normal return from func_level0\n&quot; );</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
<BR><BR>The return value of<TT> GetExceptionInformation()</TT> is a pointer to an <TT> EXCEPTION_POINTERS</TT> structure that
contains pointers to two other structures:&nbsp; an <TT> EXCEPTION_RECORD</TT> structure containing a description of the exception,
and a <TT> CONTEXT</TT> structure containing the machine-state information.&nbsp; The filter function can make a copy of the
structures if a more permanent copy is desired.&nbsp; Check your Win32 SDK documentation for more information on these structures.
<H2 ID="Throwing_Your_Own_Exceptions"> Throwing Your Own Exceptions </H2>
<BR>You can use the same exception handling mechanisms to deal with software exceptions raised by your application.&nbsp;
The<TT> RaiseException()</TT> function can be used to throw your own application-defined exceptions.&nbsp; The first argument
to this function is the exception code.&nbsp; It would be wise to define your exception codes so that they do not collide
with system defined ones.&nbsp; The following example shows how to throw an exception.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #define MY_EXCEPTION ( (DWORD) 123L )</TT>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RaiseException( MY_EXCEPTION,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; EXCEPTION_NONCONTINUABLE,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; 0, NULL );</TT>
<BR><BR>In this example, the<TT> GetExceptionCode()</TT> function, when used in an exception handler filter expression or
in the body of an exception handler, would return the value 123.
<BR><BR>See the Win32 SDK documentation for more information on the arguments to the<TT> RaiseException()</TT> function.
<H1 ID="Creating_ROMMbased_Applications"> Creating ROM-based Applications </H1>
<BR>This chapter provides information for developers who wish to write applications to be placed in read-only memory (ROM).
<H2 ID="ROMable_Functions"> ROMable Functions </H2>
<BR>The following functions in the Open Watcom C/C++ library are not dependent on any operating system.&nbsp; Therefore they
can be used for embedded applications.&nbsp; The math functions are listed here because they are ROMable, however you must
supply a different<TT> _matherr</TT> function if you are not running in the DOS, OS/2 or Windows NT environment.
<BR><BR><TT>abs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; acos&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; alloca&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; asctime&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; asin
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; atan&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; atan2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; atexit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; atof&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; atoi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; atol&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsearch
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cabs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ceil&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
_chain_intr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _clear87&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; _control87&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cos&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cosh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; difftime&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _disable&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; div&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
_enable&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fabs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; floor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fmemccpy&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fmemchr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fmemcmp
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fmemcpy&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; _fmemicmp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fmemmove&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; _fmemset&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fmod&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FP_OFF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; FP_SEG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fpreset&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; frexp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; _fstrcat&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fstrchr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; _fstrcmp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fstrcpy&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fstrcspn&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fstricmp
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fstrlen&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;_fstrlwr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fstrncat&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; _fstrncmp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fstrncpy&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fstrnicmp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fstrnset&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fstrpbrk&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fstrrchr&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fstrrev&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
_fstrset&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fstrspn&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; _fstrstr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fstrtok&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fstrupr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gmtime&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hypot&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; inp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
inpw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int86 (1)&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int86x (1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int386 (2)&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int386x (2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; intr&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; intrf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; isalnum&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isalpha&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isascii&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;iscntrl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isdigit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isgraph&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; islower
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isprint&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; ispunct&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isspace&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isupper&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;isxdigit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; itoa&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; j1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;jn&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; labs&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ldexp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ldiv&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;lfind&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; localeconv&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; log&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;log10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; longjmp&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _lrotl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; _lrotr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lsearch&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ltoa&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; matherr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mblen&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mbstowcs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>mbtowc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memccpy&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memchr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;memcmp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memcpy&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memicmp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;memmove&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memset&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MK_FP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;modf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movedata&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offsetof&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
outp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outpw&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pow&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; qsort&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rand&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _rotl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _rotr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
segread&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setjmp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setlocale&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sin&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sinh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
sqrt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; srand&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sscanf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; stackavail&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _status87&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; strcat&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strchr&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcmp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; strcmpi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcoll&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcpy&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; strcspn&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strdup&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strerror&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stricmp
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strlen&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; strlwr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strncat&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strncmp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; strncpy&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strnicmp&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strnset&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strpbrk
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strrchr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; strrev&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strset&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strspn&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; strstr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strtod&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strtok&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; strtol&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strtoul&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strupr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; strxfrm&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; swab&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tan&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tanh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
tolower&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; toupper&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ultoa&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; utoa
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_arg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_end&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;va_start&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vsprintf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; vsscanf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wcstombs&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wctomb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; y0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y1&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yn&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp; * (1) 16-bit libraries
<BR>&nbsp;&nbsp;&nbsp;&nbsp; * (2) 32-bit libraries
<H2 ID="SystemMDependent_Functions"> System-Dependent Functions </H2>
<BR>The following functions in the C/C++ library directly or indirectly make use of operating system functions.&nbsp; They
cannot be used on systems that are not running on one of the DOS, OS/2 or Windows NT operating systems.
<BR><BR><TT>abort&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; access&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; bdos&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _beginthread&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _bios_disk&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _bios_equiplist&nbsp;&nbsp;
&nbsp; _bios_keybrd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _bios_memsize&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _bios_printer
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _bios_serialcom&nbsp;&nbsp;&nbsp;&nbsp; _bios_timeofday&nbsp;&nbsp;&nbsp;&nbsp; calloc&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cgets&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; chdir&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chmod&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chsize&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clearerr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clock&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; closedir&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cprintf&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cputs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; creat&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cscanf&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ctime&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; cwait&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delay&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _dos_allocmem&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _dos_close
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _dos_creat&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _dos_creatnew
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _dos_findfirst&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _dos_findnext&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
_dos_freemem&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _dos_getdate&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _dos_getdiskfree
&nbsp;&nbsp; _dos_getdrive&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _dos_getfileattr&nbsp;&nbsp;&nbsp; _dos_getftime&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; _dos_gettime&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _dos_getvect&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;_dos_keep&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _dos_open&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; _dos_read&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _dos_setblock&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; _dos_setdate&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _dos_setdrive&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _dos_setfileattr
&nbsp;&nbsp; _dos_setftime&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _dos_settime&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _dos_setvect
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _dos_write&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dosexterr&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dup&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; dup2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _endthread&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eof&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; execl (1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; execle (1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; execlp (1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; execlpe (1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; execv (1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; execve (1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; execvp (1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; execvpe (1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; exit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _exit&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; fcloseall&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fdopen&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; feof&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; ferror&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fflush&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _ffree&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; _fheapchk&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fheapgrow (1)&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;_fheapmin&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fheapset&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; _fheapshrink&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fheapwalk&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; fgetc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fgetpos&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fgets&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; filelength&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fileno&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; flushall&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fmalloc&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fopen&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;fprintf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fputc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fputs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; fread&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _frealloc&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; free&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;freopen&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fscanf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fseek&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;fsetpos&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fstat&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>ftell&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fwrite&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; getch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getchar&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getche&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; getcmd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getcwd&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getenv&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; getpid&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gets&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; halloc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; _heapchk&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _heapgrow&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _heapmin&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _heapset
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _heapshrink&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _heapwalk
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hfree&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; intdos&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; intdosx&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isatty&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; kbhit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; localtime&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lock&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;locking&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lseek&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _makepath&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; malloc
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mkdir&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mktime&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _nfree
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _nheapchk&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; _nheapgrow&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _nheapmin&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; _nheapset&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _nheapshrink&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; _nheapwalk&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _nmalloc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; _nrealloc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nosound&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; open&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; opendir&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; perror&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;putc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; putch&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; putchar&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; putenv&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; puts&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; raise&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; read&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; readdir
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; realloc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; remove&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rename&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rewind&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; rmdir&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sbrk&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scanf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _searchenv&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setbuf&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setmode&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;setvbuf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sleep&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;sopen&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sound&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spawnl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; spawnle&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spawnlp&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spawnlpe&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spawnv
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spawnve&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; spawnvp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spawnvpe&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _splitpath&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stat&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strftime&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; system&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tell&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmpfile&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmpnam
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tzset&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; umask&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ungetc
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ungetch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; unlink&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unlock&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; utime&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; vfprintf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vfscanf&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vprintf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;vscanf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wait&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</TT>
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp; * (1) 16-bit libraries
<H2 ID="Modifying_the_Startup_Code"> Modifying the Startup Code </H2>
<BR>Source files are included in the package for the Open Watcom C/C++ application start-up (or initialization) sequence.
&nbsp;These files are described in the section entitled <A HREF="#The_Open_Watcom_CDCPP_RunMtime_Initialization_Routines">The Open Watcom C/C++ Run-time Initialization Routines</A>.
&nbsp;The startup code will have to be modified if you are creating a ROMable application or you are not running in a DOS,
OS/2, QNX, or Windows environment.
<H2 ID="Choosing_the_Correct_FloatingMPoint_Option"> Choosing the Correct Floating-Point Option </H2>
<BR>If there will be a math coprocessor chip in your embedded system, then you should compile your application with the &quot;fpi87&quot;
option and one of &quot;fp2&quot;, &quot;fp3&quot; or &quot;fp5&quot; depending on which math coprocessor chip will be in
your embedded system.&nbsp; If there will not be a math coprocessor chip in your embedded system, then you should compile
your application with the &quot;fpc&quot; option.&nbsp; You should not use the &quot;fpi&quot; option since that will cause
extra code to be linked into your application to decode and emulate the 80x87 instructions contained in your application.
<H1 ID="Use_of_Environment_Variables"> Use of Environment Variables </H1>
<BR><BR>In the Open Watcom C/C++ software development package, a number of environment variables are used.&nbsp; This appendix
summarizes their use with a particular component of the package.
<H2 ID="FORCE"> FORCE </H2>
<BR>The<B> FORCE</B> environment variable identifies a file that is to be included as part of the source input stream.&nbsp;
This variable is used by Open Watcom C/C++.&nbsp; 
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SET FORCE=[d:][path]filename[.ext]</TT>
<BR><BR>The specified file is included as if a
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; #include &quot;[d:][path]filename[.ext]&quot;</TT>
<BR><BR>directive were placed at the start of the source file.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set force=\watcom\h\common.cnv</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;wcc report</TT>
<BR><BR>The<B> FORCE</B> environment variable can be overridden by use of the Open Watcom C/C++ &quot;fi&quot; option.
<H2 ID="INCLUDE"> INCLUDE </H2>
<BR>The<B> INCLUDE</B> environment variable describes the location of the C and C++ header files (files with the &quot;.h&quot;
filename extension).&nbsp; This variable is used by Open Watcom C/C++.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SET include=[d:][path];[d:][path]...</TT>
<BR><BR>The<B> INCLUDE</B> environment string is like the<B> PATH</B> string in that you can specify one or more directories
separated by semicolons (&quot;;&quot;).
<H2 ID="LFN"> LFN </H2>
<BR>The<B> LFN</B> environment variable is checked by the Open Watcom run-time C libraries and it is used to control DOS LFN
(DOS Long File Name) support.&nbsp; Normally, these libraries will use DOS LFN support if it is available on host OS.&nbsp;
If you don't wish to use DOS LFN support, you can define the<B> LFN</B> environment variable and setup it's value to 'N'.
&nbsp;Using the &quot;SET&quot; command, define the environment variable as follows:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SET LFN=N</TT>
<BR><BR>Now, when you run your application, the DOS LFN support will be ignored.&nbsp; To undefine the environment variable,
enter the command:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SET LFN=</TT>
<H2 ID="LIB"> LIB </H2>
<BR>The use of the<B> WATCOM</B> environment variable and the Open Watcom Linker &quot;SYSTEM&quot; directive is recommended
over the use of this environment variable.
<BR><BR>The<B> LIB</B> environment variable is used to select the libraries that will be used when the application is linked.
&nbsp;This variable is used by the Open Watcom Linker (WLINK.EXE).&nbsp; The<B> LIB</B> environment string is like the<B>
PATH</B> string in that you can specify one or more directories separated by semicolons (&quot;;&quot;).
<BR><BR>If you have the 286 development system, 16-bit applications can be linked for DOS, Microsoft Windows, OS/2, and QNX
depending on which libraries are selected.&nbsp; If you have the 386 development system, 32-bit applications can be linked
for DOS Extender systems, Microsoft Windows and QNX.
<H2 ID="LIBDOS"> LIBDOS </H2>
<BR>The use of the<B> WATCOM</B> environment variable and the Open Watcom Linker &quot;SYSTEM&quot; directive is recommended
over the use of this environment variable.
<BR><BR>If you are developing a DOS application, the<B> LIBDOS</B> environment variable must include the location of the 16-bit
Open Watcom C/C++ DOS library files (files with the &quot;.lib&quot; filename extension).&nbsp; This variable is used by the
Open Watcom Linker (WLINK.EXE).&nbsp; The default installation directory for the 16-bit Open Watcom C/C++ DOS libraries is<TT>
\WATCOM\LIB286\DOS.</TT>&nbsp; The<B> LIBDOS</B> environment variable must also include the location of the 16-bit Open Watcom
C/C++ math library files.&nbsp; The default installation directory for the 16-bit Open Watcom C/C++ math libraries is<TT>
\WATCOM\LIB286.</TT>
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set libdos=c:\watcom\lib286\dos;c:\watcom\lib286</TT>
<H2 ID="LIBWIN"> LIBWIN </H2>
<BR>The use of the<B> WATCOM</B> environment variable and the Open Watcom Linker &quot;SYSTEM&quot; directive is recommended
over the use of this environment variable.
<BR><BR>If you are developing a 16-bit Microsoft Windows application, the<B> LIBWIN</B> environment variable must include
the location of the 16-bit Open Watcom C/C++ Windows library files (files with the &quot;.lib&quot; filename extension).&nbsp;
This variable is used by the Open Watcom Linker (WLINK.EXE).&nbsp; If you are developing a 32-bit Microsoft Windows application,
see the description of the<B> LIBPHAR</B> environment variable.&nbsp; The default installation directory for the 16-bit Open
Watcom C/C++ Windows libraries is<TT> \WATCOM\LIB286\WIN.</TT>&nbsp; The<B> LIBWIN</B> environment variable must also include
the location of the 16-bit Open Watcom C/C++ math library files.&nbsp; The default installation directory for the 16-bit Open
Watcom C/C++ math libraries is<TT> \WATCOM\LIB286.</TT>
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set libwin=c:\watcom\lib286\win;c:\watcom\lib286</TT>
<H2 ID="LIBOS2"> LIBOS2 </H2>
<BR>The use of the<B> WATCOM</B> environment variable and the Open Watcom Linker &quot;SYSTEM&quot; directive is recommended
over the use of this environment variable.
<BR><BR>If you are developing an OS/2 application, the<B> LIBOS2</B> environment variable must include the location of the
16-bit Open Watcom C/C++ OS/2 library files (files with the &quot;.lib&quot; filename extension).&nbsp; This variable is used
by the Open Watcom Linker (WLINK.EXE).&nbsp; The default installation directory for the 16-bit Open Watcom C/C++ OS/2 libraries
is<TT> \WATCOM\LIB286\OS2.</TT>&nbsp; The<B> LIBOS2</B> environment variable must also include the directory of the OS/2<TT>
DOSCALLS.LIB</TT> file which is usually<TT> \OS2.</TT>&nbsp; The<B> LIBOS2</B> environment variable must also include the
location of the 16-bit Open Watcom C/C++ math library files.&nbsp; The default installation directory for the 16-bit Open
Watcom C/C++ math libraries is<TT> \WATCOM\LIB286.</TT>
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set libos2=c:\watcom\lib286\os2;c:\watcom\lib286;c:\os2</TT>
<H2 ID="LIBPHAR"> LIBPHAR </H2>
<BR>The use of the<B> WATCOM</B> environment variable and the Open Watcom Linker &quot;SYSTEM&quot; directive is recommended
over the use of this environment variable.
<BR><BR>If you are developing a 32-bit Windows or DOS Extender application, the<B> LIBPHAR</B> environment variable must include
the location of the 32-bit Open Watcom C/C++ DOS Extender library files or the 32-bit Open Watcom C/C++ Windows library files
(files with the &quot;.lib&quot; filename extension).&nbsp; This variable is used by the Open Watcom Linker (WLINK.EXE).&nbsp;
The default installation directory for the 32-bit Open Watcom C/C++ DOS Extender libraries is<TT> \WATCOM\LIB386\DOS.</TT>
&nbsp;The default installation directory for the 32-bit Open Watcom C/C++ Windows libraries is<TT> \WATCOM\LIB386\WIN.</TT>
&nbsp;The<B> LIBPHAR</B> environment variable must also include the location of the 32-bit Open Watcom C/C++ math library
files.&nbsp; The default installation directory for the 32-bit Open Watcom C/C++ math libraries is<TT> \WATCOM\LIB386.</TT>
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set libphar=c:\watcom\lib386\dos;c:\watcom\lib386</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set libphar=c:\watcom\lib386\win;c:\watcom\lib386</TT>
<H2 ID="NO87"> NO87 </H2>
<BR>The<B> NO87</B> environment variable is checked by the Open Watcom run-time math libraries that include floating-point
emulation support.&nbsp; Normally, these libraries will detect the presence of a numeric data processor (80x87) and use it.
&nbsp;If you have a numeric data processor in your system but you wish to test a version of your application that will use
floating-point emulation, you can define the<B> NO87</B> environment variable.&nbsp; Using the &quot;SET&quot; command, define
the environment variable as follows:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SET NO87=1</TT>
<BR><BR>Now, when you run your application, the 80x87 will be ignored.&nbsp; To undefine the environment variable, enter the
command:
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SET NO87=</TT>
<H2 ID="PATH"> PATH </H2>
<BR>The<B> PATH</B> environment variable is used by DOS &quot;COMMAND.COM&quot; or OS/2 &quot;CMD.EXE&quot; to locate programs.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; PATH [d:][path];[d:][path]...</TT>
<BR><BR>The<B> PATH</B> environment variable should include the disk and directory of the Open Watcom C/C++ binary program
files when using Open Watcom C/C++ and its related tools.
<BR><BR><B>If your host system is DOS:</B>
<BR><BR>The default installation directory for 16-bit Open Watcom C/C++ and 32-bit Open Watcom C/C++ DOS binaries is called<TT>
\WATCOM\BINW.</TT>
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;path c:\watcom\binw;c:\dos;c:\windows</TT>
<BR><BR><B>If your host system is OS/2:</B>
<BR><BR>The default installation directories for 16-bit Open Watcom C/C++ and 32-bit Open Watcom C/C++ OS/2 binaries are called<TT>
\WATCOM\BINP</TT> and<TT> \WATCOM\BINW.</TT>
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; [C:\]path c:\watcom\binp;c:\watcom\binw</TT>
<BR><BR><B>If your host system is Windows NT:</B>
<BR><BR>The default installation directories for 16-bit Open Watcom C/C++ and 32-bit Open Watcom C/C++ Windows NT binaries
are called<TT> \WATCOM\BINNT</TT> and<TT> \WATCOM\BINW.</TT>
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;path c:\watcom\binnt;c:\watcom\binw</TT>
<BR><BR>The<B> PATH</B> environment variable is also used by the following programs in the described manner.
<OL>
<LI>Open Watcom Compile and Link to locate the 16-bit Open Watcom C/C++ and 32-bit Open Watcom C/C++ compilers and the Open
Watcom Linker.
<LI>&quot;WD.EXE&quot; to locate programs and debugger command files.
</OL>
<H2 ID="TMP"> TMP </H2>
<BR>The<B> TMP</B> environment variable describes the location (disk and path) for temporary files created by the 16-bit Open
Watcom C/C++ and 32-bit Open Watcom C/C++ compilers and the Open Watcom Linker.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SET TMP=[d:][path]</TT>
<BR><BR>Normally, Open Watcom C/C++ will create temporary spill files in the current directory.&nbsp; However, by defining
the<B> TMP</B> environment variable to be a certain disk and directory, you can tell Open Watcom C/C++ where to place its
temporary files.&nbsp; The same is true of the Open Watcom Linker temporary file.
<BR><BR>Consider the following definition of the<B> TMP</B> environment variable.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set tmp=d:\watcom\tmp</TT>
<BR><BR>The Open Watcom C/C++ compiler and Open Watcom Linker will create its temporary files in<TT> d:\watcom\tmp.</TT>
<H2 ID="WATCOM"> WATCOM </H2>
<BR>In order for the Open Watcom Linker to locate the 16-bit Open Watcom C/C++ and 32-bit Open Watcom C/C++ library files,
the<B> WATCOM</B> environment variable should be defined.&nbsp; The<B> WATCOM</B> environment variable is used to locate the
libraries that will be used when the application is linked.&nbsp; The default directory for 16-bit Open Watcom C/C++ and 32-bit
Open Watcom C/C++ files is &quot;\WATCOM&quot;.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set watcom=c:\watcom</TT>
<H2 ID="WCC"> WCC </H2>
<BR>The<B> WCC</B> environment variable can be used to specify commonly-used options for the 16-bit C compiler.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SET WCC=-option1 -option2 ...</TT>
<BR><BR>These options are processed before options specified on the command line.&nbsp; The following example defines the
default options to be &quot;d1&quot; (include line number debug information in the object file) and &quot;ox&quot; (compile
for maximum number of code optimizations).
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set wcc=-d1 -ox</TT>
<BR><BR>Once the<B> WCC</B> environment variable has been defined, those options listed become the default each time the<B><I>
WCC</I></B> command is used.
<H2 ID="WCC386"> WCC386 </H2>
<BR>The<B> WCC386</B> environment variable can be used to specify commonly-used options for the 32-bit C compiler.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SET WCC386=-option1 -option2 ...</TT>
<BR><BR>These options are processed before options specified on the command line.&nbsp; The following example defines the
default options to be &quot;d1&quot; (include line number debug information in the object file) and &quot;ox&quot; (compile
for maximum number of code optimizations).
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set wcc386=-d1 -ox</TT>
<BR><BR>Once the<B> WCC386</B> environment variable has been defined, those options listed become the default each time the<B><I>
WCC386</I></B> command is used.
<H2 ID="WCL"> WCL </H2>
<BR>The<B> WCL</B> environment variable can be used to specify commonly-used WCL options.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SET WCL=-option1 -option2 ...</TT>
<BR><BR>These options are processed before options specified on the command line.&nbsp; The following example defines the
default options to be &quot;mm&quot; (compile code for medium memory model), &quot;d1&quot; (include line number debug information
in the object file), and &quot;ox&quot; (compile for maximum number of code optimizations).
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set wcl=-mm -d1 -ox</TT>
<BR><BR>Once the<B> WCL</B> environment variable has been defined, those options listed become the default each time the WCL
command is used.
<H2 ID="WCL386"> WCL386 </H2>
<BR>The<B> WCL386</B> environment variable can be used to specify commonly-used WCL386 options.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SET WCL386=-option1 -option2 ...</TT>
<BR><BR>These options are processed before options specified on the command line.&nbsp; The following example defines the
default options to be &quot;3s&quot; (compile code for stack-based argument passing convention), &quot;d1&quot; (include line
number debug information in the object file), and &quot;ox&quot; (compile for maximum number of code optimizations).
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set wcl386=-3s -d1 -ox</TT>
<BR><BR>Once the<B> WCL386</B> environment variable has been defined, those options listed become the default each time the
WCL386 command is used.
<H2 ID="WCGMEMORY"> WCGMEMORY </H2>
<BR>The<B> WCGMEMORY</B> environment variable may be used to request a report of the amount of memory used by the compiler's
code generator for its work area.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set WCGMEMORY=?</TT>
<BR><BR>When the memory amount is &quot;?&quot; then the code generator will report how much memory was used to generate the
code.
<BR><BR>It may also be used to instruct the compiler's code generator to allocate a fixed amount of memory for a work area.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set WCGMEMORY=128</TT>
<BR><BR>When the memory amount is &quot;nnn&quot; then exactly &quot;nnnK&quot; bytes will be used.&nbsp; In the above example,
128K bytes is requested.&nbsp; If less than &quot;nnnK&quot; is available then the compiler will quit with a fatal error message.
&nbsp;If more than &quot;nnnK&quot; is available then only &quot;nnnK&quot; will be used.
<BR><BR>There are two reasons why this second feature may be quite useful.&nbsp; In general, the more memory available to
the code generator, the more optimal code it will generate.&nbsp; Thus, for two personal computers with different amounts
of memory, the code generator may produce different (although correct) object code.&nbsp; If you have a software quality assurance
requirement that the same results (i.e., code) be produced on two different machines then you should use this feature.&nbsp;
To generate identical code on two personal computers with different memory configurations, you must ensure that the<B> WCGMEMORY</B>
environment variable is set identically on both machines.
<BR><BR>The second reason where this feature is useful is on virtual memory paging systems (e.g., OS/2) where an unlimited
amount of memory can be used by the code generator.&nbsp; If a very large module is being compiled, it may take a very long
time to compile it.&nbsp; The code generator will continue to allocate more and more memory and cause an excessive amount
of paging.&nbsp; By restricting the amount of memory that the code generator can use, you can reduce the amount of time required
to compile a routine.
<H2 ID="WD"> WD </H2>
<BR>The<B> WD</B> environment variable can be used to specify commonly-used Open Watcom Debugger options.&nbsp; This environment
variable is not used by the Windows version of the debugger, WDW.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SET WD=-option1 -option2 ...</TT>
<BR><BR>These options are processed before options specified on the command line.&nbsp; The following example defines the
default options to be &quot;noinvoke&quot; (do not execute the<TT> profile.dbg</TT> file) and &quot;reg=10&quot; (retain up
to 10 register sets while tracing).
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set wd=-noinvoke -reg#10</TT>
<BR><BR>Once the<B> WD</B> environment variable has been defined, those options listed become the default each time the WD
command is used.
<H2 ID="WDW"> WDW </H2>
<BR>The<B> WDW</B> environment variable can be used to specify commonly-used Open Watcom Debugger options.&nbsp; This environment
variable is used by the Windows version of the debugger, WDW.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SET WDW=-option1 -option2 ...</TT>
<BR><BR>These options are processed before options specified in the WDW prompt dialogue box.&nbsp; The following example defines
the default options to be &quot;noinvoke&quot; (do not execute the<TT> profile.dbg</TT> file) and &quot;reg=10&quot; (retain
up to 10 register sets while tracing).
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set wdw=-noinvoke -reg#10</TT>
<BR><BR>Once the<B> WDW</B> environment variable has been defined, those options listed become the default each time the WDW
command is used.
<H2 ID="WLANG"> WLANG </H2>
<BR>The<B> WLANG</B> environment variable can be used to control which language is used to display diagnostic and program
usage messages by various Open Watcom software tools.&nbsp; The two currently-supported values for this variable are &quot;English&quot;
or &quot;Japanese&quot;.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SET WLANG=English</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SET WLANG=Japanese</TT>
<BR><BR>Alternatively, a numeric value of 0 (for English) or 1 (for Japanese) can be specified.
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set wlang=0</TT>
<BR><BR>By default, Japanese messages are displayed when the current codepage is 932 and English messages are displayed otherwise.
&nbsp;Normally, use of the<B> WLANG</B> environment variable should not be required.
<H2 ID="WPP"> WPP </H2>
<BR>The<B> WPP</B> environment variable can be used to specify commonly-used options for the 16-bit C++ compiler.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SET WPP=-option1 -option2 ...</TT>
<BR><BR>These options are processed before options specified on the command line.&nbsp; The following example defines the
default options to be &quot;d1&quot; (include line number debug information in the object file) and &quot;ox&quot; (compile
for maximum number of code optimizations).
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set wpp=-d1 -ox</TT>
<BR><BR>Once the<B> WPP</B> environment variable has been defined, those options listed become the default each time the<B><I>
WPP</I></B> command is used.
<H2 ID="WPP386"> WPP386 </H2>
<BR>The<B> WPP386</B> environment variable can be used to specify commonly-used options for the 32-bit C++ compiler.
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; SET WPP386=-option1 -option2 ...</TT>
<BR><BR>These options are processed before options specified on the command line.&nbsp; The following example defines the
default options to be &quot;d1&quot; (include line number debug information in the object file) and &quot;ox&quot; (compile
for maximum number of code optimizations).
<BR><BR><B>Example:</B>
<BR><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; C&gt;set wpp386=-d1 -ox</TT>
<BR><BR>Once the<B> WPP386</B> environment variable has been defined, those options listed become the default each time the<B><I>
WPP386</I></B> command is used.
<H1 ID="Open_Watcom_CDCPP_RunMTime_Messages"> Open Watcom C/C++ Run-Time Messages </H1>
<BR>The following is a list of error messages produced by the Open Watcom C/C++ run-time library.&nbsp; These messages can
only appear during the execution of an application built with one of the C run-time libraries.
<H2 ID="RunMTime_Error_Messages"> Run-Time Error Messages </H2>
<DL>
<DT>Assertion failed:&nbsp; %s, file %s, line %d
<DD>
<BR><BR>This message is displayed whenever an assertion that you have made in your program is not true.
<DT>Stack Overflow!
<DD>
<BR><BR>Your program is trying to use more stack space than is available.&nbsp; If you believe that your program is correct,
you can increase the size of the stack by using the &quot;option stack=nnnn&quot; when you link the program.&nbsp; The stack
size can also be specified with the &quot;k&quot; option if you are using WCL or WCL386.
<DT>Floating-point support not loaded
<DD>
<BR><BR>You have called one of the printf functions with a format of &quot;%e&quot;, &quot;%f&quot;, or &quot;%g&quot;, but
have not passed a floating-point value.&nbsp; The compiler generates a reference to the variable &quot;_fltused_&quot; whenever
you pass a floating-point value to a function.&nbsp; During the linking phase, the extra floating-point formatting routines
will also be brought into your application when &quot;_fltused_&quot; is referenced.&nbsp; Otherwise, you only get the non
floating-point formatting routines.
<DT>*** NULL assignment detected
<DD>
<BR><BR>This message is displayed if any of the first 32 bytes of your program's data segment has been modified.&nbsp; The
check is performed just before your program exits to the operating system.&nbsp; All this message means is that sometime during
the execution of your program, this memory was modified.
<BR><BR>To find the problem, you must link your application with debugging information and use Open Watcom Debugger to monitor
its execution.&nbsp; First, run the application with Open Watcom Debugger until it completes.&nbsp; Examine the first 16 bytes
of the data segment (&quot;examine __nullarea&quot;) and press the space bar to see the next 16 bytes.&nbsp; Any values that
are not equal to '01' have been modified.&nbsp; Reload the application, set watch points on the modified locations, and start
execution.&nbsp; Open Watcom Debugger will stop when the specified location(s) change in value.
</DL>
<H2 ID="errno_Values_and_Their_Meanings"> errno Values and Their Meanings </H2>
<BR>The following errors can be generated by the C run-time library.&nbsp; These error codes correspond to the error types
defined in<TT> errno.h.</TT>
<DL>
<DT>ENOENT
<DD><B> No such file or directory</B>
<BR><BR>The specified file or directory cannot be found.&nbsp; 
<DT>E2BIG
<DD><B> Argument list too big</B>
<BR><BR>The argument list passed to the<TT> spawn..., exec...</TT>&nbsp; or<TT> system</TT> functions requires more than 128
bytes, or the environment information exceeds 32K.&nbsp; 
<DT>ENOEXEC
<DD><B> Exec format error</B>
<BR><BR>The executable file has an invalid format.&nbsp; 
<DT>EBADF
<DD><B> Bad file number</B>
<BR><BR>The file handle is not a valid file handle value or it does not correspond to an open file.&nbsp; 
<DT>ENOMEM
<DD><B> Not enough memory</B>
<BR><BR>There was not enough memory available to perform the specified request.&nbsp; 
<DT>EACCES
<DD><B> Permission denied</B>
<BR><BR>You do not have the required (or correct) permissions to access a file.&nbsp; 
<DT>EEXIST
<DD><B> File exists</B>
<BR><BR>An attempt was made to create a file with the O_EXCL (exclusive) flag when the file already exists.&nbsp; 
<DT>EXDEV
<DD><B> Cross-device link</B>
<BR><BR>An attempt was made to rename a file to a different device.&nbsp; 
<DT>EINVAL
<DD><B> Invalid argument</B>
<BR><BR>An invalid value was specified for one of the arguments to a function.&nbsp; 
<DT>ENFILE
<DD><B> File table overflow</B>
<BR><BR>All the FILE structures are in use, so no more files can be opened.&nbsp; 
<DT>EMFILE
<DD><B> Too many open files</B>
<BR><BR>There are no more file handles available, so no more files can be opened.&nbsp; The maximum number of file handles
available is controlled by the &quot;FILES=&quot; option in the &quot;CONFIG.SYS&quot; file.&nbsp; 
<DT>ENOSPC
<DD><B> No space left on device</B>
<BR><BR>No more space is left for writing on the device, which usually means that the disk is full.&nbsp; 
<DT>EDOM
<DD><B> Argument too large</B>
<BR><BR>An argument to a math function is not in the domain of the function.&nbsp; 
<DT>ERANGE
<DD><B> Result too large</B>
<BR><BR>The result of a math function could not be represented (too small, or too large).&nbsp; 
<DT>EDEADLK
<DD><B> Resource deadlock would occur</B>
<BR><BR>A resource deadlock would occur with regards to locked files.
</DL>
<H2 ID="Math_RunMTime_Error_Messages"> Math Run-Time Error Messages </H2>
<BR>The following errors can be generated by the math functions in the C run-time library.&nbsp; These error codes correspond
to the exception types defined in<TT> math.h</TT> and returned by the<TT> matherr</TT> function when a math error occurs.
<DL>
<DT>DOMAIN
<DD><B> Domain error</B>
<BR><BR>An argument to the function is outside the domain of the function.&nbsp; 
<DT>OVERFLOW
<DD><B> Overflow range error</B>
<BR><BR>The function result is too large.&nbsp; 
<DT>PLOSS
<DD><B> Partial loss of significance</B>
<BR><BR>A partial loss of significance occurred.&nbsp; 
<DT>SING
<DD><B> Argument singularity</B>
<BR><BR>An argument to the function has a bad value (e.g., log(0.0)).&nbsp; 
<DT>TLOSS
<DD><B> Total loss of significance</B>
<BR><BR>A total loss of significance occurred.&nbsp; An argument to a function was too large to produce a meaningful result.
&nbsp;
<DT>UNDERFLOW
<DD><B> Underflow range error</B>
<BR><BR>The result is too small to be represented.
</DL>
</BODY>
